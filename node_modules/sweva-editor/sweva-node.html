<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">
<link rel="import" href="../marked-element/marked-element.html">
<link rel="import" href="sweva-node-editor.html">

<!--
`<sweva-node>` is a SWEVA processing node.
-->

<dom-module id="sweva-node">
  <template>
    <style>
      :host {
        display: block;
        width: 100px;
        height: 100px;
        background-color: #0094ff;
        position: absolute;
        left: 50px;
        top: 50px;
        border-radius: 10px;
        cursor: pointer;
        box-sizing: border-box;
        z-index: 5;  /*JSPlumb Z axes*/
        padding: 10px;
      }

      .inner {
        height: 100%;
        width: 100%;
        text-align: center;
        color: #ffffff;
         
        overflow: auto;
        word-break: break-all;
        display: initial;
        font-size: 14px;
         
      }
      .alias {
        outline-color: white;
      }

      :host.selected {
        background-color: #FF4F00;
      }

      .inner .name {
        font-style: italic;
        font-weight: lighter;
        text-decoration: underline;
      }

      .hidden {
        display: none;
      }

      .fixed {
        font-size: 10px;
        text-align: right;
        margin: -15px 6px 0 6px;
      }

      :host.jsplumb-drag {
        outline: none !important;
        box-shadow: 1px 1px 10px#000000 !important;
      }
      paper-tooltip {
        width: 200%!important;
      }
      paper-tooltip.endpoint-tooltip marked-element {
        font-family: monospace !important;
        white-space: pre;
        display: inline-table;
      }

        paper-tooltip.endpoint-tooltip marked-element .markdown-html {
          margin-bottom: -30px;
          margin-top: -15px;
        }

      paper-tooltip {
        --paper-tooltip:

      {
        font-size: 15px !important;
      }

      }
    </style>

    <paper-tooltip>{{description}}</paper-tooltip>
    <paper-tooltip class="endpoint-tooltip">
      <marked-element markdown="{{tooltip}}">
        <div class="markdown-html"></div>
      </marked-element>
    </paper-tooltip>
     
    <div class="inner">
      <div class$="{{isFixedClass(fixed)}}">
      fixed
      </div>
      <div contenteditable="false" spellcheck="false" class="alias">
        {{alias}}
      </div>
      <div class="name">
        {{name}}
      </div>
    </div>
    
  </template>
  <script>
    var MIN_HEIGHT = 100;
    var BASE_HEIGHT = 30;
    var MIN_WIDTH = 100;
    var BASE_WIDTH = 30;
    var ENDPOINT_HEIGHT = 50;
    var ENDPOINT_WIDTH = 50;

    class SwevaNode extends Polymer.Element {
      static get is() {
        return 'sweva-node';
      }

      static get properties() {
        return {
          /* properties meta data object just like 1.x */
          name: {
            type: String,
            value: 'Module1'
          },
          id: {
            type: String
          },
          alias: {
            type: String,
            value: ''
          },
          code: {
            type: String,
            value: ''
          },
          description: {
            type: String,
            value: ''
          },
          tooltip: {
            type: String,
            value: ''
          },
          fixed: {
            type: Boolean,
            valie: false
          },
          posX: {
            type: Number,
            value: 50
          },
          posY: {
            type: Number,
            value: 50
          },
          jsPlumbInstance: {
            type: Object,
            value: null
          },
          jsPlumbStyles: {
            type: Object,
            value: {
            }
          },
          yjs: {
            type: Object,
            value: null
          },
          edges: {
            type: Object,
            value: null
          },
          selectedBy: {
            type: String,
            value: ''
          }
        }
      }

      /**
       * Aarray of observers.
       *
       * @returns {string[]}
       */
      static get observers() {
        return [
          'updatePos(posX, posY)',
          'updateCode(code)',
          'updateAlias(alias)'
        ]
      }

      isFixedClass(fixed) {
        if (fixed) {
          return 'fixed';
        }
        return 'hidden';
      }

      ready() {
        super.ready();

        this._prepareStyles();

        this.addEventListener("mousedown", this._handleMousedown);
        this.addEventListener("dblclick", this._handleDoubleclick);
        //this.addEventListener("click", this._handleClick.bind(this), false);
        this.addEventListener("contextmenu", this._handleContextmenu);
        this.addEventListener("mouseenter", this._handleEnter);
      }

      connectedCallback() {
        super.connectedCallback();
        Polymer.RenderStatus.beforeNextRender(this, function () {
          this.shadowRoot.querySelector('.alias').addEventListener("blur", this._handleAliasChanged.bind(this), false);
        });
      }

      selectBy(userId, color) {
        this.selectedBy = userId;
        this.style.border = '5px solid ' + color;
      }

      unselect() {
        this.selectedBy = '';
        this.style.border = '';
      }

      edit() {
        this.dispatchEvent(new CustomEvent('edit-node', {detail: {id: this.id, alias: this.alias}, bubbles: true, composed: true}));
        //document.getElementById(this.id+'editor').open('Edit Node ' + this.alias);
      }

      handleEditComplete() {}

      addConnection(sourceEndpointId, targetId, targetEndpointId, fromYjs) {
        //this.connectedTo[sourceEndpointId] = { target: targetId, endpoint: targetEndpointId };
        var connectionExists = false;
        var possibleSourceEndpoint = '';
        var possibleTargetEndpoint = '';
        this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
          var targetEndpoint = null;
          var sourceEndpoint = null;
          for (var i = 0; i < connection.endpoints.length; i++) {
            var endpoint = connection.endpoints[i];
            if (endpoint.isSource) {
              sourceEndpoint = endpoint.getUuid();
            }
            else if (endpoint.isTarget) {
              targetEndpoint = endpoint.getUuid();
            }
          }
          if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
            connectionExists = true;
          }
        });
        this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
          if (endpoint.isSource) {
            possibleSourceEndpoint = endpoint.getUuid();
          }
        });
        if (!connectionExists) {
          try {
            if (!sourceEndpointId) {
              this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
                if (endpoint.isSource) {
                  sourceEndpointId = endpoint.getUuid();
                }
              });
            }
            if (!targetEndpointId) {
              this.jsPlumbInstance.selectEndpoints({ target: targetId }).each(function (endpoint) {
                if (endpoint.isTarget) {
                  targetEndpointId = endpoint.getUuid();
                }
              });
            }
            if (sourceEndpointId && targetEndpointId) {
              this.jsPlumbInstance.connect({ uuids: [sourceEndpointId, targetEndpointId], editable: true, deleteEndpointsOnDetach: false });
            }
          } catch (e) {}
        }
        if (sourceEndpointId && targetEndpointId) {
          var self = this;
          if (typeof fromYjs === 'undefined' || fromYjs == false) {
            var map = this.yjs.share.edges.set(sourceEndpointId + targetEndpointId, Y.Map);
            map.set('source', self.id);
            map.set('target', targetId);
            map.set('sourceEndpoint', sourceEndpointId);
            map.set('targetEndpoint', targetEndpointId);
          }
        }
      }

      removeConnection(sourceEndpointId, targetEndpointId, fromYjs) {
        var self = this;
        this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
          var targetEndpoint = null;
          var sourceEndpoint = null;
          for (var i = 0; i < connection.endpoints.length; i++) {
            var endpoint = connection.endpoints[i];
            if (endpoint.isSource) {
              sourceEndpoint = endpoint.getUuid();
            }
            else if (endpoint.isTarget) {
              targetEndpoint = endpoint.getUuid();
            }
          }
          //console.log('weg')
          if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
            self.jsPlumbInstance.detach(connection);
          }
        });
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          this.yjs.share.edges.delete(sourceEndpointId + targetEndpointId);
        }
      }

      clearConnections() {
        var self = this;
        this.jsPlumbInstance.select().each(function (connection) {
          if (connection.sourceId == self.id || connection.targetId == self.id) {
            var targetEndpoint = null;
            var sourceEndpoint = null;
            for (var i = 0; i < connection.endpoints.length; i++) {
              var endpoint = connection.endpoints[i];
              if (endpoint.isSource) {
                sourceEndpoint = endpoint.getUuid();
              }
              else if (endpoint.isTarget) {
                targetEndpoint = endpoint.getUuid();
              }
            }
            if (targetEndpoint && sourceEndpoint) {
              self.removeConnection(sourceEndpoint, targetEndpoint);
            }
          }
        });
      }

      updateConnections() {
        var edges = this.edges;
        if (edges) {
          for (var key in edges) {
            if (edges.hasOwnProperty(key)) {
              var edge = edges[key];
              if (this.id == edge.source) {
                //console.log('target', edge.target);
                this.addConnection(edge.sourceEndpoint, edge.target, edge.targetEndpoint);
              }
            }
          }
        }
      }

      remove(fromYjs) {
        this.clearConnections();
        this.jsPlumbInstance.remove(this);
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          this.yjs.share.nodes.delete(this.id);
        }
      }

      _handleEnter(event) {
        var current = event.target;
        //get correct position if over children
        while (current.parentNode && current.tagName != 'SWEVA-NODE') {
          current = current.parentNode;
        }
        var tooltip = this.shadowRoot.querySelector('.endpoint-tooltip');
        setTimeout(function () {
          tooltip.hide();
        }, 100);
      }

      contextMenu(action){
        if (action == 'edit') {
          this.dispatchEvent(new CustomEvent('editnode', { bubbles: true, composed: true , detail: this }));
        }
        else if (action == 'clone') {
          this.dispatchEvent(new CustomEvent('clonenode', { bubbles: true, composed: true , detail: this }));
        }
        else if (action == 'delete') {
          this.dispatchEvent(new CustomEvent('deletenode', { bubbles: true, composed: true , detail: this }));
        }
      }

      _handleContextmenu(event) {
        var current = event.target;
        //get correct position if over children
        while (current.parentNode && current.tagName != 'SWEVA-NODE') {
          current = current.parentNode;
        }
        var items = [
          { title: 'Edit', fn: current.contextMenu.bind(current, 'edit') },
          { title: 'Clone', fn: current.contextMenu.bind(current, 'clone') },
          {},
          { title: 'Delete', fn: current.contextMenu.bind(current, 'delete') }
        ];
        basicContext.show(items, event);
        event.preventDefault();
      }

      _handleMousedown(event) {
        var current = event.target;
        //get correct position if over children
        while (current.parentNode && current.tagName != 'SWEVA-NODE') {
          current = current.parentNode;
        }
        this.dispatchEvent(new CustomEvent('selected', { bubbles: true, composed: true , detail: this }));
      }

      _handleDoubleclick(event) {
        var current = event.target;
        //get correct position if over children
        while (current.parentNode && current.tagName != 'SWEVA-NODE') {
          current = current.parentNode;
        }
        var aliasField = this.shadowRoot.querySelector('.alias');
        aliasField.contentEditable = 'true';
        aliasField.focus();
        var range = document.createRange();
        var sel = window.getSelection();
        range.selectNodeContents(aliasField);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
      }

      _handleAliasChanged(event) {
        event.target.textContent = event.target.textContent.trim();
        event.target.contentEditable = 'false';
        var alias = event.target.textContent;
        this.updateAlias(alias);
      }

      _prepareStyles() {
        var nodeEndpointHoverStyle = {
          fillStyle: "#00cc00",
          strokeStyle: "#00cc00"
        };
        var nodeDataInEndpoint = {
          endpoint: "Dot",
          paintStyle: {
            strokeStyle: "#0094ff",
            fillStyle: "#ffffff",
            radius: 10,
            lineWidth: 4
          },
          hoverPaintStyle: nodeEndpointHoverStyle,
          maxConnections: 1,
          dropOptions: { hoverClass: "hover", activeClass: "active" },
          isTarget: true
        };
        var nodeInputEndpoint = {
          endpoint: "Rectangle",
          paintStyle: {
            strokeStyle: "#333",
            fillStyle: "#ffffff",
            radius: 10,
            lineWidth: 6
          },
          hoverPaintStyle: nodeEndpointHoverStyle,
          maxConnections: 1,
          dropOptions: { hoverClass: "hover", activeClass: "active" },
          isTarget: true
        };
        var nodeConnectorPaintStyle = {
          lineWidth: 4,
          strokeStyle: "#ff9d00",
          joinstyle: "round",
          outlineColor: "white",
          outlineWidth: 2,
        };
        var nodeConnectorHoverStyle = {
          lineWidth: 4,
          strokeStyle: "#00cc00",
          outlineWidth: 2,
          outlineColor: "#00cc00",
        };
        var nodeDataOutEndpoint = {
          endpoint: "Dot",
          paintStyle: {
            strokeStyle: "#ff9d00",
            fillStyle: "#ff9d00",
            radius: 10,
            lineWidth: 4
          },
          isSource: true,
          connector: ["Bezier"],
          connectorStyle: nodeConnectorPaintStyle,
          hoverPaintStyle: nodeEndpointHoverStyle,
          connectorHoverStyle: nodeConnectorHoverStyle,
          dragOptions: {},
          maxConnections: -1
        };
        this.jsPlumbStyles.nodeInputEndpoint = nodeInputEndpoint;
        this.jsPlumbStyles.nodeDataInEndpoint = nodeDataInEndpoint;
        this.jsPlumbStyles.nodeDataOutEndpoint = nodeDataOutEndpoint;
      }

      _adjustHeight(endpointsX, endpointsY) {
        var height = BASE_HEIGHT + endpointsY * ENDPOINT_HEIGHT;
        var width = BASE_WIDTH + endpointsX * ENDPOINT_WIDTH;
        if (height < MIN_HEIGHT) {
          height = MIN_HEIGHT;
        }
        if (width < MIN_WIDTH) {
          width = MIN_WIDTH;
        }
        this.style.height = height + 'px';
        this.style.width = width + 'px';
      }

      init(jsPlumbInstance, yjs, edges, alias, code, fixed, position, id, fromYjs) {
        this.edges = edges;
        var position = position || { x: 0, y: 0 };
        this.alias = alias || '';
        if (this.alias.trim().length === 0) {
          this.alias = 'Node' + (Math.floor(Math.random() * 300) + '');
        }
        this.id = id || this._generateGUID();
        this.fixed = fixed ? true : false;
        this.posX = position.x;
        this.posY = position.y;
        this.style.left = this.posX + 'px';
        this.style.top = this.posY + 'px';
        //jsPlumbInstance.draggable(this, { grid: [20, 20] });
        //Polymer.dom.flush();
        this.jsPlumbInstance = jsPlumbInstance;
        if (!code) {
          code = '';
          this._addEndpoints(['IN1'], ['OUT1'], ['INPUT1']);
        }
        else {
          var obj;
          try {
            obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(code));
          }
          catch (e) {
            obj = {
              dataInNames: [],
              dataOutNames: [],
              inputNames: []
            }
          }
          this.name = obj.name || 'Node';
          this.description = obj.description || this.name;
          this._addEndpoints(obj.dataInNames, obj.dataOutNames, obj.inputNames, obj.dataInSchema, obj.dataOutSchema, obj.inputSchema);
        }
        this.code = code;
        var self = this;
        self.yjs = yjs;
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          var map = yjs.share.nodes.set(self.id, Y.Map);
          map.set('position', { x: self.posX, y: self.posY });
          map.set('alias', self.alias);
          map.set('code', self.code);
          map.set('fixed', self.fixed);
          var text = map.set('sharedCode' + self.id, Y.Text);
          self.sharedCode = text;
          text.insert(0, code);
          self.dispatchEvent(new CustomEvent('nodecreated', { bubbles: true, composed: true, detail: self }));
          this.updatePos();
        } else {
          var map = self.yjs.share.nodes.get(self.id);
          var text = map.get('sharedCode' + self.id);
          if (text) {
            self.sharedCode = text;
            self.dispatchEvent(new CustomEvent('nodecreated', { bubbles: true, composed: true, detail: self }));
          }
        }
        jsPlumbInstance.draggable(this, {
          stop: function (event) {
            self.updatePos(event.el.offsetLeft, event.el.offsetTop);
          }
        });
      }

      _generateGUID() {
        function s4() {
          return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
          s4() + '-' + s4() + s4() + s4();
      }

      _jsonSchemaToReadable(string) {
        function getSpaces(spaces) {
          var result = '';
          for (var i = 0; i < spaces; i++) {
            result += ' ';
          }
          return result;
        }
        var result = '';
        var lines = string.split(/\r?\n/);
        var ident = '';
        var level = -1;
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i].trim();
          if (line.length > 0) {
            line = line.replace(/"/g, '');
            var identChanged = false;
            if (line.indexOf('{') > -1 || line.indexOf('[') > -1) {
              level++;
              identChanged = true;
            }
            if (line.indexOf('}') > -1 || line.indexOf(']') > -1) {
              level--;
              ident = getSpaces(level * 2);
            }
            line = line.replace(/\{|\[|\]|\,|\}/g, '').trim();
            if (line.length > 0) {
              result += ident + line.replace(/\{|\[|\]|\,|\}/g, '').trim() + '\n';
            }
            if (identChanged) {
              ident = getSpaces(level * 2);
            }
          }
        }
        return result;
      }

      _readableJsonToHtml(string) {
        var regexProperty = new RegExp(/\w+:/);
        var result = '';
        var lines = string.split(/\r?\n/);
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          var match = regexProperty.exec(line);
          if (match != null) {
            if (line.length == match.index + match[0].length) {
              line = line.slice(0, match.index) + '***' + line.slice(match.index, match.index + match[0].length) + '***' + line.slice(match.index + match[0].length);
            }
          }
          result += line.replace(/_/g, '\_') + '\n';
        }
        return result;
      }

      _addEndpoints(dataIn, dataOut,  input, dataInSchema, dataOutSchema, inputSchema) {
        if (typeof dataIn === 'undefined'
          || typeof dataOut === 'undefined'
          || typeof input === 'undefined') {
          return;
        }
        this._adjustHeight(input.length, Math.max(dataIn.length, dataOut.length));
        var nodeId = this.id;
        var self = this;
        this.jsPlumbInstance.selectEndpoints({ source: nodeId }).each(function (endpoint) {
          self.jsPlumbInstance.deleteEndpoint(endpoint);
        });
        this.jsPlumbInstance.selectEndpoints({ target: nodeId }).each(function (endpoint) {
          self.jsPlumbInstance.deleteEndpoint(endpoint);
        });
        this.jsPlumbInstance.batch(function () {
          //dataIn
          var stepSizeIn = (1) / (dataIn.length + 1);
          var schemaInfo = null;
          if (dataInSchema) {
            schemaInfo = dataInSchema.properties;
          }
          for (var i = 0; i < dataIn.length; i++) {
            var labelId = nodeId + dataIn[i] + 'label';
            var endpoint = self.jsPlumbInstance.addEndpoint(self, self.jsPlumbStyles.nodeDataInEndpoint, {
              anchor: [0, stepSizeIn * (i + 1), -1, 0],
              uuid: nodeId + dataIn[i]+'in',
              overlays: [
                ["Label", {
                  location: [0.4, -0.5],
                  label: dataIn[i],
                  cssClass: "node-data-in-endpoint-label node-label"
                }]
              ],
              events: {
                mouseover: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');
                  if (c.tooltip && c.tooltip.length > 0) {
                    self.tooltip = c.tooltip;
                    if (!tooltip._showing) {
                      tooltip.show();
                    }
                  }
                },
                mouseout: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');
                  tooltip.hide();
                }
              }
            });
            endpoint.tooltip = '';
            var jsonString = '{}';
            if (schemaInfo) {
              if (schemaInfo[dataIn[i]]) {
                jsonString = JSON.stringify(schemaInfo[dataIn[i]], null, 2);
              }
              else if (dataOutSchema) {
                jsonString = JSON.stringify(dataInSchema, null, 2);
              }
            }
            else if (dataOutSchema) {
              jsonString = JSON.stringify(dataInSchema, null, 2);
            }
            endpoint.tooltip = self._readableJsonToHtml(self._jsonSchemaToReadable(jsonString));
          }
          //dataOut
          schemaInfo = null;
          if (dataOutSchema) {
            schemaInfo = dataOutSchema.properties;
          }
          var stepSizeOut = (1) / (dataOut.length + 1);
          for (var i = 0; i < dataOut.length; i++) {
            var endpoint = self.jsPlumbInstance.addEndpoint(self, self.jsPlumbStyles.nodeDataOutEndpoint, {
              anchor: [1, stepSizeOut * (i + 1), 1, 0],
              uuid: nodeId + dataOut[i] + 'out',
              overlays: [
                ["Label", {
                  location: [0.6, -0.5],
                  label: dataOut[i],
                  cssClass: "node-data-out-endpoint-label node-label"
                }]
              ],
              events: {
                mouseover: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');

                  if (c.tooltip && c.tooltip.length > 0) {
                    self.tooltip = c.tooltip;
                    if (!tooltip._showing) {
                      tooltip.show();
                    }
                  }
                },
                mouseout: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');
                  tooltip.hide();
                }
              }
            });
            endpoint.tooltip = '';
            var jsonString = '{}';
            if (schemaInfo) {
              if (schemaInfo[dataOut[i]]) {
                jsonString = JSON.stringify(schemaInfo[dataOut[i]], null, 2);
              }
              else if (dataOutSchema) {
                jsonString = JSON.stringify(dataOutSchema, null, 2);
              }
            }
            else  if(dataOutSchema){
              jsonString = JSON.stringify(dataOutSchema, null, 2);
            }
            endpoint.tooltip = self._readableJsonToHtml(self._jsonSchemaToReadable(jsonString));
          }
          //input
          schemaInfo = null;
          if (inputSchema) {
            schemaInfo = inputSchema.properties;
          }
          var stepSizeOut = (1) / (input.length + 1);
          for (var i = 0; i < input.length; i++) {
            var endpoint = self.jsPlumbInstance.addEndpoint(self, self.jsPlumbStyles.nodeInputEndpoint, {
              anchor: [stepSizeOut * (i + 1), 0 , 0, -1],
              uuid: nodeId + input[i] + 'input',
              overlays: [
                ["Label", {
                  location: [0.6, -0.5],
                  label: input[i],
                  cssClass: "node-input-endpoint-label node-label"
                }]
              ],
              events: {
                mouseover: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');
                  if (c.tooltip && c.tooltip.length > 0) {
                    self.tooltip = c.tooltip;
                    if (!tooltip._showing) {
                      tooltip.show();
                    }
                  }
                },
                mouseout: function (c) {
                  var tooltip = self.shadowRoot.querySelector('.endpoint-tooltip');
                  tooltip.hide();
                }
              }
            });
            endpoint.isInput = true;
            endpoint.tooltip = '';
            var jsonString = '{}';
            if (schemaInfo) {
              if (schemaInfo[input[i]]) {
                jsonString = JSON.stringify(schemaInfo[input[i]], null, 2);
              }
              else if (inputSchema) {
                jsonString = JSON.stringify(inputSchema, null, 2);
              }
            }
            else if (inputSchema) {
              jsonString = JSON.stringify(inputSchema, null, 2);
            }
            endpoint.tooltip = self._readableJsonToHtml(self._jsonSchemaToReadable(jsonString));
          }
        });
      }

      toJSON() {
        var obj;
        try {
          obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(this.code));
        }
        catch (e) {
          obj = {}
        }
        return JSON.stringify(obj, null, 4);
      }

      updateCode(code, fromYjs) {
        var oldCode = this.code;
        if (typeof code === 'string') {
          this.code = code;
        }
        if (this.code && this.code.length > 0) {
          if (typeof fromYjs === 'undefined' || fromYjs == false) {
            if (this.yjs) {
              code = this.code;
              var map = this.yjs.share.nodes.get(this.id);
              map.set('code', code);
            }
          }
          var obj;
          try {
            obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(this.code));
          }
          catch (e) {
            obj = {
              name: 'name',
              dataInNames: [],
              dataOutNames: [],
              inputNames: []
            }
          }
          this.name = obj.name;
          this.description = obj.description || this.description;
          if (this.jsPlumbInstance && obj.dataInNames && obj.dataOutNames && obj.inputNames) {
            if (oldCode && oldCode.length > 0) {
              var oldObj;
              try {
                oldObj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(oldCode));
              }
              catch (e) {
                oldObj = {
                  dataInNames: [],
                  dataOutNames: [],
                  inputNames: []
                }
              }
              if (obj.dataInNames.length == oldObj.dataInNames.length
                && obj.dataOutNames.length == oldObj.dataOutNames.length
                && obj.inputNames.length == oldObj.inputNames.length) {
                var same = true;
                for (var i = 0; i < obj.dataInNames.length; i++) {
                  if (obj.dataInNames[i] != oldObj.dataInNames[i]) {
                    same = false;
                  }
                }
                for (var i = 0; i < obj.dataOutNames.length; i++) {
                  if (obj.dataOutNames[i] != oldObj.dataOutNames[i]) {
                    same = false;
                  }
                }
                for (var i = 0; i < obj.inputNames.length; i++) {
                  if (obj.inputNames[i] != oldObj.inputNames[i]) {
                    same = false;
                  }
                }
                if (same) {
                  if (JSON.stringify(obj.dataInSchema) == JSON.stringify(oldObj.dataInSchema)
                    && JSON.stringify(obj.dataOutSchema) == JSON.stringify(oldObj.dataOutSchema)
                    && JSON.stringify(obj.inputSchema) == JSON.stringify(oldObj.inputSchema)) {
                    return;
                  }
                }
              }
            }
            this._addEndpoints(obj.dataInNames, obj.dataOutNames, obj.inputNames, obj.dataInSchema, obj.dataOutSchema, obj.inputSchema);
            this.updateConnections();
          }
        }
      }

      updateAlias(alias) {
        if (typeof alias === 'string') {
          this.alias = alias;
        }
        var self = this;
        this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(500),
          () => {
            if (this.yjs) {
              var self = this;
              var map = this.yjs.share.nodes.get(this.id);
              map.set('alias', self.alias);
            }
          });
      }

      updatePos(x, y, fromYjs) {
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
          if (this.posX == x && this.posY == y) {
            return;
          }
          this.posX = x;
          this.posY = y;
        }
        this.style.left = this.posX + 'px';
        this.style.top = this.posY + 'px';
        this.repaint();
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          if (this.yjs) {
            var self = this;
            var map = this.yjs.share.nodes.get(this.id);
            if (map) {
              map.set('position', { x: self.posX, y: self.posY });
            }
          }
        }
      }

      repaint() {
        try {
          this.jsPlumbInstance.repaint(this, { left: this.posX, top: this.posY });
        }
        catch (e) {}
      }

      animatePos(x, y) {
        var self = this;
        TweenLite.to(self, .3, {
          left: x + 'px', top: y + 'px', ease: Power2.easeInOut,
          onComplete: function () {
            self.updatePos(x,y);
          }
        });
      }
    }

    // Register custom element definition using standard platform API
    window.customElements.define(SwevaNode.is, SwevaNode);
  </script>
</dom-module>