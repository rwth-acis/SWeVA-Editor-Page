<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../bower_components/marked-element/marked-element.html">
<dom-module id="sweva-node">
    <template>
        <style>
            :host {
                display: block;
                width: 100px;
                height: 100px;
                background-color: #0094ff;
                position: absolute;     
                left: 50px;
                top: 50px;
                border-radius: 10px;
                cursor: pointer;
                box-sizing: border-box;
            }

            .inner {
                width: 100%;
                height: 100%;
                text-align: center;
                color: #ffffff;
                padding: 5px;
                word-break: break-all;
                display: initial;
                overflow: hidden;
            }

            :host.selected {
                background-color: #FF4F00;
            }

            .inner .name {
                font-style: italic;
                font-weight: lighter;
                text-decoration: underline;
            }

            .hidden {
                display: none;
            }

            .fixed {
                font-size: 10px;
                text-align: right;
                margin: -15px 6px 0 6px;
            }

            :host.jsplumb-drag {
                outline: none !important;
                box-shadow: 1px 1px 10px#000000 !important;
            }

            paper-tooltip.endpoint-tooltip marked-element {
                font-family: monospace !important;
                white-space: pre;
                display: inline-table;
            }

                paper-tooltip.endpoint-tooltip marked-element .markdown-html {
                    margin-bottom: -30px;
                    margin-top: -15px;
                }

            paper-tooltip {
                --paper-tooltip:

            {
                font-size: 15px !important;
            }

            }
        </style>
        <paper-tooltip>{{description}}</paper-tooltip>
        <paper-tooltip class="endpoint-tooltip">
            <marked-element markdown="{{tooltip}}">
                <div class="markdown-html"></div>
            </marked-element>
        </paper-tooltip>
        <div class="inner">
            <div class$="{{isFixedClass(fixed)}}">
            fixed
            </div>
            <div class="alias">
                {{alias}}
            </div>
            <div class="name">
                {{name}}
            </div>
        </div>
        
    </template>
    <script>
        (function () {
            'use strict';

            var MIN_HEIGHT = 100;
            var BASE_HEIGHT = 30;
            var ENDPOINT_HEIGHT = 50;
            Polymer({
                is: 'sweva-node',
                properties: {
                    name: {
                        type: String,
                        value: 'Module1'
                    },
                    id: {
                        type: String
                    },
                    alias: {
                        type: String,
                        value: 'Node'
                    },
                    code: {
                        type: String,
                        value: ''
                    },
                    description: {
                        type: String,
                        value: ''
                    },
                    tooltip: {
                        type: String,
                        value: 'asdas'
                    },
                    fixed: {
                        type: Boolean,
                        valie: false
                    },
                    posX: {
                        type: Number,
                        value: 50
                    },
                    posY: {
                        type: Number,
                        value: 50
                    },
                    jsPlumbInstance: {
                        type: Object,
                        value: null
                    },
                    jsPlumbStyles: {
                        type: Object,
                        value: {
                        }
                    },
                    yjs: {
                        type: Object,
                        value: null
                    },
                    edges: {
                        type: Object,
                        value: null
                    },
                    selectedBy: {
                        type: String,
                        value: ''
                    }
                },
                observers: [
                    'updatePos(posX, posY)',
                    'updateCode(code)',
                    'updateAlias(alias)'
                ],
                isFixedClass: function (fixed) {
                   
                    if (fixed) {
                        return 'fixed';
                    }
                    
                    return 'hidden';
                },
                ready: function () {
                    this._prepareStyles();

                    this.addEventListener("mousedown", this._handleMousedown.bind(this), false);
                   //this.addEventListener("click", this._handleClick.bind(this), false);
                    this.addEventListener("contextmenu", this._handleContextmenu.bind(this), false);
                    this.addEventListener("mouseenter", this._handleEnter.bind(this), false);
                },
                selectBy: function (userId, color) {
                    this.selectedBy = userId;
                    this.style.border = '5px solid ' + color;
                },
                unselect: function () {
                    this.selectedBy = '';
                    this.style.border = '';
                },
                addConnection: function (sourceEndpointId, targetId, targetEndpointId, fromYjs) {
                   
                    //this.connectedTo[sourceEndpointId] = { target: targetId, endpoint: targetEndpointId };

                    var connectionExists = false;
                    var possibleSourceEndpoint = '';
                    var possibleTargetEndpoint = '';
                    this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
                        var targetEndpoint = null;
                        var sourceEndpoint = null;
                        for (var i = 0; i < connection.endpoints.length; i++) {
                            var endpoint = connection.endpoints[i];
                            if (endpoint.isSource) {
                                sourceEndpoint = endpoint.getUuid();
                            }
                            else if (endpoint.isTarget) {
                                targetEndpoint = endpoint.getUuid();
                            }

                        }

                        if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
                            connectionExists = true;
                        }
                    });

                    this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
                        if (endpoint.isSource) {
                            possibleSourceEndpoint = endpoint.getUuid();
                        }                        
                    });
                    

                    if (!connectionExists) {
                        try {
                            
                            
                            if (!sourceEndpointId) {
                               
                                this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
                                    if (endpoint.isSource) {
                                        sourceEndpointId = endpoint.getUuid();
                                       
                                    }
                                });
                            }
                            if (!targetEndpointId) {
                                this.jsPlumbInstance.selectEndpoints({ target: targetId }).each(function (endpoint) {
                                    if (endpoint.isTarget) {
                                        targetEndpointId = endpoint.getUuid();                                       
                                    }
                                });
                            }
                           
                            
                            if (sourceEndpointId && targetEndpointId) {
                                this.jsPlumbInstance.connect({ uuids: [sourceEndpointId, targetEndpointId], editable: true, deleteEndpointsOnDetach: false });


                                
                            }
                        } catch (e) {

                        }
                        

                    }
                    if (sourceEndpointId && targetEndpointId) {
                        var self = this;
                        if (typeof fromYjs === 'undefined' || fromYjs == false) {

                            this.yjs.share.edges.set(sourceEndpointId + targetEndpointId, Y.Map).then(function (map) {

                                map.set('source', self.id);
                                map.set('target', targetId);
                                map.set('sourceEndpoint', sourceEndpointId);
                                map.set('targetEndpoint', targetEndpointId);

                            });
                        }
                    }
                   
                },
                removeConnection: function (sourceEndpointId, targetEndpointId, fromYjs) {
                    var self = this;
                    this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
                        var targetEndpoint = null;
                        var sourceEndpoint = null;
                        for (var i = 0; i < connection.endpoints.length; i++) {
                            var endpoint = connection.endpoints[i];
                            if (endpoint.isSource) {
                                sourceEndpoint = endpoint.getUuid();
                            }
                            else if (endpoint.isTarget) {
                                targetEndpoint = endpoint.getUuid();
                            }

                        }
                        //console.log('weg')
                        if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
                            
                            self.jsPlumbInstance.detach(connection);
                        }
                    });

                    if (typeof fromYjs === 'undefined' || fromYjs == false) {
                        this.yjs.share.edges.delete(sourceEndpointId + targetEndpointId);
                    }
                },
                clearConnections: function () {
                    var self = this;
                    this.jsPlumbInstance.select().each(function (connection) {
                        if (connection.sourceId == self.id || connection.targetId == self.id) {
                            var targetEndpoint = null;
                            var sourceEndpoint = null;
                            for (var i = 0; i < connection.endpoints.length; i++) {
                                var endpoint = connection.endpoints[i];
                                if (endpoint.isSource) {
                                    sourceEndpoint = endpoint.getUuid();
                                }
                                else if (endpoint.isTarget) {
                                    targetEndpoint = endpoint.getUuid();
                                }

                            }

                            if (targetEndpoint && sourceEndpoint) {
                                self.removeConnection(sourceEndpoint, targetEndpoint);
                            }
                        }
                    });
                },
                updateConnections: function () {
                    var edges = this.edges;
                    if (edges) {
                        for (var key in edges) {
                            if (edges.hasOwnProperty(key)) {
                                var edge = edges[key];
                                if (this.id == edge.source) {
                                    //console.log('target', edge.target);

                                    this.addConnection(edge.sourceEndpoint, edge.target, edge.targetEndpoint);
                                }
                            }

                        }
                    }
                },

                remove: function (fromYjs) {
                    this.clearConnections();
                    this.jsPlumbInstance.remove(this.id);

                    if (typeof fromYjs === 'undefined' || fromYjs == false) {
                        this.yjs.share.nodes.delete(this.id);
                    }

                },
                _handleEnter: function (event) {

                    var current = event.target;
                    //get correct position if over children
                    while (current.parentNode && current.tagName != 'SWEVA-NODE') {
                        current = current.parentNode;
                    }
                    var tooltip = this.querySelector('.endpoint-tooltip');
                    setTimeout(function () {
                        tooltip.hide();
                    }, 100);

                },
                contextMenu: function(action){
                   
                    if (action == 'edit') {
                        this.fire('editnode',this)
                    }
                    else if (action == 'delete') {
                        this.fire('deletenode',this)
                    }
                },
                _handleContextmenu: function (event) {
                   
                    var current = event.target;
                    //get correct position if over children
                    while (current.parentNode && current.tagName != 'SWEVA-NODE') {
                        current = current.parentNode;
                    }

                    

                    var items = [
                        { title: 'Edit', fn: current.contextMenu.bind(current, 'edit') },
                        {},
                        { title: 'Delete', fn: current.contextMenu.bind(current, 'delete') }
                    ];

                    basicContext.show(items, event);
                    event.preventDefault();
                   
                },
                _handleMousedown: function (event) {

                    var current = event.target;
                    //get correct position if over children
                    while (current.parentNode && current.tagName != 'SWEVA-NODE') {
                        current = current.parentNode;
                    }
                   
                    
                   
                    this.fire('selected', this);

                },
                _prepareStyles: function () {
                    var nodeEndpointHoverStyle = {
                        fillStyle: "#00cc00",
                        strokeStyle: "#00cc00"
                    };

                    var nodeDataInEndpoint = {
                        endpoint: "Dot",
                        paintStyle: {
                            strokeStyle: "#0094ff",
                            fillStyle: "#ffffff",
                            radius: 10,
                            lineWidth: 4
                        },
                        hoverPaintStyle: nodeEndpointHoverStyle,
                        maxConnections: 1,
                        dropOptions: { hoverClass: "hover", activeClass: "active" },
                        isTarget: true
                    }
                    var nodeConnectorPaintStyle = {
                        lineWidth: 4,
                        strokeStyle: "#0094ff",
                        joinstyle: "round",
                        outlineColor: "white",
                        outlineWidth: 2,
                        gradient: {
                            stops: [[0, "#ff9d00"], [1, "#0094ff"]]
                        }
                    }
                    var nodeConnectorHoverStyle = {
                        lineWidth: 4,
                        strokeStyle: "#00cc00",
                        outlineWidth: 2,
                        outlineColor: "#00cc00",
                        gradient: {
                            stops: [[0, "#00cc00"], [1, "#00cc00"]]
                        }
                    }
                    var nodeDataOutEndpoint = {
                        endpoint: "Dot",
                        paintStyle: {
                            strokeStyle: "#ff9d00",
                            fillStyle: "#ff9d00",
                            radius: 10,
                            lineWidth: 4
                        },

                        isSource: true,
                        connector: ["Bezier"],
                        connectorStyle: nodeConnectorPaintStyle,
                        hoverPaintStyle: nodeEndpointHoverStyle,
                        connectorHoverStyle: nodeConnectorHoverStyle,
                        dragOptions: {},

                    }
                    this.jsPlumbStyles.nodeDataInEndpoint = nodeDataInEndpoint;
                    this.jsPlumbStyles.nodeDataOutEndpoint = nodeDataOutEndpoint;
                },
                _adjustHeight: function (endpoints) {
                    var height = BASE_HEIGHT + endpoints * ENDPOINT_HEIGHT;
                    if (height < MIN_HEIGHT) {
                        height = MIN_HEIGHT;
                    }
                    this.style.height = height + 'px';
                },

                init: function (jsPlumbInstance, yjs, edges, alias, code, fixed, position, id, fromYjs) {

                    this.edges = edges;
                    var position = position || { x: 0, y: 0 };
                    this.alias = alias || 'Node';
                    this.id = id || this._generateGUID();
                    this.fixed = fixed ? true : false;

                    this.posX = position.x;
                    this.posY = position.y;
                    this.style.left = this.posX + 'px';
                    this.style.top = this.posY + 'px';
                    //jsPlumbInstance.draggable(this, { grid: [20, 20] });
                    Polymer.dom.flush();

                    if (!code) {
                        code = '';
                        this._addEndpoints(jsPlumbInstance, ['IN1'], ['OUT1']);
                    }
                    else {
                        var obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(code));
                        this.name = obj.name || 'Node';
                        this.description = obj.description || this.name;
                        this._addEndpoints(jsPlumbInstance, obj.dataInNames, obj.dataOutNames, obj.dataInSchema, obj.dataOutSchema);
                    }
                    this.code = code;

                    var self = this;
                    self.yjs = yjs;
                    if (typeof fromYjs === 'undefined' || fromYjs == false) {

                        yjs.share.nodes.set(self.id, Y.Map).then(function (map) {

                            map.set('position', { x: self.posX, y: self.posY });
                            map.set('alias', alias);
                            map.set('code', code);
                            map.set('fixed', self.fixed);
                            map.set('sharedCode', Y.Text).then(function (text) {

                                //text.insert(0, code);

                            });

                        });
                        this.updatePos();

                    }
                    this.jsPlumbInstance = jsPlumbInstance;
                    jsPlumbInstance.draggable(this, {
                        stop: function (event) {
                            self.updatePos(event.el.offsetLeft, event.el.offsetTop);
                        }
                    });

                },
                _generateGUID: function () {
                    function s4() {
                        return Math.floor((1 + Math.random()) * 0x10000)
                          .toString(16)
                          .substring(1);
                    }
                    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                      s4() + '-' + s4() + s4() + s4();
                },
                _jsonSchemaToReadable: function (string) {
                    function getSpaces(spaces) {
                        var result = '';
                        for (var i = 0; i < spaces; i++) {
                            result += ' ';
                        }
                        return result;
                    }
                    var result = '';
                    var lines = string.split(/\r?\n/);

                    var ident = '';
                    var level = -1;
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line.length > 0) {
                            line = line.replace(/"/g, '');
                            var identChanged = false;
                            if (line.indexOf('{') > -1 || line.indexOf('[') > -1) {
                                level++;
                                identChanged = true;
                            }
                            if (line.indexOf('}') > -1 || line.indexOf(']') > -1) {
                                level--;
                                ident = getSpaces(level * 2);
                            }
                            line = line.replace(/\{|\[|\]|\,|\}/g, '').trim();
                            if (line.length > 0) {
                                result += ident + line.replace(/\{|\[|\]|\,|\}/g, '').trim() + '\n';
                            }

                            if (identChanged) {
                                ident = getSpaces(level * 2);
                            }
                        }
                    }
                    return result;
                },

                _readableJsonToHtml: function (string) {
                    var regexProperty = new RegExp(/\w+:/);
                    var result = '';

                    var lines = string.split(/\r?\n/);
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];
                        var match = regexProperty.exec(line);
                        if (match != null) {
                            if (line.length == match.index + match[0].length) {
                                line = line.slice(0, match.index) + '***' + line.slice(match.index, match.index + match[0].length) + '***' + line.slice(match.index + match[0].length);
                            }
                        }
                        result += line.replace(/_/g, '\_') + '\n';
                    }

                    return result;
                },

                _addEndpoints: function (jsPlumbInstance, dataIn, dataOut, dataInSchema, dataOutSchema) {

                    this._adjustHeight(Math.max(dataIn.length, dataOut.length));

                    var nodeId = this.id;

                    var self = this;
                    var innerHtml = self.innerHTML;//because jsPlumbInstance.empty kills all children too
                    // jsPlumbInstance.empty(nodeId);
                    // Polymer.dom.flush();
                    //  self.innerHTML = innerHtml;

                    jsPlumbInstance.selectEndpoints({ source: nodeId }).each(function (endpoint) {
                        jsPlumbInstance.deleteEndpoint(endpoint);
                    });
                    jsPlumbInstance.selectEndpoints({ target: nodeId }).each(function (endpoint) {
                        jsPlumbInstance.deleteEndpoint(endpoint);
                    });

                    jsPlumbInstance.batch(function () {

                        var stepSizeIn = (1) / (dataIn.length + 1);
                        var schemaInfo = null;
                        if (dataInSchema) {
                            schemaInfo = dataInSchema.properties;
                        }

                        for (var i = 0; i < dataIn.length; i++) {

                            var labelId = nodeId + dataIn[i] + 'label';
                            var endpoint = jsPlumbInstance.addEndpoint(nodeId, self.jsPlumbStyles.nodeDataInEndpoint, {
                                anchor: [0, stepSizeIn * (i + 1), -1, 0],
                                uuid: nodeId + dataIn[i],
                                overlays: [
                                    ["Label", {
                                        location: [0.4, -0.5],
                                        label: dataIn[i],
                                        cssClass: "node-data-in-endpoint-label node-label"
                                    }]
                                ],
                                events: {
                                    mouseover: function (c) {
                                        var tooltip = self.querySelector('.endpoint-tooltip');

                                        if (c.tooltip && c.tooltip.length > 0) {
                                            self.tooltip = c.tooltip;
                                            if (!tooltip._showing) {
                                                tooltip.show();
                                            }
                                        }

                                    },
                                    mouseout: function (c) {
                                        var tooltip = self.querySelector('.endpoint-tooltip');

                                        tooltip.hide();
                                    }
                                }
                            });
                            endpoint.tooltip = '';
                            var jsonString = '{}';

                            if (schemaInfo) {

                                if (schemaInfo[dataIn[i]]) {
                                    jsonString = JSON.stringify(schemaInfo[dataIn[i]], null, 2);
                                }
                                else if (dataOutSchema) {
                                    jsonString = JSON.stringify(dataInSchema, null, 2);
                                }

                            }
                            else if (dataOutSchema) {
                                jsonString = JSON.stringify(dataInSchema, null, 2);
                            }
                            endpoint.tooltip = self._readableJsonToHtml(self._jsonSchemaToReadable(jsonString));

                        }
                        schemaInfo = null;
                        if (dataOutSchema) {
                            schemaInfo = dataOutSchema.properties;
                        }
                        var stepSizeOut = (1) / (dataOut.length + 1);
                        for (var i = 0; i < dataOut.length; i++) {
                            var endpoint = jsPlumbInstance.addEndpoint(nodeId, self.jsPlumbStyles.nodeDataOutEndpoint, {
                                anchor: [1, stepSizeOut * (i + 1), 1, 0],
                                uuid: nodeId + dataOut[i],
                                overlays: [
                                    ["Label", {
                                        location: [0.6, -0.5],
                                        label: dataOut[i],
                                        cssClass: "node-data-out-endpoint-label node-label"
                                    }]
                                ],
                                events: {
                                    mouseover: function (c) {
                                        var tooltip = self.querySelector('.endpoint-tooltip');

                                        if (c.tooltip && c.tooltip.length > 0) {
                                            self.tooltip = c.tooltip;
                                            if (!tooltip._showing) {
                                                tooltip.show();
                                            }
                                        }

                                    },
                                    mouseout: function (c) {
                                        var tooltip = self.querySelector('.endpoint-tooltip');
                                        tooltip.hide();
                                    }
                                }
                            });
                            endpoint.tooltip = '';
                            var jsonString = '{}';

                            if (schemaInfo) {                               
                                
                                if (schemaInfo[dataOut[i]]) {
                                    jsonString = JSON.stringify(schemaInfo[dataOut[i]], null, 2);
                                }
                                else if (dataOutSchema) {
                                    jsonString = JSON.stringify(dataOutSchema, null, 2);
                                }
                                
                            }
                            else  if(dataOutSchema){                                    
                                jsonString = JSON.stringify(dataOutSchema, null, 2);
                            }
                            endpoint.tooltip = self._readableJsonToHtml(self._jsonSchemaToReadable(jsonString));
                        }
                    });

                },
                toJSON: function () {
                    var obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(this.code));
                    return JSON.stringify(obj, null, 4);
                },
                updateCode: function (code, fromYjs) {
                    var oldCode = this.code;
                    if (typeof code === 'string') {
                        this.code = code;
                    }
                    if (this.code && this.code.length > 0) {

                        if (typeof fromYjs === 'undefined' || fromYjs == false) {
                            if (this.yjs) {
                                code = this.code;
                                this.yjs.share.nodes.get(this.id).then(function (map) {
                                    map.set('code', code);
                                });
                            }
                        }

                        var obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(this.code));
                        this.name = obj.name;

                        if (this.jsPlumbInstance && obj.dataInNames && obj.dataOutNames) {

                            if (oldCode && oldCode.length > 0) {
                                var oldObj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(oldCode));

                                if (obj.dataInNames.length == oldObj.dataInNames.length
                                    && obj.dataOutNames.length == oldObj.dataOutNames.length) {
                                    var same = true;
                                    for (var i = 0; i < obj.dataInNames.length; i++) {
                                        if (obj.dataInNames[i] != oldObj.dataInNames[i]) {
                                            same = false;
                                        }
                                    }
                                    for (var i = 0; i < obj.dataOutNames.length; i++) {
                                        if (obj.dataOutNames[i] != oldObj.dataOutNames[i]) {
                                            same = false;
                                        }
                                    }
                                    if (same) {

                                        return;
                                    }
                                }
                            }
                           
                            this._addEndpoints(this.jsPlumbInstance, obj.dataInNames, obj.dataOutNames, obj.dataInSchema, obj.dataOutSchema);
                            this.updateConnections();
                        }
                    }

                },
                updateAlias: function (alias) {
                    if (typeof alias === 'string') {
                        this.alias = alias;
                    }

                    var self = this;
                    this.debounce('doSomething', function () {

                        if (this.yjs) {
                            var self = this;
                            this.yjs.share.nodes.get(this.id).then(function (map) {

                                map.set('alias', self.alias);

                            });
                        }
                    }, 500);

                },
                updatePos: function (x, y, fromYjs) {
                    if (typeof x !== 'undefined' && typeof y !== 'undefined') {
                        if (this.posX == x && this.posY == y) {
                            return;
                        }
                        this.posX = x;
                        this.posY = y;
                    }

                    this.style.left = this.posX + 'px';
                    this.style.top = this.posY + 'px';
                    if (typeof fromYjs === 'undefined' || fromYjs == false) {
                        if (this.yjs) {
                            var self = this;
                            this.yjs.share.nodes.get(this.id).then(function (map) {

                                map.set('position', { x: self.posX, y: self.posY });

                            });
                        }
                    }
                }

            });
        })();
    </script>
</dom-module>