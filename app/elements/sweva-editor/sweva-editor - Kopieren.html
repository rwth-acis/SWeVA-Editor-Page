<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<dom-module id="sweva-editor">
    <template>
        <style>
            :host {
                display: block;
                height: 100%;
                width: 100%;
            }

            .jtk-demo-main {
                margin-left: 50px;
                display: block;
                height: 500px;
                width: 500px;
                border: 1px solid black;
                overflow: hidden;
            }

            #canvas {
                display: block;
                height: 100%;
                width: 100%;
                border: 1px solid blue;
            }

            [data-shape=Ellipse] {
                width: 210px;
                height: 70px;
                left: 250px;
                top: 250px;
                line-height: 70px;
                /* background-image: url(ellipse.png); */
                background: red;
            }
        </style>
       
        <button on-click="handleLeftClick">left</button>
        <button on-click="handleRightClick">right</button>
        <button on-click="handleZoomInClick">+</button>
        <button on-click="handleZoomOutClick">
            -
        </button>
        <button on-click="handleZoomCenterClick">#</button>
        <span>{{mouse.x}}</span>
        <span> </span>
        <span>{{mouse.y}}</span>
        <div class="jtk-demo-main">
            <!-- demo -->
            <div class="jtk-demo-canvas canvas-wide perimeter-demo jtk-surface jtk-surface-nopan" id="canvas" on-mousemove="handleMouse" on-mousewheel="handleWheel" on-mousedown="handleMouseDown" on-mouseup="handleMouseUp">
                <div style="display:block; width:50px; height: 50px; border:1px solid black; position: absolute; left: 50px; top:50px;"></div>
                <div class="shape jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Rectangle" id="jsPlumb_2_1">Rectangle</div>
                <div class="shape jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Ellipse" id="jsPlumb_2_2">Ellipse</div>
                <div class="shape jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Circle" id="jsPlumb_2_3">Circle</div>
                <div class="shape jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Diamond" id="jsPlumb_2_4">Diamond</div>
                <div class="shape jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Triangle" id="jsPlumb_2_5">Triangle</div>
                <div class="shape _90 jsplumb-draggable jsplumb-endpoint-anchor jsplumb-connected" data-shape="Triangle" data-rotation="90" style="left:60px;top:500px;" id="jsPlumb_2_6">90° rotation</div>
            </div>
            <!-- /demo -->
        </div>
    </template>
    <script src="../../../bower_components/yjs/yjs.js"></script>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <link rel="stylesheet" href="https://jsplumbtoolkit.com/community/demo/perimeterAnchors/app.css">
    <script src="../../../bower_components/jsplumb/dist/js/jsPlumb-2.1.0.js"></script>
    <script>

        (function () {
            'use strict';

            Polymer({
                is: 'sweva-editor',
                properties: {
                    items: {
                        type: Array,
                        notify: true,
                    },
                    offset: {
                        type: Object,
                        value: {
                            left: 0,
                            top: 0,
                            panX: 0,
                            panY: 0
                        }
                    },
                    realOffset: {
                        type: Object,
                        value: {
                            left: 0,
                            top: 0,
                            panX: 0,
                            panY: 0
                        }
                    },
                    transformation: {
                        type: Object,
                        value: {
                            translateX: 0,
                            translateY: 0,
                            originX: 250,
                            originY: 250,
                            scale: 1
                        }
                    },
                    xLast: {
                        value: 0
                    }
                    ,
                    yLast: {
                        value: 0
                    },
                    mouse: {
                        type: Object,

                        value: {
                            x: 1,
                            y: 0
                        }
                    },
                    isPanning: {
                        value: false
                    },
                    panHistory: {
                        value: {}
                    }
                },
                transform: function () {
                    var node = this.querySelector('#canvas');
                    node.style.transformOrigin = this.transformation.originX + 'px' + ' ' + this.transformation.originY + 'px';
                    var transform2d = "matrix(";
                    transform2d += this.transformation.scale.toFixed(1) + ",0,0," + this.transformation.scale.toFixed(1) + "," + this.transformation.translateX.toFixed(1) + "," + this.transformation.translateY.toFixed(1) + ")";

                    node.style.transform = transform2d;//'translatex(' + this.transformation.translateX + 'px) translatey(' + this.transformation.translateY + 'px) scale(' + this.transformation.scale + ')';
                    node.style.left = this.offset.left + 'px';
                    node.style.top = this.offset.top + 'px';
                    /*console.log('realoffsetx ' + this.realOffset.left);
                    console.log('offset ' + this.offset.left);
                    console.log('offsetPan ' + this.offset.panX);
                    console.log(this.transformation);*/
                    this.instance.setZoom(this.transformation.scale);

                },
                handleWheel: function (event) {
                    event.stopPropagation();
                    event.preventDefault();
                   

                    var zoom = event.wheelDelta / 400;
                    var prevScale = this.transformation.scale;
                    this.transformation.originX = this.mouse.x;
                    this.transformation.originY = this.mouse.y;
                    this.transformation.scale = this.transformation.scale + zoom;

                    if (this.transformation.scale < 1) {
                        this.transformation.scale = 1;
                    }
                    else if (this.transformation.scale > 5) {
                        this.transformation.scale = 5;
                    }

                    this.offset.left = this.realOffset.left;
                    this.offset.top = this.realOffset.top;

                    this.transform();

                },
                handleMouseDown: function (event) {
                    if (event.target.id != 'canvas') {
                        return;
                    }
                    this.isPanning = true;
                },
                handleMouseUp: function (event) {
                    if (event.target.id != 'canvas') {
                        return;
                    }
                    this.isPanning = false;
                },
                handleMouse: function (event) {

                    var x = event.offsetX;
                    var y = event.offsetY;
                    var current = event.target;
                    while (current.parentNode && current.id != 'canvas') {
                        //console.log(current);
                        x += current.offsetLeft;
                        y += current.offsetTop;
                        current = current.parentNode;
                    }

                    this.mouse = { x: x, y: y };

                    if (event.buttons == 1 && event.target.id == 'canvas') {

                        this.offset.left += event.movementX;
                        this.offset.top += event.movementY;

                        this.offset.panX = this.offset.left;
                        this.offset.panY = this.offset.top;

                        this.realOffset.left += event.movementX / this.transformation.scale;
                        this.realOffset.top += event.movementY / this.transformation.scale;

                        this.transform();
                    }

                },
                handleLeftClick: function () {
                    //this.transformation.translateX -= 50 * this.transformation.scale;
                    this.offset.left -= 50;
                    this.offset.panX = this.offset.left;
                    this.transform();
                },
                handleRightClick: function () {
                    //this.transformation.translateX += 50 * this.transformation.scale;
                    this.offset.left += 50;
                    this.offset.panX = this.offset.left;

                    this.transform();
                },
                zoom: function (scale) {
                    if (scale < 6 && scale >= 0.25) {

                        // current scale
                        var previousScale = this.transformation.scale;
                        // new scale
                        var newScale = scale;

                        var node = this.querySelector('#canvas');

                        var width = node.offsetWidth;
                        var height = node.offsetHeight;

                        var focusX = width / 2;
                        var focusY = 250;

                        /*

                        var oldLeft = this.offset.left;
                        var newOriginX = (250 - this.offset.left);

                            //newOriginX = (250 - this.offset.left) * (newScale / previousScale);
                        this.offset.left = this.offset.left * (newScale/previousScale);

                        var screen = this.offset.left / (500 * newScale);

                        this.offset.left *= screen;
                        if (this.offset.panX != oldLeft) {
                            newOriginX = this.transformation.originX;
                        }
                        */

                        // scale of the image

                        /*var xImage = 0; // last x location on the image
                        var yImage = 0; // last y location on the image

                        var xScreen = 250;
                        var yScreen = 250;

                        xImage = xImage + ((xScreen - this.xLast) / previousScale);
                        yImage = yImage + ((yScreen - this.yLast) / previousScale);

                        var xNew = (xScreen - xImage) / newScale;
                        var yNew = (yScreen - yImage) / newScale;

                        this.xLast = xScreen;
                        this.yLast = yScreen;

                        this.offset.left = xNew;
                        this.offset.top = yNew;*/
                        var newOffsetX = 250;

                        this.transformation.originX = newOffsetX;
                        this.transformation.originY = 250;
                        this.transformation.scale = newScale;

                        this.transform();
                    }

                },
                handleZoomInClick: function () {
                    var node = this.querySelector('#jsPlumb_2_3');

                    node.style.left = (+(node.style.left.replace('px', '')) + 50) + 'px';
                    this.instance.repaintEverything();
                    
                    //this.zoom(this.transformation.scale * 2);
                },
                handleZoomOutClick: function () {
                   // this.zoom(1);
                },
                handleZoomCenterClick: function () {
                    this.transformation.translateX = 0;
                    this.transformation.translateY = 0;
                    this.transformation.scale = 1;
                    this.offset.left = 0;
                    this.offset.top = 0;
                    this.offset.panX = 0;
                    this.offset.panY = 0;
                    this.realOffset.left = 0;
                    this.realOffset.top = 0;
                    this.transform();
                },
                ready: function () {
                    var self = this;
                    Y({
                        db: {
                            name: 'memory'
                        },
                        connector: {
                            name: 'websockets-client',
                            room: 'swevatest'
                            // debug: true,
                            // url: 'http://127.0.0.1:2345'
                        },
                        sourceDir: 'http://127.0.0.1:8021/SWeVA-Editor-Page/bower_components',
                        share: {
                            piece1: 'Map'
                            
                        }
                    }).then(function (y) {
                        self.yjs = y;
                        y.share.piece1.observe(function () {
                            var position = y.share.piece1.get('position') || {x:100, y:50};
                            var node = self.querySelector('#jsPlumb_2_3');
                            node.style.left = position.x + 'px';
                            node.style.top = position.y + 'px';
                            self.instance.repaintEverything();



                            //.then(function (value) {
                                //var node = self.querySelector('#jsPlumb_2_3');
                                /*
                                node.style.left = value.x + 'px';
                                node.style.top = value.y + 'px';
                                self.instance.repaintEverything();*/
                                
                           // });
                        });
                    })

                },
                attached: function () {

                    var self = this;
                    var rect = self.querySelector('#canvas').getBoundingClientRect();

                    var canvas = self.querySelector('#canvas')
                    canvas.style.position = 'absolute';
                    canvas.style.left = '0';
                    canvas.style.top = '0';

                    // getting the DOM objects (Polymer way of doing document.querySelector('#handle1')  )
                    setTimeout(function () {
                        jsPlumb.ready(function () {

                            var instance = jsPlumb.getInstance({
                                Connector: "StateMachine",
                                PaintStyle: { lineWidth: 3, strokeStyle: "#ffa500", "dashstyle": "2 4" },
                                Endpoint: ["Dot", { radius: 5 }],
                                EndpointStyle: { fillStyle: "#ffa500" },
                                Container: self.querySelector('#canvas')
                            });
                            self.instance = instance;
                            var shapes = jsPlumb.getSelector(".shape");
                            // make everything draggable
                            instance.draggable(shapes, {
                                stop: function (event) {
                                    
                                    self.yjs.share.piece1.set('position', { x: event.el.offsetLeft, y: event.el.offsetTop });
                                }
                            });

                            // suspend drawing and initialise.
                            instance.batch(function () {

                                // loop through them and connect each one to each other one.
                                for (var i = 0; i < shapes.length; i++) {
                                    for (var j = i + 1; j < shapes.length; j++) {
                                        instance.connect({
                                            container: self.querySelector('#canvas'),
                                            source: shapes[i],  // just pass in the current node in the selector for source
                                            target: shapes[j],
                                            // here we supply a different anchor for source and for target, and we get the element's "data-shape"
                                            // attribute to tell us what shape we should use, as well as, optionally, a rotation value.
                                            anchors: [
                                                ["Perimeter", { shape: shapes[i].getAttribute("data-shape"), rotation: shapes[i].getAttribute("data-rotation") }],
                                                ["Perimeter", { shape: shapes[j].getAttribute("data-shape"), rotation: shapes[j].getAttribute("data-rotation") }]
                                            ]
                                        });
                                    }
                                }
                            });
                            jsPlumb.recalculateOffsets("canvas");
                            instance.recalculateOffsets("canvas");
                            //instance.repaint(shapes, {left:-256, top:20});

                            // jsPlumb.repaint(shapes,{left:500, top:20});

                            //jsPlumb.fire("jsPlumbDemoLoaded", instance);
                            canvas.style.position = 'relative';

                            var maxRight = 0;
                            var maxBottom = 0;
                            for (var i = 0; i < canvas.children.length; i++) {

                                var child = canvas.children[i];

                                var right = child.offsetLeft + child.offsetWidth;
                                var bottom = child.offsetTop + child.offsetHeight;
                                if (right > maxRight) {
                                    maxRight = right;
                                }
                                if (bottom > maxBottom) {
                                    maxBottom = bottom;
                                }
                            }
                            console.log(maxRight);
                            canvas.style.width = maxRight + 'px';
                            canvas.style.height = maxBottom + 'px';

                        });
                    }, 100);

                }
            });
        })();
    </script>
</dom-module>