<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="sweva-input-container.html">

<link rel="import" href="../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<dom-module id="sweva-input-mapper">
    <template>
        <style>
            :host {
                width: 500px;
                height: 300px;
                display: flex;
                flex-direction: column;
                position: absolute;
                left: 2000px;
                top: 2000px;
                background-color: #ff6a00;
                border-radius: 10px;
            }

            #header {
                color: #fff;
                text-align: center;
                font-size: 15px;
                padding: 4px;
            }

            #content {
                padding: 25px 15px 20px 15px;
                flex: 1 1 0;
                display: flex;
                flex-direction: row;
            }

            #container {
                flex: 1 1 0;
                display: flex;
                flex-direction: row;
            }

            #content paper-icon-button {
                width: 70px;
                height: 70px;
                margin: 20px;
            }

            #visualization-url {
                --paper-input-container-color: #fff;
                --paper-input-container-input-color: #fff;
                --paper-input-container-focus-color: #111;
                margin: -10px 10px 0 10px;
              
            }

               
        </style>
        <div id="header">
            Input Mapping
            <paper-icon-button style="float: right;
                                        height: 20px;
                                        padding: 2px;"
                               title="Minimize"
                               icon="icons:check-box-outline-blank"
                               on-click="handleMinimize">
            </paper-icon-button>
        </div>
        <paper-input id="visualization-url" label="Visualization Tool" value="{{visualizationUrl}}" on-change="handleVisualizationChanged"></paper-input>
        <div id="content">

            <div id="container">
            </div>

            <template is="dom-if" if="{{showAdd}}">
                <paper-icon-button title="Add"
                                   icon="icons:add-circle-outline"
                                   on-click="handleAdd">
                </paper-icon-button>
            </template>
        </div>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'sweva-input-mapper',
                properties: {
                    posX: {
                        type: Number,
                        value: 50
                    },
                    posY: {
                        type: Number,
                        value: 50
                    },
                    yjs: {
                        type: Object,
                        value: null
                    },
                    jsPlumbInstance: {
                        type: Object,
                        value: null
                    },
                    showAdd: {
                        type: Boolean,
                        value: true
                    },
                    edges: {
                        type: Object,
                        value: null
                    },
                    visualizationUrl: {
                        type: String,
                        value: ''
                    }
                },
                ready: function () {

                },
                attached: function () {

                },
                add: function (options, fromYjs) {

                    var parent = this.$.container;
                    var inputContainer = document.createElement('sweva-input-container');

                    var inserted = false;
                    if (typeof options === 'object') {
                        //if index given
                        if (typeof options.index === 'number') {

                            var children = Polymer.dom(parent).children;
                            var previousIndex = 0;
                            for (var i = 0; i < children.length; i++) {
                                var element = children[i];
                                if (element.index == options.index) {
                                    var nextSibling = Polymer.dom(element).nextSibling;
                                    if (nextSibling) {
                                        inserted = true;
                                        inputContainer.index = element.index + (nextSibling.index - element.index) / 2.0;

                                        Polymer.dom(parent).appendChild(inputContainer);
                                    }
                                }

                                /*if (element.index > options.index) {
                                    inserted = true;
                                    console.log(previousIndex, element.index, options.index)

                                    inputContainer.index = previousIndex+(element.index - previousIndex) / 2.0;

                                    Polymer.dom(parent).appendChild(inputContainer);
                                }
                                previousIndex = element.index;*/
                            }

                        }
                    }

                    if (!inserted) {

                        var children = Polymer.dom(parent).children;
                        var highestIndex = 0;
                        for (var i = 0; i < children.length; i++) {
                            var element = children[i];
                            if (highestIndex < element.index) {
                                highestIndex = element.index;
                            }
                        }
                        inputContainer.index = highestIndex + 1;
                        Polymer.dom(parent).appendChild(inputContainer);
                    }

                    this.updateDOM();

                    if (typeof options === 'object') {
                        inputContainer.init(this.jsPlumbInstance, this.yjs, this.edges, options.id, fromYjs);
                    }
                    else {
                        inputContainer.init(this.jsPlumbInstance, this.yjs, this.edges, null, fromYjs);
                    }

                    inputContainer.addEventListener('moveleft', this.handleContainerMoveLeft.bind(this), false);
                    inputContainer.addEventListener('moveright', this.handleContainerMoveRight.bind(this), false);
                    inputContainer.addEventListener('close', this.handleContainerClose.bind(this), false);
                    inputContainer.addEventListener('add', this.handleContainerAdd.bind(this), false);
                    inputContainer.addEventListener('minimized', this.updateWidth.bind(this), false);
                    inputContainer.addEventListener('indexchangedyjs', this.updateDOM.bind(this), false);

                    if (typeof options === 'object') {
                        if (typeof options.index === 'number') {
                            delete options.index;
                        }
                        inputContainer.update(options);
                    }
                    if (this.showAdd) {
                        this.showAdd = false;
                        var self = this;
                        setTimeout(function () {
                            self.jsPlumbInstance.repaintEverything();
                        }, 100);

                    }

                    return inputContainer;
                },
                updateDOM: function () {
                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    var copy = [];

                    for (var i = 0; i < children.length; i++) {
                        var element = children[i];
                        copy.push(element);
                        Polymer.dom(parent).removeChild(element);
                    }

                    copy.sort(function (a, b) { return a.index - b.index; });
                    //console.log(children);
                    for (var i = 0; i < copy.length; i++) {
                        var element = copy[i];
                        Polymer.dom(parent).appendChild(element);
                    }

                    Polymer.dom.flush();
                    this.updateWidth();
                },
                init: function (jsPlumb, yjs, edges) {
                    this.edges = edges;
                    this.yjs = yjs;
                    this.jsPlumbInstance = jsPlumb;

                    var self = this;
                    this.jsPlumbInstance.draggable(this, {
                        start: function (event) {
                            if (event.el && event.el.offsetLeft) {
                                self.updatePos(event.el.offsetLeft, event.el.offsetTop);
                                //self.jsPlumbInstance.recalculateOffsets(event.el);
                                self.jsPlumbInstance.repaint(event.el);
                            }

                        },

                        stop: function (event) {
                            if (event.el && event.el.offsetLeft) {
                                self.updatePos(event.el.offsetLeft, event.el.offsetTop);
                            }

                        }

                    });
                    this.updateWidth();

                    this.yjs.share.mapper.observe(function (events) {
                        var position = self.yjs.share.mapper.get('position');

                        if (position != null) {
                            self.updatePos(position.x, position.y, true);
                            self.jsPlumbInstance.repaintEverything();
                        }

                    });

                   
                    this.yjs.share.mapperVisualization.observe(function (events) {
                        var url = self.yjs.share.mapperVisualization.get('url');
                        if (url != null && self.visualizationUrl != url) {
                            self.visualizationUrl = url;
                        }
                    });

                    this.yjs.share.mapperContainers.observe(function (events) {
                        for (var i = 0; i < events.length; i++) {
                            var event = events[i];
                            (function (event) {
                                if (event.type === 'add') {
                                    try {
                                        self.yjs.share.mapperContainers.get(event.name).then(function (map) {

                                            var index = map.get('index') || '';
                                            var type = map.get('type') || '';
                                            var label = map.get('label') || '';
                                            var stringvalue = map.get('stringvalue') || '';
                                            var numbervalue = map.get('numbervalue') || '';
                                            var booleanvalue = map.get('booleanvalue') || '';
                                            var min = map.get('min') || '';
                                            var max = map.get('max') || '';
                                            var items = map.get('items') || '';
                                            var description = map.get('description') || '';
                                            var container = document.getElementById(event.name);

                                            if (!container) {

                                                container = self.add({
                                                    id: event.name,
                                                    type: type,
                                                    index: index,
                                                    label: label,
                                                    stringvalue: stringvalue,
                                                    numbervalue: numbervalue,
                                                    booleanvalue: booleanvalue,
                                                    min: min,
                                                    max: max,
                                                    items: items,
                                                    description: description
                                                }, true);

                                            }

                                            var nodes = self.querySelectorAll('sweva-input-container');

                                            for (var k = 0; k < nodes.length; k++) {
                                                nodes[k].updateConnections();
                                            }

                                            nodes = self.querySelectorAll('sweva-node');
                                            for (var k = 0; k < nodes.length; k++) {
                                                nodes[k].updateConnections();
                                            }
                                            self.jsPlumbInstance.repaintEverything();
                                            map.observe(function (events2) {

                                                for (var k = 0; k < events2.length; k++) {
                                                    var event2 = events2[k];
                                                    (function (event2) {
                                                        if (event2.type !== 'delete') {
                                                            var property = event2.name;
                                                            var value = event2.object.contents[property];
                                                            var container = document.getElementById(event.name);

                                                            if (container) {
                                                                var options = {};
                                                                options[property] = value;
                                                                container.update(options, true);
                                                            }
                                                        }
                                                    })(event2);
                                                }

                                            });

                                        });
                                    }
                                    catch (e) {

                                    }
                                }

                                else if (event.type === 'delete') {
                                    var node = document.getElementById(event.name);
                                    if (node) {
                                        self.remove(node, true);
                                    }

                                }
                            })(event);
                        }
                    });

                },
                handleVisualizationChanged: function(event){
                    this.yjs.share.mapperVisualization.set('url', this.visualizationUrl);
                },
                setVisualization: function (visualization) {
                    this.visualizationUrl = visualization;
                    this.handleVisualizationChanged();
                },
                getInformation: function () {
                    var result = [{
                        label: 'Section1',
                        controls: []
                    }];
                    var currentSection = 0;
                    var firstHeaderSeen = false;
                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    for (var i = 0; i < children.length; i++) {
                        var container = children[i].getInformation();
                        if (typeof container === 'object' && Object.keys(container).length > 0) {
                            if (container.type == 'header') {
                                if (!firstHeaderSeen) {
                                    result[currentSection].label = container.label;
                                    firstHeaderSeen = true;
                                }
                                else {
                                    currentSection++;
                                    result.push({
                                        label: container.label,
                                        controls: []
                                    });
                                }
                            }
                            else {
                                result[currentSection].controls.push(container);
                            }
                        }

                    }
                    var visualization = this.visualizationUrl;
                    return { visualization: visualization, sections: result };
                },
                handleAdd: function () {
                    this.add();
                },
                moveContainer: function (element, direction) {

                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    for (var i = 0; i < children.length; i++) {
                        var container = children[i];
                        if (container.id == element.id) {
                            if (direction == 'left') {
                                if (i <= 0) {
                                    return; //ignore leftmost tem
                                }
                                var temp = children[i].index;
                                children[i].updateIndex(children[i - 1].index);
                                children[i - 1].updateIndex(temp);

                            }
                            else {
                                if (i == children.length - 1) {
                                    return; //ignore rightmost tem
                                }
                                var temp = children[i].index;
                                children[i].updateIndex(children[i + 1].index);
                                children[i + 1].updateIndex(temp);
                            }
                            this.updateDOM();
                            break;
                        }
                    }

                },
                clear: function () {
                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    for (var i = 0; i < children.length; i++) {
                        var container = children[i];
                        this.remove(container);
                    }
                },
                remove: function (element, fromYjs) {
                    var parent = this.$.container;

                    element.clear();
                    Polymer.dom(parent).removeChild(element);
                    if (typeof element === 'undefined' || !fromYjs) {
                        this.yjs.share.mapperContainers.delete(element.id);
                    }
                    this.updateDOM();

                    if (Polymer.dom(parent).children.length <= 0) {
                        this.showAdd = true;
                    }

                },
                handleMinimize: function () {

                    var allMinimized = true;

                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    for (var i = 0; i < children.length; i++) {
                        var container = children[i];
                        if (!container.minimized) {
                            allMinimized = false;
                            break;
                        }
                    }

                    for (var i = 0; i < children.length; i++) {
                        var container = children[i];

                        container.minimize(!allMinimized);
                    }
                    this.updateWidth();
                },
                handleContainerMoveLeft: function (event) {
                    this.moveContainer(event.detail, 'left');
                },
                handleContainerMoveRight: function (event) {
                    this.moveContainer(event.detail, 'right');
                },
                handleContainerClose: function (event) {
                    this.remove(event.detail);

                },
                handleContainerAdd: function (event) {
                    var element = event.detail;

                    this.add({ index: element.index });

                },
                updateWidth: function () {

                    var containerWidth = 50;

                    var parent = this.$.container;
                    var children = Polymer.dom(parent).children;

                    if (children.length > 0) {

                        var width = 0;
                        for (var i = 0; i < children.length; i++) {
                            if (children[i].minimized) {
                                width += children[i].minimizedWidth;
                            }
                            else {

                                width += children[i].width;
                            }
                        }
                        if (width < 150) {
                            width = 150;
                        }
                        this.style.width = width + 'px';
                    }
                    else {
                        this.style.width = (150) + 'px';
                    }

                    this.jsPlumbInstance.repaintEverything();
                },
                updatePos: function (x, y, fromYjs) {
                    if (typeof x !== 'undefined' && typeof y !== 'undefined') {
                        if (this.posX == x && this.posY == y) {
                            return;
                        }
                        this.posX = x;
                        this.posY = y;
                    }

                    this.style.left = this.posX + 'px';
                    this.style.top = this.posY + 'px';

                    if (typeof fromYjs === 'undefined' || fromYjs == false) {
                        if (this.yjs) {
                            var self = this;
                            this.yjs.share.mapper.set('position', { x: self.posX, y: self.posY });
                        }
                    }

                }

            });
        })();
    </script>
</dom-module>