<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="stylesheet" href="../../bower_components/basicContext/dist/basicContext.min.css">
<link rel="stylesheet" href="../../bower_components/basicContext/dist/themes/default.min.css">

<link rel="import" href="sweva-code.html">
<script src="../../bower_components/basicContext/dist/basicContext.min.js"></script>

<dom-module id="sweva-node-manager">
    <template>
        <style>
            :host {
                display: block;
            }
        </style>
        <div id="node-canvas">
            <content>
            </content>            
        </div>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'sweva-node-manager',
                properties: {
                    jsPlumbInstance: {
                        type: Object,
                        value: null
                    },
                    yjs: {
                        type: Object,
                        value: null
                    },
                    edges: {
                        type: Object,
                        value: {}
                    },
                    lastDraggedConnection: {
                        type: Object,
                        value: {}
                    },
                    viewPort: {
                        type: Object,
                        value: { left: 0, top: 0, right: 1000, bottom: 1000 }
                    },
                    canvasOffset: {
                        type: Object,
                        value: {
                            x: -2000,
                            y: -2000
                        }
                    },
                    repositoryAddress: {
                        type: String,
                        value: ''
                    },
                    repositorySuffix: {
                        type: String,
                        value: ''
                    },
                    selectedNode: {
                        type: Object,
                        value: null
                    }

                },
                handleNodeSelected: function (event) {

                    this.selectedNode = event.detail;
                    var nodes = document.getElementById('canvas').querySelectorAll('sweva-node');

                    for (var i = 0; i < nodes.length; i++) {
                        // nodes[i].toggleClass('selected', nodes[i].id == this.selectedNode.id);

                        if (nodes[i].id == this.selectedNode.id) {
                            nodes[i].style.backgroundColor = '#FF4F00';
                        }
                        else if (nodes[i].style.backgroundColor) {
                            nodes[i].style.backgroundColor = '';
                        }
                    }

                    this.fire('nodeselected', event.detail);
                },
                
                selectNodeBy: function(nodeId, userId, color){
                    var nodes = document.getElementById('canvas').querySelectorAll('sweva-node');
                    for (var i = 0; i < nodes.length; i++) {
                        if (nodes[i].id == nodeId) {
                            nodes[i].selectBy(userId, color);
                        }
                        else 
                        if (nodes[i].selectedBy == userId) {
                            nodes[i].unselect();
                        }
                    }
                },
                getDefaultInputData: function() {
                    var graph = this.getGraphData();
                    var nodesWithIncomingConnection = {};
                    var data = {};
                    var input = {};
                    for (var i = 0; i < graph.edges.length; i++) {
                        var edge = graph.edges[i];
                        nodesWithIncomingConnection[edge.to] = true;
                    }

                    for (var i = 0; i < graph.nodes.length; i++) {
                        var node = JSON.parse(sweva.ComposableLoader.convertCodeToJson(graph.nodes[i].code));
                        if (!nodesWithIncomingConnection.hasOwnProperty(graph.nodes[i].id) && node.dataInNames) {
                            data[graph.nodes[i].alias] = {};
                            for (var k = 0; k < node.dataInNames.length; k++) {
                                data[graph.nodes[i].alias][node.dataInNames[k]] = 42;//just some value
                            }
                        }
                        
                        if (node.inputNames) {
                            input[graph.nodes[i].alias] = {};
                            for (var k = 0; k < node.inputNames.length; k++) {
                                input[graph.nodes[i].alias][node.inputNames[k]] = 42;//just some value
                            }
                        }
                    }
                    return { data: data, input: input };
                },
                getComposition: function (code) {
                    var graph = this.getGraphData();
                    
                    var composition = {};
                    composition.composables = {};
                    var nodesWithConnections = [];
                    var nodeDictionary = {};
                    var morethanOneNode = graph.nodes.length>1;
                    for (var i = 0; i < graph.nodes.length; i++) {
                        nodeDictionary[graph.nodes[i].id] = graph.nodes[i];
                        if (composition.composables.hasOwnProperty(graph.nodes[i].alias)) {
                            alert('There are multiple nodes with the same alias: ' + graph.nodes[i].alias);
                            return null;
                        }

                        if (graph.nodes[i].fixed) {
                            composition.composables[graph.nodes[i].alias] = graph.nodes[i].name;
                        }
                        else {
                            composition.composables[graph.nodes[i].alias] = JSON.parse(sweva.ComposableLoader.convertCodeToJson(graph.nodes[i].code));
                        }
                    }

                    composition.links = {};
                    for (var i = 0; i < graph.edges.length; i++) {
                        var edge = graph.edges[i];
                        var alias = nodeDictionary[edge.from].alias;
                        if (!composition.links.hasOwnProperty(alias)) {
                            composition.links[alias] = [];
                        }
                       
                        var to = nodeDictionary[edge.to].alias;
                        var mapping = {};
                        mapping[edge.fromEndpoint] = edge.toEndpoint;
                        var toMap = {
                            to: to,
                            mapping: mapping
                        };
                        nodesWithConnections[alias] = true;
                        nodesWithConnections[to] = true;
                        composition.links[alias].push(toMap);
                    }

                    for (var key in composition.composables) {
                       
                        if (composition.composables.hasOwnProperty(key)) {
                            if (typeof nodesWithConnections[key]==='undefined') {
                                
                                delete composition.composables[key];
                            }
                        }
                    }

                    var obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(code));

                    obj.composables = composition.composables;
                    obj.links = composition.links;
                    
                    return obj;
                },
                updateViewport: function (viewPort) {
                    this.viewPort = viewPort;
                },
                getGraphData: function () {
                    var nodes = document.getElementById('canvas').querySelectorAll('sweva-node');
                    var edges = [];

                    this.jsPlumbInstance.select().each(function (connection) {
                        var edge = {};
                        edge.from = connection.sourceId;
                        edge.to = connection.targetId;

                        if (connection.endpoints.length != 2) {
                            return;
                        }

                        var labels = connection.endpoints[0].getOverlays();
                        for (var key in labels) {
                            if (labels.hasOwnProperty(key)) {
                                edge.fromEndpoint = labels[key].label;
                            }
                        }

                        labels = connection.endpoints[1].getOverlays();
                        for (var key in labels) {
                            if (labels.hasOwnProperty(key)) {
                                edge.toEndpoint = labels[key].label;
                            }
                        }
                        edges.push(edge);
                    });

                    return { nodes: nodes, edges: edges };
                },
                autoLayout: function () {
                    var graph = this.getGraphData();
                    var g = new dagre.graphlib.Graph();
                    g.setGraph({});
                    g.setDefaultEdgeLabel(function () { return {}; });
                    var nodeDictionary = {};
                    for (var i = 0; i < graph.nodes.length; i++) {
                        nodeDictionary[graph.nodes[i].id] = i;
                        g.setNode(i, { width: graph.nodes[i].offsetWidth, height: graph.nodes[i].offsetHeight });
                    }

                    for (var i = 0; i < graph.edges.length; i++) {
                        g.setEdge(nodeDictionary[graph.edges[i].from], nodeDictionary[graph.edges[i].to]);
                    }

                    g.setGraph({ rankdir: 'LR', nodesep: 80, ranksep: 200 })
                    dagre.layout(g);

                    var canvasOffset = this.canvasOffset;

                    g.nodes().forEach(function (v) {
                        if (typeof v !== 'undefined' && v !== 'undefined') {

                            var node = g.node(v);
                            var realNode = graph.nodes[v];

                            realNode.posX = -canvasOffset.x + node.x;
                            realNode.posY = -canvasOffset.y + node.y;
                            realNode.updatePos();

                        }
                    });

                    this.jsPlumbInstance.repaintEverything();
                },
                deleteNode: function (node) {                   
                    if (node && node.remove) {
                        node.remove();
                       
                    }
                },
                clear: function(){
                    var nodes = document.getElementById('canvas').querySelectorAll('sweva-node');
                    for (var i = 0; i < nodes.length; i++) {
                        nodes[i].remove();
                    }
                },
                importNodeJson: function (alias, content) {
                    var json = JSON.parse(content);
                    var code = sweva.ComposableLoader.convertJsonToCode(json);
                    
                    this.createNode({ alias: alias, code: code });
                },
                importNodeObject: function (alias, content) {
                    this.createNode({alias: alias, code: content});
                },
                importCompositionJSON: function(content){
                    var obj = JSON.parse(content);
                    var nodeDictionary = {};
                    var promises = [];
                    if (obj.composables) {
                        for (var key in obj.composables) {
                            if (obj.composables.hasOwnProperty(key)) {
                                var composable = obj.composables[key];
                                var node;
                                if (typeof composable === 'string') {
                                    promises.push(this.createNode({ alias: key, url: composable, fixed: true}));
                                }
                                else {
                                    promises.push(this.createNode({ alias: key, code: sweva.ComposableLoader.convertJsonToCode(composable)}));
                                }
                               
                            }
                        }
                    }

                    var autoLayout = this.autoLayout.bind(this);
                    Promise.all(promises).then(function (result) {
                        for (var i = 0; i < result.length; i++) {
                            var node = result[i];
                            nodeDictionary[result[i].alias] = result[i];
                        }

                        if (obj.links) {
                            for (var key in obj.links) {
                                if (obj.links.hasOwnProperty(key)) {
                                    var links = obj.links[key];
                                    var from = key;

                                    for (var i = 0; i < links.length; i++) {
                                        var link = links[i];

                                        var to = link.to;
                                        var fromEndpoint = '';
                                        var toEndpoint = '';
                                        if (link.hasOwnProperty('mapping')) {
                                            if (typeof link.mapping === 'string') {
                                                fromEndpoint = '';
                                                toEndpoint = link.mapping;
                                            }
                                            else {
                                                var oKeys = Object.keys(link.mapping);
                                                for (var k = 0; k < oKeys.length; k++) {
                                                    fromEndpoint = oKeys[k];
                                                    toEndpoint = link.mapping[oKeys[k]];
                                                }
                                            }
                                        }
                                        else {
                                            fromEndpoint = '';
                                            toEndpoint = '';
                                        }
                                        //console.log(from, fromEndpoint, to, toEndpoint);
                                        if (nodeDictionary[from] && nodeDictionary[to]) {
                                            if (fromEndpoint) {
                                                fromEndpoint = nodeDictionary[from].id + fromEndpoint;
                                            }
                                            if (toEndpoint) {
                                                toEndpoint = nodeDictionary[to].id + toEndpoint;
                                            }
                                            nodeDictionary[from].addConnection(fromEndpoint, nodeDictionary[to].id, toEndpoint);
                                        }
                                    }
                                    
                                }
                            }
                        }

                        autoLayout();
                    });
                   
                    
                   

                },
                createNode: function (options) {

                    var self = this;
                    var node = document.createElement('sweva-node');
                    
                    Polymer.dom(this).appendChild(node);
                    
                    var func = function (resolve, reject) {
                            var self = this;
                            
                            var center = {};
                            center.x = self.viewPort.left + (self.viewPort.right - self.viewPort.left) / 2;
                            center.y = self.viewPort.top + (self.viewPort.bottom - self.viewPort.top) / 2;

                            var x = options.x || center.x;
                            var y = options.y || center.y;
                            var fixed = options.fixed ? true : false;

                            var alias = options.alias || 'Node';
                            var code = options.code || sweva.ComposableLoader.getDefaultModule();

                            if (options.url) {
                                var url = options.url;
                                //if not full url specified, add the required rest
                                if (url.indexOf('://') == -1) {
                                    url = self.repositoryAddress + url + self.repositorySuffix;
                                }

                                var self = self;
                                axios.get(url).then(function (response) {

                                    var code = sweva.ComposableLoader.convertJsonToCode(response.data);

                                    node.init(self.jsPlumbInstance, self.yjs, self.edges, alias, code, fixed, { x: x, y: y });
                                    node.addEventListener('selected', self.handleNodeSelected);
                                    resolve(node);
                                })
                            }
                            else {
                                node.init(self.jsPlumbInstance, self.yjs, self.edges, options.alias, code, fixed, { x: x, y: y });
                                node.addEventListener('selected', self.handleNodeSelected);
                                resolve(node);
                            }
                        
                    }
                    
                    var promise = func.bind(this);
                    return new Promise(function (resolve, reject) {
                        promise(resolve, reject);
                    });
                },
                yjsCreateNode: function (nodeData) {
                    var node = document.createElement('sweva-node');
                    Polymer.dom(this).appendChild(node);

                    node.init(this.jsPlumbInstance, this.yjs, this.edges, nodeData.alias, nodeData.code, nodeData.fixed, { x: nodeData.x, y: nodeData.y }, nodeData.id, true);
                    node.addEventListener('selected', this.handleNodeSelected);
                   
                    return node;
                },
                init: function (yjs) {
                    this.yjs = yjs;
                    var self = this;
                    yjs.share.nodes.observe(function (events) {

                        for (var i = 0; i < events.length; i++) {
                            var event = events[i];
                            (function (event) {
                                //console.log('event', event.name, event.type);

                                if (event.type === 'add') {
                                    try {
                                        yjs.share.nodes.get(event.name).then(function (map) {

                                            var position = map.get('position') || { x: 0, y: 0 };
                                            var alias = map.get('alias')||'node';
                                            var code = map.get('code') || '';
                                            var fixed = map.get('fixed')?true:false;
                                            //var code = codeObj.toString();
                                            //console.log(code);
                                           
                                           
                                                var node = document.getElementById(event.name);
                                                
                                                if (!node) {
                                                    node = self.yjsCreateNode({ id: event.name, alias: alias, code: code, fixed:fixed, x: position.x, y: position.y });
                                                    
                                                   
                                                }
                                                var nodes = self.querySelectorAll('sweva-node');

                                                for (var k = 0; k < nodes.length; k++) {
                                                    nodes[k].updateConnections();
                                                }
                                                self.jsPlumbInstance.repaintEverything();
                                                
                                               
                                                map.observe(function (events2) {

                                                    var position = map.get('position');
                                                    var alias = map.get('alias');
                                                    var code = map.get('code');
                                                    var fixed = map.get('fixed');
                                                    if (position != null && code != null && alias != null) {//prevent randomly inserting nodes at 0 0
                                                        
                                                        var node = document.getElementById(event.name);

                                                        if (!node) {
                                                            return;
                                                        }
                                                        //node.jsPlumbInstance = self.jsPlumbInstance;
                                                        if (node.alias != alias) {
                                                            node.alias = alias;
                                                        }
                                                        if (node.code != code) {
                                                            node.updateCode(code, true);
                                                        }
                                                        if (typeof fixed !== 'undefined' && node.fixed != fixed) {
                                                            node.fixed = fixed;
                                                        }
                                                       
                                                        if (node.posX != position.x
                                                            || node.posY != position.y) {
                                                           
                                                            node.updatePos(position.x, position.y, true);
                                                            
                                                            self.jsPlumbInstance.repaintEverything();
                                                        }

                                                    }
                                                });

                                            
                                        });
                                    }
                                    catch (e) {

                                    }
                                }
                                else if (event.type === 'delete') {
                                    var node = document.getElementById(event.name);
                                    if (node) {
                                        node.remove(true);
                                        
                                        self.jsPlumbInstance.repaintEverything();
                                    }

                                }

                            })(event);
                        }
                    });

                    yjs.share.edges.observe(function (events) {

                        for (var i = 0; i < events.length; i++) {
                            var event = events[i];
                            (function (event) {

                                if (event.type === 'add') {
                                    try {
                                        yjs.share.edges.get(event.name).then(function (map) {
                                            var source = map.get('source') || '';
                                            var target = map.get('target') || '';
                                            var sourceEndpoint = map.get('sourceEndpoint') || '';
                                            var targetEndpoint = map.get('targetEndpoint') || '';

                                            if (source && target && sourceEndpoint && targetEndpoint) {

                                                self.edges[event.name] = { source: source, target: target, sourceEndpoint: sourceEndpoint, targetEndpoint: targetEndpoint };
                                                var node = document.getElementById(source);
                                                //
                                                if (node) {

                                                    node.addConnection(sourceEndpoint, target, targetEndpoint, true);

                                                }

                                            }

                                            map.observe(function (events2) {
                                                //console.log('edges', events2);
                                                var source = map.get('source') || '';
                                                var target = map.get('target') || '';
                                                var sourceEndpoint = map.get('sourceEndpoint') || '';
                                                var targetEndpoint = map.get('targetEndpoint') || '';
                                                if (source && target && sourceEndpoint && targetEndpoint) {
                                                    self.edges[event.name] = { source: source, target: target, sourceEndpoint: sourceEndpoint, targetEndpoint: targetEndpoint };
                                                    var node = document.getElementById(source);
                                                    if (node) {

                                                        node.addConnection(sourceEndpoint, target, targetEndpoint, true);

                                                    }
                                                }
                                            });
                                        });
                                    }
                                    catch (e) {

                                    }
                                }
                                else if (event.type === 'delete') {
                                    var edge = self.edges[event.name];
                                    //console.log('delete', edge);
                                    if (edge) {
                                        var node = document.getElementById(edge.source);
                                        if (node) {
                                            node.removeConnection(edge.sourceEndpoint, edge.targetEndpoint, true);
                                            self.jsPlumbInstance.repaintEverything();
                                        }
                                        delete self.edges[event.name];
                                    }
                                }

                            })(event);
                        }
                    });
                },
                ready: function () {

                },
                attached: function () {
                    var self = this;

                    jsPlumb.ready(function () {

                        var instance = window.jsp = jsPlumb.getInstance({
                            // default drag options
                            DragOptions: { cursor: 'pointer', zIndex: 2000 },
                            // the overlays to decorate each connection with.  note that the label overlay uses a function to generate the label text; in this
                            // case it returns the 'labelText' member that we set on each connection in the 'init' method below.
                            ConnectionOverlays: [
                                ["PlainArrow", { location: 1 }]
                            ],
                            Container: "canvas"
                        });
                        self.jsPlumbInstance = instance;
                        instance.Defaults.Container = document.getElementById('canvas');

                        self.fire('jsplumbloaded', instance);
                        var init = function (connection) {
                            //  connection.getOverlay("label").setLabel(connection.sourceId.substring(15) + "-" + connection.targetId.substring(15));
                        };
                        instance.registerEndpointTypes({
                            
                            "invalid": {
                                paintStyle: {
                                    strokeStyle: "#ff0000",
                                    fillStyle: "#ff0000",
                                    radius: 10,
                                    lineWidth: 4
                                },
                            }
                        });
                        // suspend drawing and initialise.
                        instance.batch(function () {

                            // listen for new connections; initialise them the same way we initialise the connections at startup.
                            instance.bind("connection", function (connInfo, originalEvent) {
                                init(connInfo.connection);
                            });

                            // make all the window divs draggable

                            instance.draggable(jsPlumb.getSelector('sweva-node'), { grid: [20, 20] });

                            //instance.draggable(jsPlumb.getSelector(".flowchart-demo .window"), { grid: [20, 20] });
                            // THIS DEMO ONLY USES getSelector FOR CONVENIENCE. Use your library's appropriate selector
                            // method, or document.querySelectorAll:
                            //jsPlumb.draggable(document.querySelectorAll(".window"), { grid: [20, 20] });

                            // connect a few up
                            // instance.connect({ uuids: ["node1_13", "node2_12"], editable: true });

                            //
                            // listen for clicks on connections, and offer to delete connections on click.
                            //
                            instance.bind("click", function (conn, originalEvent) {
                                // if (confirm("Delete connection from " + conn.sourceId + " to " + conn.targetId + "?"))
                                //   instance.detach(conn);
                                conn.toggleType("basic");
                            });
                            instance.bind("beforeDrop", function (connection) {
                                
                                if (connection.sourceId === connection.targetId) {
                                    return false;
                                }

                                return true;
                            });
                            instance.bind("connectionMoved", function (info) {

                                var node = document.getElementById(info.originalSourceId);
                                if (node) {
                                    //console.log('moved', info.originalSourceEndpoint.getUuid(), info.originalTargetEndpoint.getUuid());
                                   
                                    self.yjs.share.edges.delete(info.originalSourceEndpoint.getUuid() + info.originalTargetEndpoint.getUuid());
                                    self.yjs.share.edges.set(info.newSourceEndpoint.getUuid() + info.newTargetEndpoint.getUuid(), Y.Map).then(function (map) {

                                        map.set('source', info.originalSourceId);
                                        map.set('target', info.newTargetId);
                                        map.set('sourceEndpoint', info.newSourceEndpoint.getUuid());
                                        map.set('targetEndpoint', info.newTargetEndpoint.getUuid());

                                    });
                                   
                                }
                                self.wasMoved = true;
                            });
                            instance.bind("connectionDrag", function (connection) {
                                //console.log("connection " + connection.id + " is being dragged. suspendedElement is ", connection.suspendedElement, " of type ", connection.suspendedElementType);

                                //console.log(connection);
                                
                                var targetEndpoint = null;
                                var sourceEndpoint = null;
                                var sourceTooltip='';
                                for (var i = 0; i < connection.endpoints.length; i++) {
                                    var endpoint = connection.endpoints[i];
                                    if (endpoint.isSource) {
                                        sourceEndpoint = endpoint.getUuid();
                                        if (typeof endpoint.tooltip === 'string') {                                            
                                            sourceTooltip = endpoint.tooltip.trim();
                                        }
                                    }
                                    else if (endpoint.isTarget) {
                                        targetEndpoint = endpoint.getUuid();
                                    }

                                }
                                if (connection.sourceId && connection.targetId) {
                                    self.lastDraggedConnection.sourceId = connection.sourceId;
                                    self.lastDraggedConnection.sourceEndpoint = sourceEndpoint;
                                    self.lastDraggedConnection.targetEndpoint = targetEndpoint;
                                }
                                
                                self.jsPlumbInstance.selectEndpoints().each(function (endpoint) {
                                    
                                    //simple, make it more sophisticated
                                    if (sourceTooltip.length > 0 && typeof endpoint.tooltip == 'string' && endpoint.tooltip.trim().length > 0) {
                                        if (sourceTooltip != endpoint.tooltip.trim()) {
                                            endpoint.setType("invalid");
                                        }
                                    }
                                    
                                });

                            });

                            instance.bind("connectionDragStop", function (connection) {
                                //console.log("connection " + connection.id + " was dragged");
                                if (self.wasMoved) {
                                    self.wasMoved = false;
                                    return;
                                }
                                if (connection.source && connection.target) {

                                    var targetEndpoint = null;
                                    var sourceEndpoint = null;
                                    for (var i = 0; i < connection.endpoints.length; i++) {
                                        var endpoint = connection.endpoints[i];
                                        if (endpoint.isSource) {
                                            sourceEndpoint = endpoint.getUuid();
                                        }
                                        else if (endpoint.isTarget) {
                                            targetEndpoint = endpoint.getUuid();
                                        }

                                    }
                                    connection.source.addConnection(sourceEndpoint, connection.targetId, targetEndpoint);
                                }
                                else {
                                    if (self.lastDraggedConnection) {
                                        var node = document.getElementById(self.lastDraggedConnection.sourceId);
                                        if (node) {
                                            node.removeConnection(self.lastDraggedConnection.sourceEndpoint, self.lastDraggedConnection.targetEndpoint);
                                        }
                                    }

                                }
                                self.jsPlumbInstance.selectEndpoints().each(function (endpoint) {
                                    endpoint.removeType("invalid");
                                });

                            });

                           
                        });

                        jsPlumb.fire("jsPlumbDemoLoaded", instance);

                    });

                },
                cleanUp: function () {
                    this.edges = [];
                    this.yjs = null;
                    this.selectedNode = null;
                    var nodes = document.getElementById('canvas').querySelectorAll('sweva-node');
                    for (var i = 0; i < nodes.length; i++) {
                        this.jsPlumbInstance.remove(nodes[i]);
                    }
                    
                }
            });
        })();
    </script>
</dom-module>