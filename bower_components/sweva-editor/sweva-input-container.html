<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-input/paper-textarea.html">

<link rel="import" href="../paper-toggle-button/paper-toggle-button.html">

<!--

`<sweva-input-container>` is the element shown on the canvas representing input nodes.

-->

<dom-module id="sweva-input-container">
  <template>
    <style>
      :host {
        display: block;
        width: 200px;
        height: 200px;
        background: #00a46d;
        position: absolute;
        border-radius: 10px;
        box-sizing: border-box;
      }

      .index {
        line-height: 30px;
        padding: 0 10px;
        color: #fff;
      }

      [hidden] {
        display: none !important;
      }

      #content {
        background: #fff;
        overflow-y: auto;
        overflow-x: hidden;
        position: absolute;
        top: 30px;
        left: 0;
        bottom: 0;
        padding: 10px;
        border: 1px solid;
        border-top: none;
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
      }

      #content paper-toggle-button {
        margin-top: 10px;
      }

      select {
        font-family: inherit;
        background-color: transparent;
        width: 100%;
        padding: 4px 0;
        font-size: 16px;
        color: #727272;
        border: none;
        border-bottom: 1px solid #727272;
        -moz-appearance: none;
        -webkit-appearance: none;
        appearance: none;
      }

      select:focus {
        outline: none;
      }

      .material-select {
        position: relative;
      }

      .material-select:after {
        position: absolute;
        top: 0.75em;
        right: 0.45em;
        width: 0;
        height: 0;
        padding: 0;
        content: '';
        border-left: 0.315em solid transparent;
        border-right: 0.315em solid transparent;
        border-top: 0.35em solid #BDBDBD;
        pointer-events: none;
      }
    </style>

    <div class="index">Index: {{indexPos}}</div>

    <div id="content">
      <paper-dropdown-menu label="Select Type" no-label-float="true" on-iron-select="handleTypeChanged">
        <paper-listbox slot="dropdown-content" id="type" attr-for-selected="value">
          <paper-item value="header">Section Header</paper-item>
          <paper-item value="text">Text</paper-item>
          <paper-item value="multiline">Multi-Line Text</paper-item>
          <paper-item value="number">Number</paper-item>
          <paper-item value="slider">Slider</paper-item>
          <paper-item value="toggle">Toggle</paper-item>
          <paper-item value="dropdown">Dropdown</paper-item>
          <paper-item value="fixed">Fixed Value</paper-item>
        </paper-listbox>
      </paper-dropdown-menu>

      <paper-input id="indexPos" type="number" label="Index" value="[[indexPos]]" on-change="handleIndexChanged" data-parent="this" onclick="this.focus()"></paper-input>

      <paper-input hidden$="{{!showElement('label',type)}}" id="label" label="Label" value="" on-change="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-input>
      <paper-input hidden$="{{!showElement('stringvalue',type)}}" id="stringvalue" label="Value" value="" on-change="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-input>
      <paper-textarea hidden$="{{!showElement('multilinevalue',type)}}" id="multilinevalue" label="Value" value="" on-value-changed="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-textarea>
      <paper-input hidden$="{{!showElement('numbervalue',type)}}" id="numbervalue" type="number" label="Value" value="" on-change="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-input>
      <paper-toggle-button hidden$="{{!showElement('booleanvalue',type)}}" id="booleanvalue" label="Value" data-parent="this"
                           on-iron-change="toggleButtonValueChanged">
          {{toggleButtonValue}}
      </paper-toggle-button>
      <paper-input hidden$="{{!showElement('min',type)}}" id="min" type="number" label="Min" value="" on-change="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-input>
      <paper-input hidden$="{{!showElement('max',type)}}" id="max" type="number" label="Max" value="" on-change="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-input>
      <paper-textarea hidden$="{{!showElement('items',type)}}" id="items" label="Items , Separated" value="" on-value-changed="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-textarea>

      <paper-textarea hidden$="{{!showElement('description',type)}}" id="description" label="Description" value="" on-value-changed="handleInputChanged" data-parent="this" onclick="this.focus()"></paper-textarea>
    </div>

  </template>

  <script>
    class SwevaInputContainer extends Polymer.Element {
      static get is() {
        return 'sweva-input-container';
      }

      static get properties() {
        return {
            /* properties meta data object just like 1.x */
          posX: {
            type: Number,
            value: 50
          },
          posY: {
            type: Number,
            value: 50
          },
          indexPos: {
            type: Number,
            value: 0
          },
          yjs: {
            type: Object,
            value: null
          },
          jsPlumbInstance: {
            type: Object,
            value: null
          },
          width: {
            type: Number,
            value: 200
          },

          jsPlumbStyles: {
            type: Object,
            value: {
            }
          },
          type: {
            type: Object,
            value: ''
          },
          toggleButtonValue: {
            type: Boolean,
            value: false

          },
          edges: {
            type: Object,
            value: null
          },
          selectedBy: {
            type: String,
            value: ''
          },
          id: {
            type: String
          }
        }
      }

      ready() {
        super.ready();
        this.prepareStyles();
      }

      connectedCallback() {
        super.connectedCallback();
        this.$.content.addEventListener('mousewheel', function (event) {event.stopPropagation();}, false);
        this.shadowRoot.querySelector('#type').addEventListener('change', this.handleTypeChanged.bind(this), false);
        this.addEventListener("contextmenu", this.handleContextmenu.bind(this), false);
      }

      init(jsPlumbInstance, yjs, edges, id, fromYjs) {
        this.edges = edges;
        this.yjs = yjs;
        this.jsPlumbInstance = jsPlumbInstance;
        this.style.width = this.width + 'px';
        this.id = id || this._generateGUID();
        Polymer.dom.flush();
        var self = this;
        if (typeof fromYjs === 'undefined' || fromYjs == false) {

          var map = self.yjs.share.mapperContainers.set(self.id, Y.Map) //.then(function (map) {
            map.set('index', self.indexPos);
            map.set('type', self.shadowRoot.querySelector('#type').value || '');
            map.set('label', self.shadowRoot.querySelector('#label').value || '');
            map.set('stringvalue', self.shadowRoot.querySelector('#stringvalue').value || '');
            map.set('multilinevalue', self.shadowRoot.querySelector('#multilinevalue').value || '');
            map.set('numbervalue', self.shadowRoot.querySelector('#numbervalue').value || '');
            map.set('booleanvalue', self.shadowRoot.querySelector('#booleanvalue').checked || '');
            map.set('min', self.shadowRoot.querySelector('#min').value || '');
            map.set('max', self.shadowRoot.querySelector('#max').value || '');
            map.set('items', self.shadowRoot.querySelector('#items').value || '');
            map.set('description', self.shadowRoot.querySelector('#description').value || '');
            map.set('position', { x: self.posX, y: self.posY });
          //});

        }

        this.jsPlumbInstance.draggable(this, {
          stop: function (event) {
            self.updatePos(event.el.offsetLeft, event.el.offsetTop);
          }
        });

        this.updatePos();
        this.endpoint = this.jsPlumbInstance.addEndpoint(this, this.jsPlumbStyles.inputEndpoint, {
          anchor: [1, 0, 1, -1],
          uuid: this.id + 'endpoint'
        });
      }

      contextMenu(action) {
        if (action == 'delete') {
          this.remove();
        }
      }

      handleContextmenu(event) {
        var current = event.target;
        //get correct position if over children
        while (current.parentNode && current.tagName != 'SWEVA-INPUT-CONTAINER') {
          current = current.parentNode;
        }
        var items = [
          { title: 'Delete', fn: current.contextMenu.bind(current, 'delete') }
        ];
        basicContext.show(items, event);
        event.preventDefault();
      }

      remove(fromYjs) {
        this.clearConnections();
        this.jsPlumbInstance.remove(this);
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          this.yjs.share.mapperContainers.delete(this.id);
        }
      }

      clear() {
        this.clearConnections();
        this.jsPlumbInstance.deleteEndpoint(this.endpoint);
      }

      addConnection(sourceEndpointId, targetId, targetEndpointId, fromYjs) {
        var connectionExists = false;
        var possibleSourceEndpoint = '';
        var possibleTargetEndpoint = '';
        this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
          var targetEndpoint = null;
          var sourceEndpoint = null;
          for (var i = 0; i < connection.endpoints.length; i++) {
            var endpoint = connection.endpoints[i];
            if (endpoint.isSource) {
              sourceEndpoint = endpoint.getUuid();
            }
            else if (endpoint.isTarget) {
              targetEndpoint = endpoint.getUuid();
            }
          }
          if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
            connectionExists = true;
          }
        });
        this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
          if (endpoint.isSource) {
            possibleSourceEndpoint = endpoint.getUuid();
          }
        });
        if (!connectionExists) {
          try {
            if (!sourceEndpointId) {
              this.jsPlumbInstance.selectEndpoints({ source: this.id }).each(function (endpoint) {
                if (endpoint.isSource) {
                  sourceEndpointId = endpoint.getUuid();
                }
              });
            }
            if (!targetEndpointId) {
              this.jsPlumbInstance.selectEndpoints({ target: targetId }).each(function (endpoint) {
                if (endpoint.isTarget) {
                  targetEndpointId = endpoint.getUuid();
                }
              });
            }
            if (sourceEndpointId && targetEndpointId) {
              this.jsPlumbInstance.connect({ uuids: [sourceEndpointId, targetEndpointId], editable: true, deleteEndpointsOnDetach: false });
            }
          } catch (e) {}
        }
        if (sourceEndpointId && targetEndpointId) {
          var self = this;
          if (typeof fromYjs === 'undefined' || fromYjs == false) {
            var map = this.yjs.share.edges.set(sourceEndpointId + targetEndpointId, Y.Map);
            map.set('source', self.id);
            map.set('target', targetId);
            map.set('sourceEndpoint', sourceEndpointId);
            map.set('targetEndpoint', targetEndpointId);
          }
        }
      }

      removeConnection(sourceEndpointId, targetEndpointId, fromYjs) {
        var self = this;
        this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
          var targetEndpoint = null;
          var sourceEndpoint = null;
          for (var i = 0; i < connection.endpoints.length; i++) {
            var endpoint = connection.endpoints[i];
            if (endpoint.isSource) {
              sourceEndpoint = endpoint.getUuid();
            }
            else if (endpoint.isTarget) {
              targetEndpoint = endpoint.getUuid();
            }
          }
          //console.log('weg')
          if (sourceEndpoint == sourceEndpointId && targetEndpoint == targetEndpointId) {
            self.jsPlumbInstance.detach(connection);
          }
        });
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          this.yjs.share.edges.delete(sourceEndpointId + targetEndpointId);
        }
      }

      clearConnections() {
        var self = this;
        this.jsPlumbInstance.select().each(function (connection) {
          if (connection.sourceId == self.id || connection.targetId == self.id) {
            var targetEndpoint = null;
            var sourceEndpoint = null;
            for (var i = 0; i < connection.endpoints.length; i++) {
              var endpoint = connection.endpoints[i];
              if (endpoint.isSource) {
                sourceEndpoint = endpoint.getUuid();
              }
              else if (endpoint.isTarget) {
                targetEndpoint = endpoint.getUuid();
              }
            }
            if (targetEndpoint && sourceEndpoint) {
              self.removeConnection(sourceEndpoint, targetEndpoint);
            }
          }
        });
      }

      updateConnections() {
        var edges = this.edges;
        if (edges) {
          for (var key in edges) {
            if (edges.hasOwnProperty(key)) {
              var edge = edges[key];
              if (this.id == edge.source) {
                //console.log('target', edge.target);
                this.addConnection(edge.sourceEndpoint, edge.target, edge.targetEndpoint);
              }
            }
          }
        }
      }

      getInformation() {
        var result = {};
        result.type = this.type;
        switch (this.type) {
          case 'header':
            result.label = this.shadowRoot.querySelector('#label').value;
            break;
          case 'text':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#stringvalue').value;
            break;
          case 'multiline':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#multilinevalue').value;
            break;
          case 'number':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#numbervalue').value || 0;
            if (this.shadowRoot.querySelector('#min').value) {
              result.min = this.shadowRoot.querySelector('#min').value;
            }
            if (this.shadowRoot.querySelector('#max').value) {
              result.max = this.shadowRoot.querySelector('#max').value;
            }
            break;
          case 'slider':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#numbervalue').value || 0;
            if (this.shadowRoot.querySelector('#min').value) {
              result.min = this.shadowRoot.querySelector('#min').value;
            }
            if (this.shadowRoot.querySelector('#max').value) {
              result.max = this.shadowRoot.querySelector('#max').value;
            }
            break;
          case 'toggle':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#booleanvalue').checked;
            break;
          case 'dropdown':
            result.label = this.shadowRoot.querySelector('#label').value;
            result.description = this.shadowRoot.querySelector('#description').value;
            var items = this.shadowRoot.querySelector('#items');
            result.items = (typeof items.value === 'string') ? items.value.split(',') : items.value;
            break;
          case 'fixed':
            result.description = this.shadowRoot.querySelector('#description').value;
            result.value = this.shadowRoot.querySelector('#multilinevalue').value;
            break;
          default:
        }
        //mapping
        result.map = [];
        if (this.type !== 'header') {
          this.jsPlumbInstance.select({ source: this.id }).each(function (connection) {
            var inputLabel = '';
            var nodeAlias = connection.target.alias;
            for (var i = 0; i < connection.endpoints.length; i++) {
              var endpoint = connection.endpoints[i];
              if (endpoint.isTarget) {
                var labels = endpoint.getOverlays();
                for (var key in labels) {
                  if (labels.hasOwnProperty(key)) {
                    inputLabel = labels[key].label;
                  }
                }
              }
            }
            result.map.push('input.' + nodeAlias + '.' + inputLabel);
          });
        }
        return result;
      }

      toggleButtonValueChanged(event) {
        if (event.target) {
          this.toggleButtonValue = event.target.checked;
          this.handleInputChanged(event);
        }
      }

      handleTypeChanged(event) {
        this.updateType(event.target);
      }

      updateType(element, fromYjs) {
        if(fromYjs){
          this.type = element.value;
        } else {
          this.type = element.selected;
        }
        this.style.backgroundColor = '';
        switch (this.type) {
          case 'header':
            this.style.backgroundColor = '#f00';
            break;
          case 'text':
            this.style.backgroundColor = '#00802b';
            break;
          case 'multiline':
            this.style.backgroundColor = '#00802b';
            break;
          case 'number':
            this.style.backgroundColor = '#007fff';
            break;
          case 'slider':
            this.style.backgroundColor = '#000596';
            break;
          case 'toggle':
            this.style.backgroundColor = '#666';
            break;
          case 'dropdown':
            this.style.backgroundColor = '#ff00bf';
            break;
          case 'fixed':
            this.style.backgroundColor = '#111';
            break;
          default:
        }
        if (typeof fromYjs === 'undefined' || !fromYjs) {
          this.updateYjs(element);
        }
      }

      /**
       * Decides which input elements to show within the input node, depending on the input type. E.g., if the input
       * node type is 'text', we don't need to show the dropdown type items list textbox.
       *
       * @param element
       * @param type
       * @returns {boolean}
       */
      showElement(element, type) {
        switch (type) {
          case 'header':
            return (['label'].indexOf(element) >= 0);
          case 'text':
            return (['label', 'description', 'stringvalue'].indexOf(element) >= 0);
          case 'multiline':
            return (['label', 'description', 'multilinevalue'].indexOf(element) >= 0);
          case 'number':
            return (['label', 'description', 'min', 'max', 'numbervalue'].indexOf(element) >= 0);
          case 'slider':
            return (['label', 'description', 'min', 'max', 'numbervalue'].indexOf(element) >= 0);
          case 'toggle':
            return (['label', 'description', 'booleanvalue'].indexOf(element) >= 0);
          case 'dropdown':
            return (['label', 'description', 'items'].indexOf(element) >= 0);
          case 'fixed':
            return (['description', 'multilinevalue'].indexOf(element) >= 0);
          default:
            return false;
        }
      }

      handleIndexChanged(event) {
        this.indexPos = event.target.value;
        var map = this.yjs.share.mapperContainers.get(this.id);
        map.set('index', this.indexPos);
      }

      handleInputChanged(event) {
        if (event.target == null) {
          return;
        }
        var self = this;
        var currentElement = event.target;
        /*this.debounce('inputupdate', function () {
          if (currentElement) {
            while (!currentElement.dataset.parent && currentElement.parentNode) {
              currentElement = currentElement.parentNode;
            }
            self.updateYjs(currentElement);
          }
        }, 600); */
        this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(600),
          () => {
            if (currentElement) {
              while (!currentElement.dataset.parent && currentElement.parentNode) {
                currentElement = currentElement.parentNode;
              }
              self.updateYjs(currentElement);
            }
          });
      }

      _generateGUID() {
        function s4() {
          return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
          s4() + '-' + s4() + s4() + s4();
      }

      prepareStyles() {
        var inputEndpointHoverStyle = {
          fillStyle: "#00cc00",
          strokeStyle: "#00cc00"
        };
        var connectorPaintStyle = {
          lineWidth: 4,
          strokeStyle: "#333",
          joinstyle: "round",
          outlineColor: "white",
          outlineWidth: 2,
          dashstyle: '1'
        }
        var connectorHoverStyle = {
          lineWidth: 4,
          strokeStyle: "#00cc00",
          outlineWidth: 2,
          outlineColor: "#00cc00",
          dashstyle: '0'
        }
        var inputEndpoint = {
          endpoint: "Rectangle",
          paintStyle: {
            strokeStyle: "none",
            fillStyle: "#333",
            radius: 14
          },
          hoverPaintStyle: inputEndpointHoverStyle,
          maxConnections: -1,
          dropOptions: { hoverClass: "hover", activeClass: "active" },
          isSource: true,
          connector: ["Bezier"],
          connectorStyle: connectorPaintStyle,
          connectorHoverStyle: connectorHoverStyle,
          dragOptions: {},
        }
        this.jsPlumbStyles.inputEndpoint = inputEndpoint;
      }

      repaint() {
        try {
          this.jsPlumbInstance.repaint(this, { left: this.posX, top: this.posY });
        }
        catch (e) {}
      }

      /**
       * Updates input node map values based on the type of the changed HTML element.
       *
       * @param element
       */
      updateYjs(element) {
        if (element == null) {
          return;
        }
        try {
          var map = this.yjs.share.mapperContainers.get(this.id);
          var value;
          if (element.id === 'booleanvalue') {
            value = element.checked;
          } else if (element.id === 'type') {
            value = element.selected;
          } else {
            value = element.value;
          }
          map.set(element.id + '', value);
        }
        catch (e) {}
      }

      updateIndex(index) {
        if (this.index != index) {
          this.index = index;
          var map = this.yjs.share.mapperContainers.get(this.id);
          map.set('index', index);
        }
      }

      update(options, fromYjs) {
        if (typeof options === 'object') {
          for (var key in options) {
            if (options.hasOwnProperty(key)) {
              if (key == 'index') {
                if (this.indexPos != options.index) {
                  this.indexPos = options.index;
                }
              }
              else if (key == 'booleanvalue') {
                var element = this.shadowRoot.querySelector('#booleanvalue');
                if (element.checked != options.booleanvalue) {
                  element.checked = options.booleanvalue;
                }
              }
              else if (key == 'value') {
                if (typeof options.type === 'string') {

                  switch (this.type) {
                    case 'header':
                      break;
                    case 'text':
                      var element = this.shadowRoot.querySelector('#stringvalue');
                      element.value = options[key];
                      break;
                    case 'multiline':
                      var element = this.shadowRoot.querySelector('#multilinevalue');
                      element.value = options[key];
                      break;
                    case 'number':
                    case 'slider':
                      var element = this.shadowRoot.querySelector('#numbervalue');
                      element.value = options[key];
                      break;
                    case 'toggle':
                      var element = this.shadowRoot.querySelector('#booleanvalue');
                      element.checked = options[key];
                      break;
                    case 'dropdown':
                      var element = this.shadowRoot.querySelector('#items');
                      element.value = options[key].join(',') || options[key];//(Array.isArray(options[key])) ? options[key].join(';') : options[key];
                      break;
                    case 'fixed':
                      var element = this.shadowRoot.querySelector('#multilinevalue');
                      element.value = options[key];
                    default:
                  }
                }
              }
              else if (key === 'map') {
              }
              else if (key === 'position') {
                this.updatePos( options[key].x , options[key].y, fromYjs);
              } else {
                var element = this.shadowRoot.querySelector('#' + key);
                if (element && element.value !== options[key]) {
                  element.value = options[key];
                  if (element.id === 'type') {
                    this.updateType(element, true);
                  }
                }
              }
            }
          }
        }
      }

      updatePos(x, y, fromYjs) {
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
          if (this.posX == x && this.posY == y) {
            return;
          }
          this.posX = x;
          this.posY = y;
        }
        this.style.left = this.posX + 'px';
        this.style.top = this.posY + 'px';
        this.repaint();
        if (typeof fromYjs === 'undefined' || fromYjs == false) {
          if (this.yjs) {
            var map = this.yjs.share.mapperContainers.get(this.id);
            if (map) {
              map.set('position', { x: this.posX, y: this.posY });
            }
          }
        }
      }
    }

    // Register custom element definition using standard platform API
    customElements.define(SwevaInputContainer.is, SwevaInputContainer);
  </script>
</dom-module>