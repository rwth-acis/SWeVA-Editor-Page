<link rel="import" href="../polymer/polymer.html">
<link rel="stylesheet" href="../basicContext/dist/basicContext.min.css">
<link rel="stylesheet" href="../basicContext/dist/themes/default.min.css">
<link rel="import" href="sweva-node.html">
<link rel="import" href="sweva-input-mapper.html">
<link rel="import" href="sweva-code.html">
<script src="../basicContext/dist/basicContext.min.js"></script>

<!--

`<sweva-node-manager>` is the element responsible for showing processing nodes. It contains `<sweva-input-mapper>` which is
responsible for showing input nodes.

-->

<dom-module id="sweva-node-manager">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div id="node-canvas">
      <slot></slot>
    </div>

    <sweva-input-mapper id="input-mapper"></sweva-input-mapper>
  </template>

  <script>
    class SwevaNodeManager extends Polymer.Element {

      static get is() {
        return 'sweva-node-manager';
      }

      static get properties() {
        return {
          /* properties meta data object just like 1.x */
          jsPlumbInstance: {
            type: Object,
            value: null
          },
          yjs: {
            type: Object,
            value: null
          },
          edges: {
            type: Object,
            value: {}
          },
          lastDraggedConnection: {
            type: Object,
            value: {}
          },
          viewPort: {
            type: Object,
            value: {left: 0, top: 0, right: 1000, bottom: 1000}
          },
          canvasOffset: {
            type: Object,
            value: {
              x: -2000,
              y: -2000
            }
          },
          repositoryAddress: {
            type: String,
            value: ''
          },
          repositorySuffix: {
            type: String,
            value: ''
          },
          selectedNode: {
            type: Object,
            value: null
          },
          visualization: {
            type: String,
            value: ''
          },
          canvas: {
            type: Object
          }
        }
      }

      handleNodeCreated(event) {
        this.dispatchEvent(new CustomEvent('nodecreated', { bubbles: true, composed: true, detail: event.detail }));
      }

      handleNodeSelected(event) {

        this.selectedNode = event.detail;
        var nodes = this.shadowRoot.querySelectorAll('sweva-node');
        for (var i = 0; i < nodes.length; i++) {
          // nodes[i].toggleClass('selected', nodes[i].id == this.selectedNode.id);
          if (nodes[i].id == this.selectedNode.id) {
            nodes[i].style.backgroundColor = '#FF4F00';
          }
          else if (nodes[i].style.backgroundColor) {
            nodes[i].style.backgroundColor = '';
          }
        }
        this.dispatchEvent(new CustomEvent('nodeselected', { bubbles: true, composed: true , detail: event.detail }));
      }

      selectNodeBy(nodeId, userId, color) {
        var nodes = this.canvas.querySelectorAll('sweva-node');
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].id == nodeId) {
            nodes[i].selectBy(userId, color);
          }
          else if (nodes[i].selectedBy == userId) {
            nodes[i].unselect();
          }
        }
      }

      getDefaultInputData() {
        var graph = this.getGraphData();
        var nodesWithIncomingConnection = {};
        var data = {};
        var input = {};
        for (var i = 0; i < graph.edges.length; i++) {
          var edge = graph.edges[i];
          nodesWithIncomingConnection[edge.to] = true;
        }

        for (var i = 0; i < graph.nodes.length; i++) {
          var node = JSON.parse(sweva.ComposableLoader.convertCodeToJson(graph.nodes[i].code));
          if (!nodesWithIncomingConnection.hasOwnProperty(graph.nodes[i].id) && node.dataInNames) {
            data[graph.nodes[i].alias] = {};
            for (var k = 0; k < node.dataInNames.length; k++) {
              data[graph.nodes[i].alias][node.dataInNames[k]] = 42;//just some value
            }
          }

          if (node.inputNames) {
            input[graph.nodes[i].alias] = {};
            for (var k = 0; k < node.inputNames.length; k++) {
              input[graph.nodes[i].alias][node.inputNames[k]] = 42;//just some value
            }
          }
        }
        return {data: data, input: input};
      }

      getComposition(code) {
        var graph = this.getGraphData();
        var composition = {};
        composition.composables = {};
        var nodesWithConnections = [];
        var nodeDictionary = {};
        var morethanOneNode = graph.nodes.length > 1;
        for (var i = 0; i < graph.nodes.length; i++) {
          if (graph.nodes[i].alias) {
            nodeDictionary[graph.nodes[i].id] = graph.nodes[i];
            if (composition.composables.hasOwnProperty(graph.nodes[i].alias)) {
              alert('There are multiple nodes with the same alias: ' + graph.nodes[i].alias);
              return null;
            }
            if (graph.nodes[i].fixed) {
              composition.composables[graph.nodes[i].alias] = graph.nodes[i].name;
            }
            else {
              composition.composables[graph.nodes[i].alias] = JSON.parse(sweva.ComposableLoader.convertCodeToJson(graph.nodes[i].code));
            }
          }
        }
        composition.links = {};
        for (var i = 0; i < graph.edges.length; i++) {
          var edge = graph.edges[i];
          if (!nodeDictionary.hasOwnProperty(edge.from)) {
            continue;
          }
          var alias = nodeDictionary[edge.from].alias;
          if (!composition.links.hasOwnProperty(alias)) {
            composition.links[alias] = {};
          }
          if (!composition.links[alias].hasOwnProperty(edge.fromEndpoint)) {
            composition.links[alias][edge.fromEndpoint] = {};
          }
          var to = nodeDictionary[edge.to].alias;
          composition.links[alias][edge.fromEndpoint][to] = edge.toEndpoint;
          /*var mapping = {};
           mapping[edge.fromEndpoint] = edge.toEndpoint;
           var toMap = {
           to: to,
           mapping: mapping
           };*/
          nodesWithConnections[alias] = true;
          nodesWithConnections[to] = true;
          //composition.links[alias].push(toMap);
        }
        /*for (var key in composition.composables) {

         if (composition.composables.hasOwnProperty(key)) {
         if (typeof nodesWithConnections[key]==='undefined') {

         delete composition.composables[key];
         }
         }
         }*/
        composition.controls = {};
        composition.visualization = '';
        var container = this.shadowRoot.querySelector('#input-mapper');
        if (container) {
          var sections = container.getInformation();
          composition.visualization = this.visualization;
          composition.controls = sections;
        }
        var obj = JSON.parse(sweva.ComposableLoader.convertCodeToJson(code));
        obj.composables = composition.composables;
        obj.links = composition.links;
        obj.controls = composition.controls;
        obj.visualization = composition.visualization;
        return obj;
      }

      updateVisualization(url) {
        this.visualization = url;
      }

      updateViewport(viewPort) {
        this.viewPort = viewPort;
      }

      getGraphData() {
        var nodes = [].slice.call(this.canvas.querySelector("#node-manager").$["node-canvas"].querySelectorAll("sweva-node"));
        for (
          var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          node.graphNodeType = 'node';
        }
        var inputNodes = [].slice.call(this.canvas.querySelector("#node-manager").$["input-mapper"].$["input-canvas"].querySelectorAll('sweva-input-container'));
        for (var i = 0; i < inputNodes.length; i++) {
          var node = inputNodes[i];
          node.graphNodeType = 'input';
        }
        nodes = nodes.concat(inputNodes);
        var edges = [];
        this.jsPlumbInstance.select().each(function (connection) {
          var edge = {};
          edge.from = connection.sourceId;
          edge.to = connection.targetId;
          if (connection.endpoints.length != 2) {
            return;
          }
          var labels = connection.endpoints[0].getOverlays();
          for (var key in labels) {
            if (labels.hasOwnProperty(key)) {
              edge.fromEndpoint = labels[key].label;
            }
          }
          labels = connection.endpoints[1].getOverlays();
          for (var key in labels) {
            if (
              labels.hasOwnProperty(key)) {
              edge.toEndpoint = labels[key].label;
            }
          }
          edges.push(edge);
        });
        return {
          nodes: nodes,
          edges: edges
        };
      }

      autoLayout() {
        var graph = this.getGraphData();
        var g = new dagre.graphlib.Graph();
        g.setGraph({});
        g.setDefaultEdgeLabel(function () { return {}; });
        var nodeDictionary = {};
        for (var i = 0; i < graph.nodes.length; i++) {
          nodeDictionary[graph.nodes[i].id] = i;
          g.setNode(i, { width:graph.nodes[i]
            .offsetWidth,height: graph.nodes[i].offsetHeight, type: graph.nodes[i].graphNodeType });
        }
        for (var i = 0; i < graph.edges.length; i++) {
          g.setEdge(nodeDictionary[graph.edges[i].from], nodeDictionary[graph.edges[i].to]);
        }
        g.setGraph({ rankdir: 'LR', nodesep: 120, ranksep: 200 })
        dagre.layout(g);
        var canvasOffset = this.canvasOffset;
        g.nodes().forEach(function (v) {
          if (typeof v !== 'undefined' && v !== 'undefined') {
            var node = g.node(v);
            var realNode = graph.nodes[v];
            if (node.type == 'node') {
              realNode.posX = -canvasOffset.x + node.x;
              realNode.posY = -canvasOffset.y + node.y;
            }
            else {
              realNode.posX = -canvasOffset.x + node.x;
              realNode.posY = -canvasOffset.y + node.y;
            }
            realNode.updatePos();
          }
        });
        this.jsPlumbInstance.repaintEverything();
      }

      deleteNode(node) {
        if (node && node.remove) {
          node.remove();
        }
      }

      clear() {
        var nodes = this.canvas.querySelectorAll('sweva-node');
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].remove();
        }
        var container = this.shadowRoot.querySelector('#input-mapper');
        if (container) {
          container.clear();
        }
      }

      cloneNode(node) {
        this.createNode({ alias: node.alias +'-C', code: node.code });
      }

      importNodeJson(alias, content) {
        var json = JSON.parse(content);
        var code = sweva.ComposableLoader.convertJsonToCode(json);
        this.createNode({ alias: alias,
          code: code }
        );
      }

      importNodeObject(alias, content) {
        this.createNode({alias: alias, code: content});
      }

      importCompositionJSON(content) {
        var obj = JSON.parse(content);
        var nodeDictionary = {};
        var promises = [];
        var self = this;
        if (obj.composables) {
          for (var key in obj.composables) {
            if (
              obj.composables.hasOwnProperty(key)) {
              var composable = obj.composables[key];
              var node;
              if (typeof composable === 'string') {
                promises.push(this.createNode({ alias: key, url: composable, fixed: true}));
              }
              else {
                promises.push(this.createNode({ alias: key, code: sweva.ComposableLoader.convertJsonToCode(composable)}));
              }
            }
          }
        }
        var autoLayout = this.autoLayout.bind(this);
        Promise.all(promises).then(function (result) {
          for (var i = 0; i < result.length; i++) {
            var node = result[i];
            nodeDictionary[result[i].alias] = result[i];
          }
          if (obj.links) {
            for (var fromNode in obj.links) {
              if (obj.links.hasOwnProperty(fromNode)) {
                var nodeLinks = obj.links[fromNode];
                for (var fromEndpoint in nodeLinks) {
                  if (nodeLinks.hasOwnProperty(fromEndpoint)) {
                    var endpointLinks = nodeLinks[fromEndpoint];
                    for (var toNode in endpointLinks) {
                      if (endpointLinks.hasOwnProperty(toNode)) {
                        var toEndpoint = endpointLinks[toNode];
                        if (nodeDictionary[fromNode] && nodeDictionary[toNode]) {
                          var fromEndpointOut = nodeDictionary[fromNode].id + fromEndpoint + 'out';
                          var toEndpointIn = nodeDictionary[toNode].id + toEndpoint + 'in';
                          nodeDictionary[fromNode].addConnection(fromEndpointOut, nodeDictionary[toNode].id, toEndpointIn);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (obj.controls) {
            var container = self.shadowRoot.querySelector('#input-mapper');
            if (container) {
              for (var i = 0; i < obj.controls.length; i++) {
                var section = obj.controls[i];
                container.add({ type:'header', label: section.label});
                for (var k = 0; k < section.controls.length; k++) {
                  var added = container.add(section.controls[k]);
                  if (section.controls[k].map) {
                    for (var j = 0; j < section.controls[k].map.length; j++) {
                      var parts = section.controls[k].map[j].split('.');
                      if (parts.length == 3) {
                        var node = nodeDictionary[parts[1]];
                        if (node) {
                          var fromEndpoint = added.id + 'endpoint';
                          var toEndpoint = node.id + parts[2] + 'input';
                          added.addConnection(fromEndpoint, node.id, toEndpoint);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (obj.visualization) {
            self.visualization = obj.visualization;
            self.dispatchEvent(new CustomEvent('updatevisualization', { bubbles: true, composed: true , detail: obj.visualization }));
          }
          autoLayout();
        });
      }

      createInputNode() {
        var container = this.shadowRoot.querySelector('#input-mapper');
        var options = {};
        options.position = {};
        options.position.x = this.viewPort.left + (this.viewPort.right - this.viewPort.left) / 2;
        options.position.y = this.viewPort.top + (this.viewPort.bottom - this.viewPort.top) / 2;
        container.add(options);
      }

      createNode(options) {
        var node = new SwevaNode();
        this.$['node-canvas'].appendChild(node);

        var func = function (resolve, reject) {
          var self = this;
          var center = {};
          center.x = self.viewPort.left + (self.viewPort.right - self.viewPort.left) / 2;
          center.y = self.viewPort.top + (self.viewPort.bottom - self.viewPort.top) / 2;
          var x = options.x || center.x;
          var y = options.y || center.y;
          var fixed = options.fixed ? true : false;
          var alias = options.alias || '';
          var code = options.code || sweva.ComposableLoader.getDefaultModule();
          if (options.url) {
            var url = options.url;
            //if not full url specified, add the required rest
            if (url.indexOf('://') == -1) {
              url = self.repositoryAddress + url + self.repositorySuffix;
            }
            var self = self;
            axios.get(url).then(
              function (response) {
                var code = sweva.ComposableLoader.convertJsonToCode(response.data);
                node.init(self.jsPlumbInstance, self.yjs, self.edges, alias, code, fixed, { x: x, y: y });
                node.addEventListener('created', self.handleNodeCreated.bind(self));
                node.addEventListener('selected', self.handleNodeSelected.bind(self));
                resolve(node);
              });
          } else {
            node.init(self.jsPlumbInstance, self.yjs, self.edges, options.alias, code, fixed, { x: x, y: y });
            node.addEventListener('created', self.handleNodeCreated.bind(this));
            node.addEventListener('selected', self.handleNodeSelected.bind(this));
            resolve(node);
          }
        };
        var promise = func.bind(this);
        return new Promise(function (resolve, reject) {
          promise(resolve, reject);
        });
      }

      /**
       * Event handler for when a new node is created within the Yjs node map.
       *
       * @param nodeData
       * @returns {HTMLElement}
       */
      yjsCreateNode(nodeData) {
        var node = document.createElement('sweva-node');
        this.shadowRoot.getElementById('node-canvas').appendChild(node);
//          Polymer.dom(this).appendChild(node);
        node.init(this.jsPlumbInstance, this.yjs, this.edges, nodeData.alias,
          nodeData.code, nodeData.fixed, { x: nodeData.x, y: nodeData.y }, nodeData.id, true);
        node.addEventListener('created', this.handleNodeCreated.bind(this));
        node.addEventListener('selected', this.handleNodeSelected.bind(this));
        return node;
      }

      init(yjs) {
        this.yjs = yjs;
        var self = this;
        jsPlumb.ready(
          function () {
            // instance is the JSPlumb instance.
            var instance = window.jsp = jsPlumb.getInstance({
              // default drag options
              DragOptions: { cursor: 'pointer', zIndex: 2000 },
              // the overlays to decorate each connection with.  note that the label overlay uses a function to generate the label text; in this// case it returns the 'labelText' member that we set on each connection in the 'init' method below.
              ConnectionOverlays: [
                ["PlainArrow", { location: 1 }]
              ],
              Container: self.canvas
            });
            self.jsPlumbInstance = instance;
            instance.Defaults.Container = self.canvas;
            self.dispatchEvent(new CustomEvent('jsplumbloaded', { bubbles: true, composed: true , detail: instance}));
            var init = function (connection) {
              //  connection.getOverlay("label").setLabel(connection.sourceId.substring(15) + "-" + connection.targetId.substring(15));
            };
            instance.registerEndpointTypes({
              "invalid": {
                paintStyle: {
                  strokeStyle: "#ff0000",
                  fillStyle: "#ff0000",
                  radius: 10,
                  lineWidth: 4
                },
              }
            });
            // suspend drawing and initialize.
            instance
              .batch(function () {
                // listen for new connections; initialise them the same way we initialise the connections at startup.
                instance.bind("connection", function (connInfo, originalEvent) {
                  init(connInfo.connection);
                });
                // make all the window divs draggable
                //instance.draggable(jsPlumb.getSelector('sweva-node'), { grid: [20, 20] });
                //instance.draggable(jsPlumb.getSelector(".flowchart-demo .window"), { grid: [20, 20] });
                // THIS DEMO ONLY USES getSelector FOR CONVENIENCE. Use your library's appropriate selector
                // method, or document.querySelectorAll:
                //jsPlumb.draggable(document.querySelectorAll(".window"), { grid: [20, 20] });
                // connect a few up
                // instance.connect({ uuids: ["node1_13", "node2_12"], editable: true });
                //
                // listen for clicks on connections, and offer to delete connections on click.
                //
                instance.bind("click", function (conn, originalEvent) {
                  // if (confirm("Delete connection from " + conn.sourceId + " to " + conn.targetId + "?"))
                  //   instance.detach(conn);
                  conn.toggleType("basic");
                });
                instance.bind("beforeDrop", function (connection) {
                  if (connection.sourceId === connection.targetId) {
                    return false;
                  }
                  var source = self.shadowRoot.getElementById(connection.sourceId);

                  if (source && source.tagName == 'SWEVA-INPUT-CONTAINER' && !connection.dropEndpoint.isInput) {
                    return false;
                  }
                  return true;
                });
                instance.bind("connectionMoved", function (info) {
                  if (info.originalSourceEndpoint.getUuid() == info.newSourceEndpoint.getUuid()
                    && info.originalTargetEndpoint.getUuid() == info.newTargetEndpoint.getUuid()) {
                    return;
                  }
                  var node = self.shadowRoot.getElementById(info.originalSourceId);
                  // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                  // out if the source node is of type input node
                  if (!node) {
                    node = self.shadowRoot.querySelector('#input-mapper').getInputNode(info.originalSourceId);
                  }
                  if (node) {
                    //console.log('moved', info.originalSourceEndpoint.getUuid(), info.originalTargetEndpoint.getUuid());
                    self.yjs.share.edges.delete(info.originalSourceEndpoint.getUuid() + info
                        .originalTargetEndpoint.getUuid());
                    var map = self.yjs.share.edges.set(info.newSourceEndpoint.getUuid() + info.newTargetEndpoint.getUuid(), Y.Map);
                    map.set('source', info.originalSourceId);
                    map.set('target', info.newTargetId);
                    map.set('sourceEndpoint', info.newSourceEndpoint.getUuid());
                    map.set('targetEndpoint', info.newTargetEndpoint.getUuid());
                  }
                  self.wasMoved = true;
                });
                instance.bind("connectionDrag", function (connection) {
                  //console.log("connection " + connection.id + " is being dragged. suspendedElement is ", connection.suspendedElement, " of type ", connection.suspendedElementType);
                  //console.log(connection);
                  var targetEndpoint = null;
                  var sourceEndpoint = null;
                  var sourceTooltip = '';
                  for (var i = 0; i < connection.endpoints.length; i++) {
                    var endpoint = connection.endpoints[i];
                    if (endpoint.isSource) {
                      sourceEndpoint = endpoint.getUuid();
                      if (typeof endpoint.tooltip === 'string') {
                        sourceTooltip = endpoint.tooltip.trim();
                      }
                    }
                    else if (endpoint.isTarget) {
                      targetEndpoint = endpoint.getUuid();
                    }
                  }
                  if (connection.sourceId && connection.targetId) {
                    self.lastDraggedConnection.sourceId = connection.sourceId;
                    self.lastDraggedConnection.sourceEndpoint = sourceEndpoint;
                    self.lastDraggedConnection.targetEndpoint = targetEndpoint;
                  }
                  self.jsPlumbInstance.selectEndpoints().each(function (endpoint) {
                      //simple, make it more sophisticated
                      if (sourceTooltip.length > 0 && endpoint.isTarget &&
                        typeof endpoint.tooltip == 'string' && endpoint.tooltip.trim().length > 0) {
                        if (sourceTooltip != endpoint.tooltip.trim()) {
                          endpoint.setType("invalid");
                        }
                      }
                    }
                  );
                });
                instance.bind("connectionDragStop", function(connection) {
                  //console.log("connection " + connection.id + " was dragged");
                  if (self.wasMoved) {
                    self.wasMoved = false;
                    return;
                  }
                  if (connection.source && connection.target) {
                    var targetEndpoint = null;
                    var sourceEndpoint = null;
                    for (var i = 0; i < connection.endpoints.length; i++) {
                      var endpoint = connection.endpoints[i];
                      if (endpoint.isSource) {
                        sourceEndpoint = endpoint.getUuid();
                      }
                      else if (endpoint.isTarget) {
                        targetEndpoint = endpoint.getUuid();
                      }
                    }
                    connection.source.addConnection
                    (sourceEndpoint, connection.targetId, targetEndpoint);
                  }
                  else {
                    if (self.lastDraggedConnection) {
                      var node = self.shadowRoot.getElementById(self.lastDraggedConnection.sourceId);
                      // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                      // out if the source node is of type input node
                      if (!node) {
                        node = self.shadowRoot.querySelector('#input-mapper').getInputNode(self.lastDraggedConnection.sourceId);
                      }
                      if (node) {
                        node.removeConnection(self.lastDraggedConnection.sourceEndpoint, self.lastDraggedConnection.targetEndpoint);
                      }
                    }
                  }
                  self.jsPlumbInstance.selectEndpoints().each(function (endpoint) {
                    endpoint.removeType("invalid");
                  });
                });
              });
            jsPlumb.fire("jsPlumbDemoLoaded", instance);
            //jsPlumb.dispatchEvent(new CustomEvent('jsPlumbDemoLoaded', { bubbles: true, composed: true , detail: instance }));
            self.loaded();
          });
      }


      /**
       * This is called when all the resources have been loaded, and Yjs is ready.
       *
       **/
      loaded() {
        var yjs = this.yjs;
        var self = this;

        // load existing nodes
        for (var i = 0; i < yjs.share.nodes.keys().length; i++) {
          var nodeId = yjs.share.nodes.keys()[i];
          var nodeMap = yjs.share.nodes.get(nodeId);
          var position = nodeMap.get('position') || { x: 0, y: 0 };
          var alias = nodeMap.get('alias') || 'node';
          var code = nodeMap.get('code') || '';
          var fixed = !!nodeMap.get('fixed');

          self.yjsCreateNode({ id: nodeId, alias: alias, code: code, fixed: fixed, x: position.x, y: position.y });
        }

        // add an observer for nodes
        yjs.share.nodes.observe(
          function(event) {

            (function (event) {
              if (event.type === 'add' && event.object.opContents.hasOwnProperty(event.name)) {

                try {
                  var map = yjs.share.nodes.get(event.name);
                  var position = map.get('position') || { x: 0, y: 0 };
                  var alias = map.get('alias') || 'node';
                  var code = map.get('code') || '';
                  var fixed = map.get('fixed') ? true : false;
                  var node = self.shadowRoot.getElementById(event.name);

                  // check if we already have the node on the canvas; if yes, this indicates that we have created the node
                  // ourselves.
                  if (!node) {
                    node = self.yjsCreateNode({ id: event.name, alias: alias, code: code, fixed: fixed, x: position.x, y: position.y });
                  }

                  // update all connections between processing nodes
                  var nodes = self.shadowRoot.querySelectorAll('sweva-node');
                  for (var k = 0; k < nodes.length; k++) {
                    nodes[k].updateConnections();
                  }

                  // update all connections between input nodes
                  nodes = self.shadowRoot.querySelectorAll('sweva-input-container');
                  for (var k = 0; k < nodes.length; k++) {
                    nodes[k].updateConnections();
                  }

                  self.jsPlumbInstance.repaintEverything();

                  // observe changes of the node, like position, alias, code, fixed.
                  map.observe(function(event2) {
                    var position = map.get('position');
                    var alias = map.get('alias');
                    var code = map.get('code');
                    var fixed = map.get('fixed');
                    if (position != null && code != null && alias != null) {
                      //prevent randomly inserting nodes at 0 0
                      var node = self.shadowRoot.getElementById(event.name);
                      if (!node) {
                        return;
                      }
                      if (!node.sharedCode) {
                        var text = map.get('sharedCode' + node.id);
                        if (text) {
                          node.sharedCode = text;
                          node.dispatchEvent(new CustomEvent('nodecreated', { bubbles: true, composed: true , detail:node}));
                        }
                      }
                      //node.jsPlumbInstance = self.jsPlumbInstance;
                      if (node.alias != alias) {
                        node.alias = alias;
                      }
                      if (node.code != code) {
                        node.updateCode(code, true);
                      }
                      if (typeof fixed !== 'undefined' && node.fixed != fixed) {
                        node.fixed = fixed;
                      }
                      if ((node.posX != position.x) || (node.posY != position.y)) {
                        node.animatePos(position.x, position.y, true);
                      }
                    }
                  });
                } catch (e) {
                  console.log('not found');
                }

              } else if (event.type === 'delete') {
                var node = self.shadowRoot.getElementById(event.name);
                // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                // out if the source node is of type input node
                if (!node) {
                  node = self.shadowRoot.querySelector('#input-mapper').getInputNode(event.name);
                }
                if (node) {
                  node.remove(true);
                  self.jsPlumbInstance.repaintEverything();
                }
              } else if (event.type === 'update') {
                // do nothing
              }
            })(event);

          });

        // now initialize the input nodes
        var container = this.shadowRoot.querySelector('#input-mapper');
        container.init(this.jsPlumbInstance, this.yjs, this.edges);

        // load existing edges
        for (var i = 0; i < yjs.share.edges.keys().length; i++) {
          var edgeId = yjs.share.edges.keys()[i];
          var edgeMap = yjs.share.edges.get(edgeId);

          var source = edgeMap.get('source') || '';
          var target = edgeMap.get('target') || '';
          var sourceEndpoint = edgeMap.get('sourceEndpoint') || '';
          var targetEndpoint = edgeMap.get('targetEndpoint') || '';

          if (source && target && sourceEndpoint && targetEndpoint) {
            self.edges[edgeId] = { source: source, target: target, sourceEndpoint: sourceEndpoint, targetEndpoint: targetEndpoint };
            var node = self.shadowRoot.getElementById(source);
            // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
            // out if the source node is of type input node
            if (!node) {
              node = self.shadowRoot.querySelector('#input-mapper').getInputNode(source);
            }
            if (node) {
              node.addConnection(sourceEndpoint, target, targetEndpoint, true);
            }
          }
        }

        // add an observer for edges
        yjs.share.edges.observe(function (event) {
          (function (event) {
            if (event.type === 'add') {
              try {
                var map = yjs.share.edges.get(event.name);
                var source = map.get('source') || '';
                var target = map.get('target') || '';
                var sourceEndpoint = map.get('sourceEndpoint') || '';
                var targetEndpoint = map.get('targetEndpoint') || '';
                if (source && target && sourceEndpoint && targetEndpoint) {
                  self.edges[event.name] = { source: source, target: target, sourceEndpoint: sourceEndpoint, targetEndpoint: targetEndpoint };
                  var node = self.shadowRoot.getElementById(source);
                  // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                  // out if the source node is of type input node
                  if (!node) {
                    node = self.shadowRoot.querySelector('#input-mapper').getInputNode(source);
                  }
                  if (node) {
                    node.addConnection(sourceEndpoint, target, targetEndpoint, true);
                  }
                }
                map.observe(function(event2) {
                  //console.log('edges', events2);
                  var source = map.get('source') || '';
                  var target = map.get('target') || '';
                  var sourceEndpoint = map.get('sourceEndpoint') || '';
                  var targetEndpoint = map.get('targetEndpoint') || '';
                  if (source && target && sourceEndpoint && targetEndpoint) {
                    self.edges[event.name] = { source: source, target: target, sourceEndpoint: sourceEndpoint, targetEndpoint: targetEndpoint };
                    var node = self.shadowRoot.getElementById(source);
                    // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                    // out if the source node is of type input node
                    if (!node) {
                      node = self.shadowRoot.querySelector('#input-mapper').getInputNode(source);
                    }
                    if (node) {
                      node.addConnection(sourceEndpoint, target, targetEndpoint, true);
                    }
                  }
                });
              } catch (e) {}
            } else if (event.type === 'delete') {
              var edge = self.edges[event.name];
              //console.log('delete', edge);
              if (edge) {
                var node = self.shadowRoot.getElementById(edge.source);
                // input nodes can't be found because they are in the sweva-input-mapper shadow DOM, therefore try
                // out if the source node is of type input node
                if (!node) {
                  node = self.shadowRoot.querySelector('#input-mapper').getInputNode(edge.source);
                }
                if (node) {
                  node.removeConnection(edge.sourceEndpoint, edge.targetEndpoint, true);
                  if (node.repaint) {
                    node.repaint();
                  }
                }
                delete self.edges[event.name];
              }
            }
          })(event);
        });
      }

      cleanUp() {
        this.edges = [];
        this.yjs = null;
        this.selectedNode = null;
        var nodes = this.shadowRoot.querySelectorAll('sweva-node');
        for (var i = 0; i < nodes.length; i++) {
          this.jsPlumbInstance.remove(nodes[i]);
        }
      }
    }

    // Register custom element definition using standard platform API
    window.customElements.define(SwevaNodeManager.is, SwevaNodeManager);
  </script>
</dom-module>