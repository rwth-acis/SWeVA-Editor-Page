<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="sweva-visualization-container-panel.html">
<link rel="import" href="sweva-error-console.html">
<link rel="import" href="../polymer/lib/utils/import-href.html">

<script src="../yjs/y.js"></script>
<script src="../y-memory/y-memory.js"></script>
<script src="../y-map/y-map.js"></script>
<script src="../y-array/y-array.js"></script>
<script src="../y-text/y-text.js"></script>
<script src="../y-websockets-client/y-websockets-client.js"></script>
<script src="../../node_modules/sweva-core/dist/core.build.js"></script>
<!--<script src="../../node_modules/sweva-core/dist/core.build.min.js"></script>-->

<dom-module id="sweva-visualization-container">
  <template>
    <style>
      :host {
        height: 100%;
        min-height: 300px;
        position: relative;
        font-family: 'Roboto', 'Noto', sans-serif;
        position: relative;
        display: block;
      }

      .container {
        display: flex;
        flex-direction: row;
        box-sizing: border-box;
        width: 100%;
        height: calc(100% - 50px);
        margin-bottom: 50px;
      }
      .log-container {
        margin-top: 10px;
        position: relative;
      }
      #visualization-area {
        flex: 1 1 0;
        background: #ffffff;
        overflow: auto;
        position: relative;
      }

      #loading-bar {
        width: 5%;
        height: 10px;
        background-color: #ffa500;
        transition: width 0.3s ease-in-out;
      }

    </style>

    <div class="container">
      <div id="loading-bar"></div>

      <div id="visualization-area">
        <div id="console-log"></div>
      </div>
      <sweva-visualization-container-panel id="panel"
                                           on-inputchanged="handleInputChanged"
                                           on-roomchanged="handleRoomChanged"
                                           on-executed="handleExecuted"
                                           room="{{room}}">
      </sweva-visualization-container-panel>
    </div>
    <sweva-error-console id="error-console">
    </sweva-error-console>
  </template>


  <script>

    class SwevaVisualizationContainer extends Polymer.Element {

      static get is() {
        return 'sweva-visualization-container';
      }

      static get properties() {
        return {
            /* properties meta data object just like 1.x */
          toolUrl: {
            type: String,
            value: null
          },
          controls: {
            type: Array,
            value: []
          },
          input: {
            type: Object,
            value: null
          },
          result: {
            type: Object,
            value: {}
          },
          executionManager: {
            type: Object,
            value: null
          },
          yjsServer: {
            type: String,
            value: 'https://yjs.dbis.rwth-aachen.de:5072'
          },
          yjs: {
            type: Object,
            value: null
          },
          composition: {
            type: Object,
            value: {}
          },
          oldComposition: {
            type: String,
            value: ''
          },
          room: {
            type: String,
            value: 'defaultSwevaVisRoom1'
          },
          visualizationUrlPrefix: {
            type: String,
            value: ' '
          },
          visualizationUrlSuffix: {
            type: String,
            value: ' '
          },
          pollTimer: {
            type: Object,
            value: null
          },
          visualizationAreaSize: {
            type: Object,
            value: {
              width: 10,
              height: 10
            }
          },
          staticInput: {
            type: Boolean,
            value: false
          },
          overrideInput: {
            type: Object,
            value: null
          }
        }
      }

      ready() {
        super.ready();
        this.executionManager = new sweva.ExecutionManager();
        var self = this;
        this.executionManager.onProgress(function(progress) {
          console.log("Progress "+progress+"%");
          var panel = self.$.panel;
          panel.updateProgress(progress);

        });

        var visualizationArea = this.shadowRoot.querySelector('#visualization-area');

        // Create a separate div for the loading bar and log container
        var loadingContainer = document.createElement('div');
        loadingContainer.classList.add('loading-container');

        // Create the loading bar
        var loadingBar = document.createElement('div');
        loadingBar.id = 'loading-bar';
        loadingBar.style.width = '0%';
        loadingBar.style.height = '10px';
        loadingBar.style.backgroundColor = '#ffa500';
        loadingBar.style.transition = 'width 0.3s ease-in-out';

        loadingContainer.appendChild(loadingBar);
        visualizationArea.appendChild(loadingContainer);

        // Intercept console.log() statements
        var originalConsoleLog = console.log;

        let startTimeOffloading =0;
        let startMemOffloading = 0;

        let endTimeOffloading =0;
        let endMemOffloading = 0;
        let endTotalMem=0;
        let startTotalTime = 0;
        let startTotalMem = 0;

        console.log = function() {
          var args = Array.from(arguments);

          // Loading bar
          if (args.some(arg => typeof arg === 'string' && arg.includes('Progress'))) {
            let logMessageBar = args.map(arg => {
              if (typeof arg === 'object') {
                return JSON.stringify(arg);
              }
              return arg;
            }).join(' ');

            // Extract the percentage from the log message
            var percentage = logMessageBar.match(/\d+/);
            if (percentage) {
              var percentValue = parseInt(percentage[0]);
              if (!isNaN(percentValue)) {
                // Update the loading bar width based on the percentage
                loadingBar.style.width = percentValue + '%';
              }
            }
          }

          // Test msgs
          if (args.some(arg => typeof arg === 'string' && arg.includes('offloadingOutput'))) {
            let logMessageText = args.map(arg => {
              if (typeof arg === 'string' && arg.includes('offloadingOutput')) {
                return arg.split('$')[1].trim();
              }
              return arg;
            }).join(' ');

            // Create a new div element and append the log message
            var logContainer = document.createElement('div');
            logContainer.classList.add('log-container');
            var paragraph = document.createElement('p');
            paragraph.innerHTML = logMessageText;
            logContainer.appendChild(paragraph);
            visualizationArea.appendChild(logContainer);
          }

          if (args.some(arg => typeof arg === 'string' && arg.includes('begin the execution'))) {

            startTotalMem = performance.memory.usedJSHeapSize;
            startTotalTime = Date.now();
          }

          if (args.some(arg => typeof arg === 'string' && arg.includes('broadcasting to discovery network....'))) {

            startMemOffloading = performance.memory.usedJSHeapSize;
            startTimeOffloading = Date.now();
          }

          if (args.some(arg => typeof arg === 'string' && arg.includes('===== Recieved offloaded Result ====='))) {
            endTimeOffloading = Date.now();
            endMemOffloading= performance.memory.usedJSHeapSize;
            endTotalMem = endMemOffloading;

            if (endMemOffloading < startMemOffloading) {
              let temp = endMemOffloading;
              endMemOffloading = startMemOffloading;
              startMemOffloading = temp;
            }
            if (endTotalMem < startTotalMem) {
              let temp = endTotalMem;
              endTotalMem = startMemOffloading;
              startTotalMem = temp;
            }

            console.log('offloadingOutput$ Offloading time: ',formatTime(endTimeOffloading-startTimeOffloading),' (',endTimeOffloading-startTimeOffloading,' ms)');
            console.log('offloadingOutput$ Offloading Memory: ',formatBytes(endMemOffloading-startMemOffloading),' (',endMemOffloading-startMemOffloading,' bytes)');
            console.log('offloadingOutput$ Total execution time: ',formatTime(endTimeOffloading-startTotalTime),' (',endTimeOffloading-startTotalTime,' ms)');
            console.log('offloadingOutput$ Total used Memory: ',formatBytes(endTotalMem-startTotalMem),' (',endTotalMem-startTotalMem,' bytes)');
          }


          // Call the original console.log() function
          originalConsoleLog.apply(console, args);


        };
      }




      connectedCallback() {
        super.connectedCallback();
        Polymer.RenderStatus.beforeNextRender(this, function() {
          this.init();
        });
      }

      // Element Behavior
      handleRoomChanged(event) {
        this.room = event.detail;

        this.yjs.connector.options.room = this.room;
        this.yjs = null;
        console.log(this.room);
        this.init();
      }

      handleExecuted(event) {
        this.input = event.detail;

        this.execute();
      }

      handleInputChanged(event) {
        var input = event.detail;
        this.input = input;
      }

      execute() {
        var self = this;
        var input = this.input || {};

        if (this.overrideInput != null) {
          input = this.overrideInput;
        }

        var panel = this.$.panel;
        panel.resetProgress();


        let startMemExecute = performance.memory.usedJSHeapSize;
        let startTimeExecute = Date.now();
        this.executionManager.execute(
          {},
          input
        ).then(function (result) {
          let endTimeExecute = Date.now();
          let endMemExecute = performance.memory.usedJSHeapSize;
            self.result = result;
            self.updateVisualization();

          if (endMemExecute < startMemExecute) {
            let temp = endMemExecute;
            endMemExecute = startMemExecute;
            startMemExecute = temp;
          }

          console.log('offloadingOutput$ Execution time: ',formatTime(endTimeExecute-startTimeExecute),' (',endTimeExecute-startTimeExecute,' ms)');
          console.log('offloadingOutput$ Execution Memory: ',formatBytes(endMemExecute-startMemExecute),' (',endMemExecute-startMemExecute,' bytes)');
          });
        this.executionManager.onMQTTDataRecieved( function (result) {
              self.result = result;
              self.updateVisualization();
          }
        );
      }

      load(composition) {
        sweva.ExecutionManager.setInitialIntermediatePipeline(composition);
        var errorConsole = this.shadowRoot.querySelector('#error-console');
        if (errorConsole) {
          errorConsole.clear();
        }

        var sameTool = true;
        var sameComposition = true;
        var sameControls = true;

        if (typeof composition === 'object') {
          var jsonString = JSON.stringify(composition)
          if (jsonString != this.oldComposition) {
            this.oldComposition = jsonString;

            this.composition = composition;
            sameComposition = false;
          }

        }
        if (!sameComposition) {

          this.executionManager.setup(this.composition);

          if (this.composition.controls) {
            this.$.panel.sections = this.composition.controls;
          } else {
            this.$.panel.sections = this.controls;
          }
          if (this.composition.visualization) {
            if (this.toolUrl != this.composition.visualization) {
              this.toolUrl = this.composition.visualization;
              sameTool = false;
            }
          }

          var self = this;
          if (!sameTool) {
            var url = this.toolUrl;
            this.loadVisualizationTool(this.toolUrl).then(function () {
              console.log(url + ' loaded!');
              self.execute();
            });
          } else {
            this.execute();
          }

        }
      }

      updateVisualization() {
        var visualization = this.shadowRoot.querySelector('#visualization-tool');
        if (visualization) {
          visualization.set(this.result);
        }
      }

      loadVisualizationTool(url) {
        var self = this;
        return new Promise(function (resolve, reject) {
          if (typeof url === 'undefined' || url === null) {
            reject();
          }
          var area = self.shadowRoot.querySelector('#visualization-area');

          var tool = self.shadowRoot.querySelector('#visualization-tool');

          if (tool && typeof tool.cleanUp === 'function') {
            tool.cleanUp();
          }
          //console.log(area.offsetWidth, area.offsetHeight)
          var children = Polymer.dom(area).children;  //TODO change
          for (var i = 0; i < children.length; i++) {
            Polymer.dom(area).removeChild(children[i]); //TODO change
          }
          Polymer.dom.flush();

          if (url.indexOf('http') != 0) {
            url = self.visualizationUrlPrefix + url + self.visualizationUrlSuffix;
          }
          Polymer.importHref(url, function (e) {
            // e.target.import is the import document.

            var match = new RegExp(/\/[\w-]+\.(min.html|html)/).exec(url);

            if (match && match[0].length > 6) {

              var toolName = match[0].substring(1, match[0].length - 5);

              // remove the ".min" from minified files
              if (toolName.indexOf('.min') > -1) {
                toolName = toolName.substring(0, toolName.length - 4);
              }

              var newElement = document.createElement(toolName);
              //newElement.myProperty = 'foo';
              newElement.id = 'visualization-tool';

              Polymer.dom(area).appendChild(newElement); //TODO change

              Polymer.dom.flush();
              newElement.resize(area.offsetWidth, area.offsetHeight);
              resolve();
            }
            else {
              reject();
            }

          },
          function (e) {
            reject(e);
          });
        });
      }

      init() {
        var self = this;

        if (this.pollTimer) {
          clearInterval(this.pollTimer);
        }

        this.pollTimer = setInterval(function () {
          var area = self.shadowRoot.querySelector('#visualization-area');
          if (area.offsetWidth != self.visualizationAreaSize.width || area.offsetHeight != self.visualizationAreaSize.height) {
            self.visualizationAreaSize.width = area.offsetWidth;
            self.visualizationAreaSize.height = area.offsetHeight;
            var visualization = self.shadowRoot.querySelector('#visualization-tool');
            if (visualization && visualization.resize) {
              this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(400),
                  () => {
                  visualization.resize(area.offsetWidth, area.offsetHeight);
              });
            }
          }
        }, 100);

        if (!this.staticInput) {
          Y({
            db: {
              name: 'memory'
            },
            connector: {
              name: 'websockets-client',
              room: self.room,//'swevavisualtest1'
              // debug: true,
              url: self.yjsServer
            },
            sourceDir: /*'../../bower_components/',//*/'http://0.0.0.0:8021/yjs/bower_components',
            share: {

              chat: 'Array',
              input: 'Map',
              inputUpdates: 'Array'

            }
          }).then(function (y) {
            self.yjs = y;

            var panel = self.$.panel;

            panel.init(y);

            self.dispatchEvent(new CustomEvent('initialized', { bubbles: true, composed: true, detail:{}}));
          });
        } else {
          var panel = self.$.panel;
          panel.style.display = 'none';
          var errorConsole = self.shadowRoot.querySelector('#error-console');
          errorConsole.style.display = 'none';
          var container = self.shadowRoot.querySelector('.container');
          container.style.height = '100%';
          container.style.marginBottom = '0';

          self.dispatchEvent(new CustomEvent('initialized', { bubbles: true, composed: true, detail: {} }));
        }
      }
    }

    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) {
        return '0 Bytes';
      }

      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

      const i = Math.floor(Math.log(bytes) / Math.log(k));
      const size = parseFloat((bytes / Math.pow(k, i)).toFixed(dm));

      if (!isNaN(size)) {
        return `${size} ${sizes[i]}`;
      }
    }


    function formatTime(milliseconds) {
      const seconds = Math.floor(milliseconds / 1000) % 60;
      const minutes = Math.floor(milliseconds / (1000 * 60)) % 60;

      const formattedTime = [];

      if (minutes > 0) {
        formattedTime.push(minutes + (minutes === 1 ? ' minute' : ' minutes'));
      }
      if (seconds >0){
        formattedTime.push(seconds + (seconds === 1 ? ' second' : ' seconds'));
      }
      return formattedTime.join(', ');
    }
    // Register custom element definition using standard platform API
    window.customElements.define(SwevaVisualizationContainer.is, SwevaVisualizationContainer);
  </script>
</dom-module>