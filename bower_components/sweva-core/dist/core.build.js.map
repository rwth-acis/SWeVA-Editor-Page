{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/core/compilers/assemblyScriptCompiler.js","app/core/compilers/compiler.js","app/core/composables/composable.js","app/core/composables/composition.js","app/core/composables/module.js","app/core/core.js","app/core/errors/ExecutionError.js","app/core/errors/compileError.js","app/core/errors/definitionError.js","app/core/errors/errorManager.js","app/core/errors/swevaError.js","app/core/execution/composableLoader.js","app/core/execution/executionManager.js","app/core/execution/supportLibrary.js","app/core/network/dataProcessingDevice.js","app/core/network/potentialOffloadingTarget.js","app/core/offloading/availableOffloadingResources.js","app/core/offloading/offloadingDecision.js","app/core/offloading/offloadingTarget.js","app/core/runners/assemblyScriptRunner.js","app/core/runners/runner.js","app/core/swevaScript/swevaScript.js","node_modules/ajv/lib/ajv.js","node_modules/ajv/lib/cache.js","node_modules/ajv/lib/compile/_rules.js","node_modules/ajv/lib/compile/equal.js","node_modules/ajv/lib/compile/formats.js","node_modules/ajv/lib/compile/index.js","node_modules/ajv/lib/compile/resolve.js","node_modules/ajv/lib/compile/rules.js","node_modules/ajv/lib/compile/schema_obj.js","node_modules/ajv/lib/compile/util.js","node_modules/ajv/lib/dotjs/allOf.js","node_modules/ajv/lib/dotjs/anyOf.js","node_modules/ajv/lib/dotjs/dependencies.js","node_modules/ajv/lib/dotjs/enum.js","node_modules/ajv/lib/dotjs/format.js","node_modules/ajv/lib/dotjs/items.js","node_modules/ajv/lib/dotjs/maxItems.js","node_modules/ajv/lib/dotjs/maxLength.js","node_modules/ajv/lib/dotjs/maxProperties.js","node_modules/ajv/lib/dotjs/maximum.js","node_modules/ajv/lib/dotjs/minItems.js","node_modules/ajv/lib/dotjs/minLength.js","node_modules/ajv/lib/dotjs/minProperties.js","node_modules/ajv/lib/dotjs/minimum.js","node_modules/ajv/lib/dotjs/multipleOf.js","node_modules/ajv/lib/dotjs/not.js","node_modules/ajv/lib/dotjs/oneOf.js","node_modules/ajv/lib/dotjs/pattern.js","node_modules/ajv/lib/dotjs/properties.js","node_modules/ajv/lib/dotjs/ref.js","node_modules/ajv/lib/dotjs/required.js","node_modules/ajv/lib/dotjs/uniqueItems.js","node_modules/ajv/lib/dotjs/validate.js","node_modules/ajv/lib/refs/json-schema-draft-04.json","node_modules/as-bind/dist/as-bind.cjs.js","node_modules/async-mqtt/index.js","node_modules/available-typed-arrays/index.js","node_modules/base64-js/index.js","node_modules/bl/bl.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/builtin-status-codes/browser.js","node_modules/call-bind/callBound.js","node_modules/call-bind/index.js","node_modules/clone/clone.js","node_modules/core-util-is/lib/util.js","node_modules/d/auto-bind.js","node_modules/d/index.js","node_modules/duplexify/index.js","node_modules/end-of-stream/index.js","node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js","node_modules/es5-ext/array/#/clear.js","node_modules/es5-ext/array/#/e-index-of.js","node_modules/es5-ext/array/from/index.js","node_modules/es5-ext/array/from/is-implemented.js","node_modules/es5-ext/array/from/shim.js","node_modules/es5-ext/function/is-arguments.js","node_modules/es5-ext/function/is-function.js","node_modules/es5-ext/function/noop.js","node_modules/es5-ext/math/sign/index.js","node_modules/es5-ext/math/sign/is-implemented.js","node_modules/es5-ext/math/sign/shim.js","node_modules/es5-ext/number/is-nan/index.js","node_modules/es5-ext/number/is-nan/is-implemented.js","node_modules/es5-ext/number/is-nan/shim.js","node_modules/es5-ext/number/to-integer.js","node_modules/es5-ext/number/to-pos-integer.js","node_modules/es5-ext/object/_iterate.js","node_modules/es5-ext/object/assign/index.js","node_modules/es5-ext/object/assign/is-implemented.js","node_modules/es5-ext/object/assign/shim.js","node_modules/es5-ext/object/copy.js","node_modules/es5-ext/object/create.js","node_modules/es5-ext/object/for-each.js","node_modules/es5-ext/object/is-object.js","node_modules/es5-ext/object/is-value.js","node_modules/es5-ext/object/keys/index.js","node_modules/es5-ext/object/keys/is-implemented.js","node_modules/es5-ext/object/keys/shim.js","node_modules/es5-ext/object/map.js","node_modules/es5-ext/object/normalize-options.js","node_modules/es5-ext/object/primitive-set.js","node_modules/es5-ext/object/set-prototype-of/index.js","node_modules/es5-ext/object/set-prototype-of/is-implemented.js","node_modules/es5-ext/object/set-prototype-of/shim.js","node_modules/es5-ext/object/valid-callable.js","node_modules/es5-ext/object/valid-value.js","node_modules/es5-ext/string/#/contains/index.js","node_modules/es5-ext/string/#/contains/is-implemented.js","node_modules/es5-ext/string/#/contains/shim.js","node_modules/es5-ext/string/is-string.js","node_modules/es6-iterator/array.js","node_modules/es6-iterator/for-of.js","node_modules/es6-iterator/get.js","node_modules/es6-iterator/index.js","node_modules/es6-iterator/is-iterable.js","node_modules/es6-iterator/string.js","node_modules/es6-iterator/valid-iterable.js","node_modules/es6-map/index.js","node_modules/es6-map/is-implemented.js","node_modules/es6-map/is-native-implemented.js","node_modules/es6-map/lib/iterator-kinds.js","node_modules/es6-map/lib/iterator.js","node_modules/es6-map/polyfill.js","node_modules/es6-symbol/index.js","node_modules/es6-symbol/is-implemented.js","node_modules/es6-symbol/is-symbol.js","node_modules/es6-symbol/lib/private/generate-name.js","node_modules/es6-symbol/lib/private/setup/standard-symbols.js","node_modules/es6-symbol/lib/private/setup/symbol-registry.js","node_modules/es6-symbol/polyfill.js","node_modules/es6-symbol/validate-symbol.js","node_modules/event-emitter/index.js","node_modules/events/events.js","node_modules/ext/global-this/implementation.js","node_modules/ext/global-this/index.js","node_modules/ext/global-this/is-implemented.js","node_modules/foreach/index.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/get-intrinsic/index.js","node_modules/has-symbols/index.js","node_modules/has-symbols/shams.js","node_modules/has-tostringtag/shams.js","node_modules/has/src/index.js","node_modules/https-browserify/index.js","node_modules/ieee754/index.js","node_modules/in-array/index.js","node_modules/inherits/inherits_browser.js","node_modules/is-arguments/index.js","node_modules/is-generator-function/index.js","node_modules/is-typed-array/index.js","node_modules/isarray/index.js","node_modules/js-tokens/index.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/mqtt-packet/constants.js","node_modules/mqtt-packet/generate.js","node_modules/mqtt-packet/mqtt.js","node_modules/mqtt-packet/numbers.js","node_modules/mqtt-packet/packet.js","node_modules/mqtt-packet/parser.js","node_modules/mqtt-packet/writeToStream.js","node_modules/mqtt/lib/client.js","node_modules/mqtt/lib/connect/index.js","node_modules/mqtt/lib/connect/tcp.js","node_modules/mqtt/lib/connect/tls.js","node_modules/mqtt/lib/connect/ws.js","node_modules/mqtt/lib/connect/wx.js","node_modules/mqtt/lib/store.js","node_modules/mqtt/lib/validations.js","node_modules/once/once.js","node_modules/os-browserify/browser.js","node_modules/path-browserify/index.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/node_modules/safe-buffer/index.js","node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","node_modules/readable-stream/readable-browser.js","node_modules/reinterval/index.js","node_modules/safe-buffer/index.js","node_modules/stream-http/index.js","node_modules/stream-http/lib/capability.js","node_modules/stream-http/lib/request.js","node_modules/stream-http/lib/response.js","node_modules/stream-http/node_modules/readable-stream/errors-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_transform.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/from-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/state.js","node_modules/stream-http/node_modules/readable-stream/readable-browser.js","node_modules/stream-shift/index.js","node_modules/timers-browserify/main.js","node_modules/type/function/is.js","node_modules/type/lib/resolve-exception.js","node_modules/type/lib/safe-to-string.js","node_modules/type/lib/to-short-string.js","node_modules/type/object/is.js","node_modules/type/plain-function/ensure.js","node_modules/type/plain-function/is.js","node_modules/type/prototype/is.js","node_modules/type/string/coerce.js","node_modules/type/value/ensure.js","node_modules/type/value/is.js","node_modules/url/url.js","node_modules/url/util.js","node_modules/util-deprecate/browser.js","node_modules/util/support/isBufferBrowser.js","node_modules/util/support/types.js","node_modules/util/util.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_readable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_writable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/websocket-stream/stream.js","node_modules/websocket-stream/ws-fallback.js","node_modules/which-typed-array/index.js","node_modules/wrappy/wrappy.js","node_modules/xtend/immutable.js","../../node_modules/systeminformation/lib/audio.js","../../node_modules/systeminformation/lib/battery.js","../../node_modules/systeminformation/lib/bluetooth.js","../../node_modules/systeminformation/lib/cpu.js","../../node_modules/systeminformation/lib/docker.js","../../node_modules/systeminformation/lib/dockerSocket.js","../../node_modules/systeminformation/lib/filesystem.js","../../node_modules/systeminformation/lib/graphics.js","../../node_modules/systeminformation/lib/index.js","../../node_modules/systeminformation/lib/internet.js","../../node_modules/systeminformation/lib/memory.js","../../node_modules/systeminformation/lib/network.js","../../node_modules/systeminformation/lib/osinfo.js","../../node_modules/systeminformation/lib/printer.js","../../node_modules/systeminformation/lib/processes.js","../../node_modules/systeminformation/lib/system.js","../../node_modules/systeminformation/lib/usb.js","../../node_modules/systeminformation/lib/users.js","../../node_modules/systeminformation/lib/util.js","../../node_modules/systeminformation/lib/virtualbox.js","../../node_modules/systeminformation/lib/wifi.js","../../node_modules/systeminformation/package.json"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1qDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC58CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC/kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"core.build.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\n//var {asc, assemblyscript} = require('../../../node_modules/assemblyscript/dist/sdk.js');\n//var AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\n//var AsBindTransform = require('../../../node_modules/as-bind/dist/transform.cjs');\nvar Runner = require('../../core/runners/runner.js');\nvar Compiler = require('../../core/compilers/compiler.js');\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\nvar Composable = require('../../core/composables/composable.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar CompileError = require('../../core/errors/compileError.js');\nconst DefinitionError = require(\"../../core/errors/ExecutionError.js\");\nconst offloadingDecision = require(\"../offloading/offloadingDecision\");\n\n//var AssemblyScriptGetterTransform = require('./assemblyScriptGetterTransform.js');\n\n/** include web-worker library for Nodejs **/\n\nif(typeof Worker === 'undefined') {\n    console.log(\"Loading Node worker module\");\n    var WorkerNodeJS = require('../../../node_modules/web-worker/cjs/node');\n}\n\n\n/**\n * The AssemblyScriptCompiler supports strict TypeScript\n *\n * @constructor\n * @extends Compiler\n *\n */\nfunction AssemblyScriptCompiler(supportLib) {\n    this.worker = null;\n    this.internalGetterPrefix = \"_internal_get_\";\n    this.supportLibraryDeclares = this.generateSupportLibraryDeclares(supportLib);\n    this.supportLibraryDocumentation = \"The lib namespace contains all function from the support library.\\n\" +\n        \"synchronous functions return their result immediately, while the callback for asynchronous functions is called after all currently running AssemblyScript code is finished.\\n\" +\n        \"Callback functions can have less parameters than the listed parameters, in which case only the first parameters are passed.\\n\" +\n        \"Functions:\\n\";\n    this.resolveCompile = null;\n}\n\n//inherit properties\nAssemblyScriptCompiler.prototype = Object.create(Compiler.prototype);\nAssemblyScriptCompiler.prototype.constructor = AssemblyScriptCompiler;\n\n/**\n * generates declare statements necessary, to access JavaScript functions from AssemblyScript\n * additionally the documentation is generated\n * @param supportLib\n */\nAssemblyScriptCompiler.prototype.generateSupportLibraryDeclares = function (supportLib) {\n    let docs = \"\";\n    let declares = \"namespace lib {\\n\";\n    for(let funcName in supportLib.functions) {\n        let returnSig = supportLib.functions[funcName].languageSpecific.typescript.returnSig || \"void\";\n        let paramSig = supportLib.functions[funcName].languageSpecific.typescript.parameterSig;\n        //callback function name is first parameter for asynchronous functions\n        if(supportLib.functions[funcName].async) {\n            paramSig = \"callback: string | null\" + (typeof paramSig !== undefined ? \", \"+paramSig : \"\");\n            returnSig = \"void\";\n        }\n        docs += funcName+\":\\n\"+\n            \"  Description: \"+supportLib.functions[funcName].description+\"\\n\"+\n            \"  Parameters: \\\"\"+paramSig+\"\\\"\\n\"+\n            \"  \"+(supportLib.functions[funcName].async?\n                \"Async function: callback with signature \\\"\"+supportLib.functions[funcName].languageSpecific.typescript.returnSig+\"\\\" required\":\n                \"Sync function: returns \\\"\"+returnSig+\"\\\"\")+\n            \"\\n\";\n        declares += \"export declare function \" + funcName + \"(\" + paramSig + \"):\" + returnSig + \";\\n\";\n    }\n    declares += \"}\";\n    this.supportLibraryDocumentation = docs;\n    console.log(\"Support functions:\");\n    console.log(this.supportLibraryDocumentation);\n    console.log(declares)\n    return declares;\n}\n\nAssemblyScriptCompiler.prototype.setup = async function () {\n    var self = this;\n\n    if(!this.setupCompleted) {\n        return new Promise((resolve) => {\n            console.log(\"Loading AssemblyScript compiler\");\n\n            this.initWorker();\n\n            this.worker.onmessage = function (e) {\n                console.log('msg to worker');\n                console.log(e.data);\n                switch (e.data.type) {\n                    case \"setupComplete\":\n                        console.log(\"setup complete\")\n                        self.setupCompleted = true;\n                        resolve();\n                        break;\n                    case \"compileError\":\n                    case \"compileResult\":\n                        if(self.resolveCompile != null) {\n                            self.resolveCompile(e.data);\n                        }\n                        break;\n                }\n            }\n        });\n    }\n}\n\nAssemblyScriptCompiler.prototype.initWorker = function() {\n    if(typeof this.worker != 'undefined' && this.worker != null) {\n        this.worker.terminate();\n    }\n\n    //different path for NodeJS\n    if(sweva.inBrowser) {\n        console.log(\"Load worker for webbrowser\");\n        this.worker = new Worker('/node_modules/sweva-core/app/core/compilers/assemblyScriptCompilerWorker.js');\n    } else {\n        console.log(\"Load worker for NodeJS\");\n        this.worker = new WorkerNodeJS('app/core/compilers/assemblyScriptCompilerWorker.js');\n    }\n}\n// MA\nAssemblyScriptCompiler.prototype.compile = async function (module) {\n\n    const self = this;\n    while (this.currentlyCompiling) {\n        new Promise(resolveWait => setTimeout(resolveWait, 1));\n    }\n    this.currentlyCompiling = true;\n\n    //load compiler\n    await this.setup();\n\n    let doneCompiling = false;\n    let offloading = false;\n    let intervalID;\n    let odList =sweva.ExecutionManager.getODList(); //todo: user input\n    console.log(\"odList in ASC compiler = \",odList);\n\n    let endCPU = 0;\n    let cpuMonitor=0;\n    // initial mem / battery check\n    offloading = await offloadingDecision(odList);\n    console.log('initial offloading decision = ',offloading);\n    if (offloading) {\n        // optimization: speed is key we do this after resolving promise\n        //clearInterval(intervalID);\n        //abort running compilation\n        return ('offloading');\n    }\n    let startCPU =performance.now();\n    return await Promise.race([\n        //monitoring the compilation process\n        new Promise( async (resolve) => {\n            console.log('Begin periodic monitoring execution...');\n            // interval check\n            intervalID = setInterval(async () => {\n                endCPU = performance.now();\n                cpuMonitor = ((endCPU - startCPU)/5000)*100;\n                //console.log('CPU TIME= ', cpuMonitor);\n                if (cpuMonitor > odList[0]) {\n                    console.log(\"offloadingOutput$ Monitoring = CPU limit exceeded\");\n                    resolve('offloading');\n                }\n                offloading = await offloadingDecision(odList);\n                console.log('periodic offloading decision = ', offloading);\n                if (offloading) {\n                    // optimization: speed is key we do this after resolving promise\n                    //clearInterval(intervalID);\n                    //abort running compilation\n                    resolve('offloading');\n                }\n            }, 500);\n        }),\n\n        // compiling the module\n        new Promise((resolve) => {\n\n            this.resolveCompile = resolve;\n            doneCompiling = true;\n            this.worker.postMessage({type: \"compile\", source: self.prepareSourceCode(module.source)});\n\n        })\n\n    ]).\n    then((wr) => {\n\n        let workerResult = wr;\n\n        clearInterval(intervalID); //clear monitoring interval if no offloading necessary\n        console.log('workerResult');\n        console.log(workerResult);\n        this.currentlyCompiling = false;\n\n        this.resolveCompile = null;\n\n        if (workerResult.type === \"compileResult\") {\n            console.log('offloadingOutput$ Offloading not needed. Proceed as normal');\n            return workerResult;\n        } else if (workerResult === 'offloading') {\n            //todo: offloading callback\n            this.initWorker();\n            console.log(\"offloadingOutput$ Offloading necessary. Callback triggered\");\n            return 'offloading'; //todo: is String a good DT for return ?\n        } else\n            throw new CompileError(workerResult.message, module.context);  // Compiler Error handling\n\n    });\n\n}\n\n\nAssemblyScriptCompiler.prototype.prepareSourceCode = function(source) {\n    let getters = this.generateGlobalGetters(source);\n    let sourceStr = source.join(\"\\n\");\n    return this.supportLibraryDeclares + sourceStr + getters;\n}\n\nAssemblyScriptCompiler.prototype.generateGlobalGetters = function(source) {\n    let getters = \"\";\n    for(let line in source) {\n        if(source.includes(this.internalGetterPrefix)) {\n            throw new CompileError(\"Do not use \"+this.internalGetterPrefix+\" for names in your source, as it is reserved for internal use.\", \"compileError\");\n        }\n        else if(source[line].indexOf(\"export var\") === 0) {\n            let tmp = source[line].split('=')[0].split(':');\n            let type = \"anyref\";\n            if(tmp.length >= 2)\n                type = tmp[1].split(/[\\s=]+/).filter(x => x !== \"\")[0];\n            else\n                throw new CompileError(\"Exported variables require an explicit type! \\n\\\"\"+source[line]+\"\\\" does not contain a type.\", \"compileError\");\n            tmp = tmp[0].split(/[\\s=]+/).filter(x => x !== \"\");\n            let name = tmp[tmp.length-1];\n            getters += \"export function \"+this.internalGetterPrefix+name+\"():\"+type+\" { return \"+name+\"; }\\n\";\n        }\n    }\n\n    return getters;\n}\n\nmodule.exports = AssemblyScriptCompiler;","'use strict';\n\n/**\n * The compiler loads the necessary resources for compilation of a language, compiles code and returns the resulting binary.\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\n * \n * The setup needs to be done only once, while the execution can be repeated on different data.\n * Additionally the setup should only be called, when the compiler is needed, because some dependencies for compiling can be very large\n * \n * This is a default implementation, returning the input source as the compiled code. It can be used for interpreted languages.\n *\n * @param {SupportLibrary} supportLibrary - source code to compile\n * @constructor\n */\nfunction Compiler(supportLibrary) {\n    /**\n     * Determines, if dependencies are loaded.\n     * @name Compiler#setupCompleted\n     * @type {boolean}\n     */\n    this.setupCompleted = false;\n\n    /**\n     * Documentation for functions in support library - should include specifics on language syntax\n     * Available after Compiler#setup() has been called.\n     * @name Compiler#setupCompleted\n     * @type {string}\n     */\n    this.supportLibraryDocumentation = \"\";\n}\n\n/**\n * Compile the provided source code\n * @param {module} source - source code to compile\n * @return {object} containing binaryData and optionally other properties of specific compilers\n */\nCompiler.prototype.compile = function (source) {\n    return source;\n}\n   \n/**\n * Loads dependencies\n */\nCompiler.prototype.setup = async function () {\n    if(!this.setupCompleted) {\n        this.setupCompleted = true;\n    }\n}\n\n\nmodule.exports = Compiler","'use strict';\n\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar Clone = require('../../../node_modules/clone/clone.js');\n\n/**\n * Composables process data. They can be linked into networks.\n * @abstract\n * @constructor\n */\nfunction Composable() {\n}\n/**\n * A definition of a JSON object.\n * @see {@link http://json-schema.org/documentation.html}\n * @typedef {Object} JSONSchema\n */\n\n/**\n * The initalization object with optional properties to initialize composables.\n * @typedef {Object} composableInitalizer\n * @property {string} [name=someComposable] - The name of the composable.\n * @property {string} [type=module] - The type of the composable: 'module' or 'composition'.\n * @property {JSONSchema} [dataInSchema=null] - The schema of the expected data object received from other composables.\n * @property {JSONSchema} [dataOutSchema=null] - The schema of the data object passed on to later composables.\n * @property {JSONSchema} [inputSchema=null] - The schema of the input object received at the beginning of exection.\n * @property {Array.<string>} [dataInNames=['data']] - The names of the expected properties of the received data object.\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\n * Multiple properties are needed, if you want to receive data from multiple other composables.\n *\n * @property {Array.<string>} [dataOutNames=['result']] - The names of the expected properties of the produced data object.\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\n * Multiple properties are needed, if you want to send data to multiple other composables.\n *\n * @property {Array.<string>} [inputNames=[]] - The names of the expected properties of the input object.\n * If there is only one element, the array is ignored and the whole input object is taken (no property names needed).\n */\n\n/** Initializes the object with a property object.\n  * Not defined Properties will get a default value.\n *  @protected\n *  @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n */\nComposable.prototype.initialize = function (initializationObject) {\n    this.initializeProperty(initializationObject, 'name', 'someComposable');\n    this.initializeProperty(initializationObject, 'type', 'module');\n    this.initializeProperty(initializationObject, 'dataInSchema', null);\n    this.initializeProperty(initializationObject, 'dataOutSchema', null);\n    this.initializeProperty(initializationObject, 'inputSchema', null);\n\n    this.initializeProperty(initializationObject, 'dataInNames', []);\n    this.initializeProperty(initializationObject, 'dataOutNames', []);\n    this.initializeProperty(initializationObject, 'inputNames', []);\n\n    /**\n     * Amount of expected properties for the received data object.\n     * @name Composable#dataIn\n     * @type {number}\n     */\n    this.dataIn = this.dataInNames.length;\n\n    /**\n    * Amount of expected properties for the produced data object.\n    * @name Composable#dataOut\n    * @type {number}\n    */\n    this.dataOut = this.dataOutNames.length;\n\n    /**\n    * Amount of expected properties for the received input object\n    * @name Composable#inputIn\n    * @type {number}\n    */\n    this.inputIn = this.inputNames.length;\n\n    /**\n    * The context of the composable used for error messages.\n    * @name Composable#context\n    * @type {number}\n    */\n    this.context = this.constructor.name + '[' + this.name + ']';\n}\n\n/**\n * Helper function to initialize internal variables. Sets also default values.\n * @protected\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\n * @param {string} defaultValue - A default value is set, if initializationObject does not contain such a property key.\n */\nComposable.prototype.initializeProperty = function (initializationObject,\n    property, defaultValue) {\n    if (initializationObject.hasOwnProperty(property)) {\n        var obj = initializationObject[property];\n        if (typeof obj === 'object') {\n            if (Array.isArray(obj)) {\n                if (obj.length == 0) {\n                    this[property] = defaultValue;\n                    return;\n                }\n            }\n            else if (Object.keys(obj).length == 0){\n                this[property] = defaultValue;\n                return;\n            }\n        }\n        this[property] = initializationObject[property];\n    } else {\n        this[property] = defaultValue;\n    }\n}\n\n/**\n * Helper function to initialize internal functions. Sets also default values.\n * @protected\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\n * @param {number} expectedArgumentsCount - The amount of arguments the expected function needs to have. On mismatch an error is thrown.\n * @param {function} defaultValue - A default value is set, if initializationObject does not contain such a property key.\n */\nComposable.prototype.initializeFunction = function (initializationObject,\n    property, expectedArgumentsCount, defaultValue) {\n    if (initializationObject.hasOwnProperty(property)) {\n        //check if it is really a function\n        if (typeof initializationObject[property] === 'function') {\n            //the expected functions (which can be defined by the composable creators) have a fixed signature (arguments),\n            //so check here for validation.\n            if (initializationObject[property].length >= expectedArgumentsCount) {\n                this[property] = initializationObject[property];\n            }\n            else {\n                sweva.ErrorManager.error(\n                    new DefinitionError('function \"' + property + '\" requires at least ' +\n                    expectedArgumentsCount + ' arguments, but provides only ' +\n                    initializationObject[property].length,\n                    this.context, initializationObject[property]));\n            }\n        }\n        else if (initializationObject[property] == null) {\n            // for now ignore, as some functions are optional\n        }\n        else {\n            sweva.ErrorManager.error(\n                   new DefinitionError('\"' + property + '\" is reserved for functions, but not defined as one',\n                   this.context, initializationObject[property]));\n        }\n    }\n    else {\n        this[property] = defaultValue;\n    }\n}\n/**\n * Clones the current composable and overwrites/adds all the properties specified in an extender object.\n * This allows some sort of composable inheritance.\n * @this Composable\n * @param {Composable} extender - The partial composable from which to take the new values.\n * @returns {Composable} The cloned and extended composable object.\n */\nComposable.prototype.extendWith = function (extender) {\n    var cloned = Clone(this);\n    for (var key in extender) {\n        //we don't want to clone 'extends' as it is an indicator, that a composable wants to extend another. I.e. What we are doing here :)\n        if (extender.hasOwnProperty(key) && key != 'extends') {\n            cloned[key] = extender[key];\n        }\n    }\n    return cloned;\n}\n/**\n * Updates the context during the execution. It uses the parent's context and the alias, the parent has given this composable.\n * looks like: Composition[composition1].Module[module1]\n * @protected\n * @param {string} context - The context of the parent.\n * @param {string} alias - The alias (name) used in the parent for this composable.\n * @returns {string} Updated context.\n */\nComposable.prototype.getNewContext = function (context, alias) {\n    if (typeof context === 'string') {\n        //alias is optional, so check if it is defined\n        if (typeof alias !== 'string') {\n            alias = '';\n        }\n        else {\n            alias = ': ' + alias;\n        }\n        return context + '.' + this.constructor.name + '[' + this.name + alias + ']';\n    }\n    return this.context;\n}\n/**\n * Validates, if a given object has the expected structure (typecheck) compatible to this composable.\n * If available, it uses the provided JSON schema, otherwise (noch schmema available) it only checks, if the object has all required property keys. Defined by the *Names arrays (see {@link composableInitalizer}).\n * \n * @param {string} type - Type of object, needed to select the correct type definition. Use 'dataIn', 'dataOut' , 'input' respectively.\n * @param {Object} obj - Object, that should be validated.\n * @returns {boolean} - True, if the object is compatible to this composable regarding the given type.\n */\nComposable.prototype.validateTypes = function (type, obj) {\n    var typeNames = this[type + 'Names'];\n    var typeSchema = this[type + 'Schema'];\n    \n    //if properties are all present and a schema is provided, we can perform a more detailed check\n    if (typeSchema !== null) {\n        //use the validator library on the object\n        try {\n            var valid = sweva.Ajv.validate(typeSchema, obj);\n            if (!valid) {\n                sweva.ErrorManager.error(new ExecutionError('Object does not match the given ' + type + 'Schema: ' + sweva.Ajv.errorsText(sweva.Ajv.errors),\n                    this.context, obj));\n                return false;\n            }\n        } catch(err) {\n            /*\n            ignore, because an invalid schema like generated by AssemblyScript is generated from the source and\n            already matches the input/output data. Consider adding the custom types to the validator, if this is not the\n            case for future added languages.\n             */\n        }\n    }\n\n    return true;\n}\n/**\n * Function to start the data processing. Here only a dummy is defined.\n * @param {Object} data - Tha data object received.\n * @param {Object} input - The input object received.\n * @return {Promise<number>} - The processed data.\n */\nComposable.prototype.execute = function (data, input) {\n    return new Promise(function (resolve, reject) {\n        resolve(0);\n    });\n}\nmodule.exports = Composable;","'use strict';\n\nvar Composable = require('../../core/composables/composable.js');\nvar Module = require('../../core/composables/module.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\n\n/**\n * Represents how a composable is linked to another\n * @typedef {Object} linkType\n * @property {string} to - The alias/name of the target composable (i.e. under which key it is defined in the composables dictionary of the composition)\n * @property {string|Object.<string,string>} mapping - How dataOut and dataIn of two composables are mapped to each other.\n * If no mapping is specified, the whole dataOut object is taken as the dataIn object.\n * If a string is specified as a value, it is mapped to the appropriate dataIn property.\n * If a dictionary is specified, the key represents the dataOut property and thevalue the dataIn property it is mapped to.\n * All string values must be using the given values of the dataInNames and dataOutNames arrays defined in the composable.\n */\n\n/**\n * A user defineable function to map the input object of the composition to the input object of individual composables.\n * Basically the function is called for each composable and the return value is then used as its input object.\n * For example you can use an input object, where you specify in detail for every composable the value, then you could simply\n * return input[composableName];\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapInputFunction\n * @param {Object} input - The input object given to the composition.\n * @param {string} composableName - The name of the composable requesting an input object.\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\n * @param {Object} libs - A library object provides access to libs from within the function.\n * @returns {Object} A value to use for the requesting composable as the input object.\n */\n\n/**\n * A user defineable function to map the data object of the composition to the data object of individual composables.\n * Basically the function is called for each composable and the return value is then used as its data object.\n * For example you can use a data object, where you specify in detail for every composable the value, then you could simply\n * return data[composableName];\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapDataInFunction\n * @param {Object} data - The data object given to the composition.\n * @param {string} composableName - The name of the composable requesting a data object.\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\n * @param {Object} libs - A library object provides access to libs from within the function.\n * @returns {Object} A value to use for the requesting composable as the data object.\n */\n\n/**\n * A user defineable function to transform the resulting data object of the data processing pipeline.\n * You could for example add additional properties or remove some, convert values etc.\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapDataOutFunction\n * @param {Object} output - The data object produced by the composables without outgoing links (end of data processing).\n * @returns {Object} A value the composition returns as the dataprocessing result.\n */\n\n\n/**\n * The initalization object with optional properties to initialize composables.\n * @typedef {composableInitalizer} compositionInitalizer\n * @property {Object.<string,string>} [composables={}] - A dictionary of all composables used by the composition. \n * The key represents the internal alias, the value represents \n * the composable name, which is used to load the composable information.\n * \n * @property {Object.<string, Array.<linkType>>} [links={}] - A dictionary describing an edge list of how the composables are linked.\n * The key describes the origin composable, the value describes an array of target composables with mapping information of the data properties.\n * @property {Composition~mapInputFunction} [mapInput] - A function to map the input object of the composition to the input object of individual composables.\n * The default requires an input object, where each property corresponds to a composable alias/name and maps the value of the property to this composable input.\n * @property {Composition~mapDataInFunction} [mapDataIn] - A function to map the data object of the composition to the data object of individual composables.\n * The default requires a data object, where each property corresponds to a composable alias/name and maps the value of the property to this composable data.\n * @property {Composition~mapDataOutFunction} [mapDataOut] - A function to transform the resulting data object of the composition, before making it available.\n * The default does not change the output object.\n */\n\n/**\n * A composition can consist of multiple other compositions or composables.\n * It orchistrates the execution of the composables.\n * @constructor\n * @extends Composable\n * @param {compositionInitalizer} initializationObject - The object with optional properties for the composition.\n * \n */\nfunction Composition(initializationObject, manager) {\n    this.manager = manager;\n\n    this.initializeProperty(initializationObject, 'composables', {});\n    this.initializeProperty(initializationObject, 'links', {});\n\n    this.initializeFunction(initializationObject, 'mapInput', 4, function (input, composableName, composables, libs) {\n        if (input.hasOwnProperty(composableName)) {\n            return input[composableName];\n        }\n        return null;\n    });\n\n    this.initializeFunction(initializationObject, 'mapDataIn', 4, function (data, composableName, composables, libs) {\n        if (data.hasOwnProperty(composableName)) {\n            return data[composableName];\n        }\n        return null;\n    });\n\n    this.initializeFunction(initializationObject, 'mapDataOut', 2, function (output, libs) {\n        return output;\n    });\n    //call to the parent class initalization function\n    this.initialize(initializationObject);\n\n    /**\n    * Indicates, if the composition is ready to use. This is important, as required composables might need to be loaded first.\n    * @protected\n    * @name Composition#isReady\n    * @type {boolean}\n    */\n    this.isReady = false;\n}\n//inherit properties\nComposition.prototype = Object.create(Composable.prototype);\n\n/**\n * This function starts to recursively load composables required by this composition.\n * See {@link ComposableLoader} for more details on he loading process.\n * When finished all required composables are in memory and can be used.\n * As loading is async it returns a promise. \n * @returns {Promise<void>} An empty promise, signaling that everything was loaded.\n */\nComposition.prototype.loadComposables = function () {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        //collects an array of loading promises, which is then filled\n        var promises = [];\n        for (var key in self.composables) {\n            if (self.composables.hasOwnProperty(key)) {\n                //for each required composable the composable is loaded using the specified name of it\n                //the name itself acts as a part of a URL\n                //a reference to the composables dictionary of the composition is passed, so the\n                //string values (names) of the required compositions are later replaced with the comosition objects,\n                //which can then be used\n                if (typeof self.composables[key] === 'string') {\n                    promises.push(sweva.ComposableLoader.load(self.composables[key], self.composables, key));\n                }\n                else { //otherwise create from given object directly\n                    var type = self.composables[key].type;\n                    if(type=='module'){\n                        self.composables[key] = new Module(self.composables[key], self.manager);\n                    }\n                    else {\n                        self.composables[key] = new Composition(self.composables[key], self.manager);\n                    }\n                    \n                }\n                \n            }\n        }\n        //invoke all promises and wait for them to finish\n        Promise.all(promises).then(function () {\n            //when all promises are finished, all components are loaded, so the composition is ready to be used\n            self.isReady = true;\n\n            //important: as we are dealing here with async operations, one might try to execute the composition, before\n            //it is ready to be used. In this case the execution is delayed and indicated (wantsToExecute=true)\n            //now if the loading is finished, it can directly start the execution directly itself, using the provided callback\n            //no polling needed :)\n            if (self.wantsToExecute) {\n                self.wantsToExecute = false;\n                self.executeStarterCallback();\n            }\n            \n           \n            //ok all loaded, now we can analyze graph and check for compatibility\n            self.analyzeLinkGraph();\n           \n            //indicate to the outside, that we are done with everything and the composition can be used\n            resolve();\n        })\n        .catch(function (error) {\n            sweva.ErrorManager.error(\n                       new ExecutionError('Could not load all composables: ' + error,\n                       self.context, self.composables));\n            \n        });\n    });\n}\n/**\n * Checks, if all the data a composable requires is already available.\n * As composables are executed in a graph, some composables depend on the calculations of others and have to wait for the data.\n * \n * For this purpose, the {@link Composable#dataIn} property is used as a count, that has to be reached\n * by the amount of properties stored for this composable in {@links Composition#parameters}.\n * @protected\n * @param {string} composableName - The alias of the composable object, for which the check should be performed.\n * @returns {boolean} true, if all data required for the composable is available.\n */\nComposition.prototype.hasParameters = function (composableName) {\n    //how many parameters does the composable need?\n    \n    var parametersNeeded = [];\n    if(typeof this.composables[composableName].dataInConnected !== 'undefined') {\n        parametersNeeded = Object.keys(this.composables[composableName].dataInConnected);\n    }\n    \n    \n    //if it does not need any, we are good here\n    if (parametersNeeded.length === 0) {\n        return true;\n    }\n    \n    //if we are still here, it needs at least one\n    if (this.parameters.hasOwnProperty(composableName)) {\n       \n        \n        //not enough\n        for (var i = 0; i < parametersNeeded.length; i++) {\n            var parameter = parametersNeeded[i];\n            \n            if (typeof this.parameters[composableName][parameter] === 'undefined') {\n                return false;\n            }\n        }\n        return true;\n        \n    }\n    return false;\n}\n\n/**\n * Adds new data to the available pool other composables use.\n * This allows dependant composables to fetch the data and start execution.\n * It saves the data as a subkey of a subkey of {@links Composition#parameters}:\n * this.parameters[composable][property] = value\n * @protected\n * @param {string} composableName - The alias of the composable object for which the data is intended.\n * @param {string} property - The property name to save the data as, the value must correspond to a value defined\n * in {@links Composable#dataInNames} (we need correct mapping).\n * @param {Object|boolean|string|number} value - The value of the data to add.\n */\nComposition.prototype.addParameter = function (composableName, property, value) {\n    //if no key for composable present, create one\n    if (!this.parameters.hasOwnProperty(composableName)) {\n        this.parameters[composableName] = {};\n    }\n\n    this.parameters[composableName][property] = value;\n}\n\n/**\n * Resets the composition, so it can be executed again.\n * @protected\n */\nComposition.prototype.reset = function () {\n    this.parameters = {};    \n    this.output = {};\n    this.unlcearedComposables = [];\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            this.unlcearedComposables.push({\n                composable: key,\n                cleared: false\n            });\n        }\n    }\n    \n}\n\n/**\n * Checks, if the composable graph of the composition contains cycles (end therefore is not a DAG).\n * @protected\n * @param {Array.<string>} startingNodeArray - An array with the aliases of all composables, that do not have an incoming edge/link.\n * They are considered as the first nodes, that get executed.\n * @returns {boolean} True, if the graph contains cycles.\n */\nComposition.prototype.hasCycles = function (startingNodeArray) {\n    var nodes = {};\n    var edges = {};\n\n    //first create a copy of the composables in the composition (nodes)\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            nodes[key] = {}\n        }\n    }\n    //create a copy of the links without mapping information (edges)\n    for (var fromNode in this.links) {\n        if (this.links.hasOwnProperty(fromNode)) {\n            edges[fromNode] = [];\n\n            for (var fromEndpoint in this.links[fromNode]) {\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\n                    \n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\n\n                            edges[fromNode].push(toNode);\n\n                        }\n                    }\n\n                }\n            }\n            /*for (var i = 0; i < this.links[key].length; i++) {\n                edges[key].push(this.links[key][i].to);\n            }*/\n        }\n    }\n\n    \n    //Kahn's algorithm\n    //https://en.wikipedia.org/wiki/Topological_sorting\n    var L = [];\n    var S = startingNodeArray.slice();\n    var uniqueL = true;\n    while (S.length > 0) {\n        var n = S.pop();\n\n        //sorting only works, if all elements are unique!\n        if (L.indexOf(n) >= 0) {\n            uniqueL = false;\n            break;\n        }\n        L.push(n);\n        if (edges.hasOwnProperty(n)) {\n            for (var i = 0; i < edges[n].length; i++) {\n                var m = edges[n][i];\n                edges[n].splice(i, 1);\n\n                i--;\n\n                var hasIncoming = false;\n                for (var key in edges) {\n                    if (edges.hasOwnProperty(key)) {\n                        for (var k = 0; k < edges[key].length; k++) {\n                            if (edges[key][k] === m) {\n                                hasIncoming = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (hasIncoming) {\n                        break;\n                    }\n                }\n                if (!hasIncoming) {\n                    S.push(m);\n                }\n                if (edges[n].length === 0) {\n                    delete edges[n];\n                    break;\n                }\n            }\n        }\n    }\n\n    //if edges exist, or L has non unique elements: there is a cycle\n    if (Object.keys(edges).length > 0 || !uniqueL) {\n        return true;\n    }\n    return false;\n}\n/**\n * Checks, if the schemas of two objects are compatible.\n * Two objects are compatible, if one of them has no schema definition, or if the first schema is identical to the second one in a recursive comparison.\n * @protected\n * @param {string} obj1Name - The name of the first object (from). Only used for error output.\n * @param {string} obj2Name - The name of the second object (to). Only used for error output.\n * @param {JSONSchema} obj1Schema - The schema ofthe first object.\n * @param {JSONSchema} obj2Schema - The schema ofthe second object.\n * @param {string} [mappingFrom] - The relevant property name of the first object (source/from).\n * @param {string} [mappingTo] - The relevant property name of the second object (target/to).\n * @returns {boolean} True, if the object with obj1Schema can be used, where obj2Schema is required. \n */\nComposition.prototype.checkSchemaCompatibility = function (obj1Name, obj2Name, obj1Schema, obj2Schema, mappingFrom, mappingTo) {\n    //schemas are optional (null), so give the benefit of the doubt\n    if (obj1Schema == null || obj2Schema == null) { \n        return true;\n    }\n    //use to store error messages\n    var error = null;\n\n    //function for recursion, deals with the meta information level (type, properties, required, etc) of the JSONSchema\n    //level indicates the poperty chain and is used for error messages\n    function metaLevel(level, from, to) {\n        //iterate over the target keys (obj2Schema)\n        for (var key in to) {\n            //the source (obj1Schema) must have all keys the target has\n            if (key !== 'items' && key !== 'required' && !from.hasOwnProperty(key)) {\n                error = {\n                    level: level,\n                    message: 'missing property \"' + key + '\"'\n                }\n                return false;\n            }\n            //if we are dealing with an array, proceed to the meta-level\n            if (key === 'items' && from.hasOwnProperty(key)) {\n                if (!metaLevel(level + '.' + key, from[key], to[key])) {\n                    return false;\n                }\n            }\n            //if properties are defined, proceed with the recursion using the propertyLevel\n            else if (key === 'properties' && from.hasOwnProperty(key)) {\n                if (!propertyLevel(level + '.' + key, from[key], to[key])) {\n                    return false;\n                }\n            }\n            //if we get to the required array...\n            else if (key === 'required' && from.hasOwnProperty(key)) {\n                //special: required array order should be ignored\n                from[key].sort();\n                to[key].sort();\n\n                //first check if the length is the same\n                if (from[key].length !== to[key].length) {\n                    error = {\n                        level: level,\n                        message: 'array length different for \"' + key + '\" ' + from[key].toString() + ' != ' + to[key].toString()\n                    }\n                    return false;\n                }\n                //otherwise we need to compare each element\n                for (var i = 0; i < from[key].length; i++) {\n                    if (from[key][i] !== to[key][i]) {\n                        error = {\n                            level: level,\n                            message: 'array element difference for \"' + key + '\" ( ' + from[key][i] + ' != ' + to[key][i]\n                                + ' ) ' + from[key].toString() + ' != ' + to[key].toString()\n                        }\n\n                        return false;\n                    }\n                }\n            }\n            //if we get something else, we compare the values\n            //this should be all primitive types, but I'm not sure if I didn't miss any possible non-primitive\n            //in the above if-else\n            else if (from.hasOwnProperty(key)){\n                if (from[key] !== to[key]) {\n                    error = {\n                        level: level,\n                        message: 'inequal property value \"' + key + '\" ( ' + from[key] + ' != ' + to[key] + ' )'\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    //function for recursion, dealing with the enumeration of property keys of a schema\n    function propertyLevel(level, from, to) {\n        for (var key in to) {\n            //from must have at least all keys to has\n            if (!from.hasOwnProperty(key)) {\n                error = {\n                    level: level,\n                    message: 'missing property \"' + key + '\"'\n                }\n                return false;\n            }\n            //continue, by checking the meta-level of each property\n            if (!metaLevel(level + '.' + key, from[key], to[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var result = true;\n    //helper function, that helps to narrow the scope, if a mappingTo/mappingFrom is given\n    //it basically traverses the schema to the desired mapping property and returns it as the new schema\n    function scopeOnMapping(schema, mapping) {\n        var hasSchema = true;\n\n        if (schema.hasOwnProperty('properties')) {\n            if (schema.properties.hasOwnProperty(mapping)) {\n                return schema.properties[mapping];\n            }\n            else {\n                return null;\n            }\n        }\n\n        return schema;\n    }\n\n    //copy the original schemas for error output (we might modify our reference later to narrow the scope, but \n    //we still want to show the full schema for the error message\n    var OriginalObj1Schema = obj1Schema; \n    var OriginalObj2Schema = obj2Schema;\n\n    //mappings are optional, so scheck if they are defined and narrow the scopes\n    if (typeof mappingTo === 'string') {\n        var temp = scopeOnMapping(obj2Schema, mappingTo);\n        if (temp) {\n            obj2Schema = temp;\n        }\n        else {\n            error = {\n                level: '',\n                message: 'Composable \"' + obj2Name + '\" has no schema for property \"' + mappingTo + '\" provided by composable \"' + obj1Name + '\"'\n            }\n        }\n    }\n\n    if (typeof mappingFrom === 'string') {\n        var temp = scopeOnMapping(obj1Schema, mappingFrom);\n        if (temp) {\n            obj1Schema = temp;\n        }\n        else {\n            error = {\n                level: '',\n                message: 'Composable \"' + obj1Name + '\" has no schema for property \"' + mappingFrom + '\" required by composable \"' + obj2Name + '\"'\n            }\n        }\n    }\n\n    //if we didn't have an error yet, we can start the recursion\n    \n    if (!error) {\n        result = metaLevel('', obj1Schema, obj2Schema);\n    }\n\n    //output an error message\n    if (error) {\n        var relevantMapping = '';\n        if (typeof mappingFrom === 'string' && typeof mappingTo === 'string') {\n            relevantMapping = ' for the mapping \"' + mappingFrom + '\" -> \"' + mappingTo + '\"';\n        } else if (typeof mappingTo === 'string') {\n            relevantMapping = ' for the mapping \"' + mappingTo + '\"';\n        }\n\n        var faultyObject = {};\n        faultyObject[obj1Name] = OriginalObj1Schema;\n        faultyObject[obj2Name] = OriginalObj2Schema;\n        \n\n        sweva.ErrorManager.error(\n                      new DefinitionError('Schemas of \"' + obj1Name + '\" and \"' + obj2Name + '\" incompatible' + relevantMapping + ': '\n            + error.level + ': ' + error.message,\n                      this.context, faultyObject));\n    }\n    return result;\n}\n/**\n * Statically analyzes the graph before execution.\n * Checks for compatability of composables, absence of cycles in the linkage definition etc.\n * @protected\n */\nComposition.prototype.analyzeLinkGraph = function () {\n    /**\n     * False, if no errors in the link graph definition were detected.\n     * @protected\n     * @name Composition#invalidLinkGraph\n     * @type {boolean}\n     */\n    this.invalidLinkGraph = false;\n    /**\n     * Array of all the aliases of the composables, that have no ingoing link, i.e. the 'start'\n     * @protected\n     * @name Composition#startingComposables\n     * @type {Array.<string>}\n     */\n    this.startingComposables = Object.keys(this.composables);\n    /**\n    * Dictionary of all the aliases of the composables, that have no outgoing link, i.e. the 'end'\n    * Dictionary, because there will be some lookups of the key values later on.\n    * @protected\n    * @name Composition#startingComposables\n    * @type {Object.<string,string>}\n    */\n    this.endingComposables = {};\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            this.endingComposables[key] = true;\n        }\n    }\n\n    //find startingComposables that have no ingoing edges\n    //find endingComposables that have no outgoing edges\n   \n\n    for (var fromNode in this.links) {\n        if (this.links.hasOwnProperty(fromNode)) {\n           \n\n            for (var fromEndpoint in this.links[fromNode]) {\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\n\n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\n                            var toEndpoint = this.links[fromNode][fromEndpoint][toNode];\n                            //check if linking to existing composable!\n                            if (!this.composables.hasOwnProperty(toNode)) {\n                                sweva.ErrorManager.error(\n                                  new DefinitionError('Composable \"' + fromNode + '\" links to undefined composable \"' + toNode + '\"!',\n                                  this.context, Object.keys(this.composables)));\n                                this.invalidLinkGraph = true;\n                            }\n                            else {    \n                                //composable has no such dataOut, it tries to map to another composable\n                                if (this.composables[fromNode].dataOutNames.indexOf(fromEndpoint) < 0) {\n                                    sweva.ErrorManager.error(\n                                         new DefinitionError('Composable \"' + fromNode + '\" maps undefined dataOut \"' + fromEndpoint + '\" to composable \"' + toNode + '\"!',\n                                         this.context, this.composables[fromNode].dataOutNames));\n                                    this.invalidLinkGraph = true;\n                                    break;\n                                }\n\n                                //composable has no such dataIn\n                                if (this.composables[toNode].dataInNames.indexOf(toEndpoint) < 0) {\n                                    sweva.ErrorManager.error(\n                                         new DefinitionError('Composable \"' + fromNode + '\" links to undefined dataIn \"' + toEndpoint + '\" of composable \"' + toNode + '\"!',\n                                         this.context, this.composables[toNode].dataInNames));\n                                    this.invalidLinkGraph = true;\n                                    break;\n                                }\n                                //additionally check for schema compatibility (optional)\n                                if (this.composables[fromNode].dataOutSchema && this.composables[toNode].dataInSchema != null) {//schemas are optional, so only check if available\n                                    var compatibleSchemas = this.checkSchemaCompatibility(fromNode, toNode, this.composables[fromNode].dataOutSchema, this.composables[toNode].dataInSchema,fromEndpoint, toEndpoint);\n                                    if (!compatibleSchemas) {\n                                        this.invalidLinkGraph = true;\n                                        break;\n                                    }\n                                }\n                                if (typeof this.composables[toNode].dataInConnected === 'undefined') {\n                                    this.composables[toNode].dataInConnected = {};\n                                }\n                                this.composables[toNode].dataInConnected[toEndpoint] = true;\n\n                            }\n                            //if one composable A points to composable B, then B cannot be startingComposable\n                            var propIndex = this.startingComposables.indexOf(toNode);\n                            if (propIndex >= 0) {\n                                this.startingComposables.splice(propIndex, 1);\n                            }\n                            //if one composable A points to composable B, then A cannot be endingComposable\n                            \n                            if (this.endingComposables.hasOwnProperty(fromNode)) {\n                                delete this.endingComposables[fromNode]\n                            }\n\n                        }\n                    }\n                }\n            }           \n        }\n    }\n\n\n    \n\n    //check for cycles\n    var hasCycles = this.hasCycles(this.startingComposables);\n    if (hasCycles) {\n        sweva.ErrorManager.error(\n                       new DefinitionError('There are cycles in the linkage of composables!',\n                       this.context, this.links));\n        this.invalidLinkGraph = true;\n    }\n\n    //extract implicit information\n    this.dataIn = this.startingComposables.length;\n    this.dataOut = Object.keys(this.endingComposables).length;\n\n    this.dataInNames = [];\n    this.dataOutNames = [];\n\n    for (var i = 0; i < this.startingComposables.length; i++) {\n       \n        if (this.composables[this.startingComposables[i]].dataInNames.length>0) {\n            this.dataInNames.push(this.startingComposables[i]);\n        }        \n    }\n    for (var key in this.endingComposables) {\n        if (this.endingComposables.hasOwnProperty(key)) {\n            this.dataOutNames.push(key);\n        }\n    }\n    \n}\n/**\n * Recursive function that executes all composables, as soon as they can be executed (have all required data available)\n * @param {string} context - Information about the execution context, see {@link Composable#context}\n * @protected\n */\nComposition.prototype.composableQueueExecution = function (context) {\n    \n    //keep an array of all composables\n    //executed composables get marked\n    /*\n    console.log(\"CQE : context =\");\n    console.log(context);\n    console.log(\"CQE : this =\");\n    console.log(this);\n    console.log(\"CQE : unclearedComposables =\");\n    console.log(this.unlcearedComposables);\n    */\n\n    for (var i = 0; i < this.unlcearedComposables.length; i++) {\n\n        //skip already executed composables\n        if (this.unlcearedComposables[i].cleared) {\n            continue;\n        }\n        \n        var composableName = this.unlcearedComposables[i].composable;\n\n        \n       \n        var data = null;\n        var input = null;\n        \n        //check if composable has all data it depends on available\n        \n        if (this.hasParameters(composableName)) {\n            \n            //fill data and input for next composable call\n            data = this.parameters[composableName];\n           \n            input = this.mapInput(this.input, composableName, this.composables, sweva.libs);\n          \n        }\n        else {\n            continue;\n        }\n\n        //not continued = composableName can be executed (has data vailable)\n        var self = this;\n        //closure function, to get the current composable for each function\n        var func = function (composableName) {\n            return function (output) {\n                //check if composable does not provide data to other composables (end of execution chain)\n                if (self.endingComposables.hasOwnProperty(composableName)) {\n                    \n                    var allCleared = true;\n                    //if we have only one output composable, we do not need a named property,\n                    //otherwise create a property using the ending-composable alias\n                    if (Object.keys(self.endingComposables).length > 1) {\n                        self.output[composableName] = output;\n                    }\n                    else {\n                        self.output = output;\n                    }\n\n                    //check if this was the last composable (all have been executed)\n                    for (var k = 0; k < self.unlcearedComposables.length; k++) {\n                        if (!self.unlcearedComposables[k].cleared) {\n                            allCleared = false;\n                        }\n                    }\n                    //if this was the last endingComposable, finish\n                    if (allCleared) {\n                        self.executeFinishedCallback();\n                    }                    \n                }\n                //if composable provides data to other composables \n                else {\n                    if (self.links[composableName]) {\n\n                        for (var fromEndpoint in self.links[composableName]) {\n                            if (self.links[composableName].hasOwnProperty(fromEndpoint)) {\n\n                                for (var toNode in self.links[composableName][fromEndpoint]) {\n                                    if (self.links[composableName][fromEndpoint].hasOwnProperty(toNode)) {\n                                        var toEndpoint = self.links[composableName][fromEndpoint][toNode];\n                                            self.addParameter(toNode, toEndpoint, output[fromEndpoint]);                                            \n                                    }\n                                }\n                            }\n                        }                            \n                    }\n                }\n                //recursive execution of the next composables, as this one just finished and probably resolved some data dependencies\n                //console.log(self.parameters)\n\n                self.manager.addReexecutionListener(function(result) {\n                    self.needsReloadingVisualization = true;\n                    self.progress = result.mqtt_sweva_parameters.data.progress;\n                    self.context = result.mqtt_sweva_parameters.context;\n                    self.parameters = result.mqtt_sweva_parameters.data.parameters;\n                    self.output = result.mqtt_sweva_parameters.data.output;\n                    self.mqtt_client = result.mqtt_sweva_parameters.data.client;\n                    // if(result.lastReturnedData){\n                    //     for (var key in self.composables) {\n                    //       if(self.composables[key].name == result.name){\n                    //           var output =  self.composables[key].dataOutNames[0];\n                    //           for (var i in self.composables[key].dataInNames){\n                    //             self.parameters[key][self.composables[key].dataInNames[i]] = result.lastReturnedData[output];\n                    //           }\n                    //       }\n                    //     }\n                    // }\n                    self.unlcearedComposables = JSON.parse(JSON.stringify(result.mqtt_sweva_parameters.data.unclearedComposablesClone));\n                    self.composableQueueExecution.apply(self, [self.context]);\n                    console.log('recomputing demo result');\n                }, self.mqtt_module_name);\n                self.composableQueueExecution.apply(self, [context]);\n\n\n            }\n\n        };\n        //mark composable as cleared\n        if (!this.unlcearedComposables[i].cleared) {\n\n            //Retrieve Data needed for the ASYNC calls of the MQTT nodes\n            //Check if the current node about to be cleared is an MQTT node\n          var mqtt_sweva_parameters = false;\n          if (typeof this.composables[this.unlcearedComposables[i].composable].subscribe === 'function'){\n            self.mqtt_module_name = this.composables[this.unlcearedComposables[i].composable].name;\n            mqtt_sweva_parameters = {\n              module_name: this.composables[this.unlcearedComposables[i].composable].name,\n              context: context,\n              data: {\n                parameters: this.parameters,\n                output: this.output,\n                unclearedComposablesClone: JSON.parse(JSON.stringify(this.unlcearedComposables)),\n                process: this.progress,\n                client: this.mqtt_client\n              }\n            };\n          } else {\n            self.mqtt_module_name = false;\n          }\n\n\n            this.unlcearedComposables[i].cleared = true;\n           \n            //execute composable\n            this.composables[composableName].execute(data, input, context, composableName, mqtt_sweva_parameters, this.progress)\n                .then(\n                    //a => console.log(a))\n                    func(composableName))\n                .catch(function (error) {\n                    //error is logged earlier, but how to handle?\n                });\n        }\n\n       \n    }\n}\n/**\n * Starts execution of the composable, initializes required data. Use this function if you want to execute a composable!\n * @param {Object} data - The data relevant to the processing.\n * @param {Object} input - Input information on how to process the data.\n * @param {string} context - Execution context. See {@link Composable#context}.\n * @param {string} [alias] - Name, under which the composable is known to its parent.\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\n */\nComposition.prototype.execute = function (data, input, context, alias, progress) {\n    \n    var self = this;\n    this.data = data;\n    this.input = input;\n    context = this.getNewContext(context, alias);\n    this.reset();\n    \n    this.progress = progress;\n    \n    //return a promise, since execution is async\n    return new Promise(function (resolve, reject) {\n        //do not bother executing, if link graph definition is invalid, or the provided data or input object do not match the provided schema definitions\n        if (!self.invalidLinkGraph && self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\n            //each starting composable has an own data part\n            //use user-definable {@link Composition~mapDataInFunction} to map the data to the starting composables\n            for (var i = 0; i < self.startingComposables.length; i++) {\n                var composableName = self.startingComposables[i];               \n                self.parameters[composableName] = self.mapDataIn(self.data, composableName, self.composables, sweva.libs);\n            }\n            \n            //define callback for when execution is finished\n            self.executeFinishedCallback = function (error) {\n                if (error) {\n                    sweva.ErrorManager.error(\n                       new ExecutionError('Something unexpected happened: ' + error,\n                       context, error));\n                    reject(sweva.ErrorManager.getLastError());\n                }\n                //if there is no error\n                else {\n                    //use user-definable {@link Composition~mapDataOutFunction} to create the final output object\n                    var result = self.mapDataOut(self.output, sweva.libs);\n                    //validate output using provided schema\n                    if (self.validateTypes('dataOut', result)) {\n                        if(self.needsReloadingVisualization === true) {\n                            self.manager.sendDataToVisualization(result);\n                        }\n                        resolve(result);\n                    }\n                    else {\n                        reject(sweva.ErrorManager.getLastError());\n                    }\n                }\n            }\n            //all composables are loaded, so execution can start directly\n            if (self.isReady) {\n                self.composableQueueExecution.apply(self, [context]);\n            }\n                //delay execution to {@link Composition#loadComposables}\n            else {\n                //we want to execute, but cannot: tell so the initialization/loading part\n                self.wantsToExecute = true;\n                //execute via callback, as soon as loading finished\n                self.executeStarterCallback = function () { \n                    self.composableQueueExecution.apply(self, [context]);\n                }\n            }\n        }\n        else {\n            reject(sweva.ErrorManager.getLastError());\n        }\n    });\n}\n\nmodule.exports = Composition;","'use strict';\n\nvar Composable = require('../../core/composables/composable.js');\n//var Composition = require('../../core/composables/composition.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\n\n/**\n * A user defineable function to create a HTTP request as a promise. It is used to call a remote service using its API.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestFunction\n * @param {Object} data - The data object given to the module.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n/**\n * A user defineable function to handle errors from failed service calls.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestErrorFunction\n * @param {Object} response - The response object from the service call.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n\n/**\n * A user defineable function to transform the response of the service.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestErrorFunction\n * @param {Object} response - The response object from the service call.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n/**\n * A user defineable function to do all computation locally, no service is called.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~computeFunction\n * @param {Object} data - The data object given to the module.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n\n/**\n * The initalization object with optional properties to initialize modules.\n * @typedef {composableInitalizer} moduleInitalizer\n * @property {Module~requestFunction} [request] - Creates a HTTP request to call the appropriate service.\n * @property {Module~requestErrorFunction} [request] - If this function is provided, it is used to handle errors, if the service call was unsuccessful.\n * @property {Module~responseFunction} [request] - Function to transform the the service response to be used later on.\n * @property {Module~computeFunction} [request] - If provided, no service is called, but all computation is performed locally in this function.\n *\n */\n\n/**\n * A module is the smallest unit of execution.\n * It serves as an envelope to a service call and can optionally do all computations locally wihtout a remote service.\n * @constructor\n * @extends Composable\n * @param {moduleInitalizer} initializationObject - The object with optional properties for the composition.\n *\n */\nfunction Module(initializationObject, manager) {\n    this.manager = manager;\n\n    this.initialize(initializationObject);\n\n    // general node type\n\n    this.initializeFunction(initializationObject, 'run', 3, null);\n    this.initializeProperty(initializationObject, 'language', 'typescript');\n\n    this.initializeProperty(initializationObject, 'source', null);\n    this.initializeProperty(initializationObject, 'binary', null);\n    this.initializeProperty(initializationObject, 'binaryHash', null);\n\n    /*this.initializeFunction(initializationObject, 'requestError', 3, null);\n\n    this.initializeFunction(initializationObject, 'response', 3,\n      function (response, input, libs) {\n        var obj = {};\n        obj[this.dataOutNames[0]] = response.data;\n        return obj;\n      });*/\n\n    // now the asynchronous node type\n\n    this.initializeFunction(initializationObject, 'subscribe', 3, null);\n    this.initializeFunction(initializationObject, 'onConnect', 3, null);\n    this.initializeFunction(initializationObject, 'onSubscription', 3, null);\n    this.initializeFunction(initializationObject, 'onMessageReceived', 4, null);\n}\n\n//inherit properties\nModule.prototype = Object.create(Composable.prototype);\nModule.prototype.constructor = Module;\n\nModule.prototype.lastReturnedData = null;\n\n/**\n * Calls the service using the created HTTP request received from {@link Module~requestFunction}.\n *\n * @protected\n * @param {Promise} request - The async service call.\n * @param {Object} input - The data input object given to the module.\n * @returns {Promise} - A promise with the response object.\n */\nModule.prototype.callService = function (request, input) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        request\n            .then(function (response) {\n                resolve(self.response(response, input, sweva.libs));\n            })\n            .catch(function (response) {\n                //if we have a function to deal with errors from service directly...\n                if (typeof self.requestError === 'function') {\n                    resolve(self.requestError(response, input, sweva.libs));\n                } else {\n                    reject(response);\n                }\n            });\n    });\n};\n\n/**\n * This one subscribes to a topic on a message queue.\n *\n * @param subscribe\n * @param input\n */\nModule.prototype.callSubscription = function (subscribe, data, mqtt_sweva_parameters, input) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        if (subscribe !== false) {\n            var client = subscribe;\n            mqtt_sweva_parameters.data.client = client;\n            client.on('connect', function () {\n                self.onConnect(client, input, sweva.libs);\n            });\n            if (self.lastReturnedData === null) {\n                self.lastReturnedData = data;\n            }\n            client.on('message', function (topic, message) {\n                if (mqtt_sweva_parameters != false) {\n                    self.mqtt_sweva_parameters = mqtt_sweva_parameters;\n                } else {\n                    reject(error);\n                }\n                self.lastReturnedData = self.onMessageReceived(self.lastReturnedData, topic, message, sweva.libs);\n                // now notify the execution manager\n                self.manager.onModuleUpdate(self);\n            });\n        }\n\n\n        resolve(self.onSubscription(data, input, sweva.libs)).catch(function (error) {\n            // if we have a function to deal with errors from service directly...\n            if (typeof self.requestError === 'function') {\n                resolve(self.requestError(response, input, sweva.libs));\n            } else {\n                reject(error);\n            }\n        });\n    });\n};\n\n/**\n * Executes the module, i.e. performs the computation either by calling a service or locally.\n * @param {Object} data - The data relevant to the processing.\n * @param {Object} input - Input information on how to process the data.\n * @param {string} context - Execution context. See {@link Composable#context}.\n * @param {string} [alias] - Name, under which the composable is known to its parent.\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\n */\nModule.prototype.execute = function (data, input, context, alias, mqtt_sweva_parameters, progress) {\n    var self = this;\n    console.log(\"context ===\");\n    console.log(context);\n    console.log(\"Module to be executed =\");\n    console.log(self);\n    context = this.getNewContext(context, alias);\n\n    if (input == null) {\n        input = {};\n    }\n\n\n    // Promise to abort if offloading is necessary\n    return new Promise(function (resolve, reject) {\n        //begin promise\n        //only execute, if data and input objects are valid according to the optional schamas\n        if (self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\n\n            console.log(\"Input data for \" + alias + \": \");\n            console.log(data);\n\n            if (self.source != null) { //TODO: typeof self.run === 'function')\n                // if a computation function is defined, then skip service calls and compute locally\n                console.log(\"EXECUTE \" + self.name + \"[\" + alias + \"] USING: \" + sweva.runners[self.language].name);\n                //const result = await sweva.runners[self.language].exec(self, data, input, {signal});\n\n                //=== OFFLOADING === MODULE EXECUTION BEGINS HERE\n                sweva.runners[self.language].exec(self, data, input).then((result) => {\n\n                    console.log(\"Result data for \" + alias + \": \");\n                    console.log(result);\n\n                    if (result ==='offloading'){\n                     resolve('offloading') //todo: resolve or reject here ?\n                    }\n                    //TODO: MAP correctly\n                    //var result = self.run(data, input, sweva.libs);\n                    if (self.validateTypes('dataOut', result)) {\n                        //report progress, if callback is defined\n                        if (typeof progress !== 'undefined') {\n                            progress(alias, self.name, context,result);\n                        }\n                        // resolve module execution promise\n                        resolve(result);\n                    } else {\n                        // offloading callback here\n                        reject(sweva.ErrorManager.getLastError());\n                    }\n                });\n            }\n\n        } else if (typeof self.subscribe === 'function') {\n            // this is subscribing to an asynchronous message queue\n            var client;\n            if (typeof mqtt_sweva_parameters.data.client === 'undefined') {\n                client = self.subscribe(data, input, sweva.libs);\n            } else {\n                client = false;\n            }\n            self.callSubscription(client, data, mqtt_sweva_parameters, input).then(function (output) {\n                //validate output\n                if (self.validateTypes('dataOut', output)) {\n                    //report progress, if callback is defined\n                    if (typeof progress !== 'undefined') {\n\n                        progress(alias, self.name, context);\n                    }\n\n                    self.lastReturnedData = output;\n                    resolve(output);\n                } else {\n                    reject(sweva.ErrorManager.getLastError());\n                }\n            }).catch(function (error) {\n                sweva.ErrorManager.error(\n                    new ExecutionError('Something unexpected happened: ' + error,\n                        context, error));\n                reject(sweva.ErrorManager.getLastError());\n            });\n        } else if (typeof self.request === 'function') {\n            // this is an HTTP request node, call service using an HTTP request\n\n            self.callService(self.request(data, input, sweva.libs), input).then(function (output) {\n                // the output is already the HTTP response\n\n                //validate output\n                if (self.validateTypes('dataOut', output)) {\n                    //report progress, if callback is defined\n                    if (typeof progress !== 'undefined') {\n\n                        progress(alias, self.name, context);\n                    }\n\n                    resolve(output);\n                } else {\n                    reject(sweva.ErrorManager.getLastError());\n                }\n            }).catch(function (error) {\n                sweva.ErrorManager.error(\n                    new ExecutionError('Something unexpected happened: ' + error,\n                        context, error));\n                reject(sweva.ErrorManager.getLastError());\n            });\n\n        } else {\n            reject(sweva.ErrorManager.getLastError());\n        }\n\n    });\n}\n\nmodule.exports = Module;","//global object initialization\nvar globalObject;\n\nvar inBrowser = false;\n\ntry {\n    if (window) {\n        globalObject = window;\n        inBrowser = true;\n    }\n}\ncatch (e) {\n    globalObject = global;\n}\n\n//prevent loading everything twice on editor-page\nif(!globalObject.sweva) {\n    globalObject.sweva = {};\n\n    globalObject.sweva.inBrowser = inBrowser;\n\n    globalObject.sweva.asyncmqtt = require('../../node_modules/async-mqtt');\n\n    var Ajv = require('../../node_modules/ajv/lib/ajv.js');\n    globalObject.sweva.Ajv = new Ajv();\n\n    var ComposableLoader = require('../../app/core/execution/composableLoader.js');\n    globalObject.sweva.ComposableLoader = new ComposableLoader('');\n\n    globalObject.sweva.ExecutionManager = require('../../app/core/execution/executionManager.js');\n\n    var ErrorManager = require('../../app/core/errors/errorManager.js');\n    globalObject.sweva.ErrorManager = new ErrorManager();\n\n    var SwevaScript = require('../../app/core/swevaScript/swevaScript.js');\n    globalObject.sweva.SwevaScript = new SwevaScript();\n\n    var AssemblyScriptRunner = require('../../app/core/runners/assemblyScriptRunner.js');\n\n    /*\n    globalObject.sweva.axios = require('../../node_modules/axios/dist/axios.min.js');\n    globalObject.sweva.libs = {\n        axios: globalObject.sweva.axios,\n        mqtt: globalObject.sweva.asyncmqtt,\n        get: globalObject.sweva.SwevaScript.get,\n        set: globalObject.sweva.SwevaScript.set,\n        //mqttclient: globalObject.sweva.SwevaScript.client,\n        //mqttsubscribe: globalObject.sweva.SwevaScript.subscribe,\n        adddata: globalObject.sweva.SwevaScript.adddata\n    }*/\n\n    globalObject.sweva.runners = {};\n\n    var typescript = new AssemblyScriptRunner();\n    globalObject.sweva.runners[typescript.id] = typescript;\n}\n\nmodule.exports = globalObject.sweva;","'use strict';\n\nvar SwevaError = require('../../core/errors/swevaError.js');\n/**\n * An execution error should be used, if the error occured during execution.\n * @constructor\n * @extends SwevaError\n */\nfunction ExecutionError(message, context, faultyObject) {\n    SwevaError.call(this, message, context, faultyObject);\n    this.name = 'ExecutionError';\n}\nExecutionError.prototype = Object.create(SwevaError.prototype);\n\nmodule.exports = ExecutionError","'use strict';\n\nvar DefinitionError = require('../../core/errors/definitionError.js');\n/**\n * A compile error should be used, if  the error was thrown by the compiler, before actual execution and validation.\n * @constructor\n * @extends DefinitionError\n */\nfunction CompileError(message, context, faultyObject) {\n    DefinitionError.call(this, message, context, faultyObject);\n    this.name = 'CompileError';\n}\nCompileError.prototype = Object.create(DefinitionError.prototype);\n\nmodule.exports = CompileError;","'use strict';\n\nvar SwevaError = require('../../core/errors/swevaError.js');\n/**\n * A definition error should be used, if  the error occured because of incompatible definitions of composables, i.e. before actual execution.\n * @constructor\n * @extends SwevaError\n */\nfunction DefinitionError(message, context, faultyObject) {\n    SwevaError.call(this, message, context, faultyObject);\n    this.name = 'DefinitionError';\n}\nDefinitionError.prototype = Object.create(SwevaError.prototype);\n\nmodule.exports = DefinitionError;","'use strict';\n/**\n * Aggregates {@link SwevaError} messages.\n * @constructor\n */\nfunction ErrorManager() {\n    /**\n    * An array storing the error messages.\n    * @name ErrorManager#queue\n    * @type {Array.<Error>}\n    */\n    this.queue = [];\n}\n/**\n * Resets the ErrorManager.\n */\nErrorManager.prototype.clear = function () {\n    this.queue = [];\n}\n/**\n * Appends errors to the internal queue, logs them and returns the error object\n * @param {Error} error - The error object.\n * @returns {Error} - The error object.\n */\nErrorManager.prototype.error = function (error) {\n    this.queue.push(error);\n    console.log(error.toString());\n    console.log(error);\n    return error;\n}\n/**\n * Gets a string representation of all stored errors.\n * @returns {string} - All stored errors separated by a linebreak.\n */\nErrorManager.prototype.getLog = function () {\n    var result = '';\n    for (var i = 0; i < this.queue.length; i++) {\n        result += this.queue[i].toString() + '\\n';\n    }\n    return result;\n}\n/**\n * @returns {Error} - The last error that was recorded.\n */\nErrorManager.prototype.getLastError = function () {\n    if (this.queue.length > 0) {\n        return this.queue[this.queue.length - 1];\n    }\n    return null;\n}\n\nmodule.exports = ErrorManager;","'use strict';\n\n/**\n * An error object with some additional information.\n * @constructor\n * @extends Error\n * @param {string} message - The error message: What went wrong?\n * @param {string} context - The execution context, in what composable did the error occur?\n * @param {Object} [faultyObject] - Additional information about the error cause.\n */\nfunction SwevaError(message, context, faultyObject) {\n    /**\n    * The name of the error object.\n    * @name SwevaError#name\n    * @type {string}\n    */\n    this.name = 'SwevaError';\n\n    /**\n    * The error message.\n    * @name SwevaError#message\n    * @type {string}\n    */\n    this.message = message || 'Default Message';\n\n    /**\n    * The callstack of the error.\n    * @name SwevaError#stack\n    * @type {Object}\n    */\n    this.stack = (new Error()).stack;\n\n    /**\n    * The execution context of the error (in which composable it occured).\n    * @name SwevaError#context\n    * @type {string}\n    */\n    this.context = context;\n\n   \n    if (faultyObject !== 'undefined') {\n        //shallow copy: should provide enough information and save RAM\n        //copy is needed, as we need the object exactly at the time the error occurred\n        this.faultyObject = faultyObject;\n\n        if (typeof faultyObject === 'function') {\n            //make functions to strings            \n            this.faultyObject = faultyObject.toString();\n        }\n        else if (typeof faultyObject === 'object') {\n            for (var key in faultyObject) {\n                if (faultyObject.hasOwnProperty(key)) {\n                    this.faultyObject[key] = faultyObject[key];\n                }\n            }\n        }\n    }\n    else {\n        this.faultyObject = null;\n    }\n    /**\n    * The timestamp of the error.\n    * @name SwevaError#time\n    * @type {number}\n    */\n    this.time = Date.now();\n\n    console.error(\"Error in \"+context+\" created! Stacktrace:\");\n    console.trace();\n}\n//inherit properties\nSwevaError.prototype = Object.create(Error.prototype, {\n    constructor: {\n        value: this.constructor,\n        writable: true,\n        configurable: true\n    }\n});\n/**\n * @returns {string} - A string representation of the error timestamp.\n */\nSwevaError.prototype.getTime = function () {\n    return new Date(this.time).toLocaleTimeString();\n}\n\n/**\n * Converts error object to string including relevant information (timestamp, name, context, message, additional information).\n * @returns {string} - String representation of the error.\n */\nSwevaError.prototype.toString = function () {\n    var faultyObject = '';\n    if (typeof this.faultyObject === 'object') {\n        //transform object to pretty printed string (with identation).\n        faultyObject = JSON.stringify(this.faultyObject, null, 4);\n    }\n    else {\n        faultyObject = this.faultyObject.toString();\n    }\n    //construct string\n    return '[' + this.getTime() + '] SwevaError ' + this.name + ' in ' + this.context + ': ' + this.message + '\\n'\n        + faultyObject;\n}\nmodule.exports = SwevaError;","'use strict';\n\nvar Module = require('../../core/composables/module.js');\nvar Composition = require('../../core/composables/composition.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\n\n/**\n * Responsible for dynamically loading composables from a web address.\n * Loaded composables are stored in an internal dictionary, so they only need to be downloaded once.\n * @constructor\n * @param {string} [basePath=''] - The base address from which to download the composable. Gets prepended to the composable name.\n * @param {string} [suffix=.json] - The suffix that gets appended to the composable name.\n */\nfunction ComposableLoader(basePath, suffix) {\n    /**\n    * The base address from which to download the composable. Gets prepended to the composable name.\n    * @name ComposableLoader#basePath\n    * @type {string}\n    */\n    this.basePath = basePath || '';\n    /**\n    * The suffix that gets appended to the composable name.\n    * @name ComposableLoader#suffix\n    * @type {string}\n    */\n    this.suffix = suffix || '';\n    /**\n    * Dictionary of the composable names and the corresponding composable objects.\n    * @name ComposableLoader#composables\n    * @type {Object.<string, Composable>}\n    */\n    this.composables = {};\n    /**\n    * Dictionary of a waiting list, where loaded composables can be assigned to external objects\n    * @name ComposableLoader#waitingList\n    * @type {Object.<string, Object>}\n    */\n    this.waitingList = {};\n}\n\n/**\n * @returns {number} - The number of stored composables.\n */\nComposableLoader.prototype.size = function () {\n    return Object.keys(this.composables).length;\n}\n/**\n * @param {string} name - The name of the composable to return.\n * @returns {Composable} - The composable object.\n */\nComposableLoader.prototype.get = function (name) {\n    return this.composables[name];\n}\n/**\n * Composable objects can be directly added, without having to download them.\n * This can be used e.g. for rapid prototyping.\n * @param {string} name - The name of the composable to add.\n * @paranm {Composable} composable - The composable to add.\n */\nComposableLoader.prototype.add = function (name, composable) {\n    this.composables[name] = composable;\n}\n/**\n * Converts a JSON representation of a composable into a full composable object.\n * Since composables can have custom functions defined, and JSON does not support functions, we cannot use JSON.parse.\n * Instead functions are encoded as string arrays in JSON and then assembled.\n * {@link SwevaScript} is used to sanitize the functions.\n *\n * @protected\n * @param {Object} json - The JSON object of the composable.\n * @param {string} context - The context of execution (for error messages).\n * @returns {composableInitalizer} - Composable initalization object.\n */\nComposableLoader.prototype.convertToObject = function (json, context) {\n    var result = json;\n    var self = this;\n    for (var key in json) {\n        if (json.hasOwnProperty(key)) {\n           //decode base64 encoded binaries\n            if(key === 'binary' && !(json[key] instanceof Uint8Array)) {\n                /*console.log(json)\n                console.log(context)\n                console.log(json[key]);\n                console.log(typeof json[key])*/\n                let binaryList = atob(json[key]);\n               json[key] = new Uint8Array(binaryList.split(\"\").map(function(c) {\n                   return c.charCodeAt(0);\n               }));\n            }\n\n            //TODO: consider removing mapping functions\n            if (key !== 'source' && (json[key] !== null && typeof json[key][0] === 'string')) {\n                var str = String(json[key][0]);\n                //check if string array starts with 'function' -> assemble function into object\n                if (str.trim().indexOf('function') === 0) {\n                    //first sanitize the script to prevent malicious code execution\n\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\n                        function (error) {\n                            sweva.ErrorManager.error(\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\n                                    context, self.convertJsonToCode(json)));\n                        });\n                }\n            }\n\n            /*//TODO: consider removing mapping functions\n            if (key !== 'source' && typeof json[key][0] === 'string') {\n                var str = String(json[key][0]);\n                //check if string array starts with 'function' -> assemble function into object\n                if (str.trim().indexOf('function') === 0) {\n                    //first sanitize the script to prevent malicious code execution\n\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\n                        function (error) {\n                            sweva.ErrorManager.error(\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\n                                    context, self.convertJsonToCode(json)));\n                        });\n                }\n            }*/\n\n            if (typeof json[key] === 'object') {\n                json[key] = this.convertToObject(json[key], context);\n            }\n        }\n    }\n\n    return result;\n}\n//TODO: replace default modules\nComposableLoader.prototype.getDefaultModule = function () {\n    return \"{\\n\" +\n        \"      \\\"type\\\": \\\"module\\\",\\n\" +\n        \"      \\\"name\\\": \\\"Module\\\",\\n\" +\n        \"      \\\"description\\\": \\\"New Module template\\\",\\n\" +\n        \"      \\\"dataInNames\\\": [\\n\" +\n        \"        \\\"num\\\"\\n\" +\n        \"      ],\\n\" +\n        \"      \\\"dataInSchema\\\": {},\\n\" +\n        \"      \\\"dataOutNames\\\": [\\n\" +\n        \"        \\\"out\\\"\\n\" +\n        \"      ],\\n\" +\n        \"      \\\"dataOutSchema\\\": {},\\n\" +\n        \"      \\\"inputNames\\\": [],\\n\" +\n        \"      \\\"inputSchema\\\": {},\\n\" +\n        \"      \\\"source\\\": [\\n\" +\n        \"      \\\"export var a:i32 = 42;\\\",\\n\" +\n        \"      \\\"export function run(num: i32): i32 {\\\",\\n\" +\n        \"      \\\"if (a > num){\\\",\\n\" +\n        \"      \\\"return b}\\\",\\n\" +\n        \"      \\\"return num\\\",\\n\" +\n        \"      \\\"}\\\"\\n\" +\n        \"      ]\\n\" +\n        \"}\";\n}\nComposableLoader.prototype.getDefaultComposition = function () {\n    return \"{\\n    type: \\'composition\\',\\n    name: \\'composition1\\',\\n    dataInNames: [],\\n    dataInSchema: {},\\n    dataOutNames:[\\'result\\'],\\n    dataOutSchema: {},\\n    inputNames: [],\\n    inputSchema: {},\\n    mapDataIn: function (data, composableName, composables, libs) {\\n        if (data.hasOwnProperty(composableName)) {\\n            return libs.get(data, composableName);\\n        }\\n        return null;\\n    },\\n    mapDataOut: function (output, libs) {\\n        return output;\\n    },\\n    mapInput: function (input, moduleName, modules, libs) {\\n        if (input.hasOwnProperty(moduleName)) {\\n            return libs.get(input, moduleName);\\n        }\\n        return null;\\n    }\\n}\";\n}\n\nComposableLoader.prototype.convertCodeToJson = function (string) {\n    \n    var result = ''\n    var lines = string.split(/\\r?\\n/);\n   \n    var regexFunction = new RegExp(/^\\s*(\\w)+\\s*:\\s*function/);\n    var regexProperty = new RegExp(/^\\s*(\\w)+\\s*/);\n\n    var funcLines = false;\n    var funcLinesFirst = false;\n    var braceCount = 0;\n    var funcLinesJustFinished= false;\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i].trim();        \n        if (!funcLines) {\n            if (funcLinesJustFinished && line.indexOf(':') >= 0) {\n                funcLinesJustFinished = false;\n                result += ',\\n';\n            }\n            if (regexFunction.test(line)) {\n                funcLines = true;\n\n                var index = line.indexOf('function');\n\n                var linePart = line.slice(0, index);\n                var match = regexProperty.exec(linePart);\n                if (match != null) {\n                    linePart = linePart.slice(0, match.index) + '\"' + linePart.slice(match.index, match.index + match[0].length) + '\"' + linePart.slice(match.index + match[0].length);\n                }\n                linePart = linePart.replace(/'/g, '\"');\n\n                result += linePart;\n\n                result += '[\"' + line.slice(index) + '\",\\n';\n                funcLinesFirst = true;\n            }\n            else {\n                var match = regexProperty.exec(line);\n                if (match != null) {\n                    line = line.slice(0, match.index) + '\"' + line.slice(match.index, match.index + match[0].length) + '\"' + line.slice(match.index + match[0].length);\n                }\n                line = line.replace(/'/g, '\"');                \n                result += line + '\\n';\n            }\n        }\n        if (funcLines) {\n            var inQuotes = false;\n            var inSingleQuotes = false;\n            for (var k = 0; k < line.length; k++) {\n                var c = line[k];\n\n                if (c == '\"' && !inSingleQuotes) {\n                    inQuotes = !inQuotes;\n                    line = line.slice(0, k) + '\\\\' + line.slice(k);\n                    k++;\n                }\n                else if (c == '\\'' && !inQuotes) {\n                    inQuotes = !inSingleQuotes;\n                }\n                else if (c == '{' && !inQuotes && !inSingleQuotes) {\n                    braceCount++;\n                }\n                else if (c == '}' && !inQuotes && !inSingleQuotes) {\n                    braceCount--;\n                }\n            }\n            if (funcLinesFirst) {\n                funcLinesFirst = false;\n            }\n            else {\n                line = line.replace('\\\\n', '\\\\\\\\n');\n                if (braceCount == 0) {\n                    if (line.length > 0 && line.indexOf(',') >= line.length - 1) {\n                        line = line.slice(0, line.length - 1);\n                    }\n                    result += '\"' + line + '\"' + '\\n';\n                }\n                else {\n                    result += '\"' + line + '\"' + ',' + '\\n';\n                }\n            }\n\n            if (braceCount == 0) {\n                funcLines = false;\n                funcLinesFirst = false;\n                result += ']\\n';\n                funcLinesJustFinished=true;\n               \n            }\n        }\n    }\n\n    if (result.indexOf('{') !== 0) {\n        return '{' + result + '}';\n    }\n\n    return result;\n}\nComposableLoader.prototype.convertJsonToCode = function (obj) {\n    function getSpaces(spaces) {\n        var result = '';\n        for (var i = 0; i < spaces; i++) {\n            result += ' ';\n        }\n        return result;\n    }\n    function stringify(object, level, spaces) {\n        var result = '';\n\n        var ident = getSpaces(level * spaces);\n\n        var keys = Object.keys(object);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var keyString = (key.indexOf(' ') >= 0) ? ('\\'' + key + '\\'') : key;\n            result += ident + keyString + ': ';\n            if (typeof object[key] === 'string') {\n                result += '\\'' + object[key] + '\\'';\n            }\n            else if (typeof object[key] === 'object') {\n                if (Array.isArray(object[key])) {\n                    var arrayContent = '';\n\n                    if (object[key].length > 0 && typeof object[key][0] === 'string' && object[key][0].trim().indexOf('function') == 0) {\n                        //decode function\n                        var internalLevel = 0;\n                        for (var k = 0; k < object[key].length; k++) {\n                            var line = object[key][k].trim();\n                            if (line.indexOf('}') == 0) {\n                                internalLevel--;\n                                if (internalLevel < 0) {\n                                    internalLevel = 0;\n                                }\n                            }\n                            arrayContent += (k == 0 ? '' : ident) + getSpaces(spaces * internalLevel) + line + (k >= object[key].length - 1 ? '' : '\\n');\n                            if (line.length > 0 && line.indexOf('{') == line.length - 1) {\n                                internalLevel++;\n                            }\n                        }\n                        result += arrayContent + ident;\n                    }\n                    else {\n                        for (var k = 0; k < object[key].length; k++) {\n                            var element = object[key][k];\n                            arrayContent += ident + getSpaces(spaces);\n                            if (typeof element === 'string') {\n                                arrayContent += '\\'' + element + '\\'';\n                            }\n                            else if (typeof element === 'object') {\n                                arrayContent += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\n                            }\n                            else {\n                                arrayContent += element;\n                            }\n                            if (k < object[key].length - 1) {\n                                arrayContent += ',';\n                            }\n                            arrayContent += '\\n';\n                        }\n                        result += '[\\n' + arrayContent + ident + ']';\n                    }\n                }\n                else {\n                    result += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\n                }\n            }\n\n            else {\n                result += '\\'' + object[key] + '\\'';\n            }\n\n            if (i < keys.length - 1) {\n                result += ',';\n            }\n            result += '\\n';\n        }\n        return result;\n    }\n    return '{\\n'+stringify(obj, 1, 4)+'}';\n}\n\n/**\n * Helper function, that assigns the composables to the internal dictionary and optionally to external objects with a specified property.\n * This can be used to directly fill another external dictionary of composables, like the {@link Composition} composable dictionary.\n * @protected\n * @param {string} name - The name of the composable.\n * @param {Composable} composable - The composable object.\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\n */\nComposableLoader.prototype.assignLoadedComposables = function (name, composable, assignToObject, property) {\n    this.composables[name] = composable;\n\n    //check if the optional assignToObject is given\n    if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\n        assignToObject[property] = composable;\n    }\n\n    //deal with waitinglist: as the caller has to wait for 'then' we, can set the required values now with some delay\n    if (this.waitingList.hasOwnProperty(name)) {\n        //for each object, that waits for the composable to be assigned to\n        for (var i = 0; i < this.waitingList[name].length; i++) {\n            var assignTo = this.waitingList[name][i].assignTo;\n            var prop = this.waitingList[name][i].prop;\n\n            assignTo[prop] = composable;\n        }\n        //remove element from the waitingList\n        delete this.waitingList[name];\n    }\n}\n/**\n * Loads a composable by the given name from a web resource.\n * If no basePath was given in the constructor, use the full web address as the name.\n * @param {string} name - The name of the composable.\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\n * @returns {Promise<Composable>} - The loaded composable object.\n */\nComposableLoader.prototype.load = function (name, assignToObject, property) {\n    var self = this;\n\n    //return a promise, since loading is ansynchronuous\n    return new Promise(function (resolve, reject) {\n        //check if the name was already loaded or is currently being loaded\n        if (self.composables.hasOwnProperty(name)) {\n            //we have only our placeholder, no real value yet\n            //this means the composable is currently requested, but not loaded\n            if (self.composables[name] === true) {\n                //put in waitinglist, which is checked after each load\n                //but only, if it needs to be assigned externally\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\n                    if (!self.waitingList.hasOwnProperty(name)) {\n                        self.waitingList[name] = [];\n                    }\n                    self.waitingList[name].push({\n                        assignTo: assignToObject,\n                        prop: property\n                    });\n                }\n                //load from dictionary\n                resolve(self.composables[name]);\n            }\n            else {\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null) {\n                    assignToObject[property] = self.composables[name];\n                }\n                resolve(self.composables[name]);\n            }\n        }\n            //not already in dictionary, needs to be loaded\n        else {\n            //set key and prevent unnecessary loads, while loading is already in progress\n            self.composables[name] = true;\n            //construct url\n            var url = self.basePath + name + self.suffix;\n\n            sweva.axios.get(url)\n            .then(function (response) {\n                //convert the response JSON to an actual composable\n                var composable = self.convertToObject(response.data, url);\n                //closue function, dummy\n                var func = function (comp) {\n                    return function (res, rej) {\n                        res(comp);\n                    }\n                }\n                var internalPromise = new Promise(func(composable));\n\n                //check if composable just extends existing one\n                if (composable.hasOwnProperty('extends')) {\n                    var baseComposableName = composable.extends;\n                    //create a closure to load the base composable\n                    var func2 = function (baseComposableName, composable) {\n                        return function (res, rej) {\n                            self.load(baseComposableName).then(function (comp) {\n                                //extend loaded composable with extension\n                                res(comp.extendWith(composable));\n                            });\n                        }\n                    };\n                    //adjust internal promise to load the base composable first, before extending it.\n                    internalPromise = new Promise(func2(baseComposableName, composable));\n                }\n\n                internalPromise.then(function (composable) {\n                    //log as loaded\n                    console.log('loaded ' + composable.name);\n                    //if the loaded composable is a module\n                    if (composable.type == 'module') {\n                        //construct Module\n                        composable = new Module(composable);\n\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\n\n                        resolve(composable);\n                    }\n                        //if the loaded composable is a composition\n                    else {\n                        //construct Composition\n                        composable = new Composition(composable);\n\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\n                        //load composables required for the composition\n                        composable.loadComposables().then(function () {\n                            resolve(composable);\n                        });\n                    }\n                });\n            })\n            .catch(function (response) {\n                reject(self.basePath + name + self.suffix); //could not load\n            });\n        }\n    });\n}\n/**\n * Clears the internal dictionaries.\n */\nComposableLoader.prototype.clear = function () {\n    this.composables = {};\n    this.waitingList = {};\n}\nmodule.exports = ComposableLoader;","'use strict';\n\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar Module = require('../../core/composables/module.js');\nvar Composition = require('../../core/composables/composition.js');\n\n//MA\nlet potentialOffloadingTarget = require(\"../network/potentialOffloadingTarget.js\");\nlet dataProcessingDevice = require(\"../network/dataProcessingDevice.js\");\n\n// **** P2P network ****\nlet peer = new Peer('',{\n    host:\"milki-psy.dbis.rwth-aachen.de\",\n    port:443,\n    path:\"/discoveryNetwork\"\n});\nconsole.log('offloadingOutput$ Connection to the SWeVA P2P network successful!')\n//Event-based script\n//+++++++++ DEVICE is POT +++++++++\npeer.on('connection', (connection) => {\n    connection.on('data', (data) => {\n        if (data === 'peer'){\n            let msg = 'offloadingOutput$ Offloading request from device = ' + connection.peer;\n            console.log(msg);\n            potentialOffloadingTarget();\n        }\n    }); });\n//+++++++++ DEVICE is DPD +++++++++\n\nfunction broadcastToDiscoveryNetwork(intermediatePipelineAndResults) {\n    console.log('offloadingOutput$ broadcasting to discovery network....');\n    dataProcessingDevice(intermediatePipelineAndResults);\n    peer.listAllPeers((peerIds) => {\n        peerIds\n            .filter((peerId) => peerId !== peer.id) // Filter out device ID\n            .forEach((peerId) => {\n                const conn = peer.connect(peerId);\n                conn.on('open', () => {\n                    //console.log('offloadingOutput$ Discovered Peer = ' + peerId);\n                    conn.send('peer');\n                });\n                conn.on('error', (err) => {\n                    console.error('Error discovering Peer : ' + peerId);\n                    console.error(err);\n                })\n            });\n    });\n}\n\n// **** END P2P network ****\n\n// ************* Getters and Setters ****************\n\n//default values\nlet odList = [50,50,50];\nlet orList = [50,50,false];\nlet intermediatePipeline = {};\nlet intermediatePipelineResults ={};\nExecutionManager.setODList = function (odListInput) {\n    odList=odListInput;\n}\nExecutionManager.getODList = function () {\n    return odList;\n}\n\nExecutionManager.setORList = function (orListInput) {\n    orList=orListInput;\n}\nExecutionManager.getORList = function () {\n    return orList;\n}\n\nExecutionManager.setInitialIntermediatePipeline = function (intermediatePipelineInput) {\n    //prepare the intermediate pipeline for compatibility reasons\n    for (let key in intermediatePipelineInput.composables) {\n        if (intermediatePipelineInput.composables.hasOwnProperty(key)) {\n            delete intermediatePipelineInput.composables[key].manager;\n        }\n    }\n    intermediatePipeline = intermediatePipelineInput;\n\n    console.log('Initializing intermediate pipeline =',intermediatePipeline);\n\n}\n\nExecutionManager.getListOfPeers = function listOfPeers() {\n    return new Promise((resolve) => {\n        peer.listAllPeers((peerIds) => {\n            const list = peerIds\n                .filter((peerId) => peerId !== peer.id)\n                .map((peerId) => peerId.toString());\n\n            resolve(list);\n        });\n    });\n};\n\n//****** end Web GETTERS and SETTERS ***********\n\n/**\n * An ExecutionManager is responsible for managing the execution process of compositions and modules.\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an execution phase,\n * that executes the composables by providing data and input objects to them.\n *\n * The setup needs to be done only once, while the execution can be repeated on different data.\n * @constructor\n * @param {string} [name] - Name of the execution manager.\n */\nfunction ExecutionManager(name) {\n    if (typeof name === 'string') {\n        this.name = name;\n    } else {\n        this.name = 'ExecutionManager';\n    }\n    /**\n     * Amount of how many modules are used currently.\n     * @name ExecutionManager#modulesTotal\n     * @type {number}\n     */\n    this.modulesTotal = 1;\n    /**\n     * Amount of how many modules have finished execution.\n     * @name ExecutionManager#modulesDone\n     * @type {number}\n     */\n    this.modulesDone = 0;\n    /**\n     * Callback to track progress, gets called everytime a module finishes.\n     * @name ExecutionManager#progressCallback\n     * @type {function}\n     */\n    this.progressCallback = null;\n    this.updateVisualizationNotifier = null;\n\n    this.reexecutionListeners = [];\n}\n\n/**\n * Registers the callback function to track progress.\n * @param callback\n */\nExecutionManager.prototype.onProgress = function (callback) {\n    this.progressCallback = callback;\n};\n\n/**\n * Registers the callback function to update visualization on MQTT data received after reexecuting the sweva-graph.\n * @param {function} - Callback function for updating the visualization.\n */\nExecutionManager.prototype.onMQTTDataRecieved = function (callback) {\n    this.updateVisualizationNotifier = callback;\n};\n\nExecutionManager.prototype.sendDataToVisualization = function (result) {\n    if (this.updateVisualizationNotifier !== null) {\n        this.updateVisualizationNotifier(result);\n    }\n}\n\n\n/**\n * Registers a callback function that gets called whenever any asynchronous node re-executes parts of the composition.\n *\n * @param callback\n */\nExecutionManager.prototype.addReexecutionListener = function (callback, module_name) {\n    if (this.reexecutionListeners.length !== 0) {\n        for (var key in this.reexecutionListeners) {\n            if (this.reexecutionListeners[key].module_name === module_name) {\n                this.reexecutionListeners.splice(key, 1);\n            }\n        }\n        this.reexecutionListeners.push({\n            callback: callback,\n            module_name: module_name\n        });\n\n    } else if (module_name !== false) {\n        this.reexecutionListeners.push({\n            callback: callback,\n            module_name: module_name\n        });\n    }\n\n};\n\nExecutionManager.prototype.onModuleUpdate = function (module) {\n    for (var i in this.reexecutionListeners) {\n        if (this.reexecutionListeners[i].module_name === module.mqtt_sweva_parameters.module_name) this.reexecutionListeners[i].callback(module);\n    }\n};\n\n/**\n * Initializes all required composables, loads dependencies, validates.\n *\n * (IF) PARSE pipeline to JS object self gloabl to the executionManager !\n *\n * @param {Array.<string|Composable>} executionArray - Array of composables that will be executed.\n * @param {boolean} [isPureObject=false] - Set this to true, if passing pure JavaScript Objects and not just JSON.\n */\n//Global variable names\n\n\n\nExecutionManager.prototype.setup = function (executionArray, isPureObject) {\n\n    //internal recursive function to count how many modules are currently used\n    function countModules(composable) {\n        if (typeof composable.composables === 'undefined') {\n            return 1;\n        } else {\n            var count = 0;\n\n            for (var key in composable.composables) {\n                if (composable.composables.hasOwnProperty(key)) {\n                    //console.log(key, composable.composables[key]);\n                    count += countModules(composable.composables[key]);\n                }\n            }\n            //console.log('UPDATED Composable =', composable);\n            //console.log(\"Number of set up nodes in Composable: \" + count);\n            return count;\n        }\n    }\n\n    var needsLoading = [];\n    this.composables = {};\n    this.isReady = false;\n\n    this.wantsToExecute = false;\n    //if it is not an array, make it one\n    if (!Array.isArray(executionArray)) {\n        executionArray = [executionArray];\n    }\n    var names = [];\n    //for each composable, that will be executed\n    for (var i = 0; i < executionArray.length; i++) {\n        var composable = executionArray[i];\n        //if composable is provided as string, i.e. name it needs to be loaded\n        if (typeof composable === 'string') {\n            names.push(composable);\n            needsLoading.push(sweva.ComposableLoader.load(composable, this.composables, composable));\n        }\n        //otherwise a composable object is given\n        else {\n            if (typeof isPureObject === 'undefined' || !isPureObject) {\n                composable = sweva.ComposableLoader.convertToObject(composable, 'JSON');\n            }\n\n            if (composable.type === 'module') {\n                this.composables[composable.name] = new Module(composable, this);\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\n            } else {\n                this.composables[composable.name] = new Composition(composable, this);\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\n                //composables of a composition need also to be loaded\n                needsLoading.push(this.composables[composable.name].loadComposables());\n            }\n            names.push(composable.name);\n        }\n    }\n    var self = this;\n\n    //now wait for everything to load\n    Promise.all(needsLoading).then(function () {\n        //console.log('RAW Pipline / User Input=', composable);\n        //let's check, how many modules are used in total to have a rough estimate for progress tracking\n        var moduleCount = 0;\n        for (var i = 0; i < executionArray.length; i++) {\n            moduleCount += countModules(sweva.ComposableLoader.get(names[i]));\n\n        }\n        self.modulesTotal = moduleCount;\n        self.modulesDone = 0;\n\n        //composables should now contain everything\n        self.isReady = true;\n        console.log('all loaded');\n        //if we want to execute, before setup is ready, it is delayed and continued from here\n        if (self.wantsToExecute) {\n            self.wantsToExecute = false;\n            self.executeCallback();\n        }\n    })\n        .catch(function (error) {\n            sweva.ErrorManager.error(\n                new ExecutionError('Could not load all modules: ' + error,\n                    self.name, error));\n        });\n}\n\n/**\n * Calculates the current progress state and calls the optionally registered progressCallback.\n * It counts the percentage of the modules that have finished execution.\n *\n * @param {string} alias - The alias of the module, under which it is known to the parent composition.\n * @param {string} name - The name of the module.\n * @param {string} context - The context under which the module is executed (its parents).\n */\nExecutionManager.prototype.progressUpdate = function (alias, name, context,result) {\n    console.log('offloadingOutput$ Finished executing ',alias);\n    if (result==='offloading')\n        {\n            console.log('OFFLOADING flag catched in Exec manager !');\n\n            //prepare pipeline to be compatible for offloading\n            for (let key in intermediatePipeline.composables) {\n                if (intermediatePipeline.composables.hasOwnProperty(key)) {\n                    delete intermediatePipeline.composables[key].manager;\n                }\n                const composablesNode = intermediatePipeline.composables[key];\n                for (let prop in composablesNode) {\n                    if (composablesNode[prop] === null) {\n                        delete composablesNode[prop];\n                    }\n                }\n            }\n\n            intermediatePipeline =JSON.stringify(intermediatePipeline);\n\n            intermediatePipelineResults= JSON.stringify(intermediatePipelineResults);\n            let mergedPip ={intermediatePipeline:intermediatePipeline,intermediatePipelineResults:intermediatePipelineResults};\n\n            //console.log('offloading the merged Pipeline...');\n            //console.log(mergedPip);\n\n            broadcastToDiscoveryNetwork(mergedPip); //Offload merged Pipeline to best POT\n\n\n    }\n\n    //detects an offloaded pipeline :)\n    if (Object.keys(intermediatePipeline).length !== 0)\n    {\n        //consider result as linked nodes input\n        let nodeLinks = intermediatePipeline.links;\n        let moduleResult = result.out;\n\n        if (nodeLinks.hasOwnProperty(alias)){\n            let linksArray =Object.entries(nodeLinks[alias].out)[0];\n            console.log(linksArray);\n\n            intermediatePipelineResults[linksArray[0]]={\n                \"num\":moduleResult\n            };\n            console.log(intermediatePipelineResults);\n            delete intermediatePipeline.composables[alias];\n        }else {\n\n            //consider result as node output\n            intermediatePipelineResults[alias]={\n                \"out\":moduleResult\n            };\n            delete intermediatePipeline.composables[alias];\n        }\n\n\n    if (this.progressCallback !== null) {\n        this.modulesDone++;\n\n        var progress = this.modulesDone / +this.modulesTotal;\n\n        //make a value 0-100 and cut off decimal places\n        this.progressCallback((progress * 100).toFixed(0));\n\n    }}\n}\n\n\n\n/**\n * Executes the composables that were initalized during {@link ExecutionManager#setup}.\n * @param {Object} data - The data to use for the execution. If multiple composables will be executed,\n * the data property names must correspond to the composable names for a correct mapping of the data.\n * @param {Object} input - The input object for the execution. If multiple composables will be executed,\n * the input property names must correspond to the composable names for a correct mapping of the input.\n */\n\n\nExecutionManager.prototype.execute = function (data, input) {\n    /**\n     * An Array of executions, which are representing Modules (nodes).\n     * @type {Array}\n     */\n    var executions = [];\n    var self = this;\n\n    /*\n    console.log(\"///////////// Exec Manager inputs //////////////\");\n    console.log(\"data\");\n    console.log(data);\n    console.log(\"input\");\n    console.log(input);\n    console.log('self');\n    console.log(self);\n    console.log('intermediate Pipeline');\n    console.log(intermediatePipeline);\n    console.log(\"///////////////////////////\");\n    */\n    console.log('begin the execution');\n    return new Promise(function (resolve, reject) {\n        //closure function\n        //composables is the pipeline\n        //executions is the list of promises Module to be executed\n        var func = function (composables, executions, resolve, reject) {\n            /*\n            console.log(\"///////////// func inputs //////////////\");\n            console.log('Composables= ');\n            console.log(composables);\n            console.log('Executions= ');\n            console.log(executions);\n            console.log(\"///////////////////////////\");\n            */\n            return function () {\n\n                var onlyOneComposable = false;\n                // check if only one composable will be executed, because then you don't go into the loop.\n                if (Object.keys(composables).length === 1) {\n                    onlyOneComposable = true;\n                }\n\n                for (var key in composables) {\n                    if (composables.hasOwnProperty(key)) {\n                        /*\n                        console.log(\"///////////// if condition //////////////\");\n                        console.log('composables[key]= ');\n                        console.log(composables[key]);\n                        console.log('input[key] ');\n                        console.log(input[key]);\n                        console.log('key= ');\n                        console.log(key);\n                        console.log('self.progressUpdate.bind(self)= ');\n                        console.log(self.progressUpdate.bind(self));\n                        console.log(\"///////////////////////////\");\n                        */\n                        if (onlyOneComposable) {\n                            //execute function is defined in module.js\n                            executions.push(composables[key].execute(data, input, '', key, self.progressUpdate.bind(self)));\n                            //console.log(\" ====== Only One Composable ==== \");\n                        } else {\n                            //=== OFFLOADING === MODULE EXECUTION IS INITIALIZED !\n                            executions.push(composables[key].execute(data[key], input[key] || {}, '', key, self.progressUpdate.bind(self)));\n                            //console.log(\" ====== More than 1 composable ==== \");\n                        }\n\n                    }\n                }\n\n                // while loop to monitor the execution of the pipeline and update the offloading pipeline\n\n                //todo: implement a loop that updates a copy of the original pipeline each time a module is executed\n                // ( promise is fullfilled) and stops and returns the updated pipeline if one promise is rejected\n                //monitorPromises(executions);\n\n                // ELSE NO OFFLOADING ...\n                // when all the execution Promises have resolved...\n                Promise.all(executions).then(function (results) {\n                    console.log('all promises resolved');\n                    if (onlyOneComposable) {\n                        return resolve(results[0]);\n                    }\n                    resolve(results);\n                }).catch(function (results) {\n                    if (onlyOneComposable) {\n                        return resolve(results);\n                    }\n                    sweva.ErrorManager.error(\n                        new ExecutionError('Something unexpected happened: ' + results,\n                            this.name, results));\n                    reject(results);\n                });\n            }\n\n        };\n\n        if (self.isReady) {\n            func(self.composables, executions, resolve, reject)();\n        } else {\n            self.wantsToExecute = true;\n            self.executeCallback = func(self.composables, executions, resolve, reject);\n        }\n    });\n}\n//alias\nExecutionManager.prototype.run = ExecutionManager.prototype.execute;\nmodule.exports = ExecutionManager\n\n\n/*\n\n//////////////  EXPERT MODE  //////////////\n\n// inputs are extracted from device\nExecutionManager.prototype.deviceMonitoringIndex = async function () {\n    async function deviceMonitoringIndex() {\n        return new Promise((resolve, reject) => {\n            //this.window = window;\n            let metrics = [];\n\n            //Hardware metrics in Linux environments:\n            let cpu = await currentCPUusage()\n            let mem = await currentMemoryusage()\n            let storage = await availableStorage()\n            let battery = await availableBattery()\n            let charging = await isCharging()\n\n            console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\n            resolve(metrics.push(cpu, mem, storage,battery,charging));\n\n\n            //for windows testing purposes\n            let cpu = 60; //avg free cpu value for 3 measurements in %\n            let mem = 100000; // avilable free mem value in bytes\n            let storage = 2000000; // avilable free storage value in bytes\n            let battery = 80;\n            let charging = true;\n            //console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\n            metrics.push(cpu, mem, storage, battery, charging)\n            resolve(metrics);\n\n        })\n    }\n\n    return await deviceMonitoringIndex();\n\n}\n*/\n\n/*\n//inputs are extracted from frontend -> user input in backend\nExecutionManager.prototype.offloadingDecision = async function (od_CPU, od_mem, od_battery) {\n    async function offloadingDecission(wpn, od_CPU, od_mem, od_battery) {\n        return new Promise(async (resolve, reject) => {\n            const dmi = await ExecutionManager.prototype.deviceMonitoringIndex();\n            let decision = false;\n            //[0]:cpu\n            //[1]: memory\n            //[2]: storage\n            //dmi[3]: battery\n            //dmi[4]: is charging\n            if (od_CPU === 0 || od_mem === 0 || od_battery === 0) {\n                decision = true;\n            } else if (wpn[0] > (dmi[0] * od_CPU) || wpn[1] > (dmi[1] * od_mem) || dmi[3] < od_battery) {\n                decision = true;\n            }\n            resolve(decision);\n        });\n    }\n\n    return await offloadingDecission([sweva.ComposableLoader['totalCPUReq'], sweva.ComposableLoader['totalMemReq']], od_CPU, od_mem, od_battery);\n\n}\n*/\n\n//////////////  END  EXPERT MODE  //////////////\n","/**\n * Creates instance of support library\n *\n * Allow loading functionality separately, depending on what is needed for a specific runner\n *\n * @constructor\n */\n\nfunction SupportLibrary() {\n    this.functions = {};\n}\n\nSupportLibrary.prototype.loadTestSync = function() {\n    this.functions.test = {\n        async: false,\n        languageSpecific: {\n            typescript: {\n                parameterSig: \"url: string\",\n                returnSig: \"string\"\n            }\n        },\n        func: function (url) {\n            return url + url;\n        }\n    };\n}\n\nSupportLibrary.prototype.loadLogger = function() {\n    this.functions.log = {\n        description: \"Log the text to the browser console\",\n        async: false,\n        languageSpecific: {\n            typescript: {\n                parameterSig: \"text: string\",\n                returnSig: \"void\"\n            }},\n        func: function (text) {\n            console.log(text);\n        }};\n}\nSupportLibrary.prototype.loadHTTP = function() {\n    this.functions.httpRequest = {\n        description: \"Send a HTTP(S) request using the fetch api. Returns status=-1 on timeout!\",\n        async: true,\n        languageSpecific:{\n            typescript: {\n                parameterSig: \"url: string, headers:string = null | null, method:string = 'GET' | null, body:string = null | null, cache:string = 'no-store' | null, timeout:i32 = 5000\",\n                returnSig: \"text: string, status: int\"\n        }},\n        func: async function (url, headers, method, body, cache, timeout) {\n            let init = {};\n\n            if(headers != null)\n                init.headers = headers;\n            if(method != null)\n                init.method = method;\n            if(body != null)\n                init.body = body;\n            if(cache != null)\n                init.cache = cache;\n            else\n                init.cache = \"no-store\";\n\n            let controller = new AbortController();\n            let timeoutTimer = setTimeout(() => controller.abort(), timeout);\n            init.signal = controller.signal;\n\n            try{\n                let response = await fetch(url, init);\n                clearTimeout(timeoutTimer);\n                console.log(\"RESPONSE:\")\n                console.log(response);\n                let text = await response.text();\n                return [text, response.status];\n            } catch (e) {\n                return [\"TIMEOUT\", -1];\n            }\n        }};\n}\n\nmodule.exports = SupportLibrary;","let offloadingTarget = require(\"../offloading/offloadingTarget.js\");\n\nfunction createPeer(id, callback = () => {\n}) {\n    let peer = new Peer(id, {\n        host: \"milki-psy.dbis.rwth-aachen.de\", //localhost\n        port: 443, //9001\n        path: \"/offloadingNetwork\",\n    });\n    peer.on('open', function (ID) {\n        console.log('offloadingOutput$ My peer ID is = ' + ID);\n        callback();\n    });\n    peer.on(\"error\", function (err) {\n        console.log(\"Error: \" + err);\n    });\n    peer.on('disconnected', function (ID) {\n        console.log('peer ID ' + ID+' disconnected');\n        callback();\n    });\n\n    return peer;\n}\n\nfunction dataProcessingDevice(pipeline) {\n    let idAndDMIpairs = {};\n    let connections = {};\n    let allReceived = false;\n    let peer = createPeer('source', () => {\n\n        peer.on('connection', (connection) => {\n            //to check which peer sent a msg and which didn't YET!\n            connections[connection.peer]=false;\n            console.log('offloadingOutput$ connected to peer = '+connection.peer);\n            console.log(connections);\n            connection.on('data', (data) => {\n\n                if (Array.isArray(data) &&\n                    data.length > 0 &&\n                    data[data.length-1]==='dmi')\n                {\n                    console.log('received DMI from: ',connection.peer);\n                    console.log(data);\n                    //delete the flag\n                    connections[connection.peer]=true;\n                    console.log(connections);\n                    idAndDMIpairs[connection.peer]= data;\n\n                    allReceived= Object.values(connections).every(value => value === true);\n                    console.log(allReceived);\n\n                    //todo: have a timeout for robustness\n                    if (allReceived){\n\n                        return processMsgs();\n                    }\n\n\n                }else{\n                    console.log( \"Error encountered while receiving the dmi\");\n                    //TODO: error handling\n                }\n\n\n            });\n        });\n        function processMsgs () {\n\n            console.log('entered processMsgs functions');\n            let potId = offloadingTarget(idAndDMIpairs); //TODO: change processList to chooseBestPOT\n            if (potId === null ){\n                console.log( 'offloadingOutput$ No suitable peer in the SWeVA network found!');\n            }else{\n            console.log('offloadingOutput$ chosen potID for offloading = ' + potId);\n\n            let conn = peer.connect(potId);\n            conn.on('open', () => {\n                console.log('offloadingOutput$ connection opened with chosen POT !');\n                console.log('SENT PIPELINE = ',pipeline);\n                console.log('Type of PIPELINE = ', typeof pipeline);\n                conn.send(pipeline); //send pipeline here\n            });\n\n            conn.on('data', (data) => {\n\n                console.log('Pipeline result: ');\n                console.log(data); //receive pipeline results here\n\n                console.log('offloadingOutput$ ===== Recieved offloaded Result =====');\n                let msg = JSON.stringify(data);\n                msg = 'offloadingOutput$ '+msg;\n                console.log(msg);\n                peer.disconnect();\n\n            });\n\n\n        }\n\n        }\n    });\n\n}\nmodule.exports =dataProcessingDevice","\nlet availableOffloadingResources = require(\"../offloading/availableOffloadingResources\");\n\nfunction createPeer(id, callback = () => {\n}) {\n    let peer = new Peer(id, {\n        host: \"milki-psy.dbis.rwth-aachen.de\", //localhost\n        port: 443, //9001\n        path: \"/offloadingNetwork\",\n    });\n    peer.on('open', function (ID) {\n        console.log('offloadingOutput$ My peer ID is = ' + ID);\n        callback();\n    });\n    peer.on(\"error\", function (err) {\n        console.log(\"Error: \" + err);\n    });\n    peer.on('disconnected', function (ID) {\n        console.log('peer ID ' + ID+' disconnected');\n        callback();\n    });\n\n    return peer;\n}\n\nfunction potentialOffloadingTarget() {\n    let peer = createPeer('', () => {\n        peer.on('connection', (co)=>{\n            console.log('offloadingOutput$ I am chosen by Source Peer !');\n            co.on('data', (data)=>{\n                // Process Pipeline and send result\n                console.log('Data received from Source = ',data);\n                //TODO: is there a way to check if received date is really a pipeline ? yes\n                //TODO: user input ?\n                console.log('offloadingOutput$ Processing offloaded pipeline ...');\n                // setup and process the pipeline\n                processPipeline(data).then((result)=>{\n                    //send pipeline result\n                    console.log('OFFLOADING RESULT = ');\n                    console.log(result);\n                    console.log('offloadingOutput$ Finished processing the offloaded pipeline')\n                    co.send(result);\n                    console.log('offloadingOutput$ Result sent to offloading source peer')\n\n                }).catch(error => {\n                    console.error(error);\n                });\n            });\n        });\n\n        const connection = peer.connect('source');\n        connection.on('open', () => {\n            console.log('offloadingOutput$ connected to peer = '+connection.peer);\n\n            //TODO: get input from execution manager GET frontend.\n            //input offloading resources limits MUST be global value from user input (frontend)\n            let orList= sweva.ExecutionManager.getORList();\n            console.log('orList GET in potentialOffloadingTarget = ',orList);\n            availableOffloadingResources(orList).then(result => {\n\n                console.log('result is =',result);\n\n                    //push string 'dmi' as last entry in the array\n                    result.push('dmi');\n                    console.log(result);\n                    //send dmi as array\n                    connection.send(result);\n\n            }).catch(error => {\n                console.error(error);\n            });\n        });\n    });\n}\nfunction formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    const size = parseFloat((bytes / Math.pow(k, i)).toFixed(dm));\n\n    if (!isNaN(size)) {\n        return `${size} ${sizes[i]}`;\n    }\n}\n\nfunction formatTime(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000) % 60;\n    const minutes = Math.floor(milliseconds / (1000 * 60)) % 60;\n\n    const formattedTime = [];\n\n    if (minutes > 0) {\n        formattedTime.push(minutes + (minutes === 1 ? ' minute' : ' minutes'));\n    }\n    if (seconds >0){\n        formattedTime.push(seconds + (seconds === 1 ? ' second' : ' seconds'));\n    }\n\n    return formattedTime.join(', ');\n}\n\n//TODO: process pipeline in exe\nasync function processPipeline(receivedPipeline){\n    //TODO: extract intermediate result from pipeline with a new key in the object\n\n    console.log('entered processPipeline is POT ...');\n    console.log(receivedPipeline);\n\n    let {intermediatePipeline:ob1, intermediatePipelineResults:ob2} = receivedPipeline;\n    console.log('pipeline = ',ob1);\n    console.log('pipeline inputs = ',ob2);\n    let pipeline = JSON.parse(ob1);\n    let pipelineInputs = JSON.parse(ob2);\n    console.log('pipeline = ', pipeline);\n    console.log('pipeline inputs = ', pipelineInputs);\n\n\n    try {\n            let manager = new sweva.ExecutionManager();\n            manager.setup(pipeline);\n\n            let startMemExecute = performance.memory.usedJSHeapSize;\n            let startTimeExecute = Date.now();\n            let offloadedResult = await manager.execute(pipelineInputs, {});\n            let endTimeExecute = Date.now();\n            let endMemExecute = performance.memory.usedJSHeapSize;\n            console.log('OUTPUT offloaded msg = ',offloadedResult);\n\n            if (endMemExecute < startMemExecute) {\n            let temp = endMemExecute;\n            endMemExecute = startMemExecute;\n            startMemExecute = temp;\n            }\n\n            console.log('offloadingOutput$ Offloaded task Execution time: ',formatTime(endTimeExecute-startTimeExecute),' (',endTimeExecute-startTimeExecute,' ms)');\n            console.log('offloadingOutput$ Offloaded task Execution Memory: ',formatBytes(endMemExecute-startMemExecute),' (',endMemExecute-startMemExecute,' bytes)');\n            return offloadedResult;\n            }\n        catch (e){\n            console.log('Error encountered while executing the offloaded pipeline = ',e,'\\nPlease try again');\n            return 'Error encountered while executing the offloaded pipeline. Please try again';\n    }\n\n}\n\nmodule.exports = potentialOffloadingTarget","//USER input orList:\n\n// for Web environment:\n// orList = [mem%, battery%, isCharging (binary)]\n\n//for Node.JS environment:\n// orList = [cpu%, mem%, battery%, isCharging (binary)]\n\nasync function availableOffloadingResources(orList) {\n    if (orList[0] === 0 || orList[1] === 0) {\n        return [0,0,0,false];\n    }\n\n    let cpuLoad = 0;\n    let memUsage = 0;\n    let batteryPercent = 0;\n    let batteryIsCharging = false;\n\n    let listOfMetrics =[];\n    if (typeof window !== 'undefined') {\n\n        //Browser environment\n        memUsage = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100;\n        let battery = await navigator.getBattery();\n        batteryPercent = battery.level * 100;\n        batteryIsCharging = battery.charging;\n        console.log('memUsage = ',memUsage,'battery = ',batteryPercent, 'isCharging = ',batteryIsCharging);\n\n    }else{\n        //NodeJS environment\n        let si = require('systeminformation');\n\n        await Promise.all ([\n            si.currentLoad(),\n            si.mem(),\n            si.battery()\n        ]).then(([cpu, mem, battery]) => {\n            let memRSS = process.memoryUsage();\n            memUsage =  (memRSS.rss / mem.available) * 100;\n            cpuLoad = cpu.avgLoad;\n            batteryPercent = battery.percent;\n            batteryIsCharging = battery.acConnected;\n            //current cpu load higher than user limit (only for Node.js environment)\n            if (cpuLoad > orList[0]){\n                return [0,0,0,false]\n            }\n            //console.log('cpu = ',cpuLoad, 'memUsage = ',memUsage,'battery = ',batteryPercent, 'isCharging = ',batteryIsCharging);\n        }).catch((err) => {\n            console.log('Error occurred extracting metrics in the NodeJS environment. ERROR = ' + err);\n        });\n    }\n\n    if (\n        memUsage > orList[0] || // mem usage is higher than limit\n        batteryPercent < orList[1] || // battery is lower than minimum set by user\n        batteryIsCharging !== orList[2]\n    )\n    {\n        console.log('offloadingOutput$ Peer not chosen for the offloaded task.')\n        return [0,0,0,false]\n    }\n    else{\n    //Output metrics in percent %\n        listOfMetrics.push(cpuLoad,(100-memUsage),batteryPercent,batteryIsCharging);\n        return listOfMetrics;\n\n    }\n\n}\nmodule.exports = availableOffloadingResources\n\n/*\n// TEST function for Node.js environment\nsetInterval(() =>{\nconst startTime = process.hrtime();\navailableOffloadingResources([0,10,10,true]).then((result) => {\n    const endTime = process.hrtime(startTime);\n    console.log(result);\n    console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\n\n});},3000);\n*/\n\n","/*\n*\nUse this function to monitor any SWeVA execution and determine necessity of offloading\nbased on CPU , Memory and Battery metrics. This function can be used in both\nWeb and NodeJS environments !\n* USER Input odList = [Limit_cpu %, Limit_mem %, Limit_battery %]\n*/\n\nasync function offloadingDecision(odList) {\n    if (odList[0] === 0 || odList[1] === 0 || odList[2] === 0) {\n        console.log('offloadingOutput$ Offloading Triggered while monitoring the execution!');\n        return true;\n    }\n    let cpuLoad = 0;\n    let memUsage = 0;\n    let batteryPercent = 0;\n    let offloading = false;\n    if (typeof window !== 'undefined') {\n\n        //Browser environment\n        memUsage = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100;\n        let battery = await navigator.getBattery();\n        batteryPercent = battery.level * 100;\n        //console.log('Measured mem = ',memUsage,'battery = ',batteryPercent);\n\n    } else {\n\n        //NodeJS environment\n        let si = require('systeminformation');\n\n        await Promise.all ([\n            si.currentLoad(),\n            si.mem(),\n            si.battery()\n        ]).then(([cpu, mem, battery]) => {\n            let memRSS = process.memoryUsage();\n            memUsage = (memRSS.rss / mem.available) * 100;\n            cpuLoad = cpu.avgLoad;\n            batteryPercent = battery.percent;\n            console.log('cpu = ',cpuLoad, 'mem = ',memUsage,'battery = ',batteryPercent);\n        }).catch((err) => {\n            console.log('Error occurred extracting metrics in the NodeJS environment. ERROR = ' + err);\n        });\n    }\n            if (cpuLoad > odList[0]) {\n                console.log('offloadingOutput$ Monitoring = CPU limit exceeded');\n                offloading = true;\n            } else if (memUsage > odList[1]) {\n                console.log('offloadingOutput$ Monitoring = Memory limit exceeded');\n                offloading = true;\n            } else if (batteryPercent < odList[2]) {\n                console.log('offloadingOutput$ Monitoring = Battery limit exceeded');\n                offloading = true;\n            }\n\n    return offloading;\n}\nmodule.exports = offloadingDecision\n\n\n\n\n/*\n// TEST function for Node.js environment\n\n//let time =0;\nlet i=0;\nlet odList =[10,10,90];\nlet startTime = null;\nlet endTime =null;\nlet avgList=[] ;\n\n\nsetInterval(()=>{\n       startTime = process.hrtime();\n       offloadingDecision(odList).then ((result)=>{\n       endTime = process.hrtime(startTime);\n\n       console.log('Monitoring Round #'+i);\n       i++;\n       console.log(result);\n       console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\n   });\n\n\n},3000);\n*/\n\n\n","\n// orList = [cpu%, mem%, battery%, isCharging (binary)]\n\nfunction decisionValueOfPOT(offloadingResourcesList){\n    let advantageCPU = 100-offloadingResourcesList[0]; //Node.js env. only\n\n    let advantageMem = offloadingResourcesList[1]; // free memory in %\n\n    //battery is charging= MAX advantage !\n    let advantageBattery = 0;\n    //battery is not charging\n    if (!offloadingResourcesList[3]){\n        advantageBattery = 100-offloadingResourcesList[2];\n    }\n    //return advantageCPU + advantageMem - advantageBattery;\n    return advantageCPU + advantageMem - advantageBattery;\n}\n\n\n//We qualify by \"best\" the peer with highest current computation and battery\n\n//input iDandORpairs= { id : [ or list ] }\nfunction offloadingTarget (iDandORpairs){\n    let bestPOTId=null;\n    let temp = 0;\n    for ( let key in iDandORpairs ){\n\n        let dpot = decisionValueOfPOT(iDandORpairs[key]);\n        console.log('PEER = '+key+' DPOD = '+dpot);\n        if ( dpot>temp){\n            temp=dpot;\n            bestPOTId=key;\n        }\n    }\n    return bestPOTId;\n}\nmodule.exports = offloadingTarget\n\n/*\n//for testing purposes (Node.js env.)\nlet pairs = {\n    'id1' : [10,20,60,false],\n    'id2' : [50,30,100,false],\n    'id3' : [99,40,10,true],\n    'id4' : [ 0.00, 73.20, 80, false ]\n}\noffloadingTarget(pairs);\n*/\n","'use strict';\n\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\nvar Runner = require('../../core/runners/runner.js');\nvar Compiler = require('../../core/compilers/assemblyScriptCompiler.js');\nvar Composable = require('../../core/composables/composable.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar DefinitionError = require('../../core/errors/ExecutionError.js');\nvar SupportLibrary = require('../../core/execution/supportLibrary.js');\n\n\n/**\n * Parameters in the AssemblyScript run function starting with this string are used for the user inputs.\n */\nconst userInputSeparator = \"input_\";\n\n/**\n * The AssemblyScript runner supports strict TypeScript\n *\n * @constructor\n * @extends Runner\n *\n */\nfunction AssemblyScriptRunner() {\n    this.supportLib = new SupportLibrary();\n    this.supportLib.loadHTTP();\n    this.supportLib.loadLogger();\n    this.supportLib.loadTestSync();\n    this.compiler = new Compiler(this.supportLib);\n}\n\nAssemblyScriptRunner.prototype.getHTMLDescription = function () {\n    let description = \"Find the official AssemblyScript documentation on <a href='https://www.assemblyscript.org/introduction.html' target='_blank'>assemblyscript.org</a>.\\n\" +\n        \"The exported <b>run</b> function will be called with the parameters as data inputs and returned data as an output called <b>out</b>. User inputs have to be prefixed with <b>input_</b> and be the first parameters.\\n\" +\n        \"Additional outputs are generated for exported global variables. This allows returning values resulting from asynchronous callbacks.\\n\" +\n        \"If the <b>run</b> function has the return type \\\"void\\\" no default output is generated.\\n\";\n    description += \"\\n\" + this.compiler.supportLibraryDocumentation;\n\n    //HTML new lines\n    description.replaceAll(\"\\n\", \"<br>\");\n    return description;\n};\n\n//inherit properties\nAssemblyScriptRunner.prototype = Object.create(Runner.prototype);\nAssemblyScriptRunner.prototype.constructor = AssemblyScriptRunner;\n\nAssemblyScriptRunner.prototype.name = \"TypeScript (using AssemblyScript)\";\nAssemblyScriptRunner.prototype.id = \"typescript\";\n\n//=== OFFLOADING === Module => ASC code to WASM binary\nAssemblyScriptRunner.prototype.prepare = async function (module, callbackList = []) {\n    let definitionData = null;\n\n    if (!module.binary || module.binary.length === 0 || module.binaryHash !== this.calculateBinaryHash(module.binary)) {\n        module.binaryHash = null;\n        // monitored compilation in ASCcompiler.js\n        let compilerResult = await this.compiler.compile(module);\n            console.log('compilerResult');\n            console.log(compilerResult);\n            if (compilerResult === 'offloading') {\n                //todo: Offloading needed\n                console.log(\"offloading intercepted in ASCRunner.prepare()\")\n                return 'offloading';\n            } else {\n                module.binary = compilerResult.binaryData;\n                module.binaryHash = this.calculateBinaryHash(module.binary);\n                definitionData = compilerResult.definitionData;\n            }\n        }\n\n    const moduleInstance = await AsBind.instantiate(module.binary, {\n        module: this.generateFunctionDescription(callbackList)\n    });\n\n    if (definitionData != null)\n        this.createDataSchema(module, moduleInstance, definitionData);\n\n    return moduleInstance;\n}\n\n\n/**\n *  wrapper for\n */\nAssemblyScriptRunner.prototype.generateFunctionDescription = function (callbackList) {\n    let functions = {};\n\n    for (let funcName in this.supportLib.functions) {\n        let funcDesc = this.supportLib.functions[funcName];\n        let functionReference;\n\n        if (funcDesc.async) {\n            //params has callback name as first argument followed by regular parameters\n            functionReference = function (...params) {\n                let callbackName = params[0];\n                params.shift();\n\n                callbackList.push({\n                    promise: funcDesc.func(...params),\n                    params: params,\n                    funcName: funcName,\n                    callbackName: callbackName\n                });\n            }\n        } else {\n            functionReference = funcDesc.func;\n        }\n\n        functions[\"lib.\" + funcName] = functionReference;\n    }\n    return functions;\n}\n\nAssemblyScriptRunner.prototype.exec = async function (module, data, input) {\n\n    let callbackList = [];\n    /*\n    console.log(\"///////////// ASC runner inputs //////////////\");\n    console.log(\"module\");\n    console.log(module);\n    console.log(\"data\");\n    console.log(data);\n    console.log(\"input\");\n    console.log(input);\n    console.log(\"///////////////////////////\");\n     */\n    //compile and update schema\n    let instance = await this.prepare(module, callbackList);\n    console.log('instance');\n    console.log(instance);\n    if (instance === 'offloading') {\n        console.log('offloading intercepted in ASCRunner.exec()');\n        return 'offloading';\n\n    }\n    console.log('module prepared= ');\n    console.log(module);\n\n    let preparedParams = [];\n    if (module.inputNames.length > 0)\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.inputNames, input, module.context));\n    if (module.dataInNames.length > 0)\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.dataInNames, data, module.context));\n\n    //Module input\n    console.log('Module source code input');\n    console.log(preparedParams);\n\n    // returnValue returns the result from the binary execution of the WASM module\n    let returnValue = instance.exports.run(...preparedParams);\n    console.log('returnValue = ');\n    console.log(returnValue);\n\n    //finish executing all asynchronous functions ( if callback functions are needed by the module )\n    while (callbackList.length > 0) {\n        console.log(\"Remaining Callback: \");\n        console.log(callbackList[0]);\n        let result = null;\n        try {\n            //todo: monitor this?\n            result = await callbackList[0].promise;\n\n        } catch (err) {\n            throw new ExecutionError(\"Error in support function \" + callbackList[0].funcName + \" with parameters \" + callbackList[0].params + \"!\", module.context);\n        }\n\n        if (result !== null) {\n\n            let callbackDescriptor = instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName];\n            if (!callbackDescriptor)\n                throw new DefinitionError(\"Callback function with name \" + callbackList[0].callbackName + \" not found!\", module.context);\n\n            try {\n                if (callbackList[0].callbackName != null && callbackList[0].callbackName !== \"\") {\n                    //match number of parameters of callback\n                    let callbackParamCount = callbackDescriptor.parameters.length;\n                    let preparedResult = result.slice(0, callbackParamCount);\n                    console.log(instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName]);\n\n                    //Todo: do something with callback returns?\n                    let returnValue = instance.exports[callbackList[0].callbackName](...preparedResult);\n\n                    if (returnValue)\n                        console.log(\"Callback return: \" + returnValue);\n                }\n            } catch (err) {\n                throw new ExecutionError(\"Error while calling callback function \" + callbackList[0].callbackName + \" with parameters '\" + result + \"'!\", module.context);\n            }\n        }\n        callbackList.shift();\n    }\n    return this.collectOutputData(instance, returnValue);\n}\n\nAssemblyScriptRunner.prototype.collectOutputData = function (moduleInstance, returnValue) {\n    let result = {};\n\n    if (returnValue !== undefined) {\n        result.out = returnValue;\n    }\n    console.log('AsBind');\n    console.log(AsBind);\n    console.log('moduleInstance');\n    console.log(moduleInstance);\n\n\n    for (let exportedObj in moduleInstance.exports) {\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\n            result[exportedObj] = moduleInstance.exports[this.compiler.internalGetterPrefix + exportedObj]();\n        }\n    }\n    console.log('result');\n    console.log(result);\n    return result;\n}\n\nAssemblyScriptRunner.prototype.findParamAssignment = function (names, values, context) {\n    let preparedParams = [];\n    for (let i in names) {\n        let matchFound = false;\n        if (values !== undefined && values != null) {\n            for (let inputName in values) {\n                if (names[i] === inputName) {\n                    preparedParams.push(values[inputName]);\n                    matchFound = true;\n                }\n            }\n        }\n        if (!matchFound)\n            throw new DefinitionError(\"Mismatch between received and expected parameters!\\nExpected \\\"\" + names[i] + \"\\\", but not contained in received parameters: \" + JSON.stringify(values), context);\n    }\n    return preparedParams;\n}\n\n\nAssemblyScriptRunner.prototype.parseAssemblyScriptVariableNames = function (definitionData) {\n    let paramNames = Array();\n    let lines = definitionData.split(\"\\n\");\n    for (let line in lines) {\n        if (lines[line].indexOf(\"export function run\") === 0) {\n            let params = lines[line].substring(lines[line].indexOf('(') + 1, lines[line].indexOf(')')).split(', ');\n            for (let i in params) {\n                let paramName = params[i].substring(0, params[i].indexOf(\":\"));\n                if (paramName.length > 0)\n                    paramNames.push(paramName);\n            }\n        }\n    }\n    return paramNames;\n}\n\nAssemblyScriptRunner.prototype.createDataSchema = function (module, moduleInstance, definitionData) {\n    let run = moduleInstance.typeDescriptor.exportedFunctions.run;\n\n    //verify entrypoint exists\n    if (run === undefined)\n        throw new DefinitionError(\"Missing entrypoint: exported function named run is required, as an entrypoint.\", module.context);\n\n    //inputs\n    //parse parameter names of run function - replace, if AssemblyScript API, to access parameter names becomes available\n    let paramNames = this.parseAssemblyScriptVariableNames(definitionData);\n\n    if (run.parameters.length !== paramNames.length)\n        throw new DefinitionError(\"Parameter length mismatch! Parameters could not be parsed fully!\", module.context);\n\n    module.dataInNames = [];\n    module.inputNames = [];\n    module.dataInSchema = {type: \"object\", properties: {}};\n    module.inputSchema = {type: \"object\", properties: {}};\n\n    for (let i in run.parameters) {\n        if (paramNames[i].startsWith(userInputSeparator)) {\n            module.inputNames.push(paramNames[i]);\n\n            module.inputSchema.properties[paramNames[i]] = {type: run.parameters[i]};\n        } else {\n            module.dataInNames.push(paramNames[i]);\n\n            module.dataInSchema.properties[paramNames[i]] = {type: run.parameters[i]};\n        }\n    }\n\n    //outputs\n    module.dataOutNames = [];\n    module.dataOutSchema = {type: \"object\", properties: {}};\n    for (let exportedObj in moduleInstance.exports) {\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\n            module.dataOutNames.push(exportedObj);\n            module.dataOutSchema.properties[exportedObj] = {type: moduleInstance.typeDescriptor.exportedFunctions[this.compiler.internalGetterPrefix + exportedObj]}\n        }\n    }\n    if (run.returnType !== 'void') {\n        if (!module.dataOutNames.includes('out')) {\n            module.dataOutNames.push('out');\n            module.dataOutSchema.properties['out'] = {type: run.returnType}\n        } else {\n            throw new DefinitionError(\"Duplicate parameter called 'out'! Do not use 'out' as a name for exported variables!\", module.context);\n        }\n    }\n}\n\n\nmodule.exports = AssemblyScriptRunner;","'use strict';\n\n\n/**\n * The runner executes the compiled code made available by the compiler and contains a reference to the matching compiler\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\n * The setup needs to be done only once, while the execution can be repeated on different data.\n * \n * This is a default implementation, which should be subclassed for each supported language\n * \n * @constructor\n * @abstract\n */\nfunction Runner() {\n    /**\n    * Determines, if dependencies are loaded.\n    * @name ExecutionManager#modulesTotal\n    * @type {boolean}\n    */\n    this.setupCompleted = false;\n}\n\n/**\n * Run the provided binary or source code\n * @param {module} module - module containing source code/binary to run\n * @param {Object} data - data passed to the processing node\n * @param {Object} input - inputs passed to the processing node\n * @abstract\n */\nRunner.prototype.exec = function (module, data, input) {\n}\n\n/**\n * Prepare the provided module for execution:\n * - compile, if not already compiled\n * - update references to binary/hash\n * - update data schemes\n * This is also used to validate new source code while editing\n *\n * @param {module} module - module containing source code/binary to run\n * @return {Object} instance ready to execute\n * @throws CompileError\n *\n * @abstract\n */\nRunner.prototype.prepare = function (module) {}\n\n/**\n * End user friendly Name\n */\nRunner.prototype.name = \"Abstract Runner\"\n\n/**\n * ID used internally, to identify runners\n */\nRunner.prototype.id = \"abstract_runner\"\n\n/**\n * @return Description of the runner including a link to the official documentation and support library explanation as html.\n * @abstract\n */\nRunner.prototype.getHTMLDescription = function () {}\n\n\n/**\n * Calculates Hash used to compare binaries\n *\n * @param {Uint8Array} binary - binary to hash\n * @return hash\n *\n */\nRunner.prototype.calculateBinaryHash = function (binary) {\n    let hash = 0;\n    for(let i in binary) {\n        hash = ((hash << 8)-hash)+binary[i];\n    }\n    return hash;\n}\n\n/**\n * Determine data schema based on source/binary and write results to the module\n * The properties dataInSchema, dataOutSchema, inputSchema, dataInNames, dataOutNames, inputNames of the module can be written\n * Called automatically, when new source is compiled, but can be used to manually regenerate data schema\n *\n * @param {module} module - module containing source code/binary\n *\n * @abstract\n */\nRunner.prototype.createDataSchema = function (module) {\n}\n\nmodule.exports = Runner","'use strict';\nvar JsTokens = require('../../../node_modules/js-tokens/index.js');\n/**\n * Responsible to verify if a string complies to a safe  JavaScript subset.\n * A blacklist used to ensure no harmful operation can be performed by user defined scripts.\n * Currently the following tokens are forbidden:\n * arguments, callee, caller, constructor, eval, prototype, stack, unwatch, valueOf, watch, __proto__, __parent__, 'this', window, document, '[', ']', Function, 'with', uneval, toSource, setTimeout, setInterval\n * Use {@link SwevaScript#get} as a replacement for [].\n * \n * Additionally global variables are masked.\n * @constructor \n */\nfunction SwevaScript() {\n    /**\n    * List of forbidden tokens, that are not allowed in this JavaScript subset.\n    * @name SwevaScript#forbiddenList\n    * @type {Object.<string, boolean>}\n    */\n    this.forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    /**\n    * List of allowed global variables, that should not be masked.\n    * This is currently: Math, console \n    * @name SwevaScript#allowedGlobals\n    * @type {Object.<string, boolean>}\n    */\n    this.allowedGlobals = {\n        Math: true,\n        console: true,\n        'true': true,\n        'false': true\n    }\n}\n\n/**\n * Verifies if a JavaScript code complies to the safer JavaScript subset.\n * Does not rewrite or change the code, therefor you should DENY anything, that is considered harmful by this function.\n * \n * @param {string} code - The JavaScript code to verify for safety.\n * @returns {boolean} True, if the code does not contain forbidden tokens.\n */\nSwevaScript.prototype.verify = function (code) {\n    try {\n        //get an array of tokens using the tokenizer (external library)\n        var tokens = code.match(JsTokens);\n    } catch (e) {\n        return {\n            valid: false,\n            error: e.message\n        }\n    }\n   \n    //check for each token\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i].trim();\n        if (token.length > 0) {\n            //if token non empty: is it in the blacklist?\n            if (this.forbiddenList.hasOwnProperty(token)) {\n                return {\n                    valid: false,\n                    error: 'Invalid usage of ' + token\n                };\n            }\n        }\n\n        \n    }\n\n    //if no return reached before, we can assume there was no forbidden token present\n    return {\n        valid: true,\n        error: ''\n    }\n};\n\n/**\n * Replaces the forbidden [] accessor, by checking the property name during runtime.\n * If a forbidden property (see {@link SwevaScript}) is used, the property is not accessed.\n * \n * @param {Object} object - The object from which the property value is required.\n * @param {string|number} property - The name of the property to retrieve the value from.\n * returns {Object|boolean|string|number} - The value of the property, if an illegal property name is used null.\n */\nSwevaScript.prototype.get = function (object, property) {\n    var forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    //if a string is provided, check for being in the blacklist\n    if (typeof property === 'string') {\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\n            return object[property];\n        }\n    }\n    //numbers are not checked for being in the blacklist\n    else if (typeof property === 'number') {\n        return object[property];\n    }\n\n    console.error('Illegal property name: ' + property);\n    return null;\n}\n\nSwevaScript.prototype.set = function (object, property, value) {\n    var forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    //if a string is provided, check for being in the blacklist\n    if (typeof property === 'string') {\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\n            object[property] = value;\n        }\n        else {\n            console.error('Illegal property name: ' + property);\n        }\n    }\n    //numbers are not checked for being in the blacklist\n    else if (typeof property === 'number') {\n        object[property] = value;\n    }\n};\n\n/**\n * Sanitizes given Javascript code by verifying if it is a safer subset of JavaScript and masking global variables.\n * {@link SwevaScript#verify} is performed internally, so you do not need to verify explicitly beforehand.\n * @param {string} code - The JavaScript function to sanitize.\n * @param {function} errorCallback - A callback called, when an error occurs, has a string as a parameter with the error message.\n * @returns{function} - A function, that can be executed\n */\nSwevaScript.prototype.sanitize = function (code, errorCallback) {\n    //all in one line\n    //code = code.replace(/(\\r\\n|\\n|\\r)/gm, \"\"); \n   \n    var error = '';\n    //first make sure it is valid SwevaScript\n    var validation = this.verify(code);    \n    if (validation.valid) {        \n        var allowedGlobals = this.allowedGlobals;\n        //get all global variables except the exceptions we defined in {@link SwevaScript#allowedGlobals}\n        var globals = Object.keys(window).filter(function (obj) {\n            return !allowedGlobals.hasOwnProperty(obj)\n        }).join(',');\n        //we want to shadow all global variables except the ones we allow, by declaring them as local variables\n        //https://stackoverflow.com/posts/26917938/revisions\n        //var funcReg = /function *\\(([^()]*)\\)[ \\n\\t]*{(.*)}/gmi;\n        var funcReg = /function\\s*\\(([^()]*)\\)\\s\\{((.|\\n)*)\\}/gmi;\n        var match = funcReg.exec(code);\n       \n        //we extract funtion header (decrlaration with parameters) and body\n        if (match) {\n            \n            //enforce strict behavior, shadow globals, append verified code\n            var fn_text = '\"use strict\"; var ' + globals + ';' + match[2] + ';';\n            \n            var fn = new Function(match[1].split(','), fn_text);//generate sanitized function\n\n            return fn;\n        }\n        else {\n            error = 'Not a valid JS function';\n        }\n    }\n    else {\n        error = validation.error;\n    }\n    if (typeof errorCallback === 'function') {\n        errorCallback(error);\n    }\n    \n    return null;\n}\n\nmodule.exports = SwevaScript;","'use strict';\n\nvar compileSchema = require('./compile')\n    , resolve = require('./compile/resolve')\n    , Cache = require('./cache')\n    , SchemaObject = require('./compile/schema_obj')\n    , stableStringify = require('json-stable-stringify')\n    , formats = require('./compile/formats');\n\nmodule.exports = Ajv;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';\nvar SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i;\nfunction SCHEMA_URI_FORMAT_FUNC(str) {\n    return SCHEMA_URI_FORMAT.test(str);\n}\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n    if (!(this instanceof Ajv)) return new Ajv(opts);\n    var self = this;\n\n    this.opts = opts || {};\n    this._schemas = {};\n    this._refs = {};\n    this._formats = formats(this.opts.format);\n    this._cache = this.opts.cache || new Cache;\n    this._loadingSchemas = {};\n\n    // this is done on purpose, so that methods are bound to the instance\n    // (without using bind) so that they can be used without the instance\n    this.validate = validate;\n    this.compile = compile;\n    this.compileAsync = compileAsync;\n    this.addSchema = addSchema;\n    this.addMetaSchema = addMetaSchema;\n    this.validateSchema = validateSchema;\n    this.getSchema = getSchema;\n    this.removeSchema = removeSchema;\n    this.addFormat = addFormat;\n    this.errorsText = errorsText;\n\n    this._compile = _compile;\n\n    addInitialSchemas();\n    if (this.opts.formats) addInitialFormats();\n\n\n    /**\n     * Validate data using schema\n     * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     * @param  {Any} data to be validated\n     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n     */\n    function validate(schemaKeyRef, data) {\n        var v;\n        if (typeof schemaKeyRef == 'string') {\n            v = getSchema(schemaKeyRef);\n            if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n        } else {\n            var schemaObj = _addSchema(schemaKeyRef);\n            v = schemaObj.validate || _compile(schemaObj);\n        }\n\n        var valid = v(data);\n        self.errors = v.errors;\n        return valid;\n    }\n\n\n    /**\n     * Create validating function for passed schema.\n     * @param  {String|Object} schema\n     * @return {Function} validating function\n     */\n    function compile(schema) {\n        var schemaObj = _addSchema(schema);\n        return schemaObj.validate || _compile(schemaObj);\n    }\n\n\n    /**\n     * Create validating function for passed schema with asynchronous loading of missing schemas.\n     * `loadSchema` option should be a function that accepts schema uri and node-style callback.\n     * @param  {String|Object} schema\n     * @param  {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.\n     */\n    function compileAsync(schema, callback) {\n        var schemaObj;\n        try {\n            schemaObj = _addSchema(schema);\n        } catch(e) {\n            setTimeout(function() { callback(e); });\n            return;\n        }\n        if (schemaObj.validate)\n            setTimeout(function() { callback(null, schemaObj.validate); });\n        else {\n            if (typeof self.opts.loadSchema != 'function')\n                throw new Error('options.loadSchema should be a function');\n            _compileAsync(schema, callback, true);\n        }\n    }\n\n\n    function _compileAsync(schema, callback, firstCall) {\n        var validate;\n        try { validate = compile(schema); }\n        catch(e) {\n            if (e.missingSchema) loadMissingSchema(e);\n            else deferCallback(e);\n            return;\n        }\n        deferCallback(null, validate);\n\n        function loadMissingSchema(e) {\n            var ref = e.missingSchema;\n            if (self._refs[ref] || self._schemas[ref])\n                return callback(new Error('Schema ' + ref + ' is loaded but' + e.missingRef + 'cannot be resolved'));\n            var _callbacks = self._loadingSchemas[ref];\n            if (_callbacks) {\n                if (typeof _callbacks == 'function')\n                    self._loadingSchemas[ref] = [_callbacks, schemaLoaded];\n                else\n                    _callbacks[_callbacks.length] = schemaLoaded;\n            } else {\n                self._loadingSchemas[ref] = schemaLoaded;\n                self.opts.loadSchema(ref, function (err, sch) {\n                    var _callbacks = self._loadingSchemas[ref];\n                    delete self._loadingSchemas[ref];\n                    if (typeof _callbacks == 'function')\n                        _callbacks(err, sch);\n                    else\n                        for (var i=0; i<_callbacks.length; i++)\n                            _callbacks[i](err, sch);\n                });\n            }\n\n            function schemaLoaded(err, sch) {\n                if (err) callback(err);\n                else {\n                    if (!(self._refs[ref] || self._schemas[ref])) {\n                        try {\n                            addSchema(sch, ref);\n                        } catch(e) {\n                            callback(e);\n                            return;\n                        }\n                    }\n                    _compileAsync(schema, callback);\n                }\n            }\n        }\n\n        function deferCallback(err, validate) {\n            if (firstCall) setTimeout(function() { callback(err, validate); });\n            else callback(err, validate);\n        }\n    }\n\n\n    /**\n     * Adds schema to the instance.\n     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` will be ignored.\n     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n     */\n    function addSchema(schema, key, _skipValidation, _meta) {\n        if (Array.isArray(schema)){\n            for (var i=0; i<schema.length; i++) addSchema(schema[i]);\n            return;\n        }\n        // can key/id have # inside?\n        key = resolve.normalizeId(key || schema.id);\n        checkUnique(key);\n        var schemaObj = self._schemas[key] = _addSchema(schema, _skipValidation);\n        schemaObj.meta = _meta;\n    }\n\n\n    /**\n     * Add schema that will be used to validate other schemas\n     * removeAdditional option is alway set to false\n     * @param {Object} schema\n     * @param {String} key optional schema key\n     */\n    function addMetaSchema(schema, key, _skipValidation) {\n        addSchema(schema, key, _skipValidation, true);\n    }\n\n\n    /**\n     * Validate schema\n     * @param  {Object} schema schema to validate\n     * @return {Boolean}\n     */\n    function validateSchema(schema) {\n        var $schema = schema.$schema || META_SCHEMA_ID;\n        var currentUriFormat = self._formats.uri;\n        self._formats.uri = typeof currentUriFormat == 'function'\n                            ? SCHEMA_URI_FORMAT_FUNC\n                            : SCHEMA_URI_FORMAT;\n        var valid = validate($schema, schema);\n        self._formats.uri = currentUriFormat;\n        return valid;\n    }\n\n\n    /**\n     * Get compiled schema from the instance by `key` or `ref`.\n     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n     * @return {Function} schema validating function (with property `schema`).\n     */\n    function getSchema(keyRef) {\n        var schemaObj = _getSchemaObj(keyRef);\n        switch (typeof schemaObj) {\n            case 'object': return schemaObj.validate || _compile(schemaObj);\n            case 'string': return getSchema(schemaObj);\n        }\n    }\n\n\n    function _getSchemaObj(keyRef) {\n        keyRef = resolve.normalizeId(keyRef);\n        return self._schemas[keyRef] || self._refs[keyRef];\n    }\n\n\n    /**\n     * Remove cached schema\n     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     */\n    function removeSchema(schemaKeyRef) {\n        switch (typeof schemaKeyRef) {\n            case 'string':\n                var schemaObj = _getSchemaObj(schemaKeyRef);\n                self._cache.del(schemaObj.jsonStr);\n                delete self._schemas[schemaKeyRef];\n                delete self._refs[schemaKeyRef];\n                break;\n            case 'object':\n                var jsonStr = stableStringify(schemaKeyRef);\n                self._cache.del(jsonStr);\n                var id = schemaKeyRef.id;\n                if (id) {\n                    id = resolve.normalizeId(id);\n                    delete self._refs[id];\n                }\n        }\n    }\n\n\n    function _addSchema(schema, skipValidation) {\n        if (typeof schema != 'object') throw new Error('schema should be object');\n        var jsonStr = stableStringify(schema);\n        var cached = self._cache.get(jsonStr);\n        if (cached) return cached;\n\n        var id = resolve.normalizeId(schema.id);\n        if (id) checkUnique(id);\n\n        var ok = skipValidation || self.opts.validateSchema === false\n                 || validateSchema(schema);\n        if (!ok) {\n            var message = 'schema is invalid:' + errorsText();\n            if (self.opts.validateSchema == 'log') console.error(message);\n            else throw new Error(message);\n        }\n\n        var localRefs = resolve.ids.call(self, schema);\n\n        var schemaObj = new SchemaObject({\n            id: id,\n            schema: schema,\n            localRefs: localRefs,\n            jsonStr: jsonStr,\n        });\n\n        if (id[0] != '#') self._refs[id] = schemaObj;\n        self._cache.put(jsonStr, schemaObj);\n\n        return schemaObj;\n    }\n\n\n    function _compile(schemaObj, root) {\n        if (schemaObj.compiling) {\n            schemaObj.validate = callValidate;\n            callValidate.schema = schemaObj.schema;\n            callValidate.errors = null;\n            callValidate.root = root ? root : callValidate;\n            return callValidate;\n        }\n        schemaObj.compiling = true;\n\n        var currentRA = self.opts.removeAdditional;\n        if (currentRA && schemaObj.meta) self.opts.removeAdditional = false;\n        var v;\n        try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }\n        finally {\n            schemaObj.compiling = false;\n            if (currentRA) self.opts.removeAdditional = currentRA;\n        }\n\n        schemaObj.validate = v;\n        schemaObj.refs = v.refs;\n        schemaObj.refVal = v.refVal;\n        schemaObj.root = v.root;\n        return v;\n\n\n        function callValidate() {\n            var v = schemaObj.validate;\n            var result = v.apply(null, arguments);\n            callValidate.errors = v.errors;\n            return result;\n        }\n    }\n\n\n    function errorsText(errors, opts) {\n        errors = errors || self.errors;\n        if (!errors) return 'No errors';\n        opts = opts || {};\n        var separator = opts.separator || ', ';\n        var dataVar = opts.dataVar || 'data';\n\n        var text = errors.reduce(function(txt, e) {\n            return e ? txt + dataVar + e.dataPath + ' ' + e.message + separator : txt;\n        }, '');\n        return text.slice(0, -separator.length);\n    }\n\n\n    function addFormat(name, format) {\n        if (typeof format == 'string') format = new RegExp(format);\n        self._formats[name] = format;\n    }\n\n\n    function addInitialSchemas() {\n        if (self.opts.meta !== false) {\n            var metaSchema = require('./refs/json-schema-draft-04.json');\n            addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n            self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n        }\n\n        var optsSchemas = self.opts.schemas;\n        if (!optsSchemas) return;\n        if (Array.isArray(optsSchemas)) addSchema(optsSchemas);\n        else for (var key in optsSchemas) addSchema(optsSchemas[key], key);\n    }\n\n\n    function addInitialFormats() {\n        for (var name in self.opts.formats) {\n            var format = self.opts.formats[name];\n            addFormat(name, format);\n        }\n    }\n\n\n    function checkUnique(id) {\n        if (self._schemas[id] || self._refs[id])\n            throw new Error('schema with key or id \"' + id + '\" already exists');\n    }\n}\n","'use strict';\n\n\nvar Cache = module.exports = function Cache() {\n    this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n    this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n    return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n    delete this._cache[key];\n};\n","'use strict';\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': require('../dotjs/ref'),\n  anyOf: require('../dotjs/anyOf'),\n  format: require('../dotjs/format'),\n  maxLength: require('../dotjs/maxLength'),\n  minItems: require('../dotjs/minItems'),\n  minimum: require('../dotjs/minimum'),\n  oneOf: require('../dotjs/oneOf'),\n  required: require('../dotjs/required'),\n  dependencies: require('../dotjs/dependencies'),\n  items: require('../dotjs/items'),\n  maxProperties: require('../dotjs/maxProperties'),\n  minLength: require('../dotjs/minLength'),\n  multipleOf: require('../dotjs/multipleOf'),\n  pattern: require('../dotjs/pattern'),\n  uniqueItems: require('../dotjs/uniqueItems'),\n  allOf: require('../dotjs/allOf'),\n  enum: require('../dotjs/enum'),\n  maxItems: require('../dotjs/maxItems'),\n  maximum: require('../dotjs/maximum'),\n  minProperties: require('../dotjs/minProperties'),\n  not: require('../dotjs/not'),\n  properties: require('../dotjs/properties'),\n  validate: require('../dotjs/validate')\n};\n","'use strict';\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  var arrA = Array.isArray(a)\n    , arrB = Array.isArray(b)\n    , i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n    for (i = 0; i < a.length; i++)\n      if (!equal(a[i], b[i])) return false;\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    var keys = Object.keys(a);\n\n    if (keys.length !== Object.keys(b).length) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if (b[keys[i]] === undefined) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if(!equal(a[keys[i]], b[keys[i]])) return false;\n\n    return true;\n  }\n\n  return false;\n};\n","'use strict';\n\nvar util = require('./util');\n\nvar DATE = /^\\d\\d\\d\\d-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/;\nvar HOSTNAME = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?(?:\\#(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?$/i;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t ][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nformats.full = {\n  date: date,\n  'date-time': date_time,\n  uri: uri,\n  email: /^[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&''*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: hostname,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var month = +matches[1];\n  var day = +matches[2];\n  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];\n}\n\n\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.toLowerCase().split('t');\n  if (!date(dateTime[0])) return false;\n\n  var matches = dateTime[1].match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  return hour <= 23 && minute <= 59 && second <= 59;\n}\n\n\nfunction hostname(str) {\n  // http://tools.ietf.org/html/rfc1034#section-3.5\n  return str.length <= 255 && HOSTNAME.test(str);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|\\:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nfunction regex(str) {\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n","'use strict';\n\nvar resolve = require('./resolve')\n  , util = require('./util')\n  , equal = require('./equal');\n\ntry { var beautify = require('' + 'js-beautify').js_beautify; } catch(e) {}\n\nvar RULES = require('./rules')\n  , validateGenerator = require('../dotjs/validate');\n\nmodule.exports = compile;\n\n\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  var self = this\n    , refVal = [ undefined ] \n    , refs = {}\n    , patterns = []\n    , patternsHash = {};\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var formats = this._formats;\n\n  return localCompile(schema, root, localRefs, baseId);\n\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var validateCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errorPath: '\"\"',\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      opts: self.opts,\n      formats: formats\n    });\n\n    validateCode = refsCode(refVal) + patternsCode(patterns) + validateCode;\n\n    if (self.opts.beautify) {\n      var opts = self.opts.beautify === true ? { indent_size: 2 } : self.opts.beautify;\n      if (beautify) validateCode = beautify(validateCode, opts);\n      else console.error('\"npm install js-beautify\" to use beautify option');\n    }\n    // console.log('\\n\\n\\n *** \\n', validateCode);\n    var validate;\n    // try {\n      eval(validateCode);\n      refVal[0] = validate;\n    // } catch(e) {\n    //   console.log('Error compiling schema, function code:', validateCode);\n    //   throw e;\n    // }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (!v) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, self.opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v) {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(schema, code) {\n    return typeof schema == 'object'\n            ? { schema: schema, code: code }\n            : code;\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n}\n\n\nfunction patternsCode(patterns) {\n  return _arrCode(patterns, patternCode);\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction refsCode(refVal) {\n  return _arrCode(refVal, refCode);\n}\n\n\nfunction refCode(i, refVal) {\n  return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';\n}\n\n\nfunction _arrCode(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\n","'use strict';\n\nvar url = require('url')\n  , equal = require('./equal')\n  , util = require('./util')\n  , SchemaObject = require('./schema_obj');\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\n\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n  \n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject)\n    return inlineRef(refVal.schema, this.opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n\n  var res = _resolve.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject)\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  else if (schema)\n    v = inlineRef(schema, this.opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n\n  return v;\n}\n\n\nfunction _resolve(root, ref) {\n  /* jshint validthis: true */\n  var p = url.parse(ref, false, true)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(root.schema.id);\n  if (refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(root.schema.id);\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = _resolve.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    if (schema.id) baseId = resolveUrl(baseId, schema.id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum']);\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.hash = parsedRef.hash || '';\n  if (parsedRef.hash.slice(0,2) != '#/') return;\n  var parts = parsedRef.hash.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = unescapeFragment(part);\n      schema = schema[part];\n      if (!schema) break;\n      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);\n      if (schema.$ref) {\n        var $ref = resolveUrl(baseId, schema.$ref);\n        var res = _resolve.call(this, root, $ref);\n        if (res) {\n          schema = res.schema;\n          root = res.root;\n        }\n      }\n    }\n  }\n  if (schema && schema != root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum' \n]);\nfunction inlineRef(schema, limit) {\n  if (limit === undefined) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      else {\n        item = schema[key];\n        if (typeof item == 'object' && !checkNoRef(item)) return false;\n      }\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) count++;\n      else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction unescapeFragment(str) {\n  return decodeURIComponent(str)\n          .replace(/~1/g, '/')\n          .replace(/~0/g, '~');\n}\n\n\nfunction escapeFragment(str) {\n  str = str.replace(/~/g, '~0').replace(/\\//g, '~1');\n  return encodeURIComponent(str);\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = url.parse(id, false, true);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return (p.protocol||'') + (p.protocol?'//':'') + (p.host||'') + (p.path||'')  + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return url.resolve(baseId, id);\n}\n\n\nfunction resolveIds(schema) {\n  /* jshint validthis: true */\n  var id = normalizeId(schema.id);\n  var localRefs = {};\n  _resolveIds.call(this, schema, getFullPath(id, false), id);\n  return localRefs;\n\n  function _resolveIds(schema, fullPath, baseId) {\n    /* jshint validthis: true */\n    if (Array.isArray(schema))\n      for (var i=0; i<schema.length; i++)\n        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);\n    else if (schema && typeof schema == 'object') {\n      if (typeof schema.id == 'string') {\n        var id = baseId = baseId\n                          ? url.resolve(baseId, schema.id)\n                          : normalizeId(schema.id);\n\n        var refVal = this._refs[id];\n        if (typeof refVal == 'string') refVal = this._refs[refVal];\n        if (refVal && refVal.schema) {\n          if (!equal(schema, refVal.schema))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n        } else if (id != normalizeId(fullPath)) {\n          if (id[0] == '#') {\n            if (localRefs[id] && !equal(schema, localRefs[id]))\n              throw new Error('id \"' + id + '\" resolves to more than one schema');\n            localRefs[id] = schema;\n          } else\n            this._refs[id] = fullPath;\n        }\n      }\n      for (var key in schema)\n        _resolveIds.call(this, schema[key], fullPath+'/'+escapeFragment(key), baseId);\n    }\n  }\n}\n","'use strict';\n\nvar ruleModules = require('./_rules')\n  , util = require('./util');\n\nvar RULES = module.exports = [\n  { type: 'number',\n    rules: [ 'maximum', 'minimum', 'multipleOf'] },\n  { type: 'string',\n    rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n  { type: 'array',\n    rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },\n  { type: 'object',\n    rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },\n  { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }\n];\n\nRULES.all = [ 'type', 'additionalProperties', 'patternProperties' ];\n\n\nRULES.forEach(function (group) {\n  group.rules = group.rules.map(function (keyword) {\n    RULES.all.push(keyword);\n    return {\n      keyword: keyword,\n      code: ruleModules[keyword]\n    };\n  });\n});\n\nRULES.all = util.toHash(RULES.all);\n","'use strict';\n\nvar util = require('./util');\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n    util.copy(obj, this);\n}\n","'use strict';\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  ucs2length: ucs2length,\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  cleanUpCode: cleanUpCode,\n  cleanUpVarErrors: cleanUpVarErrors,\n  schemaHasRules: schemaHasRules,\n  stableStringify: require('json-stable-stringify'),\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1))';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);\n\n      return code;\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return IDENTIFIER.test(key)\n          ? '.' + key\n          : \"['\" + key.replace(SINGLE_QUOTE, '\\\\$&') + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&');\n}\n\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nvar EMPTY_ELSE = /else\\s*{\\s*}/g\n  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g\n  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;\nfunction cleanUpCode(out) {\n  return out.replace(EMPTY_ELSE, '')\n            .replace(EMPTY_IF_NO_ELSE, '')\n            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');\n}\n\n\nvar ERRORS_REGEXP = /[^v\\.]errors/g\n  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g\n  , RETURN_VALID = 'return errors === 0;'\n  , RETURN_TRUE = 'validate.errors = null; return true;';\n\nfunction cleanUpVarErrors(out) {\n  var matches = out.match(ERRORS_REGEXP);\n  if (matches && matches.length === 2)\n    return out.replace(REMOVE_ERRORS, '')\n              .replace(RETURN_VALID, RETURN_TRUE);\n  else\n    return out;\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction toQuotedString (str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr (currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath (currentPath, prop, jsonPointers) {\n  var path = jsonPointers\n              ? toQuotedString('/' + prop.replace(/~/g, '~0').replace(/\\//g, '~1'))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/' \\+ '/g, '');\n}\n","'use strict';\nmodule.exports = function generate_allOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['allOf'],\n    $schemaPath = it.schemaPath + '.' + 'allOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces.slice(0, -1));\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_anyOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['anyOf'],\n    $schemaPath = it.schemaPath + '.' + 'anyOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return it.util.schemaHasRules($sch, it.RULES.all);\n  });\n  if ($noEmptySchema) {\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ' + ($valid) + ' = ' + ($valid) + ' || valid' + ($it.level) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   { keyword: \\'' + ('anyOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match some schema in anyOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n    out = it.util.cleanUpCode(out);\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_dependencies(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['dependencies'],\n    $schemaPath = it.schemaPath + '.' + 'dependencies',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $schemaDeps = {},\n    $propertyDeps = {};\n  for ($property in $schema) {\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  for (var $property in $propertyDeps) {\n    out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined) { ';\n    $deps = $propertyDeps[$property];\n    out += ' if ( ';\n    var arr1 = $deps;\n    if (arr1) {\n      var $dep, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $dep = arr1[$i += 1];\n        if ($i) {\n          out += ' || ';\n        }\n        out += ' ' + ($data) + (it.util.getProperty($dep)) + ' === undefined ';\n      }\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      $closingBraces += '}';\n      out += ' else { ';\n    }\n    out += ' }';\n  }\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if (it.util.schemaHasRules($sch, it.RULES.all)) {\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '[\\'' + ($property) + '\\'] !== undefined) { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      out += ' ' + (it.validate($it)) + ' }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_enum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['enum'],\n    $schemaPath = it.schemaPath + '.' + 'enum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $i = 'i' + $lvl;\n  out += 'var enumSchema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ' , ' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<enumSchema' + ($lvl) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', enumSchema' + ($lvl) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; } if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_format(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['format'],\n    $schemaPath = it.schemaPath + '.' + 'format',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $format = it.formats[$schema];\n  if (it.opts.format !== false && $format) {\n    out += ' if (!   ';\n    if (typeof $format == 'function') {\n      out += ' formats' + (it.util.getProperty($schema)) + ' (' + ($data) + ') ';\n    } else {\n      out += ' formats' + (it.util.getProperty($schema)) + ' .test(' + ($data) + ') ';\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_items(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['items'],\n    $schemaPath = it.schemaPath + '.' + 'items',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + ';  if (!' + ($valid) + ') {  ';\n      if (!it.compositeRule && $breakOnError) {\n        out += ' validate.errors = [ { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }]; return false; ';\n      } else {\n        out += '  var err =   { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' }  ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          var $passData = $data + '[' + $i + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (valid' + ($it.level) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var i' + ($lvl) + ' = ' + ($schema.length) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n      var $passData = $data + '[i' + $lvl + ']';\n      var $code = it.validate($it);\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!valid' + ($it.level) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += '  for (var i' + ($lvl) + ' = ' + (0) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n    var $passData = $data + '[i' + $lvl + ']';\n    var $code = it.validate($it);\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!valid' + ($it.level) + ') break; ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxItems'],\n    $schemaPath = it.schemaPath + '.' + 'maxItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxLength'],\n    $schemaPath = it.schemaPath + '.' + 'maxLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxProperties'],\n    $schemaPath = it.schemaPath + '.' + 'maxProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maximum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maximum'],\n    $schemaPath = it.schemaPath + '.' + 'maximum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMaximum === true,\n    $op = $exclusive ? '<' : '<=',\n    $notOp = $exclusive ? '>=' : '>';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minItems'],\n    $schemaPath = it.schemaPath + '.' + 'minItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minLength'],\n    $schemaPath = it.schemaPath + '.' + 'minLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minProperties'],\n    $schemaPath = it.schemaPath + '.' + 'minProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minimum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minimum'],\n    $schemaPath = it.schemaPath + '.' + 'minimum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMinimum === true,\n    $op = $exclusive ? '>' : '>=',\n    $notOp = $exclusive ? '<=' : '<';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_multipleOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['multipleOf'],\n    $schemaPath = it.schemaPath + '.' + 'multipleOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'var division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schema) + ';if (' + ($data) + ' / ' + ($schema) + ' !== parseInt(division' + ($lvl) + ')) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_not(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['not'],\n    $schemaPath = it.schemaPath + '.' + 'not',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += ' ' + (it.validate($it)) + '  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (valid' + ($it.level) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be valid\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_oneOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['oneOf'],\n    $schemaPath = it.schemaPath + '.' + 'oneOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n      } else {\n        out += ' var valid' + ($it.level) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (valid' + ($it.level) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (valid' + ($it.level) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_pattern(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['pattern'],\n    $schemaPath = it.schemaPath + '.' + 'pattern',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  new RegExp($schema);\n  out += 'if (! ' + (it.usePattern($schema)) + '.test(' + ($data) + ') ) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_properties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['properties'],\n    $schemaPath = it.schemaPath + '.' + 'properties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  var $schemaKeys = Object.keys($schema || {}),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $requiredProperties = it.util.toHash(it.schema.required || []);\n  out += 'var ' + ($errs) + ' = errors;var valid' + ($it.level) + ' = true;';\n  if ($checkAdditional) {\n    out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { ';\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 5) {\n          out += ' || validate.schema' + ($schemaPath) + '[key' + ($lvl) + '] ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || key' + ($lvl) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n        } else {\n          out += ' valid' + ($it.level) + ' = false;  ';\n          if (!it.compositeRule && $breakOnError) {\n            out += ' validate.errors = [ { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }]; return false; ';\n          } else {\n            out += '  var err =   { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!valid' + ($it.level) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[key' + ($lvl) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!valid' + ($it.level) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          $it.schema = $sch;\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($requiredProperties[$propertyKey]) {\n            out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = false; ';\n            var $currentErrorPath = it.errorPath,\n              $missingProperty = it.util.escapeQuotes($propertyKey);\n            it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            it.errorPath = $currentErrorPath;\n            out += ' } else { ';\n          } else {\n            if ($breakOnError) {\n              out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = true; } else { ';\n            } else {\n              out += ' if (' + ($useData) + ' !== undefined) { ';\n            }\n          }\n          out += ' ' + ($code) + ' } ';\n        }\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  var arr4 = $pPropertyKeys;\n  if (arr4) {\n    var $pProperty, i4 = -1,\n      l4 = arr4.length - 1;\n    while (i4 < l4) {\n      $pProperty = arr4[i4 += 1];\n      var $sch = $pProperties[$pProperty];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n        out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { if (' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ')) { ';\n        $it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n        var $passData = $data + '[key' + $lvl + ']';\n        var $code = it.validate($it);\n        if (it.util.varOccurences($code, $nextData) < 2) {\n          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n        } else {\n          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n        }\n        if ($breakOnError) {\n          out += ' if (!valid' + ($it.level) + ') break; ';\n        }\n        out += ' } ';\n        if ($breakOnError) {\n          out += ' else valid' + ($it.level) + ' = true; ';\n        }\n        out += ' }  ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_ref(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['$ref'],\n    $schemaPath = it.schemaPath + '.' + '$ref',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      out += '  if (! ' + ('validate') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('validate') + '.errors; else vErrors = vErrors.concat(' + ('validate') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      out += '  if (! ' + ('root.refVal[0]') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('root.refVal[0]') + '.errors; else vErrors = vErrors.concat(' + ('root.refVal[0]') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = 'can\\'t resolve reference ' + $schema + ' from id ' + it.baseId;\n      if (it.opts.missingRefs == 'fail') {\n        console.log($message);\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        console.log($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        var $error = new Error($message);\n        $error.missingRef = it.resolve.url(it.baseId, $schema);\n        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));\n        throw $error;\n      }\n    } else if (typeof $refVal == 'string') {\n      out += '  if (! ' + ($refVal) + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ($refVal) + '.errors; else vErrors = vErrors.concat(' + ($refVal) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      var $it = it.util.copy(it),\n        $closingBraces = '';\n      $it.level++;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      var $code = it.validate($it);\n      if (/validate\\.schema/.test($code)) {\n        out += ' var rootSchema' + ($it.level) + ' = validate.schema; validate.schema = ' + ($refVal.code) + '; ' + ($code) + ' validate.schema = rootSchema' + ($it.level) + '; ';\n      } else {\n        out += ' ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n      }\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_required(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['required'],\n    $schemaPath = it.schemaPath + '.' + 'required',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if (it.schema.properties && Object.keys(it.schema.properties).length) {\n    var $required = [];\n    var arr1 = $schema;\n    if (arr1) {\n      var $property, i1 = -1,\n        l1 = arr1.length - 1;\n      while (i1 < l1) {\n        $property = arr1[i1 += 1];\n        var $propertySch = it.schema.properties[$property];\n        if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {\n          $required[$required.length] = $property;\n        }\n      }\n    }\n  } else {\n    var $required = $schema;\n  }\n  if ($required.length) {\n    var $currentErrorPath = it.errorPath;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($required.length <= 20) {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $property, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $property = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($property);\n            out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $property : $prop)) + ') ) ';\n          }\n        }\n        out += ') { ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { var ' + ($valid) + ' = ' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; }  if (!' + ($valid) + ') {  ';\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($required.length <= 20) {\n        var arr3 = $required;\n        if (arr3) {\n          var $property, $i = -1,\n            l3 = arr3.length - 1;\n          while ($i < l3) {\n            $property = arr3[$i += 1];\n            var $prop = it.util.getProperty($property),\n              $missingProperty = it.util.escapeQuotes($prop);\n            it.errorPath = it.util.getPath($currentErrorPath, $property, it.opts.jsonPointers);\n            out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'is a required property\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            if (it.opts.i18n) {\n              out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n            }\n            out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { if (' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'is a required property\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        if (it.opts.i18n) {\n          out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n        }\n        out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_uniqueItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['uniqueItems'],\n    $schemaPath = it.schemaPath + '.' + 'uniqueItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema && it.opts.uniqueItems !== false) {\n    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } if (!' + ($valid) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_validate(it) {\n  var out = '';\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.root.schema.id);\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    out += ' validate = function (data, dataPath) { \\'use strict\\'; var vErrors = null; ';\n    out += ' var errors = 0;     ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $typeSchema = it.schema.type;\n  var arr1 = it.RULES;\n  if (arr1) {\n    var $rulesGroup, i1 = -1,\n      l1 = arr1.length - 1;\n    while (i1 < l1) {\n      $rulesGroup = arr1[i1 += 1];\n      if ($shouldUseGroup($rulesGroup)) {\n        if ($rulesGroup.type) {\n          out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';\n        }\n        var arr2 = $rulesGroup.rules;\n        if (arr2) {\n          var $rule, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $rule = arr2[i2 += 1];\n            if ($shouldUseRule($rule)) {\n              out += ' ' + ($rule.code(it)) + ' ';\n              if ($breakOnError) {\n                $closingBraces1 += '}';\n              }\n            }\n          }\n        }\n        if ($breakOnError) {\n          out += ' ' + ($closingBraces1) + ' ';\n          $closingBraces1 = '';\n        }\n        if ($rulesGroup.type) {\n          out += ' } ';\n          if ($typeSchema && $typeSchema === $rulesGroup.type) {\n            var $typeChecked = true;\n            out += ' else {  ';\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            out += ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (errors === ';\n          if ($top) {\n            out += '0';\n          } else {\n            out += 'errs_' + ($lvl);\n          }\n          out += ') { ';\n          $closingBraces2 += '}';\n        }\n      }\n    }\n  }\n  if ($typeSchema && !$typeChecked) {\n    var $schemaPath = it.schemaPath + '.type',\n      $isArray = Array.isArray($typeSchema),\n      $method = $isArray ? 'checkDataTypes' : 'checkDataType';\n    out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    out += ' validate.errors = vErrors; ';\n    out += ' return errors === 0;       ';\n    out += ' }';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n  out = it.util.cleanUpCode(out);\n  if ($top && $breakOnError) {\n    out = it.util.cleanUpVarErrors(out);\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    for (var i = 0; i < $rulesGroup.rules.length; i++)\n      if ($shouldUseRule($rulesGroup.rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length)));\n  }\n  return out;\n}\n","module.exports={\n    \"id\": \"http://json-schema.org/draft-04/schema#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"description\": \"Core schema meta-schema\",\n    \"definitions\": {\n        \"schemaArray\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"items\": { \"$ref\": \"#\" }\n        },\n        \"positiveInteger\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n        },\n        \"positiveIntegerDefault0\": {\n            \"allOf\": [ { \"$ref\": \"#/definitions/positiveInteger\" }, { \"default\": 0 } ]\n        },\n        \"simpleTypes\": {\n            \"enum\": [ \"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\" ]\n        },\n        \"stringArray\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" },\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": {},\n        \"multipleOf\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"exclusiveMinimum\": true\n        },\n        \"maximum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"minimum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxLength\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minLength\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"pattern\": {\n            \"type\": \"string\",\n            \"format\": \"regex\"\n        },\n        \"additionalItems\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"items\": {\n            \"anyOf\": [\n                { \"$ref\": \"#\" },\n                { \"$ref\": \"#/definitions/schemaArray\" }\n            ],\n            \"default\": {}\n        },\n        \"maxItems\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minItems\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"uniqueItems\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxProperties\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minProperties\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\n        \"additionalProperties\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"definitions\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"properties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"patternProperties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"dependencies\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"anyOf\": [\n                    { \"$ref\": \"#\" },\n                    { \"$ref\": \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        \"enum\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        },\n        \"type\": {\n            \"anyOf\": [\n                { \"$ref\": \"#/definitions/simpleTypes\" },\n                {\n                    \"type\": \"array\",\n                    \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\n                    \"minItems\": 1,\n                    \"uniqueItems\": true\n                }\n            ]\n        },\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"not\": { \"$ref\": \"#\" }\n    },\n    \"dependencies\": {\n        \"exclusiveMaximum\": [ \"maximum\" ],\n        \"exclusiveMinimum\": [ \"minimum\" ]\n    },\n    \"default\": {}\n}\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});const t=\"undefined\"!=typeof BigUint64Array,e=Symbol(),r=new TextDecoder(\"utf-16le\",{fatal:!0});function n(t,e){let n=new Uint32Array(t)[e+-4>>>2]>>>1;const s=new Uint16Array(t,e,n);if(n<=192)return String.fromCharCode(...s);try{return r.decode(s)}catch{let t=\"\",e=0;for(;n-e>1024;)t+=String.fromCharCode(...s.subarray(e,e+=1024));return t+String.fromCharCode(...s.subarray(e))}}function s(t){const e={};function r(t,e){return t?n(t.buffer,e):\"<yet unknown>\"}const s=t.env=t.env||{};return s.abort=s.abort||function(t,n,o,i){const a=e.memory||s.memory;throw Error(`abort: ${r(a,t)} at ${r(a,n)}:${o}:${i}`)},s.trace=s.trace||function(t,n,...o){const i=e.memory||s.memory;console.log(`trace: ${r(i,t)}${n?\" \":\"\"}${o.slice(0,n).join(\", \")}`)},s.seed=s.seed||Date.now,t.Math=t.Math||Math,t.Date=t.Date||Date,e}const o=function(){throw Error(\"Operation requires compiling with --exportRuntime\")};function i(e,r){const s=r.exports,i=s.memory,a=s.table,c=s.__new||o,u=s.__pin||o,y=s.__unpin||o,l=s.__collect||o,p=s.__rtti_base,d=p?function(t){return t[p>>>2]}:o;function b(t){const e=function(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t]}(t);if(!(7&e))throw Error(`not an array: ${t}, flags=${e}`);return e}function h(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t+1]}function m(t){return 31-Math.clz32(t>>>6&31)}function g(t,e,r){const n=i.buffer;if(r)switch(t){case 2:return new Float32Array(n);case 3:return new Float64Array(n)}else switch(t){case 0:return new(e?Int8Array:Uint8Array)(n);case 1:return new(e?Int16Array:Uint16Array)(n);case 2:return new(e?Int32Array:Uint32Array)(n);case 3:return new(e?BigInt64Array:BigUint64Array)(n)}throw Error(`unsupported align: ${t}`)}function A(t){const e=new Uint32Array(i.buffer),r=b(e[t+-8>>>2]),n=m(r);let s=4&r?t:e[t+4>>>2];const o=2&r?e[t+12>>>2]:e[s+-4>>>2]>>>n;return g(n,2048&r,4096&r).subarray(s>>>=n,s+o)}function w(t,e,r){return new t(_(t,e,r))}function _(t,e,r){const n=i.buffer,s=new Uint32Array(n),o=s[r+4>>>2];return new t(n,o,s[o+-4>>>2]>>>e)}function T(t,r,n){e[`__get${r}`]=w.bind(null,t,n),e[`__get${r}View`]=_.bind(null,t,n)}return e.__new=c,e.__pin=u,e.__unpin=y,e.__collect=l,e.__newString=function(t){if(null==t)return 0;const e=t.length,r=c(e<<1,1),n=new Uint16Array(i.buffer);for(var s=0,o=r>>>1;s<e;++s)n[o+s]=t.charCodeAt(s);return r},e.__newArrayBuffer=function(t){if(null==t)return 0;const e=new Uint8Array(t),r=c(e.length,0);return new Uint8Array(i.buffer).set(e,r),r},e.__getString=function(t){if(!t)return null;const e=i.buffer;if(1!==new Uint32Array(e)[t+-8>>>2])throw Error(`not a string: ${t}`);return n(e,t)},e.__newArray=function(t,e){const r=b(t),n=m(r),s=e.length,o=c(s<<n,4&r?t:0);let a;if(4&r)a=o;else{u(o);const e=c(2&r?16:12,t);y(o);const f=new Uint32Array(i.buffer);f[e+0>>>2]=o,f[e+4>>>2]=o,f[e+8>>>2]=s<<n,2&r&&(f[e+12>>>2]=s),a=e}const f=g(n,2048&r,4096&r);if(16384&r)for(let t=0;t<s;++t){const r=e[t];f[(o>>>n)+t]=r}else f.set(e,o>>>n);return a},e.__getArrayView=A,e.__getArray=function(t){const e=A(t),r=e.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n},e.__getArrayBuffer=function(t){const e=i.buffer,r=new Uint32Array(e)[t+-4>>>2];return e.slice(t,t+r)},[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array].forEach((t=>{T(t,t.name,31-Math.clz32(t.BYTES_PER_ELEMENT))})),t&&[BigUint64Array,BigInt64Array].forEach((t=>{T(t,t.name.slice(3),3)})),e.__instanceof=function(t,e){const r=new Uint32Array(i.buffer);let n=r[t+-8>>>2];if(n<=d(r))do{if(n==e)return!0;n=h(n)}while(n);return!1},e.memory=e.memory||i,e.table=e.table||a,f(s,e)}function a(t){return\"undefined\"!=typeof Response&&t instanceof Response}function c(t){return t instanceof WebAssembly.Module}async function u(t,e={}){if(a(t=await t))return y(t,e);const r=c(t)?t:await WebAssembly.compile(t),n=s(e),o=await WebAssembly.instantiate(r,e);return{module:r,instance:o,exports:i(n,o)}}async function y(t,e={}){if(!WebAssembly.instantiateStreaming)return u(a(t=await t)?t.arrayBuffer():t,e);const r=s(e),n=await WebAssembly.instantiateStreaming(t,e),o=i(r,n.instance);return{...n,exports:o}}function f(t,r={}){const n=t.__argumentsLength?e=>{t.__argumentsLength.value=e}:t.__setArgumentsLength||t.__setargc||(()=>{});for(let s in t){if(!Object.prototype.hasOwnProperty.call(t,s))continue;const o=t[s];let i=s.split(\".\"),a=r;for(;i.length>1;){let t=i.shift();Object.prototype.hasOwnProperty.call(a,t)||(a[t]={}),a=a[t]}let c=i[0],u=c.indexOf(\"#\");if(u>=0){const r=c.substring(0,u),i=a[r];if(void 0===i||!i.prototype){const t=function(...e){return t.wrap(t.prototype.constructor(0,...e))};t.prototype={valueOf(){return this[e]}},t.wrap=function(r){return Object.create(t.prototype,{[e]:{value:r,writable:!1}})},i&&Object.getOwnPropertyNames(i).forEach((e=>Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e)))),a[r]=t}if(c=c.substring(u+1),a=a[r].prototype,/^(get|set):/.test(c)){if(!Object.prototype.hasOwnProperty.call(a,c=c.substring(4))){let r=t[s.replace(\"set:\",\"get:\")],n=t[s.replace(\"get:\",\"set:\")];Object.defineProperty(a,c,{get(){return r(this[e])},set(t){n(this[e],t)},enumerable:!0})}}else\"constructor\"===c?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:(a[c]=function(...t){return n(t.length),o(this[e],...t)}).original=o}else/^(get|set):/.test(c)?Object.prototype.hasOwnProperty.call(a,c=c.substring(4))||Object.defineProperty(a,c,{get:t[s.replace(\"set:\",\"get:\")],set:t[s.replace(\"get:\",\"set:\")],enumerable:!0}):\"function\"==typeof o&&o!==n?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:a[c]=o}return r}var l={instantiate:u,instantiateSync:function(t,e={}){const r=c(t)?t:new WebAssembly.Module(t),n=s(e),o=new WebAssembly.Instance(r,e);return{module:r,instance:o,exports:i(n,o)}},instantiateStreaming:y,demangle:f};function p(t,e,r){return e}function d(t,e,r){return t.exports[`__get${function(t){return t.startsWith(\"~lib/typedarray/\")?((t=t.slice(\"~lib/typedarray/\".length)).startsWith(\"Big\")&&(t=t.slice(3)),t):t}(r)}View`](e)}function b(t,e,r){return t.exports.__newArray(t.getTypeId(r),e)}function h(t){if(!t.startsWith(\"~lib/array/Array\"))throw Error(`${JSON.stringify(t)} is not an array type`);return t.slice(\"~lib/array/Array<\".length,-1)}const m=new Map([[\"void\",{ascToJs:p,jsToAsc:p}],[/^(i|u|f)(8|16|32|64)|[ui]size|bool|externref$/,{ascToJs:p,jsToAsc:p}],[\"~lib/string/String\",{ascToJs:function(t,e,r){return t.exports.__getString(e)},jsToAsc:function(t,e,r){return t.exports.__newString(e)}}],[\"~lib/typedarray/Int8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8ClampedArray\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/arraybuffer/ArrayBuffer\",{ascToJs:function(t,e,r){return t.exports.__getArrayBuffer(e)},jsToAsc:function(t,e,r){const n=t.exports.__new(e.byteLength,t.getTypeId(r));return new Uint8Array(t.exports.memory.buffer,n,e.byteLength).set(new Uint8Array(e)),n}}],[/^~lib\\/array\\/Array<.+>$/,{ascToJs:function(t,e,r){const n=h(r),s=A(n);return t.exports.__getArray(e).map((e=>s.ascToJs(t,e,n)))},jsToAsc:function(t,e,r){const n=h(r),s=A(n),o=e.map((e=>s.jsToAsc(t,e,n)));return t.exports.__newArray(t.getTypeId(r),o)}}]]),g=new Set;function A(t){for(const[e,r]of m)if(\"string\"!=typeof e){if(e.test(t))return r}else if(e===t)return r;return g.has(t)||(console.warn(`No converter for ${JSON.stringify(t)}, using pass-through`),g.add(t)),{ascToJs:p,jsToAsc:p}}function w(t){var e;return null===(e=A(t))||void 0===e?void 0:e.ascToJs}function _(t){var e;return null===(e=A(t))||void 0===e?void 0:e.jsToAsc}function T(t,e,r){const n=r.parameters.map(w),s=_(r.returnType);return function(...o){if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=o.map(((e,s)=>n[s](t,e,r.parameters[s]))),a=e(...i);return s(t,a,r.returnType)}}function j(t,e,r){const n=r.parameters.map(_),s=w(r.returnType);return(...o)=>{if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=[],a=o.map(((e,s)=>{const o=n[s](t,e,r.parameters[s]);return o!==e&&(t.exports.__pin(o),i.push(o)),o})),c=e(...a);return i.forEach((e=>t.exports.__unpin(e))),s(t,c,r.returnType)}}function x(t,{depth:e=Number.POSITIVE_INFINITY}={}){return e<=0||!t||\"object\"!=typeof t?t:Object.fromEntries(Object.entries(t).map((([t,r])=>[t,x(r,{depth:e-1})])))}function O(t){const e=WebAssembly.Module.customSections(t,\"as-bind_bindings\"),r=new TextDecoder(\"utf8\").decode(new Uint8Array(e[0]));try{return JSON.parse(r)}catch(t){throw Error(`Couldnt decode type descriptor: ${t.message}`)}}class U{constructor(){this.unboundExports={},this.exports={},this.importObject={}}getTypeId(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].id;throw Error(`Unknown type ${JSON.stringify(t)}`)}getTypeSize(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].byteSize;throw Error(`Unknown type ${JSON.stringify(t)}`)}_validate(){if(!WebAssembly.Module.exports(this.module).find((t=>\"__new\"===t.name)))throw Error(\"The AssemblyScript wasm module was not built with --exportRuntime, which is required.\");if(1!==WebAssembly.Module.customSections(this.module,\"as-bind_bindings\").length)throw new Error(\"The AssemblyScript wasm module was not built with the as-bind transform.\")}async _instantiate(t,e){this.module=await async function(t){if(t=await Promise.resolve(t),\"undefined\"!=typeof Response&&t instanceof Response){if(WebAssembly.compileStreaming)return WebAssembly.compileStreaming(t);t=await t.arrayBuffer()}return WebAssembly.compile(t)}(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=await async function(t,e){return l.instantiate(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateSync(t,e){this.module=new WebAssembly.Module(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=function(t,e){return l.instantiateSync(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateBindImportFunctions(t){this.importObject=x(t,{depth:2});for(const[e,r]of Object.entries(this.typeDescriptor.importedFunctions))for(const[n,s]of Object.entries(r))this.importObject[e][`__asbind_unbound_${n}`]=t[e][n],this.importObject[e][n]=T(this,t[e][n],s)}_instantiateBindUnboundExports(){const t=this.loadedModule.exports;this.exports=x(t,{depth:1});for(const[e,r]of Object.entries(this.typeDescriptor.exportedFunctions))this.exports[e]=j(this,t[e],r)}}exports.converters=m,exports.instantiate=async function(t,e){let r=new U;return await r._instantiate(t,e),r},exports.instantiateSync=function(t,e){let r=new U;return r._instantiateSync(t,e),r},exports.version=\"0.8.1\";\n","\"use strict\";\nvar mqtt = require(\"mqtt\");\nvar inArray = require(\"in-array\");\n\nvar RegularClientPrototype = mqtt.MqttClient.prototype;\n\nvar ASYNC_METHODS = [\"publish\",\n\t\"subscribe\",\n\t\"unsubscribe\",\n\t\"unsubscribe\",\n\t\"end\"\n];\n\nvar SYNC_METHODS = [\n\t\"emit\",\n\t\"addListener\",\n\t\"on\",\n\t\"once\",\n\t\"removeListener\",\n\t\"removeAllListeners\",\n\t\"setMaxListeners\",\n\t\"getMaxListeners\",\n\t\"listeners\",\n\t\"listenerCount\"\n];\n\nmodule.exports = {\n\tconnect: connect,\n\tAsyncClient: AsyncClient\n};\n\nfunction connect(brokerURL, opts) {\n\tvar client = mqtt.connect(brokerURL, opts);\n\n\tvar asyncClient = new AsyncClient(client);\n\n\treturn asyncClient;\n}\n\nfunction AsyncClient(client) {\n\tthis._client = client;\n}\n\nAsyncClient.prototype = {\n\tset handleMessage(newHandler) {\n\t\tthis._client.handleMessage = newHandler;\n\t},\n\tget handleMessage() {\n\t\treturn this._client.handleMessage;\n\t}\n};\n\nASYNC_METHODS.forEach(defineAsync);\nSYNC_METHODS.forEach(definePassthrough);\n\nfunction definePassthrough(name) {\n\tAsyncClient.prototype[name] = function() {\n\t\tvar client = this._client;\n\t\treturn client[name].apply(client, arguments);\n\t};\n}\n\nfunction defineAsync(name) {\n\tAsyncClient.prototype[name] = function asyncMethod() {\n\t\tvar client = this._client;\n\t\tvar args = [];\n\t\tvar length = arguments.length;\n\t\tvar i = 0;\n\t\tfor (i; i < length; i++)\n\t\t\targs.push(arguments[i]);\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\targs.push(makeCallback(resolve, reject));\n\t\t\tclient[name].apply(client, args);\n\t\t});\n\t};\n}\n\nfunction makeCallback(resolve, reject) {\n\treturn function(err, data) {\n\t\tif (err)\n\t\t\treject(err);\n\t\telse resolve(data);\n\t};\n}\n","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n  , Buffer       = require('safe-buffer').Buffer\n\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n  } else {\n    this.append(callback)\n  }\n\n  DuplexStream.call(this)\n}\n\n\nutil.inherits(BufferList, DuplexStream)\n\n\nBufferList.prototype._offset = function _offset (offset) {\n  var tot = 0, i = 0, _t\n  if (offset === 0) return [ 0, 0 ]\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t || i == this._bufs.length - 1)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\n\nBufferList.prototype.append = function append (buf) {\n  var i = 0\n\n  if (Buffer.isBuffer(buf)) {\n    this._appendBuffer(buf);\n  } else if (Array.isArray(buf)) {\n    for (; i < buf.length; i++)\n      this.append(buf[i])\n  } else if (buf instanceof BufferList) {\n    // unwrap argument into individual BufferLists\n    for (; i < buf._bufs.length; i++)\n      this.append(buf._bufs[i])\n  } else if (buf != null) {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf == 'number')\n      buf = buf.toString()\n\n    this._appendBuffer(Buffer.from(buf));\n  }\n\n  return this\n}\n\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\n\nBufferList.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback == 'function')\n    callback()\n}\n\n\nBufferList.prototype._read = function _read (size) {\n  if (!this.length)\n    return this.push(null)\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\n\nBufferList.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\n\nBufferList.prototype.get = function get (index) {\n  return this.slice(index, index + 1)[0]\n}\n\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start == 'number' && start < 0)\n    start += this.length\n  if (typeof end == 'number' && end < 0)\n    end += this.length\n  return this.copy(null, 0, start, end)\n}\n\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || Buffer.alloc(0)\n  if (srcEnd <= 0)\n    return dst || Buffer.alloc(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) { // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = end || this.length\n\n  if (start < 0)\n    start += this.length\n  if (end < 0)\n    end += this.length\n\n  var startOffset = this._offset(start)\n    , endOffset = this._offset(end)\n    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] == 0)\n    buffers.pop()\n  else\n    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])\n\n  if (startOffset[1] != 0)\n    buffers[0] = buffers[0].slice(startOffset[1])\n\n  return new BufferList(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\n\nBufferList.prototype.duplicate = function duplicate () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\n\nBufferList.prototype.destroy = function destroy () {\n  this._bufs.length = 0\n  this.length = 0\n  this.push(null)\n}\n\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\n\nmodule.exports = BufferList\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","\"use strict\";\n\nvar isValue             = require(\"type/value/is\")\n  , ensureValue         = require(\"type/value/ensure\")\n  , ensurePlainFunction = require(\"type/plain-function/ensure\")\n  , copy                = require(\"es5-ext/object/copy\")\n  , normalizeOptions    = require(\"es5-ext/object/normalize-options\")\n  , map                 = require(\"es5-ext/object/map\");\n\nvar bind = Function.prototype.bind\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n","\"use strict\";\n\nvar isValue         = require(\"type/value/is\")\n  , isPlainFunction = require(\"type/plain-function/is\")\n  , assign          = require(\"es5-ext/object/assign\")\n  , normalizeOpts   = require(\"es5-ext/object/normalize-options\")\n  , contains        = require(\"es5-ext/string/#/contains\");\n\nvar d = (module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif (arguments.length < 2 || typeof dscr !== \"string\") {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t\tw = contains.call(dscr, \"w\");\n\t} else {\n\t\tc = w = true;\n\t\te = false;\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n});\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== \"string\") {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (!isValue(get)) {\n\t\tget = undefined;\n\t} else if (!isPlainFunction(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (!isValue(set)) {\n\t\tset = undefined;\n\t} else if (!isPlainFunction(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t} else {\n\t\tc = true;\n\t\te = false;\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","var stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n\"use strict\";\n\nvar value = require(\"../../object/valid-value\");\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n","\"use strict\";\n\nvar numberIsNaN       = require(\"../../number/is-nan\")\n  , toPosInt          = require(\"../../number/to-pos-integer\")\n  , value             = require(\"../../object/valid-value\")\n  , indexOf           = Array.prototype.indexOf\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , abs               = Math.abs\n  , floor             = Math.floor;\n\nmodule.exports = function (searchElement/*, fromIndex*/) {\n\tvar i, length, fromIndex, val;\n\tif (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n\tlength = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < length; ++i) {\n\t\tif (objHasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (numberIsNaN(val)) return i; // Jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Array.from : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== \"function\") return false;\n\tarr = [\"raz\", \"dwa\"];\n\tresult = from(arr);\n\treturn Boolean(result && result !== arr && result[1] === \"dwa\");\n};\n","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArguments    = require(\"../../function/is-arguments\")\n  , isFunction     = require(\"../../function/is-function\")\n  , toPosInt       = require(\"../../number/to-pos-integer\")\n  , callable       = require(\"../../object/valid-callable\")\n  , validValue     = require(\"../../object/valid-value\")\n  , isValue        = require(\"../../object/is-value\")\n  , isString       = require(\"../../string/is-string\")\n  , isArray        = Array.isArray\n  , call           = Function.prototype.call\n  , desc           = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\n// eslint-disable-next-line complexity, max-lines-per-function\nmodule.exports = function (arrayLike/*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1]\n\t  , thisArg = arguments[2]\n\t  , Context\n\t  , i\n\t  , j\n\t  , arr\n\t  , length\n\t  , code\n\t  , iterator\n\t  , result\n\t  , getIterator\n\t  , value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (isValue(mapFn)) callable(mapFn);\n\tif (!this || this === Array || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tlength = arrayLike.length;\n\t\t\t\tif (length !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array((length = arrayLike.length));\n\t\t\t\tfor (i = 0; i < length; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tContext = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Context) arr = new Context();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tlength = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tlength = arrayLike.length;\n\t\t\tif (Context) arr = new Context();\n\t\t\tfor (i = 0, j = 0; i < length; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlength = j;\n\t\t}\n\t}\n\tif (length === undefined) {\n\t\t// Source: array or array-like\n\t\tlength = toPosInt(arrayLike.length);\n\t\tif (Context) arr = new Context(length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (Context) {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t} else {\n\t\t\t\tarr[i] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (Context) {\n\t\tdesc.value = null;\n\t\tarr.length = length;\n\t}\n\treturn arr;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , id = objToString.call((function () { return arguments; })());\n\nmodule.exports = function (value) { return objToString.call(value) === id; };\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);\n\nmodule.exports = function (value) {\n\treturn typeof value === \"function\" && isFunctionStringTag(objToString.call(value));\n};\n","\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Math.sign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== \"function\") return false;\n\treturn sign(10) === 1 && sign(-20) === -1;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || value === 0) return value;\n\treturn value > 0 ? 1 : -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Number.isNaN : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar numberIsNaN = Number.isNaN;\n\tif (typeof numberIsNaN !== \"function\") return false;\n\treturn !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\t// eslint-disable-next-line no-self-compare\n\treturn value !== value;\n};\n","\"use strict\";\n\nvar sign  = require(\"../math/sign\")\n  , abs   = Math.abs\n  , floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif (value === 0 || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n","\"use strict\";\n\nvar toInteger = require(\"./to-integer\")\n  , max       = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n\"use strict\";\n\nvar callable                = require(\"./valid-callable\")\n  , value                   = require(\"./valid-value\")\n  , bind                    = Function.prototype.bind\n  , call                    = Function.prototype.call\n  , keys                    = Object.keys\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb/*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== \"function\") method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n","\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src/*, srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","\"use strict\";\n\nvar aFrom  = require(\"../array/from\")\n  , assign = require(\"./assign\")\n  , value  = require(\"./valid-value\");\n\nmodule.exports = function (obj/*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n\"use strict\";\n\nvar create = Object.create, shim;\n\nif (!require(\"./set-prototype-of/is-implemented\")()) {\n\tshim = require(\"./set-prototype-of/shim\");\n}\n\nmodule.exports = (function () {\n\tvar nullObject, polyProps, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tpolyProps = {};\n\tdesc = { configurable: false, enumerable: false, writable: true, value: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === \"__proto__\") {\n\t\t\tpolyProps[name] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: undefined\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tpolyProps[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, polyProps);\n\n\tObject.defineProperty(shim, \"nullPolyfill\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: nullObject\n\t});\n\n\treturn function (prototype, props) {\n\t\treturn create(prototype === null ? nullObject : prototype, props);\n\t};\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./_iterate\")(\"forEach\");\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };\n","\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) { return val !== _undefined && val !== null; };\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };\n","\"use strict\";\n\nvar callable = require(\"./valid-callable\")\n  , forEach  = require(\"./for-each\")\n  , call     = Function.prototype.call;\n\nmodule.exports = function (obj, cb/*, thisArg*/) {\n\tvar result = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, targetObj, index) {\n\t\tresult[key] = call.call(cb, thisArg, value, key, targetObj, index);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1/*, options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (arg/*, args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) { set[name] = true; });\n\treturn set;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.setPrototypeOf : require(\"./shim\");\n","\"use strict\";\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};\n\nmodule.exports = function (/* CustomCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== \"function\") return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n};\n","/* eslint no-proto: \"off\" */\n\n// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n\"use strict\";\n\nvar isObject         = require(\"../is-object\")\n  , value            = require(\"../valid-value\")\n  , objIsPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty   = Object.defineProperty\n  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif (prototype === null || isObject(prototype)) return obj;\n\tthrow new TypeError(\"Prototype must be null or an object\");\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, \"level\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: status.level\n\t});\n})(\n\t(function () {\n\t\tvar tmpObj1 = Object.create(null)\n\t\t  , tmpObj2 = {}\n\t\t  , set\n\t\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n\t\tif (desc) {\n\t\t\ttry {\n\t\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\t\tset.call(tmpObj1, tmpObj2);\n\t\t\t} catch (ignore) {}\n\t\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n\t\t}\n\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n\t\ttmpObj1 = {};\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n\t\treturn false;\n\t})()\n);\n\nrequire(\"../create\");\n","\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n","\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n","\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(\"\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\ttypeof value === \"string\" ||\n\t\t(value &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\t(value instanceof String || objToString.call(value) === id)) ||\n\t\tfalse\n\t);\n};\n","\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , contains       = require(\"es5-ext/string/#/contains\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tIterator.call(this, arr);\n\tif (!kind) kind = \"value\";\n\telse if (contains.call(kind, \"key+value\")) kind = \"key+value\";\n\telse if (contains.call(kind, \"key\")) kind = \"key\";\n\telse kind = \"value\";\n\tdefineProperty(this, \"__kind__\", d(\"\", kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete ArrayIterator.prototype.constructor;\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === \"value\") return this.__list__[i];\n\t\tif (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n\t\treturn i;\n\t})\n});\ndefineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , callable    = require(\"es5-ext/object/valid-callable\")\n  , isString    = require(\"es5-ext/string/is-string\")\n  , get         = require(\"./get\");\n\nvar isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb /*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = \"array\";\n\telse if (isString(iterable)) mode = \"string\";\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () {\n\t\tbroken = true;\n\t};\n\tif (mode === \"array\") {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\treturn broken;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === \"string\") {\n\t\tlength = iterable.length;\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif (i + 1 < length) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n","\"use strict\";\n\nvar isArguments    = require(\"es5-ext/function/is-arguments\")\n  , isString       = require(\"es5-ext/string/is-string\")\n  , ArrayIterator  = require(\"./array\")\n  , StringIterator = require(\"./string\")\n  , iterable       = require(\"./valid-iterable\")\n  , iteratorSymbol = require(\"es6-symbol\").iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n","\"use strict\";\n\nvar clear    = require(\"es5-ext/array/#/clear\")\n  , assign   = require(\"es5-ext/object/assign\")\n  , callable = require(\"es5-ext/object/valid-callable\")\n  , value    = require(\"es5-ext/object/valid-value\")\n  , d        = require(\"d\")\n  , autoBind = require(\"d/auto-bind\")\n  , Symbol   = require(\"es6-symbol\");\n\nvar defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tdefineProperties(this, {\n\t\t__list__: d(\"w\", value(list)),\n\t\t__context__: d(\"w\", context),\n\t\t__nextIndex__: d(\"w\", 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on(\"_add\", this._onAdd);\n\tcontext.on(\"_delete\", this._onDelete);\n\tcontext.on(\"_clear\", this._onClear);\n};\n\n// Internal %IteratorPrototype% doesn't expose its constructor\ndelete Iterator.prototype.constructor;\n\ndefineProperties(\n\tIterator.prototype,\n\tassign(\n\t\t{\n\t\t\t_next: d(function () {\n\t\t\t\tvar i;\n\t\t\t\tif (!this.__list__) return undefined;\n\t\t\t\tif (this.__redo__) {\n\t\t\t\t\ti = this.__redo__.shift();\n\t\t\t\t\tif (i !== undefined) return i;\n\t\t\t\t}\n\t\t\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\t\t\tthis._unBind();\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t\tnext: d(function () {\n\t\t\t\treturn this._createResult(this._next());\n\t\t\t}),\n\t\t\t_createResult: d(function (i) {\n\t\t\t\tif (i === undefined) return { done: true, value: undefined };\n\t\t\t\treturn { done: false, value: this._resolve(i) };\n\t\t\t}),\n\t\t\t_resolve: d(function (i) {\n\t\t\t\treturn this.__list__[i];\n\t\t\t}),\n\t\t\t_unBind: d(function () {\n\t\t\t\tthis.__list__ = null;\n\t\t\t\tdelete this.__redo__;\n\t\t\t\tif (!this.__context__) return;\n\t\t\t\tthis.__context__.off(\"_add\", this._onAdd);\n\t\t\t\tthis.__context__.off(\"_delete\", this._onDelete);\n\t\t\t\tthis.__context__.off(\"_clear\", this._onClear);\n\t\t\t\tthis.__context__ = null;\n\t\t\t}),\n\t\t\ttoString: d(function () {\n\t\t\t\treturn \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n\t\t\t})\n\t\t},\n\t\tautoBind({\n\t\t\t_onAdd: d(function (index) {\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t++this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) {\n\t\t\t\t\tdefineProperty(this, \"__redo__\", d(\"c\", [index]));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t\t\t}, this);\n\t\t\t\tthis.__redo__.push(index);\n\t\t\t}),\n\t\t\t_onDelete: d(function (index) {\n\t\t\t\tvar i;\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t--this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) return;\n\t\t\t\ti = this.__redo__.indexOf(index);\n\t\t\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\t\t\tthis.__redo__.forEach(function (redo, j) {\n\t\t\t\t\tif (redo > index) this.__redo__[j] = --redo;\n\t\t\t\t}, this);\n\t\t\t}),\n\t\t\t_onClear: d(function () {\n\t\t\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\t\t\tthis.__nextIndex__ = 0;\n\t\t\t})\n\t\t})\n\t)\n);\n\ndefineProperty(\n\tIterator.prototype,\n\tSymbol.iterator,\n\td(function () {\n\t\treturn this;\n\t})\n);\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , isValue     = require(\"es5-ext/object/is-value\")\n  , isString    = require(\"es5-ext/string/is-string\");\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArray        = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn typeof value[iteratorSymbol] === \"function\";\n};\n","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, \"__length__\", d(\"\", str.length));\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete StringIterator.prototype.constructor;\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\t_next: d(function () {\n\t\tif (!this.__list__) return undefined;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t\treturn undefined;\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t})\n});\ndefineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n","\"use strict\";\n\nvar isIterable = require(\"./is-iterable\");\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Map : require('./polyfill');\n","'use strict';\n\nmodule.exports = function () {\n\tvar map, iterator, result;\n\tif (typeof Map !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tmap = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(map) !== '[object Map]') return false;\n\tif (map.size !== 3) return false;\n\tif (typeof map.clear !== 'function') return false;\n\tif (typeof map.delete !== 'function') return false;\n\tif (typeof map.entries !== 'function') return false;\n\tif (typeof map.forEach !== 'function') return false;\n\tif (typeof map.get !== 'function') return false;\n\tif (typeof map.has !== 'function') return false;\n\tif (typeof map.keys !== 'function') return false;\n\tif (typeof map.set !== 'function') return false;\n\tif (typeof map.values !== 'function') return false;\n\n\titerator = map.entries();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (!result.value) return false;\n\tif (result.value[0] !== 'raz') return false;\n\tif (result.value[1] !== 'one') return false;\n\n\treturn true;\n};\n","// Exports true if environment provides native `Map` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Map === 'undefined') return false;\n\treturn (Object.prototype.toString.call(new Map()) === '[object Map]');\n}());\n","'use strict';\n\nmodule.exports = require('es5-ext/object/primitive-set')('key',\n\t'value', 'key+value');\n","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , d                 = require('d')\n  , Iterator          = require('es6-iterator')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n  , kinds             = require('./iterator-kinds')\n\n  , defineProperties = Object.defineProperties\n  , unBind = Iterator.prototype._unBind\n  , MapIterator;\n\nMapIterator = module.exports = function (map, kind) {\n\tif (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n\tIterator.call(this, map.__mapKeysData__, map);\n\tif (!kind || !kinds[kind]) kind = 'key+value';\n\tdefineProperties(this, {\n\t\t__kind__: d('', kind),\n\t\t__values__: d('w', map.__mapValuesData__)\n\t});\n};\nif (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\nMapIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(MapIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__values__[i];\n\t\tif (this.__kind__ === 'key') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__values__[i]];\n\t}),\n\t_unBind: d(function () {\n\t\tthis.__values__ = null;\n\t\tunBind.call(this);\n\t}),\n\ttoString: d(function () { return '[object Map Iterator]'; })\n});\nObject.defineProperty(MapIterator.prototype, toStringTagSymbol,\n\td('c', 'Map Iterator'));\n","'use strict';\n\nvar clear          = require('es5-ext/array/#/clear')\n  , eIndexOf       = require('es5-ext/array/#/e-index-of')\n  , setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , callable       = require('es5-ext/object/valid-callable')\n  , validValue     = require('es5-ext/object/valid-value')\n  , d              = require('d')\n  , ee             = require('event-emitter')\n  , Symbol         = require('es6-symbol')\n  , iterator       = require('es6-iterator/valid-iterable')\n  , forOf          = require('es6-iterator/for-of')\n  , Iterator       = require('./lib/iterator')\n  , isNative       = require('./is-native-implemented')\n\n  , call = Function.prototype.call\n  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf\n  , MapPoly;\n\nmodule.exports = MapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], keys, values, self;\n\tif (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (Map !== MapPoly)) {\n\t\tself = setPrototypeOf(new Map(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) iterator(iterable);\n\tdefineProperties(self, {\n\t\t__mapKeysData__: d('c', keys = []),\n\t\t__mapValuesData__: d('c', values = [])\n\t});\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tvar key = validValue(value)[0];\n\t\tvalue = value[1];\n\t\tif (eIndexOf.call(keys, key) !== -1) return;\n\t\tkeys.push(key);\n\t\tvalues.push(value);\n\t}, self);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(MapPoly, Map);\n\tMapPoly.prototype = Object.create(Map.prototype, {\n\t\tconstructor: d(MapPoly)\n\t});\n}\n\nee(defineProperties(MapPoly.prototype, {\n\tclear: d(function () {\n\t\tif (!this.__mapKeysData__.length) return;\n\t\tclear.call(this.__mapKeysData__);\n\t\tclear.call(this.__mapValuesData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return false;\n\t\tthis.__mapKeysData__.splice(index, 1);\n\t\tthis.__mapValuesData__.splice(index, 1);\n\t\tthis.emit('_delete', index, key);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result;\n\t\tcallable(cb);\n\t\titerator = this.entries();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tcall.call(cb, thisArg, this.__mapValuesData__[result],\n\t\t\t\tthis.__mapKeysData__[result], this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\tget: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return;\n\t\treturn this.__mapValuesData__[index];\n\t}),\n\thas: d(function (key) {\n\t\treturn (eIndexOf.call(this.__mapKeysData__, key) !== -1);\n\t}),\n\tkeys: d(function () { return new Iterator(this, 'key'); }),\n\tset: d(function (key, value) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key), emit;\n\t\tif (index === -1) {\n\t\t\tindex = this.__mapKeysData__.push(key) - 1;\n\t\t\temit = true;\n\t\t}\n\t\tthis.__mapValuesData__[index] = value;\n\t\tif (emit) this.emit('_add', index, key);\n\t\treturn this;\n\t}),\n\tsize: d.gs(function () { return this.__mapKeysData__.length; }),\n\tvalues: d(function () { return new Iterator(this, 'value'); }),\n\ttoString: d(function () { return '[object Map]'; })\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {\n\treturn this.entries();\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? require(\"ext/global-this\").Symbol\n\t: require(\"./polyfill\");\n","\"use strict\";\n\nvar global     = require(\"ext/global-this\")\n  , validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar Symbol = global.Symbol;\n\tvar symbol;\n\tif (typeof Symbol !== \"function\") return false;\n\tsymbol = Symbol(\"test symbol\");\n\ttry { String(symbol); }\n\tcatch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\tif (typeof value === \"symbol\") return true;\n\tif (!value.constructor) return false;\n\tif (value.constructor.name !== \"Symbol\") return false;\n\treturn value[value.constructor.toStringTag] === \"Symbol\";\n};\n","\"use strict\";\n\nvar d = require(\"d\");\n\nvar create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;\n\nvar created = create(null);\nmodule.exports = function (desc) {\n\tvar postfix = 0, name, ie11BugWorkaround;\n\twhile (created[desc + (postfix || \"\")]) ++postfix;\n\tdesc += postfix || \"\";\n\tcreated[desc] = true;\n\tname = \"@@\" + desc;\n\tdefineProperty(\n\t\tobjPrototype,\n\t\tname,\n\t\td.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t})\n\t);\n\treturn name;\n};\n","\"use strict\";\n\nvar d            = require(\"d\")\n  , NativeSymbol = require(\"ext/global-this\").Symbol;\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t\t// fallback to eventual native implementation of given symbol\n\t\thasInstance: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill(\"hasInstance\")\n\t\t),\n\t\tisConcatSpreadable: d(\n\t\t\t\"\",\n\t\t\t(NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\t\t\tSymbolPolyfill(\"isConcatSpreadable\")\n\t\t),\n\t\titerator: d(\"\", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill(\"iterator\")),\n\t\tmatch: d(\"\", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill(\"match\")),\n\t\treplace: d(\"\", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill(\"replace\")),\n\t\tsearch: d(\"\", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill(\"search\")),\n\t\tspecies: d(\"\", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill(\"species\")),\n\t\tsplit: d(\"\", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill(\"split\")),\n\t\ttoPrimitive: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill(\"toPrimitive\")\n\t\t),\n\t\ttoStringTag: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill(\"toStringTag\")\n\t\t),\n\t\tunscopables: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill(\"unscopables\")\n\t\t)\n\t});\n};\n","\"use strict\";\n\nvar d              = require(\"d\")\n  , validateSymbol = require(\"../../../validate-symbol\");\n\nvar registry = Object.create(null);\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\tfor: d(function (key) {\n\t\t\tif (registry[key]) return registry[key];\n\t\t\treturn (registry[key] = SymbolPolyfill(String(key)));\n\t\t}),\n\t\tkeyFor: d(function (symbol) {\n\t\t\tvar key;\n\t\t\tvalidateSymbol(symbol);\n\t\t\tfor (key in registry) {\n\t\t\t\tif (registry[key] === symbol) return key;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t})\n\t});\n};\n","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d                    = require(\"d\")\n  , validateSymbol       = require(\"./validate-symbol\")\n  , NativeSymbol         = require(\"ext/global-this\").Symbol\n  , generateName         = require(\"./lib/private/generate-name\")\n  , setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\")\n  , setupSymbolRegistry  = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create\n  , defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty;\n\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n} else {\n\tNativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = description === undefined ? \"\" : String(description);\n\treturn defineProperties(symbol, {\n\t\t__description__: d(\"\", description),\n\t\t__name__: d(\"\", generateName(description))\n\t});\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d(\"\", function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return \"Symbol (\" + validateSymbol(this).__description__ + \")\"; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(\n\tSymbolPolyfill.prototype,\n\tSymbolPolyfill.toPrimitive,\n\td(\"\", function () {\n\t\tvar symbol = validateSymbol(this);\n\t\tif (typeof symbol === \"symbol\") return symbol;\n\t\treturn symbol.toString();\n\t})\n);\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])\n);\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])\n);\n","\"use strict\";\n\nvar isSymbol = require(\"./is-symbol\");\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ is resolved with global context, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? globalThis : require(\"./implementation\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tif (typeof globalThis !== \"object\") return false;\n\tif (!globalThis) return false;\n\treturn globalThis.Array === Array;\n};\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * in-array <https://github.com/jonschlinkert/in-array>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\nmodule.exports = function inArray (arr, val) {\n  arr = arr || [];\n  var len = arr.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    if (arr[i] === val) {\n      return true;\n    }\n  }\n  return false;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// Copyright 2014, 2015 Simon Lydell\n// X11 (MIT) Licensed. (See LICENSE.)\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nmodule.exports = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyu]{1,5}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|((?:0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?))|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]{1,6}\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-*\\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nmodule.exports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0]}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\n\n/* Protocol - protocol constants */\nvar protocol = module.exports\n\n/* Command code => mnemonic */\nprotocol.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'reserved'\n}\n\n/* Mnemonic => Command code */\nprotocol.codes = {}\nfor (var k in protocol.types) {\n  var v = protocol.types[k]\n  protocol.codes[v] = k\n}\n\n/* Header */\nprotocol.CMD_SHIFT = 4\nprotocol.CMD_MASK = 0xF0\nprotocol.DUP_MASK = 0x08\nprotocol.QOS_MASK = 0x03\nprotocol.QOS_SHIFT = 1\nprotocol.RETAIN_MASK = 0x01\n\n/* Length */\nprotocol.LENGTH_MASK = 0x7F\nprotocol.LENGTH_FIN_MASK = 0x80\n\n/* Connack */\nprotocol.SESSIONPRESENT_MASK = 0x01\nprotocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])\nprotocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT])\n\n/* Connect */\nprotocol.USERNAME_MASK = 0x80\nprotocol.PASSWORD_MASK = 0x40\nprotocol.WILL_RETAIN_MASK = 0x20\nprotocol.WILL_QOS_MASK = 0x18\nprotocol.WILL_QOS_SHIFT = 3\nprotocol.WILL_FLAG_MASK = 0x04\nprotocol.CLEAN_SESSION_MASK = 0x02\nprotocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT])\n\nfunction genHeader (type) {\n  return [0, 1, 2].map(function (qos) {\n    return [0, 1].map(function (dup) {\n      return [0, 1].map(function (retain) {\n        var buf = new Buffer(1)\n        buf.writeUInt8(\n          protocol.codes[type] << protocol.CMD_SHIFT |\n          (dup ? protocol.DUP_MASK : 0) |\n          qos << protocol.QOS_SHIFT | retain, 0, true)\n        return buf\n      })\n    })\n  })\n}\n\n/* Publish */\nprotocol.PUBLISH_HEADER = genHeader('publish')\n\n/* Subscribe */\nprotocol.SUBSCRIBE_HEADER = genHeader('subscribe')\n\n/* Unsubscribe */\nprotocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')\n\n/* Confirmations */\nprotocol.ACKS = {\n  unsuback: genHeader('unsuback'),\n  puback: genHeader('puback'),\n  pubcomp: genHeader('pubcomp'),\n  pubrel: genHeader('pubrel'),\n  pubrec: genHeader('pubrec')\n}\n\nprotocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT])\n\n/* Protocol versions */\nprotocol.VERSION3 = Buffer.from([3])\nprotocol.VERSION4 = Buffer.from([4])\n\n/* QoS */\nprotocol.QOS = [0, 1, 2].map(function (qos) {\n  return Buffer.from([qos])\n})\n\n/* Empty packets */\nprotocol.EMPTY = {\n  pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n  pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n  disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0])\n}\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar writeToStream = require('./writeToStream')\nvar EE = require('events').EventEmitter\nvar inherits = require('inherits')\n\nfunction generate (packet) {\n  var stream = new Accumulator()\n  writeToStream(packet, stream)\n  return stream.concat()\n}\n\nfunction Accumulator () {\n  this._array = new Array(20)\n  this._i = 0\n}\n\ninherits(Accumulator, EE)\n\nAccumulator.prototype.write = function (chunk) {\n  this._array[this._i++] = chunk\n  return true\n}\n\nAccumulator.prototype.concat = function () {\n  var length = 0\n  var lengths = new Array(this._array.length)\n  var list = this._array\n  var pos = 0\n  var i\n  var result\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') lengths[i] = list[i].length\n    else lengths[i] = Buffer.byteLength(list[i])\n\n    length += lengths[i]\n  }\n\n  result = Buffer.allocUnsafe(length)\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') {\n      list[i].copy(result, pos)\n      pos += lengths[i]\n    } else {\n      result.write(list[i], pos)\n      pos += lengths[i]\n    }\n  }\n\n  return result\n}\n\nmodule.exports = generate\n","'use strict'\n\nexports.parser = require('./parser')\nexports.generate = require('./generate')\nexports.writeToStream = require('./writeToStream')\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar max = 65536\nvar cache = {}\n\nfunction generateBuffer (i) {\n  var buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer\n}\n","\nfunction Packet () {\n  this.cmd = null\n  this.retain = false\n  this.qos = 0\n  this.dup = false\n  this.length = -1\n  this.topic = null\n  this.payload = null\n}\n\nmodule.exports = Packet\n","'use strict'\n\nvar bl = require('bl')\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar Packet = require('./packet')\nvar constants = require('./constants')\n\nfunction Parser () {\n  if (!(this instanceof Parser)) return new Parser()\n\n  this._states = [\n    '_parseHeader',\n    '_parseLength',\n    '_parsePayload',\n    '_newPacket'\n  ]\n\n  this._resetState()\n}\n\ninherits(Parser, EE)\n\nParser.prototype._resetState = function () {\n  this.packet = new Packet()\n  this.error = null\n  this._list = bl()\n  this._stateCounter = 0\n}\n\nParser.prototype.parse = function (buf) {\n  if (this.error) this._resetState()\n\n  this._list.append(buf)\n\n  while ((this.packet.length !== -1 || this._list.length > 0) &&\n         this[this._states[this._stateCounter]]() &&\n         !this.error) {\n    this._stateCounter++\n\n    if (this._stateCounter >= this._states.length) this._stateCounter = 0\n  }\n\n  return this._list.length\n}\n\nParser.prototype._parseHeader = function () {\n  // There is at least one byte in the buffer\n  var zero = this._list.readUInt8(0)\n  this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n  this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n  this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n  this.packet.dup = (zero & constants.DUP_MASK) !== 0\n\n  this._list.consume(1)\n\n  return true\n}\n\nParser.prototype._parseLength = function () {\n  // There is at least one byte in the list\n  var bytes = 0\n  var mul = 1\n  var length = 0\n  var result = true\n  var current\n\n  while (bytes < 5) {\n    current = this._list.readUInt8(bytes++)\n    length += mul * (current & constants.LENGTH_MASK)\n    mul *= 0x80\n\n    if ((current & constants.LENGTH_FIN_MASK) === 0) break\n    if (this._list.length <= bytes) {\n      result = false\n      break\n    }\n  }\n\n  if (result) {\n    this.packet.length = length\n    this._list.consume(bytes)\n  }\n\n  return result\n}\n\nParser.prototype._parsePayload = function () {\n  var result = false\n\n  // Do we have a payload? Do we have enough data to complete the payload?\n  // PINGs have no payload\n  if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n    this._pos = 0\n\n    switch (this.packet.cmd) {\n      case 'connect':\n        this._parseConnect()\n        break\n      case 'connack':\n        this._parseConnack()\n        break\n      case 'publish':\n        this._parsePublish()\n        break\n      case 'puback':\n      case 'pubrec':\n      case 'pubrel':\n      case 'pubcomp':\n        this._parseMessageId()\n        break\n      case 'subscribe':\n        this._parseSubscribe()\n        break\n      case 'suback':\n        this._parseSuback()\n        break\n      case 'unsubscribe':\n        this._parseUnsubscribe()\n        break\n      case 'unsuback':\n        this._parseUnsuback()\n        break\n      case 'pingreq':\n      case 'pingresp':\n      case 'disconnect':\n        // These are empty, nothing to do\n        break\n      default:\n        this._emitError(new Error('Not supported'))\n    }\n\n    result = true\n  }\n\n  return result\n}\n\nParser.prototype._parseConnect = function () {\n  var protocolId // Protocol ID\n  var clientId // Client ID\n  var topic // Will topic\n  var payload // Will payload\n  var password // Password\n  var username // Username\n  var flags = {}\n  var packet = this.packet\n\n  // Parse protocolId\n  protocolId = this._parseString()\n\n  if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n  if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n    return this._emitError(new Error('Invalid protocolId'))\n  }\n\n  packet.protocolId = protocolId\n\n  // Parse constants version number\n  if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n  packet.protocolVersion = this._list.readUInt8(this._pos)\n\n  if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4) {\n    return this._emitError(new Error('Invalid protocol version'))\n  }\n\n  this._pos++\n\n  if (this._pos >= this._list.length) {\n    return this._emitError(new Error('Packet too short'))\n  }\n\n  // Parse connect flags\n  flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n  flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n  flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n  if (flags.will) {\n    packet.will = {}\n    packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n    packet.will.qos = (this._list.readUInt8(this._pos) &\n                          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n  }\n\n  packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n  this._pos++\n\n  // Parse keepalive\n  packet.keepalive = this._parseNum()\n  if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n  // Parse clientId\n  clientId = this._parseString()\n  if (clientId === null) return this._emitError(new Error('Packet too short'))\n  packet.clientId = clientId\n\n  if (flags.will) {\n    // Parse will topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n    packet.will.topic = topic\n\n    // Parse will payload\n    payload = this._parseBuffer()\n    if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n    packet.will.payload = payload\n  }\n\n  // Parse username\n  if (flags.username) {\n    username = this._parseString()\n    if (username === null) return this._emitError(new Error('Cannot parse username'))\n    packet.username = username\n  }\n\n  // Parse password\n  if (flags.password) {\n    password = this._parseBuffer()\n    if (password === null) return this._emitError(new Error('Cannot parse password'))\n    packet.password = password\n  }\n\n  return packet\n}\n\nParser.prototype._parseConnack = function () {\n  var packet = this.packet\n\n  if (this._list.length < 2) return null\n\n  packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n  packet.returnCode = this._list.readUInt8(this._pos)\n\n  if (packet.returnCode === -1) return this._emitError(new Error('Cannot parse return code'))\n}\n\nParser.prototype._parsePublish = function () {\n  var packet = this.packet\n  packet.topic = this._parseString()\n\n  if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n  // Parse messageId\n  if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n  packet.payload = this._list.slice(this._pos, packet.length)\n}\n\nParser.prototype._parseSubscribe = function () {\n  var packet = this.packet\n  var topic\n  var qos\n\n  if (packet.qos !== 1) {\n    return this._emitError(new Error('Wrong subscribe header'))\n  }\n\n  packet.subscriptions = []\n\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n    qos = this._list.readUInt8(this._pos++)\n\n    // Push pair to subscriptions\n    packet.subscriptions.push({ topic: topic, qos: qos })\n  }\n}\n\nParser.prototype._parseSuback = function () {\n  this.packet.granted = []\n\n  if (!this._parseMessageId()) { return }\n\n  // Parse granted QoSes\n  while (this._pos < this.packet.length) {\n    this.packet.granted.push(this._list.readUInt8(this._pos++))\n  }\n}\n\nParser.prototype._parseUnsubscribe = function () {\n  var packet = this.packet\n\n  packet.unsubscriptions = []\n\n  // Parse messageId\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    var topic\n\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Push topic to unsubscriptions\n    packet.unsubscriptions.push(topic)\n  }\n}\n\nParser.prototype._parseUnsuback = function () {\n  if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n}\n\nParser.prototype._parseMessageId = function () {\n  var packet = this.packet\n\n  packet.messageId = this._parseNum()\n\n  if (packet.messageId === null) {\n    this._emitError(new Error('Cannot parse messageId'))\n    return false\n  }\n\n  return true\n}\n\nParser.prototype._parseString = function (maybeBuffer) {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.toString('utf8', this._pos, end)\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseBuffer = function () {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.slice(this._pos, end)\n\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseNum = function () {\n  if (this._list.length - this._pos < 2) return -1\n\n  var result = this._list.readUInt16BE(this._pos)\n  this._pos += 2\n\n  return result\n}\n\nParser.prototype._newPacket = function () {\n  if (this.packet) {\n    this._list.consume(this.packet.length)\n    this.emit('packet', this.packet)\n  }\n\n  this.packet = new Packet()\n\n  return true\n}\n\nParser.prototype._emitError = function (err) {\n  this.error = err\n  this.emit('error', err)\n}\n\nmodule.exports = Parser\n","'use strict'\n\nvar protocol = require('./constants')\nvar Buffer = require('safe-buffer').Buffer\nvar empty = Buffer.allocUnsafe(0)\nvar zeroBuf = Buffer.from([0])\nvar numbers = require('./numbers')\nvar nextTick = require('process-nextick-args').nextTick\n\nvar numCache = numbers.cache\nvar generateNumber = numbers.generateNumber\nvar generateCache = numbers.generateCache\nvar writeNumber = writeNumberCached\nvar toGenerate = true\n\nfunction generate (packet, stream) {\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream)\n    case 'connack':\n      return connack(packet, stream)\n    case 'publish':\n      return publish(packet, stream)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n    case 'unsuback':\n      return confirmation(packet, stream)\n    case 'subscribe':\n      return subscribe(packet, stream)\n    case 'suback':\n      return suback(packet, stream)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream)\n    case 'pingreq':\n    case 'pingresp':\n    case 'disconnect':\n      return emptyPacket(packet, stream)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get: function () {\n    return writeNumber === writeNumberCached\n  },\n  set: function (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (opts, stream) {\n  var settings = opts || {}\n  var protocolId = settings.protocolId || 'MQTT'\n  var protocolVersion = settings.protocolVersion || 4\n  var will = settings.will\n  var clean = settings.clean\n  var keepalive = settings.keepalive || 0\n  var clientId = settings.clientId || ''\n  var username = settings.username\n  var password = settings.password\n\n  if (clean === undefined) clean = true\n\n  var length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4\n  if (protocolVersion !== 3 && protocolVersion !== 4) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion === 4) && (clientId || clean)) {\n    length += clientId.length + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    if (will.payload && will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload) + 2\n        } else {\n          length += will.payload.length + 2\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    } else {\n      length += 2\n    }\n  }\n\n  // Username\n  var providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n  stream.write(\n    protocolVersion === 4 ? protocol.VERSION4 : protocol.VERSION3\n  )\n\n  // Connect flags\n  var flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (opts, stream) {\n  var settings = opts || {}\n  var rc = settings.returnCode\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  writeLength(stream, 2)\n  stream.write(opts.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  return stream.write(Buffer.from([rc]))\n}\n\nfunction publish (opts, stream) {\n  var settings = opts || {}\n  var qos = settings.qos || 0\n  var retain = settings.retain ? protocol.RETAIN_MASK : 0\n  var topic = settings.topic\n  var payload = settings.payload || empty\n  var id = settings.messageId\n\n  var length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][opts.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeLength(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Payload\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (opts, stream) {\n  var settings = opts || {}\n  var type = settings.cmd || 'puback'\n  var id = settings.messageId\n  var dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  var qos = 0\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeLength(stream, 2)\n\n  // Message ID\n  return writeNumber(stream, id)\n}\n\nfunction subscribe (opts, stream) {\n  var settings = opts || {}\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var id = settings.messageId\n  var subs = settings.subscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (var i = 0; i < subs.length; i += 1) {\n      var itopic = subs[i].topic\n      var iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  var result = true\n\n  // Generate subs\n  for (var j = 0; j < subs.length; j++) {\n    var sub = subs[j]\n    var jtopic = sub.topic\n    var jqos = sub.qos\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // Write qos\n    result = stream.write(protocol.QOS[jqos])\n  }\n\n  return result\n}\n\nfunction suback (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var granted = settings.granted\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (var i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var unsubs = settings.unsubscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (var i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // Unsubs\n  var result = true\n  for (var j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction emptyPacket (opts, stream) {\n  return stream.write(protocol.EMPTY[opts.cmd])\n}\n\n/**\n * calcLengthLength - calculate the length of the remaining\n * length field\n *\n * @api private\n */\nfunction calcLengthLength (length) {\n  if (length >= 0 && length < 128) return 1\n  else if (length >= 128 && length < 16384) return 2\n  else if (length >= 16384 && length < 2097152) return 3\n  else if (length >= 2097152 && length < 268435456) return 4\n  else return 0\n}\n\nfunction genBufLength (length) {\n  var digit = 0\n  var pos = 0\n  var buffer = Buffer.allocUnsafe(calcLengthLength(length))\n\n  do {\n    digit = length % 128 | 0\n    length = length / 128 | 0\n    if (length > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (length > 0)\n\n  return buffer\n}\n\n/**\n * writeLength - write an MQTT style length field to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nvar lengthCache = {}\nfunction writeLength (stream, length) {\n  var buffer = lengthCache[length]\n\n  if (!buffer) {\n    buffer = genBufLength(length)\n    if (length < 16384) lengthCache[length] = buffer\n  }\n\n  stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  var strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  stream.write(string, 'utf8')\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  return stream.write(generateNumber(number))\n}\n\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n","'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId] === 'function') {\n        queue[messageId](new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store()\n  this.incomingStore = this.options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return\n    }\n\n    this.connected = true\n    var outStore = this.outgoingStore.createStream()\n\n    this.once('close', remove)\n    outStore.on('end', function () {\n      that.removeListener('close', remove)\n    })\n    outStore.on('error', function (err) {\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n\n      var packet = outStore.read(1)\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId]\n        that.outgoing[packet.messageId] = function (err, status) {\n          // Ensure that the original callback passed in to publish gets invoked\n          if (cb) {\n            cb(err, status)\n          }\n\n          storeDeliver()\n        }\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    // start flowing\n    storeDeliver()\n  })\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer)\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  var firstConnection = true\n  // resubscribe\n  this.on('connect', function () {\n    if (!firstConnection &&\n        this.options.clean &&\n        Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      } else {\n        this._resubscribeTopics = {}\n      }\n    }\n\n    firstConnection = false\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    process.nextTick(work)\n  }\n\n  function work () {\n    var packet = packets.shift()\n    var done = completeParse\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      completeParse = null\n      done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    work()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'))\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop\n      this._sendPacket(packet)\n      break\n    default:\n      this._sendPacket(packet, callback)\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = Array.prototype.slice.call(arguments)\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = { qos: 0 }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos ||\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\n          resubscribe) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        })\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (that._resubscribeTopics[k] < obj[k] ||\n            !that._resubscribeTopics.hasOwnProperty(k) ||\n            resubscribe) {\n          subs.push({\n            topic: k,\n            qos: obj[k]\n          })\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i]\n      }\n    }\n\n    callback(err, subs)\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n\n  callback = callback || nop\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  this.outgoing[packet.messageId] = callback\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this\n\n  if (typeof force === 'function') {\n    cb = force\n    force = false\n  }\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments)\n        }\n        that.emit('end')\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid]\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    this.stream.destroy()\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n      this.queue.push({ packet: packet, cb: cb })\n    } else if (packet.qos > 0) {\n      cb = this.outgoing[packet.messageId]\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err)\n        }\n      })\n    } else if (cb) {\n      cb(new Error('No connection to broker'))\n    }\n\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode\n  var errors = [\n    '',\n    'Unacceptable protocol version',\n    'Identifier rejected',\n    'Server unavailable',\n    'Bad username or password',\n    'Not authorized'\n  ]\n\n  clearTimeout(this.connackTimer)\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this.emit('connect', packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n      })\n      break\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\n      })\n      break\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid]\n  var that = this\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n\n      this._sendPacket(response)\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid]\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic]\n          })\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.incomingStore.put(packet, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.handleMessage(pub, function (err) {\n          if (err) {\n            return callback(err)\n          }\n          that._sendPacket(comp, callback)\n        })\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\nmodule.exports = MqttClient\n","'use strict'\n\nvar MqttClient = require('../client')\nvar Store = require('../store')\nvar url = require('url')\nvar xtend = require('xtend')\nvar protocols = {}\n\nif (process.title !== 'browser') {\n  protocols.mqtt = require('./tcp')\n  protocols.tcp = require('./tcp')\n  protocols.ssl = require('./tls')\n  protocols.tls = require('./tls')\n  protocols.mqtts = require('./tls')\n} else {\n  protocols.wx = require('./wx')\n  protocols.wxs = require('./wx')\n}\n\nprotocols.ws = require('./ws')\nprotocols.wss = require('./ws')\n\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\nfunction parseAuthOptions (opts) {\n  var matches\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/)\n    if (matches) {\n      opts.username = matches[1]\n      opts.password = matches[2]\n    } else {\n      opts.username = opts.auth\n    }\n  }\n}\n\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\nfunction connect (brokerUrl, opts) {\n  if ((typeof brokerUrl === 'object') && !opts) {\n    opts = brokerUrl\n    brokerUrl = null\n  }\n\n  opts = opts || {}\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true)\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port)\n    }\n\n    opts = xtend(parsed, opts)\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol')\n    }\n    opts.protocol = opts.protocol.replace(/:$/, '')\n  }\n\n  // merge in the auth options if supplied\n  parseAuthOptions(opts)\n\n  // support clientId passed in the query string of the url\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts'\n            break\n          case 'ws':\n            opts.protocol = 'wss'\n            break\n          case 'wx':\n            opts.protocol = 'wxs'\n            break\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!')\n        }\n      }\n    } else {\n      // don't know what protocol he want to use, mqtts or wss\n      throw new Error('Missing secure protocol key')\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\n    opts.protocol = [\n      'mqtt',\n      'mqtts',\n      'ws',\n      'wss',\n      'wx',\n      'wxs'\n    ].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false\n      }\n      return (typeof protocols[key] === 'function')\n    })[0]\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients')\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol\n  }\n\n  function wrapper (client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host\n      opts.port = opts.servers[client._reconnectCount].port\n      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)\n      opts.hostname = opts.host\n\n      client._reconnectCount++\n    }\n\n    return protocols[opts.protocol](client, opts)\n  }\n\n  return new MqttClient(wrapper, opts)\n}\n\nmodule.exports = connect\nmodule.exports.connect = connect\nmodule.exports.MqttClient = MqttClient\nmodule.exports.Store = Store\n","'use strict'\nvar net = require('net')\n\n/*\n  variables port and host can be removed since\n  you have all required information in opts object\n*/\nfunction buildBuilder (client, opts) {\n  var port, host\n  opts.port = opts.port || 1883\n  opts.hostname = opts.hostname || opts.host || 'localhost'\n\n  port = opts.port\n  host = opts.hostname\n\n  return net.createConnection(port, host)\n}\n\nmodule.exports = buildBuilder\n","'use strict'\nvar tls = require('tls')\n\nfunction buildBuilder (mqttClient, opts) {\n  var connection\n  opts.port = opts.port || 8883\n  opts.host = opts.hostname || opts.host || 'localhost'\n\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\n\n  delete opts.path\n\n  connection = tls.connect(opts)\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'))\n    } else {\n      connection.removeListener('error', handleTLSerrors)\n    }\n  })\n\n  function handleTLSerrors (err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err)\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end()\n  }\n\n  connection.on('error', handleTLSerrors)\n  return connection\n}\n\nmodule.exports = buildBuilder\n","'use strict'\n\nvar websocket = require('websocket-stream')\nvar urlModule = require('url')\nvar WSS_OPTIONS = [\n  'rejectUnauthorized',\n  'ca',\n  'cert',\n  'key',\n  'pfx',\n  'passphrase'\n]\nvar IS_BROWSER = process.title === 'browser'\n\nfunction buildUrl (opts, client) {\n  var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      opts.port = 443\n    } else {\n      opts.port = 80\n    }\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n        opts.wsOptions[prop] = opts[prop]\n      }\n    })\n  }\n}\n\nfunction createWebSocket (client, opts) {\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n  var url = buildUrl(opts, client)\n  return websocket(url, [websocketSubProtocol], opts.wsOptions)\n}\n\nfunction buildBuilder (client, opts) {\n  return createWebSocket(client, opts)\n}\n\nfunction buildBuilderBrowser (client, opts) {\n  if (!opts.hostname) {\n    opts.hostname = opts.host\n  }\n\n  if (!opts.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof (document) === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.')\n    }\n    var parsed = urlModule.parse(document.URL)\n    opts.hostname = parsed.hostname\n\n    if (!opts.port) {\n      opts.port = parsed.port\n    }\n  }\n  return createWebSocket(client, opts)\n}\n\nif (IS_BROWSER) {\n  module.exports = buildBuilderBrowser\n} else {\n  module.exports = buildBuilder\n}\n","'use strict'\n\n/* global wx */\nvar socketOpen = false\nvar socketMsgQueue = []\n\nfunction sendSocketMessage (msg) {\n  if (socketOpen) {\n    wx.sendSocketMessage({\n      data: msg.buffer || msg\n    })\n  } else {\n    socketMsgQueue.push(msg)\n  }\n}\n\nfunction WebSocket (url, protocols) {\n  var ws = {\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3,\n    readyState: socketOpen ? 1 : 0,\n    send: sendSocketMessage,\n    close: wx.closeSocket,\n    onopen: null,\n    onmessage: null,\n    onclose: null,\n    onerror: null\n  }\n\n  wx.connectSocket({\n    url: url,\n    protocols: protocols\n  })\n  wx.onSocketOpen(function (res) {\n    ws.readyState = ws.OPEN\n    socketOpen = true\n    for (var i = 0; i < socketMsgQueue.length; i++) {\n      sendSocketMessage(socketMsgQueue[i])\n    }\n    socketMsgQueue = []\n\n    ws.onopen && ws.onopen.apply(ws, arguments)\n  })\n  wx.onSocketMessage(function (res) {\n    ws.onmessage && ws.onmessage.apply(ws, arguments)\n  })\n  wx.onSocketClose(function () {\n    ws.onclose && ws.onclose.apply(ws, arguments)\n    ws.readyState = ws.CLOSED\n    socketOpen = false\n  })\n  wx.onSocketError(function () {\n    ws.onerror && ws.onerror.apply(ws, arguments)\n    ws.readyState = ws.CLOSED\n    socketOpen = false\n  })\n\n  return ws\n}\n\nvar websocket = require('websocket-stream')\n\nfunction buildUrl (opts, client) {\n  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'\n  var url = protocol + '://' + opts.hostname + opts.path\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  }\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n}\n\nfunction createWebSocket (client, opts) {\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n  var url = buildUrl(opts, client)\n  return websocket(WebSocket(url, [websocketSubProtocol]))\n}\n\nfunction buildBuilder (client, opts) {\n  opts.hostname = opts.hostname || opts.host\n\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.')\n  }\n\n  return createWebSocket(client, opts)\n}\n\nmodule.exports = buildBuilder\n","'use strict'\n\n/**\n * Module dependencies\n */\nvar xtend = require('xtend')\n\nvar Readable = require('readable-stream').Readable\nvar streamsOpts = { objectMode: true }\nvar defaultStoreOptions = {\n  clean: true\n}\n\n/**\n * es6-map can preserve insertion order even if ES version is older.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\n * It should be noted that a Map which is a map of an object, especially\n * a dictionary of dictionaries, will only map to the object's insertion\n * order. In ES2015 this is ordered for objects but for older versions of\n * ES, this may be random and not ordered.\n *\n */\nvar Map = require('es6-map')\n\n/**\n * In-memory implementation of the message store\n * This can actually be saved into files.\n *\n * @param {Object} [options] - store options\n */\nfunction Store (options) {\n  if (!(this instanceof Store)) {\n    return new Store(options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  this.options = xtend(defaultStoreOptions, options)\n\n  this._inflights = new Map()\n}\n\n/**\n * Adds a packet to the store, a packet is\n * anything that has a messageId property.\n *\n */\nStore.prototype.put = function (packet, cb) {\n  this._inflights.set(packet.messageId, packet)\n\n  if (cb) {\n    cb()\n  }\n\n  return this\n}\n\n/**\n * Creates a stream with all the packets in the store\n *\n */\nStore.prototype.createStream = function () {\n  var stream = new Readable(streamsOpts)\n  var destroyed = false\n  var values = []\n  var i = 0\n\n  this._inflights.forEach(function (value, key) {\n    values.push(value)\n  })\n\n  stream._read = function () {\n    if (!destroyed && i < values.length) {\n      this.push(values[i++])\n    } else {\n      this.push(null)\n    }\n  }\n\n  stream.destroy = function () {\n    if (destroyed) {\n      return\n    }\n\n    var self = this\n\n    destroyed = true\n\n    process.nextTick(function () {\n      self.emit('close')\n    })\n  }\n\n  return stream\n}\n\n/**\n * deletes a packet from the store.\n */\nStore.prototype.del = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    this._inflights.delete(packet.messageId)\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * get a packet from the store.\n */\nStore.prototype.get = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * Close the store\n */\nStore.prototype.close = function (cb) {\n  if (this.options.clean) {\n    this._inflights = null\n  }\n  if (cb) {\n    cb()\n  }\n}\n\nmodule.exports = Store\n","'use strict'\n\n/**\n * Validate a topic to see if it's valid or not.\n * A topic is valid if it follow below rules:\n * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n * - Rule #2: Part `#` must be located at the end of the mailbox\n *\n * @param {String} topic - A topic\n * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n */\nfunction validateTopic (topic) {\n  var parts = topic.split('/')\n\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] === '+') {\n      continue\n    }\n\n    if (parts[i] === '#') {\n      // for Rule #2\n      return i === parts.length - 1\n    }\n\n    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Validate an array of topics to see if any of them is valid or not\n  * @param {Array} topics - Array of topics\n * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n */\nfunction validateTopics (topics) {\n  if (topics.length === 0) {\n    return 'empty_topic_list'\n  }\n  for (var i = 0; i < topics.length; i++) {\n    if (!validateTopic(topics[i])) {\n      return topics[i]\n    }\n  }\n  return null\n}\n\nmodule.exports = {\n  validateTopics: validateTopics\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","'use strict'\n\nfunction ReInterval (callback, interval, args) {\n  var self = this;\n\n  this._callback = callback;\n  this._args = args;\n\n  this._interval = setInterval(callback, interval, this._args);\n\n  this.reschedule = function (interval) {\n    // if no interval entered, use the interval passed in on creation\n    if (!interval)\n      interval = self._interval;\n\n    if (self._interval)\n      clearInterval(self._interval);\n    self._interval = setInterval(self._callback, interval, self._args);\n  };\n\n  this.clear = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n      self._interval = undefined;\n    }\n  };\n  \n  this.destroy = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n    }\n    self._callback = undefined;\n    self._interval = undefined;\n    self._args = undefined;\n  };\n}\n\nfunction reInterval () {\n  if (typeof arguments[0] !== 'function')\n    throw new Error('callback needed');\n  if (typeof arguments[1] !== 'number')\n    throw new Error('interval needed');\n\n  var args;\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2];\n    }\n  }\n\n  return new ReInterval(arguments[0], arguments[1], args);\n}\n\nmodule.exports = reInterval;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","module.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\");\n\nmodule.exports = function (value) {\n\tif (typeof value !== \"function\") return false;\n\n\tif (!hasOwnProperty.call(value, \"length\")) return false;\n\n\ttry {\n\t\tif (typeof value.length !== \"number\") return false;\n\t\tif (typeof value.call !== \"function\") return false;\n\t\tif (typeof value.apply !== \"function\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\treturn !isPrototype(value);\n};\n","\"use strict\";\n\nvar isValue       = require(\"../value/is\")\n  , isObject      = require(\"../object/is\")\n  , stringCoerce  = require(\"../string/coerce\")\n  , toShortString = require(\"./to-short-string\");\n\nvar resolveMessage = function (message, value) {\n\treturn message.replace(\"%v\", toShortString(value));\n};\n\nmodule.exports = function (value, defaultMessage, inputOptions) {\n\tif (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));\n\tif (!isValue(value)) {\n\t\tif (\"default\" in inputOptions) return inputOptions[\"default\"];\n\t\tif (inputOptions.isOptional) return null;\n\t}\n\tvar errorMessage = stringCoerce(inputOptions.errorMessage);\n\tif (!isValue(errorMessage)) errorMessage = defaultMessage;\n\tthrow new TypeError(resolveMessage(errorMessage, value));\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\ttry {\n\t\treturn value.toString();\n\t} catch (error) {\n\t\ttry { return String(value); }\n\t\tcatch (error2) { return null; }\n\t}\n};\n","\"use strict\";\n\nvar safeToString = require(\"./safe-to-string\");\n\nvar reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n\nmodule.exports = function (value) {\n\tvar string = safeToString(value);\n\tif (string === null) return \"<Non-coercible to string value>\";\n\t// Trim if too long\n\tif (string.length > 100) string = string.slice(0, 99) + \"\";\n\t// Replace eventual new lines\n\tstring = string.replace(reNewLine, function (char) {\n\t\tswitch (char) {\n\t\t\tcase \"\\n\":\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase \"\\r\":\n\t\t\t\treturn \"\\\\r\";\n\t\t\tcase \"\\u2028\":\n\t\t\t\treturn \"\\\\u2028\";\n\t\t\tcase \"\\u2029\":\n\t\t\t\treturn \"\\\\u2029\";\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected character\");\n\t\t}\n\t});\n\treturn string;\n};\n","\"use strict\";\n\nvar isValue = require(\"../value/is\");\n\n// prettier-ignore\nvar possibleTypes = { \"object\": true, \"function\": true, \"undefined\": true /* document.all */ };\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\treturn hasOwnProperty.call(possibleTypes, typeof value);\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"%v is not a plain function\", arguments[1]);\n};\n","\"use strict\";\n\nvar isFunction = require(\"../function/is\");\n\nvar classRe = /^\\s*class[\\s{/}]/, functionToString = Function.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isFunction(value)) return false;\n\tif (classRe.test(functionToString.call(value))) return false;\n\treturn true;\n};\n","\"use strict\";\n\nvar isObject = require(\"../object/is\");\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) return false;\n\ttry {\n\t\tif (!value.constructor) return false;\n\t\treturn value.constructor.prototype === value;\n\t} catch (error) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue  = require(\"../value/is\")\n  , isObject = require(\"../object/is\");\n\nvar objectToString = Object.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return null;\n\tif (isObject(value)) {\n\t\t// Reject Object.prototype.toString coercion\n\t\tvar valueToString = value.toString;\n\t\tif (typeof valueToString !== \"function\") return null;\n\t\tif (valueToString === objectToString) return null;\n\t\t// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant\n\t\t// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case\n\t}\n\ttry {\n\t\treturn \"\" + value; // Ensure implicit coercion\n\t} catch (error) {\n\t\treturn null;\n\t}\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"Cannot use %v\", arguments[1]);\n};\n","\"use strict\";\n\n// ES3 safe\nvar _undefined = void 0;\n\nmodule.exports = function (value) { return value !== _undefined && value !== null; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\nvar WS = require('ws')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = WebSocketStream\n\nfunction buildProxy (options, socketWrite, socketEnd) {\n  var proxy = new Transform({\n    objectMode: options.objectMode\n  })\n\n  proxy._write = socketWrite\n  proxy._flush = socketEnd\n\n  return proxy\n}\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket\n\n  var isBrowser = process.title === 'browser'\n  var isNative = !!global.WebSocket\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols\n    protocols = null\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {}\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  var proxy = buildProxy(options, socketWrite, socketEnd)\n\n  if (!options.objectMode) {\n    proxy._writev = writev\n  }\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target\n  // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols)\n    } else {\n      socket = new WS(target, protocols, options)\n    }\n\n    socket.binaryType = 'arraybuffer'\n  }\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else if (isBrowser) {\n    stream = proxy\n    stream.cork()\n    socket.onopen = onopenBrowser\n  } else {\n    stream = duplexify.obj()\n    socket.onopen = onopen\n  }\n\n  stream.socket = socket\n\n  socket.onclose = onclose\n  socket.onerror = onerror\n  socket.onmessage = onmessage\n\n  proxy.on('close', destroy)\n\n  var coerceToBuffer = !options.objectMode\n\n  function socketWriteNode(chunk, enc, next) {\n    // avoid errors, this never happens unless\n    // destroy() is called\n    if (socket.readyState !== socket.OPEN) {\n      next()\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n    socket.send(chunk, next)\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch(err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEnd(done) {\n    socket.close()\n    done()\n  }\n\n  function onopen() {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onopenBrowser () {\n    stream.uncork()\n    stream.emit('connect')\n  }\n\n  function onclose() {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror(err) {\n    stream.destroy(err)\n  }\n\n  function onmessage(event) {\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  function destroy() {\n    socket.close()\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    var buffers = new Array(chunks.length)\n    for (var i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  return stream\n}\n","\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n}\n\nmodule.exports = ws\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. audio\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseAudioType(str, input, output) {\n  str = str.toLowerCase();\n  let result = '';\n\n  if (str.indexOf('input') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('display audio') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('speak') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('laut') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('loud') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('head') >= 0) { result = 'Headset'; }\n  if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('mikr') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('controll') >= 0) { result = 'Controller'; }\n  if (str.indexOf('line o') >= 0) { result = 'Line Out'; }\n  if (str.indexOf('digital o') >= 0) { result = 'Digital Out'; }\n  if (str.indexOf('smart sound technology') >= 0) { result = 'Digital Signal Processor'; }\n  if (str.indexOf('high definition audio') >= 0) { result = 'Sound Driver'; }\n\n  if (!result && output) {\n    result = 'Speaker';\n  } else if (!result && input) {\n    result = 'Microphone';\n  }\n  return result;\n}\n\n\nfunction getLinuxAudioPci() {\n  let cmd = 'lspci -v 2>/dev/null';\n  let result = [];\n  try {\n    const parts = execSync(cmd).toString().split('\\n\\n');\n    parts.forEach(element => {\n      const lines = element.split('\\n');\n      if (lines && lines.length && lines[0].toLowerCase().indexOf('audio') >= 0) {\n        const audio = {};\n        audio.slotId = lines[0].split(' ')[0];\n        audio.driver = util.getValue(lines, 'Kernel driver in use', ':', true) || util.getValue(lines, 'Kernel modules', ':', true);\n        result.push(audio);\n      }\n    });\n    return result;\n  } catch (e) {\n    return result;\n  }\n}\n\nfunction parseLinuxAudioPciMM(lines, audioPCI) {\n  const result = {};\n  const slotId = util.getValue(lines, 'Slot');\n\n  const pciMatch = audioPCI.filter(function (item) { return item.slotId === slotId; });\n\n  result.id = slotId;\n  result.name = util.getValue(lines, 'SDevice');\n  result.manufacturer = util.getValue(lines, 'SVendor');\n  result.revision = util.getValue(lines, 'Rev');\n  result.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : '';\n  result.default = null;\n  result.channel = 'PCIe';\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseDarwinChannel(str) {\n  let result = '';\n\n  if (str.indexOf('builtin') >= 0) { result = 'Built-In'; }\n  if (str.indexOf('extern') >= 0) { result = 'Audio-Jack'; }\n  if (str.indexOf('hdmi') >= 0) { result = 'HDMI'; }\n  if (str.indexOf('displayport') >= 0) { result = 'Display-Port'; }\n  if (str.indexOf('usb') >= 0) { result = 'USB'; }\n  if (str.indexOf('pci') >= 0) { result = 'PCIe'; }\n\n  return result;\n}\n\nfunction parseDarwinAudio(audioObject, id) {\n  const result = {};\n  const channelStr = ((audioObject.coreaudio_device_transport || '') + ' ' + (audioObject._name || '')).toLowerCase();\n\n  result.id = id;\n  result.name = audioObject._name;\n  result.manufacturer = audioObject.coreaudio_device_manufacturer;\n  result.revision = null;\n  result.driver = null;\n  result.default = !!(audioObject.coreaudio_default_audio_input_device || '') || !!(audioObject.coreaudio_default_audio_output_device || '');\n  result.channel = parseDarwinChannel(channelStr);\n  result.type = parseAudioType(result.name, !!(audioObject.coreaudio_device_input || ''), !!(audioObject.coreaudio_device_output || ''));\n  result.in = !!(audioObject.coreaudio_device_input || '');\n  result.out = !!(audioObject.coreaudio_device_output || '');\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseWindowsAudio(lines) {\n  const result = {};\n  const status = util.getValue(lines, 'StatusInfo', ':');\n\n  result.id = util.getValue(lines, 'DeviceID', ':'); // PNPDeviceID??\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.revision = null;\n  result.driver = null;\n  result.default = null;\n  result.channel = null;\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = status;\n\n  return result;\n}\n\nfunction audio(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'lspci -vmm 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // PCI\n          if (!error) {\n            const audioPCI = getLinuxAudioPci();\n            const parts = stdout.toString().split('\\n\\n');\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'class', ':', true).toLowerCase().indexOf('audio') >= 0) {\n                const audio = parseLinuxAudioPciMM(lines, audioPCI);\n                result.push(audio);\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPAudioDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]['_items'] && outObj.SPAudioDataType[0]['_items'].length) {\n                for (let i = 0; i < outObj.SPAudioDataType[0]['_items'].length; i++) {\n                  const audio = parseDarwinAudio(outObj.SPAudioDataType[0]['_items'][i], i);\n                  result.push(audio);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'name', ':')) {\n                result.push(parseWindowsAudio(lines));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.audio = audio;\n","'use strict';\n// @ts-check;\n// ==================================================================================\n// battery.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 6. Battery\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {\n  const result = {};\n  let status = util.getValue(lines, 'BatteryStatus', ':').trim();\n  // 1 = \"Discharging\"\n  // 2 = \"On A/C\"\n  // 3 = \"Fully Charged\"\n  // 4 = \"Low\"\n  // 5 = \"Critical\"\n  // 6 = \"Charging\"\n  // 7 = \"Charging High\"\n  // 8 = \"Charging Low\"\n  // 9 = \"Charging Critical\"\n  // 10 = \"Undefined\"\n  // 11 = \"Partially Charged\"\n  if (status >= 0) {\n    const statusValue = status ? parseInt(status) : 0;\n    result.status = statusValue;\n    result.hasBattery = true;\n    result.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, 'DesignCapacity', ':') || 0);\n    result.designedCapacity = parseInt(util.getValue(lines, 'DesignCapacity', ':') || designedCapacity);\n    result.voltage = parseInt(util.getValue(lines, 'DesignVoltage', ':') || 0) / 1000.0;\n    result.capacityUnit = 'mWh';\n    result.percent = parseInt(util.getValue(lines, 'EstimatedChargeRemaining', ':') || 0);\n    result.currentCapacity = parseInt(result.maxCapacity * result.percent / 100);\n    result.isCharging = (statusValue >= 6 && statusValue <= 9) || statusValue === 11 || ((statusValue !== 3) && (statusValue !== 1) && result.percent < 100);\n    result.acConnected = result.isCharging || statusValue === 2;\n    result.model = util.getValue(lines, 'DeviceID', ':');\n  } else {\n    result.status = -1;\n  }\n\n  return result;\n}\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        hasBattery: false,\n        cycleCount: 0,\n        isCharging: false,\n        designedCapacity: 0,\n        maxCapacity: 0,\n        currentCapacity: 0,\n        voltage: 0,\n        capacityUnit: '',\n        percent: 0,\n        timeRemaining: null,\n        acConnected: true,\n        type: '',\n        model: '',\n        manufacturer: '',\n        serial: ''\n      };\n\n      if (_linux) {\n        let battery_path = '';\n        if (fs.existsSync('/sys/class/power_supply/BAT1/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT1/';\n        } else if (fs.existsSync('/sys/class/power_supply/BAT0/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT0/';\n        }\n\n        let acConnected = false;\n        let acPath = '';\n        if (fs.existsSync('/sys/class/power_supply/AC/online')) {\n          acPath = '/sys/class/power_supply/AC/online';\n        } else if (fs.existsSync('/sys/class/power_supply/AC0/online')) {\n          acPath = '/sys/class/power_supply/AC0/online';\n        }\n\n        if (acPath) {\n          const file = fs.readFileSync(acPath);\n          acConnected = file.toString().trim() === '1';\n        }\n\n        if (battery_path) {\n          fs.readFile(battery_path + 'uevent', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n\n              result.isCharging = (util.getValue(lines, 'POWER_SUPPLY_STATUS', '=').toLowerCase() === 'charging');\n              result.acConnected = acConnected || result.isCharging;\n              result.voltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_NOW', '='), 10) / 1000000.0;\n              result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n              result.cycleCount = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CYCLE_COUNT', '='), 10);\n              result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL', '=', true, true), 10) / 1000.0 * (result.voltage || 1));\n              const desingedMinVoltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_MIN_DESIGN', '='), 10) / 1000000.0;\n              result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL_DESIGN', '=', true, true), 10) / 1000.0 * (desingedMinVoltage || result.voltage || 1));\n              result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_NOW', '='), 10) / 1000.0 * (result.voltage || 1));\n              if (!result.maxCapacity) {\n                result.maxCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL', '=', true, true), 10) / 1000.0;\n                result.designedCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL_DESIGN', '=', true, true), 10) / 1000.0 | result.maxCapacity;\n                result.currentCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10) / 1000.0;\n              }\n              const percent = util.getValue(lines, 'POWER_SUPPLY_CAPACITY', '=');\n              const energy = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10);\n              const power = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_POWER_NOW', '='), 10);\n              const current = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CURRENT_NOW', '='), 10);\n\n              result.percent = parseInt('0' + percent, 10);\n              if (result.maxCapacity && result.currentCapacity) {\n                result.hasBattery = true;\n                if (!percent) {\n                  result.percent = 100.0 * result.currentCapacity / result.maxCapacity;\n                }\n              }\n              if (result.isCharging) {\n                result.hasBattery = true;\n              }\n              if (energy && power) {\n                result.timeRemaining = Math.floor(energy / power * 60);\n              } else if (current && result.currentCapacity) {\n                result.timeRemaining = Math.floor(result.currentCapacity / current * 60);\n              }\n              result.type = util.getValue(lines, 'POWER_SUPPLY_TECHNOLOGY', '=');\n              result.model = util.getValue(lines, 'POWER_SUPPLY_MODEL_NAME', '=');\n              result.manufacturer = util.getValue(lines, 'POWER_SUPPLY_MANUFACTURER', '=');\n              result.serial = util.getValue(lines, 'POWER_SUPPLY_SERIAL_NUMBER', '=');\n              if (callback) { callback(result); }\n              resolve(result);\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i hw.acpi.battery hw.acpi.acline', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const batteries = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.units'), 10);\n          const percent = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.life'), 10);\n          result.hasBattery = (batteries > 0);\n          result.cycleCount = null;\n          result.isCharging = util.getValue(lines, 'hw.acpi.acline') !== '1';\n          result.acConnected = result.isCharging;\n          result.maxCapacity = null;\n          result.currentCapacity = null;\n          result.capacityUnit = 'unknown';\n          result.percent = batteries ? percent : null;\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('ioreg -n AppleSmartBattery -r | egrep \"CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage\"; pmset -g batt | grep %', function (error, stdout) {\n          if (stdout) {\n            let lines = stdout.toString().replace(/ +/g, '').replace(/\"+/g, '').replace(/-/g, '').split('\\n');\n            result.cycleCount = parseInt('0' + util.getValue(lines, 'cyclecount', '='), 10);\n            result.voltage = parseInt('0' + util.getValue(lines, 'voltage', '='), 10) / 1000.0;\n            result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n            result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawmaxcapacity', '='), 10) * (result.voltage || 1));\n            result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawcurrentcapacity', '='), 10) * (result.voltage || 1));\n            result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'DesignCapacity', '='), 10) * (result.voltage || 1));\n            result.manufacturer = 'Apple';\n            result.serial = util.getValue(lines, 'BatterySerialNumber', '=');\n            let percent = null;\n            const line = util.getValue(lines, 'internal', 'Battery');\n            let parts = line.split(';');\n            if (parts && parts[0]) {\n              let parts2 = parts[0].split('\\t');\n              if (parts2 && parts2[1]) {\n                percent = parseFloat(parts2[1].trim().replace(/%/g, ''));\n              }\n            }\n            if (parts && parts[1]) {\n              result.isCharging = (parts[1].trim() === 'charging');\n              result.acConnected = (parts[1].trim() !== 'discharging');\n            } else {\n              result.isCharging = util.getValue(lines, 'ischarging', '=').toLowerCase() === 'yes';\n              result.acConnected = result.isCharging;\n            }\n            if (result.maxCapacity && result.currentCapacity) {\n              result.hasBattery = true;\n              result.type = 'Li-ion';\n              result.percent = percent !== null ? percent : Math.round(100.0 * result.currentCapacity / result.maxCapacity);\n              if (!result.isCharging) {\n                result.timeRemaining = parseInt('0' + util.getValue(lines, 'TimeRemaining', '='), 10);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            if (data) {\n              let parts = data.results[0].split(/\\n\\s*\\n/);\n              let batteries = [];\n              const hasValue = value => /\\S/.test(value);\n              for (let i = 0; i < parts.length; i++) {\n                if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {\n                  batteries.push([]);\n                }\n                if (hasValue(parts[i])) {\n                  batteries[batteries.length - 1].push(parts[i]);\n                }\n              }\n              let designCapacities = data.results[1].split('\\r\\n').filter(e => e);\n              let fullChargeCapacities = data.results[2].split('\\r\\n').filter(e => e);\n              if (batteries.length) {\n                let first = false;\n                let additionalBatteries = [];\n                for (let i = 0; i < batteries.length; i++) {\n                  let lines = batteries[i][0].split('\\r\\n');\n                  const designedCapacity = designCapacities && designCapacities.length >= (i + 1) && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;\n                  const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= (i + 1) && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;\n                  const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);\n                  if (!first && parsed.status > 0 && parsed.status !== 10) {\n                    result.hasBattery = parsed.hasBattery;\n                    result.maxCapacity = parsed.maxCapacity;\n                    result.designedCapacity = parsed.designedCapacity;\n                    result.voltage = parsed.voltage;\n                    result.capacityUnit = parsed.capacityUnit;\n                    result.percent = parsed.percent;\n                    result.currentCapacity = parsed.currentCapacity;\n                    result.isCharging = parsed.isCharging;\n                    result.acConnected = parsed.acConnected;\n                    result.model = parsed.model;\n                    first = true;\n                  } else if (parsed.status !== -1) {\n                    additionalBatteries.push(\n                      {\n                        hasBattery: parsed.hasBattery,\n                        maxCapacity: parsed.maxCapacity,\n                        designedCapacity: parsed.designedCapacity,\n                        voltage: parsed.voltage,\n                        capacityUnit: parsed.capacityUnit,\n                        percent: parsed.percent,\n                        currentCapacity: parsed.currentCapacity,\n                        isCharging: parsed.isCharging,\n                        timeRemaining: null,\n                        acConnected: parsed.acConnected,\n                        model: parsed.model,\n                        type: '',\n                        manufacturer: '',\n                        serial: ''\n                      }\n                    );\n                  }\n                }\n                if (!first && additionalBatteries.length) {\n                  result = additionalBatteries[0];\n                  additionalBatteries.shift();\n                }\n                if (additionalBatteries.length) {\n                  result.additionalBatteries = additionalBatteries;\n                }\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n};\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 17. bluetooth\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst path = require('path');\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseBluetoothType(str) {\n  let result = '';\n\n  if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  if (str.indexOf('speaker') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('headset') >= 0) { result = 'Headset'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Computer'; }\n  if (str.indexOf('imac') >= 0) { result = 'Computer'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Tablet'; }\n  if (str.indexOf('watch') >= 0) { result = 'Watch'; }\n  if (str.indexOf('headphone') >= 0) { result = 'Headset'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseBluetoothManufacturer(str) {\n  let result = str.split(' ')[0];\n  str = str.toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Apple'; }\n  if (str.indexOf('imac') >= 0) { result = 'Apple'; }\n  if (str.indexOf('iphone') >= 0) { result = 'Apple'; }\n  if (str.indexOf('magic mouse') >= 0) { result = 'Apple'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Apple'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', '=');\n  result.manufacturer = null;\n  result.macDevice = macAddr1;\n  result.macHost = macAddr2;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = false;\n\n  return result;\n}\n\nfunction parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {\n  const result = {};\n  const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || '') + (bluetoothObject.device_name || '')).toLowerCase();\n\n  result.device = bluetoothObject.device_services || '';\n  result.name = bluetoothObject.device_name || '';\n  result.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothManufacturer(bluetoothObject.device_name || '') || '';\n  result.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || '').toLowerCase().replace(/-/g, ':');\n  result.macHost = macAddr2;\n  result.batteryPercent = bluetoothObject.device_batteryPercent || null;\n  result.type = parseBluetoothType(typeStr);\n  result.connected = bluetoothObject.device_isconnected === 'attrib_Yes' || false;\n\n  return result;\n}\n\nfunction parseWindowsBluetooth(lines) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.macDevice = null;\n  result.macHost = null;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = null;\n\n  return result;\n}\n\nfunction bluetoothDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        // get files in /var/lib/bluetooth/ recursive\n        const btFiles = util.getFilesInPath('/var/lib/bluetooth/');\n        btFiles.forEach((element) => {\n          const filename = path.basename(element);\n          const pathParts = element.split('/');\n          const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;\n          const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;\n          if (filename === 'info') {\n            const infoFile = fs.readFileSync(element, { encoding: 'utf8' }).split('\\n');\n            result.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));\n          }\n        });\n        // determine \"connected\" with hcitool con\n        try {\n          const hdicon = execSync('hcitool con').toString().toLowerCase();\n          for (let i = 0; i < result.length; i++) {\n            if (result[i].macDevice && result[i].macDevice.length > 10 && hdicon.indexOf(result[i].macDevice.toLowerCase()) >= 0) {\n              result[i].connected = true;\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPBluetoothDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_title'] && outObj.SPBluetoothDataType[0]['device_title'].length) {\n                // missing: host BT Adapter macAddr ()\n                let macAddr2 = null;\n                if (outObj.SPBluetoothDataType[0]['local_device_title'] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {\n                  macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ':');\n                }\n                outObj.SPBluetoothDataType[0]['device_title'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_connected'] && outObj.SPBluetoothDataType[0]['device_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_Yes';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_not_connected'] && outObj.SPBluetoothDataType[0]['device_not_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_not_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_No';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach((part) => {\n              if (util.getValue(part.split('\\n'), 'PNPClass', ':') === 'Bluetooth') {\n                result.push(parseWindowsBluetooth(part.split('\\n')));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _netbsd || _openbsd || _sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.bluetoothDevices = bluetoothDevices;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// cpu.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 4. CPU\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _cpu_speed = 0;\nlet _current_cpu = {\n  user: 0,\n  nice: 0,\n  system: 0,\n  idle: 0,\n  irq: 0,\n  load: 0,\n  tick: 0,\n  ms: 0,\n  currentLoad: 0,\n  currentLoadUser: 0,\n  currentLoadSystem: 0,\n  currentLoadNice: 0,\n  currentLoadIdle: 0,\n  currentLoadIrq: 0,\n  rawCurrentLoad: 0,\n  rawCurrentLoadUser: 0,\n  rawCurrentLoadSystem: 0,\n  rawCurrentLoadNice: 0,\n  rawCurrentLoadIdle: 0,\n  rawCurrentLoadIrq: 0\n};\nlet _cpus = [];\nlet _corecount = 0;\n\nconst AMDBaseFrequencies = {\n  '8346': '1.8',\n  '8347': '1.9',\n  '8350': '2.0',\n  '8354': '2.2',\n  '8356|SE': '2.4',\n  '8356': '2.3',\n  '8360': '2.5',\n  '2372': '2.1',\n  '2373': '2.1',\n  '2374': '2.2',\n  '2376': '2.3',\n  '2377': '2.3',\n  '2378': '2.4',\n  '2379': '2.4',\n  '2380': '2.5',\n  '2381': '2.5',\n  '2382': '2.6',\n  '2384': '2.7',\n  '2386': '2.8',\n  '2387': '2.8',\n  '2389': '2.9',\n  '2393': '3.1',\n  '8374': '2.2',\n  '8376': '2.3',\n  '8378': '2.4',\n  '8379': '2.4',\n  '8380': '2.5',\n  '8381': '2.5',\n  '8382': '2.6',\n  '8384': '2.7',\n  '8386': '2.8',\n  '8387': '2.8',\n  '8389': '2.9',\n  '8393': '3.1',\n  '2419EE': '1.8',\n  '2423HE': '2.0',\n  '2425HE': '2.1',\n  '2427': '2.2',\n  '2431': '2.4',\n  '2435': '2.6',\n  '2439SE': '2.8',\n  '8425HE': '2.1',\n  '8431': '2.4',\n  '8435': '2.6',\n  '8439SE': '2.8',\n  '4122': '2.2',\n  '4130': '2.6',\n  '4162EE': '1.7',\n  '4164EE': '1.8',\n  '4170HE': '2.1',\n  '4174HE': '2.3',\n  '4176HE': '2.4',\n  '4180': '2.6',\n  '4184': '2.8',\n  '6124HE': '1.8',\n  '6128HE': '2.0',\n  '6132HE': '2.2',\n  '6128': '2.0',\n  '6134': '2.3',\n  '6136': '2.4',\n  '6140': '2.6',\n  '6164HE': '1.7',\n  '6166HE': '1.8',\n  '6168': '1.9',\n  '6172': '2.1',\n  '6174': '2.2',\n  '6176': '2.3',\n  '6176SE': '2.3',\n  '6180SE': '2.5',\n  '3250': '2.5',\n  '3260': '2.7',\n  '3280': '2.4',\n  '4226': '2.7',\n  '4228': '2.8',\n  '4230': '2.9',\n  '4234': '3.1',\n  '4238': '3.3',\n  '4240': '3.4',\n  '4256': '1.6',\n  '4274': '2.5',\n  '4276': '2.6',\n  '4280': '2.8',\n  '4284': '3.0',\n  '6204': '3.3',\n  '6212': '2.6',\n  '6220': '3.0',\n  '6234': '2.4',\n  '6238': '2.6',\n  '6262HE': '1.6',\n  '6272': '2.1',\n  '6274': '2.2',\n  '6276': '2.3',\n  '6278': '2.4',\n  '6282SE': '2.6',\n  '6284SE': '2.7',\n  '6308': '3.5',\n  '6320': '2.8',\n  '6328': '3.2',\n  '6338P': '2.3',\n  '6344': '2.6',\n  '6348': '2.8',\n  '6366': '1.8',\n  '6370P': '2.0',\n  '6376': '2.3',\n  '6378': '2.4',\n  '6380': '2.5',\n  '6386': '2.8',\n  'FX|4100': '3.6',\n  'FX|4120': '3.9',\n  'FX|4130': '3.8',\n  'FX|4150': '3.8',\n  'FX|4170': '4.2',\n  'FX|6100': '3.3',\n  'FX|6120': '3.6',\n  'FX|6130': '3.6',\n  'FX|6200': '3.8',\n  'FX|8100': '2.8',\n  'FX|8120': '3.1',\n  'FX|8140': '3.2',\n  'FX|8150': '3.6',\n  'FX|8170': '3.9',\n  'FX|4300': '3.8',\n  'FX|4320': '4.0',\n  'FX|4350': '4.2',\n  'FX|6300': '3.5',\n  'FX|6350': '3.9',\n  'FX|8300': '3.3',\n  'FX|8310': '3.4',\n  'FX|8320': '3.5',\n  'FX|8350': '4.0',\n  'FX|8370': '4.0',\n  'FX|9370': '4.4',\n  'FX|9590': '4.7',\n  'FX|8320E': '3.2',\n  'FX|8370E': '3.3',\n\n  // ZEN Desktop CPUs\n  '1200': '3.1',\n  'Pro 1200': '3.1',\n  '1300X': '3.5',\n  'Pro 1300': '3.5',\n  '1400': '3.2',\n  '1500X': '3.5',\n  'Pro 1500': '3.5',\n  '1600': '3.2',\n  '1600X': '3.6',\n  'Pro 1600': '3.2',\n  '1700': '3.0',\n  'Pro 1700': '3.0',\n  '1700X': '3.4',\n  'Pro 1700X': '3.4',\n  '1800X': '3.6',\n  '1900X': '3.8',\n  '1920': '3.2',\n  '1920X': '3.5',\n  '1950X': '3.4',\n\n  // ZEN Desktop APUs\n  '200GE': '3.2',\n  'Pro 200GE': '3.2',\n  '220GE': '3.4',\n  '240GE': '3.5',\n  '3000G': '3.5',\n  '300GE': '3.4',\n  '3050GE': '3.4',\n  '2200G': '3.5',\n  'Pro 2200G': '3.5',\n  '2200GE': '3.2',\n  'Pro 2200GE': '3.2',\n  '2400G': '3.6',\n  'Pro 2400G': '3.6',\n  '2400GE': '3.2',\n  'Pro 2400GE': '3.2',\n\n  // ZEN Mobile APUs\n  'Pro 200U': '2.3',\n  '300U': '2.4',\n  '2200U': '2.5',\n  '3200U': '2.6',\n  '2300U': '2.0',\n  'Pro 2300U': '2.0',\n  '2500U': '2.0',\n  'Pro 2500U': '2.2',\n  '2600H': '3.2',\n  '2700U': '2.0',\n  'Pro 2700U': '2.2',\n  '2800H': '3.3',\n\n  // ZEN Server Processors\n  '7351': '2.4',\n  '7351P': '2.4',\n  '7401': '2.0',\n  '7401P': '2.0',\n  '7551P': '2.0',\n  '7551': '2.0',\n  '7251': '2.1',\n  '7261': '2.5',\n  '7281': '2.1',\n  '7301': '2.2',\n  '7371': '3.1',\n  '7451': '2.3',\n  '7501': '2.0',\n  '7571': '2.2',\n  '7601': '2.2',\n\n  // ZEN Embedded Processors\n  'V1500B': '2.2',\n  'V1780B': '3.35',\n  'V1202B': '2.3',\n  'V1404I': '2.0',\n  'V1605B': '2.0',\n  'V1756B': '3.25',\n  'V1807B': '3.35',\n\n  '3101': '2.1',\n  '3151': '2.7',\n  '3201': '1.5',\n  '3251': '2.5',\n  '3255': '2.5',\n  '3301': '2.0',\n  '3351': '1.9',\n  '3401': '1.85',\n  '3451': '2.15',\n\n  // ZEN+ Desktop\n  '1200|AF': '3.1',\n  '2300X': '3.5',\n  '2500X': '3.6',\n  '2600': '3.4',\n  '2600E': '3.1',\n  '1600|AF': '3.2',\n  '2600X': '3.6',\n  '2700': '3.2',\n  '2700E': '2.8',\n  'Pro 2700': '3.2',\n  '2700X': '3.7',\n  'Pro 2700X': '3.6',\n  '2920X': '3.5',\n  '2950X': '3.5',\n  '2970WX': '3.0',\n  '2990WX': '3.0',\n\n  // ZEN+ Desktop APU\n  'Pro 300GE': '3.4',\n  'Pro 3125GE': '3.4',\n  '3150G': '3.5',\n  'Pro 3150G': '3.5',\n  '3150GE': '3.3',\n  'Pro 3150GE': '3.3',\n  '3200G': '3.6',\n  'Pro 3200G': '3.6',\n  '3200GE': '3.3',\n  'Pro 3200GE': '3.3',\n  '3350G': '3.6',\n  'Pro 3350G': '3.6',\n  '3350GE': '3.3',\n  'Pro 3350GE': '3.3',\n  '3400G': '3.7',\n  'Pro 3400G': '3.7',\n  '3400GE': '3.3',\n  'Pro 3400GE': '3.3',\n\n  // ZEN+ Mobile\n  '3300U': '2.1',\n  'PRO 3300U': '2.1',\n  '3450U': '2.1',\n  '3500U': '2.1',\n  'PRO 3500U': '2.1',\n  '3500C': '2.1',\n  '3550H': '2.1',\n  '3580U': '2.1',\n  '3700U': '2.3',\n  'PRO 3700U': '2.3',\n  '3700C': '2.3',\n  '3750H': '2.3',\n  '3780U': '2.3',\n\n  // ZEN2 Desktop CPUS\n  '3100': '3.6',\n  '3300X': '3.8',\n  '3500': '3.6',\n  '3500X': '3.6',\n  '3600': '3.6',\n  'Pro 3600': '3.6',\n  '3600X': '3.8',\n  '3600XT': '3.8',\n  'Pro 3700': '3.6',\n  '3700X': '3.6',\n  '3800X': '3.9',\n  '3800XT': '3.9',\n  '3900': '3.1',\n  'Pro 3900': '3.1',\n  '3900X': '3.8',\n  '3900XT': '3.8',\n  '3950X': '3.5',\n  '3960X': '3.8',\n  '3970X': '3.7',\n  '3990X': '2.9',\n  '3945WX': '4.0',\n  '3955WX': '3.9',\n  '3975WX': '3.5',\n  '3995WX': '2.7',\n\n  // ZEN2 Desktop APUs\n  '4300GE': '3.5',\n  'Pro 4300GE': '3.5',\n  '4300G': '3.8',\n  'Pro 4300G': '3.8',\n  '4600GE': '3.3',\n  'Pro 4650GE': '3.3',\n  '4600G': '3.7',\n  'Pro 4650G': '3.7',\n  '4700GE': '3.1',\n  'Pro 4750GE': '3.1',\n  '4700G': '3.6',\n  'Pro 4750G': '3.6',\n  '4300U': '2.7',\n  '4450U': '2.5',\n  'Pro 4450U': '2.5',\n  '4500U': '2.3',\n  '4600U': '2.1',\n  'PRO 4650U': '2.1',\n  '4680U': '2.1',\n  '4600HS': '3.0',\n  '4600H': '3.0',\n  '4700U': '2.0',\n  'PRO 4750U': '1.7',\n  '4800U': '1.8',\n  '4800HS': '2.9',\n  '4800H': '2.9',\n  '4900HS': '3.0',\n  '4900H': '3.3',\n  '5300U': '2.6',\n  '5500U': '2.1',\n  '5700U': '1.8',\n\n  // ZEN2 - EPYC\n  '7232P': '3.1',\n  '7302P': '3.0',\n  '7402P': '2.8',\n  '7502P': '2.5',\n  '7702P': '2.0',\n  '7252': '3.1',\n  '7262': '3.2',\n  '7272': '2.9',\n  '7282': '2.8',\n  '7302': '3.0',\n  '7352': '2.3',\n  '7402': '2.8',\n  '7452': '2.35',\n  '7502': '2.5',\n  '7532': '2.4',\n  '7542': '2.9',\n  '7552': '2.2',\n  '7642': '2.3',\n  '7662': '2.0',\n  '7702': '2.0',\n  '7742': '2.25',\n  '7H12': '2.6',\n  '7F32': '3.7',\n  '7F52': '3.5',\n  '7F72': '3.2',\n\n  // Epyc (Milan)\n\n  '7763': '2.45',\n  '7713': '2.0',\n  '7713P': '2.0',\n  '7663': '2.0',\n  '7643': '2.3',\n  '75F3': '2.95',\n  '7543': '2.8',\n  '7543P': '2.8',\n  '7513': '2.6',\n  '7453': '2.75',\n  '74F3': '3.2',\n  '7443': '2.85',\n  '7443P': '2.85',\n  '7413': '2.65',\n  '73F3': '3.5',\n  '7343': '3.2',\n  '7313': '3.0',\n  '7313P': '3.0',\n  '72F3': '3.7',\n\n  // ZEN3\n  '5600X': '3.7',\n  '5800X': '3.8',\n  '5900X': '3.7',\n  '5950X': '3.4'\n};\n\n\nconst socketTypes = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Daughter Board',\n  4: 'ZIF Socket',\n  5: 'Replacement/Piggy Back',\n  6: 'None',\n  7: 'LIF Socket',\n  8: 'Slot 1',\n  9: 'Slot 2',\n  10: '370 Pin Socket',\n  11: 'Slot A',\n  12: 'Slot M',\n  13: '423',\n  14: 'A (Socket 462)',\n  15: '478',\n  16: '754',\n  17: '940',\n  18: '939',\n  19: 'mPGA604',\n  20: 'LGA771',\n  21: 'LGA775',\n  22: 'S1',\n  23: 'AM2',\n  24: 'F (1207)',\n  25: 'LGA1366',\n  26: 'G34',\n  27: 'AM3',\n  28: 'C32',\n  29: 'LGA1156',\n  30: 'LGA1567',\n  31: 'PGA988A',\n  32: 'BGA1288',\n  33: 'rPGA988B',\n  34: 'BGA1023',\n  35: 'BGA1224',\n  36: 'LGA1155',\n  37: 'LGA1356',\n  38: 'LGA2011',\n  39: 'FS1',\n  40: 'FS2',\n  41: 'FM1',\n  42: 'FM2',\n  43: 'LGA2011-3',\n  44: 'LGA1356-3',\n  45: 'LGA1150',\n  46: 'BGA1168',\n  47: 'BGA1234',\n  48: 'BGA1364',\n  49: 'AM4',\n  50: 'LGA1151',\n  51: 'BGA1356',\n  52: 'BGA1440',\n  53: 'BGA1515',\n  54: 'LGA3647-1',\n  55: 'SP3',\n  56: 'SP3r2',\n  57: 'LGA2066',\n  58: 'BGA1392',\n  59: 'BGA1510',\n  60: 'BGA1528',\n  61: 'LGA4189',\n  62: 'LGA1200',\n  63: 'LGA4677',\n};\n\nconst socketTypesByName = {\n  'LGA1150': 'i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430',\n  'LGA1151': 'i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400',\n  '1155': 'G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290'\n};\n\nfunction getSocketTypesByName(str) {\n  let result = '';\n  for (const key in socketTypesByName) {\n    const names = socketTypesByName[key].split(' ');\n    names.forEach(element => {\n      if (str.indexOf(element) >= 0) {\n        result = key;\n      }\n    });\n  }\n  return result;\n}\n\nfunction cpuManufacturer(str) {\n  let result = str;\n  str = str.toLowerCase();\n\n  if (str.indexOf('intel') >= 0) { result = 'Intel'; }\n  if (str.indexOf('amd') >= 0) { result = 'AMD'; }\n  if (str.indexOf('qemu') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('hygon') >= 0) { result = 'Hygon'; }\n  if (str.indexOf('centaur') >= 0) { result = 'WinChip/Via'; }\n  if (str.indexOf('vmware') >= 0) { result = 'VMware'; }\n  if (str.indexOf('Xen') >= 0) { result = 'Xen Hypervisor'; }\n  if (str.indexOf('tcg') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n\n  return result;\n}\n\nfunction cpuBrandManufacturer(res) {\n  res.brand = res.brand.replace(/\\(R\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(TM\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(C\\)+/g, '').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/CPU+/g, '').replace(/\\s+/g, ' ').trim();\n  res.manufacturer = cpuManufacturer(res.brand);\n\n  let parts = res.brand.split(' ');\n  parts.shift();\n  res.brand = parts.join(' ');\n  return res;\n}\n\nfunction getAMDSpeed(brand) {\n  let result = '0';\n  for (let key in AMDBaseFrequencies) {\n    if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {\n      let parts = key.split('|');\n      let found = 0;\n      parts.forEach(item => {\n        if (brand.indexOf(item) > -1) {\n          found++;\n        }\n      });\n      if (found === parts.length) {\n        result = AMDBaseFrequencies[key];\n      }\n    }\n  }\n  return parseFloat(result);\n}\n\n// --------------------------\n// CPU - brand, speed\n\nfunction getCpu() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const UNKNOWN = 'unknown';\n      let result = {\n        manufacturer: UNKNOWN,\n        brand: UNKNOWN,\n        vendor: '',\n        family: '',\n        model: '',\n        stepping: '',\n        revision: '',\n        voltage: '',\n        speed: 0,\n        speedMin: 0,\n        speedMax: 0,\n        governor: '',\n        cores: util.cores(),\n        physicalCores: util.cores(),\n        performanceCores: util.cores(),\n        efficiencyCores: 0,\n        processors: 1,\n        socket: '',\n        flags: '',\n        virtualization: false,\n        cache: {}\n      };\n      cpuFlags().then(flags => {\n        result.flags = flags;\n        result.virtualization = flags.indexOf('vmx') > -1 || flags.indexOf('svm') > -1;\n        if (_darwin) {\n          exec('sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily', function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            const modelline = util.getValue(lines, 'machdep.cpu.brand_string');\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            const speed = modellineParts[1] ? modellineParts[1].trim() : '0';\n            result.speed = parseFloat(speed.replace(/GHz+/g, ''));\n            let tbFrequency = util.getValue(lines, 'hw.tbfrequency') / 1000000000.0;\n            tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;\n            result.speed = result.speed === 0 ? tbFrequency : result.speed;\n\n            _cpu_speed = result.speed;\n            result = cpuBrandManufacturer(result);\n            result.speedMin = util.getValue(lines, 'hw.cpufrequency_min') ? (util.getValue(lines, 'hw.cpufrequency_min') / 1000000000.0) : result.speed;\n            result.speedMax = util.getValue(lines, 'hw.cpufrequency_max') ? (util.getValue(lines, 'hw.cpufrequency_max') / 1000000000.0) : result.speed;\n            result.vendor = util.getValue(lines, 'machdep.cpu.vendor') || 'Apple';\n            result.family = util.getValue(lines, 'machdep.cpu.family') || util.getValue(lines, 'hw.cpufamily');\n            result.model = util.getValue(lines, 'machdep.cpu.model');\n            result.stepping = util.getValue(lines, 'machdep.cpu.stepping') || util.getValue(lines, 'hw.cpusubfamily');\n            result.virtualization = true;\n            const countProcessors = util.getValue(lines, 'hw.packages');\n            const countCores = util.getValue(lines, 'hw.physicalcpu_max');\n            const countThreads = util.getValue(lines, 'hw.ncpu');\n            if (os.arch() === 'arm64') {\n              const clusters = execSync('ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type').toString().split('\\n');\n              const efficiencyCores = clusters.filter(line => line.indexOf('\"E\"') >= 0).length;\n              const performanceCores = clusters.filter(line => line.indexOf('\"P\"') >= 0).length;\n              result.socket = 'SOC';\n              result.efficiencyCores = efficiencyCores;\n              result.performanceCores = performanceCores;\n            }\n            if (countProcessors) {\n              result.processors = parseInt(countProcessors) || 1;\n            }\n            if (countCores && countThreads) {\n              result.cores = parseInt(countThreads) || util.cores();\n              result.physicalCores = parseInt(countCores) || util.cores();\n            }\n            cpuCache().then((res) => {\n              result.cache = res;\n              resolve(result);\n            });\n          });\n        }\n        if (_linux) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; lscpu; echo -n \"Governor: \"; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n            }\n            modelline = util.getValue(lines, 'model name') || modelline;\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            result.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = Math.round(parseFloat(util.getValue(lines, 'cpu min mhz').replace(/,/g, '.')) / 10.0) / 100;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'cpu max mhz').replace(/,/g, '.')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'vendor id'));\n\n            result.family = util.getValue(lines, 'cpu family');\n            result.model = util.getValue(lines, 'model:');\n            result.stepping = util.getValue(lines, 'stepping');\n            result.revision = util.getValue(lines, 'cpu revision');\n            result.cache.l1d = util.getValue(lines, 'l1d cache');\n            if (result.cache.l1d) { result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1d.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l1i = util.getValue(lines, 'l1i cache');\n            if (result.cache.l1i) { result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1i.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l2 = util.getValue(lines, 'l2 cache');\n            if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l2.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l3 = util.getValue(lines, 'l3 cache');\n            if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l3.indexOf('K') !== -1 ? 1024 : 1)); }\n\n            const threadsPerCore = util.getValue(lines, 'thread(s) per core') || '1';\n            const processors = util.getValue(lines, 'socket(s)') || '1';\n            let threadsPerCoreInt = parseInt(threadsPerCore, 10); // threads per code (normally only for performance cores)\n            let processorsInt = parseInt(processors, 10) || 1;  // number of sockets /  processor units in machine (normally 1)\n            const coresPerSocket = parseInt(util.getValue(lines, 'core(s) per socket'), 10); // number of cores (e.g. 16 on i12900)\n            result.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result.cores / threadsPerCoreInt;\n            result.performanceCores = threadsPerCoreInt > 1 ? result.cores - result.physicalCores : result.cores;\n            result.efficiencyCores = threadsPerCoreInt > 1 ? result.cores - (threadsPerCoreInt * result.performanceCores) : 0;\n            result.processors = processorsInt;\n            result.governor = util.getValue(lines, 'governor') || '';\n\n            // Test Raspberry\n            if (result.vendor === 'ARM') {\n              const linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n              const rPIRevision = util.decodePiCpuinfo(linesRpi);\n              if (rPIRevision.model.toLowerCase().indexOf('raspberry') >= 0) {\n                result.family = result.manufacturer;\n                result.manufacturer = rPIRevision.manufacturer;\n                result.brand = rPIRevision.processor;\n                result.revision = rPIRevision.revisionCode;\n                result.socket = 'SOC';\n              }\n            }\n\n            // socket type\n            let lines2 = [];\n            exec('export LC_ALL=C; dmidecode t 4 2>/dev/null | grep \"Upgrade: Socket\"; unset LC_ALL', function (error2, stdout2) {\n              lines2 = stdout2.toString().split('\\n');\n              if (lines2 && lines2.length) {\n                result.socket = util.getValue(lines2, 'Upgrade').replace('Socket', '').trim() || result.socket;\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL', function (error, stdout) {\n            let cache = [];\n            if (!error) {\n              const data = stdout.toString().split('# dmidecode');\n              const processor = data.length > 1 ? data[1] : '';\n              cache = data.length > 2 ? data[2].split('Cache Information') : [];\n\n              lines = processor.split('\\n');\n            }\n            result.brand = modelline.split('@')[0].trim();\n            result.speed = modelline.split('@')[1] ? parseFloat(modelline.split('@')[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = result.speed;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'max speed').replace(/Mhz/g, '')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'manufacturer'));\n            let sig = util.getValue(lines, 'signature');\n            sig = sig.split(',');\n            for (let i = 0; i < sig.length; i++) {\n              sig[i] = sig[i].trim();\n            }\n            result.family = util.getValue(sig, 'Family', ' ', true);\n            result.model = util.getValue(sig, 'Model', ' ', true);\n            result.stepping = util.getValue(sig, 'Stepping', ' ', true);\n            result.revision = '';\n            const voltage = parseFloat(util.getValue(lines, 'voltage'));\n            result.voltage = isNaN(voltage) ? '' : voltage.toFixed(2);\n            for (let i = 0; i < cache.length; i++) {\n              lines = cache[i].split('\\n');\n              let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n              cacheType = cacheType.length ? cacheType[0] : '';\n              const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n              let size = parseInt(sizeParts[0], 10);\n              const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n              size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n              if (cacheType) {\n                if (cacheType === 'l1') {\n                  result.cache[cacheType + 'd'] = size / 2;\n                  result.cache[cacheType + 'i'] = size / 2;\n                } else {\n                  result.cache[cacheType] = size;\n                }\n              }\n            }\n            // socket type\n            result.socket = util.getValue(lines, 'Upgrade').replace('Socket', '').trim();\n            // # threads / # cores\n            const threadCount = util.getValue(lines, 'thread count').trim();\n            const coreCount = util.getValue(lines, 'core count').trim();\n            if (coreCount && threadCount) {\n              result.cores = parseInt(threadCount, 10);\n              result.physicalCores = parseInt(coreCount, 10);\n            }\n            resolve(result);\n          });\n        }\n        if (_sunos) {\n          resolve(result);\n        }\n        if (_windows) {\n          try {\n            const workload = [];\n            workload.push(util.powerShell('Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl'));\n            workload.push(util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl'));\n            workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n\n            Promise.all(\n              workload\n            ).then((data) => {\n              let lines = data[0].split('\\r\\n');\n              let name = util.getValue(lines, 'name', ':') || '';\n              if (name.indexOf('@') >= 0) {\n                result.brand = name.split('@')[0].trim();\n                result.speed = name.split('@')[1] ? parseFloat(name.split('@')[1].trim()) : 0;\n                _cpu_speed = result.speed;\n              } else {\n                result.brand = name.trim();\n                result.speed = 0;\n              }\n              result = cpuBrandManufacturer(result);\n              result.revision = util.getValue(lines, 'revision', ':');\n              result.cache.l1d = 0;\n              result.cache.l1i = 0;\n              result.cache.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.cache.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2, 10) * 1024; }\n              if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3, 10) * 1024; }\n              result.vendor = util.getValue(lines, 'manufacturer', ':');\n              result.speedMax = Math.round(parseFloat(util.getValue(lines, 'maxclockspeed', ':').replace(/,/g, '.')) / 10.0) / 100;\n              if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n                result.speed = getAMDSpeed(result.brand);\n              }\n              if (result.speed === 0) {\n                result.speed = result.speedMax;\n              }\n              result.speedMin = result.speed;\n\n              let description = util.getValue(lines, 'description', ':').split(' ');\n              for (let i = 0; i < description.length; i++) {\n                if (description[i].toLowerCase().startsWith('family') && (i + 1) < description.length && description[i + 1]) {\n                  result.family = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('model') && (i + 1) < description.length && description[i + 1]) {\n                  result.model = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('stepping') && (i + 1) < description.length && description[i + 1]) {\n                  result.stepping = description[i + 1];\n                }\n              }\n              // socket type\n              const socketId = util.getValue(lines, 'UpgradeMethod', ':');\n              if (socketTypes[socketId]) {\n                result.socket = socketTypes[socketId];\n              }\n              const socketByName = getSocketTypesByName(name);\n              if (socketByName) {\n                result.socket = socketByName;\n              }\n              // # threads / # cores\n              const countProcessors = util.countLines(lines, 'Caption');\n              const countThreads = util.getValue(lines, 'NumberOfLogicalProcessors', ':');\n              const countCores = util.getValue(lines, 'NumberOfCores', ':');\n              if (countProcessors) {\n                result.processors = parseInt(countProcessors) || 1;\n              }\n              if (countCores && countThreads) {\n                result.cores = parseInt(countThreads) || util.cores();\n                result.physicalCores = parseInt(countCores) || util.cores();\n              }\n              if (countProcessors > 1) {\n                result.cores = result.cores * countProcessors;\n                result.physicalCores = result.physicalCores * countProcessors;\n              }\n              const parts = data[1].split(/\\n\\s*\\n/);\n              parts.forEach(function (part) {\n                lines = part.split('\\r\\n');\n                const cacheType = util.getValue(lines, 'CacheType');\n                const level = util.getValue(lines, 'Level');\n                const installedSize = util.getValue(lines, 'InstalledSize');\n                // L1 Instructions\n                if (level === '3' && cacheType === '3') {\n                  result.cache.l1i = parseInt(installedSize, 10);\n                }\n                // L1 Data\n                if (level === '3' && cacheType === '4') {\n                  result.cache.l1d = parseInt(installedSize, 10);\n                }\n                // L1 all\n                if (level === '3' && cacheType === '5' && !result.cache.l1i && !result.cache.l1d) {\n                  result.cache.l1i = parseInt(installedSize, 10) / 2;\n                  result.cache.l1d = parseInt(installedSize, 10) / 2;\n                }\n              });\n              const hyperv = data[2] ? data[2].toString().toLowerCase() : '';\n              result.virtualization = hyperv.indexOf('true') !== -1;\n\n              resolve(result);\n            });\n          } catch (e) {\n            resolve(result);\n          }\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// CPU - Processor Data\n\nfunction cpu(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getCpu().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.cpu = cpu;\n\n// --------------------------\n// CPU - current speed - in GHz\n\nfunction getCpuCurrentSpeedSync() {\n\n  let cpus = os.cpus();\n  let minFreq = 999999999;\n  let maxFreq = 0;\n  let avgFreq = 0;\n  let cores = [];\n\n  if (cpus && cpus.length) {\n    for (let i in cpus) {\n      if ({}.hasOwnProperty.call(cpus, i)) {\n        let freq = cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1000 : cpus[i].speed / 10;\n        avgFreq = avgFreq + freq;\n        if (freq > maxFreq) { maxFreq = freq; }\n        if (freq < minFreq) { minFreq = freq; }\n        cores.push(parseFloat(freq.toFixed(2)));\n      }\n    }\n    avgFreq = avgFreq / cpus.length;\n    return {\n      min: parseFloat(minFreq.toFixed(2)),\n      max: parseFloat(maxFreq.toFixed(2)),\n      avg: parseFloat((avgFreq).toFixed(2)),\n      cores: cores\n    };\n  } else {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0,\n      cores: cores\n    };\n  }\n}\n\nfunction cpuCurrentSpeed(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getCpuCurrentSpeedSync();\n      if (result.avg === 0 && _cpu_speed !== 0) {\n        const currCpuSpeed = parseFloat(_cpu_speed);\n        result = {\n          min: currCpuSpeed,\n          max: currCpuSpeed,\n          avg: currCpuSpeed,\n          cores: []\n        };\n      }\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.cpuCurrentSpeed = cpuCurrentSpeed;\n\n// --------------------------\n// CPU - temperature\n// if sensors are installed\n\nfunction cpuTemperature(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        main: null,\n        cores: [],\n        max: null,\n        socket: [],\n        chipset: null\n      };\n      if (_linux) {\n        // CPU Chipset, Socket\n        try {\n          const cmd = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo \"-----\"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';\n          const parts = execSync(cmd).toString().split('-----\\n');\n          if (parts.length === 2) {\n            const lines = parts[0].split('\\n');\n            const lines2 = parts[1].split('\\n');\n            for (let i = 0; i < lines.length; i++) {\n              const line = lines[i].trim();\n              if (line.startsWith('acpi') && lines2[i]) {\n                result.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);\n              }\n              if (line.startsWith('pch') && lines2[i]) {\n                result.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;\n              }\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in \"$mon\"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat \"$label\")___$(cat \"$value\"); fi; done; done;';\n        try {\n          exec(cmd, function (error, stdout) {\n            stdout = stdout.toString();\n            const tdiePos = stdout.toLowerCase().indexOf('tdie');\n            if (tdiePos !== -1) {\n              stdout = stdout.substring(tdiePos);\n            }\n            let lines = stdout.split('\\n');\n            lines.forEach(line => {\n              const parts = line.split('___');\n              const label = parts[0];\n              const value = parts.length > 1 && parts[1] ? parts[1] : '0';\n              if (value && (label === undefined || (label && label.toLowerCase().startsWith('core')))) {\n                result.cores.push(Math.round(parseInt(value, 10) / 100) / 10);\n              } else if (value && label && result.main === null && (label.toLowerCase().indexOf('package') >= 0 || label.toLowerCase().indexOf('physical') >= 0)) {\n                result.main = Math.round(parseInt(value, 10) / 100) / 10;\n              }\n            });\n\n            if (result.cores.length > 0) {\n              if (result.main === null) {\n                result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n              }\n              let maxtmp = Math.max.apply(Math, result.cores);\n              result.max = (maxtmp > result.main) ? maxtmp : result.main;\n            }\n            if (result.main !== null) {\n              if (result.max === null) {\n                result.max = result.main;\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n              return;\n            }\n            exec('sensors', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                let tdieTemp = null;\n                let newSectionStarts = true;\n                let section = '';\n                lines.forEach(function (line) {\n                  // determine section\n                  if (line.trim() === '') {\n                    newSectionStarts = true;\n                  } else if (newSectionStarts) {\n                    if (line.trim().toLowerCase().startsWith('acpi')) { section = 'acpi'; }\n                    if (line.trim().toLowerCase().startsWith('pch')) { section = 'pch'; }\n                    if (line.trim().toLowerCase().startsWith('core')) { section = 'core'; }\n                    newSectionStarts = false;\n                  }\n                  let regex = /[+-]([^]*)/g;\n                  let temps = line.match(regex);\n                  let firstPart = line.split(':')[0].toUpperCase();\n                  if (section === 'acpi') {\n                    // socket temp\n                    if (firstPart.indexOf('TEMP') !== -1) {\n                      result.socket.push(parseFloat(temps));\n                    }\n                  } else if (section === 'pch') {\n                    // chipset temp\n                    if (firstPart.indexOf('TEMP') !== -1 && !result.chipset) {\n                      result.chipset = parseFloat(temps);\n                    }\n                  }\n                  // cpu temp\n                  if (firstPart.indexOf('PHYSICAL') !== -1 || firstPart.indexOf('PACKAGE') !== -1) {\n                    result.main = parseFloat(temps);\n                  }\n                  if (firstPart.indexOf('CORE ') !== -1) {\n                    result.cores.push(parseFloat(temps));\n                  }\n                  if (firstPart.indexOf('TDIE') !== -1 && tdieTemp === null) {\n                    tdieTemp = parseFloat(temps);\n                  }\n                });\n                if (result.cores.length > 0) {\n                  result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n                  let maxtmp = Math.max.apply(Math, result.cores);\n                  result.max = (maxtmp > result.main) ? maxtmp : result.main;\n                } else {\n                  if (result.main === null && tdieTemp !== null) {\n                    result.main = tdieTemp;\n                    result.max = tdieTemp;\n                  }\n                }\n                if (result.main !== null || result.max !== null) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                  return;\n                }\n              }\n              fs.stat('/sys/class/thermal/thermal_zone0/temp', function (err) {\n                if (err === null) {\n                  fs.readFile('/sys/class/thermal/thermal_zone0/temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0) {\n                        result.main = parseFloat(lines[0]) / 1000.0;\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  exec('/opt/vc/bin/vcgencmd measure_temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0 && lines[0].indexOf('=')) {\n                        result.main = parseFloat(lines[0].split('=')[1]);\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              });\n            });\n          });\n        } catch (er) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl dev.cpu | grep temp', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            let sum = 0;\n            lines.forEach(function (line) {\n              const parts = line.split(':');\n              if (parts.length > 1) {\n                const temp = parseFloat(parts[1].replace(',', '.'));\n                if (temp > result.max) { result.max = temp; }\n                sum = sum + temp;\n                result.cores.push(temp);\n              }\n            });\n            if (result.cores.length) {\n              result.main = Math.round(sum / result.cores.length * 100) / 100;\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        /*\n        let osxTemp = null;\n        try {\n          //osxTemp = require('osx-temperature-sensor');\n        } catch (er) {\n          osxTemp = null;\n        }\n        if (osxTemp) {\n          //result = osxTemp.cpuTemperature();\n          // round to 2 digits\n          if (result.main) {\n            result.main = Math.round(result.main * 100) / 100;\n          }\n          if (result.max) {\n            result.max = Math.round(result.max * 100) / 100;\n          }\n          if (result.cores && result.cores.length) {\n            for (let i = 0; i < result.cores.length; i++) {\n              result.cores[i] = Math.round(result.cores[i] * 100) / 100;\n            }\n          }\n        }\n\n        if (callback) { callback(result); }\n        resolve(result);\n        */\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace \"root/wmi\" | Select CurrentTemperature').then((stdout, error) => {\n            if (!error) {\n              let sum = 0;\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                let value = (parseInt(line, 10) - 2732) / 10;\n                if (!isNaN(value)) {\n                  sum = sum + value;\n                  if (value > result.max) { result.max = value; }\n                  result.cores.push(value);\n                }\n              });\n              if (result.cores.length) {\n                result.main = sum / result.cores.length;\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuTemperature = cpuTemperature;\n\n// --------------------------\n// CPU Flags\n\nfunction cpuFlags(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_windows) {\n        try {\n          exec('reg query \"HKEY_LOCAL_MACHINE\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\" /v FeatureSet', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let flag_hex = stdout.split('0x').pop().trim();\n              let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);\n              let flag_bin = '0'.repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;\n              // empty flags are the reserved fields in the CPUID feature bit list\n              // as found on wikipedia:\n              // https://en.wikipedia.org/wiki/CPUID\n              let all_flags = [\n                'fpu', 'vme', 'de', 'pse', 'tsc', 'msr', 'pae', 'mce', 'cx8', 'apic',\n                '', 'sep', 'mtrr', 'pge', 'mca', 'cmov', 'pat', 'pse-36', 'psn', 'clfsh',\n                '', 'ds', 'acpi', 'mmx', 'fxsr', 'sse', 'sse2', 'ss', 'htt', 'tm', 'ia64', 'pbe'\n              ];\n              for (let f = 0; f < all_flags.length; f++) {\n                if (flag_bin[f] === '1' && all_flags[f] !== '') {\n                  result += ' ' + all_flags[f];\n                }\n              }\n              result = result.trim().toLowerCase();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        try {\n\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                if (line.split(':')[0].toUpperCase().indexOf('FLAGS') !== -1) {\n                  result = line.split(':')[1].trim().toLowerCase();\n                }\n              });\n            }\n            if (!result) {\n              fs.readFile('/proc/cpuinfo', function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  result = util.getValue(lines, 'features', ':', true).toLowerCase();\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let flags = [];\n          if (!error) {\n            let parts = stdout.toString().split('\\tFlags:');\n            const lines = parts.length > 1 ? parts[1].split('\\tVersion:')[0].split('\\n') : [];\n            lines.forEach(function (line) {\n              let flag = (line.indexOf('(') ? line.split('(')[0].toLowerCase() : '').trim().replace(/\\t/g, '');\n              if (flag) {\n                flags.push(flag);\n              }\n            });\n          }\n          result = flags.join(' ').trim().toLowerCase();\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl machdep.cpu.features', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0 && lines[0].indexOf('machdep.cpu.features:') !== -1) {\n              result = lines[0].split(':')[1].trim().toLowerCase();\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.cpuFlags = cpuFlags;\n\n// --------------------------\n// CPU Cache\n\nfunction cpuCache(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        l1d: null,\n        l1i: null,\n        l2: null,\n        l3: null,\n      };\n      if (_linux) {\n        try {\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                let parts = line.split(':');\n                if (parts[0].toUpperCase().indexOf('L1D CACHE') !== -1) {\n                  result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L1I CACHE') !== -1) {\n                  result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L2 CACHE') !== -1) {\n                  result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L3 CACHE') !== -1) {\n                  result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let cache = [];\n          if (!error) {\n            const data = stdout.toString();\n            cache = data.split('Cache Information');\n            cache.shift();\n          }\n          for (let i = 0; i < cache.length; i++) {\n            const lines = cache[i].split('\\n');\n            let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n            cacheType = cacheType.length ? cacheType[0] : '';\n            const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n            let size = parseInt(sizeParts[0], 10);\n            const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n            size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n            if (cacheType) {\n              if (cacheType === 'l1') {\n                result.cache[cacheType + 'd'] = size / 2;\n                result.cache[cacheType + 'i'] = size / 2;\n              } else {\n                result.cache[cacheType] = size;\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let parts = line.split(':');\n              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.l1d = 0;\n              result.l1i = 0;\n              result.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.l2) { result.l2 = parseInt(result.l2, 10) * 1024; }\n              if (result.l3) { result.l3 = parseInt(result.l3, 10) * 1024; }\n            }\n            util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl').then((stdout, error) => {\n              if (!error) {\n                const parts = stdout.split(/\\n\\s*\\n/);\n                parts.forEach(function (part) {\n                  const lines = part.split('\\r\\n');\n                  const cacheType = util.getValue(lines, 'CacheType');\n                  const level = util.getValue(lines, 'Level');\n                  const installedSize = util.getValue(lines, 'InstalledSize');\n                  // L1 Instructions\n                  if (level === '3' && cacheType === '3') {\n                    result.l1i = parseInt(installedSize, 10);\n                  }\n                  // L1 Data\n                  if (level === '3' && cacheType === '4') {\n                    result.l1d = parseInt(installedSize, 10);\n                  }\n                  // L1 all\n                  if (level === '3' && cacheType === '5' && !result.l1i && !result.l1d) {\n                    result.l1i = parseInt(installedSize, 10) / 2;\n                    result.l1d = parseInt(installedSize, 10) / 2;\n                  }\n                });\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuCache = cpuCache;\n\n// --------------------------\n// CPU - current load - in %\n\nfunction getLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let loads = os.loadavg().map(function (x) { return x / util.cores(); });\n      let avgLoad = parseFloat((Math.max.apply(Math, loads)).toFixed(2));\n      let result = {};\n\n      let now = Date.now() - _current_cpu.ms;\n      if (now >= 200) {\n        _current_cpu.ms = Date.now();\n        const cpus = os.cpus();\n        let totalUser = 0;\n        let totalSystem = 0;\n        let totalNice = 0;\n        let totalIrq = 0;\n        let totalIdle = 0;\n        let cores = [];\n        _corecount = (cpus && cpus.length) ? cpus.length : 0;\n\n        for (let i = 0; i < _corecount; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIdle += cpu.idle;\n          totalIrq += cpu.irq;\n          let tmpTick = (_cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0);\n          let tmpLoad = (_cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0);\n          let tmpUser = (_cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0);\n          let tmpSystem = (_cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0);\n          let tmpNice = (_cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0);\n          let tmpIdle = (_cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0);\n          let tmpIrq = (_cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0);\n          _cpus[i] = cpu;\n          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;\n          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;\n          _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;\n          _cpus[i].load = (_cpus[i].totalLoad - tmpLoad);\n          _cpus[i].loadUser = (_cpus[i].user - tmpUser);\n          _cpus[i].loadSystem = (_cpus[i].sys - tmpSystem);\n          _cpus[i].loadNice = (_cpus[i].nice - tmpNice);\n          _cpus[i].loadIdle = (_cpus[i].idle - tmpIdle);\n          _cpus[i].loadIrq = (_cpus[i].irq - tmpIrq);\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;\n        let totalLoad = totalUser + totalSystem + totalNice + totalIrq;\n        let currentTick = totalTick - _current_cpu.tick;\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,\n          currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,\n          currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,\n          currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,\n          currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,\n          currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,\n          rawCurrentLoad: (totalLoad - _current_cpu.load),\n          rawCurrentLoadUser: (totalUser - _current_cpu.user),\n          rawCurrentLoadSystem: (totalSystem - _current_cpu.system),\n          rawCurrentLoadNice: (totalNice - _current_cpu.nice),\n          rawCurrentLoadIdle: (totalIdle - _current_cpu.idle),\n          rawCurrentLoadIrq: (totalIrq - _current_cpu.irq),\n          cpus: cores\n        };\n        _current_cpu = {\n          user: totalUser,\n          nice: totalNice,\n          system: totalSystem,\n          idle: totalIdle,\n          irq: totalIrq,\n          tick: totalTick,\n          load: totalLoad,\n          ms: _current_cpu.ms,\n          currentLoad: result.currentLoad,\n          currentLoadUser: result.currentLoadUser,\n          currentLoadSystem: result.currentLoadSystem,\n          currentLoadNice: result.currentLoadNice,\n          currentLoadIdle: result.currentLoadIdle,\n          currentLoadIrq: result.currentLoadIrq,\n          rawCurrentLoad: result.rawCurrentLoad,\n          rawCurrentLoadUser: result.rawCurrentLoadUser,\n          rawCurrentLoadSystem: result.rawCurrentLoadSystem,\n          rawCurrentLoadNice: result.rawCurrentLoadNice,\n          rawCurrentLoadIdle: result.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: result.rawCurrentLoadIrq,\n        };\n      } else {\n        let cores = [];\n        for (let i = 0; i < _corecount; i++) {\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: _current_cpu.currentLoad,\n          currentLoadUser: _current_cpu.currentLoadUser,\n          currentLoadSystem: _current_cpu.currentLoadSystem,\n          currentLoadNice: _current_cpu.currentLoadNice,\n          currentLoadIdle: _current_cpu.currentLoadIdle,\n          currentLoadIrq: _current_cpu.currentLoadIrq,\n          rawCurrentLoad: _current_cpu.rawCurrentLoad,\n          rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,\n          rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,\n          rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,\n          rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,\n          cpus: cores\n        };\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction currentLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.currentLoad = currentLoad;\n\n// --------------------------\n// PS - full load\n// since bootup\n\nfunction getFullLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const cpus = os.cpus();\n      let totalUser = 0;\n      let totalSystem = 0;\n      let totalNice = 0;\n      let totalIrq = 0;\n      let totalIdle = 0;\n\n      let result = 0;\n\n      if (cpus && cpus.length) {\n        for (let i = 0, len = cpus.length; i < len; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIrq += cpu.irq;\n          totalIdle += cpu.idle;\n        }\n        let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;\n        result = (totalTicks - totalIdle) / totalTicks * 100.0;\n\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction fullLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getFullLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.fullLoad = fullLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// docker.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. Docker\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst DockerSocket = require('./dockerSocket');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\n\nlet _docker_container_stats = {};\nlet _docker_socket;\nlet _docker_last_read = 0;\n\n\n// --------------------------\n// get containers (parameter all: get also inactive/exited containers)\n\nfunction dockerInfo(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const result = {};\n\n      _docker_socket.getInfo((data) => {\n        result.id = data.ID;\n        result.containers = data.Containers;\n        result.containersRunning = data.ContainersRunning;\n        result.containersPaused = data.ContainersPaused;\n        result.containersStopped = data.ContainersStopped;\n        result.images = data.Images;\n        result.driver = data.Driver;\n        result.memoryLimit = data.MemoryLimit;\n        result.swapLimit = data.SwapLimit;\n        result.kernelMemory = data.KernelMemory;\n        result.cpuCfsPeriod = data.CpuCfsPeriod;\n        result.cpuCfsQuota = data.CpuCfsQuota;\n        result.cpuShares = data.CPUShares;\n        result.cpuSet = data.CPUSet;\n        result.ipv4Forwarding = data.IPv4Forwarding;\n        result.bridgeNfIptables = data.BridgeNfIptables;\n        result.bridgeNfIp6tables = data.BridgeNfIp6tables;\n        result.debug = data.Debug;\n        result.nfd = data.NFd;\n        result.oomKillDisable = data.OomKillDisable;\n        result.ngoroutines = data.NGoroutines;\n        result.systemTime = data.SystemTime;\n        result.loggingDriver = data.LoggingDriver;\n        result.cgroupDriver = data.CgroupDriver;\n        result.nEventsListener = data.NEventsListener;\n        result.kernelVersion = data.KernelVersion;\n        result.operatingSystem = data.OperatingSystem;\n        result.osType = data.OSType;\n        result.architecture = data.Architecture;\n        result.ncpu = data.NCPU;\n        result.memTotal = data.MemTotal;\n        result.dockerRootDir = data.DockerRootDir;\n        result.httpProxy = data.HttpProxy;\n        result.httpsProxy = data.HttpsProxy;\n        result.noProxy = data.NoProxy;\n        result.name = data.Name;\n        result.labels = data.Labels;\n        result.experimentalBuild = data.ExperimentalBuild;\n        result.serverVersion = data.ServerVersion;\n        result.clusterStore = data.ClusterStore;\n        result.clusterAdvertise = data.ClusterAdvertise;\n        result.defaultRuntime = data.DefaultRuntime;\n        result.liveRestoreEnabled = data.LiveRestoreEnabled;\n        result.isolation = data.Isolation;\n        result.initBinary = data.InitBinary;\n        result.productLicense = data.ProductLicense;\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.dockerInfo = dockerInfo;\n\nfunction dockerImages(all, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listImages(all, data => {\n        let dockerImages = {};\n        try {\n          dockerImages = data;\n          if (dockerImages && Object.prototype.toString.call(dockerImages) === '[object Array]' && dockerImages.length > 0) {\n\n            dockerImages.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerImagesInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerImagesInspect(imageID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      imageID = imageID || '';\n      if (typeof imageID !== 'string') {\n        return resolve();\n      }\n      const imageIDSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(imageID, true)).trim();\n      if (imageIDSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.inspectImage(imageIDSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              container: data.Container,\n              comment: data.Comment,\n              os: data.Os,\n              architecture: data.Architecture,\n              parent: data.Parent,\n              dockerVersion: data.DockerVersion,\n              size: data.Size,\n              sharedSize: payload.SharedSize,\n              virtualSize: data.VirtualSize,\n              author: data.Author,\n              created: data.Created ? Math.round(new Date(data.Created).getTime() / 1000) : 0,\n              containerConfig: data.ContainerConfig ? data.ContainerConfig : {},\n              graphDriver: data.GraphDriver ? data.GraphDriver : {},\n              repoDigests: data.RepoDigests ? data.RepoDigests : {},\n              repoTags: data.RepoTags ? data.RepoTags : {},\n              config: data.Config ? data.Config : {},\n              rootFS: data.RootFS ? data.RootFS : {},\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerImages = dockerImages;\n\nfunction dockerContainers(all, callback) {\n\n  function inContainers(containers, id) {\n    let filtered = containers.filter(obj => {\n      /**\n       * @namespace\n       * @property {string}  Id\n       */\n      return (obj.Id && (obj.Id === id));\n    });\n    return (filtered.length > 0);\n  }\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listContainers(all, data => {\n        let docker_containers = {};\n        try {\n          docker_containers = data;\n          if (docker_containers && Object.prototype.toString.call(docker_containers) === '[object Array]' && docker_containers.length > 0) {\n            // GC in _docker_container_stats\n            for (let key in _docker_container_stats) {\n              if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n                if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n              }\n            }\n\n            docker_containers.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerContainerInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          // GC in _docker_container_stats\n          for (let key in _docker_container_stats) {\n            if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n              if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerContainerInspect(containerID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve();\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerIdSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              name: payload.Name,\n              image: payload.Image,\n              imageID: payload.ImageID,\n              command: payload.Command,\n              created: payload.Created,\n              started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1000) : 0,\n              finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? Math.round(new Date(data.State.FinishedAt).getTime() / 1000) : 0,\n              createdAt: data.Created ? data.Created : '',\n              startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : '',\n              finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? data.State.FinishedAt : '',\n              state: payload.State,\n              restartCount: data.RestartCount || 0,\n              platform: data.Platform || '',\n              driver: data.Driver || '',\n              ports: payload.Ports,\n              mounts: payload.Mounts,\n              // hostconfig: payload.HostConfig,\n              // network: payload.NetworkSettings\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerContainers = dockerContainers;\n\n// --------------------------\n// helper functions for calculation of docker stats\n\nfunction docker_calcCPUPercent(cpu_stats, precpu_stats) {\n  /**\n   * @namespace\n   * @property {object}  cpu_usage\n   * @property {number}  cpu_usage.total_usage\n   * @property {number}  system_cpu_usage\n   * @property {object}  cpu_usage\n   * @property {Array}  cpu_usage.percpu_usage\n   */\n\n  if (!_windows) {\n    let cpuPercent = 0.0;\n    // calculate the change for the cpu usage of the container in between readings\n    let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n    // calculate the change for the entire system between readings\n    let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;\n\n    if (systemDelta > 0.0 && cpuDelta > 0.0) {\n      // calculate the change for the cpu usage of the container in between readings\n      if (precpu_stats.online_cpus) {\n        cpuPercent = (cpuDelta / systemDelta) * precpu_stats.online_cpus * 100.0;\n      }\n      else {\n        cpuPercent = (cpuDelta / systemDelta) * cpu_stats.cpu_usage.percpu_usage.length * 100.0;\n      }\n    }\n\n    return cpuPercent;\n  } else {\n    let nanoSecNow = util.nanoSeconds();\n    let cpuPercent = 0.0;\n    if (_docker_last_read > 0) {\n      let possIntervals = (nanoSecNow - _docker_last_read); //  / 100 * os.cpus().length;\n      let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n      if (possIntervals > 0) {\n        cpuPercent = 100.0 * intervalsUsed / possIntervals;\n      }\n    }\n    _docker_last_read = nanoSecNow;\n    return cpuPercent;\n  }\n}\n\nfunction docker_calcNetworkIO(networks) {\n  let rx;\n  let wx;\n  for (let key in networks) {\n    // skip loop if the property is from prototype\n    if (!{}.hasOwnProperty.call(networks, key)) { continue; }\n\n    /**\n     * @namespace\n     * @property {number}  rx_bytes\n     * @property {number}  tx_bytes\n     */\n    let obj = networks[key];\n    rx = +obj.rx_bytes;\n    wx = +obj.tx_bytes;\n  }\n  return {\n    rx,\n    wx\n  };\n}\n\nfunction docker_calcBlockIO(blkio_stats) {\n  let result = {\n    r: 0,\n    w: 0\n  };\n\n  /**\n   * @namespace\n   * @property {Array}  io_service_bytes_recursive\n   */\n  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === '[object Array]' && blkio_stats.io_service_bytes_recursive.length > 0) {\n    blkio_stats.io_service_bytes_recursive.forEach(function (element) {\n      /**\n       * @namespace\n       * @property {string}  op\n       * @property {number}  value\n       */\n\n      if (element.op && element.op.toLowerCase() === 'read' && element.value) {\n        result.r += element.value;\n      }\n      if (element.op && element.op.toLowerCase() === 'write' && element.value) {\n        result.w += element.value;\n      }\n    });\n  }\n  return result;\n}\n\nfunction dockerContainerStats(containerIDs, callback) {\n\n  let containerArray = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(containerIDs) && !callback) {\n        callback = containerIDs;\n        containerArray = ['*'];\n      } else {\n        containerIDs = containerIDs || '*';\n        if (typeof containerIDs !== 'string') {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        let containerIDsSanitized = '';\n        containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;\n        containerIDsSanitized.__proto__.replace = util.stringReplace;\n        containerIDsSanitized.__proto__.trim = util.stringTrim;\n\n        containerIDsSanitized = containerIDs;\n        containerIDsSanitized = containerIDsSanitized.trim();\n        if (containerIDsSanitized !== '*') {\n          containerIDsSanitized = '';\n          const s = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerIDs, true)).trim();\n          for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n            if (s[i] !== undefined) {\n              s[i].__proto__.toLowerCase = util.stringToLower;\n              const sl = s[i].toLowerCase();\n              if (sl && sl[0] && !sl[1]) {\n                containerIDsSanitized = containerIDsSanitized + sl[0];\n              }\n            }\n          }\n        }\n\n        containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, '|');\n        containerArray = containerIDsSanitized.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (containerArray.length && containerArray[0].trim() === '*') {\n        containerArray = [];\n        dockerContainers().then(allContainers => {\n          for (let container of allContainers) {\n            containerArray.push(container.id);\n          }\n          if (containerArray.length) {\n            dockerContainerStats(containerArray.join(',')).then(result => {\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      } else {\n        for (let containerID of containerArray) {\n          workload.push(dockerContainerStatsSingle(containerID.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\n// --------------------------\n// container stats (for one container)\n\nfunction dockerContainerStatsSingle(containerID) {\n  containerID = containerID || '';\n  let result = {\n    id: containerID,\n    memUsage: 0,\n    memLimit: 0,\n    memPercent: 0,\n    cpuPercent: 0,\n    pids: 0,\n    netIO: {\n      rx: 0,\n      wx: 0\n    },\n    blockIO: {\n      r: 0,\n      w: 0\n    },\n    restartCount: 0,\n    cpuStats: {},\n    precpuStats: {},\n    memoryStats: {},\n    networks: {},\n  };\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (containerID) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerID, dataInspect => {\n          try {\n            _docker_socket.getStats(containerID, data => {\n              try {\n                let stats = data;\n\n                if (!stats.message) {\n                  result.memUsage = (stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0);\n                  result.memLimit = (stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0);\n                  result.memPercent = (stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100.0 : 0);\n                  result.cpuPercent = (stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0);\n                  result.pids = (stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0);\n                  result.restartCount = (dataInspect.RestartCount ? dataInspect.RestartCount : 0);\n                  if (stats.networks) { result.netIO = docker_calcNetworkIO(stats.networks); }\n                  if (stats.blkio_stats) { result.blockIO = docker_calcBlockIO(stats.blkio_stats); }\n                  result.cpuStats = (stats.cpu_stats ? stats.cpu_stats : {});\n                  result.precpuStats = (stats.precpu_stats ? stats.precpu_stats : {});\n                  result.memoryStats = (stats.memory_stats ? stats.memory_stats : {});\n                  result.networks = (stats.networks ? stats.networks : {});\n                }\n              } catch (err) {\n                util.noop();\n              }\n              // }\n              resolve(result);\n            });\n          } catch (err) {\n            util.noop();\n          }\n        });\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerStats = dockerContainerStats;\n\n// --------------------------\n// container processes (for one container)\n\nfunction dockerContainerProcesses(containerID, callback) {\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve(result);\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getProcesses(containerIdSanitized, data => {\n          /**\n           * @namespace\n           * @property {Array}  Titles\n           * @property {Array}  Processes\n           **/\n          try {\n            if (data && data.Titles && data.Processes) {\n              let titles = data.Titles.map(function (value) {\n                return value.toUpperCase();\n              });\n              let pos_pid = titles.indexOf('PID');\n              let pos_ppid = titles.indexOf('PPID');\n              let pos_pgid = titles.indexOf('PGID');\n              let pos_vsz = titles.indexOf('VSZ');\n              let pos_time = titles.indexOf('TIME');\n              let pos_elapsed = titles.indexOf('ELAPSED');\n              let pos_ni = titles.indexOf('NI');\n              let pos_ruser = titles.indexOf('RUSER');\n              let pos_user = titles.indexOf('USER');\n              let pos_rgroup = titles.indexOf('RGROUP');\n              let pos_group = titles.indexOf('GROUP');\n              let pos_stat = titles.indexOf('STAT');\n              let pos_rss = titles.indexOf('RSS');\n              let pos_command = titles.indexOf('COMMAND');\n\n              data.Processes.forEach(process => {\n                result.push({\n                  pidHost: (pos_pid >= 0 ? process[pos_pid] : ''),\n                  ppid: (pos_ppid >= 0 ? process[pos_ppid] : ''),\n                  pgid: (pos_pgid >= 0 ? process[pos_pgid] : ''),\n                  user: (pos_user >= 0 ? process[pos_user] : ''),\n                  ruser: (pos_ruser >= 0 ? process[pos_ruser] : ''),\n                  group: (pos_group >= 0 ? process[pos_group] : ''),\n                  rgroup: (pos_rgroup >= 0 ? process[pos_rgroup] : ''),\n                  stat: (pos_stat >= 0 ? process[pos_stat] : ''),\n                  time: (pos_time >= 0 ? process[pos_time] : ''),\n                  elapsed: (pos_elapsed >= 0 ? process[pos_elapsed] : ''),\n                  nice: (pos_ni >= 0 ? process[pos_ni] : ''),\n                  rss: (pos_rss >= 0 ? process[pos_rss] : ''),\n                  vsz: (pos_vsz >= 0 ? process[pos_vsz] : ''),\n                  command: (pos_command >= 0 ? process[pos_command] : '')\n                });\n              });\n            }\n          } catch (err) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerProcesses = dockerContainerProcesses;\n\nfunction dockerVolumes(callback) {\n\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      _docker_socket.listVolumes((data) => {\n        let dockerVolumes = {};\n        try {\n          dockerVolumes = data;\n          if (dockerVolumes && dockerVolumes.Volumes && Object.prototype.toString.call(dockerVolumes.Volumes) === '[object Array]' && dockerVolumes.Volumes.length > 0) {\n\n            dockerVolumes.Volumes.forEach(function (element) {\n\n              result.push({\n                name: element.Name,\n                driver: element.Driver,\n                labels: element.Labels,\n                mountpoint: element.Mountpoint,\n                options: element.Options,\n                scope: element.Scope,\n                created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1000) : 0,\n              });\n            });\n            if (callback) { callback(result); }\n            resolve(result);\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerVolumes = dockerVolumes;\n\nfunction dockerAll(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      dockerContainers(true).then(result => {\n        if (result && Object.prototype.toString.call(result) === '[object Array]' && result.length > 0) {\n          let l = result.length;\n          result.forEach(function (element) {\n            dockerContainerStats(element.id).then((res) => {\n              // include stats in array\n              element.memUsage = res[0].memUsage;\n              element.memLimit = res[0].memLimit;\n              element.memPercent = res[0].memPercent;\n              element.cpuPercent = res[0].cpuPercent;\n              element.pids = res[0].pids;\n              element.netIO = res[0].netIO;\n              element.blockIO = res[0].blockIO;\n              element.cpuStats = res[0].cpuStats;\n              element.precpuStats = res[0].precpuStats;\n              element.memoryStats = res[0].memoryStats;\n              element.networks = res[0].networks;\n\n              dockerContainerProcesses(element.id).then(processes => {\n                element.processes = processes;\n\n                l -= 1;\n                if (l === 0) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n              // all done??\n            });\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerAll = dockerAll;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// dockerSockets.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. DockerSockets\n// ----------------------------------------------------------------------------------\n\nconst net = require('net');\nconst isWin = require('os').type() === 'Windows_NT';\nconst socketPath = isWin ? '//./pipe/docker_engine' : '/var/run/docker.sock';\n\nclass DockerSocket {\n\n  getInfo(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/info HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  listImages(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/images/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  inspectImage(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/images/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listContainers(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/containers/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  getStats(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getInspect(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getProcesses(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listVolumes(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/volumes HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n}\n\nmodule.exports = DockerSocket;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst fs = require('fs');\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromiseSave = util.promisifySave(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _fs_speed = {};\nlet _disk_io = {};\n\n// --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n\n  let macOsDisks = [];\n  let osMounts = [];\n\n  function getmacOsFsType(fs) {\n    if (!fs.startsWith('/')) { return 'NFS'; }\n    const parts = fs.split('/');\n    const fsShort = parts[parts.length - 1];\n    const macOsDisksSingle = macOsDisks.filter(item => item.indexOf(fsShort) >= 0);\n    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf('APFS') >= 0) { return 'APFS'; }\n    return 'HFS';\n  }\n\n  function isLinuxTmpFs(fs) {\n    const linuxTmpFileSystems = ['rootfs', 'unionfs', 'squashfs', 'cramfs', 'initrd', 'initramfs', 'devtmpfs', 'tmpfs', 'udev', 'devfs', 'specfs', 'type', 'appimaged'];\n    let result = false;\n    linuxTmpFileSystems.forEach(linuxFs => {\n      if (fs.toLowerCase().indexOf(linuxFs) >= 0) { result = true; }\n    });\n    return result;\n  }\n\n  function filterLines(stdout) {\n    let lines = stdout.toString().split('\\n');\n    if (stdout.toString().toLowerCase().indexOf('filesystem')) {\n      let removeLines = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i].toLowerCase().startsWith('filesystem')) {\n          removeLines = i;\n        }\n      }\n      for (let i = 0; i < removeLines; i++) {\n        lines.shift();\n      }\n    }\n    return lines;\n  }\n\n  function parseDf(lines) {\n    let data = [];\n    lines.forEach(function (line) {\n      if (line !== '') {\n        line = line.replace(/ +/g, ' ').split(' ');\n        if (line && ((line[0].startsWith('/')) || (line[6] && line[6] === '/') || (line[0].indexOf('/') > 0) || (line[0].indexOf(':') === 1) || !_darwin && !isLinuxTmpFs(line[1]))) {\n          const fs = line[0];\n          const fsType = ((_linux || _freebsd || _openbsd || _netbsd) ? line[1] : getmacOsFsType(line[0]));\n          const size = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[2] : line[1])) * 1024;\n          const used = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[3] : line[2])) * 1024;\n          const available = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[4] : line[3])) * 1024;\n          const use = parseFloat((100.0 * (used / (used + available))).toFixed(2));\n          let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs] || false : null;\n          line.splice(0, (_linux || _freebsd || _openbsd || _netbsd) ? 6 : 5);\n          const mount = line.join(' ');\n          if (!data.find(el => (el.fs === fs && el.type === fsType))) {\n            data.push({\n              fs,\n              type: fsType,\n              size,\n              used,\n              available,\n              use,\n              mount,\n              rw\n            });\n          }\n        }\n      }\n    });\n    return data;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = '';\n        macOsDisks = [];\n        osMounts = {};\n        if (_darwin) {\n          cmd = 'df -kP';\n          try {\n            macOsDisks = execSync('diskutil list').toString().split('\\n').filter(line => {\n              return !line.startsWith('/') && line.indexOf(':') > 0;\n            });\n            execSync('mount').toString().split('\\n').filter(line => {\n              return line.startsWith('/');\n            }).forEach((line) => {\n              osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n            });\n          } catch (e) {\n            util.noop();\n          }\n        }\n        if (_linux) {\n          cmd = 'df -lkPTx squashfs';\n          execSync('cat /proc/mounts 2>/dev/null').toString().split('\\n').filter(line => {\n            return line.startsWith('/');\n          }).forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('rw') >= 0;\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'df -lkPT';\n          execSync('mount').toString().split('\\n').forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n          });\n        }\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          let lines = filterLines(stdout);\n          data = parseDf(lines);\n          if (!error || data.length) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('df -kPT', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = filterLines(stdout);\n                data = parseDf(lines);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        try {\n          // util.wmic('logicaldisk get Caption,FileSystem,FreeSpace,Size').then((stdout) => {\n          util.powerShell('Get-CimInstance Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const size = util.toInt(util.getValue(lines, 'size', ':'));\n                const free = util.toInt(util.getValue(lines, 'freespace', ':'));\n                const caption = util.getValue(lines, 'caption', ':');\n                const rwValue = util.getValue(lines, 'access', ':');\n                const rw = rwValue ? (util.toInt(rwValue) !== 1) : null;\n                if (size) {\n                  data.push({\n                    fs: caption,\n                    type: util.getValue(lines, 'filesystem', ':'),\n                    size,\n                    used: size - free,\n                    available: free,\n                    use: parseFloat(((100.0 * (size - free)) / size).toFixed(2)),\n                    mount: caption,\n                    rw\n                  });\n                }\n              });\n            }\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize;\n\n// --------------------------\n// FS - open files count\n\nfunction fsOpenFiles(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = {\n        max: null,\n        allocated: null,\n        available: null\n      };\n      if (_freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = 'sysctl -i kern.maxfiles kern.num_files kern.open_files';\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.max = parseInt(util.getValue(lines, 'kern.maxfiles', ':'), 10);\n            result.allocated = parseInt(util.getValue(lines, 'kern.num_files', ':'), 10) || parseInt(util.getValue(lines, 'kern.open_files', ':'), 10);\n            result.available = result.max - result.allocated;\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        fs.readFile('/proc/sys/fs/file-nr', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines[0]) {\n              const parts = lines[0].replace(/\\s+/g, ' ').split(' ');\n              if (parts.length === 3) {\n                result.allocated = parseInt(parts[0], 10);\n                result.available = parseInt(parts[1], 10);\n                result.max = parseInt(parts[2], 10);\n                if (!result.available) { result.available = result.max - result.allocated; }\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            fs.readFile('/proc/sys/fs/file-max', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                if (lines[0]) {\n                  result.max = parseInt(lines[0], 10);\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.fsOpenFiles = fsOpenFiles;\n\n// --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n        if (parts.length > 1) {\n          if (!devices[i]) {\n            devices[i] = {\n              name: '',\n              identifier: '',\n              type: 'disk',\n              fsType: '',\n              mount: '',\n              size: 0,\n              physical: 'HDD',\n              uuid: '',\n              label: '',\n              model: '',\n              serial: '',\n              removable: false,\n              protocol: '',\n              group: '',\n              device: ''\n            };\n          }\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) { devices[i].identifier = parts[1]; }\n          if ('DEVICENODE' === parts[0]) { devices[i].name = parts[1]; }\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) { devices[i].label = parts[1]; }\n          }\n          if ('PROTOCOL' === parts[0]) { devices[i].protocol = parts[1]; }\n          if ('DISKSIZE' === parts[0]) { devices[i].size = parseBytes(parts[1]); }\n          if ('FILESYSTEMPERSONALITY' === parts[0]) { devices[i].fsType = parts[1]; }\n          if ('MOUNTPOINT' === parts[0]) { devices[i].mount = parts[1]; }\n          if ('VOLUMEUUID' === parts[0]) { devices[i].uuid = parts[1]; }\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'CD/DVD'; }\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'SSD'; }\n          if ('VIRTUAL' === parts[0]) { devices[i].type = 'virtual'; }\n          if ('REMOVABLEMEDIA' === parts[0]) { devices[i].removable = (parts[1] === 'Removable'); }\n          if ('PARTITIONTYPE' === parts[0]) { devices[i].type = 'part'; }\n          if ('DEVICE/MEDIANAME' === parts[0]) { devices[i].model = parts[1]; }\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n\n  lines.filter(line => line !== '').forEach((line) => {\n    try {\n      line = decodeURIComponent(line.replace(/\\\\x/g, '%'));\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n      let disk = JSON.parse(line);\n      data.push({\n        'name': disk.name,\n        'type': disk.type,\n        'fsType': disk.fsType,\n        'mount': disk.mountpoint,\n        'size': parseInt(disk.size),\n        'physical': (disk.type === 'disk' ? (disk.rota === '0' ? 'SSD' : 'HDD') : (disk.type === 'rom' ? 'CD/DVD' : '')),\n        'uuid': disk.uuid,\n        'label': disk.label,\n        'model': (disk.model || '').trim(),\n        'serial': disk.serial,\n        'removable': disk.rm === '1',\n        'protocol': disk.tran,\n        'group': disk.group || '',\n      });\n    } catch (e) {\n      util.noop();\n    }\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction decodeMdabmData(lines) {\n  const raid = util.getValue(lines, 'md_level', '=');\n  const label = util.getValue(lines, 'md_name', '='); // <- get label info\n  const uuid = util.getValue(lines, 'md_uuid', '='); // <- get uuid info\n  const members = [];\n  lines.forEach(line => {\n    if (line.toLowerCase().startsWith('md_device_dev') && line.toLowerCase().indexOf('/dev/') > 0) {\n      members.push(line.split('/dev/')[1]);\n    }\n  });\n  return {\n    raid,\n    label,\n    uuid,\n    members\n  };\n}\n\nfunction raidMatchLinux(data) {\n  // for all block devices of type \"raid%\"\n  let result = data;\n  try {\n    data.forEach(element => {\n      if (element.type.startsWith('raid')) {\n        const lines = execSync(`mdadm --export --detail /dev/${element.name}`).toString().split('\\n');\n        const mdData = decodeMdabmData(lines);\n\n        element.label = mdData.label; // <- assign label info\n        element.uuid = mdData.uuid; // <- assign uuid info\n\n        if (mdData.members && mdData.members.length && mdData.raid === element.type) {\n          result = result.map(blockdevice => {\n            if (blockdevice.fsType === 'linux_raid_member' && mdData.members.indexOf(blockdevice.name) >= 0) {\n              blockdevice.group = element.name;\n            }\n            return blockdevice;\n          });\n        }\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesLinux(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push(element.name);\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesLinux(data) {\n  let result = data;\n  try {\n    const devices = getDevicesLinux(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element)) {\n            blockdevice.device = '/dev/' + element;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesMac(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push({ name: element.name, model: element.model, device: element.name });\n    }\n    if (element.type.startsWith('virtual')) {\n      let device = '';\n      result.forEach(e => {\n        if (e.model === element.model) {\n          device = e.device;\n        }\n      });\n      if (device) {\n        result.push({ name: element.name, model: element.model, device });\n      }\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesMac(data) {\n  let result = data;\n  try {\n    const devices = getDevicesMac(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk') || blockdevice.type.startsWith('virtual')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element.name)) {\n            blockdevice.device = element.device;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesWin(diskDrives) {\n  const result = [];\n  diskDrives.forEach(element => {\n    const lines = element.split('\\r\\n');\n    const device = util.getValue(lines, 'DeviceID', ':');\n    let partitions = element.split('@{DeviceID=');\n    if (partitions.length > 1) {\n      partitions = partitions.slice(1);\n      partitions.forEach(partition => {\n        result.push({ name: partition.split(';')[0].toUpperCase(), device });\n      });\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesWin(data, diskDrives) {\n  const devices = getDevicesWin(diskDrives);\n  data.map(element => {\n    const filteresDevices = devices.filter((e) => { return e.name === element.name.toUpperCase(); });\n    if (filteresDevices.length > 0) {\n      element.device = filteresDevices[0].device;\n    }\n    return element;\n  });\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString()\n    .replace(/NAME=/g, '{\"name\":')\n    .replace(/FSTYPE=/g, ',\"fsType\":')\n    .replace(/TYPE=/g, ',\"type\":')\n    .replace(/SIZE=/g, ',\"size\":')\n    .replace(/MOUNTPOINT=/g, ',\"mountpoint\":')\n    .replace(/UUID=/g, ',\"uuid\":')\n    .replace(/ROTA=/g, ',\"rota\":')\n    .replace(/RO=/g, ',\"ro\":')\n    .replace(/RM=/g, ',\"rm\":')\n    .replace(/TRAN=/g, ',\"tran\":')\n    .replace(/SERIAL=/g, ',\"serial\":')\n    .replace(/LABEL=/g, ',\"label\":')\n    .replace(/MODEL=/g, ',\"model\":')\n    .replace(/OWNER=/g, ',\"owner\":')\n    .replace(/GROUP=/g, ',\"group\":')\n    .replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n            data = raidMatchLinux(data);\n            data = matchDevicesLinux(data);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n                data = raidMatchLinux(data);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        exec('diskutil info -all', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            // parse lines into temp array of devices\n            data = parseDevices(lines);\n            data = matchDevicesMac(data);\n          }\n          if (callback) {\n            callback(data);\n          }\n          resolve(data);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        let drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n        try {\n          // util.wmic('logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value').then((stdout, error) => {\n          // util.powerShell('Get-CimInstance Win32_logicaldisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl').then((stdout, error) => {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl'));\n          workload.push(util.powerShell('Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L=\\'Partitions\\'; E={$_.GetRelated(\\'Win32_DiskPartition\\').GetRelated(\\'Win32_LogicalDisk\\') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl'));\n          util.promiseAll(\n            workload\n          ).then((res) => {\n            let logicalDisks = res.results[0].toString().split(/\\n\\s*\\n/);\n            let diskDrives = res.results[1].toString().split(/\\n\\s*\\n/);\n            logicalDisks.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              let drivetype = util.getValue(lines, 'drivetype', ':');\n              if (drivetype) {\n                data.push({\n                  name: util.getValue(lines, 'name', ':'),\n                  identifier: util.getValue(lines, 'caption', ':'),\n                  type: 'disk',\n                  fsType: util.getValue(lines, 'filesystem', ':').toLowerCase(),\n                  mount: util.getValue(lines, 'caption', ':'),\n                  size: util.getValue(lines, 'size', ':'),\n                  physical: (drivetype >= 0 && drivetype <= 6) ? drivetypes[drivetype] : drivetypes[0],\n                  uuid: util.getValue(lines, 'volumeserialnumber', ':'),\n                  label: util.getValue(lines, 'volumename', ':'),\n                  model: '',\n                  serial: util.getValue(lines, 'volumeserialnumber', ':'),\n                  removable: drivetype === '2',\n                  protocol: '',\n                  group: '',\n                  device: ''\n                });\n              }\n            });\n            // match devices\n            data = matchDevicesWin(data, diskDrives);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        // will follow\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n\n    });\n  });\n}\n\nexports.blockDevices = blockDevices;\n\n// --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: null,\n    wx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = null;\n    _fs_speed.wx_sec = null;\n    _fs_speed.tx_sec = null;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n  return result;\n}\n\nfunction fsStats(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: null,\n        wx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let rx = 0;\n      let wx = 0;\n      if ((_fs_speed && !_fs_speed.ms) || (_fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500)) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk -r 2>/dev/null | grep /', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) { fs_filter.push(line[0]); }\n                }\n              });\n\n              let output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: null,\n    wIO_sec: null,\n    tIO_sec: null,\n    rWaitTime: 0,\n    wWaitTime: 0,\n    tWaitTime: 0,\n    rWaitPercent: null,\n    wWaitPercent: null,\n    tWaitPercent: null,\n    ms: 0\n  };\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    result.rWaitPercent = (result.rWaitTime - _disk_io.rWaitTime) * 100 / (result.ms);\n    result.wWaitPercent = (result.wWaitTime - _disk_io.wWaitTime) * 100 / (result.ms);\n    result.tWaitPercent = (result.tWaitTime - _disk_io.tWaitTime) * 100 / (result.ms);\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = result.rWaitPercent;\n    _disk_io.wWaitPercent = result.wWaitPercent;\n    _disk_io.tWaitPercent = result.tWaitPercent;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = null;\n    _disk_io.wIO_sec = null;\n    _disk_io.tIO_sec = null;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = null;\n    _disk_io.wWaitPercent = null;\n    _disk_io.tWaitPercent = null;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n  return result;\n}\n\nfunction disksIO(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        return resolve(null);\n      }\n      if (_sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: null,\n        wIO_sec: null,\n        tIO_sec: null,\n        rWaitTime: 0,\n        wWaitTime: 0,\n        tWaitTime: 0,\n        rWaitPercent: null,\n        wWaitPercent: null,\n        tWaitPercent: null,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n      let rWaitTime = 0;\n      let wWaitTime = 0;\n      let tWaitTime = 0;\n\n      if ((_disk_io && !_disk_io.ms) || (_disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500)) {\n        if (_linux || _freebsd || _openbsd || _netbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/ //' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = 'for mount in `lsblk 2>/dev/null | grep \" disk \" | sed \"s/[]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n\n          exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) { return; }\n\n                // sum r/wIO of all disks to compute all disks IO\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n                rWaitTime += parseInt(stats[3]);\n                wWaitTime += parseInt(stats[7]);\n                tWaitTime += parseInt(stats[10]);\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n        result.rWaitTime = _disk_io.rWaitTime;\n        result.wWaitTime = _disk_io.wWaitTime;\n        result.tWaitTime = _disk_io.tWaitTime;\n        result.rWaitPercent = _disk_io.rWaitPercent;\n        result.wWaitPercent = _disk_io.wWaitPercent;\n        result.tWaitPercent = _disk_io.tWaitPercent;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n\n  function getVendorFromModel(model) {\n    const diskManufacturers = [\n      { pattern: 'WESTERN.*', manufacturer: 'Western Digital' },\n      { pattern: '^WDC.*', manufacturer: 'Western Digital' },\n      { pattern: 'WD.*', manufacturer: 'Western Digital' },\n      { pattern: 'TOSHIBA.*', manufacturer: 'Toshiba' },\n      { pattern: 'HITACHI.*', manufacturer: 'Hitachi' },\n      { pattern: '^IC.*', manufacturer: 'Hitachi' },\n      { pattern: '^HTS.*', manufacturer: 'Hitachi' },\n      { pattern: 'SANDISK.*', manufacturer: 'SanDisk' },\n      { pattern: 'KINGSTON.*', manufacturer: 'Kingston Technology' },\n      { pattern: '^SONY.*', manufacturer: 'Sony' },\n      { pattern: 'TRANSCEND.*', manufacturer: 'Transcend' },\n      { pattern: 'SAMSUNG.*', manufacturer: 'Samsung' },\n      { pattern: '^ST(?!I\\\\ ).*', manufacturer: 'Seagate' },\n      { pattern: '^STI\\\\ .*', manufacturer: 'SimpleTech' },\n      { pattern: '^D...-.*', manufacturer: 'IBM' },\n      { pattern: '^IBM.*', manufacturer: 'IBM' },\n      { pattern: '^FUJITSU.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MP.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MK.*', manufacturer: 'Toshiba' },\n      { pattern: 'MAXTO.*', manufacturer: 'Maxtor' },\n      { pattern: 'PIONEER.*', manufacturer: 'Pioneer' },\n      { pattern: 'PHILIPS.*', manufacturer: 'Philips' },\n      { pattern: 'QUANTUM.*', manufacturer: 'Quantum Technology' },\n      { pattern: 'FIREBALL.*', manufacturer: 'Quantum Technology' },\n      { pattern: '^VBOX.*', manufacturer: 'VirtualBox' },\n      { pattern: 'CORSAIR.*', manufacturer: 'Corsair Components' },\n      { pattern: 'CRUCIAL.*', manufacturer: 'Crucial' },\n      { pattern: 'ECM.*', manufacturer: 'ECM' },\n      { pattern: 'INTEL.*', manufacturer: 'INTEL' },\n      { pattern: 'EVO.*', manufacturer: 'Samsung' },\n      { pattern: 'APPLE.*', manufacturer: 'Apple' },\n    ];\n\n    let result = '';\n    if (model) {\n      model = model.toUpperCase();\n      diskManufacturers.forEach((manufacturer) => {\n        const re = RegExp(manufacturer.pattern);\n        if (re.test(model)) { result = manufacturer.manufacturer; }\n      });\n    }\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const commitResult = res => {\n        for (let i = 0; i < res.length; i++) {\n          delete res[i].BSDName;\n        }\n        if (callback) {\n          callback(res);\n        }\n        resolve(res);\n      };\n\n      let result = [];\n      let cmd = '';\n\n      if (_linux) {\n        let cmdFullSmart = '';\n\n        exec('export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            try {\n              const out = stdout.toString().trim();\n              let devices = [];\n              try {\n                const outJSON = JSON.parse(out);\n                if (outJSON && {}.hasOwnProperty.call(outJSON, 'blockdevices')) {\n                  devices = outJSON.blockdevices.filter(item => { return (item.type === 'disk') && item.size > 0 && (item.model !== null || (item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf('/ram') !== 0 && item.path.indexOf('/loop') !== 0 && item['disc-max'] && item['disc-max'] !== 0)); });\n                }\n              } catch (e) {\n                // fallback to older version of lsblk\n                const out2 = execSync('export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL').toString();\n                let lines = blkStdoutToObject(out2).split('\\n');\n                const data = parseBlk(lines);\n                devices = data.filter(item => { return (item.type === 'disk') && item.size > 0 && ((item.model !== null && item.model !== '') || (item.mount === '' && item.label === '' && item.fsType === '')); });\n              }\n              devices.forEach((device) => {\n                let mediumType = '';\n                const BSDName = '/dev/' + device.name;\n                const logical = device.name;\n                try {\n                  mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational 2>/dev/null').toString().split('\\n')[0];\n                } catch (e) {\n                  util.noop();\n                }\n                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : '';\n                if (interfaceType === 'NVME') {\n                  mediumType = '2';\n                  interfaceType = 'PCIe';\n                }\n                result.push({\n                  device: BSDName,\n                  type: (mediumType === '0' ? 'SSD' : (mediumType === '1' ? 'HD' : (mediumType === '2' ? 'NVMe' : (device.model && device.model.indexOf('SSD') > -1 ? 'SSD' : (device.model && device.model.indexOf('NVM') > -1 ? 'NVMe' : 'HD'))))),\n                  name: device.model || '',\n                  vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ''),\n                  size: device.size || 0,\n                  bytesPerSector: null,\n                  totalCylinders: null,\n                  totalHeads: null,\n                  totalSectors: null,\n                  totalTracks: null,\n                  tracksPerCylinder: null,\n                  sectorsPerTrack: null,\n                  firmwareRevision: device.rev ? device.rev.trim() : '',\n                  serialNum: device.serial ? device.serial.trim() : '',\n                  interfaceType: interfaceType,\n                  smartStatus: 'unknown',\n                  temperature: null,\n                  BSDName: BSDName\n                });\n                cmd += `printf \"\\n${BSDName}|\"; smartctl -H ${BSDName} | grep overall;`;\n                cmdFullSmart += `${cmdFullSmart ? 'printf \",\";' : ''}smartctl -a -j ${BSDName};`;\n              });\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // check S.M.A.R.T. status\n          if (cmdFullSmart) {\n            exec(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              try {\n                const data = JSON.parse(`[${stdout}]`);\n                data.forEach(disk => {\n                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];\n\n                  for (let i = 0; i < result.length; i++) {\n                    if (result[i].BSDName === diskBSDName) {\n                      result[i].smartStatus = (disk.smart_status.passed ? 'Ok' : (disk.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (disk.temperature && disk.temperature.current) {\n                        result[i].temperature = disk.temperature.current;\n                      }\n                      result[i].smartData = disk;\n                    }\n                  }\n                });\n                commitResult(result);\n              } catch (e) {\n                if (cmd) {\n                  cmd = cmd + 'printf \"\\n\"';\n                  exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                    let lines = stdout.toString().split('\\n');\n                    lines.forEach(line => {\n                      if (line) {\n                        let parts = line.split('|');\n                        if (parts.length === 2) {\n                          let BSDName = parts[0];\n                          parts[1] = parts[1].trim();\n                          let parts2 = parts[1].split(':');\n                          if (parts2.length === 2) {\n                            parts2[1] = parts2[1].trim();\n                            let status = parts2[1].toLowerCase();\n                            for (let i = 0; i < result.length; i++) {\n                              if (result[i].BSDName === BSDName) {\n                                result[i].smartStatus = (status === 'passed' ? 'Ok' : (status === 'failed!' ? 'Predicted Failure' : 'unknown'));\n                              }\n                            }\n                          }\n                        }\n                      }\n                    });\n                    commitResult(result);\n                  });\n                } else {\n                  commitResult(result);\n                }\n              }\n            });\n          } else {\n            commitResult(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            // split by type:\n            let lines = stdout.toString().split('\\n');\n            let linesSATA = [];\n            let linesNVMe = [];\n            let linesUSB = [];\n            let dataType = 'SATA';\n            lines.forEach(line => {\n              if (line === 'NVMExpress:') { dataType = 'NVMe'; }\n              else if (line === 'USB:') { dataType = 'USB'; }\n              else if (line === 'SATA/SATA Express:') { dataType = 'SATA'; }\n              else if (dataType === 'SATA') { linesSATA.push(line); }\n              else if (dataType === 'NVMe') { linesNVMe.push(line); }\n              else if (dataType === 'USB') { linesUSB.push(line); }\n            });\n            try {\n              // Serial ATA Drives\n              let devices = linesSATA.join('\\n').split(' Physical Interconnect: ');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = 'InterfaceType: ' + device;\n                let lines = device.split('\\n');\n                const mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n                const sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()) || util.getValue(lines, 'Manufacturer', ':', true),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n\n            // NVME Drives\n            try {\n              let devices = linesNVMe.join('\\n').split('\\n\\n          Capacity:');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                let lines = device.split('\\n');\n                const linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                const sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            // USB Drives\n            try {\n              let devices = linesUSB.join('\\n').replaceAll('Media:\\n ', 'Model:').split('\\n\\n          Product ID:');\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\n');\n                const sizeStr = util.getValue(lines, 'Capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'USB',\n                      name: util.getValue(lines, 'Model', ':', true).trim().replaceAll(':', ''),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: 'USB',\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            if (cmd) {\n              cmd = cmd + 'printf \"\\n\"';\n              exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(line => {\n                  if (line) {\n                    let parts = line.split('|');\n                    if (parts.length === 2) {\n                      let BSDName = parts[0];\n                      parts[1] = parts[1].trim();\n                      let parts2 = parts[1].split(':');\n                      if (parts2.length === 2) {\n                        parts2[1] = parts2[1].trim();\n                        let status = parts2[1].toLowerCase();\n                        for (let i = 0; i < result.length; i++) {\n                          if (result[i].BSDName === BSDName) {\n                            result[i].smartStatus = (status === 'not supported' ? 'not supported' : (status === 'verified' ? 'Ok' : (status === 'failing' ? 'Predicted Failure' : 'unknown')));\n                          }\n                        }\n                      }\n                    }\n                  }\n                });\n                for (let i = 0; i < result.length; i++) {\n                  delete result[i].BSDName;\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              for (let i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          }\n        });\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl'));\n          workload.push(util.powerShell('Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl'));\n          if (util.smartMonToolsInstalled()) {\n            try {\n              const smartDev = JSON.parse(execSync('smartctl --scan -j'));\n              if (smartDev && smartDev.devices && smartDev.devices.length > 0) {\n                smartDev.devices.forEach((dev) => {\n                  workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let devices = data.results[0].toString().split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const status = util.getValue(lines, 'Status', ':').trim().toLowerCase();\n              if (size) {\n                result.push({\n                  device: util.getValue(lines, 'DeviceId', ':'),  // changed from PNPDeviceId to DeviceID (be be able to match devices)\n                  type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                  name: util.getValue(lines, 'Caption', ':'),\n                  vendor: getVendorFromModel(util.getValue(lines, 'Caption', ':', true).trim()),\n                  size: parseInt(size),\n                  bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', ':')),\n                  totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', ':')),\n                  totalHeads: parseInt(util.getValue(lines, 'TotalHeads', ':')),\n                  totalSectors: parseInt(util.getValue(lines, 'TotalSectors', ':')),\n                  totalTracks: parseInt(util.getValue(lines, 'TotalTracks', ':')),\n                  tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', ':')),\n                  sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', ':')),\n                  firmwareRevision: util.getValue(lines, 'FirmwareRevision', ':').trim(),\n                  serialNum: util.getValue(lines, 'SerialNumber', ':').trim(),\n                  interfaceType: util.getValue(lines, 'InterfaceType', ':').trim(),\n                  smartStatus: (status === 'ok' ? 'Ok' : (status === 'degraded' ? 'Degraded' : (status === 'pred fail' ? 'Predicted Failure' : 'Unknown'))),\n                  temperature: null,\n                });\n              }\n            });\n            devices = data.results[1].split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n              const name = util.getValue(lines, 'FriendlyName', ':').trim().replace('Msft ', 'Microsoft');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const model = util.getValue(lines, 'Model', ':').trim();\n              const interfaceType = util.getValue(lines, 'BusType', ':').trim();\n              let mediaType = util.getValue(lines, 'MediaType', ':').trim();\n              if (mediaType === '3' || mediaType === 'HDD') { mediaType = 'HD'; }\n              if (mediaType === '4') { mediaType = 'SSD'; }\n              if (mediaType === '5') { mediaType = 'SCM'; }\n              if (mediaType === 'Unspecified' && (model.toLowerCase().indexOf('virtual') > -1 || model.toLowerCase().indexOf('vbox') > -1)) { mediaType = 'Virtual'; }\n              if (size) {\n                let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                if (i === -1 || serialNum === '') {\n                  i = util.findObjectByKey(result, 'name', name);\n                }\n                if (i != -1) {\n                  result[i].type = mediaType;\n                  result[i].interfaceType = interfaceType;\n                }\n              }\n            });\n            // S.M.A.R.T\n            data.results.shift();\n            data.results.shift();\n            if (data.results.length) {\n              data.results.forEach((smartStr) => {\n                try {\n                  const smartData = JSON.parse(smartStr);\n                  if (smartData.serial_number) {\n                    const serialNum = smartData.serial_number;\n                    let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                    if (i != -1) {\n                      result[i].smartStatus = (smartData.smart_status && smartData.smart_status.passed ? 'Ok' : (smartData.smart_status && smartData.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (smartData.temperature && smartData.temperature.current) {\n                        result[i].temperature = smartData.temperature.current;\n                      }\n                      result[i].smartData = smartData;\n                    }\n                  }\n                } catch (e) {\n                  util.noop();\n                }\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// graphics.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 7. Graphics (controller, display)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\nlet _nvidiaSmiPath = '';\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _resolutionX = 0;\nlet _resolutionY = 0;\nlet _pixelDepth = 0;\nlet _refreshRate = 0;\n\nconst videoTypes = {\n  '-2': 'UNINITIALIZED',\n  '-1': 'OTHER',\n  '0': 'HD15',\n  '1': 'SVIDEO',\n  '2': 'Composite video',\n  '3': 'Component video',\n  '4': 'DVI',\n  '5': 'HDMI',\n  '6': 'LVDS',\n  '8': 'D_JPN',\n  '9': 'SDI',\n  '10': 'DP',\n  '11': 'DP embedded',\n  '12': 'UDI',\n  '13': 'UDI embedded',\n  '14': 'SDTVDONGLE',\n  '15': 'MIRACAST',\n  '2147483648': 'INTERNAL'\n};\n\nfunction getVendorFromModel(model) {\n  const manufacturers = [\n    { pattern: '^LG.+', manufacturer: 'LG' },\n    { pattern: '^BENQ.+', manufacturer: 'BenQ' },\n    { pattern: '^ASUS.+', manufacturer: 'Asus' },\n    { pattern: '^DELL.+', manufacturer: 'Dell' },\n    { pattern: '^SAMSUNG.+', manufacturer: 'Samsung' },\n    { pattern: '^VIEWSON.+', manufacturer: 'ViewSonic' },\n    { pattern: '^SONY.+', manufacturer: 'Sony' },\n    { pattern: '^ACER.+', manufacturer: 'Acer' },\n    { pattern: '^AOC.+', manufacturer: 'AOC Monitors' },\n    { pattern: '^HP.+', manufacturer: 'HP' },\n    { pattern: '^EIZO.?', manufacturer: 'Eizo' },\n    { pattern: '^PHILIPS.?', manufacturer: 'Philips' },\n    { pattern: '^IIYAMA.?', manufacturer: 'Iiyama' },\n    { pattern: '^SHARP.?', manufacturer: 'Sharp' },\n    { pattern: '^NEC.?', manufacturer: 'NEC' },\n    { pattern: '^LENOVO.?', manufacturer: 'Lenovo' },\n    { pattern: 'COMPAQ.?', manufacturer: 'Compaq' },\n    { pattern: 'APPLE.?', manufacturer: 'Apple' },\n    { pattern: 'INTEL.?', manufacturer: 'Intel' },\n    { pattern: 'AMD.?', manufacturer: 'AMD' },\n    { pattern: 'NVIDIA.?', manufacturer: 'NVDIA' },\n  ];\n\n  let result = '';\n  if (model) {\n    model = model.toUpperCase();\n    manufacturers.forEach((manufacturer) => {\n      const re = RegExp(manufacturer.pattern);\n      if (re.test(model)) { result = manufacturer.manufacturer; }\n    });\n  }\n  return result;\n}\n\nfunction getVendorFromId(id) {\n  const vendors = {\n    '610': 'Apple',\n    '1e6d': 'LG',\n    '10ac': 'DELL',\n    '4dd9': 'Sony',\n    '38a3': 'NEC',\n  };\n  return vendors[id] || '';\n}\n\nfunction vendorToId(str) {\n  let result = '';\n  str = (str || '').toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = '0x05ac'; }\n  else if (str.indexOf('nvidia') >= 0) { result = '0x10de'; }\n  else if (str.indexOf('intel') >= 0) { result = '0x8086'; }\n  else if (str.indexOf('ati') >= 0 || str.indexOf('amd') >= 0) { result = '0x1002'; }\n\n  return result;\n}\n\nfunction getMetalVersion(id) {\n  const families = {\n    'spdisplays_mtlgpufamilymac1': 'mac1',\n    'spdisplays_mtlgpufamilymac2': 'mac2',\n    'spdisplays_mtlgpufamilyapple1': 'apple1',\n    'spdisplays_mtlgpufamilyapple2': 'apple2',\n    'spdisplays_mtlgpufamilyapple3': 'apple3',\n    'spdisplays_mtlgpufamilyapple4': 'apple4',\n    'spdisplays_mtlgpufamilyapple5': 'apple5',\n    'spdisplays_mtlgpufamilyapple6': 'apple6',\n    'spdisplays_mtlgpufamilyapple7': 'apple7',\n    'spdisplays_metalfeaturesetfamily11': 'family1_v1',\n    'spdisplays_metalfeaturesetfamily12': 'family1_v2',\n    'spdisplays_metalfeaturesetfamily13': 'family1_v3',\n    'spdisplays_metalfeaturesetfamily14': 'family1_v4',\n    'spdisplays_metalfeaturesetfamily21': 'family2_v1'\n  };\n  return families[id] || '';\n}\n\nfunction graphics(callback) {\n\n  function parseLinesDarwin(graphicsArr) {\n    const res = {\n      controllers: [],\n      displays: []\n    };\n    try {\n      graphicsArr.forEach(function (item) {\n        // controllers\n        const bus = ((item.sppci_bus || '').indexOf('builtin') > -1 ? 'Built-In' : ((item.sppci_bus || '').indexOf('pcie') > -1 ? 'PCIe' : ''));\n        const vram = (parseInt((item.spdisplays_vram || ''), 10) || 0) * (((item.spdisplays_vram || '').indexOf('GB') > -1) ? 1024 : 1);\n        const vramDyn = (parseInt((item.spdisplays_vram_shared || ''), 10) || 0) * (((item.spdisplays_vram_shared || '').indexOf('GB') > -1) ? 1024 : 1);\n        let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || '');\n        res.controllers.push({\n          vendor: getVendorFromModel(item.spdisplays_vendor || '') || item.spdisplays_vendor || '',\n          model: item.sppci_model || '',\n          bus,\n          vramDynamic: bus === 'Built-In',\n          vram: vram || vramDyn || null,\n          deviceId: item['spdisplays_device-id'] || '',\n          vendorId: item['spdisplays_vendor-id'] || vendorToId((item['spdisplays_vendor'] || '') + (item.sppci_model || '')),\n          external: (item.sppci_device_type === 'spdisplays_egpu'),\n          cores: item['sppci_cores'] || null,\n          metalVersion\n        });\n\n        // displays\n        if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {\n          item.spdisplays_ndrvs.forEach(function (displayItem) {\n            const connectionType = displayItem['spdisplays_connection_type'] || '';\n            const currentResolutionParts = (displayItem['_spdisplays_resolution'] || '').split('@');\n            const currentResolution = currentResolutionParts[0].split('x');\n            const pixelParts = (displayItem['_spdisplays_pixels'] || '').split('x');\n            const pixelDepthString = displayItem['spdisplays_depth'] || '';\n            const serial = displayItem['_spdisplays_display-serial-number'] || displayItem['_spdisplays_display-serial-number2'] || null;\n            res.displays.push({\n              vendor: getVendorFromId(displayItem['_spdisplays_display-vendor-id'] || '') || getVendorFromModel(displayItem['_name'] || ''),\n              vendorId: displayItem['_spdisplays_display-vendor-id'] || '',\n              model: displayItem['_name'] || '',\n              productionYear: displayItem['_spdisplays_display-year'] || null,\n              serial: serial !== '0' ? serial : null,\n              displayId: displayItem['_spdisplays_displayID'] || null,\n              main: displayItem['spdisplays_main'] ? displayItem['spdisplays_main'] === 'spdisplays_yes' : false,\n              builtin: (displayItem['spdisplays_display_type'] || '').indexOf('built-in') > -1,\n              connection: ((connectionType.indexOf('_internal') > -1) ? 'Internal' : ((connectionType.indexOf('_displayport') > -1) ? 'Display Port' : ((connectionType.indexOf('_hdmi') > -1) ? 'HDMI' : null))),\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: (pixelDepthString === 'CGSThirtyBitColor' ? 30 : (pixelDepthString === 'CGSThirtytwoBitColor' ? 32 : (pixelDepthString === 'CGSTwentyfourBitColor' ? 24 : null))),\n              resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,\n              resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,\n              currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,\n              currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null,\n\n            });\n          });\n        }\n      });\n      return res;\n    } catch (e) {\n      return res;\n    }\n  }\n\n  function parseLinesLinuxControllers(lines) {\n    let controllers = [];\n    let currentController = {\n      vendor: '',\n      model: '',\n      bus: '',\n      busAddress: '',\n      vram: null,\n      vramDynamic: false,\n      pciID: ''\n    };\n    let isGraphicsController = false;\n    // PCI bus IDs\n    let pciIDs = [];\n    try {\n      pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep \"Bus Address: \"').toString().split('\\n');\n      for (let i = 0; i < pciIDs.length; i++) {\n        pciIDs[i] = pciIDs[i].replace('Bus Address:', '').replace('0000:', '').trim();\n      }\n      pciIDs = pciIDs.filter(function (el) {\n        return el != null && el;\n      });\n    } catch (e) {\n      util.noop();\n    }\n    lines.forEach((line) => {\n      if ('' !== line.trim()) {\n        if (' ' !== line[0] && '\\t' !== line[0]) {        // first line of new entry\n          let isExternal = (pciIDs.indexOf(line.split(' ')[0]) >= 0);\n          let vgapos = line.toLowerCase().indexOf(' vga ');\n          let _3dcontrollerpos = line.toLowerCase().indexOf('3d controller');\n          if (vgapos !== -1 || _3dcontrollerpos !== -1) {         // VGA\n            if (_3dcontrollerpos !== -1 && vgapos === -1) {\n              vgapos = _3dcontrollerpos;\n            }\n            if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n              controllers.push(currentController);\n              currentController = {\n                vendor: '',\n                model: '',\n                bus: '',\n                busAddress: '',\n                vram: null,\n                vramDynamic: false,\n              };\n            }\n\n            const pciIDCandidate = line.split(' ')[0];\n            if (/[\\da-fA-F]{2}:[\\da-fA-F]{2}\\.[\\da-fA-F]/.test(pciIDCandidate)) {\n              currentController.busAddress = pciIDCandidate;\n            }\n            isGraphicsController = true;\n            let endpos = line.search(/\\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);\n            let parts = line.substr(vgapos, endpos - vgapos).split(':');\n            currentController.busAddress = line.substr(0, vgapos).trim();\n            if (parts.length > 1) {\n              parts[1] = parts[1].trim();\n              if (parts[1].toLowerCase().indexOf('corporation') >= 0) {\n                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf('corporation') + 11).trim();\n                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf('corporation') + 11, 200).trim().split('(')[0];\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' inc.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' inc.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' inc.') + 5, 200).trim().split('(')[0].trim();\n                }\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' ltd.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' ltd.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' ltd.') + 5, 200).trim().split('(')[0].trim();\n                }\n              }\n            }\n\n          } else {\n            isGraphicsController = false;\n          }\n        }\n        if (isGraphicsController) { // within VGA details\n          let parts = line.split(':');\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('devicename') !== -1 && parts[1].toLowerCase().indexOf('onboard') !== -1) { currentController.bus = 'Onboard'; }\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('region') !== -1 && parts[1].toLowerCase().indexOf('memory') !== -1) {\n            let memparts = parts[1].split('=');\n            if (memparts.length > 1) {\n              currentController.vram = parseInt(memparts[1]);\n            }\n          }\n        }\n      }\n    });\n\n    if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n      controllers.push(currentController);\n    }\n    return (controllers);\n  }\n\n  function parseLinesLinuxClinfo(controllers, lines) {\n    const fieldPattern = /\\[([^\\]]+)\\]\\s+(\\w+)\\s+(.*)/;\n    const devices = lines.reduce((devices, line) => {\n      const field = fieldPattern.exec(line.trim());\n      if (field) {\n        if (!devices[field[1]]) {\n          devices[field[1]] = {};\n        }\n        devices[field[1]][field[2]] = field[3];\n      }\n      return devices;\n    }, {});\n    for (let deviceId in devices) {\n      const device = devices[deviceId];\n      if (device['CL_DEVICE_TYPE'] === 'CL_DEVICE_TYPE_GPU') {\n        let busAddress;\n        if (device['CL_DEVICE_TOPOLOGY_AMD']) {\n          const bdf = device['CL_DEVICE_TOPOLOGY_AMD'].match(/[a-zA-Z0-9]+:\\d+\\.\\d+/);\n          if (bdf) {\n            busAddress = bdf[0];\n          }\n        } else if (device['CL_DEVICE_PCI_BUS_ID_NV'] && device['CL_DEVICE_PCI_SLOT_ID_NV']) {\n          const bus = parseInt(device['CL_DEVICE_PCI_BUS_ID_NV']);\n          const slot = parseInt(device['CL_DEVICE_PCI_SLOT_ID_NV']);\n          if (!isNaN(bus) && !isNaN(slot)) {\n            const b = bus & 0xff;\n            const d = (slot >> 3) & 0xff;\n            const f = slot & 0x07;\n            busAddress = `${b.toString().padStart(2, '0')}:${d.toString().padStart(2, '0')}.${f}`;\n          }\n        }\n        if (busAddress) {\n          let controller = controllers.find(controller => controller.busAddress === busAddress);\n          if (!controller) {\n            controller = {\n              vendor: '',\n              model: '',\n              bus: '',\n              busAddress,\n              vram: null,\n              vramDynamic: false\n            };\n            controllers.push(controller);\n          }\n          controller.vendor = device['CL_DEVICE_VENDOR'];\n          if (device['CL_DEVICE_BOARD_NAME_AMD']) {\n            controller.model = device['CL_DEVICE_BOARD_NAME_AMD'];\n          } else {\n            controller.model = device['CL_DEVICE_NAME'];\n          }\n          const memory = parseInt(device['CL_DEVICE_GLOBAL_MEM_SIZE']);\n          if (!isNaN(memory)) {\n            controller.vram = Math.round(memory / 1024 / 1024);\n          }\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function getNvidiaSmi() {\n    if (_nvidiaSmiPath) {\n      return _nvidiaSmiPath;\n    }\n\n    if (_windows) {\n      try {\n        const basePath = util.WINDIR + '\\\\System32\\\\DriverStore\\\\FileRepository';\n        // find all directories that have an nvidia-smi.exe file\n        const candidateDirs = fs.readdirSync(basePath).filter(dir => {\n          return fs.readdirSync([basePath, dir].join('/')).includes('nvidia-smi.exe');\n        });\n        // use the directory with the most recently created nvidia-smi.exe file\n        const targetDir = candidateDirs.reduce((prevDir, currentDir) => {\n          const previousNvidiaSmi = fs.statSync([basePath, prevDir, 'nvidia-smi.exe'].join('/'));\n          const currentNvidiaSmi = fs.statSync([basePath, currentDir, 'nvidia-smi.exe'].join('/'));\n          return (previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs) ? prevDir : currentDir;\n        });\n\n        if (targetDir) {\n          _nvidiaSmiPath = [basePath, targetDir, 'nvidia-smi.exe'].join('/');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else if (_linux) {\n      _nvidiaSmiPath = 'nvidia-smi';\n    }\n    return _nvidiaSmiPath;\n  }\n\n  function nvidiaSmi(options) {\n    const nvidiaSmiExe = getNvidiaSmi();\n    options = options || util.execOptsWin;\n    if (nvidiaSmiExe) {\n      const nvidiaSmiOpts = '--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits';\n      const cmd = nvidiaSmiExe + ' ' + nvidiaSmiOpts + (_linux ? '  2>/dev/null' : '');\n      try {\n        const res = execSync(cmd, options).toString();\n        return res;\n      } catch (e) {\n        util.noop();\n      }\n    }\n    return '';\n  }\n\n  function nvidiaDevices() {\n\n    function safeParseNumber(value) {\n      if ([null, undefined].includes(value)) {\n        return value;\n      }\n      return parseFloat(value);\n    }\n\n    const stdout = nvidiaSmi();\n    if (!stdout) {\n      return [];\n    }\n\n    const gpus = stdout.split('\\n').filter(Boolean);\n    let results = gpus.map(gpu => {\n      const splittedData = gpu.split(', ').map(value => value.includes('N/A') ? undefined : value);\n      if (splittedData.length === 16) {\n        return {\n          driverVersion: splittedData[0],\n          subDeviceId: splittedData[1],\n          name: splittedData[2],\n          pciBus: splittedData[3],\n          fanSpeed: safeParseNumber(splittedData[4]),\n          memoryTotal: safeParseNumber(splittedData[5]),\n          memoryUsed: safeParseNumber(splittedData[6]),\n          memoryFree: safeParseNumber(splittedData[7]),\n          utilizationGpu: safeParseNumber(splittedData[8]),\n          utilizationMemory: safeParseNumber(splittedData[9]),\n          temperatureGpu: safeParseNumber(splittedData[10]),\n          temperatureMemory: safeParseNumber(splittedData[11]),\n          powerDraw: safeParseNumber(splittedData[12]),\n          powerLimit: safeParseNumber(splittedData[13]),\n          clockCore: safeParseNumber(splittedData[14]),\n          clockMemory: safeParseNumber(splittedData[15]),\n        };\n      } else {\n        return {};\n      }\n    });\n    results = results.filter((item) => {\n      return ('pciBus' in item);\n    });\n    return results;\n  }\n\n  function mergeControllerNvidia(controller, nvidia) {\n    if (nvidia.driverVersion) { controller.driverVersion = nvidia.driverVersion; }\n    if (nvidia.subDeviceId) { controller.subDeviceId = nvidia.subDeviceId; }\n    if (nvidia.name) { controller.name = nvidia.name; }\n    if (nvidia.pciBus) { controller.pciBus = nvidia.pciBus; }\n    if (nvidia.fanSpeed) { controller.fanSpeed = nvidia.fanSpeed; }\n    if (nvidia.memoryTotal) {\n      controller.memoryTotal = nvidia.memoryTotal;\n      controller.vram = nvidia.memoryTotal;\n      controller.vramDynamic = false;\n    }\n    if (nvidia.memoryUsed) { controller.memoryUsed = nvidia.memoryUsed; }\n    if (nvidia.memoryFree) { controller.memoryFree = nvidia.memoryFree; }\n    if (nvidia.utilizationGpu) { controller.utilizationGpu = nvidia.utilizationGpu; }\n    if (nvidia.utilizationMemory) { controller.utilizationMemory = nvidia.utilizationMemory; }\n    if (nvidia.temperatureGpu) { controller.temperatureGpu = nvidia.temperatureGpu; }\n    if (nvidia.temperatureMemory) { controller.temperatureMemory = nvidia.temperatureMemory; }\n    if (nvidia.powerDraw) { controller.powerDraw = nvidia.powerDraw; }\n    if (nvidia.powerLimit) { controller.powerLimit = nvidia.powerLimit; }\n    if (nvidia.clockCore) { controller.clockCore = nvidia.clockCore; }\n    if (nvidia.clockMemory) { controller.clockMemory = nvidia.clockMemory; }\n    return controller;\n  }\n\n  function parseLinesLinuxEdid(edid) {\n    // parsen EDID\n    // --> model\n    // --> resolutionx\n    // --> resolutiony\n    // --> builtin = false\n    // --> pixeldepth (?)\n    // --> sizex\n    // --> sizey\n    let result = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    // find first \"Detailed Timing Description\"\n    let start = 108;\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    result.resolutionX = parseInt('0x0' + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));\n    result.resolutionY = parseInt('0x0' + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));\n    result.sizeX = parseInt('0x0' + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));\n    result.sizeY = parseInt('0x0' + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));\n    // monitor name\n    start = edid.indexOf('000000fc00'); // find first \"Monitor Description Data\"\n    if (start >= 0) {\n      let model_raw = edid.substr(start + 10, 26);\n      if (model_raw.indexOf('0a') !== -1) {\n        model_raw = model_raw.substr(0, model_raw.indexOf('0a'));\n      }\n      try {\n        if (model_raw.length > 2) {\n          result.model = model_raw.match(/.{1,2}/g).map(function (v) {\n            return String.fromCharCode(parseInt(v, 16));\n          }).join('');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else {\n      result.model = '';\n    }\n    return result;\n  }\n\n  function parseLinesLinuxDisplays(lines, depth) {\n    let displays = [];\n    let currentDisplay = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    let is_edid = false;\n    let is_current = false;\n    let edid_raw = '';\n    let start = 0;\n    for (let i = 1; i < lines.length; i++) {        // start with second line\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0] && lines[i].toLowerCase().indexOf(' connected ') !== -1) {        // first line of new entry\n          if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {         // push last display to array\n            displays.push(currentDisplay);\n            currentDisplay = {\n              vendor: '',\n              model: '',\n              main: false,\n              builtin: false,\n              connection: '',\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: null,\n              resolutionX: null,\n              resolutionY: null,\n              currentResX: null,\n              currentResY: null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: null\n            };\n          }\n          let parts = lines[i].split(' ');\n          currentDisplay.connection = parts[0];\n          currentDisplay.main = lines[i].toLowerCase().indexOf(' primary ') >= 0;\n          currentDisplay.builtin = (parts[0].toLowerCase().indexOf('edp') >= 0);\n        }\n\n        // try to read EDID information\n        if (is_edid) {\n          if (lines[i].search(/\\S|$/) > start) {\n            edid_raw += lines[i].toLowerCase().trim();\n          } else {\n            // parsen EDID\n            let edid_decoded = parseLinesLinuxEdid(edid_raw);\n            currentDisplay.vendor = edid_decoded.vendor;\n            currentDisplay.model = edid_decoded.model;\n            currentDisplay.resolutionX = edid_decoded.resolutionX;\n            currentDisplay.resolutionY = edid_decoded.resolutionY;\n            currentDisplay.sizeX = edid_decoded.sizeX;\n            currentDisplay.sizeY = edid_decoded.sizeY;\n            currentDisplay.pixelDepth = depth;\n            is_edid = false;\n          }\n        }\n        if (lines[i].toLowerCase().indexOf('edid:') >= 0) {\n          is_edid = true;\n          start = lines[i].search(/\\S|$/);\n        }\n        if (lines[i].toLowerCase().indexOf('*current') >= 0) {\n          const parts1 = lines[i].split('(');\n          if (parts1 && parts1.length > 1 && parts1[0].indexOf('x') >= 0) {\n            const resParts = parts1[0].trim().split('x');\n            currentDisplay.currentResX = util.toInt(resParts[0]);\n            currentDisplay.currentResY = util.toInt(resParts[1]);\n          }\n          is_current = true;\n        }\n        if (is_current && lines[i].toLowerCase().indexOf('clock') >= 0 && lines[i].toLowerCase().indexOf('hz') >= 0 && lines[i].toLowerCase().indexOf('v: height') >= 0) {\n          const parts1 = lines[i].split('clock');\n          if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf('hz') >= 0) {\n            currentDisplay.currentRefreshRate = util.toInt(parts1[1]);\n          }\n          is_current = false;\n        }\n      }\n    }\n\n    // pushen displays\n    if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {  // still information there\n      displays.push(currentDisplay);\n    }\n    return displays;\n  }\n\n  // function starts here\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        controllers: [],\n        displays: []\n      };\n      if (_darwin) {\n        let cmd = 'system_profiler -xml -detailLevel full SPDisplaysDataType';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const output = stdout.toString();\n              result = parseLinesDarwin(util.plistParser(output)[0]._items);\n            } catch (e) {\n              util.noop();\n            }\n            stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo \"\"');\n            const output = (stdout || '').toString();\n            const obj = util.plistReader(output);\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets']['Configs'] && obj['DisplayAnyUserSets']['Configs'][0] && obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig']) {\n              const current = obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig'];\n              let i = 0;\n              current.forEach((o) => {\n                if (o['CurrentInfo'] && 'OriginX' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['CurrentInfo']['OriginX'];\n                }\n                if (o['CurrentInfo'] && 'OriginY' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['CurrentInfo']['OriginY'];\n                }\n                i++;\n              });\n            }\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets'].length > 0 && obj['DisplayAnyUserSets'][0].length > 0 && obj['DisplayAnyUserSets'][0][0]['DisplayID']) {\n              const current = obj['DisplayAnyUserSets'][0];\n              let i = 0;\n              current.forEach((o) => {\n                if ('OriginX' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['OriginX'];\n                }\n                if ('OriginY' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['OriginY'];\n                }\n                if (o['Mode'] && 'BitsPerPixel' in o['Mode'] && result.displays && result.displays[i]) {\n                  result.displays[i].pixelDepth = o['Mode']['BitsPerPixel'];\n                }\n                i++;\n              });\n            }\n\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        // Raspberry: https://elinux.org/RPI_vcgencmd_usage\n        if (util.isRaspberry() && util.isRaspbian()) {\n          let cmd = 'fbset -s | grep \\'mode \"\\'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;';\n          exec(cmd, function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 3 && lines[0].indexOf('mode \"') >= -1 && lines[2].indexOf('0x12000a') > -1) {\n              const parts = lines[0].replace('mode', '').replace(/\"/g, '').trim().split('x');\n              if (parts.length === 2) {\n                result.displays.push({\n                  vendor: '',\n                  model: util.getValue(lines, 'device_name', '='),\n                  main: true,\n                  builtin: false,\n                  connection: 'HDMI',\n                  sizeX: null,\n                  sizeY: null,\n                  pixelDepth: null,\n                  resolutionX: parseInt(parts[0], 10),\n                  resolutionY: parseInt(parts[1], 10),\n                  currentResX: null,\n                  currentResY: null,\n                  positionX: 0,\n                  positionY: 0,\n                  currentRefreshRate: null\n                });\n              }\n            }\n            if (lines.length > 1 && stdout.toString().indexOf('gpu=') >= -1) {\n              result.controllers.push({\n                vendor: 'Broadcom',\n                model: 'VideoCore IV',\n                bus: '',\n                vram: util.getValue(lines, 'gpu', '=').replace('M', ''),\n                vramDynamic: true\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } else {\n          let cmd = 'lspci -vvv  2>/dev/null';\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              result.controllers = parseLinesLinuxControllers(lines);\n              const nvidiaData = nvidiaDevices();\n              // needs to be rewritten ... using no spread operators\n              result.controllers = result.controllers.map((controller) => { // match by busAddress\n                return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});\n              });\n            }\n            let cmd = 'clinfo --raw';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.controllers = parseLinesLinuxClinfo(result.controllers, lines);\n              }\n              let cmd = 'xdpyinfo 2>/dev/null | grep \\'depth of root window\\' | awk \\'{ print $5 }\\'';\n              exec(cmd, function (error, stdout) {\n                let depth = 0;\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  depth = parseInt(lines[0]) || 0;\n                }\n                let cmd = 'xrandr --verbose 2>/dev/null';\n                exec(cmd, function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    result.displays = parseLinesLinuxDisplays(lines, depth);\n                  }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                });\n              });\n            });\n          });\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n\n        // https://blogs.technet.microsoft.com/heyscriptingguy/2013/10/03/use-powershell-to-discover-multi-monitor-information/\n        // https://devblogs.microsoft.com/scripting/use-powershell-to-discover-multi-monitor-information/\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance win32_VideoController | fl *'));\n          workload.push(util.powerShell('gp \"HKLM:\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\*\" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));\n          workload.push(util.powerShell('Get-CimInstance win32_desktopmonitor | fl *'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorBasicDisplayParams | fl'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorConnectionParams | fl'));\n          workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + $_.InstanceName}'));\n\n          const nvidiaData = nvidiaDevices();\n\n          Promise.all(\n            workload\n          ).then((data) => {\n            // controller + vram\n            let csections = data[0].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            let vsections = data[1].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            result.controllers = parseLinesWindowsControllers(csections, vsections);\n            result.controllers = result.controllers.map((controller) => { // match by subDeviceId\n              if (controller.vendor.toLowerCase() === 'nvidia') {\n                return mergeControllerNvidia(controller, nvidiaData.find(device => {\n                  let windowsSubDeviceId = (controller.subDeviceId || '').toLowerCase();\n                  const nvidiaSubDeviceIdParts = device.subDeviceId.split('x');\n                  let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();\n                  const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);\n                  if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      nvidiaSubDeviceId = '0' + nvidiaSubDeviceId;\n                    }\n                  } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      windowsSubDeviceId = '0' + windowsSubDeviceId;\n                    }\n                  }\n                  return windowsSubDeviceId === nvidiaSubDeviceId;\n                }) || {});\n              } else {\n                return controller;\n              }\n            });\n\n            // displays\n            let dsections = data[2].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            // result.displays = parseLinesWindowsDisplays(dsections);\n            if (dsections[0].trim() === '') { dsections.shift(); }\n            if (dsections.length && dsections[dsections.length - 1].trim() === '') { dsections.pop(); }\n\n            // monitor (powershell)\n            let msections = data[3].replace(/\\r/g, '').split('Active ');\n            msections.shift();\n\n            // forms.screens (powershell)\n            let ssections = data[4].replace(/\\r/g, '').split('BitsPerPixel ');\n            ssections.shift();\n\n            // connection params (powershell) - video type\n            let tsections = data[5].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            tsections.shift();\n\n            // monitor ID (powershell) - model / vendor\n            const res = data[6].replace(/\\r/g, '').split(/\\n/);\n            let isections = [];\n            res.forEach(element => {\n              const parts = element.split('|');\n              if (parts.length === 5) {\n                isections.push({\n                  vendor: parts[0],\n                  code: parts[1],\n                  model: parts[2],\n                  serial: parts[3],\n                  instanceId: parts[4]\n                });\n              }\n            });\n\n            result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);\n\n            if (result.displays.length === 1) {\n              if (_resolutionX) {\n                result.displays[0].resolutionX = _resolutionX;\n                if (!result.displays[0].currentResX) {\n                  result.displays[0].currentResX = _resolutionX;\n                }\n              }\n              if (_resolutionY) {\n                result.displays[0].resolutionY = _resolutionY;\n                if (result.displays[0].currentResY === 0) {\n                  result.displays[0].currentResY = _resolutionY;\n                }\n              }\n              if (_pixelDepth) {\n                result.displays[0].pixelDepth = _pixelDepth;\n              }\n            }\n            result.displays = result.displays.map(element => {\n              if (_refreshRate && !element.currentRefreshRate) {\n                element.currentRefreshRate = _refreshRate;\n              }\n              return element;\n            });\n\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          })\n            .catch(() => {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n\n  function parseLinesWindowsControllers(sections, vections) {\n    const memorySizes = {};\n    for (const i in vections) {\n      if ({}.hasOwnProperty.call(vections, i)) {\n        if (vections[i].trim() !== '') {\n          const lines = vections[i].trim().split('\\n');\n          const matchingDeviceId = util.getValue(lines, 'MatchingDeviceId').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          if (matchingDeviceId) {\n            const quadWordmemorySize = parseInt(util.getValue(lines, 'HardwareInformation.qwMemorySize'));\n            if (!isNaN(quadWordmemorySize)) {\n              let deviceId = matchingDeviceId[1].toUpperCase() + '&' + matchingDeviceId[2].toUpperCase();\n              if (matchingDeviceId[3]) {\n                deviceId += '&' + matchingDeviceId[3].toUpperCase();\n              }\n              if (matchingDeviceId[4]) {\n                deviceId += '&' + matchingDeviceId[4].toUpperCase();\n              }\n              memorySizes[deviceId] = quadWordmemorySize;\n            }\n          }\n        }\n      }\n    }\n\n    let controllers = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\n');\n          let pnpDeviceId = util.getValue(lines, 'PNPDeviceID', ':').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          let subDeviceId = null;\n          let memorySize = null;\n          if (pnpDeviceId) {\n            subDeviceId = pnpDeviceId[3] || '';\n            if (subDeviceId) {\n              subDeviceId = subDeviceId.split('_')[1];\n            }\n\n            // Match PCI device identifier (there's an order of increasing generality):\n            // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/identifiers-for-pci-devices\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)\n            if (memorySize == null && pnpDeviceId[3]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)\n            if (memorySize == null) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n          }\n\n          controllers.push({\n            vendor: util.getValue(lines, 'AdapterCompatibility', ':'),\n            model: util.getValue(lines, 'name', ':'),\n            bus: util.getValue(lines, 'PNPDeviceID', ':').startsWith('PCI') ? 'PCI' : '',\n            vram: (memorySize == null ? util.toInt(util.getValue(lines, 'AdapterRAM', ':')) : memorySize) / 1024 / 1024,\n            vramDynamic: (util.getValue(lines, 'VideoMemoryType', ':') === '2'),\n            subDeviceId\n          });\n          _resolutionX = util.toInt(util.getValue(lines, 'CurrentHorizontalResolution', ':')) || _resolutionX;\n          _resolutionY = util.toInt(util.getValue(lines, 'CurrentVerticalResolution', ':')) || _resolutionY;\n          _refreshRate = util.toInt(util.getValue(lines, 'CurrentRefreshRate', ':')) || _refreshRate;\n          _pixelDepth = util.toInt(util.getValue(lines, 'CurrentBitsPerPixel', ':')) || _pixelDepth;\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {\n    let displays = [];\n    let vendor = '';\n    let model = '';\n    let deviceID = '';\n    let resolutionX = 0;\n    let resolutionY = 0;\n    if (dsections && dsections.length) {\n      let linesDisplay = dsections[0].split('\\n');\n      vendor = util.getValue(linesDisplay, 'MonitorManufacturer', ':');\n      model = util.getValue(linesDisplay, 'Name', ':');\n      deviceID = util.getValue(linesDisplay, 'PNPDeviceID', ':').replace(/&amp;/g, '&').toLowerCase();\n      resolutionX = util.toInt(util.getValue(linesDisplay, 'ScreenWidth', ':'));\n      resolutionY = util.toInt(util.getValue(linesDisplay, 'ScreenHeight', ':'));\n    }\n    for (let i = 0; i < ssections.length; i++) {\n      if (ssections[i].trim() !== '') {\n        ssections[i] = 'BitsPerPixel ' + ssections[i];\n        msections[i] = 'Active ' + msections[i];\n        // tsections can be empty OR undefined on earlier versions of powershell (<=2.0)\n        // Tag connection type as UNKNOWN by default if this information is missing\n        if (tsections.length === 0 || tsections[i] === undefined) {\n          tsections[i] = 'Unknown';\n        }\n        let linesScreen = ssections[i].split('\\n');\n        let linesMonitor = msections[i].split('\\n');\n\n        let linesConnection = tsections[i].split('\\n');\n        const bitsPerPixel = util.getValue(linesScreen, 'BitsPerPixel');\n        const bounds = util.getValue(linesScreen, 'Bounds').replace('{', '').replace('}', '').replace(/=/g, ':').split(',');\n        const primary = util.getValue(linesScreen, 'Primary');\n        const sizeX = util.getValue(linesMonitor, 'MaxHorizontalImageSize');\n        const sizeY = util.getValue(linesMonitor, 'MaxVerticalImageSize');\n        const instanceName = util.getValue(linesMonitor, 'InstanceName').toLowerCase();\n        const videoOutputTechnology = util.getValue(linesConnection, 'VideoOutputTechnology');\n        const deviceName = util.getValue(linesScreen, 'DeviceName');\n        let displayVendor = '';\n        let displayModel = '';\n        isections.forEach(element => {\n          if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith('(') && model.startsWith('PnP')) {\n            displayVendor = element.vendor;\n            displayModel = element.model;\n          }\n        });\n        displays.push({\n          vendor: instanceName.startsWith(deviceID) && displayVendor === '' ? vendor : displayVendor,\n          model: instanceName.startsWith(deviceID) && displayModel === '' ? model : displayModel,\n          deviceName,\n          main: primary.toLowerCase() === 'true',\n          builtin: videoOutputTechnology === '2147483648',\n          connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : '',\n          resolutionX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          resolutionY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          sizeX: sizeX ? parseInt(sizeX, 10) : null,\n          sizeY: sizeY ? parseInt(sizeY, 10) : null,\n          pixelDepth: bitsPerPixel,\n          currentResX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          currentResY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          positionX: util.toInt(util.getValue(bounds, 'X', ':')),\n          positionY: util.toInt(util.getValue(bounds, 'Y', ':')),\n        });\n      }\n    }\n    if (ssections.length === 0) {\n      displays.push({\n        vendor,\n        model,\n        main: true,\n        sizeX: null,\n        sizeY: null,\n        resolutionX,\n        resolutionY,\n        pixelDepth: null,\n        currentResX: resolutionX,\n        currentResY: resolutionY,\n        positionX: 0,\n        positionY: 0\n      });\n    }\n    return displays;\n  }\n}\n\nexports.graphics = graphics;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// index.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// Contributors:  Guillaume Legrain (https://github.com/glegrain)\n//                Riccardo Novaglia (https://github.com/richy24)\n//                Quentin Busuttil (https://github.com/Buzut)\n//                Lapsio (https://github.com/lapsio)\n//                csy (https://github.com/csy1983)\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n\n// ----------------------------------------------------------------------------------\n// Dependencies\n// ----------------------------------------------------------------------------------\n\nconst lib_version = require('../package.json').version;\nconst util = require('./util');\nconst system = require('./system');\nconst osInfo = require('./osinfo');\nconst cpu = require('./cpu');\nconst memory = require('./memory');\nconst battery = require('./battery');\nconst graphics = require('./graphics');\nconst filesystem = require('./filesystem');\nconst network = require('./network');\nconst wifi = require('./wifi');\nconst processes = require('./processes');\nconst users = require('./users');\nconst internet = require('./internet');\nconst docker = require('./docker');\nconst vbox = require('./virtualbox');\nconst printer = require('./printer');\nconst usb = require('./usb');\nconst audio = require('./audio');\nconst bluetooth = require('./bluetooth');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// ----------------------------------------------------------------------------------\n// init\n// ----------------------------------------------------------------------------------\n\nif (_windows) {\n  util.getCodepage();\n}\n\n// ----------------------------------------------------------------------------------\n// General\n// ----------------------------------------------------------------------------------\n\nfunction version() {\n  return lib_version;\n}\n\n// ----------------------------------------------------------------------------------\n// Get static and dynamic data (all)\n// ----------------------------------------------------------------------------------\n\n// --------------------------\n// get static data - they should not change until restarted\n\nfunction getStaticData(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let data = {};\n\n      data.version = version();\n\n      Promise.all([\n        system.system(),\n        system.bios(),\n        system.baseboard(),\n        system.chassis(),\n        osInfo.osInfo(),\n        osInfo.uuid(),\n        osInfo.versions(),\n        cpu.cpu(),\n        cpu.cpuFlags(),\n        graphics.graphics(),\n        network.networkInterfaces(),\n        memory.memLayout(),\n        filesystem.diskLayout()\n      ]).then((res) => {\n        data.system = res[0];\n        data.bios = res[1];\n        data.baseboard = res[2];\n        data.chassis = res[3];\n        data.os = res[4];\n        data.uuid = res[5];\n        data.versions = res[6];\n        data.cpu = res[7];\n        data.cpu.flags = res[8];\n        data.graphics = res[9];\n        data.net = res[10];\n        data.memLayout = res[11];\n        data.diskLayout = res[12];\n        if (callback) { callback(data); }\n        resolve(data);\n      });\n    });\n  });\n}\n\n\n// --------------------------\n// get all dynamic data - e.g. for monitoring agents\n// may take some seconds to get all data\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getDynamicData(srv, iface, callback) {\n\n  if (util.isFunction(iface)) {\n    callback = iface;\n    iface = '';\n  }\n  if (util.isFunction(srv)) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      iface = iface || network.getDefaultNetworkInterface();\n      srv = srv || '';\n\n      // use closure to track  completion\n      let functionProcessed = (function () {\n        let totalFunctions = 15;\n        if (_windows) { totalFunctions = 13; }\n        if (_freebsd || _openbsd || _netbsd) { totalFunctions = 11; }\n        if (_sunos) { totalFunctions = 6; }\n\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          }\n        };\n      })();\n\n      let data = {};\n\n      // get time\n      data.time = osInfo.time();\n\n      /**\n       * @namespace\n       * @property {Object}  versions\n       * @property {string}  versions.node\n       * @property {string}  versions.v8\n       */\n      data.node = process.versions.node;\n      data.v8 = process.versions.v8;\n\n      cpu.cpuCurrentSpeed().then((res) => {\n        data.cpuCurrentSpeed = res;\n        functionProcessed();\n      });\n\n      users.users().then((res) => {\n        data.users = res;\n        functionProcessed();\n      });\n\n      processes.processes().then((res) => {\n        data.processes = res;\n        functionProcessed();\n      });\n\n      cpu.currentLoad().then((res) => {\n        data.currentLoad = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        cpu.cpuTemperature().then((res) => {\n          data.temp = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        network.networkStats(iface).then((res) => {\n          data.networkStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        network.networkConnections().then((res) => {\n          data.networkConnections = res;\n          functionProcessed();\n        });\n      }\n\n      memory.mem().then((res) => {\n        data.mem = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        battery().then((res) => {\n          data.battery = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        processes.services(srv).then((res) => {\n          data.services = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        filesystem.fsSize().then((res) => {\n          data.fsSize = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.fsStats().then((res) => {\n          data.fsStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.disksIO().then((res) => {\n          data.disksIO = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        wifi.wifiNetworks().then((res) => {\n          data.wifiNetworks = res;\n          functionProcessed();\n        });\n      }\n\n      internet.inetLatency().then((res) => {\n        data.inetLatency = res;\n        functionProcessed();\n      });\n    });\n  });\n}\n\n// --------------------------\n// get all data at once\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getAllData(srv, iface, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = {};\n\n      if (iface && util.isFunction(iface) && !callback) {\n        callback = iface;\n        iface = '';\n      }\n\n      if (srv && util.isFunction(srv) && !iface && !callback) {\n        callback = srv;\n        srv = '';\n        iface = '';\n      }\n\n      getStaticData().then((res) => {\n        data = res;\n        getDynamicData(srv, iface).then((res) => {\n          for (let key in res) {\n            if ({}.hasOwnProperty.call(res, key)) {\n              data[key] = res[key];\n            }\n          }\n          if (callback) { callback(data); }\n          resolve(data);\n        });\n      });\n    });\n  });\n}\n\nfunction get(valueObject, callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const allPromises = Object.keys(valueObject)\n        .filter(func => ({}.hasOwnProperty.call(exports, func)))\n        .map(func => {\n          const params = valueObject[func].substring(valueObject[func].lastIndexOf('(') + 1, valueObject[func].lastIndexOf(')'));\n          let funcWithoutParams = func.indexOf(')') >= 0 ? func.split(')')[1].trim() : func;\n          funcWithoutParams = func.indexOf('|') >= 0 ? func.split('|')[0].trim() : funcWithoutParams;\n          if (params) {\n            return exports[funcWithoutParams](params);\n          } else {\n            return exports[funcWithoutParams]('');\n          }\n        });\n\n      Promise.all(allPromises).then((data) => {\n        const result = {};\n        let i = 0;\n        for (let key in valueObject) {\n          if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {\n            if (valueObject[key] === '*' || valueObject[key] === 'all') {\n              result[key] = data[i];\n            } else {\n              let keys = valueObject[key];\n              let filter = '';\n              let filterParts = [];\n              // remove params\n              if (keys.indexOf(')') >= 0) {\n                keys = keys.split(')')[1].trim();\n              }\n              // extract filter and remove it from keys\n              if (keys.indexOf('|') >= 0) {\n                filter = keys.split('|')[1].trim();\n                filterParts = filter.split(':');\n\n                keys = keys.split('|')[0].trim();\n              }\n              keys = keys.replace(/,/g, ' ').replace(/ +/g, ' ').split(' ');\n              if (data[i]) {\n                if (Array.isArray(data[i])) {\n                  // result is in an array, go through all elements of array and pick only the right ones\n                  const partialArray = [];\n                  data[i].forEach(element => {\n                    let partialRes = {};\n                    if (keys.length === 1 && (keys[0] === '*' || keys[0] === 'all')) {\n                      partialRes = element;\n                    } else {\n                      keys.forEach(k => {\n                        if ({}.hasOwnProperty.call(element, k)) {\n                          partialRes[k] = element[k];\n                        }\n                      });\n                    }\n                    // if there is a filter, then just take those elements\n                    if (filter && filterParts.length === 2) {\n                      if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {\n                        const val = partialRes[filterParts[0].trim()];\n                        if (typeof val == 'number') {\n                          if (val === parseFloat(filterParts[1].trim())) {\n                            partialArray.push(partialRes);\n                          }\n                        } else if (typeof val == 'string') {\n                          if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {\n                            partialArray.push(partialRes);\n                          }\n                        }\n                      }\n                    } else {\n                      partialArray.push(partialRes);\n                    }\n\n                  });\n                  result[key] = partialArray;\n                } else {\n                  const partialRes = {};\n                  keys.forEach(k => {\n                    if ({}.hasOwnProperty.call(data[i], k)) {\n                      partialRes[k] = data[i][k];\n                    }\n                  });\n                  result[key] = partialRes;\n                }\n              } else {\n                result[key] = {};\n              }\n            }\n            i++;\n          }\n        }\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nfunction observe(valueObject, interval, callback) {\n  let _data = null;\n\n  const result = setInterval(() => {\n    get(valueObject).then((data) => {\n      if (JSON.stringify(_data) !== JSON.stringify(data)) {\n        _data = Object.assign({}, data);\n        callback(data);\n      }\n    });\n  }, interval);\n  return result;\n}\n\n// ----------------------------------------------------------------------------------\n// export all libs\n// ----------------------------------------------------------------------------------\n\nexports.version = version;\nexports.system = system.system;\nexports.bios = system.bios;\nexports.baseboard = system.baseboard;\nexports.chassis = system.chassis;\n\nexports.time = osInfo.time;\nexports.osInfo = osInfo.osInfo;\nexports.versions = osInfo.versions;\nexports.shell = osInfo.shell;\nexports.uuid = osInfo.uuid;\n\nexports.cpu = cpu.cpu;\nexports.cpuFlags = cpu.cpuFlags;\nexports.cpuCache = cpu.cpuCache;\nexports.cpuCurrentSpeed = cpu.cpuCurrentSpeed;\nexports.cpuTemperature = cpu.cpuTemperature;\nexports.currentLoad = cpu.currentLoad;\nexports.fullLoad = cpu.fullLoad;\n\nexports.mem = memory.mem;\nexports.memLayout = memory.memLayout;\n\nexports.battery = battery;\n\nexports.graphics = graphics.graphics;\n\nexports.fsSize = filesystem.fsSize;\nexports.fsOpenFiles = filesystem.fsOpenFiles;\nexports.blockDevices = filesystem.blockDevices;\nexports.fsStats = filesystem.fsStats;\nexports.disksIO = filesystem.disksIO;\nexports.diskLayout = filesystem.diskLayout;\n\nexports.networkInterfaceDefault = network.networkInterfaceDefault;\nexports.networkGatewayDefault = network.networkGatewayDefault;\nexports.networkInterfaces = network.networkInterfaces;\nexports.networkStats = network.networkStats;\nexports.networkConnections = network.networkConnections;\n\nexports.wifiNetworks = wifi.wifiNetworks;\nexports.wifiInterfaces = wifi.wifiInterfaces;\nexports.wifiConnections = wifi.wifiConnections;\n\nexports.services = processes.services;\nexports.processes = processes.processes;\nexports.processLoad = processes.processLoad;\n\nexports.users = users.users;\n\nexports.inetChecksite = internet.inetChecksite;\nexports.inetLatency = internet.inetLatency;\n\nexports.dockerInfo = docker.dockerInfo;\nexports.dockerImages = docker.dockerImages;\nexports.dockerContainers = docker.dockerContainers;\nexports.dockerContainerStats = docker.dockerContainerStats;\nexports.dockerContainerProcesses = docker.dockerContainerProcesses;\nexports.dockerVolumes = docker.dockerVolumes;\nexports.dockerAll = docker.dockerAll;\n\nexports.vboxInfo = vbox.vboxInfo;\n\nexports.printer = printer.printer;\n\nexports.usb = usb.usb;\n\nexports.audio = audio.audio;\nexports.bluetoothDevices = bluetooth.bluetoothDevices;\n\nexports.getStaticData = getStaticData;\nexports.getDynamicData = getDynamicData;\nexports.getAllData = getAllData;\nexports.get = get;\nexports.observe = observe;\n\nexports.powerShellStart = util.powerShellStart;\nexports.powerShellRelease = util.powerShellRelease;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\n// const exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: null\n      };\n      if (typeof url !== 'string') {\n        if (callback) { callback(result); }\n        return resolve(result);\n      }\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url, true);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      result.url = urlSanitized;\n      try {\n        if (urlSanitized && !util.isPrototypePolluted()) {\n          urlSanitized.__proto__.startsWith = util.stringStartWith;\n          if (urlSanitized.startsWith('file:') || urlSanitized.startsWith('gopher:') || urlSanitized.startsWith('telnet:') || urlSanitized.startsWith('mailto:') || urlSanitized.startsWith('news:') || urlSanitized.startsWith('nntp:')) {\n            if (callback) { callback(result); }\n            return resolve(result);\n          }\n          let t = Date.now();\n          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n            let args = ['-I', '--connect-timeout', '5', '-m', '5'];\n            args.push(urlSanitized);\n            let cmd = 'curl';\n            util.execSafe(cmd, args).then((stdout) => {\n              const lines = stdout.split('\\n');\n              let statusCode = lines[0] && lines[0].indexOf(' ') >= 0 ? parseInt(lines[0].split(' ')[1], 10) : 404;\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n              result.ms = (result.ok ? Date.now() - t : null);\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          }\n          if (_windows) {   // if this is stable, this can be used for all OS types\n            const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n            try {\n              http.get(urlSanitized, (res) => {\n                const statusCode = res.statusCode;\n\n                result.status = statusCode || 404;\n                result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n                if (statusCode !== 200) {\n                  res.resume();\n                  result.ms = (result.ok ? Date.now() - t : null);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  res.on('data', () => { });\n                  res.on('end', () => {\n                    result.ms = (result.ok ? Date.now() - t : null);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              }).on('error', () => {\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } catch (err) {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } catch (err) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof host !== 'string') {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let hostSanitized = '';\n      const s = (util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host, true)).trim();\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1]) {\n            hostSanitized = hostSanitized + sl[0];\n          }\n        }\n      }\n      hostSanitized.__proto__.startsWith = util.stringStartWith;\n      if (hostSanitized.startsWith('file:') || hostSanitized.startsWith('gopher:') || hostSanitized.startsWith('telnet:') || hostSanitized.startsWith('mailto:') || hostSanitized.startsWith('news:') || hostSanitized.startsWith('nntp:')) {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let params;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          params = ['-c', '2', '-w', '3', hostSanitized];\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          params = ['-c', '2', '-t', '3', hostSanitized];\n        }\n        if (_darwin) {\n          params = ['-c2', '-t3', hostSanitized];\n        }\n        util.execSafe('ping', params).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter((line) => (line.indexOf('rtt') >= 0 || line.indexOf('round-trip') >= 0 || line.indexOf('avg') >= 0)).join('\\n');\n\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        const params = ['-s', '-a', hostSanitized, '56', '2'];\n        const filt = 'avg';\n        util.execSafe('ping', params, { timeout: 3000 }).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = null;\n        try {\n          const params = [hostSanitized, '-n', '1'];\n          util.execSafe('ping', params, util.execOptsWin).then((stdout) => {\n            if (stdout) {\n              let lines = stdout.split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// memory.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 5. Memory\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst OSX_RAM_manufacturers = {\n  '0x014F': 'Transcend Information',\n  '0x2C00': 'Micron Technology Inc.',\n  '0x802C': 'Micron Technology Inc.',\n  '0x80AD': 'Hynix Semiconductor Inc.',\n  '0x80CE': 'Samsung Electronics Inc.',\n  '0xAD00': 'Hynix Semiconductor Inc.',\n  '0xCE00': 'Samsung Electronics Inc.',\n  '0x02FE': 'Elpida',\n  '0x5105': 'Qimonda AG i. In.',\n  '0x8551': 'Qimonda AG i. In.',\n  '0x859B': 'Crucial',\n  '0x04CD': 'G-Skill'\n};\n\nconst LINUX_RAM_manufacturers = {\n  '017A': 'Apacer',\n  '0198': 'HyperX',\n  '029E': 'Corsair',\n  '04CB': 'A-DATA',\n  '04CD': 'G-Skill',\n  '059B': 'Crucial',\n  '00CE': 'Samsung',\n  '1315': 'Crutial',\n  '014F': 'Transcend Information',\n  '2C00': 'Micron Technology Inc.',\n  '802C': 'Micron Technology Inc.',\n  '80AD': 'Hynix Semiconductor Inc.',\n  '80CE': 'Samsung Electronics Inc.',\n  'AD00': 'Hynix Semiconductor Inc.',\n  'CE00': 'Samsung Electronics Inc.',\n  '02FE': 'Elpida',\n  '5105': 'Qimonda AG i. In.',\n  '8551': 'Qimonda AG i. In.',\n  '859B': 'Crucial'\n};\n\n// _______________________________________________________________________________________\n// |                         R A M                              |          H D           |\n// |______________________|_________________________|           |                        |\n// |        active             buffers/cache        |           |                        |\n// |________________________________________________|___________|_________|______________|\n// |                     used                            free   |   used       free      |\n// |____________________________________________________________|________________________|\n// |                        total                               |          swap          |\n// |____________________________________________________________|________________________|\n\n// free (older versions)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers     cached\n// Mem:         16038 (1)   15653 (2)   384 (3)  0 (4)     236 (5)     14788 (6)\n// -/+ buffers/cache:       628 (7)     15409 (8)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// | active (2-(5+6) = 7) |  available (3+5+6 = 8)              |\n// |______________________|_________________________|___________|\n// |        active        |  buffers/cache (5+6)    |           |\n// |________________________________________________|___________|\n// |                   used (2)                     | free (3)  |\n// |____________________________________________________________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n\n//\n// free (since free von procps-ng 3.3.10)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers/cache   available\n// Mem:         16038 (1)   628 (2)     386 (3)  0 (4)     15024 (5)     14788 (6)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// |                      |      available (6) estimated        |\n// |______________________|_________________________|___________|\n// |     active (2)       |   buffers/cache (5)     | free (3)  |\n// |________________________________________________|___________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n//\n// Reference: http://www.software-architect.net/blog/article/date/2015/06/12/-826c6e5052.html\n\n// /procs/meminfo - sample (all in kB)\n//\n// MemTotal: 32806380 kB\n// MemFree: 17977744 kB\n// MemAvailable: 19768972 kB\n// Buffers: 517028 kB\n// Cached: 2161876 kB\n// SwapCached: 456 kB\n// Active: 12081176 kB\n// Inactive: 2164616 kB\n// Active(anon): 10832884 kB\n// Inactive(anon): 1477272 kB\n// Active(file): 1248292 kB\n// Inactive(file): 687344 kB\n// Unevictable: 0 kB\n// Mlocked: 0 kB\n// SwapTotal: 16768892 kB\n// SwapFree: 16768304 kB\n// Dirty: 268 kB\n// Writeback: 0 kB\n// AnonPages: 11568832 kB\n// Mapped: 719992 kB\n// Shmem: 743272 kB\n// Slab: 335716 kB\n// SReclaimable: 256364 kB\n// SUnreclaim: 79352 kB\n\nfunction mem(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        total: os.totalmem(),\n        free: os.freemem(),\n        used: os.totalmem() - os.freemem(),\n\n        active: os.totalmem() - os.freemem(),     // temporarily (fallback)\n        available: os.freemem(),                  // temporarily (fallback)\n        buffers: 0,\n        cached: 0,\n        slab: 0,\n        buffcache: 0,\n\n        swaptotal: 0,\n        swapused: 0,\n        swapfree: 0\n      };\n\n      if (_linux) {\n        fs.readFile('/proc/meminfo', function (error, stdout) {\n          if (!error) {\n            const lines = stdout.toString().split('\\n');\n            result.total = parseInt(util.getValue(lines, 'memtotal'), 10);\n            result.total = result.total ? result.total * 1024 : os.totalmem();\n            result.free = parseInt(util.getValue(lines, 'memfree'), 10);\n            result.free = result.free ? result.free * 1024 : os.freemem();\n            result.used = result.total - result.free;\n\n            result.buffers = parseInt(util.getValue(lines, 'buffers'), 10);\n            result.buffers = result.buffers ? result.buffers * 1024 : 0;\n            result.cached = parseInt(util.getValue(lines, 'cached'), 10);\n            result.cached = result.cached ? result.cached * 1024 : 0;\n            result.slab = parseInt(util.getValue(lines, 'slab'), 10);\n            result.slab = result.slab ? result.slab * 1024 : 0;\n            result.buffcache = result.buffers + result.cached + result.slab;\n\n            let available = parseInt(util.getValue(lines, 'memavailable'), 10);\n            result.available = available ? available * 1024 : result.free + result.buffcache;\n            result.active = result.total - result.available;\n\n            result.swaptotal = parseInt(util.getValue(lines, 'swaptotal'), 10);\n            result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;\n            result.swapfree = parseInt(util.getValue(lines, 'swapfree'), 10);\n            result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;\n            result.swapused = result.swaptotal - result.swapfree;\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            const pagesize = parseInt(util.getValue(lines, 'vm.stats.vm.v_page_size'), 10);\n            const inactive = parseInt(util.getValue(lines, 'vm.stats.vm.v_inactive_count'), 10) * pagesize;\n            const cache = parseInt(util.getValue(lines, 'vm.stats.vm.v_cache_count'), 10) * pagesize;\n\n            result.total = parseInt(util.getValue(lines, 'hw.realmem'), 10);\n            if (isNaN(result.total)) { result.total = parseInt(util.getValue(lines, 'hw.physmem'), 10); }\n            result.free = parseInt(util.getValue(lines, 'vm.stats.vm.v_free_count'), 10) * pagesize;\n            result.buffcache = inactive + cache;\n            result.available = result.buffcache + result.free;\n            result.active = result.total - result.free - result.buffcache;\n\n            result.swaptotal = 0;\n            result.swapfree = 0;\n            result.swapused = 0;\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        let pageSize = 4096;\n        try {\n          let sysPpageSize = util.toInt(execSync('sysctl -n vm.pagesize').toString());\n          pageSize = sysPpageSize || pageSize;\n        } catch (e) {\n          util.noop();\n        }\n        exec('vm_stat 2>/dev/null | grep \"Pages active\"', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            result.active = parseInt(lines[0].split(':')[1], 10) * pageSize;\n            result.buffcache = result.used - result.active;\n            result.available = result.free + result.buffcache;\n          }\n          exec('sysctl -n vm.swapusage 2>/dev/null', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              if (lines.length > 0) {\n                let firstline = lines[0].replace(/,/g, '.').replace(/M/g, '');\n                let lineArray = firstline.trim().split('  ');\n                lineArray.forEach(line => {\n                  if (line.toLowerCase().indexOf('total') !== -1) { result.swaptotal = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('used') !== -1) { result.swapused = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('free') !== -1) { result.swapfree = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                });\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      }\n      if (_windows) {\n        let swaptotal = 0;\n        let swapused = 0;\n        try {\n          util.powerShell('Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(/\\s\\s+/);\n                  swaptotal = swaptotal + (parseInt(line[0], 10) || 0);\n                  swapused = swapused + (parseInt(line[1], 10) || 0);\n                }\n              });\n            }\n            result.swaptotal = swaptotal * 1024 * 1024;\n            result.swapused = swapused * 1024 * 1024;\n            result.swapfree = result.swaptotal - result.swapused;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.mem = mem;\n\nfunction memLayout(callback) {\n\n  function getManufacturerDarwin(manId) {\n    if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {\n      return (OSX_RAM_manufacturers[manId]);\n    }\n    return manId;\n  }\n\n  function getManufacturerLinux(manId) {\n    const manIdSearch = manId.replace('0x', '').toUpperCase();\n    if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {\n      return (LINUX_RAM_manufacturers[manIdSearch]);\n    }\n    return manId;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = [];\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE \"Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number\"; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            let devices = stdout.toString().split('Memory Device');\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const sizeString = util.getValue(lines, 'Size');\n              const size = sizeString.indexOf('GB') >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;\n              let bank = util.getValue(lines, 'Bank Locator');\n              if (bank.toLowerCase().indexOf('bad') >= 0) {\n                bank = '';\n              }\n              if (parseInt(util.getValue(lines, 'Size'), 10) > 0) {\n                const totalWidth = util.toInt(util.getValue(lines, 'Total Width'));\n                const dataWidth = util.toInt(util.getValue(lines, 'Data Width'));\n                result.push({\n                  size,\n                  bank,\n                  type: util.getValue(lines, 'Type:'),\n                  ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                  clockSpeed: (util.getValue(lines, 'Configured Clock Speed:') ? parseInt(util.getValue(lines, 'Configured Clock Speed:'), 10) : (util.getValue(lines, 'Speed:') ? parseInt(util.getValue(lines, 'Speed:'), 10) : null)),\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  manufacturer: getManufacturerLinux(util.getValue(lines, 'Manufacturer:')),\n                  partNum: util.getValue(lines, 'Part Number:'),\n                  serialNum: util.getValue(lines, 'Serial Number:'),\n                  voltageConfigured: parseFloat(util.getValue(lines, 'Configured Voltage:')) || null,\n                  voltageMin: parseFloat(util.getValue(lines, 'Minimum Voltage:')) || null,\n                  voltageMax: parseFloat(util.getValue(lines, 'Maximum Voltage:')) || null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            result.push({\n              size: os.totalmem(),\n              bank: '',\n              type: '',\n              ecc: null,\n              clockSpeed: 0,\n              formFactor: '',\n              partNum: '',\n              serialNum: '',\n              voltageConfigured: null,\n              voltageMin: null,\n              voltageMax: null,\n            });\n\n            // Try Raspberry PI\n            try {\n              let stdout = execSync('cat /proc/cpuinfo 2>/dev/null');\n              let lines = stdout.toString().split('\\n');\n              let model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n              let version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n\n              if (model === 'BCM2835' || model === 'BCM2708' || model === 'BCM2709' || model === 'BCM2835' || model === 'BCM2837') {\n\n                const clockSpeed = {\n                  '0': 400,\n                  '1': 450,\n                  '2': 450,\n                  '3': 3200\n                };\n                result[0].type = 'LPDDR2';\n                result[0].type = version && version[2] && version[2] === '3' ? 'LPDDR4' : result[0].type;\n                result[0].ecc = false;\n                result[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;\n                result[0].clockSpeed = version && version[4] && version[4] === 'd' ? 500 : result[0].clockSpeed;\n                result[0].formFactor = 'SoC';\n\n                stdout = execSync('vcgencmd get_config sdram_freq 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let freq = parseInt(util.getValue(lines, 'sdram_freq', '=', true), 10) || 0;\n                if (freq) {\n                  result[0].clockSpeed = freq;\n                }\n\n                stdout = execSync('vcgencmd measure_volts sdram_p 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let voltage = parseFloat(util.getValue(lines, 'volt', '=', true)) || 0;\n                if (voltage) {\n                  result[0].voltageConfigured = voltage;\n                  result[0].voltageMin = voltage;\n                  result[0].voltageMax = voltage;\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('system_profiler SPMemoryDataType', function (error, stdout) {\n          if (!error) {\n            const allLines = stdout.toString().split('\\n');\n            const eccStatus = util.getValue(allLines, 'ecc', ':', true).toLowerCase();\n            let devices = stdout.toString().split('        BANK ');\n            let hasBank = true;\n            if (devices.length === 1) {\n              devices = stdout.toString().split('        DIMM');\n              hasBank = false;\n            }\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const bank = (hasBank ? 'BANK ' : 'DIMM') + lines[0].trim().split('/')[0];\n              const size = parseInt(util.getValue(lines, '          Size'));\n              if (size) {\n                result.push({\n                  size: size * 1024 * 1024 * 1024,\n                  bank: bank,\n                  type: util.getValue(lines, '          Type:'),\n                  ecc: eccStatus ? eccStatus === 'enabled' : null,\n                  clockSpeed: parseInt(util.getValue(lines, '          Speed:'), 10),\n                  formFactor: '',\n                  manufacturer: getManufacturerDarwin(util.getValue(lines, '          Manufacturer:')),\n                  partNum: util.getValue(lines, '          Part Number:'),\n                  serialNum: util.getValue(lines, '          Serial Number:'),\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank: bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: '',\n                  manufacturer: '',\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            const lines = stdout.toString().split('\\n');\n            const size = parseInt(util.getValue(lines, '      Memory:'));\n            const type = util.getValue(lines, '      Type:');\n            if (size && type) {\n              result.push({\n                size: size * 1024 * 1024 * 1024,\n                bank: '0',\n                type,\n                ecc: false,\n                clockSpeed: 0,\n                formFactor: '',\n                manufacturer: 'Apple',\n                partNum: '',\n                serialNum: '',\n                voltageConfigured: null,\n                voltageMin: null,\n                voltageMax: null,\n              });\n\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        const memoryTypes = 'Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4'.split('|');\n        const FormFactors = 'Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA'.split('|');\n\n        try {\n          util.powerShell('Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const dataWidth = util.toInt(util.getValue(lines, 'DataWidth', ':'));\n                const totalWidth = util.toInt(util.getValue(lines, 'TotalWidth', ':'));\n                const size = parseInt(util.getValue(lines, 'Capacity', ':'), 10) || 0;\n                if (size) {\n                  result.push({\n                    size,\n                    bank: util.getValue(lines, 'BankLabel', ':'), // BankLabel\n                    type: memoryTypes[parseInt(util.getValue(lines, 'MemoryType', ':'), 10) || parseInt(util.getValue(lines, 'SMBIOSMemoryType', ':'), 10)],\n                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                    clockSpeed: parseInt(util.getValue(lines, 'ConfiguredClockSpeed', ':'), 10) || parseInt(util.getValue(lines, 'Speed', ':'), 10) || 0,\n                    formFactor: FormFactors[parseInt(util.getValue(lines, 'FormFactor', ':'), 10) || 0],\n                    manufacturer: util.getValue(lines, 'Manufacturer', ':'),\n                    partNum: util.getValue(lines, 'PartNumber', ':'),\n                    serialNum: util.getValue(lines, 'SerialNumber', ':'),\n                    voltageConfigured: (parseInt(util.getValue(lines, 'ConfiguredVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMin: (parseInt(util.getValue(lines, 'MinVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMax: (parseInt(util.getValue(lines, 'MaxVoltage', ':'), 10) || 0) / 1000.0,\n                  });\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.memLayout = memLayout;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _network = {};\nlet _default_iface = '';\nlet _ifaces = {};\nlet _dhcpNics = [];\nlet _networkInterfaces = [];\nlet _mac = {};\nlet pathToIp;\n\nfunction getDefaultNetworkInterface() {\n\n  let ifacename = '';\n  let ifacenameFirst = '';\n  try {\n    let ifaces = os.networkInterfaces();\n\n    let scopeid = 9999;\n\n    // fallback - \"first\" external interface (sorted by scopeid)\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.internal === false) {\n            ifacenameFirst = ifacenameFirst || dev; // fallback if no scopeid\n            if (details.scopeid && details.scopeid < scopeid) {\n              ifacename = dev;\n              scopeid = details.scopeid;\n            }\n          }\n        });\n      }\n    }\n    ifacename = ifacename || ifacenameFirst || '';\n\n    if (_windows) {\n      // https://www.inetdaemon.com/tutorials/internet/ip/routing/default_route.shtml\n      let defaultIp = '';\n      const cmd = 'netstat -r';\n      const result = execSync(cmd, util.execOptsWin);\n      const lines = result.toString().split(os.EOL);\n      lines.forEach(line => {\n        line = line.replace(/\\s+/g, ' ').trim();\n        if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n          const parts = line.split(' ');\n          if (parts.length >= 5) {\n            defaultIp = parts[parts.length - 2];\n          }\n        }\n      });\n      if (defaultIp) {\n        for (let dev in ifaces) {\n          if ({}.hasOwnProperty.call(ifaces, dev)) {\n            ifaces[dev].forEach(function (details) {\n              if (details && details.address && details.address === defaultIp) {\n                ifacename = dev;\n              }\n            });\n          }\n        }\n      }\n    }\n    if (_linux) {\n      let cmd = 'ip route 2> /dev/null | grep default';\n      let result = execSync(cmd);\n      let parts = result.toString().split('\\n')[0].split(/\\s+/);\n      if (parts[0] === 'none' && parts[5]) {\n        ifacename = parts[5];\n      } else if (parts[4]) {\n        ifacename = parts[4];\n      }\n\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n    if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {\n      let cmd = '';\n      if (_linux) { cmd = 'ip route 2> /dev/null | grep default | awk \\'{print $5}\\''; }\n      if (_darwin) { cmd = 'route -n get default 2>/dev/null | grep interface: | awk \\'{print $2}\\''; }\n      if (_freebsd || _openbsd || _netbsd || _sunos) { cmd = 'route get 0.0.0.0 | grep interface:'; }\n      let result = execSync(cmd);\n      ifacename = result.toString().split('\\n')[0];\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n  } catch (e) {\n    util.noop();\n  }\n  if (ifacename) { _default_iface = ifacename; }\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  let iface = '';\n  let mac = '';\n  let result = {};\n  if (_linux || _freebsd || _openbsd || _netbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        const lines = execSync('which ip').toString().split('\\n');\n        if (lines.length && lines[0].indexOf(':') === -1 && lines[0].indexOf('/') === 0) {\n          pathToIp = lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n    try {\n      const cmd = 'export LC_ALL=C; ' + ((pathToIp) ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== ' ') {\n          if (pathToIp) {\n            let nextline = lines[i + 1].trim().split(' ');\n            if (nextline[0] === 'link/ether') {\n              iface = lines[i].split(' ')[1];\n              iface = iface.slice(0, iface.length - 1);\n              mac = nextline[1];\n            }\n          } else {\n            iface = lines[i].split(' ')[0];\n            mac = lines[i].split('HWaddr ')[1];\n          }\n\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_darwin) {\n    try {\n      const cmd = '/sbin/ifconfig';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== '\\t' && lines[i].indexOf(':') > 0) {\n          iface = lines[i].split(':')[0];\n        } else if (lines[i].indexOf('\\tether ') === 0) {\n          mac = lines[i].split('\\tether ')[1];\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction parseLinesWindowsNics(sections, nconfigsections) {\n  let nics = [];\n  for (let i in sections) {\n    if ({}.hasOwnProperty.call(sections, i)) {\n\n      if (sections[i].trim() !== '') {\n\n        let lines = sections[i].trim().split('\\r\\n');\n        let linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split('\\r\\n') : [];\n        let netEnabled = util.getValue(lines, 'NetEnabled', ':');\n        let adapterType = util.getValue(lines, 'AdapterTypeID', ':') === '9' ? 'wireless' : 'wired';\n        let ifacename = util.getValue(lines, 'Name', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        let iface = util.getValue(lines, 'NetConnectionID', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        if (ifacename.toLowerCase().indexOf('wi-fi') >= 0 || ifacename.toLowerCase().indexOf('wireless') >= 0) {\n          adapterType = 'wireless';\n        }\n        if (netEnabled !== '') {\n          const speed = parseInt(util.getValue(lines, 'speed', ':').trim(), 10) / 1000000;\n          nics.push({\n            mac: util.getValue(lines, 'MACAddress', ':').toLowerCase(),\n            dhcp: util.getValue(linesNicConfig, 'dhcpEnabled', ':').toLowerCase() === 'true',\n            name: ifacename,\n            iface,\n            netEnabled: netEnabled === 'TRUE',\n            speed: isNaN(speed) ? null : speed,\n            operstate: util.getValue(lines, 'NetConnectionStatus', ':') === '2' ? 'up' : 'down',\n            type: adapterType\n          });\n        }\n      }\n    }\n  }\n  return nics;\n}\n\nfunction getWindowsNics() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let cmd = 'Get-CimInstance Win32_NetworkAdapter | fl *' + '; echo \\'#-#-#-#\\';';\n      cmd += 'Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled' + '';\n      try {\n        util.powerShell(cmd).then((data) => {\n          data = data.split('#-#-#-#');\n          const nsections = (data[0] || '').split(/\\n\\s*\\n/);\n          const nconfigsections = (data[1] || '').split(/\\n\\s*\\n/);\n          resolve(parseLinesWindowsNics(nsections, nconfigsections));\n        });\n      } catch (e) {\n        resolve([]);\n      }\n    });\n  });\n}\n\nfunction getWindowsDNSsuffixes() {\n\n  let iface = {};\n\n  let dnsSuffixes = {\n    primaryDNS: '',\n    exitCode: 0,\n    ifaces: [],\n  };\n\n  try {\n    const ipconfig = execSync('ipconfig /all', util.execOptsWin);\n    const ipconfigArray = ipconfig.split('\\r\\n\\r\\n');\n\n    ipconfigArray.forEach((element, index) => {\n\n      if (index == 1) {\n        const longPrimaryDNS = element.split('\\r\\n').filter((element) => {\n          return element.toUpperCase().includes('DNS');\n        });\n        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(':') + 1);\n        dnsSuffixes.primaryDNS = primaryDNS.trim();\n        if (!dnsSuffixes.primaryDNS) { dnsSuffixes.primaryDNS = 'Not defined'; }\n      }\n      if (index > 1) {\n        if (index % 2 == 0) {\n          const name = element.substring(element.lastIndexOf(' ') + 1).replace(':', '');\n          iface.name = name;\n        } else {\n          const connectionSpecificDNS = element.split('\\r\\n').filter((element) => {\n            return element.toUpperCase().includes('DNS');\n          });\n          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(':') + 1);\n          iface.dnsSuffix = dnsSuffix.trim();\n          dnsSuffixes.ifaces.push(iface);\n          iface = {};\n        }\n      }\n    });\n\n    return dnsSuffixes;\n  } catch (error) {\n    return {\n      primaryDNS: '',\n      exitCode: 0,\n      ifaces: [],\n    };\n  }\n}\n\nfunction getWindowsIfaceDNSsuffix(ifaces, ifacename) {\n  let dnsSuffix = '';\n  // Adding (.) to ensure ifacename compatibility when duplicated iface-names\n  const interfaceName = ifacename + '.';\n  try {\n    const connectionDnsSuffix = ifaces.filter((iface) => {\n      return interfaceName.includes(iface.name + '.');\n    }).map((iface) => iface.dnsSuffix);\n    if (connectionDnsSuffix[0]) {\n      dnsSuffix = connectionDnsSuffix[0];\n    }\n    if (!dnsSuffix) { dnsSuffix = ''; }\n    return dnsSuffix;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\n\nfunction getWindowsWiredProfilesInformation() {\n  try {\n    const result = execSync('netsh lan show profiles', util.execOptsWin);\n    const profileList = result.split('\\r\\nProfile on interface');\n    return profileList;\n  } catch (error) {\n    if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n      return 'Disabled';\n    }\n    return [];\n  }\n}\n\nfunction getWindowsWirelessIfaceSSID(interfaceName) {\n  try {\n    const result = execSync(`netsh wlan show  interface name=\"${interfaceName}\" | findstr \"SSID\"`, util.execOptsWin);\n    const SSID = result.split('\\r\\n').shift();\n    const parseSSID = SSID.split(':').pop();\n    return parseSSID;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\nfunction getWindowsIEEE8021x(connectionType, iface, ifaces) {\n  let i8021x = {\n    state: 'Unknown',\n    protocol: 'Unknown',\n  };\n\n  if (ifaces === 'Disabled') {\n    i8021x.state = 'Disabled';\n    i8021x.protocol = 'Not defined';\n    return i8021x;\n  }\n\n  if (connectionType == 'wired' && ifaces.length > 0) {\n    try {\n      // Get 802.1x information by interface name\n      const iface8021xInfo = ifaces.find((element) => {\n        return element.includes(iface + '\\r\\n');\n      });\n      const arrayIface8021xInfo = iface8021xInfo.split('\\r\\n');\n      const state8021x = arrayIface8021xInfo.find((element) => {\n        return element.includes('802.1x');\n      });\n\n      if (state8021x.includes('Disabled')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      } else if (state8021x.includes('Enabled')) {\n        const protocol8021x = arrayIface8021xInfo.find((element) => {\n          return element.includes('EAP');\n        });\n        i8021x.protocol = protocol8021x.split(':').pop();\n        i8021x.state = 'Enabled';\n      }\n    } catch (error) {\n      return i8021x;\n    }\n  } else if (connectionType == 'wireless') {\n\n    let i8021xState = '';\n    let i8021xProtocol = '';\n\n\n\n    try {\n      const SSID = getWindowsWirelessIfaceSSID(iface);\n      if (SSID !== 'Unknown') {\n        i8021xState = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"802.1X\"`, util.execOptsWin);\n        i8021xProtocol = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"EAP\"`, util.execOptsWin);\n      }\n\n      if (i8021xState.includes(':') && i8021xProtocol.includes(':')) {\n        i8021x.state = i8021xState.split(':').pop();\n        i8021x.protocol = i8021xProtocol.split(':').pop();\n      }\n    } catch (error) {\n      if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      }\n      return i8021x;\n    }\n  }\n\n  return i8021x;\n}\n\nfunction splitSectionsNics(lines) {\n  const result = [];\n  let section = [];\n  lines.forEach(function (line) {\n    if (!line.startsWith('\\t') && !line.startsWith(' ')) {\n      if (section.length) {\n        result.push(section);\n        section = [];\n      }\n    }\n    section.push(line);\n  });\n  if (section.length) {\n    result.push(section);\n  }\n  return result;\n}\n\nfunction parseLinesDarwinNics(sections) {\n  let nics = [];\n  sections.forEach(section => {\n    let nic = {\n      iface: '',\n      mtu: null,\n      mac: '',\n      ip6: '',\n      ip4: '',\n      speed: null,\n      type: '',\n      operstate: '',\n      duplex: '',\n      internal: false\n    };\n    const first = section[0];\n    nic.iface = first.split(':')[0].trim();\n    let parts = first.split('> mtu');\n    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;\n    if (isNaN(nic.mtu)) {\n      nic.mtu = null;\n    }\n    nic.internal = parts[0].toLowerCase().indexOf('loopback') > -1;\n    section.forEach(line => {\n      if (line.trim().startsWith('ether ')) {\n        nic.mac = line.split('ether ')[1].toLowerCase().trim();\n      }\n      if (line.trim().startsWith('inet6 ') && !nic.ip6) {\n        nic.ip6 = line.split('inet6 ')[1].toLowerCase().split('%')[0].split(' ')[0];\n      }\n      if (line.trim().startsWith('inet ') && !nic.ip4) {\n        nic.ip4 = line.split('inet ')[1].toLowerCase().split(' ')[0];\n      }\n    });\n    let speed = util.getValue(section, 'link rate');\n    nic.speed = speed ? parseFloat(speed) : null;\n    if (nic.speed === null) {\n      speed = util.getValue(section, 'uplink rate');\n      nic.speed = speed ? parseFloat(speed) : null;\n      if (nic.speed !== null && speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    } else {\n      if (speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    }\n    nic.type = util.getValue(section, 'type').toLowerCase().indexOf('wi-fi') > -1 ? 'wireless' : 'wired';\n    const operstate = util.getValue(section, 'status').toLowerCase();\n    nic.operstate = (operstate === 'active' ? 'up' : (operstate === 'inactive' ? 'down' : 'unknown'));\n    nic.duplex = util.getValue(section, 'media').toLowerCase().indexOf('half-duplex') > -1 ? 'half' : 'full';\n    if (nic.ip6 || nic.ip4 || nic.mac) {\n      nics.push(nic);\n    }\n  });\n  return nics;\n}\n\nfunction getDarwinNics() {\n  const cmd = '/sbin/ifconfig -v';\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    return (parseLinesDarwinNics(nsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getLinuxIfaceConnectionName(interfaceName) {\n  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;\n\n  try {\n    const result = execSync(cmd).toString();\n    const resultFormat = result.replace(/\\s+/g, ' ').trim();\n    const connectionNameLines = resultFormat.split(' ').slice(3);\n    const connectionName = connectionNameLines.join(' ');\n    return connectionName != '--' ? connectionName : '';\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction checkLinuxDCHPInterfaces(file) {\n  let result = [];\n  try {\n    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\\\|source'`;\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n\n    lines.forEach(line => {\n      const parts = line.replace(/\\s+/g, ' ').trim().split(' ');\n      if (parts.length >= 4) {\n        if (line.toLowerCase().indexOf(' inet ') >= 0 && line.toLowerCase().indexOf('dhcp') >= 0) {\n          result.push(parts[1]);\n        }\n      }\n      if (line.toLowerCase().includes('source')) {\n        let file = line.split(' ')[1];\n        result = result.concat(checkLinuxDCHPInterfaces(file));\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxDHCPNics() {\n  // alternate methods getting interfaces using DHCP\n  let cmd = 'ip a 2> /dev/null';\n  let result = [];\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    result = (parseLinuxDHCPNics(nsections));\n  } catch (e) {\n    util.noop();\n  }\n  try {\n    result = checkLinuxDCHPInterfaces('/etc/network/interfaces');\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction parseLinuxDHCPNics(sections) {\n  const result = [];\n  if (sections && sections.length) {\n    sections.forEach(lines => {\n      if (lines && lines.length) {\n        const parts = lines[0].split(':');\n        if (parts.length > 2) {\n          for (let line of lines) {\n            if (line.indexOf(' inet ') >= 0 && line.indexOf(' dynamic ') >= 0) {\n              const parts2 = line.split(' ');\n              const nic = parts2[parts2.length - 1].trim();\n              result.push(nic);\n              break;\n            }\n          }\n        }\n      }\n    });\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {\n  let result = false;\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.method;`;\n    try {\n      const lines = execSync(cmd).toString();\n      const resultFormat = lines.replace(/\\s+/g, ' ').trim();\n\n      let dhcStatus = resultFormat.split(' ').slice(1).toString();\n      switch (dhcStatus) {\n        case 'auto':\n          result = true;\n          break;\n\n        default:\n          result = false;\n          break;\n      }\n      return result;\n    } catch (e) {\n      return (DHCPNics.indexOf(iface) >= 0);\n    }\n  } else {\n    return (DHCPNics.indexOf(iface) >= 0);\n  }\n}\n\nfunction getDarwinIfaceDHCPstatus(iface) {\n  let result = false;\n  const cmd = `ipconfig getpacket \"${iface}\" 2>/dev/null | grep lease_time;`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    if (lines.length && lines[0].startsWith('lease_time')) {\n      result = true;\n    }\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDNSsuffix(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.dns-search;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const dnsSuffix = resultFormat.split(' ').slice(1).toString();\n      return dnsSuffix == '--' ? 'Not defined' : dnsSuffix;\n    } catch (e) {\n      return 'Unknown';\n    }\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xAuth(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep 802-1x.eap;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const authenticationProtocol = resultFormat.split(' ').slice(1).toString();\n\n\n      return authenticationProtocol == '--' ? '' : authenticationProtocol;\n    } catch (e) {\n      return 'Not defined';\n    }\n  } else {\n    return 'Not defined';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xState(authenticationProtocol) {\n  if (authenticationProtocol) {\n    if (authenticationProtocol == 'Not defined') {\n      return 'Disabled';\n    }\n    return 'Enabled';\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction testVirtualNic(iface, ifaceName, mac) {\n  const virtualMacs = ['00:00:00:00:00:00', '00:03:FF', '00:05:69', '00:0C:29', '00:0F:4B', '00:0F:4B', '00:13:07', '00:13:BE', '00:15:5d', '00:16:3E', '00:1C:42', '00:21:F6', '00:21:F6', '00:24:0B', '00:24:0B', '00:50:56', '00:A0:B1', '00:E0:C8', '08:00:27', '0A:00:27', '18:92:2C', '16:DF:49', '3C:F3:92', '54:52:00', 'FC:15:97'];\n  if (mac) {\n    return virtualMacs.filter(item => { return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length)); }).length > 0 ||\n      iface.toLowerCase().indexOf(' virtual ') > -1 ||\n      ifaceName.toLowerCase().indexOf(' virtual ') > -1 ||\n      iface.toLowerCase().indexOf('vethernet ') > -1 ||\n      ifaceName.toLowerCase().indexOf('vethernet ') > -1 ||\n      iface.toLowerCase().startsWith('veth') ||\n      ifaceName.toLowerCase().startsWith('veth') ||\n      iface.toLowerCase().startsWith('vboxnet') ||\n      ifaceName.toLowerCase().startsWith('vboxnet');\n  } else { return false; }\n}\n\nfunction networkInterfaces(callback, rescan, defaultString) {\n\n  if (typeof callback === 'string') {\n    defaultString = callback;\n    rescan = true;\n    callback = null;\n  }\n\n  if (typeof callback === 'boolean') {\n    rescan = callback;\n    callback = null;\n    defaultString = '';\n  }\n  if (typeof rescan === 'undefined') {\n    rescan = true;\n  }\n  defaultString = defaultString || '';\n  defaultString = '' + defaultString;\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let ifaces = os.networkInterfaces();\n\n      let result = [];\n      let nics = [];\n      let dnsSuffixes = [];\n      let nics8021xInfo = [];\n      // seperate handling in OSX\n      if (_darwin || _freebsd || _openbsd || _netbsd) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          const defaultInterface = getDefaultNetworkInterface();\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n\n          nics = getDarwinNics();\n\n\n          nics.forEach(nic => {\n\n            if ({}.hasOwnProperty.call(ifaces, nic.iface)) {\n              ifaces[nic.iface].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  nic.ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  nic.ip6subnet = details.netmask;\n                }\n              });\n            }\n\n            let ifaceSanitized = '';\n            const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(nic.iface);\n            for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n              if (s[i] !== undefined) {\n                ifaceSanitized = ifaceSanitized + s[i];\n              }\n            }\n\n            result.push({\n              iface: nic.iface,\n              ifaceName: nic.iface,\n              default: nic.iface === defaultInterface,\n              ip4: nic.ip4,\n              ip4subnet: nic.ip4subnet || '',\n              ip6: nic.ip6,\n              ip6subnet: nic.ip6subnet || '',\n              mac: nic.mac,\n              internal: nic.internal,\n              virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),\n              operstate: nic.operstate,\n              type: nic.type,\n              duplex: nic.duplex,\n              mtu: nic.mtu,\n              speed: nic.speed,\n              dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),\n              dnsSuffix: '',\n              ieee8021xAuth: '',\n              ieee8021xState: '',\n              carrierChanges: 0\n            });\n          });\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          _dhcpNics = getLinuxDHCPNics();\n          const defaultInterface = getDefaultNetworkInterface();\n          for (let dev in ifaces) {\n            let ip4 = '';\n            let ip4subnet = '';\n            let ip6 = '';\n            let ip6subnet = '';\n            let mac = '';\n            let duplex = '';\n            let mtu = '';\n            let speed = null;\n            let carrierChanges = 0;\n            let dhcp = false;\n            let dnsSuffix = '';\n            let ieee8021xAuth = '';\n            let ieee8021xState = '';\n            let type = '';\n\n            if ({}.hasOwnProperty.call(ifaces, dev)) {\n              let ifaceName = dev;\n              ifaces[dev].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  ip4 = details.address;\n                  ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  if (!ip6 || ip6.match(/^fe80::/i)) {\n                    ip6 = details.address;\n                    ip6subnet = details.netmask;\n                  }\n                }\n                mac = details.mac;\n                // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                  if (Object.keys(_mac).length === 0) {\n                    _mac = getMacAddresses();\n                  }\n                  mac = _mac[dev] || '';\n                }\n              });\n              let iface = dev.split(':')[0].trim().toLowerCase();\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n              const cmd = `echo -n \"addr_assign_type: \"; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;\n            echo -n \"address: \"; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;\n            echo -n \"addr_len: \"; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;\n            echo -n \"broadcast: \"; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;\n            echo -n \"carrier: \"; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;\n            echo -n \"carrier_changes: \"; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;\n            echo -n \"dev_id: \"; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;\n            echo -n \"dev_port: \"; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;\n            echo -n \"dormant: \"; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;\n            echo -n \"duplex: \"; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;\n            echo -n \"flags: \"; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;\n            echo -n \"gro_flush_timeout: \"; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;\n            echo -n \"ifalias: \"; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;\n            echo -n \"ifindex: \"; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;\n            echo -n \"iflink: \"; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;\n            echo -n \"link_mode: \"; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;\n            echo -n \"mtu: \"; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;\n            echo -n \"netdev_group: \"; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;\n            echo -n \"operstate: \"; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;\n            echo -n \"proto_down: \"; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;\n            echo -n \"speed: \"; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;\n            echo -n \"tx_queue_len: \"; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;\n            echo -n \"type: \"; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;\n            echo -n \"wireless: \"; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;\n            echo -n \"wirelessspeed: \"; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;\n\n              let lines = [];\n              try {\n                lines = execSync(cmd).toString().split('\\n');\n                const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);\n                dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);\n                dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);\n                ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);\n                ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);\n              } catch (e) {\n                util.noop();\n              }\n              duplex = util.getValue(lines, 'duplex');\n              duplex = duplex.startsWith('cat') ? '' : duplex;\n              mtu = parseInt(util.getValue(lines, 'mtu'), 10);\n              let myspeed = parseInt(util.getValue(lines, 'speed'), 10);\n              speed = isNaN(myspeed) ? null : myspeed;\n              let wirelessspeed = util.getValue(lines, 'wirelessspeed').split('tx bitrate: ');\n              if (speed === null && wirelessspeed.length === 2) {\n                myspeed = parseFloat(wirelessspeed[1]);\n                speed = isNaN(myspeed) ? null : myspeed;\n              }\n              carrierChanges = parseInt(util.getValue(lines, 'carrier_changes'), 10);\n              const operstate = util.getValue(lines, 'operstate');\n              type = operstate === 'up' ? (util.getValue(lines, 'wireless').trim() ? 'wireless' : 'wired') : 'unknown';\n              if (ifaceSanitized === 'lo' || ifaceSanitized.startsWith('bond')) { type = 'virtual'; }\n\n              let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n              if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                internal = true;\n              }\n              const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n              result.push({\n                iface: ifaceSanitized,\n                ifaceName,\n                default: iface === defaultInterface,\n                ip4,\n                ip4subnet,\n                ip6,\n                ip6subnet,\n                mac,\n                internal,\n                virtual,\n                operstate,\n                type,\n                duplex,\n                mtu,\n                speed,\n                dhcp,\n                dnsSuffix,\n                ieee8021xAuth,\n                ieee8021xState,\n                carrierChanges,\n              });\n            }\n          }\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          const defaultInterface = getDefaultNetworkInterface();\n\n          getWindowsNics().then(function (nics) {\n            nics.forEach(nic => {\n              let found = false;\n              Object.keys(ifaces).forEach(key => {\n                if (!found) {\n                  ifaces[key].forEach(value => {\n                    if (Object.keys(value).indexOf('mac') >= 0) {\n                      found = value['mac'] === nic.mac;\n                    }\n                  });\n                }\n              });\n\n              if (!found) {\n                ifaces[nic.name] = [{ mac: nic.mac }];\n              }\n            });\n            nics8021xInfo = getWindowsWiredProfilesInformation();\n            dnsSuffixes = getWindowsDNSsuffixes();\n            for (let dev in ifaces) {\n\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(dev);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n\n              let iface = dev;\n              let ip4 = '';\n              let ip4subnet = '';\n              let ip6 = '';\n              let ip6subnet = '';\n              let mac = '';\n              let duplex = '';\n              let mtu = '';\n              let speed = null;\n              let carrierChanges = 0;\n              let operstate = 'down';\n              let dhcp = false;\n              let dnsSuffix = '';\n              let ieee8021xAuth = '';\n              let ieee8021xState = '';\n              let type = '';\n\n              if ({}.hasOwnProperty.call(ifaces, dev)) {\n                let ifaceName = dev;\n                ifaces[dev].forEach(function (details) {\n                  if (details.family === 'IPv4' || details.family === 4) {\n                    ip4 = details.address;\n                    ip4subnet = details.netmask;\n                  }\n                  if (details.family === 'IPv6' || details.family === 6) {\n                    if (!ip6 || ip6.match(/^fe80::/i)) {\n                      ip6 = details.address;\n                      ip6subnet = details.netmask;\n                    }\n                  }\n                  mac = details.mac;\n                  // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                  const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                  if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                    if (Object.keys(_mac).length === 0) {\n                      _mac = getMacAddresses();\n                    }\n                    mac = _mac[dev] || '';\n                  }\n                });\n\n\n\n                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);\n                let foundFirst = false;\n                nics.forEach(detail => {\n                  if (detail.mac === mac && !foundFirst) {\n                    iface = detail.iface || iface;\n                    ifaceName = detail.name;\n                    dhcp = detail.dhcp;\n                    operstate = detail.operstate;\n                    speed = detail.speed;\n                    type = detail.type;\n                    foundFirst = true;\n                  }\n                });\n\n                if (dev.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('802.11n') >= 0 || ifaceName.toLowerCase().indexOf('wireless') >= 0 || ifaceName.toLowerCase().indexOf('wi-fi') >= 0 || ifaceName.toLowerCase().indexOf('wifi') >= 0) {\n                  type = 'wireless';\n                }\n\n                const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);\n                ieee8021xAuth = IEEE8021x.protocol;\n                ieee8021xState = IEEE8021x.state;\n                let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n                if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                  internal = true;\n                }\n                const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n                result.push({\n                  iface,\n                  ifaceName,\n                  default: iface === defaultInterface,\n                  ip4,\n                  ip4subnet,\n                  ip6,\n                  ip6subnet,\n                  mac,\n                  internal,\n                  virtual,\n                  operstate,\n                  type,\n                  duplex,\n                  mtu,\n                  speed,\n                  dhcp,\n                  dnsSuffix,\n                  ieee8021xAuth,\n                  ieee8021xState,\n                  carrierChanges,\n                });\n              }\n            }\n            _networkInterfaces = result;\n            if (defaultString.toLowerCase().indexOf('default') >= 0) {\n              result = result.filter(item => item.default);\n              if (result.length > 0) {\n                result = result[0];\n              } else {\n                result = [];\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {\n  let result = {\n    iface,\n    operstate,\n    rx_bytes,\n    rx_dropped,\n    rx_errors,\n    tx_bytes,\n    tx_dropped,\n    tx_errors,\n    rx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx_bytes - _network[iface].rx_bytes) >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;\n    result.tx_sec = (tx_bytes - _network[iface].tx_bytes) >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) { _network[iface] = {}; }\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = null;\n    _network[iface].tx_sec = null;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n  return result;\n}\n\nfunction networkStats(ifaces, callback) {\n\n  let ifacesArray = [];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(ifaces) && !callback) {\n        callback = ifaces;\n        ifacesArray = [getDefaultNetworkInterface()];\n      } else {\n        if (typeof ifaces !== 'string' && ifaces !== undefined) {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        ifaces = ifaces || getDefaultNetworkInterface();\n\n        ifaces.__proto__.toLowerCase = util.stringToLower;\n        ifaces.__proto__.replace = util.stringReplace;\n        ifaces.__proto__.trim = util.stringTrim;\n\n        ifaces = ifaces.trim().toLowerCase().replace(/,+/g, '|');\n        ifacesArray = ifaces.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (ifacesArray.length && ifacesArray[0].trim() === '*') {\n        ifacesArray = [];\n        networkInterfaces(false).then(allIFaces => {\n          for (let iface of allIFaces) {\n            ifacesArray.push(iface.iface);\n          }\n          networkStats(ifacesArray.join(',')).then(result => {\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      } else {\n        for (let iface of ifacesArray) {\n          workload.push(networkStatsSingle(iface.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction networkStatsSingle(iface) {\n\n  function parseLinesWindowsPerfData(sections) {\n    let perfData = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', ':').replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase(),\n            rx_bytes: parseInt(util.getValue(lines, 'BytesReceivedPersec', ':'), 10),\n            rx_errors: parseInt(util.getValue(lines, 'PacketsReceivedErrors', ':'), 10),\n            rx_dropped: parseInt(util.getValue(lines, 'PacketsReceivedDiscarded', ':'), 10),\n            tx_bytes: parseInt(util.getValue(lines, 'BytesSentPersec', ':'), 10),\n            tx_errors: parseInt(util.getValue(lines, 'PacketsOutboundErrors', ':'), 10),\n            tx_dropped: parseInt(util.getValue(lines, 'PacketsOutboundDiscarded', ':'), 10)\n          });\n        }\n      }\n    }\n    return perfData;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaceSanitized = '';\n      const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          ifaceSanitized = ifaceSanitized + s[i];\n        }\n      }\n\n      let result = {\n        iface: ifaceSanitized,\n        operstate: 'unknown',\n        rx_bytes: 0,\n        rx_dropped: 0,\n        rx_errors: 0,\n        tx_bytes: 0,\n        tx_dropped: 0,\n        tx_errors: 0,\n        rx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx_bytes = 0;\n      let tx_bytes = 0;\n      let rx_dropped = 0;\n      let rx_errors = 0;\n      let tx_dropped = 0;\n      let tx_errors = 0;\n\n      let cmd, lines, stats;\n      if (!_network[ifaceSanitized] || (_network[ifaceSanitized] && !_network[ifaceSanitized].ms) || (_network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + ifaceSanitized)) {\n            cmd =\n              'cat /sys/class/net/' + ifaceSanitized + '/operstate; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_errors; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_errors; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx_bytes = parseInt(lines[1], 10);\n                tx_bytes = parseInt(lines[2], 10);\n                rx_dropped = parseInt(lines[3], 10);\n                rx_errors = parseInt(lines[4], 10);\n                tx_dropped = parseInt(lines[5], 10);\n                tx_errors = parseInt(lines[6], 10);\n\n                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n\n              }\n              resolve(result);\n            });\n          } else {\n            resolve(result);\n          }\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'netstat -ibndI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n              for (let i = 1; i < lines.length; i++) {\n                const line = lines[i].replace(/ +/g, ' ').split(' ');\n                if (line && line[0] && line[7] && line[10]) {\n                  rx_bytes = rx_bytes + parseInt(line[7]);\n                  if (line[6].trim() !== '-') { rx_dropped = rx_dropped + parseInt(line[6]); }\n                  if (line[5].trim() !== '-') { rx_errors = rx_errors + parseInt(line[5]); }\n                  tx_bytes = tx_bytes + parseInt(line[10]);\n                  if (line[12].trim() !== '-') { tx_dropped = tx_dropped + parseInt(line[12]); }\n                  if (line[9].trim() !== '-') { tx_errors = tx_errors + parseInt(line[9]); }\n                  operstate = 'up';\n                }\n              }\n              result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n            }\n            resolve(result);\n          });\n        }\n        if (_darwin) {\n          cmd = 'ifconfig ' + ifaceSanitized + ' | grep \"status\"';    // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = 'netstat -bdI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  const offset = stats.length > 11 ? 1 : 0;\n                  rx_bytes = parseInt(stats[offset + 5]);\n                  rx_dropped = parseInt(stats[offset + 10]);\n                  rx_errors = parseInt(stats[offset + 4]);\n                  tx_bytes = parseInt(stats[offset + 8]);\n                  tx_dropped = parseInt(stats[offset + 10]);\n                  tx_errors = parseInt(stats[offset + 7]);\n                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n                }\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_windows) {\n          let perfData = [];\n          let ifaceName = ifaceSanitized;\n\n          // Performance Data\n          util.powerShell('Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl').then((stdout, error) => {\n            if (!error) {\n              const psections = stdout.toString().split(/\\n\\s*\\n/);\n              perfData = parseLinesWindowsPerfData(psections);\n            }\n\n            // Network Interfaces\n            networkInterfaces(false).then(interfaces => {\n              // get bytes sent, received from perfData by name\n              rx_bytes = 0;\n              tx_bytes = 0;\n              perfData.forEach(detail => {\n                interfaces.forEach(det => {\n                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.mac.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === ifaceSanitized.replace(/[()[\\] ]+/g, '').replace('#', '_').toLowerCase()) &&\n                    (det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === detail.name)) {\n                    ifaceName = det.iface;\n                    rx_bytes = detail.rx_bytes;\n                    rx_dropped = detail.rx_dropped;\n                    rx_errors = detail.rx_errors;\n                    tx_bytes = detail.tx_bytes;\n                    tx_dropped = detail.tx_dropped;\n                    tx_errors = detail.tx_errors;\n                    operstate = det.operstate;\n                  }\n                });\n              });\n              if (rx_bytes && tx_bytes) {\n                result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n              }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx_bytes = _network[ifaceSanitized].rx_bytes;\n        result.tx_bytes = _network[ifaceSanitized].tx_bytes;\n        result.rx_sec = _network[ifaceSanitized].rx_sec;\n        result.tx_sec = _network[ifaceSanitized].tx_sec;\n        result.ms = _network[ifaceSanitized].last_ms;\n        result.operstate = _network[ifaceSanitized].operstate;\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction getProcessName(processes, pid) {\n  let cmd = '';\n  processes.forEach(line => {\n    const parts = line.split(' ');\n    const id = parseInt(parts[0], 10) || -1;\n    if (id === pid) {\n      parts.shift();\n      cmd = parts.join(' ').split(':')[0];\n    }\n  });\n  cmd = cmd.split(' -')[0];\n  // return cmd;\n  const cmdParts = cmd.split('/');\n  return cmdParts[cmdParts.length - 1];\n}\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'export LC_ALL=C; netstat -tunap | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL'; }\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          if (!error && (lines.length > 1 || lines[0] != '')) {\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 7) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                let proc = line[6].split('/');\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localAddress: localip,\n                    localPort: localport,\n                    peerAddress: peerip,\n                    peerPort: peerport,\n                    state: connstate,\n                    pid: proc[0] && proc[0] !== '-' ? parseInt(proc[0], 10) : null,\n                    process: proc[1] ? proc[1].split(' ')[0].split(':')[0] : ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            cmd = 'ss -tunap | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') { connstate = 'ESTABLISHED'; }\n                    if (connstate === 'TIME-WAIT') { connstate = 'TIME_WAIT'; }\n                    let pid = null;\n                    let process = '';\n                    if (line.length >= 7 && line[6].indexOf('users:') > -1) {\n                      let proc = line[6].replace('users:((\"', '').replace(/\"/g, '').split(',');\n                      if (proc.length > 2) {\n                        process = proc[0].split(' ')[0].split(':')[0];\n                        pid = parseInt(proc[1], 10);\n                      }\n                    }\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localAddress: localip,\n                        localPort: localport,\n                        peerAddress: peerip,\n                        peerPort: peerport,\n                        state: connstate,\n                        pid,\n                        process\n                      });\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        // let cmd = 'netstat -natv | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        let cmd = 'netstat -natv | grep \"tcp4\\\\|tcp6\\\\|udp4\\\\|udp6\"';\n        const states = 'ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          if (!error) {\n            exec('ps -axo pid,command', { maxBuffer: 1024 * 20000 }, function (err2, stdout2) {\n              let processes = stdout2.toString().split('\\n');\n              processes = processes.map((line => { return line.trim().replace(/ +/g, ' '); }));\n              let lines = stdout.toString().split('\\n');\n\n              lines.forEach(function (line) {\n                line = line.replace(/ +/g, ' ').split(' ');\n                if (line.length >= 8) {\n                  let localip = line[3];\n                  let localport = '';\n                  let localaddress = line[3].split('.');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join('.');\n                  }\n                  let peerip = line[4];\n                  let peerport = '';\n                  let peeraddress = line[4].split('.');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join('.');\n                  }\n                  const hasState = states.indexOf(line[5]) >= 0;\n                  let connstate = hasState ? line[5] : 'UNKNOWN';\n                  let pid = parseInt(line[8 + (hasState ? 0 : -1)], 10);\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0],\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid: pid,\n                      process: getProcessName(processes, pid)\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n\n          }\n        });\n      }\n      if (_windows) {\n        let cmd = 'netstat -nao';\n        try {\n          exec(cmd, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n\n              let lines = stdout.toString().split('\\r\\n');\n\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n                if (line.length >= 4) {\n                  let localip = line[1];\n                  let localport = '';\n                  let localaddress = line[1].split(':');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n                  localip = localip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let peerip = line[2];\n                  let peerport = '';\n                  let peeraddress = line[2].split(':');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n                  peerip = peerip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let pid = util.toInt(line[4]);\n                  let connstate = line[3];\n                  if (connstate === 'HERGESTELLT') { connstate = 'ESTABLISHED'; }\n                  if (connstate.startsWith('ABH')) { connstate = 'LISTEN'; }\n                  if (connstate === 'SCHLIESSEN_WARTEN') { connstate = 'CLOSE_WAIT'; }\n                  if (connstate === 'WARTEND') { connstate = 'TIME_WAIT'; }\n                  if (connstate === 'SYN_GESENDET') { connstate = 'SYN_SENT'; }\n\n                  if (connstate === 'LISTENING') { connstate = 'LISTEN'; }\n                  if (connstate === 'SYN_RECEIVED') { connstate = 'SYN_RECV'; }\n                  if (connstate === 'FIN_WAIT_1') { connstate = 'FIN_WAIT1'; }\n                  if (connstate === 'FIN_WAIT_2') { connstate = 'FIN_WAIT2'; }\n                  if (line[0].toLowerCase() !== 'udp' && connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid,\n                      process: ''\n                    });\n                  } else if (line[0].toLowerCase() === 'udp') {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: '',\n                      pid: parseInt(line[3], 10),\n                      process: ''\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n\nfunction networkGatewayDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'ip route get 1';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              const line = lines && lines[0] ? lines[0] : '';\n              let parts = line.split(' via ');\n              if (parts && parts[1]) {\n                parts = parts[1].split(' ');\n                result = parts[0];\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        let cmd = 'route -n get default';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n').map(line => line.trim());\n              result = util.getValue(lines, 'gateway');\n            }\n            if (!result) {\n              cmd = 'netstat -rn | awk \\'/default/ {print $2}\\'';\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                const lines = stdout.toString().split('\\n').map(line => line.trim());\n                result = lines.find(line => (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line)));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        try {\n          exec('netstat -r', util.execOptsWin, function (error, stdout) {\n            const lines = stdout.toString().split(os.EOL);\n            lines.forEach(line => {\n              line = line.replace(/\\s+/g, ' ').trim();\n              if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n                const parts = line.split(' ');\n                if (parts.length >= 5 && (parts[parts.length - 3]).indexOf('.') > -1) {\n                  result = parts[parts.length - 3];\n                }\n              }\n            });\n            if (!result) {\n              util.powerShell('Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \\'0.0.0.0\\' -and $_.Mask -eq \\'0.0.0.0\\' }')\n                .then((data) => {\n                  let lines = data.toString().split('\\r\\n');\n                  if (lines.length > 1 && !result) {\n                    result = util.getValue(lines, 'NextHop');\n                    if (callback) {\n                      callback(result);\n                    }\n                    resolve(result);\n                    // } else {\n                    //   exec('ipconfig', util.execOptsWin, function (error, stdout) {\n                    //     let lines = stdout.toString().split('\\r\\n');\n                    //     lines.forEach(function (line) {\n                    //       line = line.trim().replace(/\\. /g, '');\n                    //       line = line.trim().replace(/ +/g, '');\n                    //       const parts = line.split(':');\n                    //       if ((parts[0].toLowerCase().startsWith('standardgate') || parts[0].toLowerCase().indexOf('gateway') > -1 || parts[0].toLowerCase().indexOf('enlace') > -1) && parts[1]) {\n                    //         result = parts[1];\n                    //       }\n                    //     });\n                    //     if (callback) { callback(result); }\n                    //     resolve(result);\n                    //   });\n                  }\n                });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkGatewayDefault = networkGatewayDefault;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// osinfo.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 3. Operating System\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// Get current time and OS uptime\n\nfunction time() {\n  let t = new Date().toString().split(' ');\n  return {\n    current: Date.now(),\n    uptime: os.uptime(),\n    timezone: (t.length >= 7) ? t[5] : '',\n    timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : (t.length >= 7) ? t.slice(6).join(' ').replace(/\\(/g, '').replace(/\\)/g, '') : ''\n  };\n}\n\nexports.time = time;\n\n// --------------------------\n// Get logo filename of OS distribution\n\nfunction getLogoFile(distro) {\n  distro = distro || '';\n  distro = distro.toLowerCase();\n  let result = _platform;\n  if (_windows) {\n    result = 'windows';\n  }\n  else if (distro.indexOf('mac os') !== -1) {\n    result = 'apple';\n  }\n  else if (distro.indexOf('arch') !== -1) {\n    result = 'arch';\n  }\n  else if (distro.indexOf('centos') !== -1) {\n    result = 'centos';\n  }\n  else if (distro.indexOf('coreos') !== -1) {\n    result = 'coreos';\n  }\n  else if (distro.indexOf('debian') !== -1) {\n    result = 'debian';\n  }\n  else if (distro.indexOf('deepin') !== -1) {\n    result = 'deepin';\n  }\n  else if (distro.indexOf('elementary') !== -1) {\n    result = 'elementary';\n  }\n  else if (distro.indexOf('fedora') !== -1) {\n    result = 'fedora';\n  }\n  else if (distro.indexOf('gentoo') !== -1) {\n    result = 'gentoo';\n  }\n  else if (distro.indexOf('mageia') !== -1) {\n    result = 'mageia';\n  }\n  else if (distro.indexOf('mandriva') !== -1) {\n    result = 'mandriva';\n  }\n  else if (distro.indexOf('manjaro') !== -1) {\n    result = 'manjaro';\n  }\n  else if (distro.indexOf('mint') !== -1) {\n    result = 'mint';\n  }\n  else if (distro.indexOf('mx') !== -1) {\n    result = 'mx';\n  }\n  else if (distro.indexOf('openbsd') !== -1) {\n    result = 'openbsd';\n  }\n  else if (distro.indexOf('freebsd') !== -1) {\n    result = 'freebsd';\n  }\n  else if (distro.indexOf('opensuse') !== -1) {\n    result = 'opensuse';\n  }\n  else if (distro.indexOf('pclinuxos') !== -1) {\n    result = 'pclinuxos';\n  }\n  else if (distro.indexOf('puppy') !== -1) {\n    result = 'puppy';\n  }\n  else if (distro.indexOf('raspbian') !== -1) {\n    result = 'raspbian';\n  }\n  else if (distro.indexOf('reactos') !== -1) {\n    result = 'reactos';\n  }\n  else if (distro.indexOf('redhat') !== -1) {\n    result = 'redhat';\n  }\n  else if (distro.indexOf('slackware') !== -1) {\n    result = 'slackware';\n  }\n  else if (distro.indexOf('sugar') !== -1) {\n    result = 'sugar';\n  }\n  else if (distro.indexOf('steam') !== -1) {\n    result = 'steam';\n  }\n  else if (distro.indexOf('suse') !== -1) {\n    result = 'suse';\n  }\n  else if (distro.indexOf('mate') !== -1) {\n    result = 'ubuntu-mate';\n  }\n  else if (distro.indexOf('lubuntu') !== -1) {\n    result = 'lubuntu';\n  }\n  else if (distro.indexOf('xubuntu') !== -1) {\n    result = 'xubuntu';\n  }\n  else if (distro.indexOf('ubuntu') !== -1) {\n    result = 'ubuntu';\n  }\n  else if (distro.indexOf('solaris') !== -1) {\n    result = 'solaris';\n  }\n  else if (distro.indexOf('tails') !== -1) {\n    result = 'tails';\n  }\n  else if (distro.indexOf('feren') !== -1) {\n    result = 'ferenos';\n  }\n  else if (distro.indexOf('robolinux') !== -1) {\n    result = 'robolinux';\n  } else if (_linux && distro) {\n    result = distro.toLowerCase().trim().replace(/\\s+/g, '-');\n  }\n  return result;\n}\n\n// --------------------------\n// FQDN\n\nfunction getFQDN() {\n  let fqdn = os.hostname;\n  if (_linux || _darwin) {\n    try {\n      const stdout = execSync('hostname -f');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_freebsd || _openbsd || _netbsd) {\n    try {\n      const stdout = execSync('hostname');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_windows) {\n    try {\n      const stdout = execSync('echo %COMPUTERNAME%.%USERDNSDOMAIN%', util.execOptsWin);\n      fqdn = stdout.toString().replace('.%USERDNSDOMAIN%', '').split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return fqdn;\n}\n\n// --------------------------\n// OS Information\n\nfunction osInfo(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n\n        platform: (_platform === 'win32' ? 'Windows' : _platform),\n        distro: 'unknown',\n        release: 'unknown',\n        codename: '',\n        kernel: os.release(),\n        arch: os.arch(),\n        hostname: os.hostname(),\n        fqdn: getFQDN(),\n        codepage: '',\n        logofile: '',\n        serial: '',\n        build: '',\n        servicepack: '',\n        uefi: false\n      };\n\n      if (_linux) {\n\n        exec('cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release', function (error, stdout) {\n          /**\n           * @namespace\n           * @property {string}  DISTRIB_ID\n           * @property {string}  NAME\n           * @property {string}  DISTRIB_RELEASE\n           * @property {string}  VERSION_ID\n           * @property {string}  DISTRIB_CODENAME\n           */\n          let release = {};\n          let lines = stdout.toString().split('\\n');\n          lines.forEach(function (line) {\n            if (line.indexOf('=') !== -1) {\n              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();\n            }\n          });\n          let releaseVersion = (release.VERSION || '').replace(/\"/g, '');\n          let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || '').replace(/\"/g, '');\n          if (releaseVersion.indexOf('(') >= 0) {\n            codename = releaseVersion.split('(')[1].replace(/[()]/g, '').trim();\n            releaseVersion = releaseVersion.split('(')[0].trim();\n          }\n          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/\"/g, '');\n          result.logofile = getLogoFile(result.distro);\n          result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/\"/g, '');\n          result.codename = codename;\n          result.codepage = util.getCodepage();\n          result.build = (release.BUILD_ID || '').replace(/\"/g, '').trim();\n          isUefiLinux().then(uefi => {\n            result.uefi = uefi;\n            uuid().then((data) => {\n              result.serial = data.os;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n\n        exec('sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const distro = util.getValue(lines, 'kern.ostype');\n          const logofile = util.getValue(lines, 'kern.ostype');\n          const release = util.getValue(lines, 'kern.osrelease').split('-')[0];\n          const serial = util.getValue(lines, 'kern.uuid');\n          const bootmethod = util.getValue(lines, 'machdep.bootmethod');\n          const uefiConf = stdout.toString().indexOf('<type>efi</type>') >= 0;\n          const uefi = bootmethod ? bootmethod.toLowerCase().indexOf('uefi') >= 0 : (uefiConf ? uefiConf : null);\n          result.distro = distro || result.distro;\n          result.logofile = logofile || result.logofile;\n          result.release = release || result.release;\n          result.serial = serial || result.serial;\n          result.codename = '';\n          result.codepage = util.getCodepage();\n          result.uefi = uefi || null;\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.serial = util.getValue(lines, 'kern.uuid');\n          result.distro = util.getValue(lines, 'ProductName');\n          result.release = util.getValue(lines, 'ProductVersion');\n          result.build = util.getValue(lines, 'BuildVersion');\n          result.logofile = getLogoFile(result.distro);\n          result.codename = 'macOS';\n          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);\n          result.codename = (result.release.indexOf('10.5') > -1 ? 'Mac OS X Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.6') > -1 ? 'Mac OS X Snow Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.7') > -1 ? 'Mac OS X Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.8') > -1 ? 'OS X Mountain Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.9') > -1 ? 'OS X Mavericks' : result.codename);\n          result.codename = (result.release.indexOf('10.10') > -1 ? 'OS X Yosemite' : result.codename);\n          result.codename = (result.release.indexOf('10.11') > -1 ? 'OS X El Capitan' : result.codename);\n          result.codename = (result.release.indexOf('10.12') > -1 ? 'macOS Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.13') > -1 ? 'macOS High Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.14') > -1 ? 'macOS Mojave' : result.codename);\n          result.codename = (result.release.indexOf('10.15') > -1 ? 'macOS Catalina' : result.codename);\n          result.codename = (result.release.startsWith('11.') ? 'macOS Big Sur' : result.codename);\n          result.codename = (result.release.startsWith('12.') ? 'macOS Monterey' : result.codename);\n          result.codename = (result.release.startsWith('13.') ? 'macOS Ventura' : result.codename);\n          result.uefi = true;\n          result.codepage = util.getCodepage();\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        result.release = result.kernel;\n        exec('uname -o', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.distro = lines[0];\n          result.logofile = getLogoFile(result.distro);\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        result.logofile = getLogoFile();\n        result.release = result.kernel;\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl'));\n          workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n            result.distro = util.getValue(lines, 'Caption', ':').trim();\n            result.serial = util.getValue(lines, 'SerialNumber', ':').trim();\n            result.build = util.getValue(lines, 'BuildNumber', ':').trim();\n            result.servicepack = util.getValue(lines, 'ServicePackMajorVersion', ':').trim() + '.' + util.getValue(lines, 'ServicePackMinorVersion', ':').trim();\n            result.codepage = util.getCodepage();\n            const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : '';\n            result.hypervisor = hyperv.indexOf('true') !== -1;\n            const term = data.results[2] ? data.results[2].toString() : '';\n            result.remoteSession = (term.toString().toLowerCase().indexOf('true') >= 0);\n            isUefiWindows().then(uefi => {\n              result.uefi = uefi;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.osInfo = osInfo;\n\nfunction isUefiLinux() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      fs.stat('/sys/firmware/efi', function (err) {\n        if (!err) {\n          return resolve(true);\n        } else {\n          exec('dmesg | grep -E \"EFI v\"', function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n');\n              return resolve(lines.length > 0);\n            }\n            return resolve(false);\n          });\n        }\n      });\n    });\n  });\n}\n\nfunction isUefiWindows() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec('findstr /C:\"Detected boot environment\" \"%windir%\\\\Panther\\\\setupact.log\"', util.execOptsWin, function (error, stdout) {\n          if (!error) {\n            const line = stdout.toString().split('\\n\\r')[0];\n            return resolve(line.toLowerCase().indexOf('efi') >= 0);\n          } else {\n            exec('echo %firmware_type%', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                const line = stdout.toString() || '';\n                return resolve(line.toLowerCase().indexOf('efi') >= 0);\n              } else {\n                return resolve(false);\n              }\n            });\n          }\n        });\n      } catch (e) {\n        return resolve(false);\n      }\n    });\n  });\n}\n\nfunction versions(apps, callback) {\n  let versionObject = {\n    kernel: os.release(),\n    openssl: '',\n    systemOpenssl: '',\n    systemOpensslLib: '',\n    node: process.versions.node,\n    v8: process.versions.v8,\n    npm: '',\n    yarn: '',\n    pm2: '',\n    gulp: '',\n    grunt: '',\n    git: '',\n    tsc: '',\n    mysql: '',\n    redis: '',\n    mongodb: '',\n    apache: '',\n    nginx: '',\n    php: '',\n    docker: '',\n    postfix: '',\n    postgresql: '',\n    perl: '',\n    python: '',\n    python3: '',\n    pip: '',\n    pip3: '',\n    java: '',\n    gcc: '',\n    virtualbox: '',\n    bash: '',\n    zsh: '',\n    fish: '',\n    powershell: '',\n    dotnet: ''\n  };\n\n  function checkVersionParam(apps) {\n    if (apps === '*') {\n      return {\n        versions: versionObject,\n        counter: 30\n      };\n    }\n    if (!Array.isArray(apps)) {\n      apps = apps.trim().toLowerCase().replace(/,+/g, '|').replace(/ /g, '|');\n      apps = apps.split('|');\n      const result = {\n        versions: {},\n        counter: 0\n      };\n      apps.forEach(el => {\n        if (el) {\n          for (let key in versionObject) {\n            if ({}.hasOwnProperty.call(versionObject, key)) {\n              if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {\n                result.versions[key] = versionObject[key];\n                if (key === 'openssl') {\n                  result.versions.systemOpenssl = '';\n                  result.versions.systemOpensslLib = '';\n                }\n\n                if (!result.versions[key]) { result.counter++; }\n              }\n            }\n          }\n        }\n      });\n      return result;\n    }\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (util.isFunction(apps) && !callback) {\n        callback = apps;\n        apps = '*';\n      } else {\n        apps = apps || '*';\n        if (typeof apps !== 'string') {\n          if (callback) { callback({}); }\n          return resolve({});\n        }\n      }\n      const appsObj = checkVersionParam(apps);\n      let totalFunctions = appsObj.counter;\n\n      let functionProcessed = (function () {\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(appsObj.versions);\n            }\n            resolve(appsObj.versions);\n          }\n        };\n      })();\n\n      let cmd = '';\n      try {\n        if ({}.hasOwnProperty.call(appsObj.versions, 'openssl')) {\n          appsObj.versions.openssl = process.versions.openssl;\n          exec('openssl version', function (error, stdout) {\n            if (!error) {\n              let openssl_string = stdout.toString().split('\\n')[0].trim();\n              let openssl = openssl_string.split(' ');\n              appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];\n              appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : 'openssl';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'npm')) {\n          exec('npm -v', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.npm = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pm2')) {\n          cmd = 'pm2';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} -v`, function (error, stdout) {\n            if (!error) {\n              let pm2 = stdout.toString().split('\\n')[0].trim();\n              if (!pm2.startsWith('[PM2]')) {\n                appsObj.versions.pm2 = pm2;\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'yarn')) {\n          exec('yarn --version', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.yarn = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gulp')) {\n          cmd = 'gulp';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const gulp = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.gulp = (gulp.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'tsc')) {\n          cmd = 'tsc';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const tsc = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.tsc = (tsc.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'grunt')) {\n          cmd = 'grunt';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const grunt = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.grunt = (grunt.toLowerCase().split('cli v')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'git')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/git') || fs.existsSync('/opt/homebrew/bin/git');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('git --version', function (error, stdout) {\n                if (!error) {\n                  let git = stdout.toString().split('\\n')[0] || '';\n                  git = (git.toLowerCase().split('version')[1] || '').trim();\n                  appsObj.versions.git = (git.split(' ')[0] || '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('git --version', function (error, stdout) {\n              if (!error) {\n                let git = stdout.toString().split('\\n')[0] || '';\n                git = (git.toLowerCase().split('version')[1] || '').trim();\n                appsObj.versions.git = (git.split(' ')[0] || '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'apache')) {\n          exec('apachectl -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const apache = (stdout.toString().split('\\n')[0] || '').split(':');\n              appsObj.versions.apache = (apache.length > 1 ? apache[1].replace('Apache', '').replace('/', '').split('(')[0].trim() : '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'nginx')) {\n          exec('nginx -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const nginx = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.nginx = (nginx.toLowerCase().split('/')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mysql')) {\n          exec('mysql -V', function (error, stdout) {\n            if (!error) {\n              let mysql = stdout.toString().split('\\n')[0] || '';\n              mysql = mysql.toLowerCase();\n              if (mysql.indexOf(',') > -1) {\n                mysql = (mysql.split(',')[0] || '').trim();\n                const parts = mysql.split(' ');\n                appsObj.versions.mysql = (parts[parts.length - 1] || '').trim();\n              } else {\n                if (mysql.indexOf(' ver ') > -1) {\n                  mysql = mysql.split(' ver ')[1];\n                  appsObj.versions.mysql = mysql.split(' ')[0];\n                }\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'php')) {\n          exec('php -v', function (error, stdout) {\n            if (!error) {\n              const php = stdout.toString().split('\\n')[0] || '';\n              let parts = php.split('(');\n              if (parts[0].indexOf('-')) {\n                parts = parts[0].split('-');\n              }\n              appsObj.versions.php = parts[0].replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'redis')) {\n          exec('redis-server --version', function (error, stdout) {\n            if (!error) {\n              const redis = stdout.toString().split('\\n')[0] || '';\n              const parts = redis.split(' ');\n              appsObj.versions.redis = util.getValue(parts, 'v', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'docker')) {\n          exec('docker --version', function (error, stdout) {\n            if (!error) {\n              const docker = stdout.toString().split('\\n')[0] || '';\n              const parts = docker.split(' ');\n              appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(',') ? parts[2].slice(0, -1) : '';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postfix')) {\n          exec('postconf -d | grep mail_version', function (error, stdout) {\n            if (!error) {\n              const postfix = stdout.toString().split('\\n') || [];\n              appsObj.versions.postfix = util.getValue(postfix, 'mail_version', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mongodb')) {\n          exec('mongod --version', function (error, stdout) {\n            if (!error) {\n              const mongodb = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.mongodb = (mongodb.toLowerCase().split(',')[0] || '').replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postgresql')) {\n          if (_linux) {\n            exec('locate bin/postgres', function (error, stdout) {\n              if (!error) {\n                const postgresqlBin = stdout.toString().split('\\n').sort();\n                if (postgresqlBin.length) {\n                  exec(postgresqlBin[postgresqlBin.length - 1] + ' -V', function (error, stdout) {\n                    if (!error) {\n                      const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    }\n                    functionProcessed();\n                  });\n                } else {\n                  functionProcessed();\n                }\n              } else {\n                exec('psql -V', function (error, stdout) {\n                  if (!error) {\n                    const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    appsObj.versions.postgresql = appsObj.versions.postgresql.split('-')[0];\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            if (_windows) {\n              util.powerShell('Get-CimInstance Win32_Service | select caption | fl').then((stdout) => {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((item) => {\n                  if (item.trim() !== '') {\n                    let lines = item.trim().split('\\r\\n');\n                    let srvCaption = util.getValue(lines, 'caption', ':', true).toLowerCase();\n                    if (srvCaption.indexOf('postgresql') > -1) {\n                      const parts = srvCaption.split(' server ');\n                      if (parts.length > 1) {\n                        appsObj.versions.postgresql = parts[1];\n                      }\n                    }\n                  }\n                });\n                functionProcessed();\n              });\n            } else {\n              exec('postgres -V', function (error, stdout) {\n                if (!error) {\n                  const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                  appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                }\n                functionProcessed();\n              });\n            }\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'perl')) {\n          exec('perl -v', function (error, stdout) {\n            if (!error) {\n              const perl = stdout.toString().split('\\n') || '';\n              while (perl.length > 0 && perl[0].trim() === '') {\n                perl.shift();\n              }\n              if (perl.length > 0) {\n                appsObj.versions.perl = perl[0].split('(').pop().split(')')[0].replace('v', '');\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python')) {\n          if (_darwin) {\n            const stdout = execSync('sw_vers');\n            const lines = stdout.toString().split('\\n');\n            const osVersion = util.getValue(lines, 'ProductVersion', ':');\n            const gitHomebrewExists1 = fs.existsSync('/usr/local/Cellar/python');\n            const gitHomebrewExists2 = fs.existsSync('/opt/homebrew/bin/python');\n            if ((util.darwinXcodeExists() && util.semverCompare('12.0.1', osVersion) < 0) || gitHomebrewExists1 || gitHomebrewExists2) {\n              const cmd = gitHomebrewExists1 ? '/usr/local/Cellar/python -V 2>&1' : (gitHomebrewExists2 ? '/opt/homebrew/bin/python -V 2>&1' : 'python -V 2>&1');\n              exec(cmd, function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/python3') || fs.existsSync('/opt/homebrew/bin/python3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('python3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip') || fs.existsSync('/opt/homebrew/bin/pip');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip3') || fs.existsSync('/opt/homebrew/bin/pip3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'java')) {\n          if (_darwin) {\n            // check if any JVM is installed but avoid dialog box that Java needs to be installed\n            exec('/usr/libexec/java_home -V 2>&1', function (error, stdout) {\n              if (!error && stdout.toString().toLowerCase().indexOf('no java runtime') === -1) {\n                // now this can be done savely\n                exec('java -version 2>&1', function (error, stdout) {\n                  if (!error) {\n                    const java = stdout.toString().split('\\n')[0] || '';\n                    const parts = java.split('\"');\n                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n                  }\n                  functionProcessed();\n                });\n              } else {\n                functionProcessed();\n              }\n            });\n          } else {\n            exec('java -version 2>&1', function (error, stdout) {\n              if (!error) {\n                const java = stdout.toString().split('\\n')[0] || '';\n                const parts = java.split('\"');\n                appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gcc')) {\n          if ((_darwin && util.darwinXcodeExists()) || !_darwin) {\n            exec('gcc -dumpversion', function (error, stdout) {\n              if (!error) {\n                appsObj.versions.gcc = stdout.toString().split('\\n')[0].trim() || '';\n              }\n              if (appsObj.versions.gcc.indexOf('.') > -1) {\n                functionProcessed();\n              } else {\n                exec('gcc --version', function (error, stdout) {\n                  if (!error) {\n                    const gcc = stdout.toString().split('\\n')[0].trim();\n                    if (gcc.indexOf('gcc') > -1 && gcc.indexOf(')') > -1) {\n                      const parts = gcc.split(')');\n                      appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;\n                    }\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'virtualbox')) {\n          exec(util.getVboxmanage() + ' -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const vbox = stdout.toString().split('\\n')[0] || '';\n              const parts = vbox.split('r');\n              appsObj.versions.virtualbox = parts[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'bash')) {\n          exec('bash --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.bash = parts[1].split(' ')[0].split('(')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'zsh')) {\n          exec('zsh --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split('zsh ');\n              if (parts.length > 1) {\n                appsObj.versions.zsh = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'fish')) {\n          exec('fish --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.fish = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'powershell')) {\n          if (_windows) {\n            util.powerShell('$PSVersionTable').then(stdout => {\n              const lines = stdout.toString().split('\\n').map(line => line.replace(/ +/g, ' ').replace(/ +/g, ':'));\n              appsObj.versions.powershell = util.getValue(lines, 'psversion');\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'dotnet')) {\n          if (_windows) {\n            util.powerShell('gci \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\NET Framework Setup\\\\NDP\" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match \"^(?!S)\\\\p{L}\"} | select PSChildName, Version, Release').then(stdout => {\n              const lines = stdout.toString().split('\\r\\n');\n              let dotnet = '';\n              lines.forEach(line => {\n                line = line.replace(/ +/g, ' ');\n                const parts = line.split(' ');\n                dotnet = dotnet || (parts[0].toLowerCase().startsWith('client') && parts.length > 2 ? parts[1].trim() : (parts[0].toLowerCase().startsWith('full') && parts.length > 2 ? parts[1].trim() : ''));\n              });\n              appsObj.versions.dotnet = dotnet.trim();\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n      } catch (e) {\n        if (callback) { callback(appsObj.versions); }\n        resolve(appsObj.versions);\n      }\n    });\n  });\n}\n\nexports.versions = versions;\n\nfunction shell(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        resolve('cmd');\n      } else {\n        let result = '';\n        exec('echo $SHELL', function (error, stdout) {\n          if (!error) {\n            result = stdout.toString().split('\\n')[0];\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.shell = shell;\n\nfunction getUniqueMacAdresses() {\n  let macs = [];\n  try {\n    const ifaces = os.networkInterfaces();\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.mac && details.mac !== '00:00:00:00:00:00') {\n            const mac = details.mac.toLowerCase();\n            if (macs.indexOf(mac) === -1) {\n              macs.push(mac);\n            }\n          }\n        });\n      }\n    }\n    macs = macs.sort(function (a, b) {\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      return 0;\n    });\n  } catch (e) {\n    macs.push('00:00:00:00:00:00');\n  }\n  return macs;\n}\n\nfunction uuid(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        os: '',\n        hardware: '',\n        macs: getUniqueMacAdresses()\n      };\n      let parts;\n\n      if (_darwin) {\n        exec('system_profiler SPHardwareDataType -json', function (error, stdout) {\n          if (!error) {\n            try {\n              const jsonObj = JSON.parse(stdout.toString());\n              if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {\n                const spHardware = jsonObj.SPHardwareDataType[0];\n                result.os = spHardware.platform_UUID.toLowerCase();\n                result.hardware = spHardware.serial_number;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        const cmd = `echo -n \"os: \"; cat /var/lib/dbus/machine-id 2> /dev/null; echo;\necho -n \"os: \"; cat /etc/machine-id 2> /dev/null; echo;\necho -n \"hardware: \"; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'os').toLowerCase();\n          result.hardware = util.getValue(lines, 'hardware').toLowerCase();\n          if (!result.hardware) {\n            const lines = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n            const serial = util.getValue(lines, 'serial');\n            result.hardware = serial || '';\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i kern.hostid kern.hostuuid', function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'kern.hostid', ':').toLowerCase();\n          result.hardware = util.getValue(lines, 'kern.hostuuid', ':').toLowerCase();\n          if (result.os.indexOf('unknown') >= 0) { result.os = ''; }\n          if (result.hardware.indexOf('unknown') >= 0) { result.hardware = ''; }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let sysdir = '%windir%\\\\System32';\n        if (process.arch === 'ia32' && Object.prototype.hasOwnProperty.call(process.env, 'PROCESSOR_ARCHITEW6432')) {\n          sysdir = '%windir%\\\\sysnative\\\\cmd.exe /c %windir%\\\\System32';\n        }\n        util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl').then((stdout) => {\n          let lines = stdout.split('\\r\\n');\n          result.hardware = util.getValue(lines, 'uuid', ':').toLowerCase();\n          exec(`${sysdir}\\\\reg query \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\" /v MachineGuid`, util.execOptsWin, function (error, stdout) {\n            parts = stdout.toString().split('\\n\\r')[0].split('REG_SZ');\n            result.os = parts.length > 1 ? parts[1].replace(/\\r+|\\n+|\\s+/ig, '').toLowerCase() : '';\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        });\n      }\n    });\n  });\n}\n\nexports.uuid = uuid;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// printers.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 15. printers\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst winPrinterStatus = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Idle',\n  4: 'Printing',\n  5: 'Warmup',\n  6: 'Stopped Printing',\n  7: 'Offline',\n};\n\nfunction parseLinuxCupsHeader(lines) {\n  const result = {};\n  if (lines && lines.length) {\n    if (lines[0].indexOf(' CUPS v') > 0) {\n      const parts = lines[0].split(' CUPS v');\n      result.cupsVersion = parts[1];\n    }\n  }\n  return result;\n}\n\nfunction parseLinuxCupsPrinter(lines) {\n  const result = {};\n  const printerId = util.getValue(lines, 'PrinterId', ' ');\n  result.id = printerId ? parseInt(printerId, 10) : null;\n  result.name = util.getValue(lines, 'Info', ' ');\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = util.getValue(lines, 'DeviceURI', ' ');\n  result.uuid = util.getValue(lines, 'UUID', ' ');\n  result.status = util.getValue(lines, 'State', ' ');\n  result.local = util.getValue(lines, 'Location', ' ').toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseLinuxLpstatPrinter(lines, id) {\n  const result = {};\n  result.id = id;\n  result.name = util.getValue(lines, 'Description', ':', true);\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = null;\n  result.uuid = null;\n  result.status = lines.length > 0 && lines[0] ? (lines[0].indexOf(' idle') > 0 ? 'idle' : (lines[0].indexOf(' printing') > 0 ? 'printing' : 'unknown')) : null;\n  result.local = util.getValue(lines, 'Location', ':', true).toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseDarwinPrinters(printerObject, id) {\n  const result = {};\n  const uriParts = printerObject.uri.split('/');\n  result.id = id;\n  result.name = printerObject._name;\n  result.model = uriParts.length ? uriParts[uriParts.length - 1] : '';\n  result.uri = printerObject.uri;\n  result.uuid = null;\n  result.status = printerObject.status;\n  result.local = printerObject.printserver === 'local';\n  result.default = printerObject.default === 'yes';\n  result.shared = printerObject.shared === 'yes';\n\n  return result;\n}\n\nfunction parseWindowsPrinters(lines, id) {\n  const result = {};\n  const status = parseInt(util.getValue(lines, 'PrinterStatus', ':'), 10);\n\n  result.id = id;\n  result.name = util.getValue(lines, 'name', ':');\n  result.model = util.getValue(lines, 'DriverName', ':');\n  result.uri = null;\n  result.uuid = null;\n  result.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;\n  result.local = util.getValue(lines, 'Local', ':').toUpperCase() === 'TRUE';\n  result.default = util.getValue(lines, 'Default', ':').toUpperCase() === 'TRUE';\n  result.shared = util.getValue(lines, 'Shared', ':').toUpperCase() === 'TRUE';\n\n  return result;\n}\n\nfunction printer(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'cat /etc/cups/printers.conf 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // printers.conf\n          if (!error) {\n            const parts = stdout.toString().split('<Printer ');\n            const printerHeader = parseLinuxCupsHeader(parts[0]);\n            for (let i = 1; i < parts.length; i++) {\n              const printers = parseLinuxCupsPrinter(parts[i].split('\\n'));\n              if (printers.name) {\n                printers.engine = 'CUPS';\n                printers.engineVersion = printerHeader.cupsVersion;\n                result.push(printers);\n              }\n            }\n          }\n          if (result.length === 0) {\n            if (_linux) {\n              cmd = 'export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL';\n              // lpstat\n              exec(cmd, function (error, stdout) {\n                const parts = ('\\n' + stdout.toString()).split('\\nprinter ');\n                for (let i = 1; i < parts.length; i++) {\n                  const printers = parseLinuxLpstatPrinter(parts[i].split('\\n'), i);\n                  result.push(printers);\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } else {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPPrintersDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {\n                for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {\n                  const printer = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);\n                  result.push(printer);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const printer = parseWindowsPrinters(parts[i].split('\\n'), i);\n              if (printer.name || printer.model) {\n                result.push(printer);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.printer = printer;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// processes.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 10. Processes\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst _processes_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _services_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _process_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\n\nconst _winStatusValues = {\n  '0': 'unknown',\n  '1': 'other',\n  '2': 'ready',\n  '3': 'running',\n  '4': 'blocked',\n  '5': 'suspended blocked',\n  '6': 'suspended ready',\n  '7': 'terminated',\n  '8': 'stopped',\n  '9': 'growing',\n};\n\nfunction parseTimeUnix(time) {\n  let result = time;\n  let parts = time.replace(/ +/g, ' ').split(' ');\n  if (parts.length === 5) {\n    result = parts[4] + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + parts[2]).slice(-2) + ' ' + parts[3];\n  }\n  return result;\n}\n\nfunction parseElapsedTime(etime) {\n  let current = new Date();\n  current = new Date(current.getTime() - current.getTimezoneOffset() * 60000);\n\n  const elapsed = etime.split('-');\n\n  const timeIndex = elapsed.length - 1;\n  const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;\n\n  const timeStr = elapsed[timeIndex].split(':');\n  const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;\n  const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);\n  const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);\n  const ms = (((((days * 24 + hours) * 60) + mins) * 60 + secs) * 1000);\n\n  let res = new Date(current.getTime());\n  let result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  try {\n    res = new Date(current.getTime() - ms);\n    result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\n// --------------------------\n// PS - services\n// pass a comma separated string with services to check (mysql, apache, postgresql, ...)\n// this function gives an array back, if the services are running.\n\nfunction services(srv, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(srv) && !callback) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof srv !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      if (srv) {\n        let srvString = '';\n        srvString.__proto__.toLowerCase = util.stringToLower;\n        srvString.__proto__.replace = util.stringReplace;\n        srvString.__proto__.trim = util.stringTrim;\n\n        const s = util.sanitizeShellString(srv);\n        for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n          if (s[i] !== undefined) {\n            srvString = srvString + s[i];\n          }\n        }\n\n        srvString = srvString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n        if (srvString === '') {\n          srvString = '*';\n        }\n        if (util.isPrototypePolluted() && srvString !== '*') {\n          srvString = '------';\n        }\n        let srvs = srvString.split('|');\n        let result = [];\n        let dataSrv = [];\n\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n          if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === '*') {\n            try {\n              const tmpsrv = execSync('systemctl --all --type=service --no-legend 2> /dev/null').toString().split('\\n');\n              srvs = [];\n              for (const s of tmpsrv) {\n                const name = s.split('.service')[0];\n                if (name && s.indexOf(' not-found ') === -1) {\n                  srvs.push(name.trim());\n                }\n              }\n              srvString = srvs.join('|');\n            } catch (d) {\n              try {\n                srvString = '';\n                const tmpsrv = execSync('service --status-all 2> /dev/null').toString().split('\\n');\n                for (const s of tmpsrv) {\n                  const parts = s.split(']');\n                  if (parts.length === 2) {\n                    srvString += (srvString !== '' ? '|' : '') + parts[1].trim();\n                  }\n                }\n                srvs = srvString.split('|');\n              } catch (e) {\n                try {\n                  const srvStr = execSync('ls /etc/init.d/ -m 2> /dev/null').toString().split('\\n').join('');\n                  srvString = '';\n                  if (srvStr) {\n                    const tmpsrv = srvStr.split(',');\n                    for (const s of tmpsrv) {\n                      const name = s.trim();\n                      if (name) {\n                        srvString += (srvString !== '' ? '|' : '') + name;\n                      }\n                    }\n                    srvs = srvString.split('|');\n                  }\n                } catch (f) {\n                  srvString = '';\n                  srvs = [];\n                }\n              }\n            }\n          }\n          if ((_darwin) && srvString === '*') { // service enumeration not yet suported on mac OS\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n          let args = (_darwin) ? ['-caxo', 'pcpu,pmem,pid,command'] : ['-axo', 'pcpu,pmem,pid,command'];\n          if (srvString !== '' && srvs.length > 0) {\n            util.execSafe('ps', args).then((stdout) => {\n              if (stdout) {\n                let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                srvs.forEach(function (srv) {\n                  let ps;\n                  if (_darwin) {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(srv) !== -1);\n                    });\n\n                  } else {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(' ' + srv + ':') !== -1) || (e.toLowerCase().indexOf('/' + srv) !== -1);\n                    });\n                  }\n                  const pids = [];\n                  for (const p of ps) {\n                    const pid = p.trim().split(' ')[2];\n                    if (pid) {\n                      pids.push(parseInt(pid, 10));\n                    }\n                  }\n                  result.push({\n                    name: srv,\n                    running: ps.length > 0,\n                    startmode: '',\n                    pids: pids,\n                    cpu: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[0]);\n                    }, 0)).toFixed(2)),\n                    mem: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[1]);\n                    }, 0)).toFixed(2))\n                  });\n                });\n                if (_linux) {\n                  // calc process_cpu - ps is not accurate in linux!\n                  let cmd = 'cat /proc/stat | grep \"cpu \"';\n                  for (let i in result) {\n                    for (let j in result[i].pids) {\n                      cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                    }\n                  }\n                  exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                    let curr_processes = stdout.toString().split('\\n');\n\n                    // first line (all - /proc/stat)\n                    let all = parseProcStat(curr_processes.shift());\n\n                    // process\n                    let list_new = {};\n                    let resultProcess = {};\n                    curr_processes.forEach((element) => {\n                      resultProcess = calcProcStatLinux(element, all, _services_cpu);\n\n                      if (resultProcess.pid) {\n                        let listPos = -1;\n                        for (let i in result) {\n                          for (let j in result[i].pids) {\n                            if (parseInt(result[i].pids[j]) === parseInt(resultProcess.pid)) {\n                              listPos = i;\n                            }\n                          }\n                        }\n                        if (listPos >= 0) {\n                          result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                        }\n\n                        // save new values\n                        list_new[resultProcess.pid] = {\n                          cpuu: resultProcess.cpuu,\n                          cpus: resultProcess.cpus,\n                          utime: resultProcess.utime,\n                          stime: resultProcess.stime,\n                          cutime: resultProcess.cutime,\n                          cstime: resultProcess.cstime\n                        };\n                      }\n                    });\n\n                    // store old values\n                    _services_cpu.all = all;\n                    _services_cpu.list = Object.assign({}, list_new);\n                    _services_cpu.ms = Date.now() - _services_cpu.ms;\n                    _services_cpu.result = Object.assign({}, result);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              } else {\n                args = ['-o', 'comm'];\n                util.execSafe('ps', args).then((stdout) => {\n                  if (stdout) {\n                    let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                    srvs.forEach(function (srv) {\n                      let ps = lines.filter(function (e) {\n                        return e.indexOf(srv) !== -1;\n                      });\n                      result.push({\n                        name: srv,\n                        running: ps.length > 0,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  } else {\n                    srvs.forEach(function (srv) {\n                      result.push({\n                        name: srv,\n                        running: false,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  }\n                });\n              }\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n        if (_windows) {\n          try {\n            let wincommand = 'Get-CimInstance Win32_Service';\n            if (srvs[0] !== '*') {\n              wincommand += ' -Filter \"';\n              srvs.forEach((srv) => {\n                wincommand += `Name='${srv}' or `;\n              });\n              wincommand = `${wincommand.slice(0, -4)}\"`;\n            }\n            wincommand += ' | select Name,Caption,Started,StartMode,ProcessId | fl';\n            util.powerShell(wincommand).then((stdout, error) => {\n              if (!error) {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let srvName = util.getValue(lines, 'Name', ':', true).toLowerCase();\n                    let srvCaption = util.getValue(lines, 'Caption', ':', true).toLowerCase();\n                    let started = util.getValue(lines, 'Started', ':', true);\n                    let startMode = util.getValue(lines, 'StartMode', ':', true);\n                    let pid = util.getValue(lines, 'ProcessId', ':', true);\n                    if (srvString === '*' || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {\n                      result.push({\n                        name: srvName,\n                        running: (started.toLowerCase() === 'true'),\n                        startmode: startMode,\n                        pids: [pid],\n                        cpu: 0,\n                        mem: 0\n                      });\n                      dataSrv.push(srvName);\n                      dataSrv.push(srvCaption);\n                    }\n                  }\n\n                });\n\n                if (srvString !== '*') {\n                  let srvsMissing = srvs.filter(function (e) {\n                    return dataSrv.indexOf(e) === -1;\n                  });\n                  srvsMissing.forEach(function (srvName) {\n                    result.push({\n                      name: srvName,\n                      running: false,\n                      startmode: '',\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              } else {\n                srvs.forEach(function (srvName) {\n                  result.push({\n                    name: srvName,\n                    running: false,\n                    startmode: '',\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) { callback([]); }\n        resolve([]);\n      }\n    });\n  });\n}\n\nexports.services = services;\n\nfunction parseProcStat(line) {\n  let parts = line.replace(/ +/g, ' ').split(' ');\n  let user = (parts.length >= 2 ? parseInt(parts[1]) : 0);\n  let nice = (parts.length >= 3 ? parseInt(parts[2]) : 0);\n  let system = (parts.length >= 4 ? parseInt(parts[3]) : 0);\n  let idle = (parts.length >= 5 ? parseInt(parts[4]) : 0);\n  let iowait = (parts.length >= 6 ? parseInt(parts[5]) : 0);\n  let irq = (parts.length >= 7 ? parseInt(parts[6]) : 0);\n  let softirq = (parts.length >= 8 ? parseInt(parts[7]) : 0);\n  let steal = (parts.length >= 9 ? parseInt(parts[8]) : 0);\n  let guest = (parts.length >= 10 ? parseInt(parts[9]) : 0);\n  let guest_nice = (parts.length >= 11 ? parseInt(parts[10]) : 0);\n  return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;\n}\n\nfunction calcProcStatLinux(line, all, _cpu_old) {\n  let statparts = line.replace(/ +/g, ' ').split(')');\n  if (statparts.length >= 2) {\n    let parts = statparts[1].split(' ');\n    if (parts.length >= 16) {\n      let pid = parseInt(statparts[0].split(' ')[0]);\n      let utime = parseInt(parts[12]);\n      let stime = parseInt(parts[13]);\n      let cutime = parseInt(parts[14]);\n      let cstime = parseInt(parts[15]);\n\n      // calc\n      let cpuu = 0;\n      let cpus = 0;\n      if (_cpu_old.all > 0 && _cpu_old.list[pid]) {\n        cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100; // user\n        cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100; // system\n      } else {\n        cpuu = (utime + cutime) / (all) * 100; // user\n        cpus = (stime + cstime) / (all) * 100; // system\n      }\n      return {\n        pid: pid,\n        utime: utime,\n        stime: stime,\n        cutime: cutime,\n        cstime: cstime,\n        cpuu: cpuu,\n        cpus: cpus\n      };\n    } else {\n      return {\n        pid: 0,\n        utime: 0,\n        stime: 0,\n        cutime: 0,\n        cstime: 0,\n        cpuu: 0,\n        cpus: 0\n      };\n    }\n  } else {\n    return {\n      pid: 0,\n      utime: 0,\n      stime: 0,\n      cutime: 0,\n      cstime: 0,\n      cpuu: 0,\n      cpus: 0\n    };\n  }\n}\n\nfunction calcProcStatWin(procStat, all, _cpu_old) {\n  // calc\n  let cpuu = 0;\n  let cpus = 0;\n  if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {\n    cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100; // user\n    cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100; // system\n  } else {\n    cpuu = (procStat.utime) / (all) * 100; // user\n    cpus = (procStat.stime) / (all) * 100; // system\n  }\n  return {\n    pid: procStat.pid,\n    utime: procStat.utime,\n    stime: procStat.stime,\n    cpuu: cpuu > 0 ? cpuu : 0,\n    cpus: cpus > 0 ? cpus : 0\n  };\n}\n\n\n\n// --------------------------\n// running processes\n\nfunction processes(callback) {\n\n  let parsedhead = [];\n\n  function getName(command) {\n    command = command || '';\n    let result = command.split(' ')[0];\n    if (result.substr(-1) === ':') {\n      result = result.substr(0, result.length - 1);\n    }\n    if (result.substr(0, 1) !== '[') {\n      let parts = result.split('/');\n      if (isNaN(parseInt(parts[parts.length - 1]))) {\n        result = parts[parts.length - 1];\n      } else {\n        result = parts[0];\n      }\n    }\n    return result;\n  }\n\n  function parseLine(line) {\n\n    let offset = 0;\n    let offset2 = 0;\n\n    function checkColumn(i) {\n      offset = offset2;\n      if (parsedhead[i]) {\n        offset2 = line.substring(parsedhead[i].to + offset, 10000).indexOf(' ');\n      } else {\n        offset2 = 10000;\n      }\n    }\n\n    checkColumn(0);\n    const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));\n    checkColumn(1);\n    const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));\n    checkColumn(2);\n    const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, '.'));\n    checkColumn(3);\n    const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, '.'));\n    checkColumn(4);\n    const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));\n    checkColumn(5);\n    const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));\n    checkColumn(6);\n    const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));\n    checkColumn(7);\n    const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;\n    checkColumn(8);\n    const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());\n    checkColumn(9);\n    let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();\n    state = (state[0] === 'R' ? 'running' : (state[0] === 'S' ? 'sleeping' : (state[0] === 'T' ? 'stopped' : (state[0] === 'W' ? 'paging' : (state[0] === 'X' ? 'dead' : (state[0] === 'Z' ? 'zombie' : ((state[0] === 'D' || state[0] === 'U') ? 'blocked' : 'unknown')))))));\n    checkColumn(10);\n    let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();\n    if (tty === '?' || tty === '??') { tty = ''; }\n    checkColumn(11);\n    const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();\n    checkColumn(12);\n    let cmdPath = '';\n    let command = '';\n    let params = '';\n    let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();\n    if (fullcommand.substr(fullcommand.length - 1) === ']') { fullcommand = fullcommand.slice(0, -1); }\n    if (fullcommand.substr(0, 1) === '[') { command = fullcommand.substring(1); }\n    else {\n      const p1 = fullcommand.indexOf('(');\n      const p2 = fullcommand.indexOf(')');\n      const p3 = fullcommand.indexOf('/');\n      const p4 = fullcommand.indexOf(':');\n      if (p1 < p2 && p1 < p3 && p3 < p2) {\n        command = fullcommand.split(' ')[0];\n        command = command.replace(/:/g, '');\n      } else {\n        if (p4 > 0 && (p3 === -1 || p3 > 3)) {\n          command = fullcommand.split(' ')[0];\n          command = command.replace(/:/g, '');\n        } else {\n          // try to figure out where parameter starts\n          let firstParamPos = fullcommand.indexOf(' -');\n          let firstParamPathPos = fullcommand.indexOf(' /');\n          firstParamPos = (firstParamPos >= 0 ? firstParamPos : 10000);\n          firstParamPathPos = (firstParamPathPos >= 0 ? firstParamPathPos : 10000);\n          const firstPos = Math.min(firstParamPos, firstParamPathPos);\n          let tmpCommand = fullcommand.substr(0, firstPos);\n          const tmpParams = fullcommand.substr(firstPos);\n          const lastSlashPos = tmpCommand.lastIndexOf('/');\n          if (lastSlashPos >= 0) {\n            cmdPath = tmpCommand.substr(0, lastSlashPos);\n            tmpCommand = tmpCommand.substr(lastSlashPos + 1);\n          }\n\n          if (firstPos === 10000 && tmpCommand.indexOf(' ') > -1) {\n            const parts = tmpCommand.split(' ');\n            if (fs.existsSync(path.join(cmdPath, parts[0]))) {\n              command = parts.shift();\n              params = (parts.join(' ') + ' ' + tmpParams).trim();\n            } else {\n              command = tmpCommand.trim();\n              params = tmpParams.trim();\n            }\n          } else {\n            command = tmpCommand.trim();\n            params = tmpParams.trim();\n          }\n        }\n      }\n\n    }\n\n    return ({\n      pid: pid,\n      parentPid: ppid,\n      name: _linux ? getName(command) : command,\n      cpu: cpu,\n      cpuu: 0,\n      cpus: 0,\n      mem: mem,\n      priority: priority,\n      memVsz: vsz,\n      memRss: rss,\n      nice: nice,\n      started: started,\n      state: state,\n      tty: tty,\n      user: user,\n      command: command,\n      params: params,\n      path: cmdPath\n    });\n  }\n\n  function parseProcesses(lines) {\n    let result = [];\n    if (lines.length > 1) {\n      let head = lines[0];\n      parsedhead = util.parseHead(head, 8);\n      lines.shift();\n      lines.forEach(function (line) {\n        if (line.trim() !== '') {\n          result.push(parseLine(line));\n        }\n      });\n    }\n    return result;\n  }\n  function parseProcesses2(lines) {\n\n    function formatDateTime(time) {\n      const month = ('0' + (time.getMonth() + 1).toString()).slice(-2);\n      const year = time.getFullYear().toString();\n      const day = ('0' + time.getDate().toString()).slice(-2);\n      const hours = ('0' + time.getHours().toString()).slice(-2);\n      const mins = ('0' + time.getMinutes().toString()).slice(-2);\n      const secs = ('0' + time.getSeconds().toString()).slice(-2);\n\n      return (year + '-' + month + '-' + day + ' ' + hours + ':' + mins + ':' + secs);\n    }\n\n    function parseElapsed(etime) {\n      let started = '';\n      if (etime.indexOf('d') >= 0) {\n        const elapsed_parts = etime.split('d');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1000));\n      } else if (etime.indexOf('h') >= 0) {\n        const elapsed_parts = etime.split('h');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1000));\n      } else if (etime.indexOf(':') >= 0) {\n        const elapsed_parts = etime.split(':');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));\n      }\n      return started;\n    }\n\n    let result = [];\n    lines.forEach(function (line) {\n      if (line.trim() !== '') {\n        line = line.trim().replace(/ +/g, ' ').replace(/,+/g, '.');\n        const parts = line.split(' ');\n        const command = parts.slice(9).join(' ');\n        const pmem = parseFloat((1.0 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));\n        const started = parseElapsed(parts[5]);\n\n        result.push({\n          pid: parseInt(parts[0]),\n          parentPid: parseInt(parts[1]),\n          name: getName(command),\n          cpu: 0,\n          cpuu: 0,\n          cpus: 0,\n          mem: pmem,\n          priority: 0,\n          memVsz: parseInt(parts[2]),\n          memRss: parseInt(parts[3]),\n          nice: parseInt(parts[4]),\n          started: started,\n          state: (parts[6] === 'R' ? 'running' : (parts[6] === 'S' ? 'sleeping' : (parts[6] === 'T' ? 'stopped' : (parts[6] === 'W' ? 'paging' : (parts[6] === 'X' ? 'dead' : (parts[6] === 'Z' ? 'zombie' : ((parts[6] === 'D' || parts[6] === 'U') ? 'blocked' : 'unknown'))))))),\n          tty: parts[7],\n          user: parts[8],\n          command: command\n        });\n      }\n    });\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        all: 0,\n        running: 0,\n        blocked: 0,\n        sleeping: 0,\n        unknown: 0,\n        list: []\n      };\n\n      let cmd = '';\n\n      if ((_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500) || _processes_cpu.ms === 0) {\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n          if (_linux) { cmd = 'export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL'; }\n          if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL'; }\n          if (_darwin) { cmd = 'ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r'; }\n          if (_sunos) { cmd = 'ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm'; }\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error && stdout.toString().trim()) {\n              result.list = (parseProcesses(stdout.toString().split('\\n'))).slice();\n              result.all = result.list.length;\n              result.running = result.list.filter(function (e) {\n                return e.state === 'running';\n              }).length;\n              result.blocked = result.list.filter(function (e) {\n                return e.state === 'blocked';\n              }).length;\n              result.sleeping = result.list.filter(function (e) {\n                return e.state === 'sleeping';\n              }).length;\n\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                cmd = 'cat /proc/stat | grep \"cpu \"';\n                result.list.forEach((element) => {\n                  cmd += (';cat /proc/' + element.pid + '/stat');\n                });\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _processes_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // store pcpu in outer array\n                      let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                      if (listPos >= 0) {\n                        result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                        result.list[listPos].cpuu = resultProcess.cpuu;\n                        result.list[listPos].cpus = resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  // store old values\n                  _processes_cpu.all = all;\n                  _processes_cpu.list = Object.assign({}, list_new);\n                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                  _processes_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm';\n              if (_sunos) {\n                cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm';\n              }\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.shift();\n\n                  result.list = parseProcesses2(lines).slice();\n                  result.all = result.list.length;\n                  result.running = result.list.filter(function (e) {\n                    return e.state === 'running';\n                  }).length;\n                  result.blocked = result.list.filter(function (e) {\n                    return e.state === 'blocked';\n                  }).length;\n                  result.sleeping = result.list.filter(function (e) {\n                    return e.state === 'sleeping';\n                  }).length;\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            }\n          });\n        } else if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n=\"CreationDate\";e={$_.CreationDate.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procs = [];\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let parentPid = parseInt(util.getValue(lines, 'ParentProcessId', ':', true), 10);\n                    let statusValue = util.getValue(lines, 'ExecutionState', ':');\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let commandLine = util.getValue(lines, 'CommandLine', ':', true);\n                    // get additional command line data\n                    let additionalCommand = false;\n                    lines.forEach((line) => {\n                      if (additionalCommand && line.toLowerCase().startsWith(' ')) {\n                        commandLine += ' ' + line.trim();\n                      } else {\n                        additionalCommand = false;\n                      }\n                      if (line.toLowerCase().startsWith('commandline')) {\n                        additionalCommand = true;\n                      }\n                    });\n                    let commandPath = util.getValue(lines, 'ExecutablePath', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let memw = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n                    result.all++;\n                    if (!statusValue) { result.unknown++; }\n                    if (statusValue === '3') { result.running++; }\n                    if (statusValue === '4' || statusValue === '5') { result.blocked++; }\n\n                    procStats.push({\n                      pid: pid,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                    });\n                    procs.push({\n                      pid: pid,\n                      parentPid: parentPid,\n                      name: name,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem: memw / os.totalmem() * 100,\n                      priority: parseInt(util.getValue(lines, 'Priority', ':', true), 10),\n                      memVsz: parseInt(util.getValue(lines, 'PageFileUsage', ':', true), 10),\n                      memRss: Math.floor(parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10) / 1024),\n                      nice: 0,\n                      started: util.getValue(lines, 'CreationDate', ':', true),\n                      state: (!statusValue ? _winStatusValues[0] : _winStatusValues[statusValue]),\n                      tty: '',\n                      user: '',\n                      command: commandLine || name,\n                      path: commandPath,\n                      params: ''\n                    });\n                  }\n                });\n\n                result.sleeping = result.all - result.running - result.blocked - result.unknown;\n                result.list = procs;\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);\n\n                  // store pcpu in outer array\n                  let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                  if (listPos >= 0) {\n                    result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                    result.list[listPos].cpuu = resultProcess.cpuu;\n                    result.list[listPos].cpus = resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _processes_cpu.all = allcpuu + allcpus;\n                _processes_cpu.all_utime = allcpuu;\n                _processes_cpu.all_stime = allcpus;\n                _processes_cpu.list = Object.assign({}, list_new);\n                _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                _processes_cpu.result = Object.assign({}, result);\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } else {\n        if (callback) { callback(_processes_cpu.result); }\n        resolve(_processes_cpu.result);\n      }\n    });\n  });\n}\n\nexports.processes = processes;\n\n// --------------------------\n// PS - process load\n// get detailed information about a certain process\n// (PID, CPU-Usage %, Mem-Usage %)\n\nfunction processLoad(proc, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(proc) && !callback) {\n    callback = proc;\n    proc = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      proc = proc || '';\n\n      if (typeof proc !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      let processesString = '';\n      processesString.__proto__.toLowerCase = util.stringToLower;\n      processesString.__proto__.replace = util.stringReplace;\n      processesString.__proto__.trim = util.stringTrim;\n\n      const s = util.sanitizeShellString(proc);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          processesString = processesString + s[i];\n        }\n      }\n\n      processesString = processesString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n      if (processesString === '') {\n        processesString = '*';\n      }\n      if (util.isPrototypePolluted() && processesString !== '*') {\n        processesString = '------';\n      }\n      let processes = processesString.split('|');\n      let result = [];\n\n      const procSanitized = util.isPrototypePolluted() ? '' : util.sanitizeShellString(proc);\n\n      // from here new\n      // let result = {\n      //   'proc': procSanitized,\n      //   'pid': null,\n      //   'cpu': 0,\n      //   'mem': 0\n      // };\n      if (procSanitized && processes.length && processes[0] !== '------') {\n        if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n\n                // go through all processes\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let mem = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n\n                    procStats.push({\n                      pid: pid,\n                      name,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem\n                    });\n                    let pname = '';\n                    let inList = false;\n                    processes.forEach(function (proc) {\n                      if (name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                        inList = true;\n                        pname = proc;\n                      }\n                    });\n\n                    if (processesString === '*' || inList) {\n                      let processFound = false;\n                      result.forEach(function (item) {\n                        if (item.proc.toLowerCase() === pname.toLowerCase()) {\n                          item.pids.push(pid);\n                          item.mem += mem / os.totalmem() * 100;\n                          processFound = true;\n                        }\n                      });\n                      if (!processFound) {\n                        result.push({\n                          proc: pname,\n                          pid: pid,\n                          pids: [pid],\n                          cpu: 0,\n                          mem: mem / os.totalmem() * 100\n                        });\n                      }\n                    }\n                  }\n                });\n\n                // add missing processes\n                if (processesString !== '*') {\n                  let processesMissing = processes.filter(function (name) {\n                    return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n\n                  });\n                  processesMissing.forEach(function (procName) {\n                    result.push({\n                      proc: procName,\n                      pid: null,\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n\n                // calculate proc stats for each proc\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);\n\n                  let listPos = -1;\n                  for (let j = 0; j < result.length; j++) {\n                    if (result[j].pid === resultProcess.pid || result[j].pids.indexOf(resultProcess.pid) >= 0) { listPos = j; }\n                  }\n                  if (listPos >= 0) {\n                    result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _process_cpu.all = allcpuu + allcpus;\n                _process_cpu.all_utime = allcpuu;\n                _process_cpu.all_stime = allcpus;\n                _process_cpu.list = Object.assign({}, list_new);\n                _process_cpu.ms = Date.now() - _process_cpu.ms;\n                _process_cpu.result = JSON.parse(JSON.stringify(result));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n\n        if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {\n          const params = ['-axo', 'pid,ppid,pcpu,pmem,comm'];\n          util.execSafe('ps', params).then((stdout) => {\n            if (stdout) {\n              let procStats = [];\n              let lines = stdout.toString().split('\\n').filter(function (line) {\n                if (processesString === '*') { return true; }\n                if (line.toLowerCase().indexOf('grep') !== -1) { return false; } // remove this??\n                let found = false;\n                processes.forEach(function (item) {\n                  found = found || (line.toLowerCase().indexOf(item.toLowerCase()) >= 0);\n                });\n                return found;\n              });\n\n              lines.forEach(function (line) {\n                let data = line.trim().replace(/ +/g, ' ').split(' ');\n                if (data.length > 4) {\n                  procStats.push({\n                    name: data[4].substring(data[4].lastIndexOf('/') + 1),\n                    pid: parseInt(data[0]) || 0,\n                    ppid: parseInt(data[1]) || 0,\n                    cpu: parseFloat(data[2].replace(',', '.')),\n                    mem: parseFloat(data[3].replace(',', '.'))\n                  });\n                }\n              });\n\n              procStats.forEach(function (item) {\n                let listPos = -1;\n                let inList = false;\n                let name = '';\n                for (let j = 0; j < result.length; j++) {\n                  if (item.name.toLowerCase().indexOf(result[j].proc.toLowerCase()) >= 0) {\n                    listPos = j;\n                  }\n                }\n                processes.forEach(function (proc) {\n\n                  if (item.name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                    inList = true;\n                    name = proc;\n                  }\n                });\n                if ((processesString === '*') || inList) {\n                  if (listPos < 0) {\n                    result.push({\n                      proc: name,\n                      pid: item.pid,\n                      pids: [item.pid],\n                      cpu: item.cpu,\n                      mem: item.mem\n                    });\n                  } else {\n                    if (item.ppid < 10) {\n                      result[listPos].pid = item.pid;\n                    }\n                    result[listPos].pids.push(item.pid);\n                    result[listPos].cpu += item.cpu;\n                    result[listPos].mem += item.mem;\n                  }\n                }\n              });\n\n              if (processesString !== '*') {\n                // add missing processes\n                let processesMissing = processes.filter(function (name) {\n                  return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n                });\n                processesMissing.forEach(function (procName) {\n                  result.push({\n                    proc: procName,\n                    pid: null,\n                    pids: [],\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n              }\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                result.forEach(function (item) {\n                  item.cpu = 0;\n                });\n                let cmd = 'cat /proc/stat | grep \"cpu \"';\n                for (let i in result) {\n                  for (let j in result[i].pids) {\n                    cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                  }\n                }\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _process_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // find result item\n                      let resultItemId = -1;\n                      for (let i in result) {\n                        if (result[i].pids.indexOf(resultProcess.pid) >= 0) {\n                          resultItemId = i;\n                        }\n                      }\n                      // store pcpu in outer result\n                      if (resultItemId >= 0) {\n                        result[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  result.forEach(function (item) {\n                    item.cpu = Math.round(item.cpu * 100) / 100;\n                  });\n\n                  _process_cpu.all = all;\n                  _process_cpu.list = Object.assign({}, list_new);\n                  _process_cpu.ms = Date.now() - _process_cpu.ms;\n                  _process_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.processLoad = processLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// system.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 2. System (Hardware, BIOS, Base Board)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst os = require('os');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromise = util.promisify(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction system(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: 'Computer',\n        version: '',\n        serial: '-',\n        uuid: '-',\n        sku: '-',\n        virtual: false\n      };\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'manufacturer');\n          result.model = util.getValue(lines, 'product name');\n          result.version = util.getValue(lines, 'version');\n          result.serial = util.getValue(lines, 'serial number');\n          result.uuid = util.getValue(lines, 'uuid').toLowerCase();\n          result.sku = util.getValue(lines, 'sku number');\n          // Non-Root values\n          const cmd = `echo -n \"product_name: \"; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;\n            echo -n \"product_serial: \"; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;\n            echo -n \"product_uuid: \"; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;\n            echo -n \"product_version: \"; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;\n            echo -n \"sys_vendor: \"; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = result.manufacturer === '' ? util.getValue(lines, 'sys_vendor') : result.manufacturer;\n            result.model = result.model === '' ? util.getValue(lines, 'product_name') : result.model;\n            result.version = result.version === '' ? util.getValue(lines, 'product_version') : result.version;\n            result.serial = result.serial === '' ? util.getValue(lines, 'product_serial') : result.serial;\n            result.uuid = result.uuid === '' ? util.getValue(lines, 'product_uuid').toLowerCase() : result.uuid;\n          } catch (e) {\n            util.noop();\n          }\n          if (!result.serial || result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = ''; }\n          if (!result.model || result.model.toLowerCase().indexOf('o.e.m.') !== -1) { result.model = 'Computer'; }\n          if (!result.version || result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = ''; }\n          if (!result.sku || result.sku.toLowerCase().indexOf('o.e.m.') !== -1) { result.sku = '-'; }\n\n          // detect virtual (1)\n          if (result.model.toLowerCase() === 'virtualbox' || result.model.toLowerCase() === 'kvm' || result.model.toLowerCase() === 'virtual machine' || result.model.toLowerCase() === 'bochs' || result.model.toLowerCase().startsWith('vmware') || result.model.toLowerCase().startsWith('droplet')) {\n            result.virtual = true;\n            switch (result.model.toLowerCase()) {\n              case 'virtualbox':\n                result.virtualHost = 'VirtualBox';\n                break;\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'kvm':\n                result.virtualHost = 'KVM';\n                break;\n              case 'bochs':\n                result.virtualHost = 'bochs';\n                break;\n            }\n          }\n          if (result.manufacturer.toLowerCase().startsWith('vmware') || result.manufacturer.toLowerCase() === 'xen') {\n            result.virtual = true;\n            switch (result.manufacturer.toLowerCase()) {\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'xen':\n                result.virtualHost = 'Xen';\n                break;\n            }\n          }\n          if (!result.virtual) {\n            try {\n              const disksById = execSync('ls -1 /dev/disk/by-id/ 2>/dev/null').toString();\n              if (disksById.indexOf('_QEMU_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'QEMU';\n              }\n              if (disksById.indexOf('_VBOX_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'VirtualBox';\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (!result.virtual && (os.release().toLowerCase().indexOf('microsoft') >= 0 || os.release().toLowerCase().endsWith('wsl2'))) {\n            const kernelVersion = parseFloat(os.release().toLowerCase());\n            result.virtual = true;\n            result.manufacturer = 'Microsoft';\n            result.model = 'WSL';\n            result.version = kernelVersion < 4.19 ? '1' : '2';\n          }\n          if ((_freebsd || _openbsd || _netbsd) && !result.virtualHost) {\n            try {\n              const procInfo = execSync('dmidecode -t 4');\n              const procLines = procInfo.toString().split('\\n');\n              const procManufacturer = util.getValue(procLines, 'manufacturer', ':', true);\n              switch (procManufacturer.toLowerCase()) {\n                case 'virtualbox':\n                  result.virtualHost = 'VirtualBox';\n                  break;\n                case 'vmware':\n                  result.virtualHost = 'VMware';\n                  break;\n                case 'kvm':\n                  result.virtualHost = 'KVM';\n                  break;\n                case 'bochs':\n                  result.virtualHost = 'bochs';\n                  break;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // detect docker\n          if (fs.existsSync('/.dockerenv') || fs.existsSync('/.dockerinit')) {\n            result.model = 'Docker Container';\n          }\n          try {\n            const stdout = execSync('dmesg 2>/dev/null | grep -iE \"virtual|hypervisor\" | grep -iE \"vmware|qemu|kvm|xen\" | grep -viE \"Nested Virtualization|/virtual/\"');\n            // detect virtual machines\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0) {\n              if (result.model === 'Computer') { result.model = 'Virtual machine'; }\n              result.virtual = true;\n              if (stdout.toString().toLowerCase().indexOf('vmware') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'VMware';\n              }\n              if (stdout.toString().toLowerCase().indexOf('qemu') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'QEMU';\n              }\n              if (stdout.toString().toLowerCase().indexOf('xen') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'Xen';\n              }\n              if (stdout.toString().toLowerCase().indexOf('kvm') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'KVM';\n              }\n            }\n          } catch (e) {\n            util.noop();\n          }\n\n          if (result.manufacturer === '' && result.model === 'Computer' && result.version === '') {\n            // Check Raspberry Pi\n            fs.readFile('/proc/cpuinfo', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n                result.version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n                result.serial = util.getValue(lines, 'serial', ':', true);\n                const model = util.getValue(lines, 'model:', ':', true);\n                // reference values: https://elinux.org/RPi_HardwareHistory\n                // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n                if ((result.model === 'BCM2835' || result.model === 'BCM2708' || result.model === 'BCM2709' || result.model === 'BCM2710' || result.model === 'BCM2711' || result.model === 'BCM2836' || result.model === 'BCM2837') && model.toLowerCase().indexOf('raspberry') >= 0) {\n                  const rPIRevision = util.decodePiCpuinfo(lines);\n                  result.model = rPIRevision.model;\n                  result.version = rPIRevision.revisionCode;\n                  result.manufacturer = 'Raspberry Pi Foundation';\n                  result.raspberry = {\n                    manufacturer: rPIRevision.manufacturer,\n                    processor: rPIRevision.processor,\n                    type: rPIRevision.type,\n                    revision: rPIRevision.revision\n                  };\n                }\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true, true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.uuid = util.getValue(lines, 'ioplatformuuid', '=', true).toLowerCase();\n            result.sku = util.getValue(lines, 'board-id', '=', true);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.manufacturer = util.getValue(lines, 'vendor', ':');\n              result.model = util.getValue(lines, 'name', ':');\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'identifyingnumber', ':');\n              result.uuid = util.getValue(lines, 'uuid', ':').toLowerCase();\n              // detect virtual (1)\n              const model = result.model.toLowerCase();\n              if (model === 'virtualbox' || model === 'kvm' || model === 'virtual machine' || model === 'bochs' || model.startsWith('vmware') || model.startsWith('qemu') || model.startsWith('parallels')) {\n                result.virtual = true;\n                if (model.startsWith('virtualbox')) { result.virtualHost = 'VirtualBox'; }\n                if (model.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (model.startsWith('kvm')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('bochs')) { result.virtualHost = 'bochs'; }\n                if (model.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              const manufacturer = result.manufacturer.toLowerCase();\n              if (manufacturer.startsWith('vmware') || manufacturer.startsWith('qemu') || manufacturer === 'xen' || manufacturer.startsWith('parallels')) {\n                result.virtual = true;\n                if (manufacturer.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (manufacturer.startsWith('xen')) { result.virtualHost = 'Xen'; }\n                if (manufacturer.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (manufacturer.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              util.powerShell('Get-CimInstance MS_Systeminformation -Namespace \"root/wmi\" | select systemsku | fl ').then((stdout, error) => {\n                if (!error) {\n                  let lines = stdout.split('\\r\\n');\n                  result.sku = util.getValue(lines, 'systemsku', ':');\n                }\n                if (!result.virtual) {\n                  util.powerShell('Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion').then((stdout, error) => {\n                    if (!error) {\n                      let lines = stdout.toString();\n                      if (lines.indexOf('VRTUAL') >= 0 || lines.indexOf('A M I ') >= 0 || lines.indexOf('VirtualBox') >= 0 || lines.indexOf('VMWare') >= 0 || lines.indexOf('Xen') >= 0 || lines.indexOf('Parallels') >= 0) {\n                        result.virtual = true;\n                        if (lines.indexOf('VirtualBox') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VirtualBox';\n                        }\n                        if (lines.indexOf('VMware') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VMware';\n                        }\n                        if (lines.indexOf('Xen') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Xen';\n                        }\n                        if (lines.indexOf('VRTUAL') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Hyper-V';\n                        }\n                        if (lines.indexOf('A M I') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Virtual PC';\n                        }\n                        if (lines.indexOf('Parallels') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Parallels';\n                        }\n                      }\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    } else {\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    }\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.system = system;\n\nfunction bios(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        vendor: '',\n        version: '',\n        releaseDate: '',\n        revision: '',\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL';\n        }\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.vendor = util.getValue(lines, 'Vendor');\n          result.version = util.getValue(lines, 'Version');\n          let datetime = util.getValue(lines, 'Release Date');\n          result.releaseDate = util.parseDateTime(datetime).date;\n          result.revision = util.getValue(lines, 'BIOS Revision');\n          result.serial = util.getValue(lines, 'SerialNumber');\n          let language = util.getValue(lines, 'Currently Installed Language').split('|')[0];\n          if (language) {\n            result.language = language;\n          }\n          if (lines.length && stdout.toString().indexOf('Characteristics:') >= 0) {\n            const features = [];\n            lines.forEach(line => {\n              if (line.indexOf(' is supported') >= 0) {\n                const feature = line.split(' is supported')[0].trim();\n                features.push(feature);\n              }\n            });\n            result.features = features;\n          }\n          // Non-Root values\n          const cmd = `echo -n \"bios_date: \"; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;\n            echo -n \"bios_vendor: \"; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;\n            echo -n \"bios_version: \"; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.vendor = !result.vendor ? util.getValue(lines, 'bios_vendor') : result.vendor;\n            result.version = !result.version ? util.getValue(lines, 'bios_version') : result.version;\n            datetime = util.getValue(lines, 'bios_date');\n            result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;\n          } catch (e) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        result.vendor = 'Apple Inc.';\n        exec(\n          'system_profiler SPHardwareDataType -json', function (error, stdout) {\n            try {\n              const hardwareData = JSON.parse(stdout.toString());\n              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {\n                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;\n                bootRomVersion = bootRomVersion ? bootRomVersion.split('(')[0].trim() : null;\n                result.version = bootRomVersion;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n      }\n      if (_sunos) {\n        result.vendor = 'Sun Microsystems';\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n=\"ReleaseDate\";e={$_.ReleaseDate.ToString(\"yyyy-MM-dd\")}},BuildNumber,SerialNumber | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              const description = util.getValue(lines, 'description', ':');\n              if (description.indexOf(' Version ') !== -1) {\n                // ... Phoenix ROM BIOS PLUS Version 1.10 A04\n                result.vendor = description.split(' Version ')[0].trim();\n                result.version = description.split(' Version ')[1].trim();\n              } else if (description.indexOf(' Ver: ') !== -1) {\n                // ... BIOS Date: 06/27/16 17:50:16 Ver: 1.4.5\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = description.split(' Ver: ')[1].trim();\n              } else {\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = util.getValue(lines, 'version', ':');\n              }\n              result.releaseDate = util.getValue(lines, 'releasedate', ':');\n              result.revision = util.getValue(lines, 'buildnumber', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.bios = bios;\n\nfunction baseboard(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        memMax: null,\n        memSlots: null\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n          // 'BCM2709', 'BCM2835', 'BCM2708' -->\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL';\n        }\n        const workload = [];\n        workload.push(execPromise(cmd));\n        workload.push(execPromise('export LC_ALL=C; dmidecode -t memory 2>/dev/null'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'Manufacturer');\n          result.model = util.getValue(lines, 'Product Name');\n          result.version = util.getValue(lines, 'Version');\n          result.serial = util.getValue(lines, 'Serial Number');\n          result.assetTag = util.getValue(lines, 'Asset Tag');\n          // Non-Root values\n          const cmd = `echo -n \"board_asset_tag: \"; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;\n            echo -n \"board_name: \"; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;\n            echo -n \"board_serial: \"; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;\n            echo -n \"board_vendor: \"; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;\n            echo -n \"board_version: \"; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = !result.manufacturer ? util.getValue(lines, 'board_vendor') : result.manufacturer;\n            result.model = !result.model ? util.getValue(lines, 'board_name') : result.model;\n            result.version = !result.version ? util.getValue(lines, 'board_version') : result.version;\n            result.serial = !result.serial ? util.getValue(lines, 'board_serial') : result.serial;\n            result.assetTag = !result.assetTag ? util.getValue(lines, 'board_asset_tag') : result.assetTag;\n          } catch (e) {\n            util.noop();\n          }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          // mem\n          lines = data.results[1] ? data.results[1].toString().split('\\n') : [''];\n          result.memMax = util.toInt(util.getValue(lines, 'Maximum Capacity')) * 1024 * 1024 * 1024 || null;\n          result.memSlots = util.toInt(util.getValue(lines, 'Number Of Devices')) || null;\n\n          // raspberry\n          let linesRpi = '';\n          try {\n            linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n          } catch (e) {\n            util.noop();\n          }\n          const hardware = util.getValue(linesRpi, 'hardware');\n          if (hardware.startsWith('BCM')) {\n            const rpi = util.decodePiCpuinfo(linesRpi);\n            result.manufacturer = rpi.manufacturer;\n            result.model = 'Raspberry Pi';\n            result.serial = rpi.serial;\n            result.version = rpi.type + ' - ' + rpi.revision;\n            result.memMax = os.totalmem();\n            result.memSlots = 0;\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        const workload = [];\n        workload.push(execPromise('ioreg -c IOPlatformExpertDevice -d 2'));\n        workload.push(execPromise('system_profiler SPMemoryDataType'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().replace(/[<>\"]/g, '').split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n          result.model = util.getValue(lines, 'model', '=', true);\n          result.version = util.getValue(lines, 'version', '=', true);\n          result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n          result.assetTag = util.getValue(lines, 'board-id', '=', true);\n\n          // mem\n          let devices = data.results[1] ? data.results[1].toString().split('        BANK ') : [''];\n          if (devices.length === 1) {\n            devices = data.results[1] ? data.results[1].toString().split('        DIMM') : [''];\n          }\n          devices.shift();\n          result.memSlots = devices.length;\n\n          if (os.arch() === 'arm64') {\n            result.memSlots = 0;\n            result.memMax = os.totalmem();\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          const win10plus = parseInt(os.release()) >= 10;\n          const maxCapacityAttribute = win10plus ? 'MaxCapacityEx' : 'MaxCapacity';\n          workload.push(util.powerShell('Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl'));\n          workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n\n            result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n            result.model = util.getValue(lines, 'model', ':');\n            if (!result.model) {\n              result.model = util.getValue(lines, 'product', ':');\n            }\n            result.version = util.getValue(lines, 'version', ':');\n            result.serial = util.getValue(lines, 'serialnumber', ':');\n            result.assetTag = util.getValue(lines, 'partnumber', ':');\n            if (!result.assetTag) {\n              result.assetTag = util.getValue(lines, 'sku', ':');\n            }\n\n            // memphysical\n            lines = data.results[1] ? data.results[1].toString().split('\\r\\n') : [''];\n            result.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ':')) * (win10plus ? 1024 : 1) || null;\n            result.memSlots = util.toInt(util.getValue(lines, 'MemoryDevices', ':')) || null;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.baseboard = baseboard;\n\nfunction chassis(callback) {\n  const chassisTypes = ['Other',\n    'Unknown',\n    'Desktop',\n    'Low Profile Desktop',\n    'Pizza Box',\n    'Mini Tower',\n    'Tower',\n    'Portable',\n    'Laptop',\n    'Notebook',\n    'Hand Held',\n    'Docking Station',\n    'All in One',\n    'Sub Notebook',\n    'Space-Saving',\n    'Lunch Box',\n    'Main System Chassis',\n    'Expansion Chassis',\n    'SubChassis',\n    'Bus Expansion Chassis',\n    'Peripheral Chassis',\n    'Storage Chassis',\n    'Rack Mount Chassis',\n    'Sealed-Case PC',\n    'Multi-System Chassis',\n    'Compact PCI',\n    'Advanced TCA',\n    'Blade',\n    'Blade Enclosure',\n    'Tablet',\n    'Convertible',\n    'Detachable',\n    'IoT Gateway ',\n    'Embedded PC',\n    'Mini PC',\n    'Stick PC',\n  ];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        type: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        sku: '',\n      };\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        const cmd = `echo -n \"chassis_asset_tag: \"; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;\n            echo -n \"chassis_serial: \"; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;\n            echo -n \"chassis_type: \"; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;\n            echo -n \"chassis_vendor: \"; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;\n            echo -n \"chassis_version: \"; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'chassis_vendor');\n          const ctype = parseInt(util.getValue(lines, 'chassis_type').replace(/\\D/g, ''));\n          result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n          result.version = util.getValue(lines, 'chassis_version');\n          result.serial = util.getValue(lines, 'chassis_serial');\n          result.assetTag = util.getValue(lines, 'chassis_asset_tag');\n          if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n          if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.assetTag = util.getValue(lines, 'board-id', '=', true);\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n\n              result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n              result.model = util.getValue(lines, 'model', ':');\n              const ctype = parseInt(util.getValue(lines, 'ChassisTypes', ':').replace(/\\D/g, ''));\n              result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n              result.assetTag = util.getValue(lines, 'partnumber', ':');\n              result.sku = util.getValue(lines, 'sku', ':');\n              if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n              if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n              if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n              if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.chassis = chassis;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// usb.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. usb\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction getLinuxUsbType(type, name) {\n  let result = type;\n  const str = (name + ' ' + type).toLowerCase();\n  if (str.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (str.indexOf('hub') >= 0) { result = 'Hub'; }\n  else if (str.indexOf('keybrd') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (str.indexOf('stora') >= 0) { result = 'Storage'; }\n  else if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (str.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (str.indexOf('audio') >= 0) { result = 'Audio'; }\n\n  return result;\n}\n\nfunction parseLinuxUsb(usb) {\n  const result = {};\n  const lines = usb.split('\\n');\n  if (lines && lines.length && lines[0].indexOf('Device') >= 0) {\n    const parts = lines[0].split(' ');\n    result.bus = parseInt(parts[0], 10);\n    if (parts[2]) {\n      result.deviceId = parseInt(parts[2], 10);\n    } else {\n      result.deviceId = null;\n    }\n  } else {\n    result.bus = null;\n    result.deviceId = null;\n  }\n  const idVendor = util.getValue(lines, 'idVendor', ' ', true).trim();\n  let vendorParts = idVendor.split(' ');\n  vendorParts.shift();\n  const vendor = vendorParts.join(' ');\n\n  const idProduct = util.getValue(lines, 'idProduct', ' ', true).trim();\n  let productParts = idProduct.split(' ');\n  productParts.shift();\n  const product = productParts.join(' ');\n\n  const interfaceClass = util.getValue(lines, 'bInterfaceClass', ' ', true).trim();\n  let interfaceClassParts = interfaceClass.split(' ');\n  interfaceClassParts.shift();\n  const usbType = interfaceClassParts.join(' ');\n\n  const iManufacturer = util.getValue(lines, 'iManufacturer', ' ', true).trim();\n  let iManufacturerParts = iManufacturer.split(' ');\n  iManufacturerParts.shift();\n  const manufacturer = iManufacturerParts.join(' ');\n\n  result.id = (idVendor.startsWith('0x') ? idVendor.split(' ')[0].substr(2, 10) : '') + ':' + (idProduct.startsWith('0x') ? idProduct.split(' ')[0].substr(2, 10) : '');\n  result.name = product;\n  result.type = getLinuxUsbType(usbType, product);\n  result.removable = null;\n  result.vendor = vendor;\n  result.manufacturer = manufacturer;\n  result.maxPower = util.getValue(lines, 'MaxPower', ' ', true);\n  result.serialNumber = null;\n\n  return result;\n}\n\nfunction getDarwinUsbType(name) {\n  let result = '';\n  if (name.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (name.indexOf('touch bar') >= 0) { result = 'Touch Bar'; }\n  else if (name.indexOf('controller') >= 0) { result = 'Controller'; }\n  else if (name.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (name.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (name.indexOf('trackpad') >= 0) { result = 'Trackpad'; }\n  else if (name.indexOf('sensor') >= 0) { result = 'Sensor'; }\n  else if (name.indexOf('bthusb') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('bth') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('rfcomm') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf(' hub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (name.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (name.indexOf('removable') >= 0) { result = 'Storage'; }\n  return result;\n}\n\n\nfunction parseDarwinUsb(usb, id) {\n  const result = {};\n  result.id = id;\n\n  usb = usb.replace(/ \\|/g, '');\n  usb = usb.trim();\n  let lines = usb.split('\\n');\n  lines.shift();\n  try {\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = lines[i].trim();\n      lines[i] = lines[i].replace(/=/g, ':');\n      if (lines[i] !== '{' && lines[i] !== '}' && lines[i + 1] && lines[i + 1].trim() !== '}') {\n        lines[i] = lines[i] + ',';\n      }\n      lines[i] = lines[i].replace(': Yes,', ': \"Yes\",');\n      lines[i] = lines[i].replace(': No,', ': \"No\",');\n    }\n    const usbObj = JSON.parse(lines.join('\\n'));\n    const removableDrive = usbObj['Built-In'].toLowerCase() !== 'yes' && usbObj['non-removable'].toLowerCase() === 'no';\n\n    result.bus = null;\n    result.deviceId = null;\n    result.id = usbObj['USB Address'] || null;\n    result.name = usbObj['kUSBProductString'] || usbObj['USB Product Name'] || null;\n    result.type = getDarwinUsbType((usbObj['kUSBProductString'] || usbObj['USB Product Name'] || '').toLowerCase() + (removableDrive ? ' removable' : ''));\n    result.removable = usbObj['non-removable'].toLowerCase() === 'no';\n    result.vendor = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.manufacturer = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.maxPower = null;\n    result.serialNumber = usbObj['kUSBSerialNumberString'] || null;\n\n    if (result.name) {\n      return result;\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getWindowsUsbTypeCreation(creationclass, name) {\n  let result = '';\n  if (name.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (name.indexOf('speicher') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (creationclass.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbcontroller') >= 0) { result = 'Controller'; }\n  else if (creationclass.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (creationclass.indexOf('pointing') >= 0) { result = 'Mouse'; }\n  else if (creationclass.indexOf('disk') >= 0) { result = 'Storage'; }\n  return result;\n}\n\nfunction parseWindowsUsb(lines, id) {\n  const usbType = getWindowsUsbTypeCreation(util.getValue(lines, 'CreationClassName', ':').toLowerCase(), util.getValue(lines, 'name', ':').toLowerCase());\n\n  if (usbType) {\n    const result = {};\n    result.bus = null;\n    result.deviceId = util.getValue(lines, 'deviceid', ':');\n    result.id = id;\n    result.name = util.getValue(lines, 'name', ':');\n    result.type = usbType;\n    result.removable = null;\n    result.vendor = null;\n    result.manufacturer = util.getValue(lines, 'Manufacturer', ':');\n    result.maxPower = null;\n    result.serialNumber = null;\n\n    return result;\n  } else {\n    return null;\n  }\n}\n\nfunction usb(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        const cmd = 'export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = ('\\n\\n' + stdout.toString()).split('\\n\\nBus ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseLinuxUsb(parts[i]);\n              result.push(usb);\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = (stdout.toString()).split(' +-o ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseDarwinUsb(parts[i]);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match \"USB\"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const usb = parseWindowsUsb(parts[i].split('\\n'), i);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos || _freebsd || _openbsd || _netbsd) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.usb = usb;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// users.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 11. Users/Sessions\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseUsersLinux(lines, phase) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let w_first = true;\n  let w_header = [];\n  let w_pos = [];\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: l[2],\n          time: l[3],\n          ip: (l && l.length > 4) ? l[4].replace(/\\(/g, '').replace(/\\)/g, '') : ''\n        });\n      } else {\n        // w part\n        if (w_first) {    // header\n          w_header = l;\n          w_header.forEach(function (item) {\n            w_pos.push(line.indexOf(item));\n          });\n          w_first = false;\n        } else {\n          // split by w_pos\n          result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();\n          result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();\n          result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\\(/g, '').replace(/\\)/g, '').trim();\n          result_w.command = line.substring(w_pos[7], 1000).trim();\n          // find corresponding 'who' line\n          who_line = result_who.filter(function (obj) {\n            return (obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty);\n          });\n          if (who_line.length === 1) {\n            result.push({\n              user: who_line[0].user,\n              tty: who_line[0].tty,\n              date: who_line[0].date,\n              time: who_line[0].time,\n              ip: who_line[0].ip,\n              command: result_w.command\n            });\n          }\n        }\n      }\n    }\n  });\n  if (result.length === 0 && phase === 2) {\n    return result_who;\n  } else {\n    return result;\n  }\n}\n\nfunction parseUsersDarwin(lines) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: ('' + new Date().getFullYear()) + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + l[3]).slice(-2),\n          time: l[4],\n        });\n      } else {\n        // w part\n        // split by w_pos\n        result_w.user = l[0];\n        result_w.tty = l[1];\n        result_w.ip = (l[2] !== '-') ? l[2] : '';\n        result_w.command = l.slice(5, 1000).join(' ');\n        // find corresponding 'who' line\n        who_line = result_who.filter(function (obj) {\n          return (obj.user === result_w.user && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty));\n        });\n        if (who_line.length === 1) {\n          result.push({\n            user: who_line[0].user,\n            tty: who_line[0].tty,\n            date: who_line[0].date,\n            time: who_line[0].time,\n            ip: result_w.ip,\n            command: result_w.command\n          });\n        }\n      }\n    }\n  });\n  return result;\n}\n\nfunction users(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n\n      // linux\n      if (_linux) {\n        exec('who --ips; echo \"---\"; w | tail -n +2', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersLinux(lines, 1);\n            if (result.length === 0) {\n              exec('who; echo \"---\"; w | tail -n +2', function (error, stdout) {\n                if (!error) {\n                  // lines / split\n                  lines = stdout.toString().split('\\n');\n                  result = parseUsersLinux(lines, 2);\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        exec('who; echo \"---\"; w -h', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        try {\n          let cmd = 'Get-CimInstance Win32_LogonSession | select LogonId,@{n=\"StartTime\";e={$_.StartTime.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl' + '; echo \\'#-#-#-#\\';';\n          cmd += 'Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ' + '; echo \\'#-#-#-#\\';';\n          cmd += '$process = (Get-CimInstance Win32_Process -Filter \"name = \\'explorer.exe\\'\"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo \\'#-#-#-#\\';';\n          cmd += 'query user';\n          util.powerShell(cmd).then((data) => {\n            if (data) {\n              data = data.split('#-#-#-#');\n              let sessions = parseWinSessions((data[0] || '').split(/\\n\\s*\\n/));\n              let loggedons = parseWinLoggedOn((data[1] || '').split(/\\n\\s*\\n/));\n              let queryUser = parseWinUsersQuery((data[3] || '').split('\\r\\n'));\n              let users = parseWinUsers((data[2] || '').split(/\\n\\s*\\n/), queryUser);\n              for (let id in loggedons) {\n                if ({}.hasOwnProperty.call(loggedons, id)) {\n                  loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : '';\n                }\n              }\n              users.forEach(user => {\n                let dateTime = '';\n                for (let id in loggedons) {\n                  if ({}.hasOwnProperty.call(loggedons, id)) {\n                    if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {\n                      dateTime = loggedons[id].dateTime;\n                    }\n                  }\n                }\n\n                result.push({\n                  user: user.user,\n                  tty: user.tty,\n                  date: `${dateTime.substring(0, 10)}`,\n                  time: `${dateTime.substring(11, 19)}`,\n                  ip: '',\n                  command: ''\n                });\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction parseWinSessions(sessionParts) {\n  const sessions = {};\n  sessionParts.forEach(session => {\n    const lines = session.split('\\r\\n');\n    const id = util.getValue(lines, 'LogonId');\n    const starttime = util.getValue(lines, 'starttime');\n    if (id) {\n      sessions[id] = starttime;\n    }\n  });\n  return sessions;\n}\n\nfunction fuzzyMatch(name1, name2) {\n  name1 = name1.toLowerCase();\n  name2 = name2.toLowerCase();\n  let eq = 0;\n  let len = name1.length;\n  if (name2.length > len) { len = name2.length; }\n\n  for (let i = 0; i < len; i++) {\n    const c1 = name1[i] || '';\n    const c2 = name2[i] || '';\n    if (c1 === c2) { eq++; }\n  }\n  return (len > 10 ? eq / len > 0.9 : (len > 0 ? eq / len > 0.8 : false));\n}\n\nfunction parseWinUsers(userParts, userQuery) {\n  const users = [];\n  userParts.forEach(user => {\n    const lines = user.split('\\r\\n');\n\n    const domain = util.getValue(lines, 'domain', ':', true);\n    const username = util.getValue(lines, 'user', ':', true);\n    const sessionid = util.getValue(lines, 'sessionid', ':', true);\n\n    if (username) {\n      const quser = userQuery.filter(item => fuzzyMatch(item.user, username));\n      users.push({\n        domain,\n        user: username,\n        tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid\n      });\n    }\n  });\n  return users;\n}\n\nfunction parseWinLoggedOn(loggedonParts) {\n  const loggedons = {};\n  loggedonParts.forEach(loggedon => {\n    const lines = loggedon.split('\\r\\n');\n\n    const antecendent = util.getValue(lines, 'antecedent', ':', true);\n    let parts = antecendent.split('=');\n    const name = parts.length > 2 ? parts[1].split(',')[0].replace(/\"/g, '').trim() : '';\n    const domain = parts.length > 2 ? parts[2].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    const dependent = util.getValue(lines, 'dependent', ':', true);\n    parts = dependent.split('=');\n    const id = parts.length > 1 ? parts[1].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    if (id) {\n      loggedons[id] = {\n        domain,\n        user: name\n      };\n    }\n  });\n  return loggedons;\n}\n\nfunction parseWinUsersQuery(lines) {\n  lines = lines.filter(item => item);\n  let result = [];\n  const header = lines[0];\n  const headerDelimiter = [];\n  if (header) {\n    const start = (header[0] === ' ') ? 1 : 0;\n    headerDelimiter.push(start - 1);\n    let nextSpace = 0;\n    for (let i = start + 1; i < header.length; i++) {\n      if (header[i] === ' ' && ((header[i - 1] === ' ') || (header[i - 1] === '.'))) {\n        nextSpace = i;\n      } else {\n        if (nextSpace) {\n          headerDelimiter.push(nextSpace);\n          nextSpace = 0;\n        }\n      }\n    }\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim()) {\n        const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || '';\n        const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || '';\n        result.push({\n          user: user,\n          tty: tty,\n        });\n      }\n    }\n  }\n  return result;\n}\n\nexports.users = users;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\nlet _smartMonToolsInstalled = null;\n\nconst WINDIR = process.env.WINDIR || 'C:\\\\Windows';\n\n// powerShell\nlet _psChild;\nlet _psResult = '';\nlet _psCmds = [];\nlet _psPersistent = false;\nconst _psToUTF8 = '$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ';\nconst _psCmdStart = '--###START###--';\nconst _psError = '--ERROR--';\nconst _psCmdSeperator = '--###ENDCMD###--';\nconst _psIdSeperator = '--##ID##--';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\n\nconst stringReplace = new String().replace;\nconst stringToLower = new String().toLowerCase;\nconst stringToString = new String().toString;\nconst stringSubstr = new String().substr;\nconst stringTrim = new String().trim;\nconst stringStartWith = new String().startsWith;\nconst mathMin = Math.min;\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed, lineMatch) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  lineMatch = lineMatch || false;\n  let result = '';\n  lines.forEach((line) => {\n    let lineLower = line.toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      lineLower = lineLower.trim();\n    }\n    if (lineLower.startsWith(property) && (lineMatch ? (lineLower.match(property + separator)) || (lineLower.match(property + ' ' + separator)) : true)) {\n      const parts = trimmed ? line.trim().split(separator) : line.split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        result = parts.join(separator).trim();\n      }\n    }\n  });\n  return result;\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 5000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (let i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC', execOptsWin).toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        powerShell(getWmic() + ' ' + command).then(stdout => {\n          resolve(stdout, '');\n        });\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? `\"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\\\VBoxManage.exe\"` : 'vboxmanage';\n}\n\nfunction powerShellProceedResults(data) {\n  let id = '';\n  let parts;\n  let res = '';\n  // startID\n  if (data.indexOf(_psCmdStart) >= 0) {\n    parts = data.split(_psCmdStart);\n    const parts2 = parts[1].split(_psIdSeperator);\n    id = parts2[0];\n    if (parts2.length > 1) {\n      data = parts2.slice(1).join(_psIdSeperator);\n    }\n  }\n  // result;\n  if (data.indexOf(_psCmdSeperator) >= 0) {\n    parts = data.split(_psCmdSeperator);\n    res = parts[0];\n  }\n  let remove = -1;\n  for (let i = 0; i < _psCmds.length; i++) {\n    if (_psCmds[i].id === id) {\n      remove = i;\n      _psCmds[i].callback(res);\n    }\n  }\n  if (remove >= 0) {\n    _psCmds.splice(remove, 1);\n  }\n}\n\nfunction powerShellStart() {\n  if (!_psChild) {\n    _psChild = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-Command', '-'], {\n      stdio: 'pipe',\n      windowsHide: true,\n      maxBuffer: 1024 * 20000,\n      encoding: 'UTF-8',\n      env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n    });\n    if (_psChild && _psChild.pid) {\n      _psPersistent = true;\n      _psChild.stdout.on('data', function (data) {\n        _psResult = _psResult + data.toString('utf8');\n        if (data.indexOf(_psCmdSeperator) >= 0) {\n          powerShellProceedResults(_psResult);\n          _psResult = '';\n        }\n      });\n      _psChild.stderr.on('data', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('error', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('close', function () {\n        _psChild.kill();\n      });\n    }\n  }\n}\n\nfunction powerShellRelease() {\n  try {\n    if (_psChild) {\n      _psChild.stdin.write('exit' + os.EOL);\n      _psChild.stdin.end();\n      _psPersistent = false;\n    }\n  } catch (e) {\n    if (_psChild) { _psChild.kill(); }\n  }\n  _psChild = null;\n}\n\nfunction powerShell(cmd) {\n\n  if (_psPersistent) {\n    const id = Math.random().toString(36).substring(2, 12);\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        function callback(data) {\n          resolve(data);\n        }\n        _psCmds.push({\n          id,\n          cmd,\n          callback,\n          start: new Date()\n        });\n        try {\n          if (_psChild && _psChild.pid) {\n            _psChild.stdin.write(_psToUTF8 + 'echo ' + _psCmdStart + id + _psIdSeperator + '; ' + os.EOL + cmd + os.EOL + 'echo ' + _psCmdSeperator + os.EOL);\n          }\n        } catch (e) {\n          resolve('');\n        }\n      });\n    });\n\n  } else {\n    let result = '';\n\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        try {\n          const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n            stdio: 'pipe',\n            windowsHide: true,\n            maxBuffer: 1024 * 20000,\n            encoding: 'UTF-8',\n            env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n          });\n\n          if (child && !child.pid) {\n            child.on('error', function () {\n              resolve(result);\n            });\n          }\n          if (child && child.pid) {\n            child.stdout.on('data', function (data) {\n              result = result + data.toString('utf8');\n            });\n            child.stderr.on('data', function () {\n              child.kill();\n              resolve(result);\n            });\n            child.on('close', function () {\n              child.kill();\n\n              resolve(result);\n            });\n            child.on('error', function () {\n              child.kill();\n              resolve(result);\n            });\n            try {\n              child.stdin.write(_psToUTF8 + cmd + os.EOL);\n              child.stdin.write('exit' + os.EOL);\n              child.stdin.end();\n            } catch (e) {\n              child.kill();\n              resolve(result);\n            }\n          } else {\n            resolve(result);\n          }\n        } catch (e) {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n\nfunction execSafe(cmd, args, options) {\n  let result = '';\n  options = options || {};\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn(cmd, args, options);\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result += data.toString();\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp', execOptsWin);\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '').trim() : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction smartMonToolsInstalled() {\n  if (_smartMonToolsInstalled !== null) {\n    return _smartMonToolsInstalled;\n  }\n  _smartMonToolsInstalled = false;\n  if (_windows) {\n    try {\n      const pathArray = execSync('WHERE smartctl 2>nul', execOptsWin).toString().split('\\r\\n');\n      if (pathArray && pathArray.length) {\n        _smartMonToolsInstalled = pathArray[0].indexOf(':\\\\') >= 0;\n      } else {\n        _smartMonToolsInstalled = false;\n      }\n    } catch (e) {\n      _smartMonToolsInstalled = false;\n    }\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    const pathArray = execSync('which smartctl 2>/dev/null', execOptsWin).toString().split('\\r\\n');\n    _smartMonToolsInstalled = pathArray.length > 0;\n  }\n  return _smartMonToolsInstalled;\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2711',\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id', '=');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str, strict) {\n  if (typeof strict === 'undefined') { strict = false; }\n  const s = str || '';\n  let result = '';\n  for (let i = 0; i <= mathMin(s.length, 2000); i++) {\n    if (!(s[i] === undefined ||\n      s[i] === '>' ||\n      s[i] === '<' ||\n      s[i] === '*' ||\n      s[i] === '?' ||\n      s[i] === '[' ||\n      s[i] === ']' ||\n      s[i] === '|' ||\n      s[i] === '' ||\n      s[i] === '$' ||\n      s[i] === ';' ||\n      s[i] === '&' ||\n      s[i] === '(' ||\n      s[i] === ')' ||\n      s[i] === ']' ||\n      s[i] === '#' ||\n      s[i] === '\\\\' ||\n      s[i] === '\\t' ||\n      s[i] === '\\n' ||\n      s[i] === '\\'' ||\n      s[i] === '`' ||\n      s[i] === '\"' ||\n      s[i].length > 1 ||\n      (strict && s[i] === '@') ||\n      (strict && s[i] === ' ') ||\n      (strict && s[i] == '{') ||\n      (strict && s[i] == ')'))) {\n      result = result + s[i];\n    }\n  }\n  return result;\n}\n\nfunction isPrototypePolluted() {\n  const s = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let notPolluted = true;\n  let st = '';\n\n  st.__proto__.replace = stringReplace;\n  st.__proto__.toLowerCase = stringToLower;\n  st.__proto__.toString = stringToString;\n  st.__proto__.substr = stringSubstr;\n\n  notPolluted = notPolluted || (s.length !== 62);\n  const ms = Date.now();\n  if (typeof ms === 'number' && ms > 1600000000000) {\n    const l = ms % 100 + 15;\n    for (let i = 0; i < l; i++) {\n      const r = Math.random() * 61.99999999 + 1;\n      const rs = parseInt(Math.floor(r).toString(), 10);\n      const rs2 = parseInt(r.toString().split('.')[0], 10);\n      const q = Math.random() * 61.99999999 + 1;\n      const qs = parseInt(Math.floor(q).toString(), 10);\n      const qs2 = parseInt(q.toString().split('.')[0], 10);\n      notPolluted = notPolluted && (r !== q);\n      notPolluted = notPolluted && rs === rs2 && qs === qs2;\n      st += s[rs - 1];\n    }\n    notPolluted = notPolluted && st.length === l;\n    // string manipulation\n    let p = Math.random() * l * 0.9999999999;\n    let stm = st.substr(0, p) + ' ' + st.substr(p, 2000);\n    stm.__proto__.replace = stringReplace;\n    let sto = stm.replace(/ /g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '{' + st.substr(p, 2000);\n    sto = stm.replace(/{/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '*' + st.substr(p, 2000);\n    sto = stm.replace(/\\*/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '$' + st.substr(p, 2000);\n    sto = stm.replace(/\\$/g, '');\n    notPolluted = notPolluted && st === sto;\n\n    // lower\n    const stl = st.toLowerCase();\n    notPolluted = notPolluted && (stl.length === l) && stl[l - 1] && !(stl[l]);\n    for (let i = 0; i < l; i++) {\n      const s1 = st[i];\n      s1.__proto__.toLowerCase = stringToLower;\n      const s2 = stl ? stl[i] : '';\n      const s1l = s1.toLowerCase();\n      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !(s1l[1]);\n    }\n  }\n  return !notPolluted;\n}\n\nfunction hex2bin(hex) {\n  return ('00000000' + (parseInt(hex, 16)).toString(2)).substr(-8);\n}\n\nfunction getFilesInPath(source) {\n  const lstatSync = fs.lstatSync;\n  const readdirSync = fs.readdirSync;\n  const join = path.join;\n\n  function isDirectory(source) {\n    return lstatSync(source).isDirectory();\n  }\n  function isFile(source) { return lstatSync(source).isFile(); }\n\n  function getDirectories(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isDirectory);\n  }\n  function getFiles(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isFile);\n  }\n\n  function getFilesRecursively(source) {\n    try {\n      let dirs = getDirectories(source);\n      let files = dirs\n        .map(function (dir) { return getFilesRecursively(dir); })\n        .reduce(function (a, b) { return a.concat(b); }, []);\n      return files.concat(getFiles(source));\n    } catch (e) {\n      return [];\n    }\n  }\n\n  if (fs.existsSync(source)) {\n    return getFilesRecursively(source);\n  } else {\n    return [];\n  }\n}\n\nfunction decodePiCpuinfo(lines) {\n\n  // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n\n  const oldRevisionCodes = {\n    '0002': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0003': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0004': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0005': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '0006': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0007': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0008': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0009': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '000d': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '000e': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '000f': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0010': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0011': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0012': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0013': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0014': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0015': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: '512MB\tEmbest',\n      processor: 'BCM2835'\n    }\n  };\n\n  const processorList = [\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2711',\n  ];\n  const manufacturerList = [\n    'Sony UK',\n    'Egoman',\n    'Embest',\n    'Sony Japan',\n    'Embest',\n    'Stadium'\n  ];\n  const typeList = {\n    '00': 'A',\n    '01': 'B',\n    '02': 'A+',\n    '03': 'B+',\n    '04': '2B',\n    '05': 'Alpha (early prototype)',\n    '06': 'CM1',\n    '08': '3B',\n    '09': 'Zero',\n    '0a': 'CM3',\n    '0c': 'Zero W',\n    '0d': '3B+',\n    '0e': '3A+',\n    '0f': 'Internal use only',\n    '10': 'CM3+',\n    '11': '4B',\n    '12': 'Zero 2 W',\n    '13': '400',\n    '14': 'CM4'\n  };\n\n  const revisionCode = getValue(lines, 'revision', ':', true);\n  const model = getValue(lines, 'model:', ':', true);\n  const serial = getValue(lines, 'serial', ':', true);\n\n  let result = {};\n  if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {\n    // old revision codes\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: oldRevisionCodes[revisionCode].memory,\n      manufacturer: oldRevisionCodes[revisionCode].manufacturer,\n      processor: oldRevisionCodes[revisionCode].processor,\n      type: oldRevisionCodes[revisionCode].type,\n      revision: oldRevisionCodes[revisionCode].revision,\n    };\n\n  } else {\n    // new revision code\n    const revision = ('00000000' + getValue(lines, 'revision', ':', true).toLowerCase()).substr(-8);\n    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;\n    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];\n    const processor = processorList[parseInt(revision.substr(4, 1), 10)];\n    const typeCode = revision.substr(5, 2);\n\n\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: 256 * Math.pow(2, memSizeCode),\n      manufacturer,\n      processor,\n      type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : '',\n      revision: '1.' + revision.substr(7, 1),\n    };\n  }\n  return result;\n}\n\nfunction promiseAll(promises) {\n  const resolvingPromises = promises.map(function (promise) {\n    return new Promise(function (resolve) {\n      let payload = new Array(2);\n      promise.then(function (result) {\n        payload[0] = result;\n      })\n        .catch(function (error) {\n          payload[1] = error;\n        })\n        .then(function () {\n          // The wrapped Promise returns an array: 0 = result, 1 = error ... we resolve all\n          resolve(payload);\n        });\n    });\n  });\n  const errors = [];\n  const results = [];\n\n  // Execute all wrapped Promises\n  return Promise.all(resolvingPromises)\n    .then(function (items) {\n      items.forEach(function (payload) {\n        if (payload[1]) {\n          errors.push(payload[1]);\n          results.push(null);\n        } else {\n          errors.push(null);\n          results.push(payload[0]);\n        }\n      });\n\n      return {\n        errors: errors,\n        results: results\n      };\n    });\n}\n\nfunction promisify(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction promisifySave(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve) {\n      args.push(function (err, data) {\n        resolve(data);\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction linuxVersion() {\n  let result = '';\n  if (_linux) {\n    try {\n      result = execSync('uname -v').toString();\n    } catch (e) {\n      result = '';\n    }\n  }\n  return result;\n}\n\nfunction plistParser(xmlStr) {\n  const tags = ['array', 'dict', 'key', 'string', 'integer', 'date', 'real', 'data', 'boolean', 'arrayEmpty'];\n  const startStr = '<plist version';\n\n  let pos = xmlStr.indexOf(startStr);\n  let len = xmlStr.length;\n  while (xmlStr[pos] !== '>' && pos < len) {\n    pos++;\n  }\n\n  let depth = 0;\n  let inTagStart = false;\n  let inTagContent = false;\n  let inTagEnd = false;\n  let metaData = [{ tagStart: '', tagEnd: '', tagContent: '', key: '', data: null }];\n  let c = '';\n  let cn = xmlStr[pos];\n\n  while (pos < len) {\n    c = cn;\n    if (pos + 1 < len) { cn = xmlStr[pos + 1]; }\n    if (c === '<') {\n      inTagContent = false;\n      if (cn === '/') { inTagEnd = true; }\n      else if (metaData[depth].tagStart) {\n        metaData[depth].tagContent = '';\n        if (!metaData[depth].data) { metaData[depth].data = metaData[depth].tagStart === 'array' ? [] : {}; }\n        depth++;\n        metaData.push({ tagStart: '', tagEnd: '', tagContent: '', key: null, data: null });\n        inTagStart = true;\n        inTagContent = false;\n      }\n      else if (!inTagStart) { inTagStart = true; }\n    } else if (c === '>') {\n      if (metaData[depth].tagStart === 'true/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = true; }\n      if (metaData[depth].tagStart === 'false/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = false; }\n      if (metaData[depth].tagStart === 'array/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/arrayEmpty'; metaData[depth].data = []; }\n      if (inTagContent) { inTagContent = false; }\n      if (inTagStart) {\n        inTagStart = false;\n        inTagContent = true;\n        if (metaData[depth].tagStart === 'array') {\n          metaData[depth].data = [];\n        }\n        if (metaData[depth].tagStart === 'dict') {\n          metaData[depth].data = {};\n        }\n      }\n      if (inTagEnd) {\n        inTagEnd = false;\n        if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {\n          if (metaData[depth].tagEnd === '/dict' || metaData[depth].tagEnd === '/array') {\n            if (depth > 1 && metaData[depth - 2].tagStart === 'array') {\n              metaData[depth - 2].data.push(metaData[depth - 1].data);\n            }\n            if (depth > 1 && metaData[depth - 2].tagStart === 'dict') {\n              metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;\n            }\n            depth--;\n            metaData.pop();\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n          else {\n            if (metaData[depth].tagEnd === '/key' && metaData[depth].tagContent) {\n              metaData[depth].key = metaData[depth].tagContent;\n            } else {\n              if (metaData[depth].tagEnd === '/real' && metaData[depth].tagContent) { metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/integer' && metaData[depth].tagContent) { metaData[depth].data = parseInt(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/string' && metaData[depth].tagContent) { metaData[depth].data = metaData[depth].tagContent || ''; }\n              if (metaData[depth].tagEnd === '/boolean') { metaData[depth].data = metaData[depth].tagContent || false; }\n              if (metaData[depth].tagEnd === '/arrayEmpty') { metaData[depth].data = metaData[depth].tagContent || []; }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'array') { metaData[depth - 1].data.push(metaData[depth].data); }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'dict') { metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data; }\n            }\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n        }\n        metaData[depth].tagEnd = '';\n        inTagStart = false;\n        inTagContent = false;\n      }\n    } else {\n      if (inTagStart) { metaData[depth].tagStart += c; }\n      if (inTagEnd) { metaData[depth].tagEnd += c; }\n      if (inTagContent) { metaData[depth].tagContent += c; }\n    }\n    pos++;\n  }\n  return metaData[0].data;\n}\n\nfunction strIsNumeric(str) {\n  return typeof str === 'string' && !isNaN(str) && !isNaN(parseFloat(str));\n}\n\nfunction plistReader(output) {\n  const lines = output.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf(' = ') >= 0) {\n      const lineParts = lines[i].split(' = ');\n      lineParts[0] = lineParts[0].trim();\n      if (!lineParts[0].startsWith('\"')) {\n        lineParts[0] = '\"' + lineParts[0] + '\"';\n      }\n      lineParts[1] = lineParts[1].trim();\n      if (lineParts[1].indexOf('\"') === -1 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1);\n        if (!strIsNumeric(valueString)) {\n          lineParts[1] = `\"${valueString}\";`;\n        }\n      }\n      if (lineParts[1].indexOf('\"') >= 0 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/\"/g, '');\n        if (strIsNumeric(valueString)) {\n          lineParts[1] = `${valueString};`;\n        }\n      }\n      lines[i] = lineParts.join(' : ');\n    }\n    lines[i] = lines[i].replace(/\\(/g, '[').replace(/\\)/g, ']').replace(/;/g, ',').trim();\n    if (lines[i].startsWith('}') && lines[i - 1] && lines[i - 1].endsWith(',')) {\n      lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);\n    }\n  }\n  output = lines.join('');\n  let obj = {};\n  try {\n    obj = JSON.parse(output);\n  } catch (e) {\n    noop();\n  }\n  return obj;\n}\n\nfunction semverCompare(v1, v2) {\n  let res = 0;\n  const parts1 = v1.split('.');\n  const parts2 = v2.split('.');\n  if (parts1[0] < parts2[0]) { res = 1; }\n  else if (parts1[0] > parts2[0]) { res = -1; }\n  else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {\n    if (parts1[1] < parts2[1]) { res = 1; }\n    else if (parts1[1] > parts2[1]) { res = -1; }\n    else if (parts1[1] === parts2[1]) {\n      if (parts1.length >= 3 && parts2.length >= 3) {\n        if (parts1[2] < parts2[2]) { res = 1; }\n        else if (parts1[2] > parts2[2]) { res = -1; }\n      } else if (parts2.length >= 3) {\n        res = 1;\n      }\n    }\n  }\n  return res;\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.powerShellStart = powerShellStart;\nexports.powerShellRelease = powerShellRelease;\nexports.execSafe = execSafe;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\nexports.isPrototypePolluted = isPrototypePolluted;\nexports.decodePiCpuinfo = decodePiCpuinfo;\nexports.promiseAll = promiseAll;\nexports.promisify = promisify;\nexports.promisifySave = promisifySave;\nexports.smartMonToolsInstalled = smartMonToolsInstalled;\nexports.linuxVersion = linuxVersion;\nexports.plistParser = plistParser;\nexports.plistReader = plistReader;\nexports.stringReplace = stringReplace;\nexports.stringToLower = stringToLower;\nexports.stringToString = stringToString;\nexports.stringSubstr = stringSubstr;\nexports.stringTrim = stringTrim;\nexports.stringStartWith = stringStartWith;\nexports.mathMin = mathMin;\nexports.WINDIR = WINDIR;\nexports.getFilesInPath = getFilesInPath;\nexports.semverCompare = semverCompare;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// virtualbox.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 14. Docker\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nfunction vboxInfo(callback) {\n\n  // fallback - if only callback is given\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(util.getVboxmanage() + ' list vms --long', function (error, stdout) {\n          let parts = (os.EOL + stdout.toString()).split(os.EOL + 'Name:');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = ('Name:' + part).split(os.EOL);\n            const state = util.getValue(lines, 'State');\n            const running = state.startsWith('running');\n            const runningSinceString = running ? state.replace('running (since ', '').replace(')', '').trim() : '';\n            let runningSince = 0;\n            try {\n              if (running) {\n                const sinceDateObj = new Date(runningSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            const stoppedSinceString = !running ? state.replace('powered off (since', '').replace(')', '').trim() : '';\n            let stoppedSince = 0;\n            try {\n              if (!running) {\n                const sinceDateObj = new Date(stoppedSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            result.push({\n              id: util.getValue(lines, 'UUID'),\n              name: util.getValue(lines, 'Name'),\n              running,\n              started: runningSinceString,\n              runningSince,\n              stopped: stoppedSinceString,\n              stoppedSince,\n              guestOS: util.getValue(lines, 'Guest OS'),\n              hardwareUUID: util.getValue(lines, 'Hardware UUID'),\n              memory: parseInt(util.getValue(lines, 'Memory size', '     '), 10),\n              vram: parseInt(util.getValue(lines, 'VRAM size'), 10),\n              cpus: parseInt(util.getValue(lines, 'Number of CPUs'), 10),\n              cpuExepCap: util.getValue(lines, 'CPU exec cap'),\n              cpuProfile: util.getValue(lines, 'CPUProfile'),\n              chipset: util.getValue(lines, 'Chipset'),\n              firmware: util.getValue(lines, 'Firmware'),\n              pageFusion: util.getValue(lines, 'Page Fusion') === 'enabled',\n              configFile: util.getValue(lines, 'Config file'),\n              snapshotFolder: util.getValue(lines, 'Snapshot folder'),\n              logFolder: util.getValue(lines, 'Log folder'),\n              hpet: util.getValue(lines, 'HPET') === 'enabled',\n              pae: util.getValue(lines, 'PAE') === 'enabled',\n              longMode: util.getValue(lines, 'Long Mode') === 'enabled',\n              tripleFaultReset: util.getValue(lines, 'Triple Fault Reset') === 'enabled',\n              apic: util.getValue(lines, 'APIC') === 'enabled',\n              x2Apic: util.getValue(lines, 'X2APIC') === 'enabled',\n              acpi: util.getValue(lines, 'ACPI') === 'enabled',\n              ioApic: util.getValue(lines, 'IOAPIC') === 'enabled',\n              biosApicMode: util.getValue(lines, 'BIOS APIC mode'),\n              bootMenuMode: util.getValue(lines, 'Boot menu mode'),\n              bootDevice1: util.getValue(lines, 'Boot Device 1'),\n              bootDevice2: util.getValue(lines, 'Boot Device 2'),\n              bootDevice3: util.getValue(lines, 'Boot Device 3'),\n              bootDevice4: util.getValue(lines, 'Boot Device 4'),\n              timeOffset: util.getValue(lines, 'Time offset'),\n              rtc: util.getValue(lines, 'RTC'),\n            });\n          });\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } catch (e) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.vboxInfo = vboxInfo;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// wifi.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. wifi\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\n\nfunction wifiDBFromQuality(quality) {\n  return (parseFloat(quality) / 2 - 100);\n}\n\nfunction wifiQualityFromDB(db) {\n  const result = 2 * (parseFloat(db) + 100);\n  return result <= 100 ? result : 100;\n}\n\nconst _wifi_frequencies = {\n  1: 2412,\n  2: 2417,\n  3: 2422,\n  4: 2427,\n  5: 2432,\n  6: 2437,\n  7: 2442,\n  8: 2447,\n  9: 2452,\n  10: 2457,\n  11: 2462,\n  12: 2467,\n  13: 2472,\n  14: 2484,\n  32: 5160,\n  34: 5170,\n  36: 5180,\n  38: 5190,\n  40: 5200,\n  42: 5210,\n  44: 5220,\n  46: 5230,\n  48: 5240,\n  50: 5250,\n  52: 5260,\n  54: 5270,\n  56: 5280,\n  58: 5290,\n  60: 5300,\n  62: 5310,\n  64: 5320,\n  68: 5340,\n  96: 5480,\n  100: 5500,\n  102: 5510,\n  104: 5520,\n  106: 5530,\n  108: 5540,\n  110: 5550,\n  112: 5560,\n  114: 5570,\n  116: 5580,\n  118: 5590,\n  120: 5600,\n  122: 5610,\n  124: 5620,\n  126: 5630,\n  128: 5640,\n  132: 5660,\n  134: 5670,\n  136: 5680,\n  138: 5690,\n  140: 5700,\n  142: 5710,\n  144: 5720,\n  149: 5745,\n  151: 5755,\n  153: 5765,\n  155: 5775,\n  157: 5785,\n  159: 5795,\n  161: 5805,\n  165: 5825,\n  169: 5845,\n  173: 5865,\n  183: 4915,\n  184: 4920,\n  185: 4925,\n  187: 4935,\n  188: 4940,\n  189: 4945,\n  192: 4960,\n  196: 4980\n};\n\nfunction wifiFrequencyFromChannel(channel) {\n  return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;\n}\n\nfunction wifiChannelFromFrequencs(frequency) {\n  let channel = 0;\n  for (let key in _wifi_frequencies) {\n    if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {\n      if (_wifi_frequencies[key] === frequency) { channel = util.toInt(key); }\n    }\n  }\n  return channel;\n}\n\nfunction ifaceListLinux() {\n  const result = [];\n  const cmd = 'iw dev 2>/dev/null';\n  try {\n    const all = execSync(cmd).toString().split('\\n').map(line => line.trim()).join('\\n');\n    const parts = all.split('\\nInterface ');\n    parts.shift();\n    parts.forEach(ifaceDetails => {\n      const lines = ifaceDetails.split('\\n');\n      const iface = lines[0];\n      const id = util.toInt(util.getValue(lines, 'ifindex', ' '));\n      const mac = util.getValue(lines, 'addr', ' ');\n      const channel = util.toInt(util.getValue(lines, 'channel', ' '));\n      result.push({\n        id,\n        iface,\n        mac,\n        channel\n      });\n    });\n    return result;\n  } catch (e) {\n    try {\n      const all = execSync('nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null').toString();\n      const parts = all.split('\\nGENERAL.DEVICE:');\n      let i = 1;\n      parts.forEach(ifaceDetails => {\n        const lines = ifaceDetails.split('\\n');\n        const iface = util.getValue(lines, 'GENERAL.DEVICE');\n        const type = util.getValue(lines, 'GENERAL.TYPE');\n        const id = i++; // // util.getValue(lines, 'GENERAL.PATH');\n        const mac = util.getValue(lines, 'GENERAL.HWADDR');\n        const channel = '';\n        if (type.toLowerCase() === 'wifi') {\n          result.push({\n            id,\n            iface,\n            mac,\n            channel\n          });\n        }\n      });\n      return result;\n    } catch (e) {\n      return [];\n    }\n  }\n}\n\nfunction nmiDeviceLinux(iface) {\n  const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const ssid = util.getValue(lines, 'GENERAL.CONNECTION');\n    return {\n      iface,\n      type: util.getValue(lines, 'GENERAL.TYPE'),\n      vendor: util.getValue(lines, 'GENERAL.VENDOR'),\n      product: util.getValue(lines, 'GENERAL.PRODUCT'),\n      mac: util.getValue(lines, 'GENERAL.HWADDR').toLowerCase(),\n      ssid: ssid !== '--' ? ssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction nmiConnectionLinux(ssid) {\n  const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const bssid = util.getValue(lines, '802-11-wireless.seen-bssids').toLowerCase();\n    return {\n      ssid: ssid !== '--' ? ssid : null,\n      uuid: util.getValue(lines, 'connection.uuid'),\n      type: util.getValue(lines, 'connection.type'),\n      autoconnect: util.getValue(lines, 'connection.autoconnect') === 'yes',\n      security: util.getValue(lines, '802-11-wireless-security.key-mgmt'),\n      bssid: bssid !== '--' ? bssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction wpaConnectionLinux(iface) {\n  const cmd = `wpa_cli -i ${iface} status 2>&1`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const freq = util.toInt(util.getValue(lines, 'freq', '='));\n    return {\n      ssid: util.getValue(lines, 'ssid', '='),\n      uuid: util.getValue(lines, 'uuid', '='),\n      security: util.getValue(lines, 'key_mgmt', '='),\n      freq,\n      channel: wifiChannelFromFrequencs(freq),\n      bssid: util.getValue(lines, 'bssid', '=').toLowerCase()\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction getWifiNetworkListNmi() {\n  const result = [];\n  const cmd = 'nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null';\n  try {\n    const stdout = execSync(cmd, { maxBuffer: 1024 * 20000 });\n    const parts = stdout.toString().split('ACTIVE:');\n    parts.shift();\n    parts.forEach(part => {\n      part = 'ACTIVE:' + part;\n      const lines = part.split(os.EOL);\n      const channel = util.getValue(lines, 'CHAN');\n      const frequency = util.getValue(lines, 'FREQ').toLowerCase().replace('mhz', '').trim();\n      const security = util.getValue(lines, 'SECURITY').replace('(', '').replace(')', '');\n      const wpaFlags = util.getValue(lines, 'WPA-FLAGS').replace('(', '').replace(')', '');\n      const rsnFlags = util.getValue(lines, 'RSN-FLAGS').replace('(', '').replace(')', '');\n      result.push({\n        ssid: util.getValue(lines, 'SSID'),\n        bssid: util.getValue(lines, 'BSSID').toLowerCase(),\n        mode: util.getValue(lines, 'MODE'),\n        channel: channel ? parseInt(channel, 10) : null,\n        frequency: frequency ? parseInt(frequency, 10) : null,\n        signalLevel: wifiDBFromQuality(util.getValue(lines, 'SIGNAL')),\n        quality: parseFloat(util.getValue(lines, 'SIGNAL')),\n        security: security && security !== 'none' ? security.split(' ') : [],\n        wpaFlags: wpaFlags && wpaFlags !== 'none' ? wpaFlags.split(' ') : [],\n        rsnFlags: rsnFlags && rsnFlags !== 'none' ? rsnFlags.split(' ') : []\n      });\n    });\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getWifiNetworkListIw(iface) {\n  const result = [];\n  try {\n    let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`).toString().split('        Cell ');\n    if (iwlistParts[0].indexOf('resource busy') >= 0) { return -1; }\n    if (iwlistParts.length > 1) {\n      iwlistParts.shift();\n      iwlistParts.forEach(element => {\n        const lines = element.split('\\n');\n        const channel = util.getValue(lines, 'channel', ':', true);\n        const address = (lines && lines.length && lines[0].indexOf('Address:') >= 0 ? lines[0].split('Address:')[1].trim().toLowerCase() : '');\n        const mode = util.getValue(lines, 'mode', ':', true);\n        const frequency = util.getValue(lines, 'frequency', ':', true);\n        const qualityString = util.getValue(lines, 'Quality', '=', true);\n        const dbParts = qualityString.toLowerCase().split('signal level=');\n        const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;\n        const quality = db ? wifiQualityFromDB(db) : 0;\n        const ssid = util.getValue(lines, 'essid', ':', true);\n\n        // security and wpa-flags\n        const isWpa = element.indexOf(' WPA ') >= 0;\n        const isWpa2 = element.indexOf('WPA2 ') >= 0;\n        const security = [];\n        if (isWpa) { security.push('WPA'); }\n        if (isWpa2) { security.push('WPA2'); }\n        const wpaFlags = [];\n        let wpaFlag = '';\n        lines.forEach(function (line) {\n          const l = line.trim().toLowerCase();\n          if (l.indexOf('group cipher') >= 0) {\n            if (wpaFlag) {\n              wpaFlags.push(wpaFlag);\n            }\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              wpaFlag = parts[1].trim().toUpperCase();\n            }\n          }\n          if (l.indexOf('pairwise cipher') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('tkip')) { wpaFlag = (wpaFlag ? 'TKIP/' + wpaFlag : 'TKIP'); }\n              else if (parts[1].indexOf('ccmp')) { wpaFlag = (wpaFlag ? 'CCMP/' + wpaFlag : 'CCMP'); }\n              else if (parts[1].indexOf('proprietary')) { wpaFlag = (wpaFlag ? 'PROP/' + wpaFlag : 'PROP'); }\n            }\n          }\n          if (l.indexOf('authentication suites') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('802.1x')) { wpaFlag = (wpaFlag ? '802.1x/' + wpaFlag : '802.1x'); }\n              else if (parts[1].indexOf('psk')) { wpaFlag = (wpaFlag ? 'PSK/' + wpaFlag : 'PSK'); }\n            }\n          }\n        });\n        if (wpaFlag) {\n          wpaFlags.push(wpaFlag);\n        }\n\n        result.push({\n          ssid,\n          bssid: address,\n          mode,\n          channel: channel ? util.toInt(channel) : null,\n          frequency: frequency ? util.toInt(frequency.replace('.', '')) : null,\n          signalLevel: db,\n          quality,\n          security,\n          wpaFlags,\n          rsnFlags: []\n        });\n      });\n    }\n    return result;\n  } catch (e) {\n    return -1;\n  }\n}\n\nfunction parseWifiDarwin(wifiObj) {\n  const result = [];\n  if (wifiObj) {\n    wifiObj.forEach(function (wifiItem) {\n      const signalLevel = wifiItem.RSSI;\n      let security = [];\n      let wpaFlags = [];\n      if (wifiItem.WPA_IE) {\n        security.push('WPA');\n        if (wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS) {\n          wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('PSK/TKIP') === -1) { wpaFlags.push('PSK/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      if (wifiItem.RSN_IE) {\n        security.push('WPA2');\n        if (wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS) {\n          wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('TKIP/TKIP') === -1) { wpaFlags.push('TKIP/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      result.push({\n        ssid: wifiItem.SSID_STR,\n        bssid: wifiItem.BSSID,\n        mode: '',\n        channel: wifiItem.CHANNEL,\n        frequency: wifiFrequencyFromChannel(wifiItem.CHANNEL),\n        signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,\n        quality: wifiQualityFromDB(signalLevel),\n        security,\n        wpaFlags,\n        rsnFlags: []\n      });\n    });\n  }\n  return result;\n}\nfunction wifiNetworks(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        result = getWifiNetworkListNmi();\n        if (result.length === 0) {\n          try {\n            const iwconfigParts = execSync('export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL').toString().split('\\n\\n');\n            let iface = '';\n            iwconfigParts.forEach(element => {\n              if (element.indexOf('no wireless') === -1 && element.trim() !== '') {\n                iface = element.split(' ')[0];\n              }\n            });\n            if (iface) {\n              const res = getWifiNetworkListIw(iface);\n              if (res === -1) {\n                // try again after 4 secs\n                setTimeout(function (iface) {\n                  const res = getWifiNetworkListIw(iface);\n                  if (res != -1) { result = res; }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                }, 4000);\n              } else {\n                result = res;\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        } else {\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        }\n      } else if (_darwin) {\n        let cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s -x';\n        exec(cmd, { maxBuffer: 1024 * 40000 }, function (error, stdout) {\n          const output = stdout.toString();\n          result = parseWifiDarwin(util.plistParser(output));\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show networks mode=Bssid';\n        util.powerShell(cmd).then((stdout) => {\n          const ssidParts = stdout.toString('utf8').split(os.EOL + os.EOL + 'SSID ');\n          ssidParts.shift();\n\n          ssidParts.forEach(ssidPart => {\n            const ssidLines = ssidPart.split(os.EOL);\n            if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(':') >= 0) {\n              const bssidsParts = ssidPart.split(' BSSID');\n              bssidsParts.shift();\n\n              bssidsParts.forEach((bssidPart) => {\n                const bssidLines = bssidPart.split(os.EOL);\n                const bssidLine = bssidLines[0].split(':');\n                bssidLine.shift();\n                const bssid = bssidLine.join(':').trim().toLowerCase();\n                const channel = bssidLines[3].split(':').pop().trim();\n                const quality = bssidLines[1].split(':').pop().trim();\n\n                result.push({\n                  ssid: ssidLines[0].split(':').pop().trim(),\n                  bssid,\n                  mode: '',\n                  channel: channel ? parseInt(channel, 10) : null,\n                  frequency: wifiFrequencyFromChannel(channel),\n                  signalLevel: wifiDBFromQuality(quality),\n                  quality: quality ? parseInt(quality, 10) : null,\n                  security: [ssidLines[2].split(':').pop().trim()],\n                  wpaFlags: [ssidLines[3].split(':').pop().trim()],\n                  rsnFlags: []\n                });\n              });\n            }\n          });\n\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiNetworks = wifiNetworks;\n\nfunction getVendor(model) {\n  model = model.toLowerCase();\n  let result = '';\n  if (model.indexOf('intel') >= 0) { result = 'Intel'; }\n  else if (model.indexOf('realtek') >= 0) { result = 'Realtek'; }\n  else if (model.indexOf('qualcom') >= 0) { result = 'Qualcom'; }\n  else if (model.indexOf('broadcom') >= 0) { result = 'Broadcom'; }\n  else if (model.indexOf('cavium') >= 0) { result = 'Cavium'; }\n  else if (model.indexOf('cisco') >= 0) { result = 'Cisco'; }\n  else if (model.indexOf('marvel') >= 0) { result = 'Marvel'; }\n  else if (model.indexOf('zyxel') >= 0) { result = 'Zyxel'; }\n  else if (model.indexOf('melanox') >= 0) { result = 'Melanox'; }\n  else if (model.indexOf('d-link') >= 0) { result = 'D-Link'; }\n  else if (model.indexOf('tp-link') >= 0) { result = 'TP-Link'; }\n  else if (model.indexOf('asus') >= 0) { result = 'Asus'; }\n  else if (model.indexOf('linksys') >= 0) { result = 'Linksys'; }\n  return result;\n}\n\nfunction wifiConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        const networkList = getWifiNetworkListNmi();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          const wpaDetails = wpaConnectionLinux(ifaceDetail.iface);\n          const ssid = nmiDetails.ssid || wpaDetails.ssid;\n          const network = networkList.filter(nw => nw.ssid === ssid);\n          const nmiConnection = nmiConnectionLinux(ssid);\n          const channel = network && network.length && network[0].channel ? network[0].channel : (wpaDetails.channel ? wpaDetails.channel : null);\n          const bssid = network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null);\n          if (ssid && bssid) {\n            result.push({\n              id: ifaceDetail.id,\n              iface: ifaceDetail.iface,\n              model: nmiDetails.product,\n              ssid,\n              bssid: network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null),\n              channel,\n              frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n              type: nmiConnection.type ? nmiConnection.type : '802.11',\n              security: nmiConnection.security ? nmiConnection.security : (wpaDetails.security ? wpaDetails.security : null),\n              signalLevel: network && network.length && network[0].signalLevel ? network[0].signalLevel : null,\n              txRate: null\n            });\n          }\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I';\n            exec(cmd, function (error, stdout) {\n              const lines2 = stdout.toString().split('\\n');\n              if (lines.length > 10) {\n                const ssid = util.getValue(lines2, 'ssid', ':', true);\n                const bssid = util.getValue(lines2, 'bssid', ':', true);\n                const security = util.getValue(lines2, 'link auth', ':', true);\n                const txRate = util.getValue(lines2, 'lastTxRate', ':', true);\n                const channel = util.getValue(lines2, 'channel', ':', true).split(',')[0];\n                const type = '802.11';\n                const rssi = util.toInt(util.getValue(lines2, 'agrCtlRSSI', ':', true));\n                const noise = util.toInt(util.getValue(lines2, 'agrCtlNoise', ':', true));\n                const signalLevel = rssi - noise;\n                if (ssid || bssid) {\n                  result.push({\n                    id: 'Wi-Fi',\n                    iface,\n                    model,\n                    ssid,\n                    bssid,\n                    channel: util.toInt(channel),\n                    frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                    type,\n                    security,\n                    signalLevel,\n                    txRate\n                  });\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const ssid = util.getValue(lines, 'SSID', ':', true);\n              const bssid = util.getValue(lines, 'BSSID', ':', true);\n              const signalLevel = util.getValue(lines, 'Signal', ':', true);\n              const type = util.getValue(lines, 'Radio type', ':', true) || util.getValue(lines, 'Type de radio', ':', true) || util.getValue(lines, 'Funktyp', ':', true) || null;\n              const security = util.getValue(lines, 'authentication', ':', true) || util.getValue(lines, 'Authentification', ':', true) || util.getValue(lines, 'Authentifizierung', ':', true) || null;\n              const channel = util.getValue(lines, 'Channel', ':', true) || util.getValue(lines, 'Canal', ':', true) || util.getValue(lines, 'Kanal', ':', true) || null;\n              const txRate = util.getValue(lines, 'Transmit rate (mbps)', ':', true) || util.getValue(lines, 'Transmission (mbit/s)', ':', true) || util.getValue(lines, 'Empfangsrate (MBit/s)', ':', true) || null;\n              if (model && id && ssid && bssid) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  ssid,\n                  bssid,\n                  channel: util.toInt(channel),\n                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                  type,\n                  security,\n                  signalLevel,\n                  txRate: util.toInt(txRate) || null\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiConnections = wifiConnections;\n\nfunction wifiInterfaces(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          result.push({\n            id: ifaceDetail.id,\n            iface: ifaceDetail.iface,\n            model: nmiDetails.product ? nmiDetails.product : null,\n            vendor: nmiDetails.vendor ? nmiDetails.vendor : null,\n            mac: ifaceDetail.mac,\n          });\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const mac = util.getValue(lines, 'MAC Address', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            result.push({\n              id: 'Wi-Fi',\n              iface,\n              model,\n              vendor: '',\n              mac\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const macParts = lines[3].indexOf(':') >= 0 ? lines[3].split(':') : [];\n              macParts.shift();\n              const mac = macParts.join(':').trim();\n              const vendor = getVendor(model);\n              if (iface && model && id && mac) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  vendor,\n                  mac,\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiInterfaces = wifiInterfaces;\n","module.exports={\n  \"name\": \"systeminformation\",\n  \"version\": \"5.17.12\",\n  \"description\": \"Advanced, lightweight system and OS information library\",\n  \"license\": \"MIT\",\n  \"author\": \"Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)\",\n  \"homepage\": \"https://systeminformation.io\",\n  \"main\": \"./lib/index.js\",\n  \"bin\": {\n    \"systeminformation\": \"lib/cli.js\"\n  },\n  \"types\": \"./lib/index.d.ts\",\n  \"scripts\": {\n    \"test\": \"node ./test/test.js\"\n  },\n  \"files\": [\n    \"lib/\"\n  ],\n  \"keywords\": [\n    \"system information\",\n    \"sysinfo\",\n    \"monitor\",\n    \"monitoring\",\n    \"os\",\n    \"linux\",\n    \"osx\",\n    \"windows\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"cpu\",\n    \"cpuload\",\n    \"physical cores\",\n    \"logical cores\",\n    \"processor\",\n    \"cores\",\n    \"threads\",\n    \"socket type\",\n    \"memory\",\n    \"file system\",\n    \"fsstats\",\n    \"diskio\",\n    \"block devices\",\n    \"netstats\",\n    \"network\",\n    \"network interfaces\",\n    \"network connections\",\n    \"network stats\",\n    \"iface\",\n    \"printer\",\n    \"processes\",\n    \"users\",\n    \"internet\",\n    \"battery\",\n    \"docker\",\n    \"docker stats\",\n    \"docker processes\",\n    \"graphics\",\n    \"graphic card\",\n    \"graphic controller\",\n    \"gpu\",\n    \"display\",\n    \"smart\",\n    \"disk layout\",\n    \"usb\",\n    \"audio\",\n    \"bluetooth\",\n    \"wifi\",\n    \"wifinetworks\",\n    \"virtual box\",\n    \"virtualbox\",\n    \"vm\",\n    \"backend\",\n    \"hardware\",\n    \"BIOS\",\n    \"chassis\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sebhildebrandt/systeminformation.git\"\n  },\n  \"funding\": {\n    \"type\": \"Buy me a coffee\",\n    \"url\": \"https://www.buymeacoffee.com/systeminfo\"\n  },\n  \"os\": [\n    \"darwin\",\n    \"linux\",\n    \"win32\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"sunos\",\n    \"android\"\n  ],\n  \"engines\": {\n    \"node\": \">=8.0.0\"\n  }\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBpbGVycy9jb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMiLCJhcHAvY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcyIsImFwcC9jb3JlL2NvcmUuanMiLCJhcHAvY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMiLCJhcHAvY29yZS9lcnJvcnMvY29tcGlsZUVycm9yLmpzIiwiYXBwL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcyIsImFwcC9jb3JlL2Vycm9ycy9lcnJvck1hbmFnZXIuanMiLCJhcHAvY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcyIsImFwcC9jb3JlL2V4ZWN1dGlvbi9jb21wb3NhYmxlTG9hZGVyLmpzIiwiYXBwL2NvcmUvZXhlY3V0aW9uL2V4ZWN1dGlvbk1hbmFnZXIuanMiLCJhcHAvY29yZS9leGVjdXRpb24vc3VwcG9ydExpYnJhcnkuanMiLCJhcHAvY29yZS9uZXR3b3JrL2RhdGFQcm9jZXNzaW5nRGV2aWNlLmpzIiwiYXBwL2NvcmUvbmV0d29yay9wb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0LmpzIiwiYXBwL2NvcmUvb2ZmbG9hZGluZy9hdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzLmpzIiwiYXBwL2NvcmUvb2ZmbG9hZGluZy9vZmZsb2FkaW5nRGVjaXNpb24uanMiLCJhcHAvY29yZS9vZmZsb2FkaW5nL29mZmxvYWRpbmdUYXJnZXQuanMiLCJhcHAvY29yZS9ydW5uZXJzL2Fzc2VtYmx5U2NyaXB0UnVubmVyLmpzIiwiYXBwL2NvcmUvcnVubmVycy9ydW5uZXIuanMiLCJhcHAvY29yZS9zd2V2YVNjcmlwdC9zd2V2YVNjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9fcnVsZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9mb3JtYXRzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcnVsZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3NjaGVtYV9vYmouanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbGxPZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2FueU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2l0ZW1zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWF4SXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhMZW5ndGguanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhQcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWF4aW11bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21pbkl0ZW1zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21pbmltdW0uanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tdWx0aXBsZU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbm90LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvb25lT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvdW5pcXVlSXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbiIsIm5vZGVfbW9kdWxlcy9hcy1iaW5kL2Rpc3QvYXMtYmluZC5janMuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtbXF0dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ibC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xvbmUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2QvYXV0by1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZHVwbGV4aWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZC1vZi1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL25vb3AuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci9pcy1uYW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvaXMtbmFuL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL2lzLW5hbi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvdG8tcG9zLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvX2l0ZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9jb3B5LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9tYXAuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9nZXQuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3Ivc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9pcy1uYXRpdmUtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9saWIvaXRlcmF0b3Ita2luZHMuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9saWIvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9pcy1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9saWIvcHJpdmF0ZS9nZW5lcmF0ZS1uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvbGliL3ByaXZhdGUvc2V0dXAvc3RhbmRhcmQtc3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2xpYi9wcml2YXRlL3NldHVwL3N5bWJvbC1yZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9leHQvZ2xvYmFsLXRoaXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZXh0L2dsb2JhbC10aGlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4dC9nbG9iYWwtdGhpcy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbi1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy10b2tlbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9tcXR0LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L251bWJlcnMuanMiLCJub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvcGFja2V0LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC93cml0ZVRvU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi9jb25uZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3QvdGNwLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3QvdGxzLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3Qvd3MuanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY29ubmVjdC93eC5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi9zdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi92YWxpZGF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvb3MtYnJvd3NlcmlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlaW50ZXJ2YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tc2hpZnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL2Z1bmN0aW9uL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3Jlc29sdmUtZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3NhZmUtdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3RvLXNob3J0LXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3BsYWluLWZ1bmN0aW9uL2Vuc3VyZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3BsYWluLWZ1bmN0aW9uL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvcHJvdG90eXBlL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvc3RyaW5nL2NvZXJjZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3ZhbHVlL2Vuc3VyZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3ZhbHVlL2lzLmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0LXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0LXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL3dzLWZhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9hdWRpby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvYmF0dGVyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvYmx1ZXRvb3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9jcHUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2RvY2tlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvZG9ja2VyU29ja2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9maWxlc3lzdGVtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9ncmFwaGljcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2ludGVybmV0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9tZW1vcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL25ldHdvcmsuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL29zaW5mby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvcHJpbnRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvcHJvY2Vzc2VzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9zeXN0ZW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3VzYi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvdXNlcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3ZpcnR1YWxib3guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3dpZmkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vcGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xTQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ptQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1OENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMva0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ252REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDem9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3p3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaHRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3R4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3h1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCc7XG5cbi8vdmFyIHthc2MsIGFzc2VtYmx5c2NyaXB0fSA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9hc3NlbWJseXNjcmlwdC9kaXN0L3Nkay5qcycpO1xuLy92YXIgQXNCaW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzLWJpbmQvZGlzdC9hcy1iaW5kLmNqcy5qcycpO1xuLy92YXIgQXNCaW5kVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzLWJpbmQvZGlzdC90cmFuc2Zvcm0uY2pzJyk7XG52YXIgUnVubmVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9ydW5uZXJzL3J1bm5lci5qcycpO1xudmFyIENvbXBpbGVyID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21waWxlcnMvY29tcGlsZXIuanMnKTtcbnZhciBBc0JpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXMtYmluZC9kaXN0L2FzLWJpbmQuY2pzLmpzJyk7XG52YXIgQ29tcG9zYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zYWJsZS5qcycpO1xudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcbnZhciBDb21waWxlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9jb21waWxlRXJyb3IuanMnKTtcbmNvbnN0IERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qc1wiKTtcbmNvbnN0IG9mZmxvYWRpbmdEZWNpc2lvbiA9IHJlcXVpcmUoXCIuLi9vZmZsb2FkaW5nL29mZmxvYWRpbmdEZWNpc2lvblwiKTtcblxuLy92YXIgQXNzZW1ibHlTY3JpcHRHZXR0ZXJUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2Fzc2VtYmx5U2NyaXB0R2V0dGVyVHJhbnNmb3JtLmpzJyk7XG5cbi8qKiBpbmNsdWRlIHdlYi13b3JrZXIgbGlicmFyeSBmb3IgTm9kZWpzICoqL1xuXG5pZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBOb2RlIHdvcmtlciBtb2R1bGVcIik7XG4gICAgdmFyIFdvcmtlck5vZGVKUyA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy93ZWItd29ya2VyL2Nqcy9ub2RlJyk7XG59XG5cblxuLyoqXG4gKiBUaGUgQXNzZW1ibHlTY3JpcHRDb21waWxlciBzdXBwb3J0cyBzdHJpY3QgVHlwZVNjcmlwdFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tcGlsZXJcbiAqXG4gKi9cbmZ1bmN0aW9uIEFzc2VtYmx5U2NyaXB0Q29tcGlsZXIoc3VwcG9ydExpYikge1xuICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICB0aGlzLmludGVybmFsR2V0dGVyUHJlZml4ID0gXCJfaW50ZXJuYWxfZ2V0X1wiO1xuICAgIHRoaXMuc3VwcG9ydExpYnJhcnlEZWNsYXJlcyA9IHRoaXMuZ2VuZXJhdGVTdXBwb3J0TGlicmFyeURlY2xhcmVzKHN1cHBvcnRMaWIpO1xuICAgIHRoaXMuc3VwcG9ydExpYnJhcnlEb2N1bWVudGF0aW9uID0gXCJUaGUgbGliIG5hbWVzcGFjZSBjb250YWlucyBhbGwgZnVuY3Rpb24gZnJvbSB0aGUgc3VwcG9ydCBsaWJyYXJ5LlxcblwiICtcbiAgICAgICAgXCJzeW5jaHJvbm91cyBmdW5jdGlvbnMgcmV0dXJuIHRoZWlyIHJlc3VsdCBpbW1lZGlhdGVseSwgd2hpbGUgdGhlIGNhbGxiYWNrIGZvciBhc3luY2hyb25vdXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciBhbGwgY3VycmVudGx5IHJ1bm5pbmcgQXNzZW1ibHlTY3JpcHQgY29kZSBpcyBmaW5pc2hlZC5cXG5cIiArXG4gICAgICAgIFwiQ2FsbGJhY2sgZnVuY3Rpb25zIGNhbiBoYXZlIGxlc3MgcGFyYW1ldGVycyB0aGFuIHRoZSBsaXN0ZWQgcGFyYW1ldGVycywgaW4gd2hpY2ggY2FzZSBvbmx5IHRoZSBmaXJzdCBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXFxuXCIgK1xuICAgICAgICBcIkZ1bmN0aW9uczpcXG5cIjtcbiAgICB0aGlzLnJlc29sdmVDb21waWxlID0gbnVsbDtcbn1cblxuLy9pbmhlcml0IHByb3BlcnRpZXNcbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21waWxlci5wcm90b3R5cGUpO1xuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlbWJseVNjcmlwdENvbXBpbGVyO1xuXG4vKipcbiAqIGdlbmVyYXRlcyBkZWNsYXJlIHN0YXRlbWVudHMgbmVjZXNzYXJ5LCB0byBhY2Nlc3MgSmF2YVNjcmlwdCBmdW5jdGlvbnMgZnJvbSBBc3NlbWJseVNjcmlwdFxuICogYWRkaXRpb25hbGx5IHRoZSBkb2N1bWVudGF0aW9uIGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHN1cHBvcnRMaWJcbiAqL1xuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuZ2VuZXJhdGVTdXBwb3J0TGlicmFyeURlY2xhcmVzID0gZnVuY3Rpb24gKHN1cHBvcnRMaWIpIHtcbiAgICBsZXQgZG9jcyA9IFwiXCI7XG4gICAgbGV0IGRlY2xhcmVzID0gXCJuYW1lc3BhY2UgbGliIHtcXG5cIjtcbiAgICBmb3IobGV0IGZ1bmNOYW1lIGluIHN1cHBvcnRMaWIuZnVuY3Rpb25zKSB7XG4gICAgICAgIGxldCByZXR1cm5TaWcgPSBzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0ubGFuZ3VhZ2VTcGVjaWZpYy50eXBlc2NyaXB0LnJldHVyblNpZyB8fCBcInZvaWRcIjtcbiAgICAgICAgbGV0IHBhcmFtU2lnID0gc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmxhbmd1YWdlU3BlY2lmaWMudHlwZXNjcmlwdC5wYXJhbWV0ZXJTaWc7XG4gICAgICAgIC8vY2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBpcyBmaXJzdCBwYXJhbWV0ZXIgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnNcbiAgICAgICAgaWYoc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmFzeW5jKSB7XG4gICAgICAgICAgICBwYXJhbVNpZyA9IFwiY2FsbGJhY2s6IHN0cmluZyB8IG51bGxcIiArICh0eXBlb2YgcGFyYW1TaWcgIT09IHVuZGVmaW5lZCA/IFwiLCBcIitwYXJhbVNpZyA6IFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuU2lnID0gXCJ2b2lkXCI7XG4gICAgICAgIH1cbiAgICAgICAgZG9jcyArPSBmdW5jTmFtZStcIjpcXG5cIitcbiAgICAgICAgICAgIFwiICBEZXNjcmlwdGlvbjogXCIrc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmRlc2NyaXB0aW9uK1wiXFxuXCIrXG4gICAgICAgICAgICBcIiAgUGFyYW1ldGVyczogXFxcIlwiK3BhcmFtU2lnK1wiXFxcIlxcblwiK1xuICAgICAgICAgICAgXCIgIFwiKyhzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0uYXN5bmM/XG4gICAgICAgICAgICAgICAgXCJBc3luYyBmdW5jdGlvbjogY2FsbGJhY2sgd2l0aCBzaWduYXR1cmUgXFxcIlwiK3N1cHBvcnRMaWIuZnVuY3Rpb25zW2Z1bmNOYW1lXS5sYW5ndWFnZVNwZWNpZmljLnR5cGVzY3JpcHQucmV0dXJuU2lnK1wiXFxcIiByZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIFwiU3luYyBmdW5jdGlvbjogcmV0dXJucyBcXFwiXCIrcmV0dXJuU2lnK1wiXFxcIlwiKStcbiAgICAgICAgICAgIFwiXFxuXCI7XG4gICAgICAgIGRlY2xhcmVzICs9IFwiZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgcGFyYW1TaWcgKyBcIik6XCIgKyByZXR1cm5TaWcgKyBcIjtcXG5cIjtcbiAgICB9XG4gICAgZGVjbGFyZXMgKz0gXCJ9XCI7XG4gICAgdGhpcy5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb24gPSBkb2NzO1xuICAgIGNvbnNvbGUubG9nKFwiU3VwcG9ydCBmdW5jdGlvbnM6XCIpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMuc3VwcG9ydExpYnJhcnlEb2N1bWVudGF0aW9uKTtcbiAgICBjb25zb2xlLmxvZyhkZWNsYXJlcylcbiAgICByZXR1cm4gZGVjbGFyZXM7XG59XG5cbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlLnNldHVwID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCF0aGlzLnNldHVwQ29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkaW5nIEFzc2VtYmx5U2NyaXB0IGNvbXBpbGVyXCIpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRXb3JrZXIoKTtcblxuICAgICAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbXNnIHRvIHdvcmtlcicpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmRhdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2V0dXBDb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzZXR1cCBjb21wbGV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXR1cENvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbXBpbGVFcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGlsZVJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZi5yZXNvbHZlQ29tcGlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNvbHZlQ29tcGlsZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlLmluaXRXb3JrZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZih0eXBlb2YgdGhpcy53b3JrZXIgIT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy53b3JrZXIgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICB9XG5cbiAgICAvL2RpZmZlcmVudCBwYXRoIGZvciBOb2RlSlNcbiAgICBpZihzd2V2YS5pbkJyb3dzZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJMb2FkIHdvcmtlciBmb3Igd2ViYnJvd3NlclwiKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcvbm9kZV9tb2R1bGVzL3N3ZXZhLWNvcmUvYXBwL2NvcmUvY29tcGlsZXJzL2Fzc2VtYmx5U2NyaXB0Q29tcGlsZXJXb3JrZXIuanMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWQgd29ya2VyIGZvciBOb2RlSlNcIik7XG4gICAgICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlck5vZGVKUygnYXBwL2NvcmUvY29tcGlsZXJzL2Fzc2VtYmx5U2NyaXB0Q29tcGlsZXJXb3JrZXIuanMnKTtcbiAgICB9XG59XG4vLyBNQVxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHdoaWxlICh0aGlzLmN1cnJlbnRseUNvbXBpbGluZykge1xuICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlV2FpdCA9PiBzZXRUaW1lb3V0KHJlc29sdmVXYWl0LCAxKSk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudGx5Q29tcGlsaW5nID0gdHJ1ZTtcblxuICAgIC8vbG9hZCBjb21waWxlclxuICAgIGF3YWl0IHRoaXMuc2V0dXAoKTtcblxuICAgIGxldCBkb25lQ29tcGlsaW5nID0gZmFsc2U7XG4gICAgbGV0IG9mZmxvYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaW50ZXJ2YWxJRDtcbiAgICBsZXQgb2RMaXN0ID1zd2V2YS5FeGVjdXRpb25NYW5hZ2VyLmdldE9ETGlzdCgpOyAvL3RvZG86IHVzZXIgaW5wdXRcbiAgICBjb25zb2xlLmxvZyhcIm9kTGlzdCBpbiBBU0MgY29tcGlsZXIgPSBcIixvZExpc3QpO1xuXG4gICAgbGV0IGVuZENQVSA9IDA7XG4gICAgbGV0IGNwdU1vbml0b3I9MDtcbiAgICAvLyBpbml0aWFsIG1lbSAvIGJhdHRlcnkgY2hlY2tcbiAgICBvZmZsb2FkaW5nID0gYXdhaXQgb2ZmbG9hZGluZ0RlY2lzaW9uKG9kTGlzdCk7XG4gICAgY29uc29sZS5sb2coJ2luaXRpYWwgb2ZmbG9hZGluZyBkZWNpc2lvbiA9ICcsb2ZmbG9hZGluZyk7XG4gICAgaWYgKG9mZmxvYWRpbmcpIHtcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uOiBzcGVlZCBpcyBrZXkgd2UgZG8gdGhpcyBhZnRlciByZXNvbHZpbmcgcHJvbWlzZVxuICAgICAgICAvL2NsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJRCk7XG4gICAgICAgIC8vYWJvcnQgcnVubmluZyBjb21waWxhdGlvblxuICAgICAgICByZXR1cm4gKCdvZmZsb2FkaW5nJyk7XG4gICAgfVxuICAgIGxldCBzdGFydENQVSA9cGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIC8vbW9uaXRvcmluZyB0aGUgY29tcGlsYXRpb24gcHJvY2Vzc1xuICAgICAgICBuZXcgUHJvbWlzZSggYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWdpbiBwZXJpb2RpYyBtb25pdG9yaW5nIGV4ZWN1dGlvbi4uLicpO1xuICAgICAgICAgICAgLy8gaW50ZXJ2YWwgY2hlY2tcbiAgICAgICAgICAgIGludGVydmFsSUQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZW5kQ1BVID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgY3B1TW9uaXRvciA9ICgoZW5kQ1BVIC0gc3RhcnRDUFUpLzUwMDApKjEwMDtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdDUFUgVElNRT0gJywgY3B1TW9uaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKGNwdU1vbml0b3IgPiBvZExpc3RbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvZmZsb2FkaW5nT3V0cHV0JCBNb25pdG9yaW5nID0gQ1BVIGxpbWl0IGV4Y2VlZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdvZmZsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZmxvYWRpbmcgPSBhd2FpdCBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGVyaW9kaWMgb2ZmbG9hZGluZyBkZWNpc2lvbiA9ICcsIG9mZmxvYWRpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXphdGlvbjogc3BlZWQgaXMga2V5IHdlIGRvIHRoaXMgYWZ0ZXIgcmVzb2x2aW5nIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLy9jbGVhckludGVydmFsKGludGVydmFsSUQpO1xuICAgICAgICAgICAgICAgICAgICAvL2Fib3J0IHJ1bm5pbmcgY29tcGlsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2ZmbG9hZGluZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8vIGNvbXBpbGluZyB0aGUgbW9kdWxlXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbXBpbGUgPSByZXNvbHZlO1xuICAgICAgICAgICAgZG9uZUNvbXBpbGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTogXCJjb21waWxlXCIsIHNvdXJjZTogc2VsZi5wcmVwYXJlU291cmNlQ29kZShtb2R1bGUuc291cmNlKX0pO1xuXG4gICAgICAgIH0pXG5cbiAgICBdKS5cbiAgICB0aGVuKCh3cikgPT4ge1xuXG4gICAgICAgIGxldCB3b3JrZXJSZXN1bHQgPSB3cjtcblxuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSUQpOyAvL2NsZWFyIG1vbml0b3JpbmcgaW50ZXJ2YWwgaWYgbm8gb2ZmbG9hZGluZyBuZWNlc3NhcnlcbiAgICAgICAgY29uc29sZS5sb2coJ3dvcmtlclJlc3VsdCcpO1xuICAgICAgICBjb25zb2xlLmxvZyh3b3JrZXJSZXN1bHQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRseUNvbXBpbGluZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbXBpbGUgPSBudWxsO1xuXG4gICAgICAgIGlmICh3b3JrZXJSZXN1bHQudHlwZSA9PT0gXCJjb21waWxlUmVzdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBPZmZsb2FkaW5nIG5vdCBuZWVkZWQuIFByb2NlZWQgYXMgbm9ybWFsJyk7XG4gICAgICAgICAgICByZXR1cm4gd29ya2VyUmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtlclJlc3VsdCA9PT0gJ29mZmxvYWRpbmcnKSB7XG4gICAgICAgICAgICAvL3RvZG86IG9mZmxvYWRpbmcgY2FsbGJhY2tcbiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvZmZsb2FkaW5nT3V0cHV0JCBPZmZsb2FkaW5nIG5lY2Vzc2FyeS4gQ2FsbGJhY2sgdHJpZ2dlcmVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuICdvZmZsb2FkaW5nJzsgLy90b2RvOiBpcyBTdHJpbmcgYSBnb29kIERUIGZvciByZXR1cm4gP1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlRXJyb3Iod29ya2VyUmVzdWx0Lm1lc3NhZ2UsIG1vZHVsZS5jb250ZXh0KTsgIC8vIENvbXBpbGVyIEVycm9yIGhhbmRsaW5nXG5cbiAgICB9KTtcblxufVxuXG5cbkFzc2VtYmx5U2NyaXB0Q29tcGlsZXIucHJvdG90eXBlLnByZXBhcmVTb3VyY2VDb2RlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgbGV0IGdldHRlcnMgPSB0aGlzLmdlbmVyYXRlR2xvYmFsR2V0dGVycyhzb3VyY2UpO1xuICAgIGxldCBzb3VyY2VTdHIgPSBzb3VyY2Uuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0TGlicmFyeURlY2xhcmVzICsgc291cmNlU3RyICsgZ2V0dGVycztcbn1cblxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuZ2VuZXJhdGVHbG9iYWxHZXR0ZXJzID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgbGV0IGdldHRlcnMgPSBcIlwiO1xuICAgIGZvcihsZXQgbGluZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYoc291cmNlLmluY2x1ZGVzKHRoaXMuaW50ZXJuYWxHZXR0ZXJQcmVmaXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKFwiRG8gbm90IHVzZSBcIit0aGlzLmludGVybmFsR2V0dGVyUHJlZml4K1wiIGZvciBuYW1lcyBpbiB5b3VyIHNvdXJjZSwgYXMgaXQgaXMgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzZS5cIiwgXCJjb21waWxlRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzb3VyY2VbbGluZV0uaW5kZXhPZihcImV4cG9ydCB2YXJcIikgPT09IDApIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBzb3VyY2VbbGluZV0uc3BsaXQoJz0nKVswXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBcImFueXJlZlwiO1xuICAgICAgICAgICAgaWYodG1wLmxlbmd0aCA+PSAyKVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0bXBbMV0uc3BsaXQoL1tcXHM9XSsvKS5maWx0ZXIoeCA9PiB4ICE9PSBcIlwiKVswXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZUVycm9yKFwiRXhwb3J0ZWQgdmFyaWFibGVzIHJlcXVpcmUgYW4gZXhwbGljaXQgdHlwZSEgXFxuXFxcIlwiK3NvdXJjZVtsaW5lXStcIlxcXCIgZG9lcyBub3QgY29udGFpbiBhIHR5cGUuXCIsIFwiY29tcGlsZUVycm9yXCIpO1xuICAgICAgICAgICAgdG1wID0gdG1wWzBdLnNwbGl0KC9bXFxzPV0rLykuZmlsdGVyKHggPT4geCAhPT0gXCJcIik7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHRtcFt0bXAubGVuZ3RoLTFdO1xuICAgICAgICAgICAgZ2V0dGVycyArPSBcImV4cG9ydCBmdW5jdGlvbiBcIit0aGlzLmludGVybmFsR2V0dGVyUHJlZml4K25hbWUrXCIoKTpcIit0eXBlK1wiIHsgcmV0dXJuIFwiK25hbWUrXCI7IH1cXG5cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXJzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VtYmx5U2NyaXB0Q29tcGlsZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBjb21waWxlciBsb2FkcyB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyBmb3IgY29tcGlsYXRpb24gb2YgYSBsYW5ndWFnZSwgY29tcGlsZXMgY29kZSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGJpbmFyeS5cbiAqIEl0IGhhcyB0d28gcGhhc2VzOiBBIHNldHVwIHBoYXNlLCB3ZXJlIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgYW5kIGFuIG9wZXJhdGlvbmFsIHBoYXNlLCB3aGljaCBpcyB1c2VkIHRvIGNvbXBpbGUgY29kZVxuICogXG4gKiBUaGUgc2V0dXAgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UsIHdoaWxlIHRoZSBleGVjdXRpb24gY2FuIGJlIHJlcGVhdGVkIG9uIGRpZmZlcmVudCBkYXRhLlxuICogQWRkaXRpb25hbGx5IHRoZSBzZXR1cCBzaG91bGQgb25seSBiZSBjYWxsZWQsIHdoZW4gdGhlIGNvbXBpbGVyIGlzIG5lZWRlZCwgYmVjYXVzZSBzb21lIGRlcGVuZGVuY2llcyBmb3IgY29tcGlsaW5nIGNhbiBiZSB2ZXJ5IGxhcmdlXG4gKiBcbiAqIFRoaXMgaXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCByZXR1cm5pbmcgdGhlIGlucHV0IHNvdXJjZSBhcyB0aGUgY29tcGlsZWQgY29kZS4gSXQgY2FuIGJlIHVzZWQgZm9yIGludGVycHJldGVkIGxhbmd1YWdlcy5cbiAqXG4gKiBAcGFyYW0ge1N1cHBvcnRMaWJyYXJ5fSBzdXBwb3J0TGlicmFyeSAtIHNvdXJjZSBjb2RlIHRvIGNvbXBpbGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb21waWxlcihzdXBwb3J0TGlicmFyeSkge1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMsIGlmIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkLlxuICAgICAqIEBuYW1lIENvbXBpbGVyI3NldHVwQ29tcGxldGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5zZXR1cENvbXBsZXRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRhdGlvbiBmb3IgZnVuY3Rpb25zIGluIHN1cHBvcnQgbGlicmFyeSAtIHNob3VsZCBpbmNsdWRlIHNwZWNpZmljcyBvbiBsYW5ndWFnZSBzeW50YXhcbiAgICAgKiBBdmFpbGFibGUgYWZ0ZXIgQ29tcGlsZXIjc2V0dXAoKSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogQG5hbWUgQ29tcGlsZXIjc2V0dXBDb21wbGV0ZWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3VwcG9ydExpYnJhcnlEb2N1bWVudGF0aW9uID0gXCJcIjtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSBwcm92aWRlZCBzb3VyY2UgY29kZVxuICogQHBhcmFtIHttb2R1bGV9IHNvdXJjZSAtIHNvdXJjZSBjb2RlIHRvIGNvbXBpbGVcbiAqIEByZXR1cm4ge29iamVjdH0gY29udGFpbmluZyBiaW5hcnlEYXRhIGFuZCBvcHRpb25hbGx5IG90aGVyIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgY29tcGlsZXJzXG4gKi9cbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2U7XG59XG4gICBcbi8qKlxuICogTG9hZHMgZGVwZW5kZW5jaWVzXG4gKi9cbkNvbXBpbGVyLnByb3RvdHlwZS5zZXR1cCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBpZighdGhpcy5zZXR1cENvbXBsZXRlZCkge1xuICAgICAgICB0aGlzLnNldHVwQ29tcGxldGVkID0gdHJ1ZTtcbiAgICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlciIsIid1c2Ugc3RyaWN0JztcblxudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcbnZhciBDbG9uZSA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcycpO1xuXG4vKipcbiAqIENvbXBvc2FibGVzIHByb2Nlc3MgZGF0YS4gVGhleSBjYW4gYmUgbGlua2VkIGludG8gbmV0d29ya3MuXG4gKiBAYWJzdHJhY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb21wb3NhYmxlKCkge1xufVxuLyoqXG4gKiBBIGRlZmluaXRpb24gb2YgYSBKU09OIG9iamVjdC5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZG9jdW1lbnRhdGlvbi5odG1sfVxuICogQHR5cGVkZWYge09iamVjdH0gSlNPTlNjaGVtYVxuICovXG5cbi8qKlxuICogVGhlIGluaXRhbGl6YXRpb24gb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyB0byBpbml0aWFsaXplIGNvbXBvc2FibGVzLlxuICogQHR5cGVkZWYge09iamVjdH0gY29tcG9zYWJsZUluaXRhbGl6ZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZT1zb21lQ29tcG9zYWJsZV0gLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT1tb2R1bGVdIC0gVGhlIHR5cGUgb2YgdGhlIGNvbXBvc2FibGU6ICdtb2R1bGUnIG9yICdjb21wb3NpdGlvbicuXG4gKiBAcHJvcGVydHkge0pTT05TY2hlbWF9IFtkYXRhSW5TY2hlbWE9bnVsbF0gLSBUaGUgc2NoZW1hIG9mIHRoZSBleHBlY3RlZCBkYXRhIG9iamVjdCByZWNlaXZlZCBmcm9tIG90aGVyIGNvbXBvc2FibGVzLlxuICogQHByb3BlcnR5IHtKU09OU2NoZW1hfSBbZGF0YU91dFNjaGVtYT1udWxsXSAtIFRoZSBzY2hlbWEgb2YgdGhlIGRhdGEgb2JqZWN0IHBhc3NlZCBvbiB0byBsYXRlciBjb21wb3NhYmxlcy5cbiAqIEBwcm9wZXJ0eSB7SlNPTlNjaGVtYX0gW2lucHV0U2NoZW1hPW51bGxdIC0gVGhlIHNjaGVtYSBvZiB0aGUgaW5wdXQgb2JqZWN0IHJlY2VpdmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgZXhlY3Rpb24uXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbZGF0YUluTmFtZXM9WydkYXRhJ11dIC0gVGhlIG5hbWVzIG9mIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIG9mIHRoZSByZWNlaXZlZCBkYXRhIG9iamVjdC5cbiAqIElmIHRoZXJlIGlzIG9ubHkgb25lIGVsZW1lbnQsIHRoZSBhcnJheSBpcyBpZ25vcmVkIGFuZCB0aGUgd2hvbGUgZGF0YSBvYmplY3QgaXMgdGFrZW4gKG5vIHByb3BlcnR5IG5hbWVzIG5lZWRlZCkuXG4gKiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGFyZSBuZWVkZWQsIGlmIHlvdSB3YW50IHRvIHJlY2VpdmUgZGF0YSBmcm9tIG11bHRpcGxlIG90aGVyIGNvbXBvc2FibGVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFtkYXRhT3V0TmFtZXM9WydyZXN1bHQnXV0gLSBUaGUgbmFtZXMgb2YgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgb2YgdGhlIHByb2R1Y2VkIGRhdGEgb2JqZWN0LlxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgZWxlbWVudCwgdGhlIGFycmF5IGlzIGlnbm9yZWQgYW5kIHRoZSB3aG9sZSBkYXRhIG9iamVjdCBpcyB0YWtlbiAobm8gcHJvcGVydHkgbmFtZXMgbmVlZGVkKS5cbiAqIE11bHRpcGxlIHByb3BlcnRpZXMgYXJlIG5lZWRlZCwgaWYgeW91IHdhbnQgdG8gc2VuZCBkYXRhIHRvIG11bHRpcGxlIG90aGVyIGNvbXBvc2FibGVzLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFtpbnB1dE5hbWVzPVtdXSAtIFRoZSBuYW1lcyBvZiB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgb2JqZWN0LlxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgZWxlbWVudCwgdGhlIGFycmF5IGlzIGlnbm9yZWQgYW5kIHRoZSB3aG9sZSBpbnB1dCBvYmplY3QgaXMgdGFrZW4gKG5vIHByb3BlcnR5IG5hbWVzIG5lZWRlZCkuXG4gKi9cblxuLyoqIEluaXRpYWxpemVzIHRoZSBvYmplY3Qgd2l0aCBhIHByb3BlcnR5IG9iamVjdC5cbiAgKiBOb3QgZGVmaW5lZCBQcm9wZXJ0aWVzIHdpbGwgZ2V0IGEgZGVmYXVsdCB2YWx1ZS5cbiAqICBAcHJvdGVjdGVkXG4gKiAgQHBhcmFtIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gaW5pdGlhbGl6YXRpb25PYmplY3QgLSBUaGUgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGNvbXBvc2FibGUuXG4gKi9cbkNvbXBvc2FibGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoaW5pdGlhbGl6YXRpb25PYmplY3QpIHtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ25hbWUnLCAnc29tZUNvbXBvc2FibGUnKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ3R5cGUnLCAnbW9kdWxlJyk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdkYXRhSW5TY2hlbWEnLCBudWxsKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2RhdGFPdXRTY2hlbWEnLCBudWxsKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2lucHV0U2NoZW1hJywgbnVsbCk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2RhdGFJbk5hbWVzJywgW10pO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnZGF0YU91dE5hbWVzJywgW10pO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnaW5wdXROYW1lcycsIFtdKTtcblxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBleHBlY3RlZCBwcm9wZXJ0aWVzIGZvciB0aGUgcmVjZWl2ZWQgZGF0YSBvYmplY3QuXG4gICAgICogQG5hbWUgQ29tcG9zYWJsZSNkYXRhSW5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YUluID0gdGhpcy5kYXRhSW5OYW1lcy5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAqIEFtb3VudCBvZiBleHBlY3RlZCBwcm9wZXJ0aWVzIGZvciB0aGUgcHJvZHVjZWQgZGF0YSBvYmplY3QuXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlI2RhdGFPdXRcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aGlzLmRhdGFPdXQgPSB0aGlzLmRhdGFPdXROYW1lcy5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAqIEFtb3VudCBvZiBleHBlY3RlZCBwcm9wZXJ0aWVzIGZvciB0aGUgcmVjZWl2ZWQgaW5wdXQgb2JqZWN0XG4gICAgKiBAbmFtZSBDb21wb3NhYmxlI2lucHV0SW5cbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aGlzLmlucHV0SW4gPSB0aGlzLmlucHV0TmFtZXMubGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgY29udGV4dCBvZiB0aGUgY29tcG9zYWJsZSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgICAqIEBuYW1lIENvbXBvc2FibGUjY29udGV4dFxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY29uc3RydWN0b3IubmFtZSArICdbJyArIHRoaXMubmFtZSArICddJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBpbnRlcm5hbCB2YXJpYWJsZXMuIFNldHMgYWxzbyBkZWZhdWx0IHZhbHVlcy5cbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7Y29tcG9zYWJsZUluaXRhbGl6ZXJ9IGluaXRpYWxpemF0aW9uT2JqZWN0IC0gVGhlIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBjb21wb3NhYmxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHZhbHVlIHRvIHNldC4gVGhlIG5hbWUgbXVzdCBiZSB0aGUgc2FtZSBib3RoIGZvciAndGhpcycgYW5kIGluaXRpYWxpemF0aW9uT2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIEEgZGVmYXVsdCB2YWx1ZSBpcyBzZXQsIGlmIGluaXRpYWxpemF0aW9uT2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gc3VjaCBhIHByb3BlcnR5IGtleS5cbiAqL1xuQ29tcG9zYWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGluaXRpYWxpemF0aW9uT2JqZWN0LFxuICAgIHByb3BlcnR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaW5pdGlhbGl6YXRpb25PYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHZhciBvYmogPSBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBpbml0aWFsaXplIGludGVybmFsIGZ1bmN0aW9ucy4gU2V0cyBhbHNvIGRlZmF1bHQgdmFsdWVzLlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gaW5pdGlhbGl6YXRpb25PYmplY3QgLSBUaGUgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGNvbXBvc2FibGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdmFsdWUgdG8gc2V0LiBUaGUgbmFtZSBtdXN0IGJlIHRoZSBzYW1lIGJvdGggZm9yICd0aGlzJyBhbmQgaW5pdGlhbGl6YXRpb25PYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwZWN0ZWRBcmd1bWVudHNDb3VudCAtIFRoZSBhbW91bnQgb2YgYXJndW1lbnRzIHRoZSBleHBlY3RlZCBmdW5jdGlvbiBuZWVkcyB0byBoYXZlLiBPbiBtaXNtYXRjaCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZWZhdWx0VmFsdWUgLSBBIGRlZmF1bHQgdmFsdWUgaXMgc2V0LCBpZiBpbml0aWFsaXphdGlvbk9iamVjdCBkb2VzIG5vdCBjb250YWluIHN1Y2ggYSBwcm9wZXJ0eSBrZXkuXG4gKi9cbkNvbXBvc2FibGUucHJvdG90eXBlLmluaXRpYWxpemVGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbml0aWFsaXphdGlvbk9iamVjdCxcbiAgICBwcm9wZXJ0eSwgZXhwZWN0ZWRBcmd1bWVudHNDb3VudCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGluaXRpYWxpemF0aW9uT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAvL2NoZWNrIGlmIGl0IGlzIHJlYWxseSBhIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvL3RoZSBleHBlY3RlZCBmdW5jdGlvbnMgKHdoaWNoIGNhbiBiZSBkZWZpbmVkIGJ5IHRoZSBjb21wb3NhYmxlIGNyZWF0b3JzKSBoYXZlIGEgZml4ZWQgc2lnbmF0dXJlIChhcmd1bWVudHMpLFxuICAgICAgICAgICAgLy9zbyBjaGVjayBoZXJlIGZvciB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XS5sZW5ndGggPj0gZXhwZWN0ZWRBcmd1bWVudHNDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdmdW5jdGlvbiBcIicgKyBwcm9wZXJ0eSArICdcIiByZXF1aXJlcyBhdCBsZWFzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRBcmd1bWVudHNDb3VudCArICcgYXJndW1lbnRzLCBidXQgcHJvdmlkZXMgb25seSAnICtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZm9yIG5vdyBpZ25vcmUsIGFzIHNvbWUgZnVuY3Rpb25zIGFyZSBvcHRpb25hbFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ1wiJyArIHByb3BlcnR5ICsgJ1wiIGlzIHJlc2VydmVkIGZvciBmdW5jdGlvbnMsIGJ1dCBub3QgZGVmaW5lZCBhcyBvbmUnLFxuICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogQ2xvbmVzIHRoZSBjdXJyZW50IGNvbXBvc2FibGUgYW5kIG92ZXJ3cml0ZXMvYWRkcyBhbGwgdGhlIHByb3BlcnRpZXMgc3BlY2lmaWVkIGluIGFuIGV4dGVuZGVyIG9iamVjdC5cbiAqIFRoaXMgYWxsb3dzIHNvbWUgc29ydCBvZiBjb21wb3NhYmxlIGluaGVyaXRhbmNlLlxuICogQHRoaXMgQ29tcG9zYWJsZVxuICogQHBhcmFtIHtDb21wb3NhYmxlfSBleHRlbmRlciAtIFRoZSBwYXJ0aWFsIGNvbXBvc2FibGUgZnJvbSB3aGljaCB0byB0YWtlIHRoZSBuZXcgdmFsdWVzLlxuICogQHJldHVybnMge0NvbXBvc2FibGV9IFRoZSBjbG9uZWQgYW5kIGV4dGVuZGVkIGNvbXBvc2FibGUgb2JqZWN0LlxuICovXG5Db21wb3NhYmxlLnByb3RvdHlwZS5leHRlbmRXaXRoID0gZnVuY3Rpb24gKGV4dGVuZGVyKSB7XG4gICAgdmFyIGNsb25lZCA9IENsb25lKHRoaXMpO1xuICAgIGZvciAodmFyIGtleSBpbiBleHRlbmRlcikge1xuICAgICAgICAvL3dlIGRvbid0IHdhbnQgdG8gY2xvbmUgJ2V4dGVuZHMnIGFzIGl0IGlzIGFuIGluZGljYXRvciwgdGhhdCBhIGNvbXBvc2FibGUgd2FudHMgdG8gZXh0ZW5kIGFub3RoZXIuIEkuZS4gV2hhdCB3ZSBhcmUgZG9pbmcgaGVyZSA6KVxuICAgICAgICBpZiAoZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT0gJ2V4dGVuZHMnKSB7XG4gICAgICAgICAgICBjbG9uZWRba2V5XSA9IGV4dGVuZGVyW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgY29udGV4dCBkdXJpbmcgdGhlIGV4ZWN1dGlvbi4gSXQgdXNlcyB0aGUgcGFyZW50J3MgY29udGV4dCBhbmQgdGhlIGFsaWFzLCB0aGUgcGFyZW50IGhhcyBnaXZlbiB0aGlzIGNvbXBvc2FibGUuXG4gKiBsb29rcyBsaWtlOiBDb21wb3NpdGlvbltjb21wb3NpdGlvbjFdLk1vZHVsZVttb2R1bGUxXVxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgcGFyZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIC0gVGhlIGFsaWFzIChuYW1lKSB1c2VkIGluIHRoZSBwYXJlbnQgZm9yIHRoaXMgY29tcG9zYWJsZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVwZGF0ZWQgY29udGV4dC5cbiAqL1xuQ29tcG9zYWJsZS5wcm90b3R5cGUuZ2V0TmV3Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhcykge1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9hbGlhcyBpcyBvcHRpb25hbCwgc28gY2hlY2sgaWYgaXQgaXMgZGVmaW5lZFxuICAgICAgICBpZiAodHlwZW9mIGFsaWFzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYWxpYXMgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsaWFzID0gJzogJyArIGFsaWFzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0ICsgJy4nICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ1snICsgdGhpcy5uYW1lICsgYWxpYXMgKyAnXSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcywgaWYgYSBnaXZlbiBvYmplY3QgaGFzIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmUgKHR5cGVjaGVjaykgY29tcGF0aWJsZSB0byB0aGlzIGNvbXBvc2FibGUuXG4gKiBJZiBhdmFpbGFibGUsIGl0IHVzZXMgdGhlIHByb3ZpZGVkIEpTT04gc2NoZW1hLCBvdGhlcndpc2UgKG5vY2ggc2NobWVtYSBhdmFpbGFibGUpIGl0IG9ubHkgY2hlY2tzLCBpZiB0aGUgb2JqZWN0IGhhcyBhbGwgcmVxdWlyZWQgcHJvcGVydHkga2V5cy4gRGVmaW5lZCBieSB0aGUgKk5hbWVzIGFycmF5cyAoc2VlIHtAbGluayBjb21wb3NhYmxlSW5pdGFsaXplcn0pLlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFR5cGUgb2Ygb2JqZWN0LCBuZWVkZWQgdG8gc2VsZWN0IHRoZSBjb3JyZWN0IHR5cGUgZGVmaW5pdGlvbi4gVXNlICdkYXRhSW4nLCAnZGF0YU91dCcgLCAnaW5wdXQnIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3QsIHRoYXQgc2hvdWxkIGJlIHZhbGlkYXRlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUsIGlmIHRoZSBvYmplY3QgaXMgY29tcGF0aWJsZSB0byB0aGlzIGNvbXBvc2FibGUgcmVnYXJkaW5nIHRoZSBnaXZlbiB0eXBlLlxuICovXG5Db21wb3NhYmxlLnByb3RvdHlwZS52YWxpZGF0ZVR5cGVzID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuICAgIHZhciB0eXBlTmFtZXMgPSB0aGlzW3R5cGUgKyAnTmFtZXMnXTtcbiAgICB2YXIgdHlwZVNjaGVtYSA9IHRoaXNbdHlwZSArICdTY2hlbWEnXTtcbiAgICBcbiAgICAvL2lmIHByb3BlcnRpZXMgYXJlIGFsbCBwcmVzZW50IGFuZCBhIHNjaGVtYSBpcyBwcm92aWRlZCwgd2UgY2FuIHBlcmZvcm0gYSBtb3JlIGRldGFpbGVkIGNoZWNrXG4gICAgaWYgKHR5cGVTY2hlbWEgIT09IG51bGwpIHtcbiAgICAgICAgLy91c2UgdGhlIHZhbGlkYXRvciBsaWJyYXJ5IG9uIHRoZSBvYmplY3RcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IHN3ZXZhLkFqdi52YWxpZGF0ZSh0eXBlU2NoZW1hLCBvYmopO1xuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihuZXcgRXhlY3V0aW9uRXJyb3IoJ09iamVjdCBkb2VzIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gJyArIHR5cGUgKyAnU2NoZW1hOiAnICsgc3dldmEuQWp2LmVycm9yc1RleHQoc3dldmEuQWp2LmVycm9ycyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgb2JqKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGlnbm9yZSwgYmVjYXVzZSBhbiBpbnZhbGlkIHNjaGVtYSBsaWtlIGdlbmVyYXRlZCBieSBBc3NlbWJseVNjcmlwdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc291cmNlIGFuZFxuICAgICAgICAgICAgYWxyZWFkeSBtYXRjaGVzIHRoZSBpbnB1dC9vdXRwdXQgZGF0YS4gQ29uc2lkZXIgYWRkaW5nIHRoZSBjdXN0b20gdHlwZXMgdG8gdGhlIHZhbGlkYXRvciwgaWYgdGhpcyBpcyBub3QgdGhlXG4gICAgICAgICAgICBjYXNlIGZvciBmdXR1cmUgYWRkZWQgbGFuZ3VhZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogRnVuY3Rpb24gdG8gc3RhcnQgdGhlIGRhdGEgcHJvY2Vzc2luZy4gSGVyZSBvbmx5IGEgZHVtbXkgaXMgZGVmaW5lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhhIGRhdGEgb2JqZWN0IHJlY2VpdmVkLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCByZWNlaXZlZC5cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gLSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG4gKi9cbkNvbXBvc2FibGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXNvbHZlKDApO1xuICAgIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NhYmxlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbXBvc2FibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMnKTtcbnZhciBNb2R1bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcycpO1xudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGhvdyBhIGNvbXBvc2FibGUgaXMgbGlua2VkIHRvIGFub3RoZXJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IGxpbmtUeXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gLSBUaGUgYWxpYXMvbmFtZSBvZiB0aGUgdGFyZ2V0IGNvbXBvc2FibGUgKGkuZS4gdW5kZXIgd2hpY2gga2V5IGl0IGlzIGRlZmluZWQgaW4gdGhlIGNvbXBvc2FibGVzIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2l0aW9uKVxuICogQHByb3BlcnR5IHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gbWFwcGluZyAtIEhvdyBkYXRhT3V0IGFuZCBkYXRhSW4gb2YgdHdvIGNvbXBvc2FibGVzIGFyZSBtYXBwZWQgdG8gZWFjaCBvdGhlci5cbiAqIElmIG5vIG1hcHBpbmcgaXMgc3BlY2lmaWVkLCB0aGUgd2hvbGUgZGF0YU91dCBvYmplY3QgaXMgdGFrZW4gYXMgdGhlIGRhdGFJbiBvYmplY3QuXG4gKiBJZiBhIHN0cmluZyBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSwgaXQgaXMgbWFwcGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBkYXRhSW4gcHJvcGVydHkuXG4gKiBJZiBhIGRpY3Rpb25hcnkgaXMgc3BlY2lmaWVkLCB0aGUga2V5IHJlcHJlc2VudHMgdGhlIGRhdGFPdXQgcHJvcGVydHkgYW5kIHRoZXZhbHVlIHRoZSBkYXRhSW4gcHJvcGVydHkgaXQgaXMgbWFwcGVkIHRvLlxuICogQWxsIHN0cmluZyB2YWx1ZXMgbXVzdCBiZSB1c2luZyB0aGUgZ2l2ZW4gdmFsdWVzIG9mIHRoZSBkYXRhSW5OYW1lcyBhbmQgZGF0YU91dE5hbWVzIGFycmF5cyBkZWZpbmVkIGluIHRoZSBjb21wb3NhYmxlLlxuICovXG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gbWFwIHRoZSBpbnB1dCBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uIHRvIHRoZSBpbnB1dCBvYmplY3Qgb2YgaW5kaXZpZHVhbCBjb21wb3NhYmxlcy5cbiAqIEJhc2ljYWxseSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoIGNvbXBvc2FibGUgYW5kIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlbiB1c2VkIGFzIGl0cyBpbnB1dCBvYmplY3QuXG4gKiBGb3IgZXhhbXBsZSB5b3UgY2FuIHVzZSBhbiBpbnB1dCBvYmplY3QsIHdoZXJlIHlvdSBzcGVjaWZ5IGluIGRldGFpbCBmb3IgZXZlcnkgY29tcG9zYWJsZSB0aGUgdmFsdWUsIHRoZW4geW91IGNvdWxkIHNpbXBseVxuICogcmV0dXJuIGlucHV0W2NvbXBvc2FibGVOYW1lXTtcbiAqIFxuICogQXR0ZW50aW9uISBUaGUgdXNlciBkZWZpbmFibGUgZnVuY3Rpb25zIHVzZSBhIGxpbWl0ZWQgc3Vic2V0IG9iIEphdmFTY3JpcHQuIFlvdSBjYW5ub3QgdXNlIGRhbmdlcmVvdXMgb3BlcmF0aW9ucywgbGlrZSBhY2Nlc3NpbmcgdGhpcywgZXZhbCwgZXRjLlxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXG4gKiBhY3RzIGFzIFtdLlxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogQGNhbGxiYWNrIENvbXBvc2l0aW9ufm1hcElucHV0RnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIGNvbXBvc2l0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvc2FibGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUgcmVxdWVzdGluZyBhbiBpbnB1dCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IGNvbXBvc2FibGVzIC0gQSBkaWN0aW9uYXJ5IG9mIHRoZSBjb21wb3NhYmxlcyB1c2VkIGJ5IHRoZSBjb21wb3NpdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWJzIC0gQSBsaWJyYXJ5IG9iamVjdCBwcm92aWRlcyBhY2Nlc3MgdG8gbGlicyBmcm9tIHdpdGhpbiB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RpbmcgY29tcG9zYWJsZSBhcyB0aGUgaW5wdXQgb2JqZWN0LlxuICovXG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gbWFwIHRoZSBkYXRhIG9iamVjdCBvZiB0aGUgY29tcG9zaXRpb24gdG8gdGhlIGRhdGEgb2JqZWN0IG9mIGluZGl2aWR1YWwgY29tcG9zYWJsZXMuXG4gKiBCYXNpY2FsbHkgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaCBjb21wb3NhYmxlIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZW4gdXNlZCBhcyBpdHMgZGF0YSBvYmplY3QuXG4gKiBGb3IgZXhhbXBsZSB5b3UgY2FuIHVzZSBhIGRhdGEgb2JqZWN0LCB3aGVyZSB5b3Ugc3BlY2lmeSBpbiBkZXRhaWwgZm9yIGV2ZXJ5IGNvbXBvc2FibGUgdGhlIHZhbHVlLCB0aGVuIHlvdSBjb3VsZCBzaW1wbHlcbiAqIHJldHVybiBkYXRhW2NvbXBvc2FibGVOYW1lXTtcbiAqIFxuICogQXR0ZW50aW9uISBUaGUgdXNlciBkZWZpbmFibGUgZnVuY3Rpb25zIHVzZSBhIGxpbWl0ZWQgc3Vic2V0IG9iIEphdmFTY3JpcHQuIFlvdSBjYW5ub3QgdXNlIGRhbmdlcmVvdXMgb3BlcmF0aW9ucywgbGlrZSBhY2Nlc3NpbmcgdGhpcywgZXZhbCwgZXRjLlxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXG4gKiBhY3RzIGFzIFtdLlxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogQGNhbGxiYWNrIENvbXBvc2l0aW9ufm1hcERhdGFJbkZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnaXZlbiB0byB0aGUgY29tcG9zaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZSByZXF1ZXN0aW5nIGEgZGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IGNvbXBvc2FibGVzIC0gQSBkaWN0aW9uYXJ5IG9mIHRoZSBjb21wb3NhYmxlcyB1c2VkIGJ5IHRoZSBjb21wb3NpdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWJzIC0gQSBsaWJyYXJ5IG9iamVjdCBwcm92aWRlcyBhY2Nlc3MgdG8gbGlicyBmcm9tIHdpdGhpbiB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHZhbHVlIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3RpbmcgY29tcG9zYWJsZSBhcyB0aGUgZGF0YSBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBkYXRhIG9iamVjdCBvZiB0aGUgZGF0YSBwcm9jZXNzaW5nIHBpcGVsaW5lLlxuICogWW91IGNvdWxkIGZvciBleGFtcGxlIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb3IgcmVtb3ZlIHNvbWUsIGNvbnZlcnQgdmFsdWVzIGV0Yy5cbiAqIFxuICogQXR0ZW50aW9uISBUaGUgdXNlciBkZWZpbmFibGUgZnVuY3Rpb25zIHVzZSBhIGxpbWl0ZWQgc3Vic2V0IG9iIEphdmFTY3JpcHQuIFlvdSBjYW5ub3QgdXNlIGRhbmdlcmVvdXMgb3BlcmF0aW9ucywgbGlrZSBhY2Nlc3NpbmcgdGhpcywgZXZhbCwgZXRjLlxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXG4gKiBhY3RzIGFzIFtdLlxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqIFxuICogQGNhbGxiYWNrIENvbXBvc2l0aW9ufm1hcERhdGFPdXRGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCAtIFRoZSBkYXRhIG9iamVjdCBwcm9kdWNlZCBieSB0aGUgY29tcG9zYWJsZXMgd2l0aG91dCBvdXRnb2luZyBsaW5rcyAoZW5kIG9mIGRhdGEgcHJvY2Vzc2luZykuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHZhbHVlIHRoZSBjb21wb3NpdGlvbiByZXR1cm5zIGFzIHRoZSBkYXRhcHJvY2Vzc2luZyByZXN1bHQuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBpbml0YWxpemF0aW9uIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBjb21wb3NhYmxlcy5cbiAqIEB0eXBlZGVmIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gY29tcG9zaXRpb25Jbml0YWxpemVyXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtjb21wb3NhYmxlcz17fV0gLSBBIGRpY3Rpb25hcnkgb2YgYWxsIGNvbXBvc2FibGVzIHVzZWQgYnkgdGhlIGNvbXBvc2l0aW9uLiBcbiAqIFRoZSBrZXkgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgYWxpYXMsIHRoZSB2YWx1ZSByZXByZXNlbnRzIFxuICogdGhlIGNvbXBvc2FibGUgbmFtZSwgd2hpY2ggaXMgdXNlZCB0byBsb2FkIHRoZSBjb21wb3NhYmxlIGluZm9ybWF0aW9uLlxuICogXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBBcnJheS48bGlua1R5cGU+Pn0gW2xpbmtzPXt9XSAtIEEgZGljdGlvbmFyeSBkZXNjcmliaW5nIGFuIGVkZ2UgbGlzdCBvZiBob3cgdGhlIGNvbXBvc2FibGVzIGFyZSBsaW5rZWQuXG4gKiBUaGUga2V5IGRlc2NyaWJlcyB0aGUgb3JpZ2luIGNvbXBvc2FibGUsIHRoZSB2YWx1ZSBkZXNjcmliZXMgYW4gYXJyYXkgb2YgdGFyZ2V0IGNvbXBvc2FibGVzIHdpdGggbWFwcGluZyBpbmZvcm1hdGlvbiBvZiB0aGUgZGF0YSBwcm9wZXJ0aWVzLlxuICogQHByb3BlcnR5IHtDb21wb3NpdGlvbn5tYXBJbnB1dEZ1bmN0aW9ufSBbbWFwSW5wdXRdIC0gQSBmdW5jdGlvbiB0byBtYXAgdGhlIGlucHV0IG9iamVjdCBvZiB0aGUgY29tcG9zaXRpb24gdG8gdGhlIGlucHV0IG9iamVjdCBvZiBpbmRpdmlkdWFsIGNvbXBvc2FibGVzLlxuICogVGhlIGRlZmF1bHQgcmVxdWlyZXMgYW4gaW5wdXQgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGEgY29tcG9zYWJsZSBhbGlhcy9uYW1lIGFuZCBtYXBzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gdGhpcyBjb21wb3NhYmxlIGlucHV0LlxuICogQHByb3BlcnR5IHtDb21wb3NpdGlvbn5tYXBEYXRhSW5GdW5jdGlvbn0gW21hcERhdGFJbl0gLSBBIGZ1bmN0aW9uIHRvIG1hcCB0aGUgZGF0YSBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uIHRvIHRoZSBkYXRhIG9iamVjdCBvZiBpbmRpdmlkdWFsIGNvbXBvc2FibGVzLlxuICogVGhlIGRlZmF1bHQgcmVxdWlyZXMgYSBkYXRhIG9iamVjdCwgd2hlcmUgZWFjaCBwcm9wZXJ0eSBjb3JyZXNwb25kcyB0byBhIGNvbXBvc2FibGUgYWxpYXMvbmFtZSBhbmQgbWFwcyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIHRoaXMgY29tcG9zYWJsZSBkYXRhLlxuICogQHByb3BlcnR5IHtDb21wb3NpdGlvbn5tYXBEYXRhT3V0RnVuY3Rpb259IFttYXBEYXRhT3V0XSAtIEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSByZXN1bHRpbmcgZGF0YSBvYmplY3Qgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgbWFraW5nIGl0IGF2YWlsYWJsZS5cbiAqIFRoZSBkZWZhdWx0IGRvZXMgbm90IGNoYW5nZSB0aGUgb3V0cHV0IG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIEEgY29tcG9zaXRpb24gY2FuIGNvbnNpc3Qgb2YgbXVsdGlwbGUgb3RoZXIgY29tcG9zaXRpb25zIG9yIGNvbXBvc2FibGVzLlxuICogSXQgb3JjaGlzdHJhdGVzIHRoZSBleGVjdXRpb24gb2YgdGhlIGNvbXBvc2FibGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb21wb3NhYmxlXG4gKiBAcGFyYW0ge2NvbXBvc2l0aW9uSW5pdGFsaXplcn0gaW5pdGlhbGl6YXRpb25PYmplY3QgLSBUaGUgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGNvbXBvc2l0aW9uLlxuICogXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCBtYW5hZ2VyKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnY29tcG9zYWJsZXMnLCB7fSk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdsaW5rcycsIHt9KTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnbWFwSW5wdXQnLCA0LCBmdW5jdGlvbiAoaW5wdXQsIGNvbXBvc2FibGVOYW1lLCBjb21wb3NhYmxlcywgbGlicykge1xuICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRbY29tcG9zYWJsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdtYXBEYXRhSW4nLCA0LCBmdW5jdGlvbiAoZGF0YSwgY29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGVzLCBsaWJzKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGNvbXBvc2FibGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbY29tcG9zYWJsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdtYXBEYXRhT3V0JywgMiwgZnVuY3Rpb24gKG91dHB1dCwgbGlicykge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICAgIC8vY2FsbCB0byB0aGUgcGFyZW50IGNsYXNzIGluaXRhbGl6YXRpb24gZnVuY3Rpb25cbiAgICB0aGlzLmluaXRpYWxpemUoaW5pdGlhbGl6YXRpb25PYmplY3QpO1xuXG4gICAgLyoqXG4gICAgKiBJbmRpY2F0ZXMsIGlmIHRoZSBjb21wb3NpdGlvbiBpcyByZWFkeSB0byB1c2UuIFRoaXMgaXMgaW1wb3J0YW50LCBhcyByZXF1aXJlZCBjb21wb3NhYmxlcyBtaWdodCBuZWVkIHRvIGJlIGxvYWRlZCBmaXJzdC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBuYW1lIENvbXBvc2l0aW9uI2lzUmVhZHlcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG59XG4vL2luaGVyaXQgcHJvcGVydGllc1xuQ29tcG9zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb3NhYmxlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzdGFydHMgdG8gcmVjdXJzaXZlbHkgbG9hZCBjb21wb3NhYmxlcyByZXF1aXJlZCBieSB0aGlzIGNvbXBvc2l0aW9uLlxuICogU2VlIHtAbGluayBDb21wb3NhYmxlTG9hZGVyfSBmb3IgbW9yZSBkZXRhaWxzIG9uIGhlIGxvYWRpbmcgcHJvY2Vzcy5cbiAqIFdoZW4gZmluaXNoZWQgYWxsIHJlcXVpcmVkIGNvbXBvc2FibGVzIGFyZSBpbiBtZW1vcnkgYW5kIGNhbiBiZSB1c2VkLlxuICogQXMgbG9hZGluZyBpcyBhc3luYyBpdCByZXR1cm5zIGEgcHJvbWlzZS4gXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQW4gZW1wdHkgcHJvbWlzZSwgc2lnbmFsaW5nIHRoYXQgZXZlcnl0aGluZyB3YXMgbG9hZGVkLlxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUubG9hZENvbXBvc2FibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvL2NvbGxlY3RzIGFuIGFycmF5IG9mIGxvYWRpbmcgcHJvbWlzZXMsIHdoaWNoIGlzIHRoZW4gZmlsbGVkXG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VsZi5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vZm9yIGVhY2ggcmVxdWlyZWQgY29tcG9zYWJsZSB0aGUgY29tcG9zYWJsZSBpcyBsb2FkZWQgdXNpbmcgdGhlIHNwZWNpZmllZCBuYW1lIG9mIGl0XG4gICAgICAgICAgICAgICAgLy90aGUgbmFtZSBpdHNlbGYgYWN0cyBhcyBhIHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICAvL2EgcmVmZXJlbmNlIHRvIHRoZSBjb21wb3NhYmxlcyBkaWN0aW9uYXJ5IG9mIHRoZSBjb21wb3NpdGlvbiBpcyBwYXNzZWQsIHNvIHRoZVxuICAgICAgICAgICAgICAgIC8vc3RyaW5nIHZhbHVlcyAobmFtZXMpIG9mIHRoZSByZXF1aXJlZCBjb21wb3NpdGlvbnMgYXJlIGxhdGVyIHJlcGxhY2VkIHdpdGggdGhlIGNvbW9zaXRpb24gb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAvL3doaWNoIGNhbiB0aGVuIGJlIHVzZWRcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29tcG9zYWJsZXNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChzd2V2YS5Db21wb3NhYmxlTG9hZGVyLmxvYWQoc2VsZi5jb21wb3NhYmxlc1trZXldLCBzZWxmLmNvbXBvc2FibGVzLCBrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vb3RoZXJ3aXNlIGNyZWF0ZSBmcm9tIGdpdmVuIG9iamVjdCBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHNlbGYuY29tcG9zYWJsZXNba2V5XS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlPT0nbW9kdWxlJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBvc2FibGVzW2tleV0gPSBuZXcgTW9kdWxlKHNlbGYuY29tcG9zYWJsZXNba2V5XSwgc2VsZi5tYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZXNba2V5XSA9IG5ldyBDb21wb3NpdGlvbihzZWxmLmNvbXBvc2FibGVzW2tleV0sIHNlbGYubWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vaW52b2tlIGFsbCBwcm9taXNlcyBhbmQgd2FpdCBmb3IgdGhlbSB0byBmaW5pc2hcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy93aGVuIGFsbCBwcm9taXNlcyBhcmUgZmluaXNoZWQsIGFsbCBjb21wb25lbnRzIGFyZSBsb2FkZWQsIHNvIHRoZSBjb21wb3NpdGlvbiBpcyByZWFkeSB0byBiZSB1c2VkXG4gICAgICAgICAgICBzZWxmLmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL2ltcG9ydGFudDogYXMgd2UgYXJlIGRlYWxpbmcgaGVyZSB3aXRoIGFzeW5jIG9wZXJhdGlvbnMsIG9uZSBtaWdodCB0cnkgdG8gZXhlY3V0ZSB0aGUgY29tcG9zaXRpb24sIGJlZm9yZVxuICAgICAgICAgICAgLy9pdCBpcyByZWFkeSB0byBiZSB1c2VkLiBJbiB0aGlzIGNhc2UgdGhlIGV4ZWN1dGlvbiBpcyBkZWxheWVkIGFuZCBpbmRpY2F0ZWQgKHdhbnRzVG9FeGVjdXRlPXRydWUpXG4gICAgICAgICAgICAvL25vdyBpZiB0aGUgbG9hZGluZyBpcyBmaW5pc2hlZCwgaXQgY2FuIGRpcmVjdGx5IHN0YXJ0IHRoZSBleGVjdXRpb24gZGlyZWN0bHkgaXRzZWxmLCB1c2luZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICAgICAgICAgIC8vbm8gcG9sbGluZyBuZWVkZWQgOilcbiAgICAgICAgICAgIGlmIChzZWxmLndhbnRzVG9FeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZVN0YXJ0ZXJDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgIFxuICAgICAgICAgICAgLy9vayBhbGwgbG9hZGVkLCBub3cgd2UgY2FuIGFuYWx5emUgZ3JhcGggYW5kIGNoZWNrIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBzZWxmLmFuYWx5emVMaW5rR3JhcGgoKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luZGljYXRlIHRvIHRoZSBvdXRzaWRlLCB0aGF0IHdlIGFyZSBkb25lIHdpdGggZXZlcnl0aGluZyBhbmQgdGhlIGNvbXBvc2l0aW9uIGNhbiBiZSB1c2VkXG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdDb3VsZCBub3QgbG9hZCBhbGwgY29tcG9zYWJsZXM6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0LCBzZWxmLmNvbXBvc2FibGVzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENoZWNrcywgaWYgYWxsIHRoZSBkYXRhIGEgY29tcG9zYWJsZSByZXF1aXJlcyBpcyBhbHJlYWR5IGF2YWlsYWJsZS5cbiAqIEFzIGNvbXBvc2FibGVzIGFyZSBleGVjdXRlZCBpbiBhIGdyYXBoLCBzb21lIGNvbXBvc2FibGVzIGRlcGVuZCBvbiB0aGUgY2FsY3VsYXRpb25zIG9mIG90aGVycyBhbmQgaGF2ZSB0byB3YWl0IGZvciB0aGUgZGF0YS5cbiAqIFxuICogRm9yIHRoaXMgcHVycG9zZSwgdGhlIHtAbGluayBDb21wb3NhYmxlI2RhdGFJbn0gcHJvcGVydHkgaXMgdXNlZCBhcyBhIGNvdW50LCB0aGF0IGhhcyB0byBiZSByZWFjaGVkXG4gKiBieSB0aGUgYW1vdW50IG9mIHByb3BlcnRpZXMgc3RvcmVkIGZvciB0aGlzIGNvbXBvc2FibGUgaW4ge0BsaW5rcyBDb21wb3NpdGlvbiNwYXJhbWV0ZXJzfS5cbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb3NhYmxlTmFtZSAtIFRoZSBhbGlhcyBvZiB0aGUgY29tcG9zYWJsZSBvYmplY3QsIGZvciB3aGljaCB0aGUgY2hlY2sgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlLCBpZiBhbGwgZGF0YSByZXF1aXJlZCBmb3IgdGhlIGNvbXBvc2FibGUgaXMgYXZhaWxhYmxlLlxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuaGFzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChjb21wb3NhYmxlTmFtZSkge1xuICAgIC8vaG93IG1hbnkgcGFyYW1ldGVycyBkb2VzIHRoZSBjb21wb3NhYmxlIG5lZWQ/XG4gICAgXG4gICAgdmFyIHBhcmFtZXRlcnNOZWVkZWQgPSBbXTtcbiAgICBpZih0eXBlb2YgdGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlTmFtZV0uZGF0YUluQ29ubmVjdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbWV0ZXJzTmVlZGVkID0gT2JqZWN0LmtleXModGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlTmFtZV0uZGF0YUluQ29ubmVjdGVkKTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy9pZiBpdCBkb2VzIG5vdCBuZWVkIGFueSwgd2UgYXJlIGdvb2QgaGVyZVxuICAgIGlmIChwYXJhbWV0ZXJzTmVlZGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy9pZiB3ZSBhcmUgc3RpbGwgaGVyZSwgaXQgbmVlZHMgYXQgbGVhc3Qgb25lXG4gICAgaWYgKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlTmFtZSkpIHtcbiAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vbm90IGVub3VnaFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnNOZWVkZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzTmVlZGVkW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlTmFtZV1bcGFyYW1ldGVyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQWRkcyBuZXcgZGF0YSB0byB0aGUgYXZhaWxhYmxlIHBvb2wgb3RoZXIgY29tcG9zYWJsZXMgdXNlLlxuICogVGhpcyBhbGxvd3MgZGVwZW5kYW50IGNvbXBvc2FibGVzIHRvIGZldGNoIHRoZSBkYXRhIGFuZCBzdGFydCBleGVjdXRpb24uXG4gKiBJdCBzYXZlcyB0aGUgZGF0YSBhcyBhIHN1YmtleSBvZiBhIHN1YmtleSBvZiB7QGxpbmtzIENvbXBvc2l0aW9uI3BhcmFtZXRlcnN9OlxuICogdGhpcy5wYXJhbWV0ZXJzW2NvbXBvc2FibGVdW3Byb3BlcnR5XSA9IHZhbHVlXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgYWxpYXMgb2YgdGhlIGNvbXBvc2FibGUgb2JqZWN0IGZvciB3aGljaCB0aGUgZGF0YSBpcyBpbnRlbmRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSBuYW1lIHRvIHNhdmUgdGhlIGRhdGEgYXMsIHRoZSB2YWx1ZSBtdXN0IGNvcnJlc3BvbmQgdG8gYSB2YWx1ZSBkZWZpbmVkXG4gKiBpbiB7QGxpbmtzIENvbXBvc2FibGUjZGF0YUluTmFtZXN9ICh3ZSBuZWVkIGNvcnJlY3QgbWFwcGluZykuXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufHN0cmluZ3xudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBkYXRhIHRvIGFkZC5cbiAqL1xuQ29tcG9zaXRpb24ucHJvdG90eXBlLmFkZFBhcmFtZXRlciA9IGZ1bmN0aW9uIChjb21wb3NhYmxlTmFtZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgLy9pZiBubyBrZXkgZm9yIGNvbXBvc2FibGUgcHJlc2VudCwgY3JlYXRlIG9uZVxuICAgIGlmICghdGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGNvbXBvc2FibGVOYW1lKSkge1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnNbY29tcG9zYWJsZU5hbWVdID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIGNvbXBvc2l0aW9uLCBzbyBpdCBjYW4gYmUgZXhlY3V0ZWQgYWdhaW4uXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7fTsgICAgXG4gICAgdGhpcy5vdXRwdXQgPSB7fTtcbiAgICB0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcG9zYWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21wb3NhYmxlOiBrZXksXG4gICAgICAgICAgICAgICAgY2xlYXJlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxufVxuXG4vKipcbiAqIENoZWNrcywgaWYgdGhlIGNvbXBvc2FibGUgZ3JhcGggb2YgdGhlIGNvbXBvc2l0aW9uIGNvbnRhaW5zIGN5Y2xlcyAoZW5kIHRoZXJlZm9yZSBpcyBub3QgYSBEQUcpLlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc3RhcnRpbmdOb2RlQXJyYXkgLSBBbiBhcnJheSB3aXRoIHRoZSBhbGlhc2VzIG9mIGFsbCBjb21wb3NhYmxlcywgdGhhdCBkbyBub3QgaGF2ZSBhbiBpbmNvbWluZyBlZGdlL2xpbmsuXG4gKiBUaGV5IGFyZSBjb25zaWRlcmVkIGFzIHRoZSBmaXJzdCBub2RlcywgdGhhdCBnZXQgZXhlY3V0ZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGdyYXBoIGNvbnRhaW5zIGN5Y2xlcy5cbiAqL1xuQ29tcG9zaXRpb24ucHJvdG90eXBlLmhhc0N5Y2xlcyA9IGZ1bmN0aW9uIChzdGFydGluZ05vZGVBcnJheSkge1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHZhciBlZGdlcyA9IHt9O1xuXG4gICAgLy9maXJzdCBjcmVhdGUgYSBjb3B5IG9mIHRoZSBjb21wb3NhYmxlcyBpbiB0aGUgY29tcG9zaXRpb24gKG5vZGVzKVxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbXBvc2FibGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIG5vZGVzW2tleV0gPSB7fVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vY3JlYXRlIGEgY29weSBvZiB0aGUgbGlua3Mgd2l0aG91dCBtYXBwaW5nIGluZm9ybWF0aW9uIChlZGdlcylcbiAgICBmb3IgKHZhciBmcm9tTm9kZSBpbiB0aGlzLmxpbmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGZyb21Ob2RlKSkge1xuICAgICAgICAgICAgZWRnZXNbZnJvbU5vZGVdID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGZyb21FbmRwb2ludCBpbiB0aGlzLmxpbmtzW2Zyb21Ob2RlXSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmtzW2Zyb21Ob2RlXS5oYXNPd25Qcm9wZXJ0eShmcm9tRW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0b05vZGUgaW4gdGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua3NbZnJvbU5vZGVdW2Zyb21FbmRwb2ludF0uaGFzT3duUHJvcGVydHkodG9Ob2RlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbZnJvbU5vZGVdLnB1c2godG9Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKmZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5rc1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWRnZXNba2V5XS5wdXNoKHRoaXMubGlua3Nba2V5XVtpXS50byk7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIC8vS2FobidzIGFsZ29yaXRobVxuICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZ1xuICAgIHZhciBMID0gW107XG4gICAgdmFyIFMgPSBzdGFydGluZ05vZGVBcnJheS5zbGljZSgpO1xuICAgIHZhciB1bmlxdWVMID0gdHJ1ZTtcbiAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuID0gUy5wb3AoKTtcblxuICAgICAgICAvL3NvcnRpbmcgb25seSB3b3JrcywgaWYgYWxsIGVsZW1lbnRzIGFyZSB1bmlxdWUhXG4gICAgICAgIGlmIChMLmluZGV4T2YobikgPj0gMCkge1xuICAgICAgICAgICAgdW5pcXVlTCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgTC5wdXNoKG4pO1xuICAgICAgICBpZiAoZWRnZXMuaGFzT3duUHJvcGVydHkobikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXNbbl0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGVkZ2VzW25dW2ldO1xuICAgICAgICAgICAgICAgIGVkZ2VzW25dLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgICAgIGktLTtcblxuICAgICAgICAgICAgICAgIHZhciBoYXNJbmNvbWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlc1trZXldLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2tleV1ba10gPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzSW5jb21pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0luY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0luY29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFMucHVzaChtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW25dLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWRnZXNbbl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vaWYgZWRnZXMgZXhpc3QsIG9yIEwgaGFzIG5vbiB1bmlxdWUgZWxlbWVudHM6IHRoZXJlIGlzIGEgY3ljbGVcbiAgICBpZiAoT2JqZWN0LmtleXMoZWRnZXMpLmxlbmd0aCA+IDAgfHwgIXVuaXF1ZUwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ2hlY2tzLCBpZiB0aGUgc2NoZW1hcyBvZiB0d28gb2JqZWN0cyBhcmUgY29tcGF0aWJsZS5cbiAqIFR3byBvYmplY3RzIGFyZSBjb21wYXRpYmxlLCBpZiBvbmUgb2YgdGhlbSBoYXMgbm8gc2NoZW1hIGRlZmluaXRpb24sIG9yIGlmIHRoZSBmaXJzdCBzY2hlbWEgaXMgaWRlbnRpY2FsIHRvIHRoZSBzZWNvbmQgb25lIGluIGEgcmVjdXJzaXZlIGNvbXBhcmlzb24uXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqMU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlyc3Qgb2JqZWN0IChmcm9tKS4gT25seSB1c2VkIGZvciBlcnJvciBvdXRwdXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqMk5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc2Vjb25kIG9iamVjdCAodG8pLiBPbmx5IHVzZWQgZm9yIGVycm9yIG91dHB1dC5cbiAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gb2JqMVNjaGVtYSAtIFRoZSBzY2hlbWEgb2Z0aGUgZmlyc3Qgb2JqZWN0LlxuICogQHBhcmFtIHtKU09OU2NoZW1hfSBvYmoyU2NoZW1hIC0gVGhlIHNjaGVtYSBvZnRoZSBzZWNvbmQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFttYXBwaW5nRnJvbV0gLSBUaGUgcmVsZXZhbnQgcHJvcGVydHkgbmFtZSBvZiB0aGUgZmlyc3Qgb2JqZWN0IChzb3VyY2UvZnJvbSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hcHBpbmdUb10gLSBUaGUgcmVsZXZhbnQgcHJvcGVydHkgbmFtZSBvZiB0aGUgc2Vjb25kIG9iamVjdCAodGFyZ2V0L3RvKS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlLCBpZiB0aGUgb2JqZWN0IHdpdGggb2JqMVNjaGVtYSBjYW4gYmUgdXNlZCwgd2hlcmUgb2JqMlNjaGVtYSBpcyByZXF1aXJlZC4gXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5jaGVja1NjaGVtYUNvbXBhdGliaWxpdHkgPSBmdW5jdGlvbiAob2JqMU5hbWUsIG9iajJOYW1lLCBvYmoxU2NoZW1hLCBvYmoyU2NoZW1hLCBtYXBwaW5nRnJvbSwgbWFwcGluZ1RvKSB7XG4gICAgLy9zY2hlbWFzIGFyZSBvcHRpb25hbCAobnVsbCksIHNvIGdpdmUgdGhlIGJlbmVmaXQgb2YgdGhlIGRvdWJ0XG4gICAgaWYgKG9iajFTY2hlbWEgPT0gbnVsbCB8fCBvYmoyU2NoZW1hID09IG51bGwpIHsgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvL3VzZSB0byBzdG9yZSBlcnJvciBtZXNzYWdlc1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICAvL2Z1bmN0aW9uIGZvciByZWN1cnNpb24sIGRlYWxzIHdpdGggdGhlIG1ldGEgaW5mb3JtYXRpb24gbGV2ZWwgKHR5cGUsIHByb3BlcnRpZXMsIHJlcXVpcmVkLCBldGMpIG9mIHRoZSBKU09OU2NoZW1hXG4gICAgLy9sZXZlbCBpbmRpY2F0ZXMgdGhlIHBvcGVydHkgY2hhaW4gYW5kIGlzIHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgZnVuY3Rpb24gbWV0YUxldmVsKGxldmVsLCBmcm9tLCB0bykge1xuICAgICAgICAvL2l0ZXJhdGUgb3ZlciB0aGUgdGFyZ2V0IGtleXMgKG9iajJTY2hlbWEpXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0bykge1xuICAgICAgICAgICAgLy90aGUgc291cmNlIChvYmoxU2NoZW1hKSBtdXN0IGhhdmUgYWxsIGtleXMgdGhlIHRhcmdldCBoYXNcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdpdGVtcycgJiYga2V5ICE9PSAncmVxdWlyZWQnICYmICFmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyBwcm9wZXJ0eSBcIicgKyBrZXkgKyAnXCInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhbiBhcnJheSwgcHJvY2VlZCB0byB0aGUgbWV0YS1sZXZlbFxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2l0ZW1zJyAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGFMZXZlbChsZXZlbCArICcuJyArIGtleSwgZnJvbVtrZXldLCB0b1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkLCBwcm9jZWVkIHdpdGggdGhlIHJlY3Vyc2lvbiB1c2luZyB0aGUgcHJvcGVydHlMZXZlbFxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAncHJvcGVydGllcycgJiYgZnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eUxldmVsKGxldmVsICsgJy4nICsga2V5LCBmcm9tW2tleV0sIHRvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHdlIGdldCB0byB0aGUgcmVxdWlyZWQgYXJyYXkuLi5cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3JlcXVpcmVkJyAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvL3NwZWNpYWw6IHJlcXVpcmVkIGFycmF5IG9yZGVyIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgZnJvbVtrZXldLnNvcnQoKTtcbiAgICAgICAgICAgICAgICB0b1trZXldLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgIC8vZmlyc3QgY2hlY2sgaWYgdGhlIGxlbmd0aCBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIGlmIChmcm9tW2tleV0ubGVuZ3RoICE9PSB0b1trZXldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhcnJheSBsZW5ndGggZGlmZmVyZW50IGZvciBcIicgKyBrZXkgKyAnXCIgJyArIGZyb21ba2V5XS50b1N0cmluZygpICsgJyAhPSAnICsgdG9ba2V5XS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL290aGVyd2lzZSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcm9tW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21ba2V5XVtpXSAhPT0gdG9ba2V5XVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdhcnJheSBlbGVtZW50IGRpZmZlcmVuY2UgZm9yIFwiJyArIGtleSArICdcIiAoICcgKyBmcm9tW2tleV1baV0gKyAnICE9ICcgKyB0b1trZXldW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyApICcgKyBmcm9tW2tleV0udG9TdHJpbmcoKSArICcgIT0gJyArIHRvW2tleV0udG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHdlIGdldCBzb21ldGhpbmcgZWxzZSwgd2UgY29tcGFyZSB0aGUgdmFsdWVzXG4gICAgICAgICAgICAvL3RoaXMgc2hvdWxkIGJlIGFsbCBwcmltaXRpdmUgdHlwZXMsIGJ1dCBJJ20gbm90IHN1cmUgaWYgSSBkaWRuJ3QgbWlzcyBhbnkgcG9zc2libGUgbm9uLXByaW1pdGl2ZVxuICAgICAgICAgICAgLy9pbiB0aGUgYWJvdmUgaWYtZWxzZVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbVtrZXldICE9PSB0b1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luZXF1YWwgcHJvcGVydHkgdmFsdWUgXCInICsga2V5ICsgJ1wiICggJyArIGZyb21ba2V5XSArICcgIT0gJyArIHRvW2tleV0gKyAnICknXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvL2Z1bmN0aW9uIGZvciByZWN1cnNpb24sIGRlYWxpbmcgd2l0aCB0aGUgZW51bWVyYXRpb24gb2YgcHJvcGVydHkga2V5cyBvZiBhIHNjaGVtYVxuICAgIGZ1bmN0aW9uIHByb3BlcnR5TGV2ZWwobGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0bykge1xuICAgICAgICAgICAgLy9mcm9tIG11c3QgaGF2ZSBhdCBsZWFzdCBhbGwga2V5cyB0byBoYXNcbiAgICAgICAgICAgIGlmICghZnJvbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcHJvcGVydHkgXCInICsga2V5ICsgJ1wiJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnRpbnVlLCBieSBjaGVja2luZyB0aGUgbWV0YS1sZXZlbCBvZiBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIW1ldGFMZXZlbChsZXZlbCArICcuJyArIGtleSwgZnJvbVtrZXldLCB0b1trZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAvL2hlbHBlciBmdW5jdGlvbiwgdGhhdCBoZWxwcyB0byBuYXJyb3cgdGhlIHNjb3BlLCBpZiBhIG1hcHBpbmdUby9tYXBwaW5nRnJvbSBpcyBnaXZlblxuICAgIC8vaXQgYmFzaWNhbGx5IHRyYXZlcnNlcyB0aGUgc2NoZW1hIHRvIHRoZSBkZXNpcmVkIG1hcHBpbmcgcHJvcGVydHkgYW5kIHJldHVybnMgaXQgYXMgdGhlIG5ldyBzY2hlbWFcbiAgICBmdW5jdGlvbiBzY29wZU9uTWFwcGluZyhzY2hlbWEsIG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIGhhc1NjaGVtYSA9IHRydWU7XG5cbiAgICAgICAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgncHJvcGVydGllcycpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1hLnByb3BlcnRpZXNbbWFwcGluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgLy9jb3B5IHRoZSBvcmlnaW5hbCBzY2hlbWFzIGZvciBlcnJvciBvdXRwdXQgKHdlIG1pZ2h0IG1vZGlmeSBvdXIgcmVmZXJlbmNlIGxhdGVyIHRvIG5hcnJvdyB0aGUgc2NvcGUsIGJ1dCBcbiAgICAvL3dlIHN0aWxsIHdhbnQgdG8gc2hvdyB0aGUgZnVsbCBzY2hlbWEgZm9yIHRoZSBlcnJvciBtZXNzYWdlXG4gICAgdmFyIE9yaWdpbmFsT2JqMVNjaGVtYSA9IG9iajFTY2hlbWE7IFxuICAgIHZhciBPcmlnaW5hbE9iajJTY2hlbWEgPSBvYmoyU2NoZW1hO1xuXG4gICAgLy9tYXBwaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHNjaGVjayBpZiB0aGV5IGFyZSBkZWZpbmVkIGFuZCBuYXJyb3cgdGhlIHNjb3Blc1xuICAgIGlmICh0eXBlb2YgbWFwcGluZ1RvID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdGVtcCA9IHNjb3BlT25NYXBwaW5nKG9iajJTY2hlbWEsIG1hcHBpbmdUbyk7XG4gICAgICAgIGlmICh0ZW1wKSB7XG4gICAgICAgICAgICBvYmoyU2NoZW1hID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIGxldmVsOiAnJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29tcG9zYWJsZSBcIicgKyBvYmoyTmFtZSArICdcIiBoYXMgbm8gc2NoZW1hIGZvciBwcm9wZXJ0eSBcIicgKyBtYXBwaW5nVG8gKyAnXCIgcHJvdmlkZWQgYnkgY29tcG9zYWJsZSBcIicgKyBvYmoxTmFtZSArICdcIidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWFwcGluZ0Zyb20gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc2NvcGVPbk1hcHBpbmcob2JqMVNjaGVtYSwgbWFwcGluZ0Zyb20pO1xuICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgb2JqMVNjaGVtYSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBsZXZlbDogJycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NvbXBvc2FibGUgXCInICsgb2JqMU5hbWUgKyAnXCIgaGFzIG5vIHNjaGVtYSBmb3IgcHJvcGVydHkgXCInICsgbWFwcGluZ0Zyb20gKyAnXCIgcmVxdWlyZWQgYnkgY29tcG9zYWJsZSBcIicgKyBvYmoyTmFtZSArICdcIidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vaWYgd2UgZGlkbid0IGhhdmUgYW4gZXJyb3IgeWV0LCB3ZSBjYW4gc3RhcnQgdGhlIHJlY3Vyc2lvblxuICAgIFxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0ID0gbWV0YUxldmVsKCcnLCBvYmoxU2NoZW1hLCBvYmoyU2NoZW1hKTtcbiAgICB9XG5cbiAgICAvL291dHB1dCBhbiBlcnJvciBtZXNzYWdlXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHZhciByZWxldmFudE1hcHBpbmcgPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nRnJvbSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG1hcHBpbmdUbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlbGV2YW50TWFwcGluZyA9ICcgZm9yIHRoZSBtYXBwaW5nIFwiJyArIG1hcHBpbmdGcm9tICsgJ1wiIC0+IFwiJyArIG1hcHBpbmdUbyArICdcIic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcHBpbmdUbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlbGV2YW50TWFwcGluZyA9ICcgZm9yIHRoZSBtYXBwaW5nIFwiJyArIG1hcHBpbmdUbyArICdcIic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmF1bHR5T2JqZWN0ID0ge307XG4gICAgICAgIGZhdWx0eU9iamVjdFtvYmoxTmFtZV0gPSBPcmlnaW5hbE9iajFTY2hlbWE7XG4gICAgICAgIGZhdWx0eU9iamVjdFtvYmoyTmFtZV0gPSBPcmlnaW5hbE9iajJTY2hlbWE7XG4gICAgICAgIFxuXG4gICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdTY2hlbWFzIG9mIFwiJyArIG9iajFOYW1lICsgJ1wiIGFuZCBcIicgKyBvYmoyTmFtZSArICdcIiBpbmNvbXBhdGlibGUnICsgcmVsZXZhbnRNYXBwaW5nICsgJzogJ1xuICAgICAgICAgICAgKyBlcnJvci5sZXZlbCArICc6ICcgKyBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgZmF1bHR5T2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFN0YXRpY2FsbHkgYW5hbHl6ZXMgdGhlIGdyYXBoIGJlZm9yZSBleGVjdXRpb24uXG4gKiBDaGVja3MgZm9yIGNvbXBhdGFiaWxpdHkgb2YgY29tcG9zYWJsZXMsIGFic2VuY2Ugb2YgY3ljbGVzIGluIHRoZSBsaW5rYWdlIGRlZmluaXRpb24gZXRjLlxuICogQHByb3RlY3RlZFxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuYW5hbHl6ZUxpbmtHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBGYWxzZSwgaWYgbm8gZXJyb3JzIGluIHRoZSBsaW5rIGdyYXBoIGRlZmluaXRpb24gd2VyZSBkZXRlY3RlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5hbWUgQ29tcG9zaXRpb24jaW52YWxpZExpbmtHcmFwaFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGFsbCB0aGUgYWxpYXNlcyBvZiB0aGUgY29tcG9zYWJsZXMsIHRoYXQgaGF2ZSBubyBpbmdvaW5nIGxpbmssIGkuZS4gdGhlICdzdGFydCdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG5hbWUgQ29tcG9zaXRpb24jc3RhcnRpbmdDb21wb3NhYmxlc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzKTtcbiAgICAvKipcbiAgICAqIERpY3Rpb25hcnkgb2YgYWxsIHRoZSBhbGlhc2VzIG9mIHRoZSBjb21wb3NhYmxlcywgdGhhdCBoYXZlIG5vIG91dGdvaW5nIGxpbmssIGkuZS4gdGhlICdlbmQnXG4gICAgKiBEaWN0aW9uYXJ5LCBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgc29tZSBsb29rdXBzIG9mIHRoZSBrZXkgdmFsdWVzIGxhdGVyIG9uLlxuICAgICogQHByb3RlY3RlZFxuICAgICogQG5hbWUgQ29tcG9zaXRpb24jc3RhcnRpbmdDb21wb3NhYmxlc1xuICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZz59XG4gICAgKi9cbiAgICB0aGlzLmVuZGluZ0NvbXBvc2FibGVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcG9zYWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5lbmRpbmdDb21wb3NhYmxlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vZmluZCBzdGFydGluZ0NvbXBvc2FibGVzIHRoYXQgaGF2ZSBubyBpbmdvaW5nIGVkZ2VzXG4gICAgLy9maW5kIGVuZGluZ0NvbXBvc2FibGVzIHRoYXQgaGF2ZSBubyBvdXRnb2luZyBlZGdlc1xuICAgXG5cbiAgICBmb3IgKHZhciBmcm9tTm9kZSBpbiB0aGlzLmxpbmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGZyb21Ob2RlKSkge1xuICAgICAgICAgICBcblxuICAgICAgICAgICAgZm9yICh2YXIgZnJvbUVuZHBvaW50IGluIHRoaXMubGlua3NbZnJvbU5vZGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua3NbZnJvbU5vZGVdLmhhc093blByb3BlcnR5KGZyb21FbmRwb2ludCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0b05vZGUgaW4gdGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua3NbZnJvbU5vZGVdW2Zyb21FbmRwb2ludF0uaGFzT3duUHJvcGVydHkodG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b0VuZHBvaW50ID0gdGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XVt0b05vZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbGlua2luZyB0byBleGlzdGluZyBjb21wb3NhYmxlIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eSh0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdDb21wb3NhYmxlIFwiJyArIGZyb21Ob2RlICsgJ1wiIGxpbmtzIHRvIHVuZGVmaW5lZCBjb21wb3NhYmxlIFwiJyArIHRvTm9kZSArICdcIiEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgT2JqZWN0LmtleXModGhpcy5jb21wb3NhYmxlcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkTGlua0dyYXBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXBvc2FibGUgaGFzIG5vIHN1Y2ggZGF0YU91dCwgaXQgdHJpZXMgdG8gbWFwIHRvIGFub3RoZXIgY29tcG9zYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1tmcm9tTm9kZV0uZGF0YU91dE5hbWVzLmluZGV4T2YoZnJvbUVuZHBvaW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignQ29tcG9zYWJsZSBcIicgKyBmcm9tTm9kZSArICdcIiBtYXBzIHVuZGVmaW5lZCBkYXRhT3V0IFwiJyArIGZyb21FbmRwb2ludCArICdcIiB0byBjb21wb3NhYmxlIFwiJyArIHRvTm9kZSArICdcIiEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQsIHRoaXMuY29tcG9zYWJsZXNbZnJvbU5vZGVdLmRhdGFPdXROYW1lcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkTGlua0dyYXBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21wb3NhYmxlIGhhcyBubyBzdWNoIGRhdGFJblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbk5hbWVzLmluZGV4T2YodG9FbmRwb2ludCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvbXBvc2FibGUgXCInICsgZnJvbU5vZGUgKyAnXCIgbGlua3MgdG8gdW5kZWZpbmVkIGRhdGFJbiBcIicgKyB0b0VuZHBvaW50ICsgJ1wiIG9mIGNvbXBvc2FibGUgXCInICsgdG9Ob2RlICsgJ1wiIScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbk5hbWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRMaW5rR3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsbHkgY2hlY2sgZm9yIHNjaGVtYSBjb21wYXRpYmlsaXR5IChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXNbZnJvbU5vZGVdLmRhdGFPdXRTY2hlbWEgJiYgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJblNjaGVtYSAhPSBudWxsKSB7Ly9zY2hlbWFzIGFyZSBvcHRpb25hbCwgc28gb25seSBjaGVjayBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXRpYmxlU2NoZW1hcyA9IHRoaXMuY2hlY2tTY2hlbWFDb21wYXRpYmlsaXR5KGZyb21Ob2RlLCB0b05vZGUsIHRoaXMuY29tcG9zYWJsZXNbZnJvbU5vZGVdLmRhdGFPdXRTY2hlbWEsIHRoaXMuY29tcG9zYWJsZXNbdG9Ob2RlXS5kYXRhSW5TY2hlbWEsZnJvbUVuZHBvaW50LCB0b0VuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29tcGF0aWJsZVNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRMaW5rR3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbkNvbm5lY3RlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zYWJsZXNbdG9Ob2RlXS5kYXRhSW5Db25uZWN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluQ29ubmVjdGVkW3RvRW5kcG9pbnRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG9uZSBjb21wb3NhYmxlIEEgcG9pbnRzIHRvIGNvbXBvc2FibGUgQiwgdGhlbiBCIGNhbm5vdCBiZSBzdGFydGluZ0NvbXBvc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcEluZGV4ID0gdGhpcy5zdGFydGluZ0NvbXBvc2FibGVzLmluZGV4T2YodG9Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydGluZ0NvbXBvc2FibGVzLnNwbGljZShwcm9wSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG9uZSBjb21wb3NhYmxlIEEgcG9pbnRzIHRvIGNvbXBvc2FibGUgQiwgdGhlbiBBIGNhbm5vdCBiZSBlbmRpbmdDb21wb3NhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kaW5nQ29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoZnJvbU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVuZGluZ0NvbXBvc2FibGVzW2Zyb21Ob2RlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIFxuXG4gICAgLy9jaGVjayBmb3IgY3ljbGVzXG4gICAgdmFyIGhhc0N5Y2xlcyA9IHRoaXMuaGFzQ3ljbGVzKHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcyk7XG4gICAgaWYgKGhhc0N5Y2xlcykge1xuICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ1RoZXJlIGFyZSBjeWNsZXMgaW4gdGhlIGxpbmthZ2Ugb2YgY29tcG9zYWJsZXMhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCB0aGlzLmxpbmtzKSk7XG4gICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy9leHRyYWN0IGltcGxpY2l0IGluZm9ybWF0aW9uXG4gICAgdGhpcy5kYXRhSW4gPSB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMubGVuZ3RoO1xuICAgIHRoaXMuZGF0YU91dCA9IE9iamVjdC5rZXlzKHRoaXMuZW5kaW5nQ29tcG9zYWJsZXMpLmxlbmd0aDtcblxuICAgIHRoaXMuZGF0YUluTmFtZXMgPSBbXTtcbiAgICB0aGlzLmRhdGFPdXROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXNbdGhpcy5zdGFydGluZ0NvbXBvc2FibGVzW2ldXS5kYXRhSW5OYW1lcy5sZW5ndGg+MCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhSW5OYW1lcy5wdXNoKHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlc1tpXSk7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5lbmRpbmdDb21wb3NhYmxlcykge1xuICAgICAgICBpZiAodGhpcy5lbmRpbmdDb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFPdXROYW1lcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG59XG4vKipcbiAqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCBjb21wb3NhYmxlcywgYXMgc29vbiBhcyB0aGV5IGNhbiBiZSBleGVjdXRlZCAoaGF2ZSBhbGwgcmVxdWlyZWQgZGF0YSBhdmFpbGFibGUpXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBleGVjdXRpb24gY29udGV4dCwgc2VlIHtAbGluayBDb21wb3NhYmxlI2NvbnRleHR9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24gPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIFxuICAgIC8va2VlcCBhbiBhcnJheSBvZiBhbGwgY29tcG9zYWJsZXNcbiAgICAvL2V4ZWN1dGVkIGNvbXBvc2FibGVzIGdldCBtYXJrZWRcbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKFwiQ1FFIDogY29udGV4dCA9XCIpO1xuICAgIGNvbnNvbGUubG9nKGNvbnRleHQpO1xuICAgIGNvbnNvbGUubG9nKFwiQ1FFIDogdGhpcyA9XCIpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgIGNvbnNvbGUubG9nKFwiQ1FFIDogdW5jbGVhcmVkQ29tcG9zYWJsZXMgPVwiKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzKTtcbiAgICAqL1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgLy9za2lwIGFscmVhZHkgZXhlY3V0ZWQgY29tcG9zYWJsZXNcbiAgICAgICAgaWYgKHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY2xlYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBjb21wb3NhYmxlTmFtZSA9IHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY29tcG9zYWJsZTtcblxuICAgICAgICBcbiAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuICAgICAgICB2YXIgaW5wdXQgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgLy9jaGVjayBpZiBjb21wb3NhYmxlIGhhcyBhbGwgZGF0YSBpdCBkZXBlbmRzIG9uIGF2YWlsYWJsZVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuaGFzUGFyYW1ldGVycyhjb21wb3NhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9maWxsIGRhdGEgYW5kIGlucHV0IGZvciBuZXh0IGNvbXBvc2FibGUgY2FsbFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlTmFtZV07XG4gICAgICAgICAgIFxuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLm1hcElucHV0KHRoaXMuaW5wdXQsIGNvbXBvc2FibGVOYW1lLCB0aGlzLmNvbXBvc2FibGVzLCBzd2V2YS5saWJzKTtcbiAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ub3QgY29udGludWVkID0gY29tcG9zYWJsZU5hbWUgY2FuIGJlIGV4ZWN1dGVkIChoYXMgZGF0YSB2YWlsYWJsZSlcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvL2Nsb3N1cmUgZnVuY3Rpb24sIHRvIGdldCB0aGUgY3VycmVudCBjb21wb3NhYmxlIGZvciBlYWNoIGZ1bmN0aW9uXG4gICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKGNvbXBvc2FibGVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgY29tcG9zYWJsZSBkb2VzIG5vdCBwcm92aWRlIGRhdGEgdG8gb3RoZXIgY29tcG9zYWJsZXMgKGVuZCBvZiBleGVjdXRpb24gY2hhaW4pXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZW5kaW5nQ29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgaGF2ZSBvbmx5IG9uZSBvdXRwdXQgY29tcG9zYWJsZSwgd2UgZG8gbm90IG5lZWQgYSBuYW1lZCBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgY3JlYXRlIGEgcHJvcGVydHkgdXNpbmcgdGhlIGVuZGluZy1jb21wb3NhYmxlIGFsaWFzXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzZWxmLmVuZGluZ0NvbXBvc2FibGVzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm91dHB1dFtjb21wb3NhYmxlTmFtZV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhpcyB3YXMgdGhlIGxhc3QgY29tcG9zYWJsZSAoYWxsIGhhdmUgYmVlbiBleGVjdXRlZClcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZWxmLnVubGNlYXJlZENvbXBvc2FibGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYudW5sY2VhcmVkQ29tcG9zYWJsZXNba10uY2xlYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbENsZWFyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoaXMgd2FzIHRoZSBsYXN0IGVuZGluZ0NvbXBvc2FibGUsIGZpbmlzaFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsQ2xlYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlRmluaXNoZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9pZiBjb21wb3NhYmxlIHByb3ZpZGVzIGRhdGEgdG8gb3RoZXIgY29tcG9zYWJsZXMgXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmcm9tRW5kcG9pbnQgaW4gc2VsZi5saW5rc1tjb21wb3NhYmxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5saW5rc1tjb21wb3NhYmxlTmFtZV0uaGFzT3duUHJvcGVydHkoZnJvbUVuZHBvaW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvTm9kZSBpbiBzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXVtmcm9tRW5kcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5saW5rc1tjb21wb3NhYmxlTmFtZV1bZnJvbUVuZHBvaW50XS5oYXNPd25Qcm9wZXJ0eSh0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvRW5kcG9pbnQgPSBzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXVtmcm9tRW5kcG9pbnRdW3RvTm9kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkUGFyYW1ldGVyKHRvTm9kZSwgdG9FbmRwb2ludCwgb3V0cHV0W2Zyb21FbmRwb2ludF0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vcmVjdXJzaXZlIGV4ZWN1dGlvbiBvZiB0aGUgbmV4dCBjb21wb3NhYmxlcywgYXMgdGhpcyBvbmUganVzdCBmaW5pc2hlZCBhbmQgcHJvYmFibHkgcmVzb2x2ZWQgc29tZSBkYXRhIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc2VsZi5wYXJhbWV0ZXJzKVxuXG4gICAgICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmFkZFJlZXhlY3V0aW9uTGlzdGVuZXIoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmVlZHNSZWxvYWRpbmdWaXN1YWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS5wcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0ID0gcmVzdWx0Lm1xdHRfc3dldmFfcGFyYW1ldGVycy5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhcmFtZXRlcnMgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vdXRwdXQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1xdHRfY2xpZW50ID0gcmVzdWx0Lm1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLmNsaWVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYocmVzdWx0Lmxhc3RSZXR1cm5lZERhdGEpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZm9yICh2YXIga2V5IGluIHNlbGYuY29tcG9zYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgaWYoc2VsZi5jb21wb3NhYmxlc1trZXldLm5hbWUgPT0gcmVzdWx0Lm5hbWUpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgdmFyIG91dHB1dCA9ICBzZWxmLmNvbXBvc2FibGVzW2tleV0uZGF0YU91dE5hbWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzZWxmLmNvbXBvc2FibGVzW2tleV0uZGF0YUluTmFtZXMpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBzZWxmLnBhcmFtZXRlcnNba2V5XVtzZWxmLmNvbXBvc2FibGVzW2tleV0uZGF0YUluTmFtZXNbaV1dID0gcmVzdWx0Lmxhc3RSZXR1cm5lZERhdGFbb3V0cHV0XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudW5sY2VhcmVkQ29tcG9zYWJsZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS51bmNsZWFyZWRDb21wb3NhYmxlc0Nsb25lKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZVF1ZXVlRXhlY3V0aW9uLmFwcGx5KHNlbGYsIFtzZWxmLmNvbnRleHRdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY29tcHV0aW5nIGRlbW8gcmVzdWx0Jyk7XG4gICAgICAgICAgICAgICAgfSwgc2VsZi5tcXR0X21vZHVsZV9uYW1lKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvc2FibGVRdWV1ZUV4ZWN1dGlvbi5hcHBseShzZWxmLCBbY29udGV4dF0pO1xuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgICAvL21hcmsgY29tcG9zYWJsZSBhcyBjbGVhcmVkXG4gICAgICAgIGlmICghdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jbGVhcmVkKSB7XG5cbiAgICAgICAgICAgIC8vUmV0cmlldmUgRGF0YSBuZWVkZWQgZm9yIHRoZSBBU1lOQyBjYWxscyBvZiB0aGUgTVFUVCBub2Rlc1xuICAgICAgICAgICAgLy9DaGVjayBpZiB0aGUgY3VycmVudCBub2RlIGFib3V0IHRvIGJlIGNsZWFyZWQgaXMgYW4gTVFUVCBub2RlXG4gICAgICAgICAgdmFyIG1xdHRfc3dldmFfcGFyYW1ldGVycyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb21wb3NhYmxlc1t0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNvbXBvc2FibGVdLnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICBzZWxmLm1xdHRfbW9kdWxlX25hbWUgPSB0aGlzLmNvbXBvc2FibGVzW3RoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY29tcG9zYWJsZV0ubmFtZTtcbiAgICAgICAgICAgIG1xdHRfc3dldmFfcGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgICAgbW9kdWxlX25hbWU6IHRoaXMuY29tcG9zYWJsZXNbdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jb21wb3NhYmxlXS5uYW1lLFxuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdGhpcy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgICAgICAgICAgdW5jbGVhcmVkQ29tcG9zYWJsZXNDbG9uZTogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzKSksXG4gICAgICAgICAgICAgICAgcHJvY2VzczogdGhpcy5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMubXF0dF9jbGllbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tcXR0X21vZHVsZV9uYW1lID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY2xlYXJlZCA9IHRydWU7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgLy9leGVjdXRlIGNvbXBvc2FibGVcbiAgICAgICAgICAgIHRoaXMuY29tcG9zYWJsZXNbY29tcG9zYWJsZU5hbWVdLmV4ZWN1dGUoZGF0YSwgaW5wdXQsIGNvbnRleHQsIGNvbXBvc2FibGVOYW1lLCBtcXR0X3N3ZXZhX3BhcmFtZXRlcnMsIHRoaXMucHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIC8vYSA9PiBjb25zb2xlLmxvZyhhKSlcbiAgICAgICAgICAgICAgICAgICAgZnVuYyhjb21wb3NhYmxlTmFtZSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvL2Vycm9yIGlzIGxvZ2dlZCBlYXJsaWVyLCBidXQgaG93IHRvIGhhbmRsZT9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgXG4gICAgfVxufVxuLyoqXG4gKiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSBjb21wb3NhYmxlLCBpbml0aWFsaXplcyByZXF1aXJlZCBkYXRhLiBVc2UgdGhpcyBmdW5jdGlvbiBpZiB5b3Ugd2FudCB0byBleGVjdXRlIGEgY29tcG9zYWJsZSFcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgcmVsZXZhbnQgdG8gdGhlIHByb2Nlc3NpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gcHJvY2VzcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gRXhlY3V0aW9uIGNvbnRleHQuIFNlZSB7QGxpbmsgQ29tcG9zYWJsZSNjb250ZXh0fS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWxpYXNdIC0gTmFtZSwgdW5kZXIgd2hpY2ggdGhlIGNvbXBvc2FibGUgaXMga25vd24gdG8gaXRzIHBhcmVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9ncmVzc10gLSBDYWxsYmFjayBmb3IgcHJvZ3Jlc3MgdHJhY2tpbmcsIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2R1bGUgZmluaXNoZXMgZXhlY3V0aW9uLlxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dCwgY29udGV4dCwgYWxpYXMsIHByb2dyZXNzKSB7XG4gICAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIGNvbnRleHQgPSB0aGlzLmdldE5ld0NvbnRleHQoY29udGV4dCwgYWxpYXMpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBcbiAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgXG4gICAgLy9yZXR1cm4gYSBwcm9taXNlLCBzaW5jZSBleGVjdXRpb24gaXMgYXN5bmNcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvL2RvIG5vdCBib3RoZXIgZXhlY3V0aW5nLCBpZiBsaW5rIGdyYXBoIGRlZmluaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHByb3ZpZGVkIGRhdGEgb3IgaW5wdXQgb2JqZWN0IGRvIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2NoZW1hIGRlZmluaXRpb25zXG4gICAgICAgIGlmICghc2VsZi5pbnZhbGlkTGlua0dyYXBoICYmIHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YUluJywgZGF0YSkgJiYgc2VsZi52YWxpZGF0ZVR5cGVzKCdpbnB1dCcsIGlucHV0KSkge1xuICAgICAgICAgICAgLy9lYWNoIHN0YXJ0aW5nIGNvbXBvc2FibGUgaGFzIGFuIG93biBkYXRhIHBhcnRcbiAgICAgICAgICAgIC8vdXNlIHVzZXItZGVmaW5hYmxlIHtAbGluayBDb21wb3NpdGlvbn5tYXBEYXRhSW5GdW5jdGlvbn0gdG8gbWFwIHRoZSBkYXRhIHRvIHRoZSBzdGFydGluZyBjb21wb3NhYmxlc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnN0YXJ0aW5nQ29tcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9zYWJsZU5hbWUgPSBzZWxmLnN0YXJ0aW5nQ29tcG9zYWJsZXNbaV07ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2VsZi5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXSA9IHNlbGYubWFwRGF0YUluKHNlbGYuZGF0YSwgY29tcG9zYWJsZU5hbWUsIHNlbGYuY29tcG9zYWJsZXMsIHN3ZXZhLmxpYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RlZmluZSBjYWxsYmFjayBmb3Igd2hlbiBleGVjdXRpb24gaXMgZmluaXNoZWRcbiAgICAgICAgICAgIHNlbGYuZXhlY3V0ZUZpbmlzaGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ1NvbWV0aGluZyB1bmV4cGVjdGVkIGhhcHBlbmVkOiAnICsgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIGVycm9yXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdXNlIHVzZXItZGVmaW5hYmxlIHtAbGluayBDb21wb3NpdGlvbn5tYXBEYXRhT3V0RnVuY3Rpb259IHRvIGNyZWF0ZSB0aGUgZmluYWwgb3V0cHV0IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5tYXBEYXRhT3V0KHNlbGYub3V0cHV0LCBzd2V2YS5saWJzKTtcbiAgICAgICAgICAgICAgICAgICAgLy92YWxpZGF0ZSBvdXRwdXQgdXNpbmcgcHJvdmlkZWQgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnZhbGlkYXRlVHlwZXMoJ2RhdGFPdXQnLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxmLm5lZWRzUmVsb2FkaW5nVmlzdWFsaXphdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWFuYWdlci5zZW5kRGF0YVRvVmlzdWFsaXphdGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2FsbCBjb21wb3NhYmxlcyBhcmUgbG9hZGVkLCBzbyBleGVjdXRpb24gY2FuIHN0YXJ0IGRpcmVjdGx5XG4gICAgICAgICAgICBpZiAoc2VsZi5pc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24uYXBwbHkoc2VsZiwgW2NvbnRleHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2RlbGF5IGV4ZWN1dGlvbiB0byB7QGxpbmsgQ29tcG9zaXRpb24jbG9hZENvbXBvc2FibGVzfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy93ZSB3YW50IHRvIGV4ZWN1dGUsIGJ1dCBjYW5ub3Q6IHRlbGwgc28gdGhlIGluaXRpYWxpemF0aW9uL2xvYWRpbmcgcGFydFxuICAgICAgICAgICAgICAgIHNlbGYud2FudHNUb0V4ZWN1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSB2aWEgY2FsbGJhY2ssIGFzIHNvb24gYXMgbG9hZGluZyBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIHNlbGYuZXhlY3V0ZVN0YXJ0ZXJDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZVF1ZXVlRXhlY3V0aW9uLmFwcGx5KHNlbGYsIFtjb250ZXh0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGlvbjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb3NhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NhYmxlLmpzJyk7XG4vL3ZhciBDb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zaXRpb24uanMnKTtcbnZhciBEZWZpbml0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9kZWZpbml0aW9uRXJyb3IuanMnKTtcbnZhciBFeGVjdXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL0V4ZWN1dGlvbkVycm9yLmpzJyk7XG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgSFRUUCByZXF1ZXN0IGFzIGEgcHJvbWlzZS4gSXQgaXMgdXNlZCB0byBjYWxsIGEgcmVtb3RlIHNlcnZpY2UgdXNpbmcgaXRzIEFQSS5cbiAqXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBjYWxsYmFjayBNb2R1bGV+cmVxdWVzdEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBbiBvYmplY3QgYWxsb3dpbmcgYWNjZXNzIHRvIGxpYnJhcmllcyBpbnNpZGUgdGhlIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyBmcm9tIGZhaWxlZCBzZXJ2aWNlIGNhbGxzLlxuICpcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcbiAqIEEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gaXMgYWNjZXNzaWJsZSBmcm9tIGluc2lkZSB0aGUgZnVuY3Rpb24gdW5kZXIgbGlicy5nZXQsIHdoaWNoIHRha2VzIHRoZSBvYmplY3QgYW5kIGRlc2lyZWQgcHJvcGVydHkga2V5IGFzIGEgc3RyaW5nIGFuZFxuICogYWN0cyBhcyBbXS5cbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGNhbGxiYWNrIE1vZHVsZX5yZXF1ZXN0RXJyb3JGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdCBmcm9tIHRoZSBzZXJ2aWNlIGNhbGwuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEFuIG9iamVjdCBhbGxvd2luZyBhY2Nlc3MgdG8gbGlicmFyaWVzIGluc2lkZSB0aGUgZnVuY3Rpb24uXG4gKi9cblxuXG4vKipcbiAqIEEgdXNlciBkZWZpbmVhYmxlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgcmVzcG9uc2Ugb2YgdGhlIHNlcnZpY2UuXG4gKlxuICogQXR0ZW50aW9uISBUaGUgdXNlciBkZWZpbmFibGUgZnVuY3Rpb25zIHVzZSBhIGxpbWl0ZWQgc3Vic2V0IG9iIEphdmFTY3JpcHQuIFlvdSBjYW5ub3QgdXNlIGRhbmdlcmVvdXMgb3BlcmF0aW9ucywgbGlrZSBhY2Nlc3NpbmcgdGhpcywgZXZhbCwgZXRjLlxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXG4gKiBhY3RzIGFzIFtdLlxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAY2FsbGJhY2sgTW9kdWxlfnJlcXVlc3RFcnJvckZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gdGhlIHNlcnZpY2UgY2FsbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWJzIC0gQW4gb2JqZWN0IGFsbG93aW5nIGFjY2VzcyB0byBsaWJyYXJpZXMgaW5zaWRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgdXNlciBkZWZpbmVhYmxlIGZ1bmN0aW9uIHRvIGRvIGFsbCBjb21wdXRhdGlvbiBsb2NhbGx5LCBubyBzZXJ2aWNlIGlzIGNhbGxlZC5cbiAqXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBjYWxsYmFjayBNb2R1bGV+Y29tcHV0ZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBbiBvYmplY3QgYWxsb3dpbmcgYWNjZXNzIHRvIGxpYnJhcmllcyBpbnNpZGUgdGhlIGZ1bmN0aW9uLlxuICovXG5cblxuLyoqXG4gKiBUaGUgaW5pdGFsaXphdGlvbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgbW9kdWxlcy5cbiAqIEB0eXBlZGVmIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gbW9kdWxlSW5pdGFsaXplclxuICogQHByb3BlcnR5IHtNb2R1bGV+cmVxdWVzdEZ1bmN0aW9ufSBbcmVxdWVzdF0gLSBDcmVhdGVzIGEgSFRUUCByZXF1ZXN0IHRvIGNhbGwgdGhlIGFwcHJvcHJpYXRlIHNlcnZpY2UuXG4gKiBAcHJvcGVydHkge01vZHVsZX5yZXF1ZXN0RXJyb3JGdW5jdGlvbn0gW3JlcXVlc3RdIC0gSWYgdGhpcyBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaXQgaXMgdXNlZCB0byBoYW5kbGUgZXJyb3JzLCBpZiB0aGUgc2VydmljZSBjYWxsIHdhcyB1bnN1Y2Nlc3NmdWwuXG4gKiBAcHJvcGVydHkge01vZHVsZX5yZXNwb25zZUZ1bmN0aW9ufSBbcmVxdWVzdF0gLSBGdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHRoZSBzZXJ2aWNlIHJlc3BvbnNlIHRvIGJlIHVzZWQgbGF0ZXIgb24uXG4gKiBAcHJvcGVydHkge01vZHVsZX5jb21wdXRlRnVuY3Rpb259IFtyZXF1ZXN0XSAtIElmIHByb3ZpZGVkLCBubyBzZXJ2aWNlIGlzIGNhbGxlZCwgYnV0IGFsbCBjb21wdXRhdGlvbiBpcyBwZXJmb3JtZWQgbG9jYWxseSBpbiB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqL1xuXG4vKipcbiAqIEEgbW9kdWxlIGlzIHRoZSBzbWFsbGVzdCB1bml0IG9mIGV4ZWN1dGlvbi5cbiAqIEl0IHNlcnZlcyBhcyBhbiBlbnZlbG9wZSB0byBhIHNlcnZpY2UgY2FsbCBhbmQgY2FuIG9wdGlvbmFsbHkgZG8gYWxsIGNvbXB1dGF0aW9ucyBsb2NhbGx5IHdpaHRvdXQgYSByZW1vdGUgc2VydmljZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tcG9zYWJsZVxuICogQHBhcmFtIHttb2R1bGVJbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zaXRpb24uXG4gKlxuICovXG5mdW5jdGlvbiBNb2R1bGUoaW5pdGlhbGl6YXRpb25PYmplY3QsIG1hbmFnZXIpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKGluaXRpYWxpemF0aW9uT2JqZWN0KTtcblxuICAgIC8vIGdlbmVyYWwgbm9kZSB0eXBlXG5cbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3J1bicsIDMsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnbGFuZ3VhZ2UnLCAndHlwZXNjcmlwdCcpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdzb3VyY2UnLCBudWxsKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2JpbmFyeScsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnYmluYXJ5SGFzaCcsIG51bGwpO1xuXG4gICAgLyp0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3JlcXVlc3RFcnJvcicsIDMsIG51bGwpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdyZXNwb25zZScsIDMsXG4gICAgICBmdW5jdGlvbiAocmVzcG9uc2UsIGlucHV0LCBsaWJzKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW3RoaXMuZGF0YU91dE5hbWVzWzBdXSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KTsqL1xuXG4gICAgLy8gbm93IHRoZSBhc3luY2hyb25vdXMgbm9kZSB0eXBlXG5cbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3N1YnNjcmliZScsIDMsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnb25Db25uZWN0JywgMywgbnVsbCk7XG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdvblN1YnNjcmlwdGlvbicsIDMsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnb25NZXNzYWdlUmVjZWl2ZWQnLCA0LCBudWxsKTtcbn1cblxuLy9pbmhlcml0IHByb3BlcnRpZXNcbk1vZHVsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvc2FibGUucHJvdG90eXBlKTtcbk1vZHVsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2R1bGU7XG5cbk1vZHVsZS5wcm90b3R5cGUubGFzdFJldHVybmVkRGF0YSA9IG51bGw7XG5cbi8qKlxuICogQ2FsbHMgdGhlIHNlcnZpY2UgdXNpbmcgdGhlIGNyZWF0ZWQgSFRUUCByZXF1ZXN0IHJlY2VpdmVkIGZyb20ge0BsaW5rIE1vZHVsZX5yZXF1ZXN0RnVuY3Rpb259LlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcmVxdWVzdCAtIFRoZSBhc3luYyBzZXJ2aWNlIGNhbGwuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgZGF0YSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB3aXRoIHRoZSByZXNwb25zZSBvYmplY3QuXG4gKi9cbk1vZHVsZS5wcm90b3R5cGUuY2FsbFNlcnZpY2UgPSBmdW5jdGlvbiAocmVxdWVzdCwgaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYucmVzcG9uc2UocmVzcG9uc2UsIGlucHV0LCBzd2V2YS5saWJzKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vaWYgd2UgaGF2ZSBhIGZ1bmN0aW9uIHRvIGRlYWwgd2l0aCBlcnJvcnMgZnJvbSBzZXJ2aWNlIGRpcmVjdGx5Li4uXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlcXVlc3RFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYucmVxdWVzdEVycm9yKHJlc3BvbnNlLCBpbnB1dCwgc3dldmEubGlicykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgb25lIHN1YnNjcmliZXMgdG8gYSB0b3BpYyBvbiBhIG1lc3NhZ2UgcXVldWUuXG4gKlxuICogQHBhcmFtIHN1YnNjcmliZVxuICogQHBhcmFtIGlucHV0XG4gKi9cbk1vZHVsZS5wcm90b3R5cGUuY2FsbFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGRhdGEsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoc3Vic2NyaWJlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIGNsaWVudCA9IHN1YnNjcmliZTtcbiAgICAgICAgICAgIG1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgICAgIGNsaWVudC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uQ29ubmVjdChjbGllbnQsIGlucHV0LCBzd2V2YS5saWJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYubGFzdFJldHVybmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGYubGFzdFJldHVybmVkRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAodG9waWMsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobXF0dF9zd2V2YV9wYXJhbWV0ZXJzICE9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubXF0dF9zd2V2YV9wYXJhbWV0ZXJzID0gbXF0dF9zd2V2YV9wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubGFzdFJldHVybmVkRGF0YSA9IHNlbGYub25NZXNzYWdlUmVjZWl2ZWQoc2VsZi5sYXN0UmV0dXJuZWREYXRhLCB0b3BpYywgbWVzc2FnZSwgc3dldmEubGlicyk7XG4gICAgICAgICAgICAgICAgLy8gbm93IG5vdGlmeSB0aGUgZXhlY3V0aW9uIG1hbmFnZXJcbiAgICAgICAgICAgICAgICBzZWxmLm1hbmFnZXIub25Nb2R1bGVVcGRhdGUoc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmVzb2x2ZShzZWxmLm9uU3Vic2NyaXB0aW9uKGRhdGEsIGlucHV0LCBzd2V2YS5saWJzKSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGVycm9ycyBmcm9tIHNlcnZpY2UgZGlyZWN0bHkuLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5yZXF1ZXN0RXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYucmVxdWVzdEVycm9yKHJlc3BvbnNlLCBpbnB1dCwgc3dldmEubGlicykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIG1vZHVsZSwgaS5lLiBwZXJmb3JtcyB0aGUgY29tcHV0YXRpb24gZWl0aGVyIGJ5IGNhbGxpbmcgYSBzZXJ2aWNlIG9yIGxvY2FsbHkuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHJlbGV2YW50IHRvIHRoZSBwcm9jZXNzaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gSW5wdXQgaW5mb3JtYXRpb24gb24gaG93IHRvIHByb2Nlc3MgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIEV4ZWN1dGlvbiBjb250ZXh0LiBTZWUge0BsaW5rIENvbXBvc2FibGUjY29udGV4dH0uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FsaWFzXSAtIE5hbWUsIHVuZGVyIHdoaWNoIHRoZSBjb21wb3NhYmxlIGlzIGtub3duIHRvIGl0cyBwYXJlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvZ3Jlc3NdIC0gQ2FsbGJhY2sgZm9yIHByb2dyZXNzIHRyYWNraW5nLCBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kdWxlIGZpbmlzaGVzIGV4ZWN1dGlvbi5cbiAqL1xuTW9kdWxlLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0LCBjb250ZXh0LCBhbGlhcywgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzLCBwcm9ncmVzcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb25zb2xlLmxvZyhcImNvbnRleHQgPT09XCIpO1xuICAgIGNvbnNvbGUubG9nKGNvbnRleHQpO1xuICAgIGNvbnNvbGUubG9nKFwiTW9kdWxlIHRvIGJlIGV4ZWN1dGVkID1cIik7XG4gICAgY29uc29sZS5sb2coc2VsZik7XG4gICAgY29udGV4dCA9IHRoaXMuZ2V0TmV3Q29udGV4dChjb250ZXh0LCBhbGlhcyk7XG5cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHt9O1xuICAgIH1cblxuXG4gICAgLy8gUHJvbWlzZSB0byBhYm9ydCBpZiBvZmZsb2FkaW5nIGlzIG5lY2Vzc2FyeVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vYmVnaW4gcHJvbWlzZVxuICAgICAgICAvL29ubHkgZXhlY3V0ZSwgaWYgZGF0YSBhbmQgaW5wdXQgb2JqZWN0cyBhcmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25hbCBzY2hhbWFzXG4gICAgICAgIGlmIChzZWxmLnZhbGlkYXRlVHlwZXMoJ2RhdGFJbicsIGRhdGEpICYmIHNlbGYudmFsaWRhdGVUeXBlcygnaW5wdXQnLCBpbnB1dCkpIHtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbnB1dCBkYXRhIGZvciBcIiArIGFsaWFzICsgXCI6IFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5zb3VyY2UgIT0gbnVsbCkgeyAvL1RPRE86IHR5cGVvZiBzZWxmLnJ1biA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAvLyBpZiBhIGNvbXB1dGF0aW9uIGZ1bmN0aW9uIGlzIGRlZmluZWQsIHRoZW4gc2tpcCBzZXJ2aWNlIGNhbGxzIGFuZCBjb21wdXRlIGxvY2FsbHlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVYRUNVVEUgXCIgKyBzZWxmLm5hbWUgKyBcIltcIiArIGFsaWFzICsgXCJdIFVTSU5HOiBcIiArIHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgLy9jb25zdCByZXN1bHQgPSBhd2FpdCBzd2V2YS5ydW5uZXJzW3NlbGYubGFuZ3VhZ2VdLmV4ZWMoc2VsZiwgZGF0YSwgaW5wdXQsIHtzaWduYWx9KTtcblxuICAgICAgICAgICAgICAgIC8vPT09IE9GRkxPQURJTkcgPT09IE1PRFVMRSBFWEVDVVRJT04gQkVHSU5TIEhFUkVcbiAgICAgICAgICAgICAgICBzd2V2YS5ydW5uZXJzW3NlbGYubGFuZ3VhZ2VdLmV4ZWMoc2VsZiwgZGF0YSwgaW5wdXQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzdWx0IGRhdGEgZm9yIFwiICsgYWxpYXMgKyBcIjogXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09J29mZmxvYWRpbmcnKXtcbiAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29mZmxvYWRpbmcnKSAvL3RvZG86IHJlc29sdmUgb3IgcmVqZWN0IGhlcmUgP1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogTUFQIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICAvL3ZhciByZXN1bHQgPSBzZWxmLnJ1bihkYXRhLCBpbnB1dCwgc3dldmEubGlicyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnZhbGlkYXRlVHlwZXMoJ2RhdGFPdXQnLCByZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlcG9ydCBwcm9ncmVzcywgaWYgY2FsbGJhY2sgaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyhhbGlhcywgc2VsZi5uYW1lLCBjb250ZXh0LHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIG1vZHVsZSBleGVjdXRpb24gcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2ZmbG9hZGluZyBjYWxsYmFjayBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHN1YnNjcmliaW5nIHRvIGFuIGFzeW5jaHJvbm91cyBtZXNzYWdlIHF1ZXVlXG4gICAgICAgICAgICB2YXIgY2xpZW50O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS5jbGllbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50ID0gc2VsZi5zdWJzY3JpYmUoZGF0YSwgaW5wdXQsIHN3ZXZhLmxpYnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2FsbFN1YnNjcmlwdGlvbihjbGllbnQsIGRhdGEsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgaW5wdXQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vdmFsaWRhdGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YU91dCcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXBvcnQgcHJvZ3Jlc3MsIGlmIGNhbGxiYWNrIGlzIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MoYWxpYXMsIHNlbGYubmFtZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhc3RSZXR1cm5lZERhdGEgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFeGVjdXRpb25FcnJvcignU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQ6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFuIEhUVFAgcmVxdWVzdCBub2RlLCBjYWxsIHNlcnZpY2UgdXNpbmcgYW4gSFRUUCByZXF1ZXN0XG5cbiAgICAgICAgICAgIHNlbGYuY2FsbFNlcnZpY2Uoc2VsZi5yZXF1ZXN0KGRhdGEsIGlucHV0LCBzd2V2YS5saWJzKSwgaW5wdXQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBvdXRwdXQgaXMgYWxyZWFkeSB0aGUgSFRUUCByZXNwb25zZVxuXG4gICAgICAgICAgICAgICAgLy92YWxpZGF0ZSBvdXRwdXRcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhT3V0Jywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcG9ydCBwcm9ncmVzcywgaWYgY2FsbGJhY2sgaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyhhbGlhcywgc2VsZi5uYW1lLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBFeGVjdXRpb25FcnJvcignU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQ6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIGVycm9yKSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZTsiLCIvL2dsb2JhbCBvYmplY3QgaW5pdGlhbGl6YXRpb25cbnZhciBnbG9iYWxPYmplY3Q7XG5cbnZhciBpbkJyb3dzZXIgPSBmYWxzZTtcblxudHJ5IHtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICAgIGdsb2JhbE9iamVjdCA9IHdpbmRvdztcbiAgICAgICAgaW5Ccm93c2VyID0gdHJ1ZTtcbiAgICB9XG59XG5jYXRjaCAoZSkge1xuICAgIGdsb2JhbE9iamVjdCA9IGdsb2JhbDtcbn1cblxuLy9wcmV2ZW50IGxvYWRpbmcgZXZlcnl0aGluZyB0d2ljZSBvbiBlZGl0b3ItcGFnZVxuaWYoIWdsb2JhbE9iamVjdC5zd2V2YSkge1xuICAgIGdsb2JhbE9iamVjdC5zd2V2YSA9IHt9O1xuXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLmluQnJvd3NlciA9IGluQnJvd3NlcjtcblxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5hc3luY21xdHQgPSByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvYXN5bmMtbXF0dCcpO1xuXG4gICAgdmFyIEFqdiA9IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qcycpO1xuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5BanYgPSBuZXcgQWp2KCk7XG5cbiAgICB2YXIgQ29tcG9zYWJsZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL2V4ZWN1dGlvbi9jb21wb3NhYmxlTG9hZGVyLmpzJyk7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLkNvbXBvc2FibGVMb2FkZXIgPSBuZXcgQ29tcG9zYWJsZUxvYWRlcignJyk7XG5cbiAgICBnbG9iYWxPYmplY3Quc3dldmEuRXhlY3V0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL2V4ZWN1dGlvbi9leGVjdXRpb25NYW5hZ2VyLmpzJyk7XG5cbiAgICB2YXIgRXJyb3JNYW5hZ2VyID0gcmVxdWlyZSgnLi4vLi4vYXBwL2NvcmUvZXJyb3JzL2Vycm9yTWFuYWdlci5qcycpO1xuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5FcnJvck1hbmFnZXIgPSBuZXcgRXJyb3JNYW5hZ2VyKCk7XG5cbiAgICB2YXIgU3dldmFTY3JpcHQgPSByZXF1aXJlKCcuLi8uLi9hcHAvY29yZS9zd2V2YVNjcmlwdC9zd2V2YVNjcmlwdC5qcycpO1xuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdCA9IG5ldyBTd2V2YVNjcmlwdCgpO1xuXG4gICAgdmFyIEFzc2VtYmx5U2NyaXB0UnVubmVyID0gcmVxdWlyZSgnLi4vLi4vYXBwL2NvcmUvcnVubmVycy9hc3NlbWJseVNjcmlwdFJ1bm5lci5qcycpO1xuXG4gICAgLypcbiAgICBnbG9iYWxPYmplY3Quc3dldmEuYXhpb3MgPSByZXF1aXJlKCcuLi8uLi9ub2RlX21vZHVsZXMvYXhpb3MvZGlzdC9heGlvcy5taW4uanMnKTtcbiAgICBnbG9iYWxPYmplY3Quc3dldmEubGlicyA9IHtcbiAgICAgICAgYXhpb3M6IGdsb2JhbE9iamVjdC5zd2V2YS5heGlvcyxcbiAgICAgICAgbXF0dDogZ2xvYmFsT2JqZWN0LnN3ZXZhLmFzeW5jbXF0dCxcbiAgICAgICAgZ2V0OiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuZ2V0LFxuICAgICAgICBzZXQ6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5zZXQsXG4gICAgICAgIC8vbXF0dGNsaWVudDogZ2xvYmFsT2JqZWN0LnN3ZXZhLlN3ZXZhU2NyaXB0LmNsaWVudCxcbiAgICAgICAgLy9tcXR0c3Vic2NyaWJlOiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuc3Vic2NyaWJlLFxuICAgICAgICBhZGRkYXRhOiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuYWRkZGF0YVxuICAgIH0qL1xuXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLnJ1bm5lcnMgPSB7fTtcblxuICAgIHZhciB0eXBlc2NyaXB0ID0gbmV3IEFzc2VtYmx5U2NyaXB0UnVubmVyKCk7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLnJ1bm5lcnNbdHlwZXNjcmlwdC5pZF0gPSB0eXBlc2NyaXB0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbE9iamVjdC5zd2V2YTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBTd2V2YUVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcycpO1xuLyoqXG4gKiBBbiBleGVjdXRpb24gZXJyb3Igc2hvdWxkIGJlIHVzZWQsIGlmIHRoZSBlcnJvciBvY2N1cmVkIGR1cmluZyBleGVjdXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFN3ZXZhRXJyb3JcbiAqL1xuZnVuY3Rpb24gRXhlY3V0aW9uRXJyb3IobWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KSB7XG4gICAgU3dldmFFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIGNvbnRleHQsIGZhdWx0eU9iamVjdCk7XG4gICAgdGhpcy5uYW1lID0gJ0V4ZWN1dGlvbkVycm9yJztcbn1cbkV4ZWN1dGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3dldmFFcnJvci5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVycm9yIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvZGVmaW5pdGlvbkVycm9yLmpzJyk7XG4vKipcbiAqIEEgY29tcGlsZSBlcnJvciBzaG91bGQgYmUgdXNlZCwgaWYgIHRoZSBlcnJvciB3YXMgdGhyb3duIGJ5IHRoZSBjb21waWxlciwgYmVmb3JlIGFjdHVhbCBleGVjdXRpb24gYW5kIHZhbGlkYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERlZmluaXRpb25FcnJvclxuICovXG5mdW5jdGlvbiBDb21waWxlRXJyb3IobWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KSB7XG4gICAgRGVmaW5pdGlvbkVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KTtcbiAgICB0aGlzLm5hbWUgPSAnQ29tcGlsZUVycm9yJztcbn1cbkNvbXBpbGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlZmluaXRpb25FcnJvci5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVFcnJvcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBTd2V2YUVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcycpO1xuLyoqXG4gKiBBIGRlZmluaXRpb24gZXJyb3Igc2hvdWxkIGJlIHVzZWQsIGlmICB0aGUgZXJyb3Igb2NjdXJlZCBiZWNhdXNlIG9mIGluY29tcGF0aWJsZSBkZWZpbml0aW9ucyBvZiBjb21wb3NhYmxlcywgaS5lLiBiZWZvcmUgYWN0dWFsIGV4ZWN1dGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU3dldmFFcnJvclxuICovXG5mdW5jdGlvbiBEZWZpbml0aW9uRXJyb3IobWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KSB7XG4gICAgU3dldmFFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIGNvbnRleHQsIGZhdWx0eU9iamVjdCk7XG4gICAgdGhpcy5uYW1lID0gJ0RlZmluaXRpb25FcnJvcic7XG59XG5EZWZpbml0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTd2V2YUVycm9yLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmaW5pdGlvbkVycm9yOyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQWdncmVnYXRlcyB7QGxpbmsgU3dldmFFcnJvcn0gbWVzc2FnZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRXJyb3JNYW5hZ2VyKCkge1xuICAgIC8qKlxuICAgICogQW4gYXJyYXkgc3RvcmluZyB0aGUgZXJyb3IgbWVzc2FnZXMuXG4gICAgKiBAbmFtZSBFcnJvck1hbmFnZXIjcXVldWVcbiAgICAqIEB0eXBlIHtBcnJheS48RXJyb3I+fVxuICAgICovXG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xufVxuLyoqXG4gKiBSZXNldHMgdGhlIEVycm9yTWFuYWdlci5cbiAqL1xuRXJyb3JNYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG4vKipcbiAqIEFwcGVuZHMgZXJyb3JzIHRvIHRoZSBpbnRlcm5hbCBxdWV1ZSwgbG9ncyB0aGVtIGFuZCByZXR1cm5zIHRoZSBlcnJvciBvYmplY3RcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIC0gVGhlIGVycm9yIG9iamVjdC5cbiAqIEByZXR1cm5zIHtFcnJvcn0gLSBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG5FcnJvck1hbmFnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGVycm9yKTtcbiAgICBjb25zb2xlLmxvZyhlcnJvci50b1N0cmluZygpKTtcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLyoqXG4gKiBHZXRzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBzdG9yZWQgZXJyb3JzLlxuICogQHJldHVybnMge3N0cmluZ30gLSBBbGwgc3RvcmVkIGVycm9ycyBzZXBhcmF0ZWQgYnkgYSBsaW5lYnJlYWsuXG4gKi9cbkVycm9yTWFuYWdlci5wcm90b3R5cGUuZ2V0TG9nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHRoaXMucXVldWVbaV0udG9TdHJpbmcoKSArICdcXG4nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcmV0dXJucyB7RXJyb3J9IC0gVGhlIGxhc3QgZXJyb3IgdGhhdCB3YXMgcmVjb3JkZWQuXG4gKi9cbkVycm9yTWFuYWdlci5wcm90b3R5cGUuZ2V0TGFzdEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWVbdGhpcy5xdWV1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXJyb3JNYW5hZ2VyOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBbiBlcnJvciBvYmplY3Qgd2l0aCBzb21lIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlOiBXaGF0IHdlbnQgd3Jvbmc/XG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBleGVjdXRpb24gY29udGV4dCwgaW4gd2hhdCBjb21wb3NhYmxlIGRpZCB0aGUgZXJyb3Igb2NjdXI/XG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhdWx0eU9iamVjdF0gLSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvciBjYXVzZS5cbiAqL1xuZnVuY3Rpb24gU3dldmFFcnJvcihtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpIHtcbiAgICAvKipcbiAgICAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvciBvYmplY3QuXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI25hbWVcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLm5hbWUgPSAnU3dldmFFcnJvcic7XG5cbiAgICAvKipcbiAgICAqIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICogQG5hbWUgU3dldmFFcnJvciNtZXNzYWdlXG4gICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnRGVmYXVsdCBNZXNzYWdlJztcblxuICAgIC8qKlxuICAgICogVGhlIGNhbGxzdGFjayBvZiB0aGUgZXJyb3IuXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI3N0YWNrXG4gICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICovXG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG5cbiAgICAvKipcbiAgICAqIFRoZSBleGVjdXRpb24gY29udGV4dCBvZiB0aGUgZXJyb3IgKGluIHdoaWNoIGNvbXBvc2FibGUgaXQgb2NjdXJlZCkuXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI2NvbnRleHRcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICBcbiAgICBpZiAoZmF1bHR5T2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvL3NoYWxsb3cgY29weTogc2hvdWxkIHByb3ZpZGUgZW5vdWdoIGluZm9ybWF0aW9uIGFuZCBzYXZlIFJBTVxuICAgICAgICAvL2NvcHkgaXMgbmVlZGVkLCBhcyB3ZSBuZWVkIHRoZSBvYmplY3QgZXhhY3RseSBhdCB0aGUgdGltZSB0aGUgZXJyb3Igb2NjdXJyZWRcbiAgICAgICAgdGhpcy5mYXVsdHlPYmplY3QgPSBmYXVsdHlPYmplY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmYXVsdHlPYmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vbWFrZSBmdW5jdGlvbnMgdG8gc3RyaW5ncyAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5mYXVsdHlPYmplY3QgPSBmYXVsdHlPYmplY3QudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmF1bHR5T2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGZhdWx0eU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChmYXVsdHlPYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhdWx0eU9iamVjdFtrZXldID0gZmF1bHR5T2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmZhdWx0eU9iamVjdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHRpbWVzdGFtcCBvZiB0aGUgZXJyb3IuXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI3RpbWVcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIFwiK2NvbnRleHQrXCIgY3JlYXRlZCEgU3RhY2t0cmFjZTpcIik7XG4gICAgY29uc29sZS50cmFjZSgpO1xufVxuLy9pbmhlcml0IHByb3BlcnRpZXNcblN3ZXZhRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogdGhpcy5jb25zdHJ1Y3RvcixcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbn0pO1xuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvciB0aW1lc3RhbXAuXG4gKi9cblN3ZXZhRXJyb3IucHJvdG90eXBlLmdldFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZSkudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgZXJyb3Igb2JqZWN0IHRvIHN0cmluZyBpbmNsdWRpbmcgcmVsZXZhbnQgaW5mb3JtYXRpb24gKHRpbWVzdGFtcCwgbmFtZSwgY29udGV4dCwgbWVzc2FnZSwgYWRkaXRpb25hbCBpbmZvcm1hdGlvbikuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IuXG4gKi9cblN3ZXZhRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmYXVsdHlPYmplY3QgPSAnJztcbiAgICBpZiAodHlwZW9mIHRoaXMuZmF1bHR5T2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvL3RyYW5zZm9ybSBvYmplY3QgdG8gcHJldHR5IHByaW50ZWQgc3RyaW5nICh3aXRoIGlkZW50YXRpb24pLlxuICAgICAgICBmYXVsdHlPYmplY3QgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmZhdWx0eU9iamVjdCwgbnVsbCwgNCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmYXVsdHlPYmplY3QgPSB0aGlzLmZhdWx0eU9iamVjdC50b1N0cmluZygpO1xuICAgIH1cbiAgICAvL2NvbnN0cnVjdCBzdHJpbmdcbiAgICByZXR1cm4gJ1snICsgdGhpcy5nZXRUaW1lKCkgKyAnXSBTd2V2YUVycm9yICcgKyB0aGlzLm5hbWUgKyAnIGluICcgKyB0aGlzLmNvbnRleHQgKyAnOiAnICsgdGhpcy5tZXNzYWdlICsgJ1xcbidcbiAgICAgICAgKyBmYXVsdHlPYmplY3Q7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFN3ZXZhRXJyb3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW9kdWxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9tb2R1bGUuanMnKTtcbnZhciBDb21wb3NpdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zaXRpb24uanMnKTtcbnZhciBEZWZpbml0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9kZWZpbml0aW9uRXJyb3IuanMnKTtcblxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgZHluYW1pY2FsbHkgbG9hZGluZyBjb21wb3NhYmxlcyBmcm9tIGEgd2ViIGFkZHJlc3MuXG4gKiBMb2FkZWQgY29tcG9zYWJsZXMgYXJlIHN0b3JlZCBpbiBhbiBpbnRlcm5hbCBkaWN0aW9uYXJ5LCBzbyB0aGV5IG9ubHkgbmVlZCB0byBiZSBkb3dubG9hZGVkIG9uY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZVBhdGg9JyddIC0gVGhlIGJhc2UgYWRkcmVzcyBmcm9tIHdoaWNoIHRvIGRvd25sb2FkIHRoZSBjb21wb3NhYmxlLiBHZXRzIHByZXBlbmRlZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXg9Lmpzb25dIC0gVGhlIHN1ZmZpeCB0aGF0IGdldHMgYXBwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cbiAqL1xuZnVuY3Rpb24gQ29tcG9zYWJsZUxvYWRlcihiYXNlUGF0aCwgc3VmZml4KSB7XG4gICAgLyoqXG4gICAgKiBUaGUgYmFzZSBhZGRyZXNzIGZyb20gd2hpY2ggdG8gZG93bmxvYWQgdGhlIGNvbXBvc2FibGUuIEdldHMgcHJlcGVuZGVkIHRvIHRoZSBjb21wb3NhYmxlIG5hbWUuXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlTG9hZGVyI2Jhc2VQYXRoXG4gICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICovXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoIHx8ICcnO1xuICAgIC8qKlxuICAgICogVGhlIHN1ZmZpeCB0aGF0IGdldHMgYXBwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cbiAgICAqIEBuYW1lIENvbXBvc2FibGVMb2FkZXIjc3VmZml4XG4gICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICovXG4gICAgdGhpcy5zdWZmaXggPSBzdWZmaXggfHwgJyc7XG4gICAgLyoqXG4gICAgKiBEaWN0aW9uYXJ5IG9mIHRoZSBjb21wb3NhYmxlIG5hbWVzIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb21wb3NhYmxlIG9iamVjdHMuXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlTG9hZGVyI2NvbXBvc2FibGVzXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENvbXBvc2FibGU+fVxuICAgICovXG4gICAgdGhpcy5jb21wb3NhYmxlcyA9IHt9O1xuICAgIC8qKlxuICAgICogRGljdGlvbmFyeSBvZiBhIHdhaXRpbmcgbGlzdCwgd2hlcmUgbG9hZGVkIGNvbXBvc2FibGVzIGNhbiBiZSBhc3NpZ25lZCB0byBleHRlcm5hbCBvYmplY3RzXG4gICAgKiBAbmFtZSBDb21wb3NhYmxlTG9hZGVyI3dhaXRpbmdMaXN0XG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdD59XG4gICAgKi9cbiAgICB0aGlzLndhaXRpbmdMaXN0ID0ge307XG59XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gLSBUaGUgbnVtYmVyIG9mIHN0b3JlZCBjb21wb3NhYmxlcy5cbiAqL1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb21wb3NhYmxlcykubGVuZ3RoO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlIHRvIHJldHVybi5cbiAqIEByZXR1cm5zIHtDb21wb3NhYmxlfSAtIFRoZSBjb21wb3NhYmxlIG9iamVjdC5cbiAqL1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb3NhYmxlc1tuYW1lXTtcbn1cbi8qKlxuICogQ29tcG9zYWJsZSBvYmplY3RzIGNhbiBiZSBkaXJlY3RseSBhZGRlZCwgd2l0aG91dCBoYXZpbmcgdG8gZG93bmxvYWQgdGhlbS5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgZS5nLiBmb3IgcmFwaWQgcHJvdG90eXBpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlIHRvIGFkZC5cbiAqIEBwYXJhbm0ge0NvbXBvc2FibGV9IGNvbXBvc2FibGUgLSBUaGUgY29tcG9zYWJsZSB0byBhZGQuXG4gKi9cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBjb21wb3NhYmxlKSB7XG4gICAgdGhpcy5jb21wb3NhYmxlc1tuYW1lXSA9IGNvbXBvc2FibGU7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvc2FibGUgaW50byBhIGZ1bGwgY29tcG9zYWJsZSBvYmplY3QuXG4gKiBTaW5jZSBjb21wb3NhYmxlcyBjYW4gaGF2ZSBjdXN0b20gZnVuY3Rpb25zIGRlZmluZWQsIGFuZCBKU09OIGRvZXMgbm90IHN1cHBvcnQgZnVuY3Rpb25zLCB3ZSBjYW5ub3QgdXNlIEpTT04ucGFyc2UuXG4gKiBJbnN0ZWFkIGZ1bmN0aW9ucyBhcmUgZW5jb2RlZCBhcyBzdHJpbmcgYXJyYXlzIGluIEpTT04gYW5kIHRoZW4gYXNzZW1ibGVkLlxuICoge0BsaW5rIFN3ZXZhU2NyaXB0fSBpcyB1c2VkIHRvIHNhbml0aXplIHRoZSBmdW5jdGlvbnMuXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtPYmplY3R9IGpzb24gLSBUaGUgSlNPTiBvYmplY3Qgb2YgdGhlIGNvbXBvc2FibGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIGV4ZWN1dGlvbiAoZm9yIGVycm9yIG1lc3NhZ2VzKS5cbiAqIEByZXR1cm5zIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gLSBDb21wb3NhYmxlIGluaXRhbGl6YXRpb24gb2JqZWN0LlxuICovXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5jb252ZXJ0VG9PYmplY3QgPSBmdW5jdGlvbiAoanNvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBqc29uO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbikge1xuICAgICAgICBpZiAoanNvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgIC8vZGVjb2RlIGJhc2U2NCBlbmNvZGVkIGJpbmFyaWVzXG4gICAgICAgICAgICBpZihrZXkgPT09ICdiaW5hcnknICYmICEoanNvbltrZXldIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAvKmNvbnNvbGUubG9nKGpzb24pXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29udGV4dClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhqc29uW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHR5cGVvZiBqc29uW2tleV0pKi9cbiAgICAgICAgICAgICAgICBsZXQgYmluYXJ5TGlzdCA9IGF0b2IoanNvbltrZXldKTtcbiAgICAgICAgICAgICAgIGpzb25ba2V5XSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeUxpc3Quc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RPRE86IGNvbnNpZGVyIHJlbW92aW5nIG1hcHBpbmcgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc291cmNlJyAmJiAoanNvbltrZXldICE9PSBudWxsICYmIHR5cGVvZiBqc29uW2tleV1bMF0gPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBTdHJpbmcoanNvbltrZXldWzBdKTtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHN0cmluZyBhcnJheSBzdGFydHMgd2l0aCAnZnVuY3Rpb24nIC0+IGFzc2VtYmxlIGZ1bmN0aW9uIGludG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignZnVuY3Rpb24nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHNhbml0aXplIHRoZSBzY3JpcHQgdG8gcHJldmVudCBtYWxpY2lvdXMgY29kZSBleGVjdXRpb25cblxuICAgICAgICAgICAgICAgICAgICBqc29uW2tleV0gPSBzd2V2YS5Td2V2YVNjcmlwdC5zYW5pdGl6ZShqc29uW2tleV0uam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvdWxkIG5vdCBzYW5pdGl6ZSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgd2hlbiBsb2FkaW5nIFwiJyArIGNvbnRleHQgKyAnXCI6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHNlbGYuY29udmVydEpzb25Ub0NvZGUoanNvbikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyovL1RPRE86IGNvbnNpZGVyIHJlbW92aW5nIG1hcHBpbmcgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc291cmNlJyAmJiB0eXBlb2YganNvbltrZXldWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBTdHJpbmcoanNvbltrZXldWzBdKTtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHN0cmluZyBhcnJheSBzdGFydHMgd2l0aCAnZnVuY3Rpb24nIC0+IGFzc2VtYmxlIGZ1bmN0aW9uIGludG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZignZnVuY3Rpb24nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHNhbml0aXplIHRoZSBzY3JpcHQgdG8gcHJldmVudCBtYWxpY2lvdXMgY29kZSBleGVjdXRpb25cblxuICAgICAgICAgICAgICAgICAgICBqc29uW2tleV0gPSBzd2V2YS5Td2V2YVNjcmlwdC5zYW5pdGl6ZShqc29uW2tleV0uam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvdWxkIG5vdCBzYW5pdGl6ZSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgd2hlbiBsb2FkaW5nIFwiJyArIGNvbnRleHQgKyAnXCI6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHNlbGYuY29udmVydEpzb25Ub0NvZGUoanNvbikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb25ba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBqc29uW2tleV0gPSB0aGlzLmNvbnZlcnRUb09iamVjdChqc29uW2tleV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vVE9ETzogcmVwbGFjZSBkZWZhdWx0IG1vZHVsZXNcbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmdldERlZmF1bHRNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwie1xcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwidHlwZVxcXCI6IFxcXCJtb2R1bGVcXFwiLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwibmFtZVxcXCI6IFxcXCJNb2R1bGVcXFwiLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiZGVzY3JpcHRpb25cXFwiOiBcXFwiTmV3IE1vZHVsZSB0ZW1wbGF0ZVxcXCIsXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJkYXRhSW5OYW1lc1xcXCI6IFtcXG5cIiArXG4gICAgICAgIFwiICAgICAgICBcXFwibnVtXFxcIlxcblwiICtcbiAgICAgICAgXCIgICAgICBdLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiZGF0YUluU2NoZW1hXFxcIjoge30sXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJkYXRhT3V0TmFtZXNcXFwiOiBbXFxuXCIgK1xuICAgICAgICBcIiAgICAgICAgXFxcIm91dFxcXCJcXG5cIiArXG4gICAgICAgIFwiICAgICAgXSxcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImRhdGFPdXRTY2hlbWFcXFwiOiB7fSxcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImlucHV0TmFtZXNcXFwiOiBbXSxcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImlucHV0U2NoZW1hXFxcIjoge30sXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJzb3VyY2VcXFwiOiBbXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJleHBvcnQgdmFyIGE6aTMyID0gNDI7XFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImV4cG9ydCBmdW5jdGlvbiBydW4obnVtOiBpMzIpOiBpMzIge1xcXCIsXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJpZiAoYSA+IG51bSl7XFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcInJldHVybiBifVxcXCIsXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJyZXR1cm4gbnVtXFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcIn1cXFwiXFxuXCIgK1xuICAgICAgICBcIiAgICAgIF1cXG5cIiArXG4gICAgICAgIFwifVwiO1xufVxuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIntcXG4gICAgdHlwZTogXFwnY29tcG9zaXRpb25cXCcsXFxuICAgIG5hbWU6IFxcJ2NvbXBvc2l0aW9uMVxcJyxcXG4gICAgZGF0YUluTmFtZXM6IFtdLFxcbiAgICBkYXRhSW5TY2hlbWE6IHt9LFxcbiAgICBkYXRhT3V0TmFtZXM6W1xcJ3Jlc3VsdFxcJ10sXFxuICAgIGRhdGFPdXRTY2hlbWE6IHt9LFxcbiAgICBpbnB1dE5hbWVzOiBbXSxcXG4gICAgaW5wdXRTY2hlbWE6IHt9LFxcbiAgICBtYXBEYXRhSW46IGZ1bmN0aW9uIChkYXRhLCBjb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZXMsIGxpYnMpIHtcXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGNvbXBvc2FibGVOYW1lKSkge1xcbiAgICAgICAgICAgIHJldHVybiBsaWJzLmdldChkYXRhLCBjb21wb3NhYmxlTmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSxcXG4gICAgbWFwRGF0YU91dDogZnVuY3Rpb24gKG91dHB1dCwgbGlicykge1xcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcXG4gICAgfSxcXG4gICAgbWFwSW5wdXQ6IGZ1bmN0aW9uIChpbnB1dCwgbW9kdWxlTmFtZSwgbW9kdWxlcywgbGlicykge1xcbiAgICAgICAgaWYgKGlucHV0Lmhhc093blByb3BlcnR5KG1vZHVsZU5hbWUpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGxpYnMuZ2V0KGlucHV0LCBtb2R1bGVOYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxufVwiO1xufVxuXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5jb252ZXJ0Q29kZVRvSnNvbiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICBcbiAgICB2YXIgcmVzdWx0ID0gJydcbiAgICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoL1xccj9cXG4vKTtcbiAgIFxuICAgIHZhciByZWdleEZ1bmN0aW9uID0gbmV3IFJlZ0V4cCgvXlxccyooXFx3KStcXHMqOlxccypmdW5jdGlvbi8pO1xuICAgIHZhciByZWdleFByb3BlcnR5ID0gbmV3IFJlZ0V4cCgvXlxccyooXFx3KStcXHMqLyk7XG5cbiAgICB2YXIgZnVuY0xpbmVzID0gZmFsc2U7XG4gICAgdmFyIGZ1bmNMaW5lc0ZpcnN0ID0gZmFsc2U7XG4gICAgdmFyIGJyYWNlQ291bnQgPSAwO1xuICAgIHZhciBmdW5jTGluZXNKdXN0RmluaXNoZWQ9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7ICAgICAgICBcbiAgICAgICAgaWYgKCFmdW5jTGluZXMpIHtcbiAgICAgICAgICAgIGlmIChmdW5jTGluZXNKdXN0RmluaXNoZWQgJiYgbGluZS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGZ1bmNMaW5lc0p1c3RGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLFxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVnZXhGdW5jdGlvbi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpbmUuaW5kZXhPZignZnVuY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lUGFydCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4UHJvcGVydHkuZXhlYyhsaW5lUGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVBhcnQgPSBsaW5lUGFydC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnXCInICsgbGluZVBhcnQuc2xpY2UobWF0Y2guaW5kZXgsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSArICdcIicgKyBsaW5lUGFydC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVQYXJ0ID0gbGluZVBhcnQucmVwbGFjZSgvJy9nLCAnXCInKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lUGFydDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnW1wiJyArIGxpbmUuc2xpY2UoaW5kZXgpICsgJ1wiLFxcbic7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzRmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhQcm9wZXJ0eS5leGVjKGxpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdcIicgKyBsaW5lLnNsaWNlKG1hdGNoLmluZGV4LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkgKyAnXCInICsgbGluZS5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLycvZywgJ1wiJyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lICsgJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmNMaW5lcykge1xuICAgICAgICAgICAgdmFyIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaW5TaW5nbGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbGluZVtrXTtcblxuICAgICAgICAgICAgICAgIGlmIChjID09ICdcIicgJiYgIWluU2luZ2xlUXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBrKSArICdcXFxcJyArIGxpbmUuc2xpY2Uoayk7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSAnXFwnJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5RdW90ZXMgPSAhaW5TaW5nbGVRdW90ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gJ3snICYmICFpblF1b3RlcyAmJiAhaW5TaW5nbGVRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09ICd9JyAmJiAhaW5RdW90ZXMgJiYgIWluU2luZ2xlUXVvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY0xpbmVzRmlyc3QpIHtcbiAgICAgICAgICAgICAgICBmdW5jTGluZXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgnXFxcXG4nLCAnXFxcXFxcXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNlQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwICYmIGxpbmUuaW5kZXhPZignLCcpID49IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1wiJyArIGxpbmUgKyAnXCInICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1wiJyArIGxpbmUgKyAnXCInICsgJywnICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJhY2VDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11cXG4nO1xuICAgICAgICAgICAgICAgIGZ1bmNMaW5lc0p1c3RGaW5pc2hlZD10cnVlO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmluZGV4T2YoJ3snKSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0ICsgJ30nO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5jb252ZXJ0SnNvblRvQ29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmdW5jdGlvbiBnZXRTcGFjZXMoc3BhY2VzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkob2JqZWN0LCBsZXZlbCwgc3BhY2VzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICB2YXIgaWRlbnQgPSBnZXRTcGFjZXMobGV2ZWwgKiBzcGFjZXMpO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIGtleVN0cmluZyA9IChrZXkuaW5kZXhPZignICcpID49IDApID8gKCdcXCcnICsga2V5ICsgJ1xcJycpIDoga2V5O1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlkZW50ICsga2V5U3RyaW5nICsgJzogJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXCcnICsgb2JqZWN0W2tleV0gKyAnXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5Q29udGVudCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Rba2V5XS5sZW5ndGggPiAwICYmIHR5cGVvZiBvYmplY3Rba2V5XVswXSA9PT0gJ3N0cmluZycgJiYgb2JqZWN0W2tleV1bMF0udHJpbSgpLmluZGV4T2YoJ2Z1bmN0aW9uJykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9kZWNvZGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbExldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2JqZWN0W2tleV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IG9iamVjdFtrZXldW2tdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCd9JykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbExldmVsLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbExldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9IChrID09IDAgPyAnJyA6IGlkZW50KSArIGdldFNwYWNlcyhzcGFjZXMgKiBpbnRlcm5hbExldmVsKSArIGxpbmUgKyAoayA+PSBvYmplY3Rba2V5XS5sZW5ndGggLSAxID8gJycgOiAnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCAmJiBsaW5lLmluZGV4T2YoJ3snKSA9PSBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxMZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhcnJheUNvbnRlbnQgKyBpZGVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2JqZWN0W2tleV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG9iamVjdFtrZXldW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSBpZGVudCArIGdldFNwYWNlcyhzcGFjZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9ICdcXCcnICsgZWxlbWVudCArICdcXCcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9ICd7XFxuJyArIHN0cmluZ2lmeShvYmplY3Rba2V5XSwgbGV2ZWwgKyAxLCBzcGFjZXMpICsgaWRlbnQgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbnRlbnQgKz0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBvYmplY3Rba2V5XS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSAnLCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnW1xcbicgKyBhcnJheUNvbnRlbnQgKyBpZGVudCArICddJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICd7XFxuJyArIHN0cmluZ2lmeShvYmplY3Rba2V5XSwgbGV2ZWwgKyAxLCBzcGFjZXMpICsgaWRlbnQgKyAnfSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcJycgKyBvYmplY3Rba2V5XSArICdcXCcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuICd7XFxuJytzdHJpbmdpZnkob2JqLCAxLCA0KSsnfSc7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLCB0aGF0IGFzc2lnbnMgdGhlIGNvbXBvc2FibGVzIHRvIHRoZSBpbnRlcm5hbCBkaWN0aW9uYXJ5IGFuZCBvcHRpb25hbGx5IHRvIGV4dGVybmFsIG9iamVjdHMgd2l0aCBhIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGlyZWN0bHkgZmlsbCBhbm90aGVyIGV4dGVybmFsIGRpY3Rpb25hcnkgb2YgY29tcG9zYWJsZXMsIGxpa2UgdGhlIHtAbGluayBDb21wb3NpdGlvbn0gY29tcG9zYWJsZSBkaWN0aW9uYXJ5LlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZS5cbiAqIEBwYXJhbSB7Q29tcG9zYWJsZX0gY29tcG9zYWJsZSAtIFRoZSBjb21wb3NhYmxlIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXNzaWduVG9PYmplY3RdIC0gVGhlIGV4dGVybmFsIG9iamVjdCB0byB3aWNoIHRoZSBjb21wb3NhYmxlIHNob3VsZCBiZSBhc3NpZ25lZCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gVGhlIHBvcnBlcnR5IG9mIHRoZSBleHRlcm5hbCBvYmplY3QgdG8gd2ljaCB0aGUgY29tcG9zYWJsZSBzaG91bGQgYmUgYXNzaWduZWQgdG8uXG4gKi9cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmFzc2lnbkxvYWRlZENvbXBvc2FibGVzID0gZnVuY3Rpb24gKG5hbWUsIGNvbXBvc2FibGUsIGFzc2lnblRvT2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHRoaXMuY29tcG9zYWJsZXNbbmFtZV0gPSBjb21wb3NhYmxlO1xuXG4gICAgLy9jaGVjayBpZiB0aGUgb3B0aW9uYWwgYXNzaWduVG9PYmplY3QgaXMgZ2l2ZW5cbiAgICBpZiAodHlwZW9mIGFzc2lnblRvT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBhc3NpZ25Ub09iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFzc2lnblRvT2JqZWN0W3Byb3BlcnR5XSA9IGNvbXBvc2FibGU7XG4gICAgfVxuXG4gICAgLy9kZWFsIHdpdGggd2FpdGluZ2xpc3Q6IGFzIHRoZSBjYWxsZXIgaGFzIHRvIHdhaXQgZm9yICd0aGVuJyB3ZSwgY2FuIHNldCB0aGUgcmVxdWlyZWQgdmFsdWVzIG5vdyB3aXRoIHNvbWUgZGVsYXlcbiAgICBpZiAodGhpcy53YWl0aW5nTGlzdC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAvL2ZvciBlYWNoIG9iamVjdCwgdGhhdCB3YWl0cyBmb3IgdGhlIGNvbXBvc2FibGUgdG8gYmUgYXNzaWduZWQgdG9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndhaXRpbmdMaXN0W25hbWVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXNzaWduVG8gPSB0aGlzLndhaXRpbmdMaXN0W25hbWVdW2ldLmFzc2lnblRvO1xuICAgICAgICAgICAgdmFyIHByb3AgPSB0aGlzLndhaXRpbmdMaXN0W25hbWVdW2ldLnByb3A7XG5cbiAgICAgICAgICAgIGFzc2lnblRvW3Byb3BdID0gY29tcG9zYWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvL3JlbW92ZSBlbGVtZW50IGZyb20gdGhlIHdhaXRpbmdMaXN0XG4gICAgICAgIGRlbGV0ZSB0aGlzLndhaXRpbmdMaXN0W25hbWVdO1xuICAgIH1cbn1cbi8qKlxuICogTG9hZHMgYSBjb21wb3NhYmxlIGJ5IHRoZSBnaXZlbiBuYW1lIGZyb20gYSB3ZWIgcmVzb3VyY2UuXG4gKiBJZiBubyBiYXNlUGF0aCB3YXMgZ2l2ZW4gaW4gdGhlIGNvbnN0cnVjdG9yLCB1c2UgdGhlIGZ1bGwgd2ViIGFkZHJlc3MgYXMgdGhlIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlLlxuICogQHBhcmFtIHtPYmplY3R9IFthc3NpZ25Ub09iamVjdF0gLSBUaGUgZXh0ZXJuYWwgb2JqZWN0IHRvIHdpY2ggdGhlIGNvbXBvc2FibGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBUaGUgcG9ycGVydHkgb2YgdGhlIGV4dGVybmFsIG9iamVjdCB0byB3aWNoIHRoZSBjb21wb3NhYmxlIHNob3VsZCBiZSBhc3NpZ25lZCB0by5cbiAqIEByZXR1cm5zIHtQcm9taXNlPENvbXBvc2FibGU+fSAtIFRoZSBsb2FkZWQgY29tcG9zYWJsZSBvYmplY3QuXG4gKi9cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy9yZXR1cm4gYSBwcm9taXNlLCBzaW5jZSBsb2FkaW5nIGlzIGFuc3luY2hyb251b3VzXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy9jaGVjayBpZiB0aGUgbmFtZSB3YXMgYWxyZWFkeSBsb2FkZWQgb3IgaXMgY3VycmVudGx5IGJlaW5nIGxvYWRlZFxuICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgLy93ZSBoYXZlIG9ubHkgb3VyIHBsYWNlaG9sZGVyLCBubyByZWFsIHZhbHVlIHlldFxuICAgICAgICAgICAgLy90aGlzIG1lYW5zIHRoZSBjb21wb3NhYmxlIGlzIGN1cnJlbnRseSByZXF1ZXN0ZWQsIGJ1dCBub3QgbG9hZGVkXG4gICAgICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlc1tuYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vcHV0IGluIHdhaXRpbmdsaXN0LCB3aGljaCBpcyBjaGVja2VkIGFmdGVyIGVhY2ggbG9hZFxuICAgICAgICAgICAgICAgIC8vYnV0IG9ubHksIGlmIGl0IG5lZWRzIHRvIGJlIGFzc2lnbmVkIGV4dGVybmFsbHlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFzc2lnblRvT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBhc3NpZ25Ub09iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi53YWl0aW5nTGlzdC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi53YWl0aW5nTGlzdFtuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud2FpdGluZ0xpc3RbbmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25UbzogYXNzaWduVG9PYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9sb2FkIGZyb20gZGljdGlvbmFyeVxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5jb21wb3NhYmxlc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFzc2lnblRvT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBhc3NpZ25Ub09iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25Ub09iamVjdFtwcm9wZXJ0eV0gPSBzZWxmLmNvbXBvc2FibGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHNlbGYuY29tcG9zYWJsZXNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgICAvL25vdCBhbHJlYWR5IGluIGRpY3Rpb25hcnksIG5lZWRzIHRvIGJlIGxvYWRlZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vc2V0IGtleSBhbmQgcHJldmVudCB1bm5lY2Vzc2FyeSBsb2Fkcywgd2hpbGUgbG9hZGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzXG4gICAgICAgICAgICBzZWxmLmNvbXBvc2FibGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc3RydWN0IHVybFxuICAgICAgICAgICAgdmFyIHVybCA9IHNlbGYuYmFzZVBhdGggKyBuYW1lICsgc2VsZi5zdWZmaXg7XG5cbiAgICAgICAgICAgIHN3ZXZhLmF4aW9zLmdldCh1cmwpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIHJlc3BvbnNlIEpTT04gdG8gYW4gYWN0dWFsIGNvbXBvc2FibGVcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9zYWJsZSA9IHNlbGYuY29udmVydFRvT2JqZWN0KHJlc3BvbnNlLmRhdGEsIHVybCk7XG4gICAgICAgICAgICAgICAgLy9jbG9zdWUgZnVuY3Rpb24sIGR1bW15XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMoY29tcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmMoY29tcG9zYWJsZSkpO1xuXG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBjb21wb3NhYmxlIGp1c3QgZXh0ZW5kcyBleGlzdGluZyBvbmVcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zYWJsZS5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlQ29tcG9zYWJsZU5hbWUgPSBjb21wb3NhYmxlLmV4dGVuZHM7XG4gICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGEgY2xvc3VyZSB0byBsb2FkIHRoZSBiYXNlIGNvbXBvc2FibGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmMyID0gZnVuY3Rpb24gKGJhc2VDb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZChiYXNlQ29tcG9zYWJsZU5hbWUpLnRoZW4oZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9leHRlbmQgbG9hZGVkIGNvbXBvc2FibGUgd2l0aCBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzKGNvbXAuZXh0ZW5kV2l0aChjb21wb3NhYmxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vYWRqdXN0IGludGVybmFsIHByb21pc2UgdG8gbG9hZCB0aGUgYmFzZSBjb21wb3NhYmxlIGZpcnN0LCBiZWZvcmUgZXh0ZW5kaW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jMihiYXNlQ29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGUpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnRlcm5hbFByb21pc2UudGhlbihmdW5jdGlvbiAoY29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAvL2xvZyBhcyBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2xvYWRlZCAnICsgY29tcG9zYWJsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgbG9hZGVkIGNvbXBvc2FibGUgaXMgYSBtb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2FibGUudHlwZSA9PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdHJ1Y3QgTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NhYmxlID0gbmV3IE1vZHVsZShjb21wb3NhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hc3NpZ25Mb2FkZWRDb21wb3NhYmxlcyhuYW1lLCBjb21wb3NhYmxlLCBhc3NpZ25Ub09iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvbXBvc2FibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBsb2FkZWQgY29tcG9zYWJsZSBpcyBhIGNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdHJ1Y3QgQ29tcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2FibGUgPSBuZXcgQ29tcG9zaXRpb24oY29tcG9zYWJsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXNzaWduTG9hZGVkQ29tcG9zYWJsZXMobmFtZSwgY29tcG9zYWJsZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9hZCBjb21wb3NhYmxlcyByZXF1aXJlZCBmb3IgdGhlIGNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NhYmxlLmxvYWRDb21wb3NhYmxlcygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29tcG9zYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZWplY3Qoc2VsZi5iYXNlUGF0aCArIG5hbWUgKyBzZWxmLnN1ZmZpeCk7IC8vY291bGQgbm90IGxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgZGljdGlvbmFyaWVzLlxuICovXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbXBvc2FibGVzID0ge307XG4gICAgdGhpcy53YWl0aW5nTGlzdCA9IHt9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NhYmxlTG9hZGVyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcbnZhciBNb2R1bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcycpO1xudmFyIENvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcycpO1xuXG4vL01BXG5sZXQgcG90ZW50aWFsT2ZmbG9hZGluZ1RhcmdldCA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL3BvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQuanNcIik7XG5sZXQgZGF0YVByb2Nlc3NpbmdEZXZpY2UgPSByZXF1aXJlKFwiLi4vbmV0d29yay9kYXRhUHJvY2Vzc2luZ0RldmljZS5qc1wiKTtcblxuLy8gKioqKiBQMlAgbmV0d29yayAqKioqXG5sZXQgcGVlciA9IG5ldyBQZWVyKCcnLHtcbiAgICBob3N0OlwibWlsa2ktcHN5LmRiaXMucnd0aC1hYWNoZW4uZGVcIixcbiAgICBwb3J0OjQ0MyxcbiAgICBwYXRoOlwiL2Rpc2NvdmVyeU5ldHdvcmtcIlxufSk7XG5jb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgQ29ubmVjdGlvbiB0byB0aGUgU1dlVkEgUDJQIG5ldHdvcmsgc3VjY2Vzc2Z1bCEnKVxuLy9FdmVudC1iYXNlZCBzY3JpcHRcbi8vKysrKysrKysrIERFVklDRSBpcyBQT1QgKysrKysrKysrXG5wZWVyLm9uKCdjb25uZWN0aW9uJywgKGNvbm5lY3Rpb24pID0+IHtcbiAgICBjb25uZWN0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGRhdGEgPT09ICdwZWVyJyl7XG4gICAgICAgICAgICBsZXQgbXNnID0gJ29mZmxvYWRpbmdPdXRwdXQkIE9mZmxvYWRpbmcgcmVxdWVzdCBmcm9tIGRldmljZSA9ICcgKyBjb25uZWN0aW9uLnBlZXI7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgICAgICAgICAgcG90ZW50aWFsT2ZmbG9hZGluZ1RhcmdldCgpO1xuICAgICAgICB9XG4gICAgfSk7IH0pO1xuLy8rKysrKysrKysgREVWSUNFIGlzIERQRCArKysrKysrKytcblxuZnVuY3Rpb24gYnJvYWRjYXN0VG9EaXNjb3ZlcnlOZXR3b3JrKGludGVybWVkaWF0ZVBpcGVsaW5lQW5kUmVzdWx0cykge1xuICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBicm9hZGNhc3RpbmcgdG8gZGlzY292ZXJ5IG5ldHdvcmsuLi4uJyk7XG4gICAgZGF0YVByb2Nlc3NpbmdEZXZpY2UoaW50ZXJtZWRpYXRlUGlwZWxpbmVBbmRSZXN1bHRzKTtcbiAgICBwZWVyLmxpc3RBbGxQZWVycygocGVlcklkcykgPT4ge1xuICAgICAgICBwZWVySWRzXG4gICAgICAgICAgICAuZmlsdGVyKChwZWVySWQpID0+IHBlZXJJZCAhPT0gcGVlci5pZCkgLy8gRmlsdGVyIG91dCBkZXZpY2UgSURcbiAgICAgICAgICAgIC5mb3JFYWNoKChwZWVySWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gcGVlci5jb25uZWN0KHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgY29ubi5vbignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgRGlzY292ZXJlZCBQZWVyID0gJyArIHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm4uc2VuZCgncGVlcicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbm4ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkaXNjb3ZlcmluZyBQZWVyIDogJyArIHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8vICoqKiogRU5EIFAyUCBuZXR3b3JrICoqKipcblxuLy8gKioqKioqKioqKioqKiBHZXR0ZXJzIGFuZCBTZXR0ZXJzICoqKioqKioqKioqKioqKipcblxuLy9kZWZhdWx0IHZhbHVlc1xubGV0IG9kTGlzdCA9IFs1MCw1MCw1MF07XG5sZXQgb3JMaXN0ID0gWzUwLDUwLGZhbHNlXTtcbmxldCBpbnRlcm1lZGlhdGVQaXBlbGluZSA9IHt9O1xubGV0IGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0cyA9e307XG5FeGVjdXRpb25NYW5hZ2VyLnNldE9ETGlzdCA9IGZ1bmN0aW9uIChvZExpc3RJbnB1dCkge1xuICAgIG9kTGlzdD1vZExpc3RJbnB1dDtcbn1cbkV4ZWN1dGlvbk1hbmFnZXIuZ2V0T0RMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvZExpc3Q7XG59XG5cbkV4ZWN1dGlvbk1hbmFnZXIuc2V0T1JMaXN0ID0gZnVuY3Rpb24gKG9yTGlzdElucHV0KSB7XG4gICAgb3JMaXN0PW9yTGlzdElucHV0O1xufVxuRXhlY3V0aW9uTWFuYWdlci5nZXRPUkxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9yTGlzdDtcbn1cblxuRXhlY3V0aW9uTWFuYWdlci5zZXRJbml0aWFsSW50ZXJtZWRpYXRlUGlwZWxpbmUgPSBmdW5jdGlvbiAoaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dCkge1xuICAgIC8vcHJlcGFyZSB0aGUgaW50ZXJtZWRpYXRlIHBpcGVsaW5lIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgICBmb3IgKGxldCBrZXkgaW4gaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlcykge1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlc1trZXldLm1hbmFnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJtZWRpYXRlUGlwZWxpbmUgPSBpbnRlcm1lZGlhdGVQaXBlbGluZUlucHV0O1xuXG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBpbnRlcm1lZGlhdGUgcGlwZWxpbmUgPScsaW50ZXJtZWRpYXRlUGlwZWxpbmUpO1xuXG59XG5cbkV4ZWN1dGlvbk1hbmFnZXIuZ2V0TGlzdE9mUGVlcnMgPSBmdW5jdGlvbiBsaXN0T2ZQZWVycygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcGVlci5saXN0QWxsUGVlcnMoKHBlZXJJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBwZWVySWRzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocGVlcklkKSA9PiBwZWVySWQgIT09IHBlZXIuaWQpXG4gICAgICAgICAgICAgICAgLm1hcCgocGVlcklkKSA9PiBwZWVySWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUobGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8qKioqKiogZW5kIFdlYiBHRVRURVJTIGFuZCBTRVRURVJTICoqKioqKioqKioqXG5cbi8qKlxuICogQW4gRXhlY3V0aW9uTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgdGhlIGV4ZWN1dGlvbiBwcm9jZXNzIG9mIGNvbXBvc2l0aW9ucyBhbmQgbW9kdWxlcy5cbiAqIEl0IGhhcyB0d28gcGhhc2VzOiBBIHNldHVwIHBoYXNlLCB3ZXJlIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgYW5kIGFuIGV4ZWN1dGlvbiBwaGFzZSxcbiAqIHRoYXQgZXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIGJ5IHByb3ZpZGluZyBkYXRhIGFuZCBpbnB1dCBvYmplY3RzIHRvIHRoZW0uXG4gKlxuICogVGhlIHNldHVwIG5lZWRzIHRvIGJlIGRvbmUgb25seSBvbmNlLCB3aGlsZSB0aGUgZXhlY3V0aW9uIGNhbiBiZSByZXBlYXRlZCBvbiBkaWZmZXJlbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIE5hbWUgb2YgdGhlIGV4ZWN1dGlvbiBtYW5hZ2VyLlxuICovXG5mdW5jdGlvbiBFeGVjdXRpb25NYW5hZ2VyKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0V4ZWN1dGlvbk1hbmFnZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgaG93IG1hbnkgbW9kdWxlcyBhcmUgdXNlZCBjdXJyZW50bHkuXG4gICAgICogQG5hbWUgRXhlY3V0aW9uTWFuYWdlciNtb2R1bGVzVG90YWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlc1RvdGFsID0gMTtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgaG93IG1hbnkgbW9kdWxlcyBoYXZlIGZpbmlzaGVkIGV4ZWN1dGlvbi5cbiAgICAgKiBAbmFtZSBFeGVjdXRpb25NYW5hZ2VyI21vZHVsZXNEb25lXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZXNEb25lID0gMDtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byB0cmFjayBwcm9ncmVzcywgZ2V0cyBjYWxsZWQgZXZlcnl0aW1lIGEgbW9kdWxlIGZpbmlzaGVzLlxuICAgICAqIEBuYW1lIEV4ZWN1dGlvbk1hbmFnZXIjcHJvZ3Jlc3NDYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gbnVsbDtcblxuICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyYWNrIHByb2dyZXNzLlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byB1cGRhdGUgdmlzdWFsaXphdGlvbiBvbiBNUVRUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgcmVleGVjdXRpbmcgdGhlIHN3ZXZhLWdyYXBoLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIHZpc3VhbGl6YXRpb24uXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTVFUVERhdGFSZWNpZXZlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gY2FsbGJhY2s7XG59O1xuXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kRGF0YVRvVmlzdWFsaXphdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAodGhpcy51cGRhdGVWaXN1YWxpemF0aW9uTm90aWZpZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uTm90aWZpZXIocmVzdWx0KTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIGFueSBhc3luY2hyb25vdXMgbm9kZSByZS1leGVjdXRlcyBwYXJ0cyBvZiB0aGUgY29tcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZFJlZXhlY3V0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1vZHVsZV9uYW1lKSB7XG4gICAgaWYgKHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWV4ZWN1dGlvbkxpc3RlbmVyc1trZXldLm1vZHVsZV9uYW1lID09PSBtb2R1bGVfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWV4ZWN1dGlvbkxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBtb2R1bGVfbmFtZVxuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAobW9kdWxlX25hbWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBtb2R1bGVfbmFtZTogbW9kdWxlX25hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0ubW9kdWxlX25hbWUgPT09IG1vZHVsZS5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMubW9kdWxlX25hbWUpIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0uY2FsbGJhY2sobW9kdWxlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFsbCByZXF1aXJlZCBjb21wb3NhYmxlcywgbG9hZHMgZGVwZW5kZW5jaWVzLCB2YWxpZGF0ZXMuXG4gKlxuICogKElGKSBQQVJTRSBwaXBlbGluZSB0byBKUyBvYmplY3Qgc2VsZiBnbG9hYmwgdG8gdGhlIGV4ZWN1dGlvbk1hbmFnZXIgIVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xDb21wb3NhYmxlPn0gZXhlY3V0aW9uQXJyYXkgLSBBcnJheSBvZiBjb21wb3NhYmxlcyB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1B1cmVPYmplY3Q9ZmFsc2VdIC0gU2V0IHRoaXMgdG8gdHJ1ZSwgaWYgcGFzc2luZyBwdXJlIEphdmFTY3JpcHQgT2JqZWN0cyBhbmQgbm90IGp1c3QgSlNPTi5cbiAqL1xuLy9HbG9iYWwgdmFyaWFibGUgbmFtZXNcblxuXG5cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKGV4ZWN1dGlvbkFycmF5LCBpc1B1cmVPYmplY3QpIHtcblxuICAgIC8vaW50ZXJuYWwgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNvdW50IGhvdyBtYW55IG1vZHVsZXMgYXJlIGN1cnJlbnRseSB1c2VkXG4gICAgZnVuY3Rpb24gY291bnRNb2R1bGVzKGNvbXBvc2FibGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb3NhYmxlLmNvbXBvc2FibGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9zYWJsZS5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NhYmxlLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhrZXksIGNvbXBvc2FibGUuY29tcG9zYWJsZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGNvdW50TW9kdWxlcyhjb21wb3NhYmxlLmNvbXBvc2FibGVzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1VQREFURUQgQ29tcG9zYWJsZSA9JywgY29tcG9zYWJsZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtYmVyIG9mIHNldCB1cCBub2RlcyBpbiBDb21wb3NhYmxlOiBcIiArIGNvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZWVkc0xvYWRpbmcgPSBbXTtcbiAgICB0aGlzLmNvbXBvc2FibGVzID0ge307XG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLndhbnRzVG9FeGVjdXRlID0gZmFsc2U7XG4gICAgLy9pZiBpdCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgb25lXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4ZWN1dGlvbkFycmF5KSkge1xuICAgICAgICBleGVjdXRpb25BcnJheSA9IFtleGVjdXRpb25BcnJheV07XG4gICAgfVxuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIC8vZm9yIGVhY2ggY29tcG9zYWJsZSwgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tcG9zYWJsZSA9IGV4ZWN1dGlvbkFycmF5W2ldO1xuICAgICAgICAvL2lmIGNvbXBvc2FibGUgaXMgcHJvdmlkZWQgYXMgc3RyaW5nLCBpLmUuIG5hbWUgaXQgbmVlZHMgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9zYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goY29tcG9zYWJsZSk7XG4gICAgICAgICAgICBuZWVkc0xvYWRpbmcucHVzaChzd2V2YS5Db21wb3NhYmxlTG9hZGVyLmxvYWQoY29tcG9zYWJsZSwgdGhpcy5jb21wb3NhYmxlcywgY29tcG9zYWJsZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vb3RoZXJ3aXNlIGEgY29tcG9zYWJsZSBvYmplY3QgaXMgZ2l2ZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzUHVyZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWlzUHVyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2FibGUgPSBzd2V2YS5Db21wb3NhYmxlTG9hZGVyLmNvbnZlcnRUb09iamVjdChjb21wb3NhYmxlLCAnSlNPTicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcG9zYWJsZS50eXBlID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zYWJsZXNbY29tcG9zYWJsZS5uYW1lXSA9IG5ldyBNb2R1bGUoY29tcG9zYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0gPSBuZXcgQ29tcG9zaXRpb24oY29tcG9zYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xuICAgICAgICAgICAgICAgIC8vY29tcG9zYWJsZXMgb2YgYSBjb21wb3NpdGlvbiBuZWVkIGFsc28gdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgbmVlZHNMb2FkaW5nLnB1c2godGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlLm5hbWVdLmxvYWRDb21wb3NhYmxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzLnB1c2goY29tcG9zYWJsZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL25vdyB3YWl0IGZvciBldmVyeXRoaW5nIHRvIGxvYWRcbiAgICBQcm9taXNlLmFsbChuZWVkc0xvYWRpbmcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdSQVcgUGlwbGluZSAvIFVzZXIgSW5wdXQ9JywgY29tcG9zYWJsZSk7XG4gICAgICAgIC8vbGV0J3MgY2hlY2ssIGhvdyBtYW55IG1vZHVsZXMgYXJlIHVzZWQgaW4gdG90YWwgdG8gaGF2ZSBhIHJvdWdoIGVzdGltYXRlIGZvciBwcm9ncmVzcyB0cmFja2luZ1xuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2R1bGVDb3VudCArPSBjb3VudE1vZHVsZXMoc3dldmEuQ29tcG9zYWJsZUxvYWRlci5nZXQobmFtZXNbaV0pKTtcblxuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9kdWxlc1RvdGFsID0gbW9kdWxlQ291bnQ7XG4gICAgICAgIHNlbGYubW9kdWxlc0RvbmUgPSAwO1xuXG4gICAgICAgIC8vY29tcG9zYWJsZXMgc2hvdWxkIG5vdyBjb250YWluIGV2ZXJ5dGhpbmdcbiAgICAgICAgc2VsZi5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FsbCBsb2FkZWQnKTtcbiAgICAgICAgLy9pZiB3ZSB3YW50IHRvIGV4ZWN1dGUsIGJlZm9yZSBzZXR1cCBpcyByZWFkeSwgaXQgaXMgZGVsYXllZCBhbmQgY29udGludWVkIGZyb20gaGVyZVxuICAgICAgICBpZiAoc2VsZi53YW50c1RvRXhlY3V0ZSkge1xuICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5leGVjdXRlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFsbCBtb2R1bGVzOiAnICsgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZSwgZXJyb3IpKTtcbiAgICAgICAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCBwcm9ncmVzcyBzdGF0ZSBhbmQgY2FsbHMgdGhlIG9wdGlvbmFsbHkgcmVnaXN0ZXJlZCBwcm9ncmVzc0NhbGxiYWNrLlxuICogSXQgY291bnRzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBtb2R1bGVzIHRoYXQgaGF2ZSBmaW5pc2hlZCBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIC0gVGhlIGFsaWFzIG9mIHRoZSBtb2R1bGUsIHVuZGVyIHdoaWNoIGl0IGlzIGtub3duIHRvIHRoZSBwYXJlbnQgY29tcG9zaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IHVuZGVyIHdoaWNoIHRoZSBtb2R1bGUgaXMgZXhlY3V0ZWQgKGl0cyBwYXJlbnRzKS5cbiAqL1xuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvZ3Jlc3NVcGRhdGUgPSBmdW5jdGlvbiAoYWxpYXMsIG5hbWUsIGNvbnRleHQscmVzdWx0KSB7XG4gICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEZpbmlzaGVkIGV4ZWN1dGluZyAnLGFsaWFzKTtcbiAgICBpZiAocmVzdWx0PT09J29mZmxvYWRpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT0ZGTE9BRElORyBmbGFnIGNhdGNoZWQgaW4gRXhlYyBtYW5hZ2VyICEnKTtcblxuICAgICAgICAgICAgLy9wcmVwYXJlIHBpcGVsaW5lIHRvIGJlIGNvbXBhdGlibGUgZm9yIG9mZmxvYWRpbmdcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlc1trZXldLm1hbmFnZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2FibGVzTm9kZSA9IGludGVybWVkaWF0ZVBpcGVsaW5lLmNvbXBvc2FibGVzW2tleV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBjb21wb3NhYmxlc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2FibGVzTm9kZVtwcm9wXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvc2FibGVzTm9kZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlUGlwZWxpbmUgPUpTT04uc3RyaW5naWZ5KGludGVybWVkaWF0ZVBpcGVsaW5lKTtcblxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzPSBKU09OLnN0cmluZ2lmeShpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHMpO1xuICAgICAgICAgICAgbGV0IG1lcmdlZFBpcCA9e2ludGVybWVkaWF0ZVBpcGVsaW5lOmludGVybWVkaWF0ZVBpcGVsaW5lLGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0czppbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHN9O1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvZmZsb2FkaW5nIHRoZSBtZXJnZWQgUGlwZWxpbmUuLi4nKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobWVyZ2VkUGlwKTtcblxuICAgICAgICAgICAgYnJvYWRjYXN0VG9EaXNjb3ZlcnlOZXR3b3JrKG1lcmdlZFBpcCk7IC8vT2ZmbG9hZCBtZXJnZWQgUGlwZWxpbmUgdG8gYmVzdCBQT1RcblxuXG4gICAgfVxuXG4gICAgLy9kZXRlY3RzIGFuIG9mZmxvYWRlZCBwaXBlbGluZSA6KVxuICAgIGlmIChPYmplY3Qua2V5cyhpbnRlcm1lZGlhdGVQaXBlbGluZSkubGVuZ3RoICE9PSAwKVxuICAgIHtcbiAgICAgICAgLy9jb25zaWRlciByZXN1bHQgYXMgbGlua2VkIG5vZGVzIGlucHV0XG4gICAgICAgIGxldCBub2RlTGlua3MgPSBpbnRlcm1lZGlhdGVQaXBlbGluZS5saW5rcztcbiAgICAgICAgbGV0IG1vZHVsZVJlc3VsdCA9IHJlc3VsdC5vdXQ7XG5cbiAgICAgICAgaWYgKG5vZGVMaW5rcy5oYXNPd25Qcm9wZXJ0eShhbGlhcykpe1xuICAgICAgICAgICAgbGV0IGxpbmtzQXJyYXkgPU9iamVjdC5lbnRyaWVzKG5vZGVMaW5rc1thbGlhc10ub3V0KVswXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxpbmtzQXJyYXkpO1xuXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHNbbGlua3NBcnJheVswXV09e1xuICAgICAgICAgICAgICAgIFwibnVtXCI6bW9kdWxlUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlc1thbGlhc107XG4gICAgICAgIH1lbHNlIHtcblxuICAgICAgICAgICAgLy9jb25zaWRlciByZXN1bHQgYXMgbm9kZSBvdXRwdXRcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0c1thbGlhc109e1xuICAgICAgICAgICAgICAgIFwib3V0XCI6bW9kdWxlUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVsZXRlIGludGVybWVkaWF0ZVBpcGVsaW5lLmNvbXBvc2FibGVzW2FsaWFzXTtcbiAgICAgICAgfVxuXG5cbiAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc0RvbmUrKztcblxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLm1vZHVsZXNEb25lIC8gK3RoaXMubW9kdWxlc1RvdGFsO1xuXG4gICAgICAgIC8vbWFrZSBhIHZhbHVlIDAtMTAwIGFuZCBjdXQgb2ZmIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFjaygocHJvZ3Jlc3MgKiAxMDApLnRvRml4ZWQoMCkpO1xuXG4gICAgfX1cbn1cblxuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIHRoYXQgd2VyZSBpbml0YWxpemVkIGR1cmluZyB7QGxpbmsgRXhlY3V0aW9uTWFuYWdlciNzZXR1cH0uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGV4ZWN1dGlvbi4gSWYgbXVsdGlwbGUgY29tcG9zYWJsZXMgd2lsbCBiZSBleGVjdXRlZCxcbiAqIHRoZSBkYXRhIHByb3BlcnR5IG5hbWVzIG11c3QgY29ycmVzcG9uZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lcyBmb3IgYSBjb3JyZWN0IG1hcHBpbmcgb2YgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGZvciB0aGUgZXhlY3V0aW9uLiBJZiBtdWx0aXBsZSBjb21wb3NhYmxlcyB3aWxsIGJlIGV4ZWN1dGVkLFxuICogdGhlIGlucHV0IHByb3BlcnR5IG5hbWVzIG11c3QgY29ycmVzcG9uZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lcyBmb3IgYSBjb3JyZWN0IG1hcHBpbmcgb2YgdGhlIGlucHV0LlxuICovXG5cblxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dCkge1xuICAgIC8qKlxuICAgICAqIEFuIEFycmF5IG9mIGV4ZWN1dGlvbnMsIHdoaWNoIGFyZSByZXByZXNlbnRpbmcgTW9kdWxlcyAobm9kZXMpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB2YXIgZXhlY3V0aW9ucyA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8qXG4gICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vIEV4ZWMgTWFuYWdlciBpbnB1dHMgLy8vLy8vLy8vLy8vLy9cIik7XG4gICAgY29uc29sZS5sb2coXCJkYXRhXCIpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIGNvbnNvbGUubG9nKFwiaW5wdXRcIik7XG4gICAgY29uc29sZS5sb2coaW5wdXQpO1xuICAgIGNvbnNvbGUubG9nKCdzZWxmJyk7XG4gICAgY29uc29sZS5sb2coc2VsZik7XG4gICAgY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSBQaXBlbGluZScpO1xuICAgIGNvbnNvbGUubG9nKGludGVybWVkaWF0ZVBpcGVsaW5lKTtcbiAgICBjb25zb2xlLmxvZyhcIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAqL1xuICAgIGNvbnNvbGUubG9nKCdiZWdpbiB0aGUgZXhlY3V0aW9uJyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy9jbG9zdXJlIGZ1bmN0aW9uXG4gICAgICAgIC8vY29tcG9zYWJsZXMgaXMgdGhlIHBpcGVsaW5lXG4gICAgICAgIC8vZXhlY3V0aW9ucyBpcyB0aGUgbGlzdCBvZiBwcm9taXNlcyBNb2R1bGUgdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoY29tcG9zYWJsZXMsIGV4ZWN1dGlvbnMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBmdW5jIGlucHV0cyAvLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb21wb3NhYmxlcz0gJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb21wb3NhYmxlcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW9ucz0gJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleGVjdXRpb25zKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb25seU9uZUNvbXBvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBvbmx5IG9uZSBjb21wb3NhYmxlIHdpbGwgYmUgZXhlY3V0ZWQsIGJlY2F1c2UgdGhlbiB5b3UgZG9uJ3QgZ28gaW50byB0aGUgbG9vcC5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29tcG9zYWJsZXMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvbmx5T25lQ29tcG9zYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vIGlmIGNvbmRpdGlvbiAvLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb21wb3NhYmxlc1trZXldPSAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBvc2FibGVzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2lucHV0W2tleV0gJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbnB1dFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdrZXk9ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWxmLnByb2dyZXNzVXBkYXRlLmJpbmQoc2VsZik9ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc2VsZi5wcm9ncmVzc1VwZGF0ZS5iaW5kKHNlbGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5T25lQ29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSBmdW5jdGlvbiBpcyBkZWZpbmVkIGluIG1vZHVsZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbnMucHVzaChjb21wb3NhYmxlc1trZXldLmV4ZWN1dGUoZGF0YSwgaW5wdXQsICcnLCBrZXksIHNlbGYucHJvZ3Jlc3NVcGRhdGUuYmluZChzZWxmKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIgPT09PT09IE9ubHkgT25lIENvbXBvc2FibGUgPT09PSBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT09IE9GRkxPQURJTkcgPT09IE1PRFVMRSBFWEVDVVRJT04gSVMgSU5JVElBTElaRUQgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbnMucHVzaChjb21wb3NhYmxlc1trZXldLmV4ZWN1dGUoZGF0YVtrZXldLCBpbnB1dFtrZXldIHx8IHt9LCAnJywga2V5LCBzZWxmLnByb2dyZXNzVXBkYXRlLmJpbmQoc2VsZikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiID09PT09PSBNb3JlIHRoYW4gMSBjb21wb3NhYmxlID09PT0gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBsb29wIHRvIG1vbml0b3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgcGlwZWxpbmUgYW5kIHVwZGF0ZSB0aGUgb2ZmbG9hZGluZyBwaXBlbGluZVxuXG4gICAgICAgICAgICAgICAgLy90b2RvOiBpbXBsZW1lbnQgYSBsb29wIHRoYXQgdXBkYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIHBpcGVsaW5lIGVhY2ggdGltZSBhIG1vZHVsZSBpcyBleGVjdXRlZFxuICAgICAgICAgICAgICAgIC8vICggcHJvbWlzZSBpcyBmdWxsZmlsbGVkKSBhbmQgc3RvcHMgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgcGlwZWxpbmUgaWYgb25lIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAvL21vbml0b3JQcm9taXNlcyhleGVjdXRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIEVMU0UgTk8gT0ZGTE9BRElORyAuLi5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFsbCB0aGUgZXhlY3V0aW9uIFByb21pc2VzIGhhdmUgcmVzb2x2ZWQuLi5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChleGVjdXRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhbGwgcHJvbWlzZXMgcmVzb2x2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlPbmVDb21wb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmx5T25lQ29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLCByZXN1bHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZWxmLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIGZ1bmMoc2VsZi5jb21wb3NhYmxlcywgZXhlY3V0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmV4ZWN1dGVDYWxsYmFjayA9IGZ1bmMoc2VsZi5jb21wb3NhYmxlcywgZXhlY3V0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy9hbGlhc1xuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUucnVuID0gRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uTWFuYWdlclxuXG5cbi8qXG5cbi8vLy8vLy8vLy8vLy8vICBFWFBFUlQgTU9ERSAgLy8vLy8vLy8vLy8vLy9cblxuLy8gaW5wdXRzIGFyZSBleHRyYWN0ZWQgZnJvbSBkZXZpY2VcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmRldmljZU1vbml0b3JpbmdJbmRleCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBkZXZpY2VNb25pdG9yaW5nSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvL3RoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICAgICAgbGV0IG1ldHJpY3MgPSBbXTtcblxuICAgICAgICAgICAgLy9IYXJkd2FyZSBtZXRyaWNzIGluIExpbnV4IGVudmlyb25tZW50czpcbiAgICAgICAgICAgIGxldCBjcHUgPSBhd2FpdCBjdXJyZW50Q1BVdXNhZ2UoKVxuICAgICAgICAgICAgbGV0IG1lbSA9IGF3YWl0IGN1cnJlbnRNZW1vcnl1c2FnZSgpXG4gICAgICAgICAgICBsZXQgc3RvcmFnZSA9IGF3YWl0IGF2YWlsYWJsZVN0b3JhZ2UoKVxuICAgICAgICAgICAgbGV0IGJhdHRlcnkgPSBhd2FpdCBhdmFpbGFibGVCYXR0ZXJ5KClcbiAgICAgICAgICAgIGxldCBjaGFyZ2luZyA9IGF3YWl0IGlzQ2hhcmdpbmcoKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNwdVwiLGNwdSxcIlxcbiBtZW1cIiwgbWVtLCBcIlxcbiBzdG9yYWdlXCIsIHN0b3JhZ2UsIFwiXFxuIGJhdHRlcnlcIiwgYmF0dGVyeSwgXCJcXG4gY2hhcmdpbmdcIiwgY2hhcmdpbmcpO1xuICAgICAgICAgICAgcmVzb2x2ZShtZXRyaWNzLnB1c2goY3B1LCBtZW0sIHN0b3JhZ2UsYmF0dGVyeSxjaGFyZ2luZykpO1xuXG5cbiAgICAgICAgICAgIC8vZm9yIHdpbmRvd3MgdGVzdGluZyBwdXJwb3Nlc1xuICAgICAgICAgICAgbGV0IGNwdSA9IDYwOyAvL2F2ZyBmcmVlIGNwdSB2YWx1ZSBmb3IgMyBtZWFzdXJlbWVudHMgaW4gJVxuICAgICAgICAgICAgbGV0IG1lbSA9IDEwMDAwMDsgLy8gYXZpbGFibGUgZnJlZSBtZW0gdmFsdWUgaW4gYnl0ZXNcbiAgICAgICAgICAgIGxldCBzdG9yYWdlID0gMjAwMDAwMDsgLy8gYXZpbGFibGUgZnJlZSBzdG9yYWdlIHZhbHVlIGluIGJ5dGVzXG4gICAgICAgICAgICBsZXQgYmF0dGVyeSA9IDgwO1xuICAgICAgICAgICAgbGV0IGNoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjcHVcIixjcHUsXCJcXG4gbWVtXCIsIG1lbSwgXCJcXG4gc3RvcmFnZVwiLCBzdG9yYWdlLCBcIlxcbiBiYXR0ZXJ5XCIsIGJhdHRlcnksIFwiXFxuIGNoYXJnaW5nXCIsIGNoYXJnaW5nKTtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChjcHUsIG1lbSwgc3RvcmFnZSwgYmF0dGVyeSwgY2hhcmdpbmcpXG4gICAgICAgICAgICByZXNvbHZlKG1ldHJpY3MpO1xuXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGRldmljZU1vbml0b3JpbmdJbmRleCgpO1xuXG59XG4qL1xuXG4vKlxuLy9pbnB1dHMgYXJlIGV4dHJhY3RlZCBmcm9tIGZyb250ZW5kIC0+IHVzZXIgaW5wdXQgaW4gYmFja2VuZFxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUub2ZmbG9hZGluZ0RlY2lzaW9uID0gYXN5bmMgZnVuY3Rpb24gKG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gb2ZmbG9hZGluZ0RlY2lzc2lvbih3cG4sIG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkbWkgPSBhd2FpdCBFeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZXZpY2VNb25pdG9yaW5nSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBkZWNpc2lvbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy9bMF06Y3B1XG4gICAgICAgICAgICAvL1sxXTogbWVtb3J5XG4gICAgICAgICAgICAvL1syXTogc3RvcmFnZVxuICAgICAgICAgICAgLy9kbWlbM106IGJhdHRlcnlcbiAgICAgICAgICAgIC8vZG1pWzRdOiBpcyBjaGFyZ2luZ1xuICAgICAgICAgICAgaWYgKG9kX0NQVSA9PT0gMCB8fCBvZF9tZW0gPT09IDAgfHwgb2RfYmF0dGVyeSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod3BuWzBdID4gKGRtaVswXSAqIG9kX0NQVSkgfHwgd3BuWzFdID4gKGRtaVsxXSAqIG9kX21lbSkgfHwgZG1pWzNdIDwgb2RfYmF0dGVyeSkge1xuICAgICAgICAgICAgICAgIGRlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGVjaXNpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgb2ZmbG9hZGluZ0RlY2lzc2lvbihbc3dldmEuQ29tcG9zYWJsZUxvYWRlclsndG90YWxDUFVSZXEnXSwgc3dldmEuQ29tcG9zYWJsZUxvYWRlclsndG90YWxNZW1SZXEnXV0sIG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KTtcblxufVxuKi9cblxuLy8vLy8vLy8vLy8vLy8gIEVORCAgRVhQRVJUIE1PREUgIC8vLy8vLy8vLy8vLy8vXG4iLCIvKipcbiAqIENyZWF0ZXMgaW5zdGFuY2Ugb2Ygc3VwcG9ydCBsaWJyYXJ5XG4gKlxuICogQWxsb3cgbG9hZGluZyBmdW5jdGlvbmFsaXR5IHNlcGFyYXRlbHksIGRlcGVuZGluZyBvbiB3aGF0IGlzIG5lZWRlZCBmb3IgYSBzcGVjaWZpYyBydW5uZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBTdXBwb3J0TGlicmFyeSgpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IHt9O1xufVxuXG5TdXBwb3J0TGlicmFyeS5wcm90b3R5cGUubG9hZFRlc3RTeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMudGVzdCA9IHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljOiB7XG4gICAgICAgICAgICB0eXBlc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyU2lnOiBcInVybDogc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmV0dXJuU2lnOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmM6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyB1cmw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5TdXBwb3J0TGlicmFyeS5wcm90b3R5cGUubG9hZExvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZnVuY3Rpb25zLmxvZyA9IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTG9nIHRoZSB0ZXh0IHRvIHRoZSBicm93c2VyIGNvbnNvbGVcIixcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljOiB7XG4gICAgICAgICAgICB0eXBlc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyU2lnOiBcInRleHQ6IHN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJ2b2lkXCJcbiAgICAgICAgICAgIH19LFxuICAgICAgICBmdW5jOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICAgIH19O1xufVxuU3VwcG9ydExpYnJhcnkucHJvdG90eXBlLmxvYWRIVFRQID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMuaHR0cFJlcXVlc3QgPSB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbmQgYSBIVFRQKFMpIHJlcXVlc3QgdXNpbmcgdGhlIGZldGNoIGFwaS4gUmV0dXJucyBzdGF0dXM9LTEgb24gdGltZW91dCFcIixcbiAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWM6e1xuICAgICAgICAgICAgdHlwZXNjcmlwdDoge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlclNpZzogXCJ1cmw6IHN0cmluZywgaGVhZGVyczpzdHJpbmcgPSBudWxsIHwgbnVsbCwgbWV0aG9kOnN0cmluZyA9ICdHRVQnIHwgbnVsbCwgYm9keTpzdHJpbmcgPSBudWxsIHwgbnVsbCwgY2FjaGU6c3RyaW5nID0gJ25vLXN0b3JlJyB8IG51bGwsIHRpbWVvdXQ6aTMyID0gNTAwMFwiLFxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJ0ZXh0OiBzdHJpbmcsIHN0YXR1czogaW50XCJcbiAgICAgICAgfX0sXG4gICAgICAgIGZ1bmM6IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGhlYWRlcnMsIG1ldGhvZCwgYm9keSwgY2FjaGUsIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGxldCBpbml0ID0ge307XG5cbiAgICAgICAgICAgIGlmKGhlYWRlcnMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpbml0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgaWYobWV0aG9kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICBpZihib2R5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGlmKGNhY2hlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluaXQuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XG5cbiAgICAgICAgICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGluaXQuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG5cbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVTUE9OU0U6XCIpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGV4dCwgcmVzcG9uc2Uuc3RhdHVzXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiVElNRU9VVFwiLCAtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH19O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1cHBvcnRMaWJyYXJ5OyIsImxldCBvZmZsb2FkaW5nVGFyZ2V0ID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvb2ZmbG9hZGluZ1RhcmdldC5qc1wiKTtcblxuZnVuY3Rpb24gY3JlYXRlUGVlcihpZCwgY2FsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gICAgbGV0IHBlZXIgPSBuZXcgUGVlcihpZCwge1xuICAgICAgICBob3N0OiBcIm1pbGtpLXBzeS5kYmlzLnJ3dGgtYWFjaGVuLmRlXCIsIC8vbG9jYWxob3N0XG4gICAgICAgIHBvcnQ6IDQ0MywgLy85MDAxXG4gICAgICAgIHBhdGg6IFwiL29mZmxvYWRpbmdOZXR3b3JrXCIsXG4gICAgfSk7XG4gICAgcGVlci5vbignb3BlbicsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTXkgcGVlciBJRCBpcyA9ICcgKyBJRCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcGVlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH0pO1xuICAgIHBlZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGVlciBJRCAnICsgSUQrJyBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwZWVyO1xufVxuXG5mdW5jdGlvbiBkYXRhUHJvY2Vzc2luZ0RldmljZShwaXBlbGluZSkge1xuICAgIGxldCBpZEFuZERNSXBhaXJzID0ge307XG4gICAgbGV0IGNvbm5lY3Rpb25zID0ge307XG4gICAgbGV0IGFsbFJlY2VpdmVkID0gZmFsc2U7XG4gICAgbGV0IHBlZXIgPSBjcmVhdGVQZWVyKCdzb3VyY2UnLCAoKSA9PiB7XG5cbiAgICAgICAgcGVlci5vbignY29ubmVjdGlvbicsIChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAvL3RvIGNoZWNrIHdoaWNoIHBlZXIgc2VudCBhIG1zZyBhbmQgd2hpY2ggZGlkbid0IFlFVCFcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24ucGVlcl09ZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgY29ubmVjdGVkIHRvIHBlZXIgPSAnK2Nvbm5lY3Rpb24ucGVlcik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb25uZWN0aW9ucyk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhW2RhdGEubGVuZ3RoLTFdPT09J2RtaScpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVjZWl2ZWQgRE1JIGZyb206ICcsY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlIHRoZSBmbGFnXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24ucGVlcl09dHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29ubmVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZEFuZERNSXBhaXJzW2Nvbm5lY3Rpb24ucGVlcl09IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsUmVjZWl2ZWQ9IE9iamVjdC52YWx1ZXMoY29ubmVjdGlvbnMpLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWxsUmVjZWl2ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdG9kbzogaGF2ZSBhIHRpbWVvdXQgZm9yIHJvYnVzdG5lc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbFJlY2VpdmVkKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NNc2dzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkVycm9yIGVuY291bnRlcmVkIHdoaWxlIHJlY2VpdmluZyB0aGUgZG1pXCIpO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc01zZ3MgKCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZW50ZXJlZCBwcm9jZXNzTXNncyBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIGxldCBwb3RJZCA9IG9mZmxvYWRpbmdUYXJnZXQoaWRBbmRETUlwYWlycyk7IC8vVE9ETzogY2hhbmdlIHByb2Nlc3NMaXN0IHRvIGNob29zZUJlc3RQT1RcbiAgICAgICAgICAgIGlmIChwb3RJZCA9PT0gbnVsbCApe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnb2ZmbG9hZGluZ091dHB1dCQgTm8gc3VpdGFibGUgcGVlciBpbiB0aGUgU1dlVkEgbmV0d29yayBmb3VuZCEnKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIGNob3NlbiBwb3RJRCBmb3Igb2ZmbG9hZGluZyA9ICcgKyBwb3RJZCk7XG5cbiAgICAgICAgICAgIGxldCBjb25uID0gcGVlci5jb25uZWN0KHBvdElkKTtcbiAgICAgICAgICAgIGNvbm4ub24oJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIGNvbm5lY3Rpb24gb3BlbmVkIHdpdGggY2hvc2VuIFBPVCAhJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NFTlQgUElQRUxJTkUgPSAnLHBpcGVsaW5lKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHlwZSBvZiBQSVBFTElORSA9ICcsIHR5cGVvZiBwaXBlbGluZSk7XG4gICAgICAgICAgICAgICAgY29ubi5zZW5kKHBpcGVsaW5lKTsgLy9zZW5kIHBpcGVsaW5lIGhlcmVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQaXBlbGluZSByZXN1bHQ6ICcpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpOyAvL3JlY2VpdmUgcGlwZWxpbmUgcmVzdWx0cyBoZXJlXG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgPT09PT0gUmVjaWV2ZWQgb2ZmbG9hZGVkIFJlc3VsdCA9PT09PScpO1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICBtc2cgPSAnb2ZmbG9hZGluZ091dHB1dCQgJyttc2c7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICBwZWVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG59XG5tb2R1bGUuZXhwb3J0cyA9ZGF0YVByb2Nlc3NpbmdEZXZpY2UiLCJcbmxldCBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlc1wiKTtcblxuZnVuY3Rpb24gY3JlYXRlUGVlcihpZCwgY2FsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gICAgbGV0IHBlZXIgPSBuZXcgUGVlcihpZCwge1xuICAgICAgICBob3N0OiBcIm1pbGtpLXBzeS5kYmlzLnJ3dGgtYWFjaGVuLmRlXCIsIC8vbG9jYWxob3N0XG4gICAgICAgIHBvcnQ6IDQ0MywgLy85MDAxXG4gICAgICAgIHBhdGg6IFwiL29mZmxvYWRpbmdOZXR3b3JrXCIsXG4gICAgfSk7XG4gICAgcGVlci5vbignb3BlbicsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTXkgcGVlciBJRCBpcyA9ICcgKyBJRCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcGVlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH0pO1xuICAgIHBlZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGVlciBJRCAnICsgSUQrJyBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwZWVyO1xufVxuXG5mdW5jdGlvbiBwb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0KCkge1xuICAgIGxldCBwZWVyID0gY3JlYXRlUGVlcignJywgKCkgPT4ge1xuICAgICAgICBwZWVyLm9uKCdjb25uZWN0aW9uJywgKGNvKT0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEkgYW0gY2hvc2VuIGJ5IFNvdXJjZSBQZWVyICEnKTtcbiAgICAgICAgICAgIGNvLm9uKCdkYXRhJywgKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBQaXBlbGluZSBhbmQgc2VuZCByZXN1bHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0YSByZWNlaXZlZCBmcm9tIFNvdXJjZSA9ICcsZGF0YSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBpcyB0aGVyZSBhIHdheSB0byBjaGVjayBpZiByZWNlaXZlZCBkYXRlIGlzIHJlYWxseSBhIHBpcGVsaW5lID8geWVzXG4gICAgICAgICAgICAgICAgLy9UT0RPOiB1c2VyIGlucHV0ID9cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgUHJvY2Vzc2luZyBvZmZsb2FkZWQgcGlwZWxpbmUgLi4uJyk7XG4gICAgICAgICAgICAgICAgLy8gc2V0dXAgYW5kIHByb2Nlc3MgdGhlIHBpcGVsaW5lXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1BpcGVsaW5lKGRhdGEpLnRoZW4oKHJlc3VsdCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIHBpcGVsaW5lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnT0ZGTE9BRElORyBSRVNVTFQgPSAnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIG9mZmxvYWRlZCBwaXBlbGluZScpXG4gICAgICAgICAgICAgICAgICAgIGNvLnNlbmQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIFJlc3VsdCBzZW50IHRvIG9mZmxvYWRpbmcgc291cmNlIHBlZXInKVxuXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gcGVlci5jb25uZWN0KCdzb3VyY2UnKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBjb25uZWN0ZWQgdG8gcGVlciA9ICcrY29ubmVjdGlvbi5wZWVyKTtcblxuICAgICAgICAgICAgLy9UT0RPOiBnZXQgaW5wdXQgZnJvbSBleGVjdXRpb24gbWFuYWdlciBHRVQgZnJvbnRlbmQuXG4gICAgICAgICAgICAvL2lucHV0IG9mZmxvYWRpbmcgcmVzb3VyY2VzIGxpbWl0cyBNVVNUIGJlIGdsb2JhbCB2YWx1ZSBmcm9tIHVzZXIgaW5wdXQgKGZyb250ZW5kKVxuICAgICAgICAgICAgbGV0IG9yTGlzdD0gc3dldmEuRXhlY3V0aW9uTWFuYWdlci5nZXRPUkxpc3QoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvckxpc3QgR0VUIGluIHBvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQgPSAnLG9yTGlzdCk7XG4gICAgICAgICAgICBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzKG9yTGlzdCkudGhlbihyZXN1bHQgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdCBpcyA9JyxyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vcHVzaCBzdHJpbmcgJ2RtaScgYXMgbGFzdCBlbnRyeSBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2RtaScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvL3NlbmQgZG1pIGFzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChyZXN1bHQpO1xuXG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gICAgaWYgKGJ5dGVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMCBCeXRlcyc7XG4gICAgfVxuXG4gICAgY29uc3QgayA9IDEwMjQ7XG4gICAgY29uc3QgZG0gPSBkZWNpbWFscyA8IDAgPyAwIDogZGVjaW1hbHM7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ107XG5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoZG0pKTtcblxuICAgIGlmICghaXNOYU4oc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIGAke3NpemV9ICR7c2l6ZXNbaV19YDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUobWlsbGlzZWNvbmRzKSB7XG4gICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCkgJSA2MDtcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihtaWxsaXNlY29uZHMgLyAoMTAwMCAqIDYwKSkgJSA2MDtcblxuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBbXTtcblxuICAgIGlmIChtaW51dGVzID4gMCkge1xuICAgICAgICBmb3JtYXR0ZWRUaW1lLnB1c2gobWludXRlcyArIChtaW51dGVzID09PSAxID8gJyBtaW51dGUnIDogJyBtaW51dGVzJykpO1xuICAgIH1cbiAgICBpZiAoc2Vjb25kcyA+MCl7XG4gICAgICAgIGZvcm1hdHRlZFRpbWUucHVzaChzZWNvbmRzICsgKHNlY29uZHMgPT09IDEgPyAnIHNlY29uZCcgOiAnIHNlY29uZHMnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlZFRpbWUuam9pbignLCAnKTtcbn1cblxuLy9UT0RPOiBwcm9jZXNzIHBpcGVsaW5lIGluIGV4ZVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BpcGVsaW5lKHJlY2VpdmVkUGlwZWxpbmUpe1xuICAgIC8vVE9ETzogZXh0cmFjdCBpbnRlcm1lZGlhdGUgcmVzdWx0IGZyb20gcGlwZWxpbmUgd2l0aCBhIG5ldyBrZXkgaW4gdGhlIG9iamVjdFxuXG4gICAgY29uc29sZS5sb2coJ2VudGVyZWQgcHJvY2Vzc1BpcGVsaW5lIGlzIFBPVCAuLi4nKTtcbiAgICBjb25zb2xlLmxvZyhyZWNlaXZlZFBpcGVsaW5lKTtcblxuICAgIGxldCB7aW50ZXJtZWRpYXRlUGlwZWxpbmU6b2IxLCBpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHM6b2IyfSA9IHJlY2VpdmVkUGlwZWxpbmU7XG4gICAgY29uc29sZS5sb2coJ3BpcGVsaW5lID0gJyxvYjEpO1xuICAgIGNvbnNvbGUubG9nKCdwaXBlbGluZSBpbnB1dHMgPSAnLG9iMik7XG4gICAgbGV0IHBpcGVsaW5lID0gSlNPTi5wYXJzZShvYjEpO1xuICAgIGxldCBwaXBlbGluZUlucHV0cyA9IEpTT04ucGFyc2Uob2IyKTtcbiAgICBjb25zb2xlLmxvZygncGlwZWxpbmUgPSAnLCBwaXBlbGluZSk7XG4gICAgY29uc29sZS5sb2coJ3BpcGVsaW5lIGlucHV0cyA9ICcsIHBpcGVsaW5lSW5wdXRzKTtcblxuXG4gICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBtYW5hZ2VyID0gbmV3IHN3ZXZhLkV4ZWN1dGlvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgIG1hbmFnZXIuc2V0dXAocGlwZWxpbmUpO1xuXG4gICAgICAgICAgICBsZXQgc3RhcnRNZW1FeGVjdXRlID0gcGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplO1xuICAgICAgICAgICAgbGV0IHN0YXJ0VGltZUV4ZWN1dGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgbGV0IG9mZmxvYWRlZFJlc3VsdCA9IGF3YWl0IG1hbmFnZXIuZXhlY3V0ZShwaXBlbGluZUlucHV0cywge30pO1xuICAgICAgICAgICAgbGV0IGVuZFRpbWVFeGVjdXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBlbmRNZW1FeGVjdXRlID0gcGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ09VVFBVVCBvZmZsb2FkZWQgbXNnID0gJyxvZmZsb2FkZWRSZXN1bHQpO1xuXG4gICAgICAgICAgICBpZiAoZW5kTWVtRXhlY3V0ZSA8IHN0YXJ0TWVtRXhlY3V0ZSkge1xuICAgICAgICAgICAgbGV0IHRlbXAgPSBlbmRNZW1FeGVjdXRlO1xuICAgICAgICAgICAgZW5kTWVtRXhlY3V0ZSA9IHN0YXJ0TWVtRXhlY3V0ZTtcbiAgICAgICAgICAgIHN0YXJ0TWVtRXhlY3V0ZSA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBPZmZsb2FkZWQgdGFzayBFeGVjdXRpb24gdGltZTogJyxmb3JtYXRUaW1lKGVuZFRpbWVFeGVjdXRlLXN0YXJ0VGltZUV4ZWN1dGUpLCcgKCcsZW5kVGltZUV4ZWN1dGUtc3RhcnRUaW1lRXhlY3V0ZSwnIG1zKScpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIE9mZmxvYWRlZCB0YXNrIEV4ZWN1dGlvbiBNZW1vcnk6ICcsZm9ybWF0Qnl0ZXMoZW5kTWVtRXhlY3V0ZS1zdGFydE1lbUV4ZWN1dGUpLCcgKCcsZW5kTWVtRXhlY3V0ZS1zdGFydE1lbUV4ZWN1dGUsJyBieXRlcyknKTtcbiAgICAgICAgICAgIHJldHVybiBvZmZsb2FkZWRSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBleGVjdXRpbmcgdGhlIG9mZmxvYWRlZCBwaXBlbGluZSA9ICcsZSwnXFxuUGxlYXNlIHRyeSBhZ2FpbicpO1xuICAgICAgICAgICAgcmV0dXJuICdFcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBleGVjdXRpbmcgdGhlIG9mZmxvYWRlZCBwaXBlbGluZS4gUGxlYXNlIHRyeSBhZ2Fpbic7XG4gICAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG90ZW50aWFsT2ZmbG9hZGluZ1RhcmdldCIsIi8vVVNFUiBpbnB1dCBvckxpc3Q6XG5cbi8vIGZvciBXZWIgZW52aXJvbm1lbnQ6XG4vLyBvckxpc3QgPSBbbWVtJSwgYmF0dGVyeSUsIGlzQ2hhcmdpbmcgKGJpbmFyeSldXG5cbi8vZm9yIE5vZGUuSlMgZW52aXJvbm1lbnQ6XG4vLyBvckxpc3QgPSBbY3B1JSwgbWVtJSwgYmF0dGVyeSUsIGlzQ2hhcmdpbmcgKGJpbmFyeSldXG5cbmFzeW5jIGZ1bmN0aW9uIGF2YWlsYWJsZU9mZmxvYWRpbmdSZXNvdXJjZXMob3JMaXN0KSB7XG4gICAgaWYgKG9yTGlzdFswXSA9PT0gMCB8fCBvckxpc3RbMV0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLDAsMCxmYWxzZV07XG4gICAgfVxuXG4gICAgbGV0IGNwdUxvYWQgPSAwO1xuICAgIGxldCBtZW1Vc2FnZSA9IDA7XG4gICAgbGV0IGJhdHRlcnlQZXJjZW50ID0gMDtcbiAgICBsZXQgYmF0dGVyeUlzQ2hhcmdpbmcgPSBmYWxzZTtcblxuICAgIGxldCBsaXN0T2ZNZXRyaWNzID1bXTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAvL0Jyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgICAgbWVtVXNhZ2UgPSAocGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplIC8gcGVyZm9ybWFuY2UubWVtb3J5LmpzSGVhcFNpemVMaW1pdCkgKiAxMDA7XG4gICAgICAgIGxldCBiYXR0ZXJ5ID0gYXdhaXQgbmF2aWdhdG9yLmdldEJhdHRlcnkoKTtcbiAgICAgICAgYmF0dGVyeVBlcmNlbnQgPSBiYXR0ZXJ5LmxldmVsICogMTAwO1xuICAgICAgICBiYXR0ZXJ5SXNDaGFyZ2luZyA9IGJhdHRlcnkuY2hhcmdpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtZW1Vc2FnZSA9ICcsbWVtVXNhZ2UsJ2JhdHRlcnkgPSAnLGJhdHRlcnlQZXJjZW50LCAnaXNDaGFyZ2luZyA9ICcsYmF0dGVyeUlzQ2hhcmdpbmcpO1xuXG4gICAgfWVsc2V7XG4gICAgICAgIC8vTm9kZUpTIGVudmlyb25tZW50XG4gICAgICAgIGxldCBzaSA9IHJlcXVpcmUoJ3N5c3RlbWluZm9ybWF0aW9uJyk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwgKFtcbiAgICAgICAgICAgIHNpLmN1cnJlbnRMb2FkKCksXG4gICAgICAgICAgICBzaS5tZW0oKSxcbiAgICAgICAgICAgIHNpLmJhdHRlcnkoKVxuICAgICAgICBdKS50aGVuKChbY3B1LCBtZW0sIGJhdHRlcnldKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVtUlNTID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgICAgICAgICAgbWVtVXNhZ2UgPSAgKG1lbVJTUy5yc3MgLyBtZW0uYXZhaWxhYmxlKSAqIDEwMDtcbiAgICAgICAgICAgIGNwdUxvYWQgPSBjcHUuYXZnTG9hZDtcbiAgICAgICAgICAgIGJhdHRlcnlQZXJjZW50ID0gYmF0dGVyeS5wZXJjZW50O1xuICAgICAgICAgICAgYmF0dGVyeUlzQ2hhcmdpbmcgPSBiYXR0ZXJ5LmFjQ29ubmVjdGVkO1xuICAgICAgICAgICAgLy9jdXJyZW50IGNwdSBsb2FkIGhpZ2hlciB0aGFuIHVzZXIgbGltaXQgKG9ubHkgZm9yIE5vZGUuanMgZW52aXJvbm1lbnQpXG4gICAgICAgICAgICBpZiAoY3B1TG9hZCA+IG9yTGlzdFswXSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLDAsMCxmYWxzZV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NwdSA9ICcsY3B1TG9hZCwgJ21lbVVzYWdlID0gJyxtZW1Vc2FnZSwnYmF0dGVyeSA9ICcsYmF0dGVyeVBlcmNlbnQsICdpc0NoYXJnaW5nID0gJyxiYXR0ZXJ5SXNDaGFyZ2luZyk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZCBleHRyYWN0aW5nIG1ldHJpY3MgaW4gdGhlIE5vZGVKUyBlbnZpcm9ubWVudC4gRVJST1IgPSAnICsgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBtZW1Vc2FnZSA+IG9yTGlzdFswXSB8fCAvLyBtZW0gdXNhZ2UgaXMgaGlnaGVyIHRoYW4gbGltaXRcbiAgICAgICAgYmF0dGVyeVBlcmNlbnQgPCBvckxpc3RbMV0gfHwgLy8gYmF0dGVyeSBpcyBsb3dlciB0aGFuIG1pbmltdW0gc2V0IGJ5IHVzZXJcbiAgICAgICAgYmF0dGVyeUlzQ2hhcmdpbmcgIT09IG9yTGlzdFsyXVxuICAgIClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBQZWVyIG5vdCBjaG9zZW4gZm9yIHRoZSBvZmZsb2FkZWQgdGFzay4nKVxuICAgICAgICByZXR1cm4gWzAsMCwwLGZhbHNlXVxuICAgIH1cbiAgICBlbHNle1xuICAgIC8vT3V0cHV0IG1ldHJpY3MgaW4gcGVyY2VudCAlXG4gICAgICAgIGxpc3RPZk1ldHJpY3MucHVzaChjcHVMb2FkLCgxMDAtbWVtVXNhZ2UpLGJhdHRlcnlQZXJjZW50LGJhdHRlcnlJc0NoYXJnaW5nKTtcbiAgICAgICAgcmV0dXJuIGxpc3RPZk1ldHJpY3M7XG5cbiAgICB9XG5cbn1cbm1vZHVsZS5leHBvcnRzID0gYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlc1xuXG4vKlxuLy8gVEVTVCBmdW5jdGlvbiBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuc2V0SW50ZXJ2YWwoKCkgPT57XG5jb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xuYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlcyhbMCwxMCwxMCx0cnVlXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgY29uc3QgZW5kVGltZSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZSk7XG4gICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICBjb25zb2xlLmxvZygnRWxhcHNlZCB0aW1lOiAnKyhlbmRUaW1lWzBdICogMTAwMCArIGVuZFRpbWVbMV0gLyAxMDAwMDAwKS50b0ZpeGVkKDIpKyAnIG1zJyk7XG5cbn0pO30sMzAwMCk7XG4qL1xuXG4iLCIvKlxuKlxuVXNlIHRoaXMgZnVuY3Rpb24gdG8gbW9uaXRvciBhbnkgU1dlVkEgZXhlY3V0aW9uIGFuZCBkZXRlcm1pbmUgbmVjZXNzaXR5IG9mIG9mZmxvYWRpbmdcbmJhc2VkIG9uIENQVSAsIE1lbW9yeSBhbmQgQmF0dGVyeSBtZXRyaWNzLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGluIGJvdGhcbldlYiBhbmQgTm9kZUpTIGVudmlyb25tZW50cyAhXG4qIFVTRVIgSW5wdXQgb2RMaXN0ID0gW0xpbWl0X2NwdSAlLCBMaW1pdF9tZW0gJSwgTGltaXRfYmF0dGVyeSAlXVxuKi9cblxuYXN5bmMgZnVuY3Rpb24gb2ZmbG9hZGluZ0RlY2lzaW9uKG9kTGlzdCkge1xuICAgIGlmIChvZExpc3RbMF0gPT09IDAgfHwgb2RMaXN0WzFdID09PSAwIHx8IG9kTGlzdFsyXSA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgT2ZmbG9hZGluZyBUcmlnZ2VyZWQgd2hpbGUgbW9uaXRvcmluZyB0aGUgZXhlY3V0aW9uIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGNwdUxvYWQgPSAwO1xuICAgIGxldCBtZW1Vc2FnZSA9IDA7XG4gICAgbGV0IGJhdHRlcnlQZXJjZW50ID0gMDtcbiAgICBsZXQgb2ZmbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIC8vQnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICBtZW1Vc2FnZSA9IChwZXJmb3JtYW5jZS5tZW1vcnkudXNlZEpTSGVhcFNpemUgLyBwZXJmb3JtYW5jZS5tZW1vcnkuanNIZWFwU2l6ZUxpbWl0KSAqIDEwMDtcbiAgICAgICAgbGV0IGJhdHRlcnkgPSBhd2FpdCBuYXZpZ2F0b3IuZ2V0QmF0dGVyeSgpO1xuICAgICAgICBiYXR0ZXJ5UGVyY2VudCA9IGJhdHRlcnkubGV2ZWwgKiAxMDA7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ01lYXN1cmVkIG1lbSA9ICcsbWVtVXNhZ2UsJ2JhdHRlcnkgPSAnLGJhdHRlcnlQZXJjZW50KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy9Ob2RlSlMgZW52aXJvbm1lbnRcbiAgICAgICAgbGV0IHNpID0gcmVxdWlyZSgnc3lzdGVtaW5mb3JtYXRpb24nKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCAoW1xuICAgICAgICAgICAgc2kuY3VycmVudExvYWQoKSxcbiAgICAgICAgICAgIHNpLm1lbSgpLFxuICAgICAgICAgICAgc2kuYmF0dGVyeSgpXG4gICAgICAgIF0pLnRoZW4oKFtjcHUsIG1lbSwgYmF0dGVyeV0pID0+IHtcbiAgICAgICAgICAgIGxldCBtZW1SU1MgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgICAgICAgICBtZW1Vc2FnZSA9IChtZW1SU1MucnNzIC8gbWVtLmF2YWlsYWJsZSkgKiAxMDA7XG4gICAgICAgICAgICBjcHVMb2FkID0gY3B1LmF2Z0xvYWQ7XG4gICAgICAgICAgICBiYXR0ZXJ5UGVyY2VudCA9IGJhdHRlcnkucGVyY2VudDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjcHUgPSAnLGNwdUxvYWQsICdtZW0gPSAnLG1lbVVzYWdlLCdiYXR0ZXJ5ID0gJyxiYXR0ZXJ5UGVyY2VudCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZCBleHRyYWN0aW5nIG1ldHJpY3MgaW4gdGhlIE5vZGVKUyBlbnZpcm9ubWVudC4gRVJST1IgPSAnICsgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICAgICAgICAgaWYgKGNwdUxvYWQgPiBvZExpc3RbMF0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTW9uaXRvcmluZyA9IENQVSBsaW1pdCBleGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgIG9mZmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZW1Vc2FnZSA+IG9kTGlzdFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBNb25pdG9yaW5nID0gTWVtb3J5IGxpbWl0IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgb2ZmbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJhdHRlcnlQZXJjZW50IDwgb2RMaXN0WzJdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIE1vbml0b3JpbmcgPSBCYXR0ZXJ5IGxpbWl0IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgb2ZmbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICByZXR1cm4gb2ZmbG9hZGluZztcbn1cbm1vZHVsZS5leHBvcnRzID0gb2ZmbG9hZGluZ0RlY2lzaW9uXG5cblxuXG5cbi8qXG4vLyBURVNUIGZ1bmN0aW9uIGZvciBOb2RlLmpzIGVudmlyb25tZW50XG5cbi8vbGV0IHRpbWUgPTA7XG5sZXQgaT0wO1xubGV0IG9kTGlzdCA9WzEwLDEwLDkwXTtcbmxldCBzdGFydFRpbWUgPSBudWxsO1xubGV0IGVuZFRpbWUgPW51bGw7XG5sZXQgYXZnTGlzdD1bXSA7XG5cblxuc2V0SW50ZXJ2YWwoKCk9PntcbiAgICAgICBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgIG9mZmxvYWRpbmdEZWNpc2lvbihvZExpc3QpLnRoZW4gKChyZXN1bHQpPT57XG4gICAgICAgZW5kVGltZSA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZSk7XG5cbiAgICAgICBjb25zb2xlLmxvZygnTW9uaXRvcmluZyBSb3VuZCAjJytpKTtcbiAgICAgICBpKys7XG4gICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICBjb25zb2xlLmxvZygnRWxhcHNlZCB0aW1lOiAnKyhlbmRUaW1lWzBdICogMTAwMCArIGVuZFRpbWVbMV0gLyAxMDAwMDAwKS50b0ZpeGVkKDIpKyAnIG1zJyk7XG4gICB9KTtcblxuXG59LDMwMDApO1xuKi9cblxuXG4iLCJcbi8vIG9yTGlzdCA9IFtjcHUlLCBtZW0lLCBiYXR0ZXJ5JSwgaXNDaGFyZ2luZyAoYmluYXJ5KV1cblxuZnVuY3Rpb24gZGVjaXNpb25WYWx1ZU9mUE9UKG9mZmxvYWRpbmdSZXNvdXJjZXNMaXN0KXtcbiAgICBsZXQgYWR2YW50YWdlQ1BVID0gMTAwLW9mZmxvYWRpbmdSZXNvdXJjZXNMaXN0WzBdOyAvL05vZGUuanMgZW52LiBvbmx5XG5cbiAgICBsZXQgYWR2YW50YWdlTWVtID0gb2ZmbG9hZGluZ1Jlc291cmNlc0xpc3RbMV07IC8vIGZyZWUgbWVtb3J5IGluICVcblxuICAgIC8vYmF0dGVyeSBpcyBjaGFyZ2luZz0gTUFYIGFkdmFudGFnZSAhXG4gICAgbGV0IGFkdmFudGFnZUJhdHRlcnkgPSAwO1xuICAgIC8vYmF0dGVyeSBpcyBub3QgY2hhcmdpbmdcbiAgICBpZiAoIW9mZmxvYWRpbmdSZXNvdXJjZXNMaXN0WzNdKXtcbiAgICAgICAgYWR2YW50YWdlQmF0dGVyeSA9IDEwMC1vZmZsb2FkaW5nUmVzb3VyY2VzTGlzdFsyXTtcbiAgICB9XG4gICAgLy9yZXR1cm4gYWR2YW50YWdlQ1BVICsgYWR2YW50YWdlTWVtIC0gYWR2YW50YWdlQmF0dGVyeTtcbiAgICByZXR1cm4gYWR2YW50YWdlQ1BVICsgYWR2YW50YWdlTWVtIC0gYWR2YW50YWdlQmF0dGVyeTtcbn1cblxuXG4vL1dlIHF1YWxpZnkgYnkgXCJiZXN0XCIgdGhlIHBlZXIgd2l0aCBoaWdoZXN0IGN1cnJlbnQgY29tcHV0YXRpb24gYW5kIGJhdHRlcnlcblxuLy9pbnB1dCBpRGFuZE9ScGFpcnM9IHsgaWQgOiBbIG9yIGxpc3QgXSB9XG5mdW5jdGlvbiBvZmZsb2FkaW5nVGFyZ2V0IChpRGFuZE9ScGFpcnMpe1xuICAgIGxldCBiZXN0UE9USWQ9bnVsbDtcbiAgICBsZXQgdGVtcCA9IDA7XG4gICAgZm9yICggbGV0IGtleSBpbiBpRGFuZE9ScGFpcnMgKXtcblxuICAgICAgICBsZXQgZHBvdCA9IGRlY2lzaW9uVmFsdWVPZlBPVChpRGFuZE9ScGFpcnNba2V5XSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQRUVSID0gJytrZXkrJyBEUE9EID0gJytkcG90KTtcbiAgICAgICAgaWYgKCBkcG90PnRlbXApe1xuICAgICAgICAgICAgdGVtcD1kcG90O1xuICAgICAgICAgICAgYmVzdFBPVElkPWtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdFBPVElkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBvZmZsb2FkaW5nVGFyZ2V0XG5cbi8qXG4vL2ZvciB0ZXN0aW5nIHB1cnBvc2VzIChOb2RlLmpzIGVudi4pXG5sZXQgcGFpcnMgPSB7XG4gICAgJ2lkMScgOiBbMTAsMjAsNjAsZmFsc2VdLFxuICAgICdpZDInIDogWzUwLDMwLDEwMCxmYWxzZV0sXG4gICAgJ2lkMycgOiBbOTksNDAsMTAsdHJ1ZV0sXG4gICAgJ2lkNCcgOiBbIDAuMDAsIDczLjIwLCA4MCwgZmFsc2UgXVxufVxub2ZmbG9hZGluZ1RhcmdldChwYWlycyk7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXNCaW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FzLWJpbmQvZGlzdC9hcy1iaW5kLmNqcy5qcycpO1xudmFyIFJ1bm5lciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvcnVubmVycy9ydW5uZXIuanMnKTtcbnZhciBDb21waWxlciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcGlsZXJzL2Fzc2VtYmx5U2NyaXB0Q29tcGlsZXIuanMnKTtcbnZhciBDb21wb3NhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NhYmxlLmpzJyk7XG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL0V4ZWN1dGlvbkVycm9yLmpzJyk7XG52YXIgU3VwcG9ydExpYnJhcnkgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2V4ZWN1dGlvbi9zdXBwb3J0TGlicmFyeS5qcycpO1xuXG5cbi8qKlxuICogUGFyYW1ldGVycyBpbiB0aGUgQXNzZW1ibHlTY3JpcHQgcnVuIGZ1bmN0aW9uIHN0YXJ0aW5nIHdpdGggdGhpcyBzdHJpbmcgYXJlIHVzZWQgZm9yIHRoZSB1c2VyIGlucHV0cy5cbiAqL1xuY29uc3QgdXNlcklucHV0U2VwYXJhdG9yID0gXCJpbnB1dF9cIjtcblxuLyoqXG4gKiBUaGUgQXNzZW1ibHlTY3JpcHQgcnVubmVyIHN1cHBvcnRzIHN0cmljdCBUeXBlU2NyaXB0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSdW5uZXJcbiAqXG4gKi9cbmZ1bmN0aW9uIEFzc2VtYmx5U2NyaXB0UnVubmVyKCkge1xuICAgIHRoaXMuc3VwcG9ydExpYiA9IG5ldyBTdXBwb3J0TGlicmFyeSgpO1xuICAgIHRoaXMuc3VwcG9ydExpYi5sb2FkSFRUUCgpO1xuICAgIHRoaXMuc3VwcG9ydExpYi5sb2FkTG9nZ2VyKCk7XG4gICAgdGhpcy5zdXBwb3J0TGliLmxvYWRUZXN0U3luYygpO1xuICAgIHRoaXMuY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIodGhpcy5zdXBwb3J0TGliKTtcbn1cblxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmdldEhUTUxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgZGVzY3JpcHRpb24gPSBcIkZpbmQgdGhlIG9mZmljaWFsIEFzc2VtYmx5U2NyaXB0IGRvY3VtZW50YXRpb24gb24gPGEgaHJlZj0naHR0cHM6Ly93d3cuYXNzZW1ibHlzY3JpcHQub3JnL2ludHJvZHVjdGlvbi5odG1sJyB0YXJnZXQ9J19ibGFuayc+YXNzZW1ibHlzY3JpcHQub3JnPC9hPi5cXG5cIiArXG4gICAgICAgIFwiVGhlIGV4cG9ydGVkIDxiPnJ1bjwvYj4gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgcGFyYW1ldGVycyBhcyBkYXRhIGlucHV0cyBhbmQgcmV0dXJuZWQgZGF0YSBhcyBhbiBvdXRwdXQgY2FsbGVkIDxiPm91dDwvYj4uIFVzZXIgaW5wdXRzIGhhdmUgdG8gYmUgcHJlZml4ZWQgd2l0aCA8Yj5pbnB1dF88L2I+IGFuZCBiZSB0aGUgZmlyc3QgcGFyYW1ldGVycy5cXG5cIiArXG4gICAgICAgIFwiQWRkaXRpb25hbCBvdXRwdXRzIGFyZSBnZW5lcmF0ZWQgZm9yIGV4cG9ydGVkIGdsb2JhbCB2YXJpYWJsZXMuIFRoaXMgYWxsb3dzIHJldHVybmluZyB2YWx1ZXMgcmVzdWx0aW5nIGZyb20gYXN5bmNocm9ub3VzIGNhbGxiYWNrcy5cXG5cIiArXG4gICAgICAgIFwiSWYgdGhlIDxiPnJ1bjwvYj4gZnVuY3Rpb24gaGFzIHRoZSByZXR1cm4gdHlwZSBcXFwidm9pZFxcXCIgbm8gZGVmYXVsdCBvdXRwdXQgaXMgZ2VuZXJhdGVkLlxcblwiO1xuICAgIGRlc2NyaXB0aW9uICs9IFwiXFxuXCIgKyB0aGlzLmNvbXBpbGVyLnN1cHBvcnRMaWJyYXJ5RG9jdW1lbnRhdGlvbjtcblxuICAgIC8vSFRNTCBuZXcgbGluZXNcbiAgICBkZXNjcmlwdGlvbi5yZXBsYWNlQWxsKFwiXFxuXCIsIFwiPGJyPlwiKTtcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vL2luaGVyaXQgcHJvcGVydGllc1xuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSdW5uZXIucHJvdG90eXBlKTtcbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VtYmx5U2NyaXB0UnVubmVyO1xuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUubmFtZSA9IFwiVHlwZVNjcmlwdCAodXNpbmcgQXNzZW1ibHlTY3JpcHQpXCI7XG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuaWQgPSBcInR5cGVzY3JpcHRcIjtcblxuLy89PT0gT0ZGTE9BRElORyA9PT0gTW9kdWxlID0+IEFTQyBjb2RlIHRvIFdBU00gYmluYXJ5XG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUucHJlcGFyZSA9IGFzeW5jIGZ1bmN0aW9uIChtb2R1bGUsIGNhbGxiYWNrTGlzdCA9IFtdKSB7XG4gICAgbGV0IGRlZmluaXRpb25EYXRhID0gbnVsbDtcblxuICAgIGlmICghbW9kdWxlLmJpbmFyeSB8fCBtb2R1bGUuYmluYXJ5Lmxlbmd0aCA9PT0gMCB8fCBtb2R1bGUuYmluYXJ5SGFzaCAhPT0gdGhpcy5jYWxjdWxhdGVCaW5hcnlIYXNoKG1vZHVsZS5iaW5hcnkpKSB7XG4gICAgICAgIG1vZHVsZS5iaW5hcnlIYXNoID0gbnVsbDtcbiAgICAgICAgLy8gbW9uaXRvcmVkIGNvbXBpbGF0aW9uIGluIEFTQ2NvbXBpbGVyLmpzXG4gICAgICAgIGxldCBjb21waWxlclJlc3VsdCA9IGF3YWl0IHRoaXMuY29tcGlsZXIuY29tcGlsZShtb2R1bGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBpbGVyUmVzdWx0Jyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb21waWxlclJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJSZXN1bHQgPT09ICdvZmZsb2FkaW5nJykge1xuICAgICAgICAgICAgICAgIC8vdG9kbzogT2ZmbG9hZGluZyBuZWVkZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9mZmxvYWRpbmcgaW50ZXJjZXB0ZWQgaW4gQVNDUnVubmVyLnByZXBhcmUoKVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAnb2ZmbG9hZGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5iaW5hcnkgPSBjb21waWxlclJlc3VsdC5iaW5hcnlEYXRhO1xuICAgICAgICAgICAgICAgIG1vZHVsZS5iaW5hcnlIYXNoID0gdGhpcy5jYWxjdWxhdGVCaW5hcnlIYXNoKG1vZHVsZS5iaW5hcnkpO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25EYXRhID0gY29tcGlsZXJSZXN1bHQuZGVmaW5pdGlvbkRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIGNvbnN0IG1vZHVsZUluc3RhbmNlID0gYXdhaXQgQXNCaW5kLmluc3RhbnRpYXRlKG1vZHVsZS5iaW5hcnksIHtcbiAgICAgICAgbW9kdWxlOiB0aGlzLmdlbmVyYXRlRnVuY3Rpb25EZXNjcmlwdGlvbihjYWxsYmFja0xpc3QpXG4gICAgfSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbkRhdGEgIT0gbnVsbClcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhU2NoZW1hKG1vZHVsZSwgbW9kdWxlSW5zdGFuY2UsIGRlZmluaXRpb25EYXRhKTtcblxuICAgIHJldHVybiBtb2R1bGVJbnN0YW5jZTtcbn1cblxuXG4vKipcbiAqICB3cmFwcGVyIGZvclxuICovXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZ2VuZXJhdGVGdW5jdGlvbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrTGlzdCkge1xuICAgIGxldCBmdW5jdGlvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGZ1bmNOYW1lIGluIHRoaXMuc3VwcG9ydExpYi5mdW5jdGlvbnMpIHtcbiAgICAgICAgbGV0IGZ1bmNEZXNjID0gdGhpcy5zdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV07XG4gICAgICAgIGxldCBmdW5jdGlvblJlZmVyZW5jZTtcblxuICAgICAgICBpZiAoZnVuY0Rlc2MuYXN5bmMpIHtcbiAgICAgICAgICAgIC8vcGFyYW1zIGhhcyBjYWxsYmFjayBuYW1lIGFzIGZpcnN0IGFyZ3VtZW50IGZvbGxvd2VkIGJ5IHJlZ3VsYXIgcGFyYW1ldGVyc1xuICAgICAgICAgICAgZnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jdGlvbiAoLi4ucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxiYWNrTmFtZSA9IHBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogZnVuY0Rlc2MuZnVuYyguLi5wYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZ1bmNOYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja05hbWU6IGNhbGxiYWNrTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25SZWZlcmVuY2UgPSBmdW5jRGVzYy5mdW5jO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zW1wibGliLlwiICsgZnVuY05hbWVdID0gZnVuY3Rpb25SZWZlcmVuY2U7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbnM7XG59XG5cbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gKG1vZHVsZSwgZGF0YSwgaW5wdXQpIHtcblxuICAgIGxldCBjYWxsYmFja0xpc3QgPSBbXTtcbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBBU0MgcnVubmVyIGlucHV0cyAvLy8vLy8vLy8vLy8vL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIm1vZHVsZVwiKTtcbiAgICBjb25zb2xlLmxvZyhtb2R1bGUpO1xuICAgIGNvbnNvbGUubG9nKFwiZGF0YVwiKTtcbiAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICBjb25zb2xlLmxvZyhcImlucHV0XCIpO1xuICAgIGNvbnNvbGUubG9nKGlucHV0KTtcbiAgICBjb25zb2xlLmxvZyhcIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAgKi9cbiAgICAvL2NvbXBpbGUgYW5kIHVwZGF0ZSBzY2hlbWFcbiAgICBsZXQgaW5zdGFuY2UgPSBhd2FpdCB0aGlzLnByZXBhcmUobW9kdWxlLCBjYWxsYmFja0xpc3QpO1xuICAgIGNvbnNvbGUubG9nKCdpbnN0YW5jZScpO1xuICAgIGNvbnNvbGUubG9nKGluc3RhbmNlKTtcbiAgICBpZiAoaW5zdGFuY2UgPT09ICdvZmZsb2FkaW5nJykge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZyBpbnRlcmNlcHRlZCBpbiBBU0NSdW5uZXIuZXhlYygpJyk7XG4gICAgICAgIHJldHVybiAnb2ZmbG9hZGluZyc7XG5cbiAgICB9XG4gICAgY29uc29sZS5sb2coJ21vZHVsZSBwcmVwYXJlZD0gJyk7XG4gICAgY29uc29sZS5sb2cobW9kdWxlKTtcblxuICAgIGxldCBwcmVwYXJlZFBhcmFtcyA9IFtdO1xuICAgIGlmIChtb2R1bGUuaW5wdXROYW1lcy5sZW5ndGggPiAwKVxuICAgICAgICBwcmVwYXJlZFBhcmFtcyA9IHByZXBhcmVkUGFyYW1zLmNvbmNhdCh0aGlzLmZpbmRQYXJhbUFzc2lnbm1lbnQobW9kdWxlLmlucHV0TmFtZXMsIGlucHV0LCBtb2R1bGUuY29udGV4dCkpO1xuICAgIGlmIChtb2R1bGUuZGF0YUluTmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgcHJlcGFyZWRQYXJhbXMgPSBwcmVwYXJlZFBhcmFtcy5jb25jYXQodGhpcy5maW5kUGFyYW1Bc3NpZ25tZW50KG1vZHVsZS5kYXRhSW5OYW1lcywgZGF0YSwgbW9kdWxlLmNvbnRleHQpKTtcblxuICAgIC8vTW9kdWxlIGlucHV0XG4gICAgY29uc29sZS5sb2coJ01vZHVsZSBzb3VyY2UgY29kZSBpbnB1dCcpO1xuICAgIGNvbnNvbGUubG9nKHByZXBhcmVkUGFyYW1zKTtcblxuICAgIC8vIHJldHVyblZhbHVlIHJldHVybnMgdGhlIHJlc3VsdCBmcm9tIHRoZSBiaW5hcnkgZXhlY3V0aW9uIG9mIHRoZSBXQVNNIG1vZHVsZVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IGluc3RhbmNlLmV4cG9ydHMucnVuKC4uLnByZXBhcmVkUGFyYW1zKTtcbiAgICBjb25zb2xlLmxvZygncmV0dXJuVmFsdWUgPSAnKTtcbiAgICBjb25zb2xlLmxvZyhyZXR1cm5WYWx1ZSk7XG5cbiAgICAvL2ZpbmlzaCBleGVjdXRpbmcgYWxsIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgKCBpZiBjYWxsYmFjayBmdW5jdGlvbnMgYXJlIG5lZWRlZCBieSB0aGUgbW9kdWxlIClcbiAgICB3aGlsZSAoY2FsbGJhY2tMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZW1haW5pbmcgQ2FsbGJhY2s6IFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coY2FsbGJhY2tMaXN0WzBdKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL3RvZG86IG1vbml0b3IgdGhpcz9cbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrTGlzdFswXS5wcm9taXNlO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4ZWN1dGlvbkVycm9yKFwiRXJyb3IgaW4gc3VwcG9ydCBmdW5jdGlvbiBcIiArIGNhbGxiYWNrTGlzdFswXS5mdW5jTmFtZSArIFwiIHdpdGggcGFyYW1ldGVycyBcIiArIGNhbGxiYWNrTGlzdFswXS5wYXJhbXMgKyBcIiFcIiwgbW9kdWxlLmNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tEZXNjcmlwdG9yID0gaW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnNbY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZV07XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrRGVzY3JpcHRvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVmaW5pdGlvbkVycm9yKFwiQ2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBuYW1lIFwiICsgY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZSArIFwiIG5vdCBmb3VuZCFcIiwgbW9kdWxlLmNvbnRleHQpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lICE9IG51bGwgJiYgY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAvL21hdGNoIG51bWJlciBvZiBwYXJhbWV0ZXJzIG9mIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYWxsYmFja1BhcmFtQ291bnQgPSBjYWxsYmFja0Rlc2NyaXB0b3IucGFyYW1ldGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVwYXJlZFJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBjYWxsYmFja1BhcmFtQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZS50eXBlRGVzY3JpcHRvci5leHBvcnRlZEZ1bmN0aW9uc1tjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9Ub2RvOiBkbyBzb21ldGhpbmcgd2l0aCBjYWxsYmFjayByZXR1cm5zP1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVmFsdWUgPSBpbnN0YW5jZS5leHBvcnRzW2NhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWVdKC4uLnByZXBhcmVkUmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbGxiYWNrIHJldHVybjogXCIgKyByZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4ZWN1dGlvbkVycm9yKFwiRXJyb3Igd2hpbGUgY2FsbGluZyBjYWxsYmFjayBmdW5jdGlvbiBcIiArIGNhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWUgKyBcIiB3aXRoIHBhcmFtZXRlcnMgJ1wiICsgcmVzdWx0ICsgXCInIVwiLCBtb2R1bGUuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2tMaXN0LnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbGxlY3RPdXRwdXREYXRhKGluc3RhbmNlLCByZXR1cm5WYWx1ZSk7XG59XG5cbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5jb2xsZWN0T3V0cHV0RGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVJbnN0YW5jZSwgcmV0dXJuVmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG5cbiAgICBpZiAocmV0dXJuVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQub3V0ID0gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdBc0JpbmQnKTtcbiAgICBjb25zb2xlLmxvZyhBc0JpbmQpO1xuICAgIGNvbnNvbGUubG9nKCdtb2R1bGVJbnN0YW5jZScpO1xuICAgIGNvbnNvbGUubG9nKG1vZHVsZUluc3RhbmNlKTtcblxuXG4gICAgZm9yIChsZXQgZXhwb3J0ZWRPYmogaW4gbW9kdWxlSW5zdGFuY2UuZXhwb3J0cykge1xuICAgICAgICBpZiAobW9kdWxlSW5zdGFuY2UuZXhwb3J0c1tleHBvcnRlZE9ial0gaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5HbG9iYWwgJiYgIWV4cG9ydGVkT2JqLnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgICAgICAgICAgcmVzdWx0W2V4cG9ydGVkT2JqXSA9IG1vZHVsZUluc3RhbmNlLmV4cG9ydHNbdGhpcy5jb21waWxlci5pbnRlcm5hbEdldHRlclByZWZpeCArIGV4cG9ydGVkT2JqXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdyZXN1bHQnKTtcbiAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5maW5kUGFyYW1Bc3NpZ25tZW50ID0gZnVuY3Rpb24gKG5hbWVzLCB2YWx1ZXMsIGNvbnRleHQpIHtcbiAgICBsZXQgcHJlcGFyZWRQYXJhbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpIGluIG5hbWVzKSB7XG4gICAgICAgIGxldCBtYXRjaEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5wdXROYW1lIGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc1tpXSA9PT0gaW5wdXROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVkUGFyYW1zLnB1c2godmFsdWVzW2lucHV0TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaEZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIk1pc21hdGNoIGJldHdlZW4gcmVjZWl2ZWQgYW5kIGV4cGVjdGVkIHBhcmFtZXRlcnMhXFxuRXhwZWN0ZWQgXFxcIlwiICsgbmFtZXNbaV0gKyBcIlxcXCIsIGJ1dCBub3QgY29udGFpbmVkIGluIHJlY2VpdmVkIHBhcmFtZXRlcnM6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFBhcmFtcztcbn1cblxuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUucGFyc2VBc3NlbWJseVNjcmlwdFZhcmlhYmxlTmFtZXMgPSBmdW5jdGlvbiAoZGVmaW5pdGlvbkRhdGEpIHtcbiAgICBsZXQgcGFyYW1OYW1lcyA9IEFycmF5KCk7XG4gICAgbGV0IGxpbmVzID0gZGVmaW5pdGlvbkRhdGEuc3BsaXQoXCJcXG5cIik7XG4gICAgZm9yIChsZXQgbGluZSBpbiBsaW5lcykge1xuICAgICAgICBpZiAobGluZXNbbGluZV0uaW5kZXhPZihcImV4cG9ydCBmdW5jdGlvbiBydW5cIikgPT09IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBsaW5lc1tsaW5lXS5zdWJzdHJpbmcobGluZXNbbGluZV0uaW5kZXhPZignKCcpICsgMSwgbGluZXNbbGluZV0uaW5kZXhPZignKScpKS5zcGxpdCgnLCAnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtTmFtZSA9IHBhcmFtc1tpXS5zdWJzdHJpbmcoMCwgcGFyYW1zW2ldLmluZGV4T2YoXCI6XCIpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1OYW1lLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbU5hbWVzO1xufVxuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuY3JlYXRlRGF0YVNjaGVtYSA9IGZ1bmN0aW9uIChtb2R1bGUsIG1vZHVsZUluc3RhbmNlLCBkZWZpbml0aW9uRGF0YSkge1xuICAgIGxldCBydW4gPSBtb2R1bGVJbnN0YW5jZS50eXBlRGVzY3JpcHRvci5leHBvcnRlZEZ1bmN0aW9ucy5ydW47XG5cbiAgICAvL3ZlcmlmeSBlbnRyeXBvaW50IGV4aXN0c1xuICAgIGlmIChydW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIk1pc3NpbmcgZW50cnlwb2ludDogZXhwb3J0ZWQgZnVuY3Rpb24gbmFtZWQgcnVuIGlzIHJlcXVpcmVkLCBhcyBhbiBlbnRyeXBvaW50LlwiLCBtb2R1bGUuY29udGV4dCk7XG5cbiAgICAvL2lucHV0c1xuICAgIC8vcGFyc2UgcGFyYW1ldGVyIG5hbWVzIG9mIHJ1biBmdW5jdGlvbiAtIHJlcGxhY2UsIGlmIEFzc2VtYmx5U2NyaXB0IEFQSSwgdG8gYWNjZXNzIHBhcmFtZXRlciBuYW1lcyBiZWNvbWVzIGF2YWlsYWJsZVxuICAgIGxldCBwYXJhbU5hbWVzID0gdGhpcy5wYXJzZUFzc2VtYmx5U2NyaXB0VmFyaWFibGVOYW1lcyhkZWZpbml0aW9uRGF0YSk7XG5cbiAgICBpZiAocnVuLnBhcmFtZXRlcnMubGVuZ3RoICE9PSBwYXJhbU5hbWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIlBhcmFtZXRlciBsZW5ndGggbWlzbWF0Y2ghIFBhcmFtZXRlcnMgY291bGQgbm90IGJlIHBhcnNlZCBmdWxseSFcIiwgbW9kdWxlLmNvbnRleHQpO1xuXG4gICAgbW9kdWxlLmRhdGFJbk5hbWVzID0gW107XG4gICAgbW9kdWxlLmlucHV0TmFtZXMgPSBbXTtcbiAgICBtb2R1bGUuZGF0YUluU2NoZW1hID0ge3R5cGU6IFwib2JqZWN0XCIsIHByb3BlcnRpZXM6IHt9fTtcbiAgICBtb2R1bGUuaW5wdXRTY2hlbWEgPSB7dHlwZTogXCJvYmplY3RcIiwgcHJvcGVydGllczoge319O1xuXG4gICAgZm9yIChsZXQgaSBpbiBydW4ucGFyYW1ldGVycykge1xuICAgICAgICBpZiAocGFyYW1OYW1lc1tpXS5zdGFydHNXaXRoKHVzZXJJbnB1dFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIG1vZHVsZS5pbnB1dE5hbWVzLnB1c2gocGFyYW1OYW1lc1tpXSk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5pbnB1dFNjaGVtYS5wcm9wZXJ0aWVzW3BhcmFtTmFtZXNbaV1dID0ge3R5cGU6IHJ1bi5wYXJhbWV0ZXJzW2ldfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhSW5OYW1lcy5wdXNoKHBhcmFtTmFtZXNbaV0pO1xuXG4gICAgICAgICAgICBtb2R1bGUuZGF0YUluU2NoZW1hLnByb3BlcnRpZXNbcGFyYW1OYW1lc1tpXV0gPSB7dHlwZTogcnVuLnBhcmFtZXRlcnNbaV19O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9vdXRwdXRzXG4gICAgbW9kdWxlLmRhdGFPdXROYW1lcyA9IFtdO1xuICAgIG1vZHVsZS5kYXRhT3V0U2NoZW1hID0ge3R5cGU6IFwib2JqZWN0XCIsIHByb3BlcnRpZXM6IHt9fTtcbiAgICBmb3IgKGxldCBleHBvcnRlZE9iaiBpbiBtb2R1bGVJbnN0YW5jZS5leHBvcnRzKSB7XG4gICAgICAgIGlmIChtb2R1bGVJbnN0YW5jZS5leHBvcnRzW2V4cG9ydGVkT2JqXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkdsb2JhbCAmJiAhZXhwb3J0ZWRPYmouc3RhcnRzV2l0aChcIl9fXCIpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGF0YU91dE5hbWVzLnB1c2goZXhwb3J0ZWRPYmopO1xuICAgICAgICAgICAgbW9kdWxlLmRhdGFPdXRTY2hlbWEucHJvcGVydGllc1tleHBvcnRlZE9ial0gPSB7dHlwZTogbW9kdWxlSW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnNbdGhpcy5jb21waWxlci5pbnRlcm5hbEdldHRlclByZWZpeCArIGV4cG9ydGVkT2JqXX1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocnVuLnJldHVyblR5cGUgIT09ICd2b2lkJykge1xuICAgICAgICBpZiAoIW1vZHVsZS5kYXRhT3V0TmFtZXMuaW5jbHVkZXMoJ291dCcpKSB7XG4gICAgICAgICAgICBtb2R1bGUuZGF0YU91dE5hbWVzLnB1c2goJ291dCcpO1xuICAgICAgICAgICAgbW9kdWxlLmRhdGFPdXRTY2hlbWEucHJvcGVydGllc1snb3V0J10gPSB7dHlwZTogcnVuLnJldHVyblR5cGV9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRGVmaW5pdGlvbkVycm9yKFwiRHVwbGljYXRlIHBhcmFtZXRlciBjYWxsZWQgJ291dCchIERvIG5vdCB1c2UgJ291dCcgYXMgYSBuYW1lIGZvciBleHBvcnRlZCB2YXJpYWJsZXMhXCIsIG1vZHVsZS5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VtYmx5U2NyaXB0UnVubmVyOyIsIid1c2Ugc3RyaWN0JztcblxuXG4vKipcbiAqIFRoZSBydW5uZXIgZXhlY3V0ZXMgdGhlIGNvbXBpbGVkIGNvZGUgbWFkZSBhdmFpbGFibGUgYnkgdGhlIGNvbXBpbGVyIGFuZCBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgbWF0Y2hpbmcgY29tcGlsZXJcbiAqIEl0IGhhcyB0d28gcGhhc2VzOiBBIHNldHVwIHBoYXNlLCB3ZXJlIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgYW5kIGFuIG9wZXJhdGlvbmFsIHBoYXNlLCB3aGljaCBpcyB1c2VkIHRvIGNvbXBpbGUgY29kZVxuICogVGhlIHNldHVwIG5lZWRzIHRvIGJlIGRvbmUgb25seSBvbmNlLCB3aGlsZSB0aGUgZXhlY3V0aW9uIGNhbiBiZSByZXBlYXRlZCBvbiBkaWZmZXJlbnQgZGF0YS5cbiAqIFxuICogVGhpcyBpcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHdoaWNoIHNob3VsZCBiZSBzdWJjbGFzc2VkIGZvciBlYWNoIHN1cHBvcnRlZCBsYW5ndWFnZVxuICogXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICovXG5mdW5jdGlvbiBSdW5uZXIoKSB7XG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzLCBpZiBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZC5cbiAgICAqIEBuYW1lIEV4ZWN1dGlvbk1hbmFnZXIjbW9kdWxlc1RvdGFsXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHRoaXMuc2V0dXBDb21wbGV0ZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIHByb3ZpZGVkIGJpbmFyeSBvciBzb3VyY2UgY29kZVxuICogQHBhcmFtIHttb2R1bGV9IG1vZHVsZSAtIG1vZHVsZSBjb250YWluaW5nIHNvdXJjZSBjb2RlL2JpbmFyeSB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gZGF0YSBwYXNzZWQgdG8gdGhlIHByb2Nlc3Npbmcgbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gaW5wdXRzIHBhc3NlZCB0byB0aGUgcHJvY2Vzc2luZyBub2RlXG4gKiBAYWJzdHJhY3RcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKG1vZHVsZSwgZGF0YSwgaW5wdXQpIHtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBwcm92aWRlZCBtb2R1bGUgZm9yIGV4ZWN1dGlvbjpcbiAqIC0gY29tcGlsZSwgaWYgbm90IGFscmVhZHkgY29tcGlsZWRcbiAqIC0gdXBkYXRlIHJlZmVyZW5jZXMgdG8gYmluYXJ5L2hhc2hcbiAqIC0gdXBkYXRlIGRhdGEgc2NoZW1lc1xuICogVGhpcyBpcyBhbHNvIHVzZWQgdG8gdmFsaWRhdGUgbmV3IHNvdXJjZSBjb2RlIHdoaWxlIGVkaXRpbmdcbiAqXG4gKiBAcGFyYW0ge21vZHVsZX0gbW9kdWxlIC0gbW9kdWxlIGNvbnRhaW5pbmcgc291cmNlIGNvZGUvYmluYXJ5IHRvIHJ1blxuICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSByZWFkeSB0byBleGVjdXRlXG4gKiBAdGhyb3dzIENvbXBpbGVFcnJvclxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5SdW5uZXIucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAobW9kdWxlKSB7fVxuXG4vKipcbiAqIEVuZCB1c2VyIGZyaWVuZGx5IE5hbWVcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5uYW1lID0gXCJBYnN0cmFjdCBSdW5uZXJcIlxuXG4vKipcbiAqIElEIHVzZWQgaW50ZXJuYWxseSwgdG8gaWRlbnRpZnkgcnVubmVyc1xuICovXG5SdW5uZXIucHJvdG90eXBlLmlkID0gXCJhYnN0cmFjdF9ydW5uZXJcIlxuXG4vKipcbiAqIEByZXR1cm4gRGVzY3JpcHRpb24gb2YgdGhlIHJ1bm5lciBpbmNsdWRpbmcgYSBsaW5rIHRvIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGFuZCBzdXBwb3J0IGxpYnJhcnkgZXhwbGFuYXRpb24gYXMgaHRtbC5cbiAqIEBhYnN0cmFjdFxuICovXG5SdW5uZXIucHJvdG90eXBlLmdldEhUTUxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHt9XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIEhhc2ggdXNlZCB0byBjb21wYXJlIGJpbmFyaWVzXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiaW5hcnkgLSBiaW5hcnkgdG8gaGFzaFxuICogQHJldHVybiBoYXNoXG4gKlxuICovXG5SdW5uZXIucHJvdG90eXBlLmNhbGN1bGF0ZUJpbmFyeUhhc2ggPSBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvcihsZXQgaSBpbiBiaW5hcnkpIHtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA4KS1oYXNoKStiaW5hcnlbaV07XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuXG4vKipcbiAqIERldGVybWluZSBkYXRhIHNjaGVtYSBiYXNlZCBvbiBzb3VyY2UvYmluYXJ5IGFuZCB3cml0ZSByZXN1bHRzIHRvIHRoZSBtb2R1bGVcbiAqIFRoZSBwcm9wZXJ0aWVzIGRhdGFJblNjaGVtYSwgZGF0YU91dFNjaGVtYSwgaW5wdXRTY2hlbWEsIGRhdGFJbk5hbWVzLCBkYXRhT3V0TmFtZXMsIGlucHV0TmFtZXMgb2YgdGhlIG1vZHVsZSBjYW4gYmUgd3JpdHRlblxuICogQ2FsbGVkIGF1dG9tYXRpY2FsbHksIHdoZW4gbmV3IHNvdXJjZSBpcyBjb21waWxlZCwgYnV0IGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IHJlZ2VuZXJhdGUgZGF0YSBzY2hlbWFcbiAqXG4gKiBAcGFyYW0ge21vZHVsZX0gbW9kdWxlIC0gbW9kdWxlIGNvbnRhaW5pbmcgc291cmNlIGNvZGUvYmluYXJ5XG4gKlxuICogQGFic3RyYWN0XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuY3JlYXRlRGF0YVNjaGVtYSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSdW5uZXIiLCIndXNlIHN0cmljdCc7XG52YXIgSnNUb2tlbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtdG9rZW5zL2luZGV4LmpzJyk7XG4vKipcbiAqIFJlc3BvbnNpYmxlIHRvIHZlcmlmeSBpZiBhIHN0cmluZyBjb21wbGllcyB0byBhIHNhZmUgIEphdmFTY3JpcHQgc3Vic2V0LlxuICogQSBibGFja2xpc3QgdXNlZCB0byBlbnN1cmUgbm8gaGFybWZ1bCBvcGVyYXRpb24gY2FuIGJlIHBlcmZvcm1lZCBieSB1c2VyIGRlZmluZWQgc2NyaXB0cy5cbiAqIEN1cnJlbnRseSB0aGUgZm9sbG93aW5nIHRva2VucyBhcmUgZm9yYmlkZGVuOlxuICogYXJndW1lbnRzLCBjYWxsZWUsIGNhbGxlciwgY29uc3RydWN0b3IsIGV2YWwsIHByb3RvdHlwZSwgc3RhY2ssIHVud2F0Y2gsIHZhbHVlT2YsIHdhdGNoLCBfX3Byb3RvX18sIF9fcGFyZW50X18sICd0aGlzJywgd2luZG93LCBkb2N1bWVudCwgJ1snLCAnXScsIEZ1bmN0aW9uLCAnd2l0aCcsIHVuZXZhbCwgdG9Tb3VyY2UsIHNldFRpbWVvdXQsIHNldEludGVydmFsXG4gKiBVc2Uge0BsaW5rIFN3ZXZhU2NyaXB0I2dldH0gYXMgYSByZXBsYWNlbWVudCBmb3IgW10uXG4gKiBcbiAqIEFkZGl0aW9uYWxseSBnbG9iYWwgdmFyaWFibGVzIGFyZSBtYXNrZWQuXG4gKiBAY29uc3RydWN0b3IgXG4gKi9cbmZ1bmN0aW9uIFN3ZXZhU2NyaXB0KCkge1xuICAgIC8qKlxuICAgICogTGlzdCBvZiBmb3JiaWRkZW4gdG9rZW5zLCB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIEphdmFTY3JpcHQgc3Vic2V0LlxuICAgICogQG5hbWUgU3dldmFTY3JpcHQjZm9yYmlkZGVuTGlzdFxuICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBib29sZWFuPn1cbiAgICAqL1xuICAgIHRoaXMuZm9yYmlkZGVuTGlzdCA9IHtcbiAgICAgICAgYXJndW1lbnRzOiB0cnVlLFxuICAgICAgICBjYWxsZWU6IHRydWUsXG4gICAgICAgIGNhbGxlcjogdHJ1ZSxcbiAgICAgICAgY29uc3RydWN0b3I6IHRydWUsXG4gICAgICAgIGV2YWw6IHRydWUsXG4gICAgICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgIHVud2F0Y2g6IHRydWUsXG4gICAgICAgIHZhbHVlT2Y6IHRydWUsXG4gICAgICAgIHdhdGNoOiB0cnVlLFxuXG4gICAgICAgIF9fcHJvdG9fXzogdHJ1ZSxcbiAgICAgICAgX19wYXJlbnRfXzogdHJ1ZSxcbiAgICAgICAgJ3RoaXMnOiB0cnVlLFxuICAgICAgICB3aW5kb3c6IHRydWUsXG4gICAgICAgIGRvY3VtZW50OiB0cnVlLFxuICAgICAgICAnWyc6IHRydWUsXG4gICAgICAgICddJzogdHJ1ZSxcbiAgICAgICAgRnVuY3Rpb246IHRydWUsXG4gICAgICAgICd3aXRoJzogdHJ1ZSxcbiAgICAgICAgdW5ldmFsOiB0cnVlLFxuICAgICAgICB0b1NvdXJjZTogdHJ1ZSxcbiAgICAgICAgc2V0VGltZW91dDogdHJ1ZSxcbiAgICAgICAgc2V0SW50ZXJ2YWw6IHRydWVcbiAgICB9XG4gICAgLyoqXG4gICAgKiBMaXN0IG9mIGFsbG93ZWQgZ2xvYmFsIHZhcmlhYmxlcywgdGhhdCBzaG91bGQgbm90IGJlIG1hc2tlZC5cbiAgICAqIFRoaXMgaXMgY3VycmVudGx5OiBNYXRoLCBjb25zb2xlIFxuICAgICogQG5hbWUgU3dldmFTY3JpcHQjYWxsb3dlZEdsb2JhbHNcbiAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59XG4gICAgKi9cbiAgICB0aGlzLmFsbG93ZWRHbG9iYWxzID0ge1xuICAgICAgICBNYXRoOiB0cnVlLFxuICAgICAgICBjb25zb2xlOiB0cnVlLFxuICAgICAgICAndHJ1ZSc6IHRydWUsXG4gICAgICAgICdmYWxzZSc6IHRydWVcbiAgICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgYSBKYXZhU2NyaXB0IGNvZGUgY29tcGxpZXMgdG8gdGhlIHNhZmVyIEphdmFTY3JpcHQgc3Vic2V0LlxuICogRG9lcyBub3QgcmV3cml0ZSBvciBjaGFuZ2UgdGhlIGNvZGUsIHRoZXJlZm9yIHlvdSBzaG91bGQgREVOWSBhbnl0aGluZywgdGhhdCBpcyBjb25zaWRlcmVkIGhhcm1mdWwgYnkgdGhpcyBmdW5jdGlvbi5cbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBUaGUgSmF2YVNjcmlwdCBjb2RlIHRvIHZlcmlmeSBmb3Igc2FmZXR5LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUsIGlmIHRoZSBjb2RlIGRvZXMgbm90IGNvbnRhaW4gZm9yYmlkZGVuIHRva2Vucy5cbiAqL1xuU3dldmFTY3JpcHQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy9nZXQgYW4gYXJyYXkgb2YgdG9rZW5zIHVzaW5nIHRoZSB0b2tlbml6ZXIgKGV4dGVybmFsIGxpYnJhcnkpXG4gICAgICAgIHZhciB0b2tlbnMgPSBjb2RlLm1hdGNoKEpzVG9rZW5zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZS5tZXNzYWdlXG4gICAgICAgIH1cbiAgICB9XG4gICBcbiAgICAvL2NoZWNrIGZvciBlYWNoIHRva2VuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldLnRyaW0oKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vaWYgdG9rZW4gbm9uIGVtcHR5OiBpcyBpdCBpbiB0aGUgYmxhY2tsaXN0P1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9yYmlkZGVuTGlzdC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCB1c2FnZSBvZiAnICsgdG9rZW5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXG4gICAgfVxuXG4gICAgLy9pZiBubyByZXR1cm4gcmVhY2hlZCBiZWZvcmUsIHdlIGNhbiBhc3N1bWUgdGhlcmUgd2FzIG5vIGZvcmJpZGRlbiB0b2tlbiBwcmVzZW50XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIGVycm9yOiAnJ1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGZvcmJpZGRlbiBbXSBhY2Nlc3NvciwgYnkgY2hlY2tpbmcgdGhlIHByb3BlcnR5IG5hbWUgZHVyaW5nIHJ1bnRpbWUuXG4gKiBJZiBhIGZvcmJpZGRlbiBwcm9wZXJ0eSAoc2VlIHtAbGluayBTd2V2YVNjcmlwdH0pIGlzIHVzZWQsIHRoZSBwcm9wZXJ0eSBpcyBub3QgYWNjZXNzZWQuXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlcXVpcmVkLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZSB0aGUgdmFsdWUgZnJvbS5cbiAqIHJldHVybnMge09iamVjdHxib29sZWFufHN0cmluZ3xudW1iZXJ9IC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgaWYgYW4gaWxsZWdhbCBwcm9wZXJ0eSBuYW1lIGlzIHVzZWQgbnVsbC5cbiAqL1xuU3dldmFTY3JpcHQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgdmFyIGZvcmJpZGRlbkxpc3QgPSB7XG4gICAgICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICAgICAgY2FsbGVlOiB0cnVlLFxuICAgICAgICBjYWxsZXI6IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cnVlLFxuICAgICAgICBldmFsOiB0cnVlLFxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICB1bndhdGNoOiB0cnVlLFxuICAgICAgICB2YWx1ZU9mOiB0cnVlLFxuICAgICAgICB3YXRjaDogdHJ1ZSxcblxuICAgICAgICBfX3Byb3RvX186IHRydWUsXG4gICAgICAgIF9fcGFyZW50X186IHRydWUsXG4gICAgICAgICd0aGlzJzogdHJ1ZSxcbiAgICAgICAgd2luZG93OiB0cnVlLFxuICAgICAgICBkb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgJ1snOiB0cnVlLFxuICAgICAgICAnXSc6IHRydWUsXG4gICAgICAgIEZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICAnd2l0aCc6IHRydWUsXG4gICAgICAgIHVuZXZhbDogdHJ1ZSxcbiAgICAgICAgdG9Tb3VyY2U6IHRydWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRydWUsXG4gICAgICAgIHNldEludGVydmFsOiB0cnVlXG4gICAgfVxuICAgIC8vaWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIGNoZWNrIGZvciBiZWluZyBpbiB0aGUgYmxhY2tsaXN0XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFvYmplY3Qud2luZG93ICYmICFmb3JiaWRkZW5MaXN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9udW1iZXJzIGFyZSBub3QgY2hlY2tlZCBmb3IgYmVpbmcgaW4gdGhlIGJsYWNrbGlzdFxuICAgIGVsc2UgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcignSWxsZWdhbCBwcm9wZXJ0eSBuYW1lOiAnICsgcHJvcGVydHkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5Td2V2YVNjcmlwdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgdmFyIGZvcmJpZGRlbkxpc3QgPSB7XG4gICAgICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICAgICAgY2FsbGVlOiB0cnVlLFxuICAgICAgICBjYWxsZXI6IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cnVlLFxuICAgICAgICBldmFsOiB0cnVlLFxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICB1bndhdGNoOiB0cnVlLFxuICAgICAgICB2YWx1ZU9mOiB0cnVlLFxuICAgICAgICB3YXRjaDogdHJ1ZSxcblxuICAgICAgICBfX3Byb3RvX186IHRydWUsXG4gICAgICAgIF9fcGFyZW50X186IHRydWUsXG4gICAgICAgICd0aGlzJzogdHJ1ZSxcbiAgICAgICAgd2luZG93OiB0cnVlLFxuICAgICAgICBkb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgJ1snOiB0cnVlLFxuICAgICAgICAnXSc6IHRydWUsXG4gICAgICAgIEZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICAnd2l0aCc6IHRydWUsXG4gICAgICAgIHVuZXZhbDogdHJ1ZSxcbiAgICAgICAgdG9Tb3VyY2U6IHRydWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRydWUsXG4gICAgICAgIHNldEludGVydmFsOiB0cnVlXG4gICAgfVxuICAgIC8vaWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIGNoZWNrIGZvciBiZWluZyBpbiB0aGUgYmxhY2tsaXN0XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFvYmplY3Qud2luZG93ICYmICFmb3JiaWRkZW5MaXN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSWxsZWdhbCBwcm9wZXJ0eSBuYW1lOiAnICsgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vbnVtYmVycyBhcmUgbm90IGNoZWNrZWQgZm9yIGJlaW5nIGluIHRoZSBibGFja2xpc3RcbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNhbml0aXplcyBnaXZlbiBKYXZhc2NyaXB0IGNvZGUgYnkgdmVyaWZ5aW5nIGlmIGl0IGlzIGEgc2FmZXIgc3Vic2V0IG9mIEphdmFTY3JpcHQgYW5kIG1hc2tpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cbiAqIHtAbGluayBTd2V2YVNjcmlwdCN2ZXJpZnl9IGlzIHBlcmZvcm1lZCBpbnRlcm5hbGx5LCBzbyB5b3UgZG8gbm90IG5lZWQgdG8gdmVyaWZ5IGV4cGxpY2l0bHkgYmVmb3JlaGFuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gVGhlIEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gc2FuaXRpemUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIC0gQSBjYWxsYmFjayBjYWxsZWQsIHdoZW4gYW4gZXJyb3Igb2NjdXJzLCBoYXMgYSBzdHJpbmcgYXMgYSBwYXJhbWV0ZXIgd2l0aCB0aGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5ze2Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24sIHRoYXQgY2FuIGJlIGV4ZWN1dGVkXG4gKi9cblN3ZXZhU2NyaXB0LnByb3RvdHlwZS5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChjb2RlLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgLy9hbGwgaW4gb25lIGxpbmVcbiAgICAvL2NvZGUgPSBjb2RlLnJlcGxhY2UoLyhcXHJcXG58XFxufFxccikvZ20sIFwiXCIpOyBcbiAgIFxuICAgIHZhciBlcnJvciA9ICcnO1xuICAgIC8vZmlyc3QgbWFrZSBzdXJlIGl0IGlzIHZhbGlkIFN3ZXZhU2NyaXB0XG4gICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZlcmlmeShjb2RlKTsgICAgXG4gICAgaWYgKHZhbGlkYXRpb24udmFsaWQpIHsgICAgICAgIFxuICAgICAgICB2YXIgYWxsb3dlZEdsb2JhbHMgPSB0aGlzLmFsbG93ZWRHbG9iYWxzO1xuICAgICAgICAvL2dldCBhbGwgZ2xvYmFsIHZhcmlhYmxlcyBleGNlcHQgdGhlIGV4Y2VwdGlvbnMgd2UgZGVmaW5lZCBpbiB7QGxpbmsgU3dldmFTY3JpcHQjYWxsb3dlZEdsb2JhbHN9XG4gICAgICAgIHZhciBnbG9iYWxzID0gT2JqZWN0LmtleXMod2luZG93KS5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuICFhbGxvd2VkR2xvYmFscy5oYXNPd25Qcm9wZXJ0eShvYmopXG4gICAgICAgIH0pLmpvaW4oJywnKTtcbiAgICAgICAgLy93ZSB3YW50IHRvIHNoYWRvdyBhbGwgZ2xvYmFsIHZhcmlhYmxlcyBleGNlcHQgdGhlIG9uZXMgd2UgYWxsb3csIGJ5IGRlY2xhcmluZyB0aGVtIGFzIGxvY2FsIHZhcmlhYmxlc1xuICAgICAgICAvL2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcG9zdHMvMjY5MTc5MzgvcmV2aXNpb25zXG4gICAgICAgIC8vdmFyIGZ1bmNSZWcgPSAvZnVuY3Rpb24gKlxcKChbXigpXSopXFwpWyBcXG5cXHRdKnsoLiopfS9nbWk7XG4gICAgICAgIHZhciBmdW5jUmVnID0gL2Z1bmN0aW9uXFxzKlxcKChbXigpXSopXFwpXFxzXFx7KCgufFxcbikqKVxcfS9nbWk7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmNSZWcuZXhlYyhjb2RlKTtcbiAgICAgICBcbiAgICAgICAgLy93ZSBleHRyYWN0IGZ1bnRpb24gaGVhZGVyIChkZWNybGFyYXRpb24gd2l0aCBwYXJhbWV0ZXJzKSBhbmQgYm9keVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9lbmZvcmNlIHN0cmljdCBiZWhhdmlvciwgc2hhZG93IGdsb2JhbHMsIGFwcGVuZCB2ZXJpZmllZCBjb2RlXG4gICAgICAgICAgICB2YXIgZm5fdGV4dCA9ICdcInVzZSBzdHJpY3RcIjsgdmFyICcgKyBnbG9iYWxzICsgJzsnICsgbWF0Y2hbMl0gKyAnOyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBmbiA9IG5ldyBGdW5jdGlvbihtYXRjaFsxXS5zcGxpdCgnLCcpLCBmbl90ZXh0KTsvL2dlbmVyYXRlIHNhbml0aXplZCBmdW5jdGlvblxuXG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9ICdOb3QgYSB2YWxpZCBKUyBmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9yID0gdmFsaWRhdGlvbi5lcnJvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnJvckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTd2V2YVNjcmlwdDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21waWxlU2NoZW1hID0gcmVxdWlyZSgnLi9jb21waWxlJylcbiAgICAsIHJlc29sdmUgPSByZXF1aXJlKCcuL2NvbXBpbGUvcmVzb2x2ZScpXG4gICAgLCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKVxuICAgICwgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21waWxlL3NjaGVtYV9vYmonKVxuICAgICwgc3RhYmxlU3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdGFibGUtc3RyaW5naWZ5JylcbiAgICAsIGZvcm1hdHMgPSByZXF1aXJlKCcuL2NvbXBpbGUvZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqdjtcblxudmFyIE1FVEFfU0NIRU1BX0lEID0gJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hJztcbnZhciBTQ0hFTUFfVVJJX0ZPUk1BVCA9IC9eKD86KD86W2Etel1bYS16MC05Ky0uXSo6KT9cXC9cXC8pP1teXFxzXSokL2k7XG5mdW5jdGlvbiBTQ0hFTUFfVVJJX0ZPUk1BVF9GVU5DKHN0cikge1xuICAgIHJldHVybiBTQ0hFTUFfVVJJX0ZPUk1BVC50ZXN0KHN0cik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBVc2FnZTogYEFqdihvcHRzKWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gYWp2IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEFqdihvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFqdikpIHJldHVybiBuZXcgQWp2KG9wdHMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5fc2NoZW1hcyA9IHt9O1xuICAgIHRoaXMuX3JlZnMgPSB7fTtcbiAgICB0aGlzLl9mb3JtYXRzID0gZm9ybWF0cyh0aGlzLm9wdHMuZm9ybWF0KTtcbiAgICB0aGlzLl9jYWNoZSA9IHRoaXMub3B0cy5jYWNoZSB8fCBuZXcgQ2FjaGU7XG4gICAgdGhpcy5fbG9hZGluZ1NjaGVtYXMgPSB7fTtcblxuICAgIC8vIHRoaXMgaXMgZG9uZSBvbiBwdXJwb3NlLCBzbyB0aGF0IG1ldGhvZHMgYXJlIGJvdW5kIHRvIHRoZSBpbnN0YW5jZVxuICAgIC8vICh3aXRob3V0IHVzaW5nIGJpbmQpIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCB3aXRob3V0IHRoZSBpbnN0YW5jZVxuICAgIHRoaXMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICB0aGlzLmNvbXBpbGUgPSBjb21waWxlO1xuICAgIHRoaXMuY29tcGlsZUFzeW5jID0gY29tcGlsZUFzeW5jO1xuICAgIHRoaXMuYWRkU2NoZW1hID0gYWRkU2NoZW1hO1xuICAgIHRoaXMuYWRkTWV0YVNjaGVtYSA9IGFkZE1ldGFTY2hlbWE7XG4gICAgdGhpcy52YWxpZGF0ZVNjaGVtYSA9IHZhbGlkYXRlU2NoZW1hO1xuICAgIHRoaXMuZ2V0U2NoZW1hID0gZ2V0U2NoZW1hO1xuICAgIHRoaXMucmVtb3ZlU2NoZW1hID0gcmVtb3ZlU2NoZW1hO1xuICAgIHRoaXMuYWRkRm9ybWF0ID0gYWRkRm9ybWF0O1xuICAgIHRoaXMuZXJyb3JzVGV4dCA9IGVycm9yc1RleHQ7XG5cbiAgICB0aGlzLl9jb21waWxlID0gX2NvbXBpbGU7XG5cbiAgICBhZGRJbml0aWFsU2NoZW1hcygpO1xuICAgIGlmICh0aGlzLm9wdHMuZm9ybWF0cykgYWRkSW5pdGlhbEZvcm1hdHMoKTtcblxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgZGF0YSB1c2luZyBzY2hlbWFcbiAgICAgKiBTY2hlbWEgd2lsbCBiZSBjb21waWxlZCBhbmQgY2FjaGVkICh1c2luZyBzZXJpYWxpemVkIEpTT04gYXMga2V5LiBbanNvbi1zdGFibGUtc3RyaW5naWZ5XShodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svanNvbi1zdGFibGUtc3RyaW5naWZ5KSBpcyB1c2VkIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFLZXlSZWYga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgICAqIEBwYXJhbSAge0FueX0gZGF0YSB0byBiZSB2YWxpZGF0ZWRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB2YWxpZGF0aW9uIHJlc3VsdC4gRXJyb3JzIGZyb20gdGhlIGxhc3QgdmFsaWRhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBpbiBgYWp2LmVycm9yc2AgKGFuZCBhbHNvIGluIGNvbXBpbGVkIHNjaGVtYTogYHNjaGVtYS5lcnJvcnNgKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIGRhdGEpIHtcbiAgICAgICAgdmFyIHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2ID0gZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXYpIHRocm93IG5ldyBFcnJvcignbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIicgKyBzY2hlbWFLZXlSZWYgKyAnXCInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWFPYmogPSBfYWRkU2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB2ID0gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IF9jb21waWxlKHNjaGVtYU9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBzZWxmLmVycm9ycyA9IHYuZXJyb3JzO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdmFsaWRhdGluZyBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hKSB7XG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBfYWRkU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hIHdpdGggYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgbWlzc2luZyBzY2hlbWFzLlxuICAgICAqIGBsb2FkU2NoZW1hYCBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHNjaGVtYSB1cmkgYW5kIG5vZGUtc3R5bGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIG5vZGUtc3R5bGUgY2FsbGJhY2ssIGl0IGlzIGFsd2F5cyBjYWxsZWQgd2l0aCAyIHBhcmFtZXRlcnM6IGVycm9yIChvciBudWxsKSBhbmQgdmFsaWRhdGluZyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21waWxlQXN5bmMoc2NoZW1hLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2NoZW1hT2JqO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NoZW1hT2JqID0gX2FkZFNjaGVtYShzY2hlbWEpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hT2JqLnZhbGlkYXRlKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCwgc2NoZW1hT2JqLnZhbGlkYXRlKTsgfSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLm9wdHMubG9hZFNjaGVtYSAhPSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBfY29tcGlsZUFzeW5jKHNjaGVtYSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaGVtYSwgY2FsbGJhY2ssIGZpcnN0Q2FsbCkge1xuICAgICAgICB2YXIgdmFsaWRhdGU7XG4gICAgICAgIHRyeSB7IHZhbGlkYXRlID0gY29tcGlsZShzY2hlbWEpOyB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmIChlLm1pc3NpbmdTY2hlbWEpIGxvYWRNaXNzaW5nU2NoZW1hKGUpO1xuICAgICAgICAgICAgZWxzZSBkZWZlckNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmVyQ2FsbGJhY2sobnVsbCwgdmFsaWRhdGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKGUpIHtcbiAgICAgICAgICAgIHZhciByZWYgPSBlLm1pc3NpbmdTY2hlbWE7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcmVmc1tyZWZdIHx8IHNlbGYuX3NjaGVtYXNbcmVmXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdTY2hlbWEgJyArIHJlZiArICcgaXMgbG9hZGVkIGJ1dCcgKyBlLm1pc3NpbmdSZWYgKyAnY2Fubm90IGJlIHJlc29sdmVkJykpO1xuICAgICAgICAgICAgdmFyIF9jYWxsYmFja3MgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgICAgICAgaWYgKF9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIF9jYWxsYmFja3MgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXSA9IFtfY2FsbGJhY2tzLCBzY2hlbWFMb2FkZWRdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc1tfY2FsbGJhY2tzLmxlbmd0aF0gPSBzY2hlbWFMb2FkZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl0gPSBzY2hlbWFMb2FkZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5vcHRzLmxvYWRTY2hlbWEocmVmLCBmdW5jdGlvbiAoZXJyLCBzY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jYWxsYmFja3MgPSBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FsbGJhY2tzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2tzKGVyciwgc2NoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPF9jYWxsYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc1tpXShlcnIsIHNjaCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNjaGVtYUxvYWRlZChlcnIsIHNjaCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHNlbGYuX3JlZnNbcmVmXSB8fCBzZWxmLl9zY2hlbWFzW3JlZl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNjaGVtYShzY2gsIHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2NvbXBpbGVBc3luYyhzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZWZlckNhbGxiYWNrKGVyciwgdmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdENhbGwpIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVyciwgdmFsaWRhdGUpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgY2FsbGJhY2soZXJyLCB2YWxpZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gc2NoZW1hIHNjaGVtYSBvciBhcnJheSBvZiBzY2hlbWFzLiBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpe1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykgYWRkU2NoZW1hKHNjaGVtYVtpXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuIGtleS9pZCBoYXZlICMgaW5zaWRlP1xuICAgICAgICBrZXkgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleSB8fCBzY2hlbWEuaWQpO1xuICAgICAgICBjaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB2YXIgc2NoZW1hT2JqID0gc2VsZi5fc2NoZW1hc1trZXldID0gX2FkZFNjaGVtYShzY2hlbWEsIF9za2lwVmFsaWRhdGlvbik7XG4gICAgICAgIHNjaGVtYU9iai5tZXRhID0gX21ldGE7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAgKiByZW1vdmVBZGRpdGlvbmFsIG9wdGlvbiBpcyBhbHdheSBzZXQgdG8gZmFsc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBvcHRpb25hbCBzY2hlbWEga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTWV0YVNjaGVtYShzY2hlbWEsIGtleSwgX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGFkZFNjaGVtYShzY2hlbWEsIGtleSwgX3NraXBWYWxpZGF0aW9uLCB0cnVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHNjaGVtYVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gc2NoZW1hIHNjaGVtYSB0byB2YWxpZGF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHZhciAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWEgfHwgTUVUQV9TQ0hFTUFfSUQ7XG4gICAgICAgIHZhciBjdXJyZW50VXJpRm9ybWF0ID0gc2VsZi5fZm9ybWF0cy51cmk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHMudXJpID0gdHlwZW9mIGN1cnJlbnRVcmlGb3JtYXQgPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gU0NIRU1BX1VSSV9GT1JNQVRfRlVOQ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogU0NIRU1BX1VSSV9GT1JNQVQ7XG4gICAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHMudXJpID0gY3VycmVudFVyaUZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBpbGVkIHNjaGVtYSBmcm9tIHRoZSBpbnN0YW5jZSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleVJlZiBga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIChgc2NoZW1hLmlkYCBvciByZXNvbHZlZCBpZCkuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHNjaGVtYSB2YWxpZGF0aW5nIGZ1bmN0aW9uICh3aXRoIHByb3BlcnR5IGBzY2hlbWFgKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKGtleVJlZik7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYU9iaikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuIHNjaGVtYU9iai52YWxpZGF0ZSB8fCBfY29tcGlsZShzY2hlbWFPYmopO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzogcmV0dXJuIGdldFNjaGVtYShzY2hlbWFPYmopO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBfZ2V0U2NoZW1hT2JqKGtleVJlZikge1xuICAgICAgICBrZXlSZWYgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleVJlZik7XG4gICAgICAgIHJldHVybiBzZWxmLl9zY2hlbWFzW2tleVJlZl0gfHwgc2VsZi5fcmVmc1trZXlSZWZdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNhY2hlZCBzY2hlbWFcbiAgICAgKiBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBzY2hlbWFLZXlSZWYga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FjaGUuZGVsKHNjaGVtYU9iai5qc29uU3RyKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHZhciBqc29uU3RyID0gc3RhYmxlU3RyaW5naWZ5KHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FjaGUuZGVsKGpzb25TdHIpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNjaGVtYUtleVJlZi5pZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3JlZnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX2FkZFNjaGVtYShzY2hlbWEsIHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSBzaG91bGQgYmUgb2JqZWN0Jyk7XG4gICAgICAgIHZhciBqc29uU3RyID0gc3RhYmxlU3RyaW5naWZ5KHNjaGVtYSk7XG4gICAgICAgIHZhciBjYWNoZWQgPSBzZWxmLl9jYWNoZS5nZXQoanNvblN0cik7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgICAgICAgdmFyIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZChzY2hlbWEuaWQpO1xuICAgICAgICBpZiAoaWQpIGNoZWNrVW5pcXVlKGlkKTtcblxuICAgICAgICB2YXIgb2sgPSBza2lwVmFsaWRhdGlvbiB8fCBzZWxmLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgIHx8IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ3NjaGVtYSBpcyBpbnZhbGlkOicgKyBlcnJvcnNUZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRzLnZhbGlkYXRlU2NoZW1hID09ICdsb2cnKSBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxSZWZzID0gcmVzb2x2ZS5pZHMuY2FsbChzZWxmLCBzY2hlbWEpO1xuXG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBuZXcgU2NoZW1hT2JqZWN0KHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgbG9jYWxSZWZzOiBsb2NhbFJlZnMsXG4gICAgICAgICAgICBqc29uU3RyOiBqc29uU3RyLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaWRbMF0gIT0gJyMnKSBzZWxmLl9yZWZzW2lkXSA9IHNjaGVtYU9iajtcbiAgICAgICAgc2VsZi5fY2FjaGUucHV0KGpzb25TdHIsIHNjaGVtYU9iaik7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYU9iajtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIF9jb21waWxlKHNjaGVtYU9iaiwgcm9vdCkge1xuICAgICAgICBpZiAoc2NoZW1hT2JqLmNvbXBpbGluZykge1xuICAgICAgICAgICAgc2NoZW1hT2JqLnZhbGlkYXRlID0gY2FsbFZhbGlkYXRlO1xuICAgICAgICAgICAgY2FsbFZhbGlkYXRlLnNjaGVtYSA9IHNjaGVtYU9iai5zY2hlbWE7XG4gICAgICAgICAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxWYWxpZGF0ZS5yb290ID0gcm9vdCA/IHJvb3QgOiBjYWxsVmFsaWRhdGU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFZhbGlkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYU9iai5jb21waWxpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjdXJyZW50UkEgPSBzZWxmLm9wdHMucmVtb3ZlQWRkaXRpb25hbDtcbiAgICAgICAgaWYgKGN1cnJlbnRSQSAmJiBzY2hlbWFPYmoubWV0YSkgc2VsZi5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIHY7XG4gICAgICAgIHRyeSB7IHYgPSBjb21waWxlU2NoZW1hLmNhbGwoc2VsZiwgc2NoZW1hT2JqLnNjaGVtYSwgcm9vdCwgc2NoZW1hT2JqLmxvY2FsUmVmcyk7IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VycmVudFJBKSBzZWxmLm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9IGN1cnJlbnRSQTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYU9iai52YWxpZGF0ZSA9IHY7XG4gICAgICAgIHNjaGVtYU9iai5yZWZzID0gdi5yZWZzO1xuICAgICAgICBzY2hlbWFPYmoucmVmVmFsID0gdi5yZWZWYWw7XG4gICAgICAgIHNjaGVtYU9iai5yb290ID0gdi5yb290O1xuICAgICAgICByZXR1cm4gdjtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gc2NoZW1hT2JqLnZhbGlkYXRlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGVycm9yc1RleHQoZXJyb3JzLCBvcHRzKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBzZWxmLmVycm9ycztcbiAgICAgICAgaWYgKCFlcnJvcnMpIHJldHVybiAnTm8gZXJyb3JzJztcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fCAnLCAnO1xuICAgICAgICB2YXIgZGF0YVZhciA9IG9wdHMuZGF0YVZhciB8fCAnZGF0YSc7XG5cbiAgICAgICAgdmFyIHRleHQgPSBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uKHR4dCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgPyB0eHQgKyBkYXRhVmFyICsgZS5kYXRhUGF0aCArICcgJyArIGUubWVzc2FnZSArIHNlcGFyYXRvciA6IHR4dDtcbiAgICAgICAgfSwgJycpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCAtc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09ICdzdHJpbmcnKSBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gICAgICAgIHNlbGYuX2Zvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcygpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0cy5tZXRhICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIG1ldGFTY2hlbWEgPSByZXF1aXJlKCcuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbicpO1xuICAgICAgICAgICAgYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLl9yZWZzWydodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYSddID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0c1NjaGVtYXMgPSBzZWxmLm9wdHMuc2NoZW1hcztcbiAgICAgICAgaWYgKCFvcHRzU2NoZW1hcykgcmV0dXJuO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpIGFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIga2V5IGluIG9wdHNTY2hlbWFzKSBhZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYub3B0cy5mb3JtYXRzKSB7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gc2VsZi5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgICAgICBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY2hlY2tVbmlxdWUoaWQpIHtcbiAgICAgICAgaWYgKHNlbGYuX3NjaGVtYXNbaWRdIHx8IHNlbGYuX3JlZnNbaWRdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMnKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIENhY2hlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWNoZSgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gQ2FjaGVfcHV0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBDYWNoZV9nZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiBDYWNoZV9kZWwoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlW2tleV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL2FsbCByZXF1aXJlcyBtdXN0IGJlIGV4cGxpY2l0IGJlY2F1c2UgYnJvd3NlcmlmeSB3b24ndCB3b3JrIHdpdGggZHluYW1pYyByZXF1aXJlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICckcmVmJzogcmVxdWlyZSgnLi4vZG90anMvcmVmJyksXG4gIGFueU9mOiByZXF1aXJlKCcuLi9kb3Rqcy9hbnlPZicpLFxuICBmb3JtYXQ6IHJlcXVpcmUoJy4uL2RvdGpzL2Zvcm1hdCcpLFxuICBtYXhMZW5ndGg6IHJlcXVpcmUoJy4uL2RvdGpzL21heExlbmd0aCcpLFxuICBtaW5JdGVtczogcmVxdWlyZSgnLi4vZG90anMvbWluSXRlbXMnKSxcbiAgbWluaW11bTogcmVxdWlyZSgnLi4vZG90anMvbWluaW11bScpLFxuICBvbmVPZjogcmVxdWlyZSgnLi4vZG90anMvb25lT2YnKSxcbiAgcmVxdWlyZWQ6IHJlcXVpcmUoJy4uL2RvdGpzL3JlcXVpcmVkJyksXG4gIGRlcGVuZGVuY2llczogcmVxdWlyZSgnLi4vZG90anMvZGVwZW5kZW5jaWVzJyksXG4gIGl0ZW1zOiByZXF1aXJlKCcuLi9kb3Rqcy9pdGVtcycpLFxuICBtYXhQcm9wZXJ0aWVzOiByZXF1aXJlKCcuLi9kb3Rqcy9tYXhQcm9wZXJ0aWVzJyksXG4gIG1pbkxlbmd0aDogcmVxdWlyZSgnLi4vZG90anMvbWluTGVuZ3RoJyksXG4gIG11bHRpcGxlT2Y6IHJlcXVpcmUoJy4uL2RvdGpzL211bHRpcGxlT2YnKSxcbiAgcGF0dGVybjogcmVxdWlyZSgnLi4vZG90anMvcGF0dGVybicpLFxuICB1bmlxdWVJdGVtczogcmVxdWlyZSgnLi4vZG90anMvdW5pcXVlSXRlbXMnKSxcbiAgYWxsT2Y6IHJlcXVpcmUoJy4uL2RvdGpzL2FsbE9mJyksXG4gIGVudW06IHJlcXVpcmUoJy4uL2RvdGpzL2VudW0nKSxcbiAgbWF4SXRlbXM6IHJlcXVpcmUoJy4uL2RvdGpzL21heEl0ZW1zJyksXG4gIG1heGltdW06IHJlcXVpcmUoJy4uL2RvdGpzL21heGltdW0nKSxcbiAgbWluUHJvcGVydGllczogcmVxdWlyZSgnLi4vZG90anMvbWluUHJvcGVydGllcycpLFxuICBub3Q6IHJlcXVpcmUoJy4uL2RvdGpzL25vdCcpLFxuICBwcm9wZXJ0aWVzOiByZXF1aXJlKCcuLi9kb3Rqcy9wcm9wZXJ0aWVzJyksXG4gIHZhbGlkYXRlOiByZXF1aXJlKCcuLi9kb3Rqcy92YWxpZGF0ZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKVxuICAgICwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYilcbiAgICAsIGk7XG5cbiAgaWYgKGFyckEgJiYgYXJyQikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFyckEgIT0gYXJyQikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoYltrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgIGlmKCFlcXVhbChhW2tleXNbaV1dLCBiW2tleXNbaV1dKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgREFURSA9IC9eXFxkXFxkXFxkXFxkLShcXGRcXGQpLShcXGRcXGQpJC87XG52YXIgREFZUyA9IFswLDMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtcbnZhciBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZDpcXGRcXGQpJC87XG52YXIgSE9TVE5BTUUgPSAvXlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KFxcLlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KSokL2k7XG52YXIgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QFxcLz9dfCVbMC05YS1mXXsyfSkqKT8oPzpcXCMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QFxcLz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRzO1xuXG5mdW5jdGlvbiBmb3JtYXRzKG1vZGUpIHtcbiAgbW9kZSA9IG1vZGUgPT0gJ2Z1bGwnID8gJ2Z1bGwnIDogJ2Zhc3QnO1xuICByZXR1cm4gdXRpbC5jb3B5KGZvcm1hdHNbbW9kZV0pO1xufVxuXG5cbmZvcm1hdHMuZmFzdCA9IHtcbiAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICBkYXRlOiAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLFxuICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgJ2RhdGUtdGltZSc6IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3QgXVswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkOlxcZFxcZCkkL2ksXG4gIC8vIHVyaTogaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9pcy1teS1qc29uLXZhbGlkL2Jsb2IvbWFzdGVyL2Zvcm1hdHMuanNcbiAgdXJpOiAvXig/OlthLXpdW2EtejAtOSstLl0qKT8oPzpcXDp8XFwvKVxcLz9bXlxcc10qJC9pLFxuICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDEzMjMvdXNpbmctYS1yZWd1bGFyLWV4cHJlc3Npb24tdG8tdmFsaWRhdGUtYW4tZW1haWwtYWRkcmVzcyNhbnN3ZXItODgyOTM2M1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxsZnVsIHZpb2xhdGlvbicpXG4gIGVtYWlsOiAvXlthLXowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG4gIGhvc3RuYW1lOiBIT1NUTkFNRSxcbiAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICAvLyBvcHRpbWl6ZWQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzQ5Ny9yZWd1bGFyLWV4cHJlc3Npb24tdGhhdC1tYXRjaGVzLXZhbGlkLWlwdjYtYWRkcmVzc2VzXG4gIGlwdjY6IC9eXFxzKig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs3fSg/OlswLTlhLWZdezEsNH18OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs2fSg/OjpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwyfSl8Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7NH0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSwzfSl8KD86KD86OlswLTlhLWZdezEsNH0pPzooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXszfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDR9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwyfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsyfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDV9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCwzfTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXsxfSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw0fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg/OjooPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw3fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNX06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoPzolLispP1xccyokL2ksXG4gIHJlZ2V4OiByZWdleFxufTtcblxuXG5mb3JtYXRzLmZ1bGwgPSB7XG4gIGRhdGU6IGRhdGUsXG4gICdkYXRlLXRpbWUnOiBkYXRlX3RpbWUsXG4gIHVyaTogdXJpLFxuICBlbWFpbDogL15bYS16MC05ISMkJSYnKitcXC89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnJyorXFwvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICByZWdleDogcmVnZXhcbn07XG5cblxuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1vbnRoID0gK21hdGNoZXNbMV07XG4gIHZhciBkYXkgPSArbWF0Y2hlc1syXTtcbiAgcmV0dXJuIG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgJiYgZGF5ID49IDEgJiYgZGF5IDw9IERBWVNbbW9udGhdO1xufVxuXG5cbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgZGF0ZVRpbWUgPSBzdHIudG9Mb3dlckNhc2UoKS5zcGxpdCgndCcpO1xuICBpZiAoIWRhdGUoZGF0ZVRpbWVbMF0pKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1hdGNoZXMgPSBkYXRlVGltZVsxXS5tYXRjaChUSU1FKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGhvdXIgPSBtYXRjaGVzWzFdO1xuICB2YXIgbWludXRlID0gbWF0Y2hlc1syXTtcbiAgdmFyIHNlY29uZCA9IG1hdGNoZXNbM107XG4gIHJldHVybiBob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTk7XG59XG5cblxuZnVuY3Rpb24gaG9zdG5hbWUoc3RyKSB7XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzQjc2VjdGlvbi0zLjVcbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gMjU1ICYmIEhPU1ROQU1FLnRlc3Qoc3RyKTtcbn1cblxuXG52YXIgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98XFw6LztcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5cblxuZnVuY3Rpb24gcmVnZXgoc3RyKSB7XG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIGVxdWFsID0gcmVxdWlyZSgnLi9lcXVhbCcpO1xuXG50cnkgeyB2YXIgYmVhdXRpZnkgPSByZXF1aXJlKCcnICsgJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7IH0gY2F0Y2goZSkge31cblxudmFyIFJVTEVTID0gcmVxdWlyZSgnLi9ydWxlcycpXG4gICwgdmFsaWRhdGVHZW5lcmF0b3IgPSByZXF1aXJlKCcuLi9kb3Rqcy92YWxpZGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7XG5cblxuZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUsIGV2aWw6IHRydWUgKi9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCByZWZWYWwgPSBbIHVuZGVmaW5lZCBdIFxuICAgICwgcmVmcyA9IHt9XG4gICAgLCBwYXR0ZXJucyA9IFtdXG4gICAgLCBwYXR0ZXJuc0hhc2ggPSB7fTtcblxuICByb290ID0gcm9vdCB8fCB7IHNjaGVtYTogc2NoZW1hLCByZWZWYWw6IHJlZlZhbCwgcmVmczogcmVmcyB9O1xuXG4gIHZhciBmb3JtYXRzID0gdGhpcy5fZm9ybWF0cztcblxuICByZXR1cm4gbG9jYWxDb21waWxlKHNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuXG5cbiAgZnVuY3Rpb24gbG9jYWxDb21waWxlKF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAgIHZhciBpc1Jvb3QgPSAhX3Jvb3QgfHwgKF9yb290ICYmIF9yb290LnNjaGVtYSA9PSBfc2NoZW1hKTtcbiAgICBpZiAoX3Jvb3Quc2NoZW1hICE9IHJvb3Quc2NoZW1hKVxuICAgICAgcmV0dXJuIGNvbXBpbGUuY2FsbChzZWxmLCBfc2NoZW1hLCBfcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuXG4gICAgdmFyIHZhbGlkYXRlQ29kZSA9IHZhbGlkYXRlR2VuZXJhdG9yKHtcbiAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgc2NoZW1hOiBfc2NoZW1hLFxuICAgICAgaXNSb290OiBpc1Jvb3QsXG4gICAgICBiYXNlSWQ6IGJhc2VJZCxcbiAgICAgIHJvb3Q6IF9yb290LFxuICAgICAgc2NoZW1hUGF0aDogJycsXG4gICAgICBlcnJvclBhdGg6ICdcIlwiJyxcbiAgICAgIFJVTEVTOiBSVUxFUyxcbiAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUdlbmVyYXRvcixcbiAgICAgIHV0aWw6IHV0aWwsXG4gICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgcmVzb2x2ZVJlZjogcmVzb2x2ZVJlZixcbiAgICAgIHVzZVBhdHRlcm46IHVzZVBhdHRlcm4sXG4gICAgICBvcHRzOiBzZWxmLm9wdHMsXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzXG4gICAgfSk7XG5cbiAgICB2YWxpZGF0ZUNvZGUgPSByZWZzQ29kZShyZWZWYWwpICsgcGF0dGVybnNDb2RlKHBhdHRlcm5zKSArIHZhbGlkYXRlQ29kZTtcblxuICAgIGlmIChzZWxmLm9wdHMuYmVhdXRpZnkpIHtcbiAgICAgIHZhciBvcHRzID0gc2VsZi5vcHRzLmJlYXV0aWZ5ID09PSB0cnVlID8geyBpbmRlbnRfc2l6ZTogMiB9IDogc2VsZi5vcHRzLmJlYXV0aWZ5O1xuICAgICAgaWYgKGJlYXV0aWZ5KSB2YWxpZGF0ZUNvZGUgPSBiZWF1dGlmeSh2YWxpZGF0ZUNvZGUsIG9wdHMpO1xuICAgICAgZWxzZSBjb25zb2xlLmVycm9yKCdcIm5wbSBpbnN0YWxsIGpzLWJlYXV0aWZ5XCIgdG8gdXNlIGJlYXV0aWZ5IG9wdGlvbicpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuICoqKiBcXG4nLCB2YWxpZGF0ZUNvZGUpO1xuICAgIHZhciB2YWxpZGF0ZTtcbiAgICAvLyB0cnkge1xuICAgICAgZXZhbCh2YWxpZGF0ZUNvZGUpO1xuICAgICAgcmVmVmFsWzBdID0gdmFsaWRhdGU7XG4gICAgLy8gfSBjYXRjaChlKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTonLCB2YWxpZGF0ZUNvZGUpO1xuICAgIC8vICAgdGhyb3cgZTtcbiAgICAvLyB9XG5cbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBfc2NoZW1hO1xuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgdmFsaWRhdGUucmVmcyA9IHJlZnM7XG4gICAgdmFsaWRhdGUucmVmVmFsID0gcmVmVmFsO1xuICAgIHZhbGlkYXRlLnJvb3QgPSBpc1Jvb3QgPyB2YWxpZGF0ZSA6IF9yb290O1xuXG4gICAgcmV0dXJuIHZhbGlkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZihiYXNlSWQsIHJlZiwgaXNSb290KSB7XG4gICAgcmVmID0gcmVzb2x2ZS51cmwoYmFzZUlkLCByZWYpO1xuICAgIHZhciByZWZJbmRleCA9IHJlZnNbcmVmXTtcbiAgICB2YXIgX3JlZlZhbCwgcmVmQ29kZTtcbiAgICBpZiAocmVmSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgX3JlZlZhbCA9IHJlZlZhbFtyZWZJbmRleF07XG4gICAgICByZWZDb2RlID0gJ3JlZlZhbFsnICsgcmVmSW5kZXggKyAnXSc7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgfVxuICAgIGlmICghaXNSb290KSB7XG4gICAgICB2YXIgcm9vdFJlZklkID0gcm9vdC5yZWZzW3JlZl07XG4gICAgICBpZiAocm9vdFJlZklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3JlZlZhbCA9IHJvb3QucmVmVmFsW3Jvb3RSZWZJZF07XG4gICAgICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYsIF9yZWZWYWwpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRSZWYoX3JlZlZhbCwgcmVmQ29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVmQ29kZSA9IGFkZExvY2FsUmVmKHJlZik7XG4gICAgdmFyIHYgPSByZXNvbHZlLmNhbGwoc2VsZiwgbG9jYWxDb21waWxlLCByb290LCByZWYpO1xuICAgIGlmICghdikge1xuICAgICAgdmFyIGxvY2FsU2NoZW1hID0gbG9jYWxSZWZzICYmIGxvY2FsUmVmc1tyZWZdO1xuICAgICAgaWYgKGxvY2FsU2NoZW1hKSB7XG4gICAgICAgIHYgPSByZXNvbHZlLmlubGluZVJlZihsb2NhbFNjaGVtYSwgc2VsZi5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgICAgICA/IGxvY2FsU2NoZW1hXG4gICAgICAgICAgICA6IGNvbXBpbGUuY2FsbChzZWxmLCBsb2NhbFNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2KSB7XG4gICAgICByZXBsYWNlTG9jYWxSZWYocmVmLCB2KTtcbiAgICAgIHJldHVybiByZXNvbHZlZFJlZih2LCByZWZDb2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMb2NhbFJlZihyZWYsIHYpIHtcbiAgICB2YXIgcmVmSWQgPSByZWZWYWwubGVuZ3RoO1xuICAgIHJlZlZhbFtyZWZJZF0gPSB2O1xuICAgIHJlZnNbcmVmXSA9IHJlZklkO1xuICAgIHJldHVybiAncmVmVmFsJyArIHJlZklkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUxvY2FsUmVmKHJlZiwgdikge1xuICAgIHZhciByZWZJZCA9IHJlZnNbcmVmXTtcbiAgICByZWZWYWxbcmVmSWRdID0gdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVkUmVmKHNjaGVtYSwgY29kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnXG4gICAgICAgICAgICA/IHsgc2NoZW1hOiBzY2hlbWEsIGNvZGU6IGNvZGUgfVxuICAgICAgICAgICAgOiBjb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlUGF0dGVybihyZWdleFN0cikge1xuICAgIHZhciBpbmRleCA9IHBhdHRlcm5zSGFzaFtyZWdleFN0cl07XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gcGF0dGVybnNIYXNoW3JlZ2V4U3RyXSA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgIHBhdHRlcm5zW2luZGV4XSA9IHJlZ2V4U3RyO1xuICAgIH1cbiAgICByZXR1cm4gJ3BhdHRlcm4nICsgaW5kZXg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBwYXR0ZXJuc0NvZGUocGF0dGVybnMpIHtcbiAgcmV0dXJuIF9hcnJDb2RlKHBhdHRlcm5zLCBwYXR0ZXJuQ29kZSk7XG59XG5cblxuZnVuY3Rpb24gcGF0dGVybkNvZGUoaSwgcGF0dGVybnMpIHtcbiAgcmV0dXJuICd2YXIgcGF0dGVybicgKyBpICsgJyA9IG5ldyBSZWdFeHAoJyArIHV0aWwudG9RdW90ZWRTdHJpbmcocGF0dGVybnNbaV0pICsgJyk7Jztcbn1cblxuXG5mdW5jdGlvbiByZWZzQ29kZShyZWZWYWwpIHtcbiAgcmV0dXJuIF9hcnJDb2RlKHJlZlZhbCwgcmVmQ29kZSk7XG59XG5cblxuZnVuY3Rpb24gcmVmQ29kZShpLCByZWZWYWwpIHtcbiAgcmV0dXJuIHJlZlZhbFtpXSA/ICd2YXIgcmVmVmFsJyArIGkgKyAnID0gcmVmVmFsWycgKyBpICsgJ107JyA6ICcnO1xufVxuXG5cbmZ1bmN0aW9uIF9hcnJDb2RlKGFyciwgc3RhdGVtZW50KSB7XG4gIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuICcnO1xuICB2YXIgY29kZSA9ICcnO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKVxuICAgIGNvZGUgKz0gc3RhdGVtZW50KGksIGFycik7XG4gIHJldHVybiBjb2RlO1xufVxuXG5cbi8qKlxuICogRnVuY3Rpb25zIGJlbG93IGFyZSB1c2VkIGluc2lkZSBjb21waWxlZCB2YWxpZGF0aW9ucyBmdW5jdGlvblxuICovXG5cbnZhciB1Y3MybGVuZ3RoID0gdXRpbC51Y3MybGVuZ3RoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbiAgLCBlcXVhbCA9IHJlcXVpcmUoJy4vZXF1YWwnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIFNjaGVtYU9iamVjdCA9IHJlcXVpcmUoJy4vc2NoZW1hX29iaicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7XG5cbnJlc29sdmUubm9ybWFsaXplSWQgPSBub3JtYWxpemVJZDtcbnJlc29sdmUuZnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbnJlc29sdmUudXJsID0gcmVzb2x2ZVVybDtcbnJlc29sdmUuaWRzID0gcmVzb2x2ZUlkcztcbnJlc29sdmUuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuXG5mdW5jdGlvbiByZXNvbHZlKGNvbXBpbGUsIHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZl07XG4gIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHRoaXMuX3JlZnNbcmVmVmFsXSkgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgIGVsc2UgcmV0dXJuIHJlc29sdmUuY2FsbCh0aGlzLCBjb21waWxlLCByb290LCByZWZWYWwpO1xuICB9XG4gIFxuICByZWZWYWwgPSByZWZWYWwgfHwgdGhpcy5fc2NoZW1hc1tyZWZdO1xuICBpZiAocmVmVmFsIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KVxuICAgIHJldHVybiBpbmxpbmVSZWYocmVmVmFsLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgICAgICA/IHJlZlZhbC5zY2hlbWFcbiAgICAgICAgICAgIDogcmVmVmFsLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcblxuICB2YXIgcmVzID0gX3Jlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICB2YXIgc2NoZW1hLCB2LCBiYXNlSWQ7XG4gIGlmIChyZXMpIHtcbiAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICB9XG5cbiAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdClcbiAgICB2ID0gc2NoZW1hLnZhbGlkYXRlIHx8IGNvbXBpbGUuY2FsbCh0aGlzLCBzY2hlbWEuc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gIGVsc2UgaWYgKHNjaGVtYSlcbiAgICB2ID0gaW5saW5lUmVmKHNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpXG4gICAgICAgID8gc2NoZW1hXG4gICAgICAgIDogY29tcGlsZS5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuXG4gIHJldHVybiB2O1xufVxuXG5cbmZ1bmN0aW9uIF9yZXNvbHZlKHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBwID0gdXJsLnBhcnNlKHJlZiwgZmFsc2UsIHRydWUpXG4gICAgLCByZWZQYXRoID0gX2dldEZ1bGxQYXRoKHApXG4gICAgLCBiYXNlSWQgPSBnZXRGdWxsUGF0aChyb290LnNjaGVtYS5pZCk7XG4gIGlmIChyZWZQYXRoICE9PSBiYXNlSWQpIHtcbiAgICB2YXIgaWQgPSBub3JtYWxpemVJZChyZWZQYXRoKTtcbiAgICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tpZF07XG4gICAgaWYgKHR5cGVvZiByZWZWYWwgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiByZXNvbHZlUmVjdXJzaXZlLmNhbGwodGhpcywgcm9vdCwgcmVmVmFsLCBwKTtcbiAgICB9IGVsc2UgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgICAgaWYgKCFyZWZWYWwudmFsaWRhdGUpIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgIHJvb3QgPSByZWZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZlZhbCA9IHRoaXMuX3NjaGVtYXNbaWRdO1xuICAgICAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgICAgICBpZiAoIXJlZlZhbC52YWxpZGF0ZSkgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICAgICAgICBpZiAoaWQgPT0gbm9ybWFsaXplSWQocmVmKSlcbiAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHJlZlZhbCwgcm9vdDogcm9vdCwgYmFzZUlkOiBiYXNlSWQgfTtcbiAgICAgICAgcm9vdCA9IHJlZlZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyb290LnNjaGVtYSkgcmV0dXJuO1xuICAgIGJhc2VJZCA9IGdldEZ1bGxQYXRoKHJvb3Quc2NoZW1hLmlkKTtcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBiYXNlSWQsIHJvb3Quc2NoZW1hLCByb290KTtcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlUmVjdXJzaXZlKHJvb3QsIHJlZiwgcGFyc2VkUmVmKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHJlcyA9IF9yZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgaWYgKHJlcykge1xuICAgIHZhciBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHZhciBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICBpZiAoc2NoZW1hLmlkKSBiYXNlSWQgPSByZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLmlkKTtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwYXJzZWRSZWYsIGJhc2VJZCwgc2NoZW1hLCByb290KTtcbiAgfVxufVxuXG5cbnZhciBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IHV0aWwudG9IYXNoKFsncHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycsICdlbnVtJ10pO1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHBhcnNlZFJlZi5oYXNoID0gcGFyc2VkUmVmLmhhc2ggfHwgJyc7XG4gIGlmIChwYXJzZWRSZWYuaGFzaC5zbGljZSgwLDIpICE9ICcjLycpIHJldHVybjtcbiAgdmFyIHBhcnRzID0gcGFyc2VkUmVmLmhhc2guc3BsaXQoJy8nKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydCA9IHVuZXNjYXBlRnJhZ21lbnQocGFydCk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFbcGFydF07XG4gICAgICBpZiAoIXNjaGVtYSkgYnJlYWs7XG4gICAgICBpZiAoc2NoZW1hLmlkICYmICFQUkVWRU5UX1NDT1BFX0NIQU5HRVtwYXJ0XSkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS5pZCk7XG4gICAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgdmFyICRyZWYgPSByZXNvbHZlVXJsKGJhc2VJZCwgc2NoZW1hLiRyZWYpO1xuICAgICAgICB2YXIgcmVzID0gX3Jlc29sdmUuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHNjaGVtYSA9IHJlcy5zY2hlbWE7XG4gICAgICAgICAgcm9vdCA9IHJlcy5yb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hICE9IHJvb3Quc2NoZW1hKVxuICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCByb290OiByb290LCBiYXNlSWQ6IGJhc2VJZCB9O1xufVxuXG5cbnZhciBTSU1QTEVfSU5MSU5FRCA9IHV0aWwudG9IYXNoKFtcbiAgJ3R5cGUnLCAnZm9ybWF0JywgJ3BhdHRlcm4nLFxuICAnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsXG4gICdtYXhQcm9wZXJ0aWVzJywgJ21pblByb3BlcnRpZXMnLFxuICAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLFxuICAnbWF4aW11bScsICdtaW5pbXVtJyxcbiAgJ3VuaXF1ZUl0ZW1zJywgJ211bHRpcGxlT2YnLFxuICAncmVxdWlyZWQnLCAnZW51bScgXG5dKTtcbmZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWEsIGxpbWl0KSB7XG4gIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2hlY2tOb1JlZihzY2hlbWEpO1xuICBlbHNlIGlmIChsaW1pdCkgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrTm9SZWYoc2NoZW1hKSB7XG4gIHZhciBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IHNjaGVtYVtpXTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnICYmICFjaGVja05vUmVmKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgdmFyIGNvdW50ID0gMCwgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKTtcbiAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIEluZmluaXR5O1xuICAgICAgaWYgKFNJTVBMRV9JTkxJTkVEW2tleV0pIGNvdW50Kys7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaXRlbSA9IHNjaGVtYVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKSArIDE7XG4gICAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cblxuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgICAgICAgLnJlcGxhY2UoL34xL2csICcvJylcbiAgICAgICAgICAucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGgoaWQsIG5vcm1hbGl6ZSkge1xuICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSkgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHZhciBwID0gdXJsLnBhcnNlKGlkLCBmYWxzZSwgdHJ1ZSk7XG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5cblxuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgcmV0dXJuIChwLnByb3RvY29sfHwnJykgKyAocC5wcm90b2NvbD8nLy8nOicnKSArIChwLmhvc3R8fCcnKSArIChwLnBhdGh8fCcnKSAgKyAnIyc7XG59XG5cblxudmFyIFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kLztcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCAnJykgOiAnJztcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHJldHVybiB1cmwucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlSWRzKHNjaGVtYSkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYS5pZCk7XG4gIHZhciBsb2NhbFJlZnMgPSB7fTtcbiAgX3Jlc29sdmVJZHMuY2FsbCh0aGlzLCBzY2hlbWEsIGdldEZ1bGxQYXRoKGlkLCBmYWxzZSksIGlkKTtcbiAgcmV0dXJuIGxvY2FsUmVmcztcblxuICBmdW5jdGlvbiBfcmVzb2x2ZUlkcyhzY2hlbWEsIGZ1bGxQYXRoLCBiYXNlSWQpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspXG4gICAgICAgIF9yZXNvbHZlSWRzLmNhbGwodGhpcywgc2NoZW1hW2ldLCBmdWxsUGF0aCsnLycraSwgYmFzZUlkKTtcbiAgICBlbHNlIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuaWQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGlkID0gYmFzZUlkID0gYmFzZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gdXJsLnJlc29sdmUoYmFzZUlkLCBzY2hlbWEuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplSWQoc2NoZW1hLmlkKTtcblxuICAgICAgICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tpZF07XG4gICAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZlZhbF07XG4gICAgICAgIGlmIChyZWZWYWwgJiYgcmVmVmFsLnNjaGVtYSkge1xuICAgICAgICAgIGlmICghZXF1YWwoc2NoZW1hLCByZWZWYWwuc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZCAhPSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgICBpZiAoaWRbMF0gPT0gJyMnKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWZzW2lkXSAmJiAhZXF1YWwoc2NoZW1hLCBsb2NhbFJlZnNbaWRdKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBcIicgKyBpZCArICdcIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYScpO1xuICAgICAgICAgICAgbG9jYWxSZWZzW2lkXSA9IHNjaGVtYTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3JlZnNbaWRdID0gZnVsbFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpXG4gICAgICAgIF9yZXNvbHZlSWRzLmNhbGwodGhpcywgc2NoZW1hW2tleV0sIGZ1bGxQYXRoKycvJytlc2NhcGVGcmFnbWVudChrZXkpLCBiYXNlSWQpO1xuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcnVsZU1vZHVsZXMgPSByZXF1aXJlKCcuL19ydWxlcycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgUlVMRVMgPSBtb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyB0eXBlOiAnbnVtYmVyJyxcbiAgICBydWxlczogWyAnbWF4aW11bScsICdtaW5pbXVtJywgJ211bHRpcGxlT2YnXSB9LFxuICB7IHR5cGU6ICdzdHJpbmcnLFxuICAgIHJ1bGVzOiBbICdtYXhMZW5ndGgnLCAnbWluTGVuZ3RoJywgJ3BhdHRlcm4nLCAnZm9ybWF0JyBdIH0sXG4gIHsgdHlwZTogJ2FycmF5JyxcbiAgICBydWxlczogWyAnbWF4SXRlbXMnLCAnbWluSXRlbXMnLCAndW5pcXVlSXRlbXMnLCAnaXRlbXMnIF0gfSxcbiAgeyB0eXBlOiAnb2JqZWN0JyxcbiAgICBydWxlczogWyAnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJywgJ3JlcXVpcmVkJywgJ2RlcGVuZGVuY2llcycsICdwcm9wZXJ0aWVzJyBdIH0sXG4gIHsgcnVsZXM6IFsgJyRyZWYnLCAnZW51bScsICdub3QnLCAnYW55T2YnLCAnb25lT2YnLCAnYWxsT2YnIF0gfVxuXTtcblxuUlVMRVMuYWxsID0gWyAndHlwZScsICdhZGRpdGlvbmFsUHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycgXTtcblxuXG5SVUxFUy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5ydWxlcyA9IGdyb3VwLnJ1bGVzLm1hcChmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgIFJVTEVTLmFsbC5wdXNoKGtleXdvcmQpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXl3b3JkOiBrZXl3b3JkLFxuICAgICAgY29kZTogcnVsZU1vZHVsZXNba2V5d29yZF1cbiAgICB9O1xuICB9KTtcbn0pO1xuXG5SVUxFUy5hbGwgPSB1dGlsLnRvSGFzaChSVUxFUy5hbGwpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU9iamVjdDtcblxuZnVuY3Rpb24gU2NoZW1hT2JqZWN0KG9iaikge1xuICAgIHV0aWwuY29weShvYmosIHRoaXMpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5OiBjb3B5LFxuICBjaGVja0RhdGFUeXBlOiBjaGVja0RhdGFUeXBlLFxuICBjaGVja0RhdGFUeXBlczogY2hlY2tEYXRhVHlwZXMsXG4gIHRvSGFzaDogdG9IYXNoLFxuICBnZXRQcm9wZXJ0eTogZ2V0UHJvcGVydHksXG4gIGVzY2FwZVF1b3RlczogZXNjYXBlUXVvdGVzLFxuICB1Y3MybGVuZ3RoOiB1Y3MybGVuZ3RoLFxuICB2YXJPY2N1cmVuY2VzOiB2YXJPY2N1cmVuY2VzLFxuICB2YXJSZXBsYWNlOiB2YXJSZXBsYWNlLFxuICBjbGVhblVwQ29kZTogY2xlYW5VcENvZGUsXG4gIGNsZWFuVXBWYXJFcnJvcnM6IGNsZWFuVXBWYXJFcnJvcnMsXG4gIHNjaGVtYUhhc1J1bGVzOiBzY2hlbWFIYXNSdWxlcyxcbiAgc3RhYmxlU3RyaW5naWZ5OiByZXF1aXJlKCdqc29uLXN0YWJsZS1zdHJpbmdpZnknKSxcbiAgdG9RdW90ZWRTdHJpbmc6IHRvUXVvdGVkU3RyaW5nLFxuICBnZXRQYXRoRXhwcjogZ2V0UGF0aEV4cHIsXG4gIGdldFBhdGg6IGdldFBhdGhcbn07XG5cblxuZnVuY3Rpb24gY29weShvLCB0bykge1xuICB0byA9IHRvIHx8IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gbykgdG9ba2V5XSA9IG9ba2V5XTtcbiAgcmV0dXJuIHRvO1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUsIGRhdGEsIG5lZ2F0ZSkge1xuICB2YXIgRVFVQUwgPSBuZWdhdGUgPyAnICE9PSAnIDogJyA9PT0gJ1xuICAgICwgQU5EID0gbmVnYXRlID8gJyB8fCAnIDogJyAmJiAnXG4gICAgLCBPSyA9IG5lZ2F0ZSA/ICchJyA6ICcnXG4gICAgLCBOT1QgPSBuZWdhdGUgPyAnJyA6ICchJztcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIGNhc2UgJ251bGwnOiByZXR1cm4gZGF0YSArIEVRVUFMICsgJ251bGwnO1xuICAgIGNhc2UgJ2FycmF5JzogcmV0dXJuIE9LICsgJ0FycmF5LmlzQXJyYXkoJyArIGRhdGEgKyAnKSc7XG4gICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuICcoJyArIE9LICsgZGF0YSArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIm9iamVjdFwiJyArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIE5PVCArICdBcnJheS5pc0FycmF5KCcgKyBkYXRhICsgJykpJztcbiAgICBjYXNlICdpbnRlZ2VyJzogcmV0dXJuICcodHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCJudW1iZXJcIicgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9UICsgJygnICsgZGF0YSArICcgJSAxKSknO1xuICAgIGRlZmF1bHQ6IHJldHVybiAndHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCInICsgZGF0YVR5cGUgKyAnXCInO1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhKSB7XG4gIHN3aXRjaCAoZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCB0cnVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciB0eXBlcyA9IHRvSGFzaChkYXRhVHlwZXMpO1xuICAgICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb2RlID0gdHlwZXMubnVsbCA/ICcoJzogJyghJyArIGRhdGEgKyAnIHx8ICc7XG4gICAgICAgIGNvZGUgKz0gJ3R5cGVvZiAnICsgZGF0YSArICcgIT09IFwib2JqZWN0XCIpJztcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5udW1iZXIpIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgICAgZm9yICh2YXIgdCBpbiB0eXBlcylcbiAgICAgICAgY29kZSArPSAoY29kZSA/ICcgJiYgJyA6ICcnICkgKyBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHRydWUpO1xuXG4gICAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgdmFyIGhhc2ggPSB7fTtcbiAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKykgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIGhhc2g7XG59XG5cblxudmFyIElERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbnZhciBTSU5HTEVfUVVPVEUgPSAvJ3xcXFxcL2c7XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIElERU5USUZJRVIudGVzdChrZXkpXG4gICAgICAgICAgPyAnLicgKyBrZXlcbiAgICAgICAgICA6IFwiWydcIiArIGtleS5yZXBsYWNlKFNJTkdMRV9RVU9URSwgJ1xcXFwkJicpICsgXCInXVwiO1xufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVF1b3RlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFNJTkdMRV9RVU9URSwgJ1xcXFwkJicpO1xufVxuXG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgdmFyIGxlbmd0aCA9IDBcbiAgICAsIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIHBvcyA9IDBcbiAgICAsIHZhbHVlO1xuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKys7XG4gICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodmFsdWUgJiAweEZDMDApID09IDB4REMwMCkgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG5mdW5jdGlvbiB2YXJPY2N1cmVuY2VzKHN0ciwgZGF0YVZhcikge1xuICBkYXRhVmFyICs9ICdbXjAtOV0nO1xuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChuZXcgUmVnRXhwKGRhdGFWYXIsICdnJykpO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbn1cblxuXG5mdW5jdGlvbiB2YXJSZXBsYWNlKHN0ciwgZGF0YVZhciwgZXhwcikge1xuICBkYXRhVmFyICs9ICcoW14wLTldKSc7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKGRhdGFWYXIsICdnJyksIGV4cHIgKyAnJDEnKTtcbn1cblxuXG52YXIgRU1QVFlfRUxTRSA9IC9lbHNlXFxzKntcXHMqfS9nXG4gICwgRU1QVFlfSUZfTk9fRUxTRSA9IC9pZlxccypcXChbXildK1xcKVxccypcXHtcXHMqXFx9KD8hXFxzKmVsc2UpL2dcbiAgLCBFTVBUWV9JRl9XSVRIX0VMU0UgPSAvaWZcXHMqXFwoKFteKV0rKVxcKVxccypcXHtcXHMqXFx9XFxzKmVsc2UoPyFcXHMqaWYpL2c7XG5mdW5jdGlvbiBjbGVhblVwQ29kZShvdXQpIHtcbiAgcmV0dXJuIG91dC5yZXBsYWNlKEVNUFRZX0VMU0UsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoRU1QVFlfSUZfTk9fRUxTRSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShFTVBUWV9JRl9XSVRIX0VMU0UsICdpZiAoISgkMSkpJyk7XG59XG5cblxudmFyIEVSUk9SU19SRUdFWFAgPSAvW152XFwuXWVycm9ycy9nXG4gICwgUkVNT1ZFX0VSUk9SUyA9IC92YXIgZXJyb3JzID0gMDt8dmFyIHZFcnJvcnMgPSBudWxsO3x2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOy9nXG4gICwgUkVUVVJOX1ZBTElEID0gJ3JldHVybiBlcnJvcnMgPT09IDA7J1xuICAsIFJFVFVSTl9UUlVFID0gJ3ZhbGlkYXRlLmVycm9ycyA9IG51bGw7IHJldHVybiB0cnVlOyc7XG5cbmZ1bmN0aW9uIGNsZWFuVXBWYXJFcnJvcnMob3V0KSB7XG4gIHZhciBtYXRjaGVzID0gb3V0Lm1hdGNoKEVSUk9SU19SRUdFWFApO1xuICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gb3V0LnJlcGxhY2UoUkVNT1ZFX0VSUk9SUywgJycpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKFJFVFVSTl9WQUxJRCwgUkVUVVJOX1RSVUUpO1xuICBlbHNlXG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiB0b1F1b3RlZFN0cmluZyAoc3RyKSB7XG4gIHJldHVybiAnXFwnJyArIGVzY2FwZVF1b3RlcyhzdHIpICsgJ1xcJyc7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aEV4cHIgKGN1cnJlbnRQYXRoLCBleHByLCBqc29uUG9pbnRlcnMsIGlzTnVtYmVyKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzXG4gICAgICAgICAgICAgID8gJ1xcJy9cXCcgKyAnICsgZXhwciArIChpc051bWJlciA/ICcnIDogJy5yZXBsYWNlKC9+L2csIFxcJ34wXFwnKS5yZXBsYWNlKC9cXFxcLy9nLCBcXCd+MVxcJyknKVxuICAgICAgICAgICAgICA6IChpc051bWJlciA/ICdcXCdbXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXVxcJycgOiAnXFwnW1xcXFxcXCdcXCcgKyAnICsgZXhwciArICcgKyBcXCdcXFxcXFwnXVxcJycpO1xuICByZXR1cm4gam9pblBhdGhzKGN1cnJlbnRQYXRoLCBwYXRoKTtcbn1cblxuXG5mdW5jdGlvbiBnZXRQYXRoIChjdXJyZW50UGF0aCwgcHJvcCwganNvblBvaW50ZXJzKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzXG4gICAgICAgICAgICAgID8gdG9RdW90ZWRTdHJpbmcoJy8nICsgcHJvcC5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKSlcbiAgICAgICAgICAgICAgOiB0b1F1b3RlZFN0cmluZyhnZXRQcm9wZXJ0eShwcm9wKSk7XG4gIHJldHVybiBqb2luUGF0aHMoY3VycmVudFBhdGgsIHBhdGgpO1xufVxuXG5cbmZ1bmN0aW9uIGpvaW5QYXRocyAoYSwgYikge1xuICBpZiAoYSA9PSAnXCJcIicpIHJldHVybiBiO1xuICByZXR1cm4gKGEgKyAnICsgJyArIGIpLnJlcGxhY2UoLycgXFwrICcvZywgJycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbGxPZihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2FsbE9mJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2FsbE9mJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcy5zbGljZSgwLCAtMSkpO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYW55T2YoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydhbnlPZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdhbnlPZicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpLFxuICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5vRW1wdHlTY2hlbWEgPSAkc2NoZW1hLmV2ZXJ5KGZ1bmN0aW9uKCRzY2gpIHtcbiAgICByZXR1cm4gaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpO1xuICB9KTtcbiAgaWYgKCRub0VtcHR5U2NoZW1hKSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgdmFyICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJHZhbGlkKSArICcgfHwgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnOyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgIH1cbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnYW55T2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHNvbWUgc2NoZW1hIGluIGFueU9mXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSBlbHNlIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2RlcGVuZGVuY2llcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2RlcGVuZGVuY2llcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdkZXBlbmRlbmNpZXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRzY2hlbWFEZXBzID0ge30sXG4gICAgJHByb3BlcnR5RGVwcyA9IHt9O1xuICBmb3IgKCRwcm9wZXJ0eSBpbiAkc2NoZW1hKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eV07XG4gICAgdmFyICRkZXBzID0gQXJyYXkuaXNBcnJheSgkc2NoKSA/ICRwcm9wZXJ0eURlcHMgOiAkc2NoZW1hRGVwcztcbiAgICAkZGVwc1skcHJvcGVydHldID0gJHNjaDtcbiAgfVxuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7JztcbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRwcm9wZXJ0eURlcHMpIHtcbiAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YSkgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpKSArICcgIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICRkZXBzID0gJHByb3BlcnR5RGVwc1skcHJvcGVydHldO1xuICAgIG91dCArPSAnIGlmICggJztcbiAgICB2YXIgYXJyMSA9ICRkZXBzO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJGRlcCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkZGVwID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgb3V0ICs9ICcgfHwgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArIChpdC51dGlsLmdldFByb3BlcnR5KCRkZXApKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gJykgeyAgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ2RlcGVuZGVuY2llcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGhhdmUgJztcbiAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0aWVzICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgd2hlbiBwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJyBpcyBwcmVzZW50XFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbjogJyArICgkZGVwcy5sZW5ndGgpICsgJywgZGVwczogXFwnJztcbiAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnLCBwcm9wZXJ0eTogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBoYXZlICc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydGllcyAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIHdoZW4gcHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICcgaXMgcHJlc2VudFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG46ICcgKyAoJGRlcHMubGVuZ3RoKSArICcsIGRlcHM6IFxcJyc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJ1xcJywgcHJvcGVydHk6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSc7XG4gIH1cbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRzY2hlbWFEZXBzKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hRGVwc1skcHJvcGVydHldO1xuICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IHRydWU7IGlmICgnICsgKCRkYXRhKSArICdbXFwnJyArICgkcHJvcGVydHkpICsgJ1xcJ10gIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpO1xuICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICAgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2VudW0oaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydlbnVtJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2VudW0nLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGkgPSAnaScgKyAkbHZsO1xuICBvdXQgKz0gJ3ZhciBlbnVtU2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7Zm9yICh2YXIgJyArICgkaSkgKyAnPTA7ICcgKyAoJGkpICsgJzxlbnVtU2NoZW1hJyArICgkbHZsKSArICcubGVuZ3RoOyAnICsgKCRpKSArICcrKykgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJywgZW51bVNjaGVtYScgKyAoJGx2bCkgKyAnWycgKyAoJGkpICsgJ10pKSB7ICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyBicmVhazsgfSBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ2VudW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlIGVxdWFsIHRvIG9uZSBvZiB2YWx1ZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnZW51bScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgZXF1YWwgdG8gb25lIG9mIHZhbHVlc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZm9ybWF0KGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnZm9ybWF0J10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2Zvcm1hdCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkZm9ybWF0ID0gaXQuZm9ybWF0c1skc2NoZW1hXTtcbiAgaWYgKGl0Lm9wdHMuZm9ybWF0ICE9PSBmYWxzZSAmJiAkZm9ybWF0KSB7XG4gICAgb3V0ICs9ICcgaWYgKCEgICAnO1xuICAgIGlmICh0eXBlb2YgJGZvcm1hdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvdXQgKz0gJyBmb3JtYXRzJyArIChpdC51dGlsLmdldFByb3BlcnR5KCRzY2hlbWEpKSArICcgKCcgKyAoJGRhdGEpICsgJykgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgZm9ybWF0cycgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkc2NoZW1hKSkgKyAnIC50ZXN0KCcgKyAoJGRhdGEpICsgJykgJztcbiAgICB9XG4gICAgb3V0ICs9ICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdmb3JtYXQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBmb3JtYXQgJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdmb3JtYXQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBmb3JtYXQgJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2l0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnaXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnaXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQ7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoQXJyYXkuaXNBcnJheSgkc2NoZW1hKSkge1xuICAgIHZhciAkYWRkaXRpb25hbEl0ZW1zID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICBpZiAoJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoIDw9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJGkpICsgJykgeyAnO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRpLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAkYWRkaXRpb25hbEl0ZW1zID09ICdvYmplY3QnICYmIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJGFkZGl0aW9uYWxJdGVtcywgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgJGl0LnNjaGVtYSA9ICRhZGRpdGlvbmFsSXRlbXM7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxJdGVtcyc7XG4gICAgICBvdXQgKz0gJyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJykgeyAgZm9yICh2YXIgaScgKyAoJGx2bCkgKyAnID0gJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnOyBpJyArICgkbHZsKSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyBpJyArICgkbHZsKSArICcrKykgeyAnO1xuICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAnaScgKyAkbHZsLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2knICsgJGx2bCArICddJztcbiAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9IH0gICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICBvdXQgKz0gJyAgZm9yICh2YXIgaScgKyAoJGx2bCkgKyAnID0gJyArICgwKSArICc7IGknICsgKCRsdmwpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7IGknICsgKCRsdmwpICsgJysrKSB7ICc7XG4gICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAnaScgKyAkbHZsLCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1tpJyArICRsdmwgKyAnXSc7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4SXRlbXMoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydtYXhJdGVtcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhJdGVtcycsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWF4SXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBpdGVtc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ21heEl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBtb3JlIHRoYW4gJyArICgkc2NoZW1hKSArICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4TGVuZ3RoKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4TGVuZ3RoJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ21heExlbmd0aCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKCAnO1xuICBpZiAoaXQub3B0cy51bmljb2RlID09PSBmYWxzZSkge1xuICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJy5sZW5ndGggJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB1Y3MybGVuZ3RoKCcgKyAoJGRhdGEpICsgJykgJztcbiAgfVxuICBvdXQgKz0gJyA+ICcgKyAoJHNjaGVtYSkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhMZW5ndGgnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSBsb25nZXIgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBjaGFyYWN0ZXJzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWF4TGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgbG9uZ2VyIHRoYW4gJyArICgkc2NoZW1hKSArICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tYXhQcm9wZXJ0aWVzKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4UHJvcGVydGllcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhQcm9wZXJ0aWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggPiAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWF4UHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhQcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBtb3JlIHRoYW4gJyArICgkc2NoZW1hKSArICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tYXhpbXVtKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4aW11bSddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhpbXVtJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRleGNsdXNpdmUgPSBpdC5zY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSxcbiAgICAkb3AgPSAkZXhjbHVzaXZlID8gJzwnIDogJzw9JyxcbiAgICAkbm90T3AgPSAkZXhjbHVzaXZlID8gJz49JyA6ICc+JztcbiAgb3V0ICs9ICdpZiAoJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21heGltdW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICcgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGNvbmRpdGlvbjogXFwnJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyB9JztcbiAgICB9XG4gICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhpbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21pbkl0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluSXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWluSXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICgnICsgKCRkYXRhKSArICcubGVuZ3RoIDwgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pbkl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBsZXNzIHRoYW4gJyArICgkc2NoZW1hKSArICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5JdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21pbkxlbmd0aChpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21pbkxlbmd0aCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5MZW5ndGgnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdWNzMmxlbmd0aCgnICsgKCRkYXRhKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgPCAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWluTGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgc2hvcnRlciB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGNoYXJhY3RlcnNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5MZW5ndGgnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSBzaG9ydGVyIHRoYW4gJyArICgkc2NoZW1hKSArICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5Qcm9wZXJ0aWVzKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluUHJvcGVydGllcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggPCAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWluUHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5Qcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBsZXNzIHRoYW4gJyArICgkc2NoZW1hKSArICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5pbXVtKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWluaW11bSddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtaW5pbXVtJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRleGNsdXNpdmUgPSBpdC5zY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSxcbiAgICAkb3AgPSAkZXhjbHVzaXZlID8gJz4nIDogJz49JyxcbiAgICAkbm90T3AgPSAkZXhjbHVzaXZlID8gJzw9JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pbmltdW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICcgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGNvbmRpdGlvbjogXFwnJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyB9JztcbiAgICB9XG4gICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5pbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX211bHRpcGxlT2YoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydtdWx0aXBsZU9mJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ211bHRpcGxlT2YnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ3ZhciBkaXZpc2lvbicgKyAoJGx2bCkgKyAnID0gJyArICgkZGF0YSkgKyAnIC8gJyArICgkc2NoZW1hKSArICc7aWYgKCcgKyAoJGRhdGEpICsgJyAvICcgKyAoJHNjaGVtYSkgKyAnICE9PSBwYXJzZUludChkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSkgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbXVsdGlwbGVPZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgbXVsdGlwbGUgb2YgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtdWx0aXBsZU9mJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBtdWx0aXBsZSBvZiAnICsgKCRzY2hlbWEpICsgJ1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9ub3QoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydub3QnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbm90JyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7ICAnO1xuICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgIG91dCArPSAnICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICAnO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9IGVsc2UgeyBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIHZhbGlkXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKGZhbHNlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX29uZU9mKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnb25lT2YnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnb25lT2YnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciBwcmV2VmFsaWQnICsgKCRsdmwpICsgJyA9IGZhbHNlO3ZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICBpZiAoYXJyMSkge1xuICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgaWYgKGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICdbJyArICRpICsgJ10nO1xuICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IHRydWU7ICc7XG4gICAgICB9XG4gICAgICBpZiAoJGkpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyAmJiBwcmV2VmFsaWQnICsgKCRsdmwpICsgJykgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsgJztcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgJyArICgkdmFsaWQpICsgJyA9IHByZXZWYWxpZCcgKyAoJGx2bCkgKyAnID0gdHJ1ZTsnO1xuICAgIH1cbiAgfVxuICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICBvdXQgKz0gJycgKyAoJGNsb3NpbmdCcmFjZXMpICsgJ2lmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnb25lT2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdvbmVPZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gZWxzZSB7IGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0nO1xuICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICBvdXQgKz0gJyB9ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcGF0dGVybihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ3BhdHRlcm4nXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAncGF0dGVybicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG5ldyBSZWdFeHAoJHNjaGVtYSk7XG4gIG91dCArPSAnaWYgKCEgJyArIChpdC51c2VQYXR0ZXJuKCRzY2hlbWEpKSArICcudGVzdCgnICsgKCRkYXRhKSArICcpICkgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgncGF0dGVybicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggcGF0dGVybiBcIicgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncGF0dGVybicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggcGF0dGVybiBcIicgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnRpZXMoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydwcm9wZXJ0aWVzJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ3Byb3BlcnRpZXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQ7XG4gIHZhciAkc2NoZW1hS2V5cyA9IE9iamVjdC5rZXlzKCRzY2hlbWEgfHwge30pLFxuICAgICRwUHJvcGVydGllcyA9IGl0LnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyB8fCB7fSxcbiAgICAkcFByb3BlcnR5S2V5cyA9IE9iamVjdC5rZXlzKCRwUHJvcGVydGllcyksXG4gICAgJGFQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgICRzb21lUHJvcGVydGllcyA9ICRzY2hlbWFLZXlzLmxlbmd0aCB8fCAkcFByb3BlcnR5S2V5cy5sZW5ndGgsXG4gICAgJG5vQWRkaXRpb25hbCA9ICRhUHJvcGVydGllcyA9PT0gZmFsc2UsXG4gICAgJGFkZGl0aW9uYWxJc1NjaGVtYSA9IHR5cGVvZiAkYVByb3BlcnRpZXMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoJGFQcm9wZXJ0aWVzKS5sZW5ndGgsXG4gICAgJHJlbW92ZUFkZGl0aW9uYWwgPSBpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwsXG4gICAgJGNoZWNrQWRkaXRpb25hbCA9ICRub0FkZGl0aW9uYWwgfHwgJGFkZGl0aW9uYWxJc1NjaGVtYSB8fCAkcmVtb3ZlQWRkaXRpb25hbCxcbiAgICAkcmVxdWlyZWRQcm9wZXJ0aWVzID0gaXQudXRpbC50b0hhc2goaXQuc2NoZW1hLnJlcXVpcmVkIHx8IFtdKTtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyc7XG4gIGlmICgkY2hlY2tBZGRpdGlvbmFsKSB7XG4gICAgb3V0ICs9ICcgZm9yICh2YXIga2V5JyArICgkbHZsKSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgaWYgKCRzb21lUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgdmFyIGlzQWRkaXRpb25hbCcgKyAoJGx2bCkgKyAnID0gIShmYWxzZSAnO1xuICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoID4gNSkge1xuICAgICAgICAgIG91dCArPSAnIHx8IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJ1trZXknICsgKCRsdmwpICsgJ10gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyMSA9ICRzY2hlbWFLZXlzO1xuICAgICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMSA9IC0xLFxuICAgICAgICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjFbaTEgKz0gMV07XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8IGtleScgKyAoJGx2bCkgKyAnID09ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkcHJvcGVydHlLZXkpKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgkcFByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycjIgPSAkcFByb3BlcnR5S2V5cztcbiAgICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgICB2YXIgJHBQcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcFByb3BlcnR5ID0gYXJyMlskaSArPSAxXTtcbiAgICAgICAgICAgIG91dCArPSAnIHx8ICcgKyAoaXQudXNlUGF0dGVybigkcFByb3BlcnR5KSkgKyAnLnRlc3Qoa2V5JyArICgkbHZsKSArICcpICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyApOyBpZiAoaXNBZGRpdGlvbmFsJyArICgkbHZsKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsID09ICdhbGwnKSB7XG4gICAgICBvdXQgKz0gJyBkZWxldGUgJyArICgkZGF0YSkgKyAnW2tleScgKyAoJGx2bCkgKyAnXTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoO1xuICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICdrZXknICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgaWYgKCRub0FkZGl0aW9uYWwpIHtcbiAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsKSB7XG4gICAgICAgICAgb3V0ICs9ICcgZGVsZXRlICcgKyAoJGRhdGEpICsgJ1trZXknICsgKCRsdmwpICsgJ107ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gZmFsc2U7ICAnO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbFByb3BlcnRpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXFwnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkYWRkaXRpb25hbElzU2NoZW1hKSB7XG4gICAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSAnZmFpbGluZycpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyAgJztcbiAgICAgICAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1trZXknICsgJGx2bCArICddJztcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodmFsaWRhdGUuZXJyb3JzICE9PSBudWxsKSB7IGlmIChlcnJvcnMpIHZhbGlkYXRlLmVycm9ycy5sZW5ndGggPSBlcnJvcnM7IGVsc2UgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgfSBkZWxldGUgJyArICgkZGF0YSkgKyAnW2tleScgKyAoJGx2bCkgKyAnXTsgfSAgJztcbiAgICAgICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkYVByb3BlcnRpZXM7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2tleScgKyAkbHZsICsgJ10nO1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIGJyZWFrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gICAgfVxuICAgIGlmICgkc29tZVByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAnO1xuICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgIH1cbiAgfVxuICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgdmFyIGFycjMgPSAkc2NoZW1hS2V5cztcbiAgICBpZiAoYXJyMykge1xuICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSxcbiAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTMgPCBsMykge1xuICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5S2V5XTtcbiAgICAgICAgaWYgKGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgIHZhciAkcHJvcCA9IGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICRwYXNzRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICRwcm9wO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoaXQuZXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICAkY29kZSA9IGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpO1xuICAgICAgICAgICAgdmFyICR1c2VEYXRhID0gJHBhc3NEYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkbmV4dERhdGE7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkcmVxdWlyZWRQcm9wZXJ0aWVzWyRwcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCkgeyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSBmYWxzZTsgJztcbiAgICAgICAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aCxcbiAgICAgICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgICAgICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCkgeyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyB9IGVsc2UgeyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHVzZURhdGEpICsgJyAhPT0gdW5kZWZpbmVkKSB7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyB9ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBhcnI0ID0gJHBQcm9wZXJ0eUtleXM7XG4gIGlmIChhcnI0KSB7XG4gICAgdmFyICRwUHJvcGVydHksIGk0ID0gLTEsXG4gICAgICBsNCA9IGFycjQubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaTQgPCBsNCkge1xuICAgICAgJHBQcm9wZXJ0eSA9IGFycjRbaTQgKz0gMV07XG4gICAgICB2YXIgJHNjaCA9ICRwUHJvcGVydGllc1skcFByb3BlcnR5XTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcucGF0dGVyblByb3BlcnRpZXMnICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcFByb3BlcnR5KTtcbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIga2V5JyArICgkbHZsKSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7IGlmICgnICsgKGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkpICsgJy50ZXN0KGtleScgKyAoJGx2bCkgKyAnKSkgeyAnO1xuICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICdrZXknICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnW2tleScgKyAkbHZsICsgJ10nO1xuICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoIXZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgYnJlYWs7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGVsc2UgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVmKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnJHJlZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICckcmVmJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgaWYgKCRzY2hlbWEgPT0gJyMnIHx8ICRzY2hlbWEgPT0gJyMvJykge1xuICAgIGlmIChpdC5pc1Jvb3QpIHtcbiAgICAgIG91dCArPSAnICBpZiAoISAnICsgKCd2YWxpZGF0ZScpICsgJygnICsgKCRkYXRhKSArICcsIChkYXRhUGF0aCB8fCBcXCdcXCcpJztcbiAgICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICAgIG91dCArPSAnICsgJyArIChpdC5lcnJvclBhdGgpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpICkgeyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9ICcgKyAoJ3ZhbGlkYXRlJykgKyAnLmVycm9yczsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoJyArICgndmFsaWRhdGUnKSArICcuZXJyb3JzKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7IH0gJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEgJyArICgncm9vdC5yZWZWYWxbMF0nKSArICcoJyArICgkZGF0YSkgKyAnLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSApIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCdyb290LnJlZlZhbFswXScpICsgJy5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJ3Jvb3QucmVmVmFsWzBdJykgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICRyZWZWYWwgPSBpdC5yZXNvbHZlUmVmKGl0LmJhc2VJZCwgJHNjaGVtYSwgaXQuaXNSb290KTtcbiAgICBpZiAoJHJlZlZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgJG1lc3NhZ2UgPSAnY2FuXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgJHNjaGVtYSArICcgZnJvbSBpZCAnICsgaXQuYmFzZUlkO1xuICAgICAgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gJ2ZhaWwnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCRtZXNzYWdlKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnJHJlZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdjYW5cXFxcXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSkpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGVzY2FwZWQ6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCckcmVmJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2NhblxcXFxcXCd0IHJlc29sdmUgcmVmZXJlbmNlICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmIChmYWxzZSkgeyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gJ2lnbm9yZScpIHtcbiAgICAgICAgY29uc29sZS5sb2coJG1lc3NhZ2UpO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkZXJyb3IgPSBuZXcgRXJyb3IoJG1lc3NhZ2UpO1xuICAgICAgICAkZXJyb3IubWlzc2luZ1JlZiA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgJHNjaGVtYSk7XG4gICAgICAgICRlcnJvci5taXNzaW5nU2NoZW1hID0gaXQucmVzb2x2ZS5ub3JtYWxpemVJZChpdC5yZXNvbHZlLmZ1bGxQYXRoKCRlcnJvci5taXNzaW5nUmVmKSk7XG4gICAgICAgIHRocm93ICRlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAkcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEgJyArICgkcmVmVmFsKSArICcoJyArICgkZGF0YSkgKyAnLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSApIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCRyZWZWYWwpICsgJy5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJHJlZlZhbCkgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICAgICAkaXQubGV2ZWwrKztcbiAgICAgICRpdC5zY2hlbWEgPSAkcmVmVmFsLnNjaGVtYTtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gJyc7XG4gICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgaWYgKC92YWxpZGF0ZVxcLnNjaGVtYS8udGVzdCgkY29kZSkpIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIHJvb3RTY2hlbWEnICsgKCRpdC5sZXZlbCkgKyAnID0gdmFsaWRhdGUuc2NoZW1hOyB2YWxpZGF0ZS5zY2hlbWEgPSAnICsgKCRyZWZWYWwuY29kZSkgKyAnOyAnICsgKCRjb2RlKSArICcgdmFsaWRhdGUuc2NoZW1hID0gcm9vdFNjaGVtYScgKyAoJGl0LmxldmVsKSArICc7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfcmVxdWlyZWQoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydyZXF1aXJlZCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdyZXF1aXJlZCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIGlmIChpdC5zY2hlbWEucHJvcGVydGllcyAmJiBPYmplY3Qua2V5cyhpdC5zY2hlbWEucHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgdmFyICRyZXF1aXJlZCA9IFtdO1xuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRwcm9wZXJ0eSwgaTEgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgICAkcHJvcGVydHkgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgICB2YXIgJHByb3BlcnR5U2NoID0gaXQuc2NoZW1hLnByb3BlcnRpZXNbJHByb3BlcnR5XTtcbiAgICAgICAgaWYgKCEoJHByb3BlcnR5U2NoICYmIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHByb3BlcnR5U2NoLCBpdC5SVUxFUy5hbGwpKSkge1xuICAgICAgICAgICRyZXF1aXJlZFskcmVxdWlyZWQubGVuZ3RoXSA9ICRwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJHJlcXVpcmVkID0gJHNjaGVtYTtcbiAgfVxuICBpZiAoJHJlcXVpcmVkLmxlbmd0aCkge1xuICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFyIG1pc3NpbmcnICsgKCRsdmwpICsgJzsgJztcbiAgICAgIGlmICgkcmVxdWlyZWQubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgIG91dCArPSAnIGlmICggJztcbiAgICAgICAgdmFyIGFycjIgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSk7XG4gICAgICAgICAgICBvdXQgKz0gJyAoICcgKyAoJGRhdGEpICsgKCRwcm9wKSArICcgPT09IHVuZGVmaW5lZCAmJiAobWlzc2luZycgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKGl0Lm9wdHMuanNvblBvaW50ZXJzID8gJHByb3BlcnR5IDogJHByb3ApKSArICcpICkgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcpIHsgJztcbiAgICAgICAgdmFyICRwcm9wZXJ0eVBhdGggPSAnbWlzc2luZycgKyAkbHZsLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgJyArICRwcm9wZXJ0eVBhdGggKyAnICsgXFwnJztcbiAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQub3B0cy5qc29uUG9pbnRlcnMgPyBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCB0cnVlKSA6ICRjdXJyZW50RXJyb3JQYXRoICsgJyArICcgKyAkcHJvcGVydHlQYXRoO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIHZhciAkaSA9ICdpJyArICRsdmwsXG4gICAgICAgICAgJHByb3BlcnR5UGF0aCA9ICdzY2hlbWEnICsgJGx2bCArICdbJyArICRpICsgJ10nLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgXCJcXCdcIiArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFwiXFwnXCIgKyBcXCcnO1xuICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8IHNjaGVtYScgKyAoJGx2bCkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgdmFyICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICdbc2NoZW1hJyArICgkbHZsKSArICdbJyArICgkaSkgKyAnXV0gIT09IHVuZGVmaW5lZDsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSBicmVhazsgfSAgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAnO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRyZXF1aXJlZC5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgdmFyIGFycjMgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIzKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwzKSB7XG4gICAgICAgICAgICAkcHJvcGVydHkgPSBhcnIzWyRpICs9IDFdO1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpLFxuICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3ApO1xuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhKSArICgkcHJvcCkgKyAnID09PSB1bmRlZmluZWQpIHsgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHlcXCcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnICB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICc7ICc7XG4gICAgICAgIHZhciAkaSA9ICdpJyArICRsdmwsXG4gICAgICAgICAgJHByb3BlcnR5UGF0aCA9ICdzY2hlbWEnICsgJGx2bCArICdbJyArICRpICsgJ10nLFxuICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSAnXFwnICsgXCJcXCdcIiArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFwiXFwnXCIgKyBcXCcnO1xuICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGkpICsgJyA9IDA7ICcgKyAoJGkpICsgJyA8IHNjaGVtYScgKyAoJGx2bCkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgaWYgKCcgKyAoJGRhdGEpICsgJ1tzY2hlbWEnICsgKCRsdmwpICsgJ1snICsgKCRpKSArICddXSA9PT0gdW5kZWZpbmVkKSB7ICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gfSAnO1xuICAgICAgfVxuICAgIH1cbiAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgfSBlbHNlIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgaWYgKHRydWUpIHsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3VuaXF1ZUl0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsndW5pcXVlSXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAndW5pcXVlSXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBpZiAoJHNjaGVtYSAmJiBpdC5vcHRzLnVuaXF1ZUl0ZW1zICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAxKSB7IHZhciBpID0gJyArICgkZGF0YSkgKyAnLmxlbmd0aCwgajsgb3V0ZXI6IGZvciAoO2ktLTspIHsgZm9yIChqID0gaTsgai0tOykgeyBpZiAoZXF1YWwoJyArICgkZGF0YSkgKyAnW2ldLCAnICsgKCRkYXRhKSArICdbal0pKSB7ICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgYnJlYWsgb3V0ZXI7IH0gfSB9IH0gaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAnO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgndW5pcXVlSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjIFxcJyArIGogKyBcXCcgYW5kIFxcJyArIGkgKyBcXCcgYXJlIGlkZW50aWNhbClcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGk6IGksIGo6IGogfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCd1bmlxdWVJdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgXFwnICsgaiArIFxcJyBhbmQgXFwnICsgaSArIFxcJyBhcmUgaWRlbnRpY2FsKVxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgaTogaSwgajogaiB9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdmFsaWRhdGUoaXQpIHtcbiAgdmFyIG91dCA9ICcnO1xuICBpZiAoaXQuaXNUb3ApIHtcbiAgICB2YXIgJHRvcCA9IGl0LmlzVG9wLFxuICAgICAgJGx2bCA9IGl0LmxldmVsID0gMCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsID0gMCxcbiAgICAgICRkYXRhID0gJ2RhdGEnO1xuICAgIGl0LnJvb3RJZCA9IGl0LnJlc29sdmUuZnVsbFBhdGgoaXQucm9vdC5zY2hlbWEuaWQpO1xuICAgIGl0LmJhc2VJZCA9IGl0LmJhc2VJZCB8fCBpdC5yb290SWQ7XG4gICAgZGVsZXRlIGl0LmlzVG9wO1xuICAgIG91dCArPSAnIHZhbGlkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGRhdGFQYXRoKSB7IFxcJ3VzZSBzdHJpY3RcXCc7IHZhciB2RXJyb3JzID0gbnVsbDsgJztcbiAgICBvdXQgKz0gJyB2YXIgZXJyb3JzID0gMDsgICAgICc7XG4gIH0gZWxzZSB7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICAgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICAgIGlmIChpdC5zY2hlbWEuaWQpIGl0LmJhc2VJZCA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgaXQuc2NoZW1hLmlkKTtcbiAgICBvdXQgKz0gJyB2YXIgZXJyc18nICsgKCRsdmwpICsgJyA9IGVycm9yczsnO1xuICB9XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzLFxuICAgICRjbG9zaW5nQnJhY2VzMSA9ICcnLFxuICAgICRjbG9zaW5nQnJhY2VzMiA9ICcnO1xuICB2YXIgJHR5cGVTY2hlbWEgPSBpdC5zY2hlbWEudHlwZTtcbiAgdmFyIGFycjEgPSBpdC5SVUxFUztcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHJ1bGVzR3JvdXAsIGkxID0gLTEsXG4gICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgJHJ1bGVzR3JvdXAgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgaWYgKCRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkpIHtcbiAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsLmNoZWNrRGF0YVR5cGUoJHJ1bGVzR3JvdXAudHlwZSwgJGRhdGEpKSArICcpIHsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyMiA9ICRydWxlc0dyb3VwLnJ1bGVzO1xuICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgIHZhciAkcnVsZSwgaTIgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpMiA8IGwyKSB7XG4gICAgICAgICAgICAkcnVsZSA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgICAgICBpZiAoJHNob3VsZFVzZVJ1bGUoJHJ1bGUpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICcgKyAoJHJ1bGUuY29kZShpdCkpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMSArPSAnfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMSkgKyAnICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMxID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgaWYgKCR0eXBlU2NoZW1hICYmICR0eXBlU2NoZW1hID09PSAkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICB2YXIgJHR5cGVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG91dCArPSAnIGVsc2UgeyAgJztcbiAgICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1tcXCcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCInLCdcIikpICsgJ1xcJ10nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IHR5cGU6IFxcJyc7XG4gICAgICAgICAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyB9JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgndHlwZScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcnICsgKCR0eXBlU2NoZW1hKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKGVycm9ycyA9PT0gJztcbiAgICAgICAgICBpZiAoJHRvcCkge1xuICAgICAgICAgICAgb3V0ICs9ICcwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICdlcnJzXycgKyAoJGx2bCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMyICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJHR5cGVTY2hlbWEgJiYgISR0eXBlQ2hlY2tlZCkge1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnR5cGUnLFxuICAgICAgJGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCR0eXBlU2NoZW1hKSxcbiAgICAgICRtZXRob2QgPSAkaXNBcnJheSA/ICdjaGVja0RhdGFUeXBlcycgOiAnY2hlY2tEYXRhVHlwZSc7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoaXQudXRpbFskbWV0aG9kXSgkdHlwZVNjaGVtYSwgJGRhdGEsIHRydWUpKSArICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCd0eXBlJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJ1xcJycgKyAoJHR5cGVTY2hlbWEpICsgJ1xcJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIixcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSc7XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMikgKyAnICc7XG4gIH1cbiAgaWYgKCR0b3ApIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyAnO1xuICAgIG91dCArPSAnIHJldHVybiBlcnJvcnMgPT09IDA7ICAgICAgICc7XG4gICAgb3V0ICs9ICcgfSc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSBlcnJvcnMgPT09IGVycnNfJyArICgkbHZsKSArICc7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIGlmICgkdG9wICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgPSBpdC51dGlsLmNsZWFuVXBWYXJFcnJvcnMob3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHJ1bGVzR3JvdXAucnVsZXMubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoJHNob3VsZFVzZVJ1bGUoJHJ1bGVzR3JvdXAucnVsZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRzaG91bGRVc2VSdWxlKCRydWxlKSB7XG4gICAgcmV0dXJuIGl0LnNjaGVtYVskcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8ICgkcnVsZS5rZXl3b3JkID09ICdwcm9wZXJ0aWVzJyAmJiAoaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSB8fCB0eXBlb2YgaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09ICdvYmplY3QnIHx8IChpdC5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgJiYgT2JqZWN0LmtleXMoaXQuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKS5sZW5ndGgpKSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcImlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gICAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwiaXRlbXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgICAgICB9LFxuICAgICAgICBcInBvc2l0aXZlSW50ZWdlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIjogMFxuICAgICAgICB9LFxuICAgICAgICBcInBvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgICAgICAgIFwiYWxsT2ZcIjogWyB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyXCIgfSwgeyBcImRlZmF1bHRcIjogMCB9IF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzaW1wbGVUeXBlc1wiOiB7XG4gICAgICAgICAgICBcImVudW1cIjogWyBcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCIgXVxuICAgICAgICB9LFxuICAgICAgICBcInN0cmluZ0FycmF5XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCJ0eXBlXCI6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImlkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgICAgICB9LFxuICAgICAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGl0bGVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICB9LFxuICAgICAgICBcImRlZmF1bHRcIjoge30sXG4gICAgICAgIFwibXVsdGlwbGVPZlwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJtaW5pbXVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhMZW5ndGhcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgIFwibWluTGVuZ3RoXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MFwiIH0sXG4gICAgICAgIFwicGF0dGVyblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgICAgICB9LFxuICAgICAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiI1wiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhJdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyXCIgfSxcbiAgICAgICAgXCJtaW5JdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIm1heFByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgIFwibWluUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInJlcXVpcmVkXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwiIH0sXG4gICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICBcImRlZmF1bHRcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJlbnVtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcImFsbE9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICAgIFwiYW55T2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgICAgXCJvbmVPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgICBcIm5vdFwiOiB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgfSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiBbIFwibWF4aW11bVwiIF0sXG4gICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiBbIFwibWluaW11bVwiIF1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB7fVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3QgdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnVWludDY0QXJyYXksZT1TeW1ib2woKSxyPW5ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIse2ZhdGFsOiEwfSk7ZnVuY3Rpb24gbih0LGUpe2xldCBuPW5ldyBVaW50MzJBcnJheSh0KVtlKy00Pj4+Ml0+Pj4xO2NvbnN0IHM9bmV3IFVpbnQxNkFycmF5KHQsZSxuKTtpZihuPD0xOTIpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ucyk7dHJ5e3JldHVybiByLmRlY29kZShzKX1jYXRjaHtsZXQgdD1cIlwiLGU9MDtmb3IoO24tZT4xMDI0Oyl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnMuc3ViYXJyYXkoZSxlKz0xMDI0KSk7cmV0dXJuIHQrU3RyaW5nLmZyb21DaGFyQ29kZSguLi5zLnN1YmFycmF5KGUpKX19ZnVuY3Rpb24gcyh0KXtjb25zdCBlPXt9O2Z1bmN0aW9uIHIodCxlKXtyZXR1cm4gdD9uKHQuYnVmZmVyLGUpOlwiPHlldCB1bmtub3duPlwifWNvbnN0IHM9dC5lbnY9dC5lbnZ8fHt9O3JldHVybiBzLmFib3J0PXMuYWJvcnR8fGZ1bmN0aW9uKHQsbixvLGkpe2NvbnN0IGE9ZS5tZW1vcnl8fHMubWVtb3J5O3Rocm93IEVycm9yKGBhYm9ydDogJHtyKGEsdCl9IGF0ICR7cihhLG4pfToke299OiR7aX1gKX0scy50cmFjZT1zLnRyYWNlfHxmdW5jdGlvbih0LG4sLi4ubyl7Y29uc3QgaT1lLm1lbW9yeXx8cy5tZW1vcnk7Y29uc29sZS5sb2coYHRyYWNlOiAke3IoaSx0KX0ke24/XCIgXCI6XCJcIn0ke28uc2xpY2UoMCxuKS5qb2luKFwiLCBcIil9YCl9LHMuc2VlZD1zLnNlZWR8fERhdGUubm93LHQuTWF0aD10Lk1hdGh8fE1hdGgsdC5EYXRlPXQuRGF0ZXx8RGF0ZSxlfWNvbnN0IG89ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcIk9wZXJhdGlvbiByZXF1aXJlcyBjb21waWxpbmcgd2l0aCAtLWV4cG9ydFJ1bnRpbWVcIil9O2Z1bmN0aW9uIGkoZSxyKXtjb25zdCBzPXIuZXhwb3J0cyxpPXMubWVtb3J5LGE9cy50YWJsZSxjPXMuX19uZXd8fG8sdT1zLl9fcGlufHxvLHk9cy5fX3VucGlufHxvLGw9cy5fX2NvbGxlY3R8fG8scD1zLl9fcnR0aV9iYXNlLGQ9cD9mdW5jdGlvbih0KXtyZXR1cm4gdFtwPj4+Ml19Om87ZnVuY3Rpb24gYih0KXtjb25zdCBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IFVpbnQzMkFycmF5KGkuYnVmZmVyKTtpZigodD4+Pj0wKT49ZChlKSl0aHJvdyBFcnJvcihgaW52YWxpZCBpZDogJHt0fWApO3JldHVybiBlWyhwKzQ+Pj4yKSsyKnRdfSh0KTtpZighKDcmZSkpdGhyb3cgRXJyb3IoYG5vdCBhbiBhcnJheTogJHt0fSwgZmxhZ3M9JHtlfWApO3JldHVybiBlfWZ1bmN0aW9uIGgodCl7Y29uc3QgZT1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpO2lmKCh0Pj4+PTApPj1kKGUpKXRocm93IEVycm9yKGBpbnZhbGlkIGlkOiAke3R9YCk7cmV0dXJuIGVbKHArND4+PjIpKzIqdCsxXX1mdW5jdGlvbiBtKHQpe3JldHVybiAzMS1NYXRoLmNsejMyKHQ+Pj42JjMxKX1mdW5jdGlvbiBnKHQsZSxyKXtjb25zdCBuPWkuYnVmZmVyO2lmKHIpc3dpdGNoKHQpe2Nhc2UgMjpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShuKTtjYXNlIDM6cmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobil9ZWxzZSBzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBuZXcoZT9JbnQ4QXJyYXk6VWludDhBcnJheSkobik7Y2FzZSAxOnJldHVybiBuZXcoZT9JbnQxNkFycmF5OlVpbnQxNkFycmF5KShuKTtjYXNlIDI6cmV0dXJuIG5ldyhlP0ludDMyQXJyYXk6VWludDMyQXJyYXkpKG4pO2Nhc2UgMzpyZXR1cm4gbmV3KGU/QmlnSW50NjRBcnJheTpCaWdVaW50NjRBcnJheSkobil9dGhyb3cgRXJyb3IoYHVuc3VwcG9ydGVkIGFsaWduOiAke3R9YCl9ZnVuY3Rpb24gQSh0KXtjb25zdCBlPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcikscj1iKGVbdCstOD4+PjJdKSxuPW0ocik7bGV0IHM9NCZyP3Q6ZVt0KzQ+Pj4yXTtjb25zdCBvPTImcj9lW3QrMTI+Pj4yXTplW3MrLTQ+Pj4yXT4+Pm47cmV0dXJuIGcobiwyMDQ4JnIsNDA5NiZyKS5zdWJhcnJheShzPj4+PW4scytvKX1mdW5jdGlvbiB3KHQsZSxyKXtyZXR1cm4gbmV3IHQoXyh0LGUscikpfWZ1bmN0aW9uIF8odCxlLHIpe2NvbnN0IG49aS5idWZmZXIscz1uZXcgVWludDMyQXJyYXkobiksbz1zW3IrND4+PjJdO3JldHVybiBuZXcgdChuLG8sc1tvKy00Pj4+Ml0+Pj5lKX1mdW5jdGlvbiBUKHQscixuKXtlW2BfX2dldCR7cn1gXT13LmJpbmQobnVsbCx0LG4pLGVbYF9fZ2V0JHtyfVZpZXdgXT1fLmJpbmQobnVsbCx0LG4pfXJldHVybiBlLl9fbmV3PWMsZS5fX3Bpbj11LGUuX191bnBpbj15LGUuX19jb2xsZWN0PWwsZS5fX25ld1N0cmluZz1mdW5jdGlvbih0KXtpZihudWxsPT10KXJldHVybiAwO2NvbnN0IGU9dC5sZW5ndGgscj1jKGU8PDEsMSksbj1uZXcgVWludDE2QXJyYXkoaS5idWZmZXIpO2Zvcih2YXIgcz0wLG89cj4+PjE7czxlOysrcyluW28rc109dC5jaGFyQ29kZUF0KHMpO3JldHVybiByfSxlLl9fbmV3QXJyYXlCdWZmZXI9ZnVuY3Rpb24odCl7aWYobnVsbD09dClyZXR1cm4gMDtjb25zdCBlPW5ldyBVaW50OEFycmF5KHQpLHI9YyhlLmxlbmd0aCwwKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIpLnNldChlLHIpLHJ9LGUuX19nZXRTdHJpbmc9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIG51bGw7Y29uc3QgZT1pLmJ1ZmZlcjtpZigxIT09bmV3IFVpbnQzMkFycmF5KGUpW3QrLTg+Pj4yXSl0aHJvdyBFcnJvcihgbm90IGEgc3RyaW5nOiAke3R9YCk7cmV0dXJuIG4oZSx0KX0sZS5fX25ld0FycmF5PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgcj1iKHQpLG49bShyKSxzPWUubGVuZ3RoLG89YyhzPDxuLDQmcj90OjApO2xldCBhO2lmKDQmcilhPW87ZWxzZXt1KG8pO2NvbnN0IGU9YygyJnI/MTY6MTIsdCk7eShvKTtjb25zdCBmPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcik7ZltlKzA+Pj4yXT1vLGZbZSs0Pj4+Ml09byxmW2UrOD4+PjJdPXM8PG4sMiZyJiYoZltlKzEyPj4+Ml09cyksYT1lfWNvbnN0IGY9ZyhuLDIwNDgmciw0MDk2JnIpO2lmKDE2Mzg0JnIpZm9yKGxldCB0PTA7dDxzOysrdCl7Y29uc3Qgcj1lW3RdO2ZbKG8+Pj5uKSt0XT1yfWVsc2UgZi5zZXQoZSxvPj4+bik7cmV0dXJuIGF9LGUuX19nZXRBcnJheVZpZXc9QSxlLl9fZ2V0QXJyYXk9ZnVuY3Rpb24odCl7Y29uc3QgZT1BKHQpLHI9ZS5sZW5ndGgsbj1uZXcgQXJyYXkocik7Zm9yKGxldCB0PTA7dDxyO3QrKyluW3RdPWVbdF07cmV0dXJuIG59LGUuX19nZXRBcnJheUJ1ZmZlcj1mdW5jdGlvbih0KXtjb25zdCBlPWkuYnVmZmVyLHI9bmV3IFVpbnQzMkFycmF5KGUpW3QrLTQ+Pj4yXTtyZXR1cm4gZS5zbGljZSh0LHQrcil9LFtJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV0uZm9yRWFjaCgodD0+e1QodCx0Lm5hbWUsMzEtTWF0aC5jbHozMih0LkJZVEVTX1BFUl9FTEVNRU5UKSl9KSksdCYmW0JpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXldLmZvckVhY2goKHQ9PntUKHQsdC5uYW1lLnNsaWNlKDMpLDMpfSkpLGUuX19pbnN0YW5jZW9mPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgcj1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpO2xldCBuPXJbdCstOD4+PjJdO2lmKG48PWQocikpZG97aWYobj09ZSlyZXR1cm4hMDtuPWgobil9d2hpbGUobik7cmV0dXJuITF9LGUubWVtb3J5PWUubWVtb3J5fHxpLGUudGFibGU9ZS50YWJsZXx8YSxmKHMsZSl9ZnVuY3Rpb24gYSh0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVzcG9uc2UmJnQgaW5zdGFuY2VvZiBSZXNwb25zZX1mdW5jdGlvbiBjKHQpe3JldHVybiB0IGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuTW9kdWxlfWFzeW5jIGZ1bmN0aW9uIHUodCxlPXt9KXtpZihhKHQ9YXdhaXQgdCkpcmV0dXJuIHkodCxlKTtjb25zdCByPWModCk/dDphd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHQpLG49cyhlKSxvPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHIsZSk7cmV0dXJue21vZHVsZTpyLGluc3RhbmNlOm8sZXhwb3J0czppKG4sbyl9fWFzeW5jIGZ1bmN0aW9uIHkodCxlPXt9KXtpZighV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpcmV0dXJuIHUoYSh0PWF3YWl0IHQpP3QuYXJyYXlCdWZmZXIoKTp0LGUpO2NvbnN0IHI9cyhlKSxuPWF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQsZSksbz1pKHIsbi5pbnN0YW5jZSk7cmV0dXJuey4uLm4sZXhwb3J0czpvfX1mdW5jdGlvbiBmKHQscj17fSl7Y29uc3Qgbj10Ll9fYXJndW1lbnRzTGVuZ3RoP2U9Pnt0Ll9fYXJndW1lbnRzTGVuZ3RoLnZhbHVlPWV9OnQuX19zZXRBcmd1bWVudHNMZW5ndGh8fHQuX19zZXRhcmdjfHwoKCk9Pnt9KTtmb3IobGV0IHMgaW4gdCl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHMpKWNvbnRpbnVlO2NvbnN0IG89dFtzXTtsZXQgaT1zLnNwbGl0KFwiLlwiKSxhPXI7Zm9yKDtpLmxlbmd0aD4xOyl7bGV0IHQ9aS5zaGlmdCgpO09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLHQpfHwoYVt0XT17fSksYT1hW3RdfWxldCBjPWlbMF0sdT1jLmluZGV4T2YoXCIjXCIpO2lmKHU+PTApe2NvbnN0IHI9Yy5zdWJzdHJpbmcoMCx1KSxpPWFbcl07aWYodm9pZCAwPT09aXx8IWkucHJvdG90eXBlKXtjb25zdCB0PWZ1bmN0aW9uKC4uLmUpe3JldHVybiB0LndyYXAodC5wcm90b3R5cGUuY29uc3RydWN0b3IoMCwuLi5lKSl9O3QucHJvdG90eXBlPXt2YWx1ZU9mKCl7cmV0dXJuIHRoaXNbZV19fSx0LndyYXA9ZnVuY3Rpb24ocil7cmV0dXJuIE9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse1tlXTp7dmFsdWU6cix3cml0YWJsZTohMX19KX0saSYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaSkuZm9yRWFjaCgoZT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksZSkpKSksYVtyXT10fWlmKGM9Yy5zdWJzdHJpbmcodSsxKSxhPWFbcl0ucHJvdG90eXBlLC9eKGdldHxzZXQpOi8udGVzdChjKSl7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGM9Yy5zdWJzdHJpbmcoNCkpKXtsZXQgcj10W3MucmVwbGFjZShcInNldDpcIixcImdldDpcIildLG49dFtzLnJlcGxhY2UoXCJnZXQ6XCIsXCJzZXQ6XCIpXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHtnZXQoKXtyZXR1cm4gcih0aGlzW2VdKX0sc2V0KHQpe24odGhpc1tlXSx0KX0sZW51bWVyYWJsZTohMH0pfX1lbHNlXCJjb25zdHJ1Y3RvclwiPT09Yz8oYVtjXT0oLi4udCk9PihuKHQubGVuZ3RoKSxvKC4uLnQpKSkub3JpZ2luYWw9bzooYVtjXT1mdW5jdGlvbiguLi50KXtyZXR1cm4gbih0Lmxlbmd0aCksbyh0aGlzW2VdLC4uLnQpfSkub3JpZ2luYWw9b31lbHNlL14oZ2V0fHNldCk6Ly50ZXN0KGMpP09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLGM9Yy5zdWJzdHJpbmcoNCkpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxjLHtnZXQ6dFtzLnJlcGxhY2UoXCJzZXQ6XCIsXCJnZXQ6XCIpXSxzZXQ6dFtzLnJlcGxhY2UoXCJnZXQ6XCIsXCJzZXQ6XCIpXSxlbnVtZXJhYmxlOiEwfSk6XCJmdW5jdGlvblwiPT10eXBlb2YgbyYmbyE9PW4/KGFbY109KC4uLnQpPT4obih0Lmxlbmd0aCksbyguLi50KSkpLm9yaWdpbmFsPW86YVtjXT1vfXJldHVybiByfXZhciBsPXtpbnN0YW50aWF0ZTp1LGluc3RhbnRpYXRlU3luYzpmdW5jdGlvbih0LGU9e30pe2NvbnN0IHI9Yyh0KT90Om5ldyBXZWJBc3NlbWJseS5Nb2R1bGUodCksbj1zKGUpLG89bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHIsZSk7cmV0dXJue21vZHVsZTpyLGluc3RhbmNlOm8sZXhwb3J0czppKG4sbyl9fSxpbnN0YW50aWF0ZVN0cmVhbWluZzp5LGRlbWFuZ2xlOmZ9O2Z1bmN0aW9uIHAodCxlLHIpe3JldHVybiBlfWZ1bmN0aW9uIGQodCxlLHIpe3JldHVybiB0LmV4cG9ydHNbYF9fZ2V0JHtmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGFydHNXaXRoKFwifmxpYi90eXBlZGFycmF5L1wiKT8oKHQ9dC5zbGljZShcIn5saWIvdHlwZWRhcnJheS9cIi5sZW5ndGgpKS5zdGFydHNXaXRoKFwiQmlnXCIpJiYodD10LnNsaWNlKDMpKSx0KTp0fShyKX1WaWV3YF0oZSl9ZnVuY3Rpb24gYih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX25ld0FycmF5KHQuZ2V0VHlwZUlkKHIpLGUpfWZ1bmN0aW9uIGgodCl7aWYoIXQuc3RhcnRzV2l0aChcIn5saWIvYXJyYXkvQXJyYXlcIikpdGhyb3cgRXJyb3IoYCR7SlNPTi5zdHJpbmdpZnkodCl9IGlzIG5vdCBhbiBhcnJheSB0eXBlYCk7cmV0dXJuIHQuc2xpY2UoXCJ+bGliL2FycmF5L0FycmF5PFwiLmxlbmd0aCwtMSl9Y29uc3QgbT1uZXcgTWFwKFtbXCJ2b2lkXCIse2FzY1RvSnM6cCxqc1RvQXNjOnB9XSxbL14oaXx1fGYpKDh8MTZ8MzJ8NjQpfFt1aV1zaXplfGJvb2x8ZXh0ZXJucmVmJC8se2FzY1RvSnM6cCxqc1RvQXNjOnB9XSxbXCJ+bGliL3N0cmluZy9TdHJpbmdcIix7YXNjVG9KczpmdW5jdGlvbih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX2dldFN0cmluZyhlKX0sanNUb0FzYzpmdW5jdGlvbih0LGUscil7cmV0dXJuIHQuZXhwb3J0cy5fX25ld1N0cmluZyhlKX19XSxbXCJ+bGliL3R5cGVkYXJyYXkvSW50OEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvSW50MTZBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0ludDMyQXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50OEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvVWludDE2QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50MzJBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0ludDY0QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50NjRBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L1VpbnQ4Q2xhbXBlZEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvRmxvYXQzMkFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvRmxvYXQ2NEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL2FycmF5YnVmZmVyL0FycmF5QnVmZmVyXCIse2FzY1RvSnM6ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LmV4cG9ydHMuX19nZXRBcnJheUJ1ZmZlcihlKX0sanNUb0FzYzpmdW5jdGlvbih0LGUscil7Y29uc3Qgbj10LmV4cG9ydHMuX19uZXcoZS5ieXRlTGVuZ3RoLHQuZ2V0VHlwZUlkKHIpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodC5leHBvcnRzLm1lbW9yeS5idWZmZXIsbixlLmJ5dGVMZW5ndGgpLnNldChuZXcgVWludDhBcnJheShlKSksbn19XSxbL15+bGliXFwvYXJyYXlcXC9BcnJheTwuKz4kLyx7YXNjVG9KczpmdW5jdGlvbih0LGUscil7Y29uc3Qgbj1oKHIpLHM9QShuKTtyZXR1cm4gdC5leHBvcnRzLl9fZ2V0QXJyYXkoZSkubWFwKChlPT5zLmFzY1RvSnModCxlLG4pKSl9LGpzVG9Bc2M6ZnVuY3Rpb24odCxlLHIpe2NvbnN0IG49aChyKSxzPUEobiksbz1lLm1hcCgoZT0+cy5qc1RvQXNjKHQsZSxuKSkpO3JldHVybiB0LmV4cG9ydHMuX19uZXdBcnJheSh0LmdldFR5cGVJZChyKSxvKX19XV0pLGc9bmV3IFNldDtmdW5jdGlvbiBBKHQpe2Zvcihjb25zdFtlLHJdb2YgbSlpZihcInN0cmluZ1wiIT10eXBlb2YgZSl7aWYoZS50ZXN0KHQpKXJldHVybiByfWVsc2UgaWYoZT09PXQpcmV0dXJuIHI7cmV0dXJuIGcuaGFzKHQpfHwoY29uc29sZS53YXJuKGBObyBjb252ZXJ0ZXIgZm9yICR7SlNPTi5zdHJpbmdpZnkodCl9LCB1c2luZyBwYXNzLXRocm91Z2hgKSxnLmFkZCh0KSkse2FzY1RvSnM6cCxqc1RvQXNjOnB9fWZ1bmN0aW9uIHcodCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT1BKHQpKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5hc2NUb0pzfWZ1bmN0aW9uIF8odCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT1BKHQpKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5qc1RvQXNjfWZ1bmN0aW9uIFQodCxlLHIpe2NvbnN0IG49ci5wYXJhbWV0ZXJzLm1hcCh3KSxzPV8oci5yZXR1cm5UeXBlKTtyZXR1cm4gZnVuY3Rpb24oLi4ubyl7aWYoby5sZW5ndGghPW4ubGVuZ3RoKXRocm93IEVycm9yKGBFeHBlY3RlZCAke24ubGVuZ3RofSBhcmd1bWVudHMsIGdvdCAke28ubGVuZ3RofWApO2NvbnN0IGk9by5tYXAoKChlLHMpPT5uW3NdKHQsZSxyLnBhcmFtZXRlcnNbc10pKSksYT1lKC4uLmkpO3JldHVybiBzKHQsYSxyLnJldHVyblR5cGUpfX1mdW5jdGlvbiBqKHQsZSxyKXtjb25zdCBuPXIucGFyYW1ldGVycy5tYXAoXykscz13KHIucmV0dXJuVHlwZSk7cmV0dXJuKC4uLm8pPT57aWYoby5sZW5ndGghPW4ubGVuZ3RoKXRocm93IEVycm9yKGBFeHBlY3RlZCAke24ubGVuZ3RofSBhcmd1bWVudHMsIGdvdCAke28ubGVuZ3RofWApO2NvbnN0IGk9W10sYT1vLm1hcCgoKGUscyk9Pntjb25zdCBvPW5bc10odCxlLHIucGFyYW1ldGVyc1tzXSk7cmV0dXJuIG8hPT1lJiYodC5leHBvcnRzLl9fcGluKG8pLGkucHVzaChvKSksb30pKSxjPWUoLi4uYSk7cmV0dXJuIGkuZm9yRWFjaCgoZT0+dC5leHBvcnRzLl9fdW5waW4oZSkpKSxzKHQsYyxyLnJldHVyblR5cGUpfX1mdW5jdGlvbiB4KHQse2RlcHRoOmU9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfT17fSl7cmV0dXJuIGU8PTB8fCF0fHxcIm9iamVjdFwiIT10eXBlb2YgdD90Ok9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0KS5tYXAoKChbdCxyXSk9Plt0LHgocix7ZGVwdGg6ZS0xfSldKSkpfWZ1bmN0aW9uIE8odCl7Y29uc3QgZT1XZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnModCxcImFzLWJpbmRfYmluZGluZ3NcIikscj1uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShuZXcgVWludDhBcnJheShlWzBdKSk7dHJ5e3JldHVybiBKU09OLnBhcnNlKHIpfWNhdGNoKHQpe3Rocm93IEVycm9yKGBDb3VsZG7igJl0IGRlY29kZSB0eXBlIGRlc2NyaXB0b3I6ICR7dC5tZXNzYWdlfWApfX1jbGFzcyBVe2NvbnN0cnVjdG9yKCl7dGhpcy51bmJvdW5kRXhwb3J0cz17fSx0aGlzLmV4cG9ydHM9e30sdGhpcy5pbXBvcnRPYmplY3Q9e319Z2V0VHlwZUlkKHQpe2lmKHQgaW4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzKXJldHVybiB0aGlzLnR5cGVEZXNjcmlwdG9yLnR5cGVJZHNbdF0uaWQ7dGhyb3cgRXJyb3IoYFVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KHQpfWApfWdldFR5cGVTaXplKHQpe2lmKHQgaW4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzKXJldHVybiB0aGlzLnR5cGVEZXNjcmlwdG9yLnR5cGVJZHNbdF0uYnl0ZVNpemU7dGhyb3cgRXJyb3IoYFVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KHQpfWApfV92YWxpZGF0ZSgpe2lmKCFXZWJBc3NlbWJseS5Nb2R1bGUuZXhwb3J0cyh0aGlzLm1vZHVsZSkuZmluZCgodD0+XCJfX25ld1wiPT09dC5uYW1lKSkpdGhyb3cgRXJyb3IoXCJUaGUgQXNzZW1ibHlTY3JpcHQgd2FzbSBtb2R1bGUgd2FzIG5vdCBidWlsdCB3aXRoIC0tZXhwb3J0UnVudGltZSwgd2hpY2ggaXMgcmVxdWlyZWQuXCIpO2lmKDEhPT1XZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnModGhpcy5tb2R1bGUsXCJhcy1iaW5kX2JpbmRpbmdzXCIpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQXNzZW1ibHlTY3JpcHQgd2FzbSBtb2R1bGUgd2FzIG5vdCBidWlsdCB3aXRoIHRoZSBhcy1iaW5kIHRyYW5zZm9ybS5cIil9YXN5bmMgX2luc3RhbnRpYXRlKHQsZSl7dGhpcy5tb2R1bGU9YXdhaXQgYXN5bmMgZnVuY3Rpb24odCl7aWYodD1hd2FpdCBQcm9taXNlLnJlc29sdmUodCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlc3BvbnNlJiZ0IGluc3RhbmNlb2YgUmVzcG9uc2Upe2lmKFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcpcmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcodCk7dD1hd2FpdCB0LmFycmF5QnVmZmVyKCl9cmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGUodCl9KHQpLHRoaXMuX3ZhbGlkYXRlKCksdGhpcy50eXBlRGVzY3JpcHRvcj1PKHRoaXMubW9kdWxlKSx0aGlzLl9pbnN0YW50aWF0ZUJpbmRJbXBvcnRGdW5jdGlvbnMoZSksdGhpcy5sb2FkZWRNb2R1bGU9YXdhaXQgYXN5bmMgZnVuY3Rpb24odCxlKXtyZXR1cm4gbC5pbnN0YW50aWF0ZSh0LGUpfSh0aGlzLm1vZHVsZSx0aGlzLmltcG9ydE9iamVjdCksdGhpcy5faW5zdGFudGlhdGVCaW5kVW5ib3VuZEV4cG9ydHMoKX1faW5zdGFudGlhdGVTeW5jKHQsZSl7dGhpcy5tb2R1bGU9bmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh0KSx0aGlzLl92YWxpZGF0ZSgpLHRoaXMudHlwZURlc2NyaXB0b3I9Tyh0aGlzLm1vZHVsZSksdGhpcy5faW5zdGFudGlhdGVCaW5kSW1wb3J0RnVuY3Rpb25zKGUpLHRoaXMubG9hZGVkTW9kdWxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGwuaW5zdGFudGlhdGVTeW5jKHQsZSl9KHRoaXMubW9kdWxlLHRoaXMuaW1wb3J0T2JqZWN0KSx0aGlzLl9pbnN0YW50aWF0ZUJpbmRVbmJvdW5kRXhwb3J0cygpfV9pbnN0YW50aWF0ZUJpbmRJbXBvcnRGdW5jdGlvbnModCl7dGhpcy5pbXBvcnRPYmplY3Q9eCh0LHtkZXB0aDoyfSk7Zm9yKGNvbnN0W2Uscl1vZiBPYmplY3QuZW50cmllcyh0aGlzLnR5cGVEZXNjcmlwdG9yLmltcG9ydGVkRnVuY3Rpb25zKSlmb3IoY29uc3RbbixzXW9mIE9iamVjdC5lbnRyaWVzKHIpKXRoaXMuaW1wb3J0T2JqZWN0W2VdW2BfX2FzYmluZF91bmJvdW5kXyR7bn1gXT10W2VdW25dLHRoaXMuaW1wb3J0T2JqZWN0W2VdW25dPVQodGhpcyx0W2VdW25dLHMpfV9pbnN0YW50aWF0ZUJpbmRVbmJvdW5kRXhwb3J0cygpe2NvbnN0IHQ9dGhpcy5sb2FkZWRNb2R1bGUuZXhwb3J0czt0aGlzLmV4cG9ydHM9eCh0LHtkZXB0aDoxfSk7Zm9yKGNvbnN0W2Uscl1vZiBPYmplY3QuZW50cmllcyh0aGlzLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zKSl0aGlzLmV4cG9ydHNbZV09aih0aGlzLHRbZV0scil9fWV4cG9ydHMuY29udmVydGVycz1tLGV4cG9ydHMuaW5zdGFudGlhdGU9YXN5bmMgZnVuY3Rpb24odCxlKXtsZXQgcj1uZXcgVTtyZXR1cm4gYXdhaXQgci5faW5zdGFudGlhdGUodCxlKSxyfSxleHBvcnRzLmluc3RhbnRpYXRlU3luYz1mdW5jdGlvbih0LGUpe2xldCByPW5ldyBVO3JldHVybiByLl9pbnN0YW50aWF0ZVN5bmModCxlKSxyfSxleHBvcnRzLnZlcnNpb249XCIwLjguMVwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbXF0dCA9IHJlcXVpcmUoXCJtcXR0XCIpO1xudmFyIGluQXJyYXkgPSByZXF1aXJlKFwiaW4tYXJyYXlcIik7XG5cbnZhciBSZWd1bGFyQ2xpZW50UHJvdG90eXBlID0gbXF0dC5NcXR0Q2xpZW50LnByb3RvdHlwZTtcblxudmFyIEFTWU5DX01FVEhPRFMgPSBbXCJwdWJsaXNoXCIsXG5cdFwic3Vic2NyaWJlXCIsXG5cdFwidW5zdWJzY3JpYmVcIixcblx0XCJ1bnN1YnNjcmliZVwiLFxuXHRcImVuZFwiXG5dO1xuXG52YXIgU1lOQ19NRVRIT0RTID0gW1xuXHRcImVtaXRcIixcblx0XCJhZGRMaXN0ZW5lclwiLFxuXHRcIm9uXCIsXG5cdFwib25jZVwiLFxuXHRcInJlbW92ZUxpc3RlbmVyXCIsXG5cdFwicmVtb3ZlQWxsTGlzdGVuZXJzXCIsXG5cdFwic2V0TWF4TGlzdGVuZXJzXCIsXG5cdFwiZ2V0TWF4TGlzdGVuZXJzXCIsXG5cdFwibGlzdGVuZXJzXCIsXG5cdFwibGlzdGVuZXJDb3VudFwiXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y29ubmVjdDogY29ubmVjdCxcblx0QXN5bmNDbGllbnQ6IEFzeW5jQ2xpZW50XG59O1xuXG5mdW5jdGlvbiBjb25uZWN0KGJyb2tlclVSTCwgb3B0cykge1xuXHR2YXIgY2xpZW50ID0gbXF0dC5jb25uZWN0KGJyb2tlclVSTCwgb3B0cyk7XG5cblx0dmFyIGFzeW5jQ2xpZW50ID0gbmV3IEFzeW5jQ2xpZW50KGNsaWVudCk7XG5cblx0cmV0dXJuIGFzeW5jQ2xpZW50O1xufVxuXG5mdW5jdGlvbiBBc3luY0NsaWVudChjbGllbnQpIHtcblx0dGhpcy5fY2xpZW50ID0gY2xpZW50O1xufVxuXG5Bc3luY0NsaWVudC5wcm90b3R5cGUgPSB7XG5cdHNldCBoYW5kbGVNZXNzYWdlKG5ld0hhbmRsZXIpIHtcblx0XHR0aGlzLl9jbGllbnQuaGFuZGxlTWVzc2FnZSA9IG5ld0hhbmRsZXI7XG5cdH0sXG5cdGdldCBoYW5kbGVNZXNzYWdlKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGllbnQuaGFuZGxlTWVzc2FnZTtcblx0fVxufTtcblxuQVNZTkNfTUVUSE9EUy5mb3JFYWNoKGRlZmluZUFzeW5jKTtcblNZTkNfTUVUSE9EUy5mb3JFYWNoKGRlZmluZVBhc3N0aHJvdWdoKTtcblxuZnVuY3Rpb24gZGVmaW5lUGFzc3Rocm91Z2gobmFtZSkge1xuXHRBc3luY0NsaWVudC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuXHRcdHJldHVybiBjbGllbnRbbmFtZV0uYXBwbHkoY2xpZW50LCBhcmd1bWVudHMpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVBc3luYyhuYW1lKSB7XG5cdEFzeW5jQ2xpZW50LnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGFzeW5jTWV0aG9kKCkge1xuXHRcdHZhciBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XG5cdFx0dmFyIGFyZ3MgPSBbXTtcblx0XHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yIChpOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGFyZ3MucHVzaChtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XG5cdFx0XHRjbGllbnRbbmFtZV0uYXBwbHkoY2xpZW50LCBhcmdzKTtcblx0XHR9KTtcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdFx0aWYgKGVycilcblx0XHRcdHJlamVjdChlcnIpO1xuXHRcdGVsc2UgcmVzb2x2ZShkYXRhKTtcblx0fTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsInZhciBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4JylcbiAgLCB1dGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBCdWZmZXIgICAgICAgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QgKGNhbGxiYWNrKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoY2FsbGJhY2spXG5cbiAgdGhpcy5fYnVmcyAgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG5cbiAgICB2YXIgcGlwZXIgPSBmdW5jdGlvbiBwaXBlciAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soZXJyKVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcblxuICAgIHRoaXMub24oJ3BpcGUnLCBmdW5jdGlvbiBvblBpcGUgKHNyYykge1xuICAgICAgc3JjLm9uKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gICAgdGhpcy5vbigndW5waXBlJywgZnVuY3Rpb24gb25VbnBpcGUgKHNyYykge1xuICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcHBlbmQoY2FsbGJhY2spXG4gIH1cblxuICBEdXBsZXhTdHJlYW0uY2FsbCh0aGlzKVxufVxuXG5cbnV0aWwuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRHVwbGV4U3RyZWFtKVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiBfb2Zmc2V0IChvZmZzZXQpIHtcbiAgdmFyIHRvdCA9IDAsIGkgPSAwLCBfdFxuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gWyAwLCAwIF1cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdCB8fCBpID09IHRoaXMuX2J1ZnMubGVuZ3RoIC0gMSlcbiAgICAgIHJldHVybiBbIGksIG9mZnNldCAtIHRvdCBdXG4gICAgdG90ID0gX3RcbiAgfVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIHZhciBpID0gMFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5hcHBlbmQoYnVmW2ldKVxuICB9IGVsc2UgaWYgKGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpIHtcbiAgICAvLyB1bndyYXAgYXJndW1lbnQgaW50byBpbmRpdmlkdWFsIEJ1ZmZlckxpc3RzXG4gICAgZm9yICg7IGkgPCBidWYuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmFwcGVuZChidWYuX2J1ZnNbaV0pXG4gIH0gZWxzZSBpZiAoYnVmICE9IG51bGwpIHtcbiAgICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gICAgLy8gdW5pbml0aWFsaXplZCBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGlmICh0eXBlb2YgYnVmID09ICdudW1iZXInKVxuICAgICAgYnVmID0gYnVmLnRvU3RyaW5nKClcblxuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihCdWZmZXIuZnJvbShidWYpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2FwcGVuZEJ1ZmZlciA9IGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlciAoYnVmKSB7XG4gIHRoaXMuX2J1ZnMucHVzaChidWYpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrKClcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkIChzaXplKSB7XG4gIGlmICghdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMucHVzaChudWxsKVxuXG4gIHNpemUgPSBNYXRoLm1pbihzaXplLCB0aGlzLmxlbmd0aClcbiAgdGhpcy5wdXNoKHRoaXMuc2xpY2UoMCwgc2l6ZSkpXG4gIHRoaXMuY29uc3VtZShzaXplKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZCAoY2h1bmspIHtcbiAgRHVwbGV4U3RyZWFtLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjaHVuaylcblxuICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFjayhudWxsLCB0aGlzLnNsaWNlKCkpXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gIH1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKGluZGV4LCBpbmRleCArIDEpWzBdXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09ICdudW1iZXInICYmIHN0YXJ0IDwgMClcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJyAmJiBlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRzdCwgZHN0U3RhcnQsIHNyY1N0YXJ0LCBzcmNFbmQpIHtcbiAgaWYgKHR5cGVvZiBzcmNTdGFydCAhPSAnbnVtYmVyJyB8fCBzcmNTdGFydCA8IDApXG4gICAgc3JjU3RhcnQgPSAwXG4gIGlmICh0eXBlb2Ygc3JjRW5kICE9ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKVxuICAgIHNyY0VuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAoc3JjRW5kIDw9IDApXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcblxuICB2YXIgY29weSAgID0gISFkc3RcbiAgICAsIG9mZiAgICA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgICAsIGxlbiAgICA9IHNyY0VuZCAtIHNyY1N0YXJ0XG4gICAgLCBieXRlcyAgPSBsZW5cbiAgICAsIGJ1Zm9mZiA9IChjb3B5ICYmIGRzdFN0YXJ0KSB8fCAwXG4gICAgLCBzdGFydCAgPSBvZmZbMV1cbiAgICAsIGxcbiAgICAsIGlcblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PSB0aGlzLmxlbmd0aCkge1xuICAgIGlmICghY29weSkgeyAvLyBzbGljZSwgYnV0IGZ1bGwgY29uY2F0IGlmIG11bHRpcGxlIGJ1ZmZlcnNcbiAgICAgIHJldHVybiB0aGlzLl9idWZzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuX2J1ZnNbMF1cbiAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZnMsIHRoaXMubGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIGNvcHksIG5lZWQgdG8gY29weSBpbmRpdmlkdWFsIGJ1ZmZlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkgLy8gYSBzbGljZSwgd2UgbmVlZCBzb21ldGhpbmcgdG8gY29weSBpbiB0b1xuICAgIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgZm9yIChpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgICAgYnVmb2ZmICs9IGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydClcbiAgICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgLy8gc2FmZWd1YXJkIHNvIHRoYXQgd2UgZG9uJ3QgcmV0dXJuIHVuaW5pdGlhbGl6ZWQgbWVtb3J5XG4gIGlmIChkc3QubGVuZ3RoID4gYnVmb2ZmKSByZXR1cm4gZHN0LnNsaWNlKDAsIGJ1Zm9mZilcblxuICByZXR1cm4gZHN0XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoYWxsb3dTbGljZSA9IGZ1bmN0aW9uIHNoYWxsb3dTbGljZSAoc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHN0YXJ0IDwgMClcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDwgMClcbiAgICBlbmQgKz0gdGhpcy5sZW5ndGhcblxuICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoc3RhcnQpXG4gICAgLCBlbmRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoZW5kKVxuICAgICwgYnVmZmVycyA9IHRoaXMuX2J1ZnMuc2xpY2Uoc3RhcnRPZmZzZXRbMF0sIGVuZE9mZnNldFswXSArIDEpXG5cbiAgaWYgKGVuZE9mZnNldFsxXSA9PSAwKVxuICAgIGJ1ZmZlcnMucG9wKClcbiAgZWxzZVxuICAgIGJ1ZmZlcnNbYnVmZmVycy5sZW5ndGgtMV0gPSBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoLTFdLnNsaWNlKDAsIGVuZE9mZnNldFsxXSlcblxuICBpZiAoc3RhcnRPZmZzZXRbMV0gIT0gMClcbiAgICBidWZmZXJzWzBdID0gYnVmZmVyc1swXS5zbGljZShzdGFydE9mZnNldFsxXSlcblxuICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoYnVmZmVycylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCkudG9TdHJpbmcoZW5jb2RpbmcpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiBjb25zdW1lIChieXRlcykge1xuICAvLyBmaXJzdCwgbm9ybWFsaXplIHRoZSBhcmd1bWVudCwgaW4gYWNjb3JkYW5jZSB3aXRoIGhvdyBCdWZmZXIgZG9lcyBpdFxuICBieXRlcyA9IE1hdGgudHJ1bmMoYnl0ZXMpXG4gIC8vIGRvIG5vdGhpbmcgaWYgbm90IGEgcG9zaXRpdmUgbnVtYmVyXG4gIGlmIChOdW1iZXIuaXNOYU4oYnl0ZXMpIHx8IGJ5dGVzIDw9IDApIHJldHVybiB0aGlzXG5cbiAgd2hpbGUgKHRoaXMuX2J1ZnMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzID49IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoKSB7XG4gICAgICBieXRlcyAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5sZW5ndGggLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMuX2J1ZnMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzWzBdID0gdGhpcy5fYnVmc1swXS5zbGljZShieXRlcylcbiAgICAgIHRoaXMubGVuZ3RoIC09IGJ5dGVzXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uIGR1cGxpY2F0ZSAoKSB7XG4gIHZhciBpID0gMFxuICAgICwgY29weSA9IG5ldyBCdWZmZXJMaXN0KClcblxuICBmb3IgKDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcblxuICByZXR1cm4gY29weVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy5fYnVmcy5sZW5ndGggPSAwXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnB1c2gobnVsbClcbn1cblxuXG47KGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAncmVhZERvdWJsZUJFJyA6IDhcbiAgICAsICdyZWFkRG91YmxlTEUnIDogOFxuICAgICwgJ3JlYWRGbG9hdEJFJyAgOiA0XG4gICAgLCAncmVhZEZsb2F0TEUnICA6IDRcbiAgICAsICdyZWFkSW50MzJCRScgIDogNFxuICAgICwgJ3JlYWRJbnQzMkxFJyAgOiA0XG4gICAgLCAncmVhZFVJbnQzMkJFJyA6IDRcbiAgICAsICdyZWFkVUludDMyTEUnIDogNFxuICAgICwgJ3JlYWRJbnQxNkJFJyAgOiAyXG4gICAgLCAncmVhZEludDE2TEUnICA6IDJcbiAgICAsICdyZWFkVUludDE2QkUnIDogMlxuICAgICwgJ3JlYWRVSW50MTZMRScgOiAyXG4gICAgLCAncmVhZEludDgnICAgICA6IDFcbiAgICAsICdyZWFkVUludDgnICAgIDogMVxuICB9XG5cbiAgZm9yICh2YXIgbSBpbiBtZXRob2RzKSB7XG4gICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRob2RzW21dKVttXSgwKVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCIxMDBcIjogXCJDb250aW51ZVwiLFxuICBcIjEwMVwiOiBcIlN3aXRjaGluZyBQcm90b2NvbHNcIixcbiAgXCIxMDJcIjogXCJQcm9jZXNzaW5nXCIsXG4gIFwiMjAwXCI6IFwiT0tcIixcbiAgXCIyMDFcIjogXCJDcmVhdGVkXCIsXG4gIFwiMjAyXCI6IFwiQWNjZXB0ZWRcIixcbiAgXCIyMDNcIjogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICBcIjIwNFwiOiBcIk5vIENvbnRlbnRcIixcbiAgXCIyMDVcIjogXCJSZXNldCBDb250ZW50XCIsXG4gIFwiMjA2XCI6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gIFwiMjA3XCI6IFwiTXVsdGktU3RhdHVzXCIsXG4gIFwiMjA4XCI6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICBcIjIyNlwiOiBcIklNIFVzZWRcIixcbiAgXCIzMDBcIjogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gIFwiMzAxXCI6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgXCIzMDJcIjogXCJGb3VuZFwiLFxuICBcIjMwM1wiOiBcIlNlZSBPdGhlclwiLFxuICBcIjMwNFwiOiBcIk5vdCBNb2RpZmllZFwiLFxuICBcIjMwNVwiOiBcIlVzZSBQcm94eVwiLFxuICBcIjMwN1wiOiBcIlRlbXBvcmFyeSBSZWRpcmVjdFwiLFxuICBcIjMwOFwiOiBcIlBlcm1hbmVudCBSZWRpcmVjdFwiLFxuICBcIjQwMFwiOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIFwiNDAxXCI6IFwiVW5hdXRob3JpemVkXCIsXG4gIFwiNDAyXCI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICBcIjQwM1wiOiBcIkZvcmJpZGRlblwiLFxuICBcIjQwNFwiOiBcIk5vdCBGb3VuZFwiLFxuICBcIjQwNVwiOiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICBcIjQwNlwiOiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIFwiNDA3XCI6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MDhcIjogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgXCI0MDlcIjogXCJDb25mbGljdFwiLFxuICBcIjQxMFwiOiBcIkdvbmVcIixcbiAgXCI0MTFcIjogXCJMZW5ndGggUmVxdWlyZWRcIixcbiAgXCI0MTJcIjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIFwiNDEzXCI6IFwiUGF5bG9hZCBUb28gTGFyZ2VcIixcbiAgXCI0MTRcIjogXCJVUkkgVG9vIExvbmdcIixcbiAgXCI0MTVcIjogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIFwiNDE2XCI6IFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIFwiNDE3XCI6IFwiRXhwZWN0YXRpb24gRmFpbGVkXCIsXG4gIFwiNDE4XCI6IFwiSSdtIGEgdGVhcG90XCIsXG4gIFwiNDIxXCI6IFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFwiLFxuICBcIjQyMlwiOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIFwiNDIzXCI6IFwiTG9ja2VkXCIsXG4gIFwiNDI0XCI6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgXCI0MjVcIjogXCJVbm9yZGVyZWQgQ29sbGVjdGlvblwiLFxuICBcIjQyNlwiOiBcIlVwZ3JhZGUgUmVxdWlyZWRcIixcbiAgXCI0MjhcIjogXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcIixcbiAgXCI0MjlcIjogXCJUb28gTWFueSBSZXF1ZXN0c1wiLFxuICBcIjQzMVwiOiBcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcIixcbiAgXCI0NTFcIjogXCJVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29uc1wiLFxuICBcIjUwMFwiOiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiLFxuICBcIjUwMVwiOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICBcIjUwMlwiOiBcIkJhZCBHYXRld2F5XCIsXG4gIFwiNTAzXCI6IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiLFxuICBcIjUwNFwiOiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICBcIjUwNVwiOiBcIkhUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gIFwiNTA2XCI6IFwiVmFyaWFudCBBbHNvIE5lZ290aWF0ZXNcIixcbiAgXCI1MDdcIjogXCJJbnN1ZmZpY2llbnQgU3RvcmFnZVwiLFxuICBcIjUwOFwiOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgXCI1MDlcIjogXCJCYW5kd2lkdGggTGltaXQgRXhjZWVkZWRcIixcbiAgXCI1MTBcIjogXCJOb3QgRXh0ZW5kZWRcIixcbiAgXCI1MTFcIjogXCJOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCJcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG5cdGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdC8vIG9yaWdpbmFsIGxlbmd0aCwgcGx1cyB0aGUgcmVjZWl2ZXIsIG1pbnVzIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIHJlY2VpdmVyKVxuXHRcdFx0JGRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHRmdW5jLFxuXHRcdFx0XHQnbGVuZ3RoJyxcblx0XHRcdFx0eyB2YWx1ZTogMSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZnVuYztcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbG9uZXMgKGNvcGllcykgYW4gT2JqZWN0IHVzaW5nIGRlZXAgY29weWluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgZGVmYXVsdCwgYnV0IGlmIHlvdSBhcmUgY2VydGFpblxuICogdGhlcmUgYXJlIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBvYmplY3QsIHlvdSBjYW4gc2F2ZSBzb21lIENQVSB0aW1lXG4gKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLlxuICpcbiAqIENhdXRpb246IGlmIGBjaXJjdWxhcmAgaXMgZmFsc2UgYW5kIGBwYXJlbnRgIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBgcGFyZW50YCAtIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG4gKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluXG4gKiAgICBjaXJjdWxhciByZWZlcmVuY2VzLiAob3B0aW9uYWwgLSB0cnVlIGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0gYGRlcHRoYCAtIHNldCB0byBhIG51bWJlciBpZiB0aGUgb2JqZWN0IGlzIG9ubHkgdG8gYmUgY2xvbmVkIHRvXG4gKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KVxuICogQHBhcmFtIGBwcm90b3R5cGVgIC0gc2V0cyB0aGUgcHJvdG90eXBlIHRvIGJlIHVzZWQgd2hlbiBjbG9uaW5nIGFuIG9iamVjdC5cbiAqICAgIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIHBhcmVudCBwcm90b3R5cGUpLlxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUpIHtcbiAgdmFyIGZpbHRlcjtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBmaWx0ZXIgPSBjaXJjdWxhci5maWx0ZXI7XG4gICAgY2lyY3VsYXIgPSBjaXJjdWxhci5jaXJjdWxhclxuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNSZWdFeHAocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7XG4gICAgICBpZiAocGFyZW50Lmxhc3RJbmRleCkgY2hpbGQubGFzdEluZGV4ID0gcGFyZW50Lmxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNEYXRlKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmICh1c2VCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7XG59XG5cbi8qKlxuICogU2ltcGxlIGZsYXQgY2xvbmUgdXNpbmcgcHJvdG90eXBlLCBhY2NlcHRzIG9ubHkgb2JqZWN0cywgdXNlZnVsbCBmb3IgcHJvcGVydHlcbiAqIG92ZXJyaWRlIG9uIEZMQVQgY29uZmlndXJhdGlvbiBvYmplY3QgKG5vIG5lc3RlZCBwcm9wcykuXG4gKlxuICogVVNFIFdJVEggQ0FVVElPTiEgVGhpcyBtYXkgbm90IGJlaGF2ZSBhcyB5b3Ugd2lzaCBpZiB5b3UgZG8gbm90IGtub3cgaG93IHRoaXNcbiAqIHdvcmtzLlxuICovXG5jbG9uZS5jbG9uZVByb3RvdHlwZSA9IGZ1bmN0aW9uIGNsb25lUHJvdG90eXBlKHBhcmVudCkge1xuICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBjID0gZnVuY3Rpb24gKCkge307XG4gIGMucHJvdG90eXBlID0gcGFyZW50O1xuICByZXR1cm4gbmV3IGMoKTtcbn07XG5cbi8vIHByaXZhdGUgdXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gX19vYmpUb1N0cihvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59O1xuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbmNsb25lLl9faXNBcnJheSA9IF9faXNBcnJheTtcblxuZnVuY3Rpb24gX19pc1JlZ0V4cChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59O1xuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlICAgICAgICAgICAgID0gcmVxdWlyZShcInR5cGUvdmFsdWUvaXNcIilcbiAgLCBlbnN1cmVWYWx1ZSAgICAgICAgID0gcmVxdWlyZShcInR5cGUvdmFsdWUvZW5zdXJlXCIpXG4gICwgZW5zdXJlUGxhaW5GdW5jdGlvbiA9IHJlcXVpcmUoXCJ0eXBlL3BsYWluLWZ1bmN0aW9uL2Vuc3VyZVwiKVxuICAsIGNvcHkgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvY29weVwiKVxuICAsIG5vcm1hbGl6ZU9wdGlvbnMgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnNcIilcbiAgLCBtYXAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L21hcFwiKTtcblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVmaW5lO1xuXG5kZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgZGVzYywgb3B0aW9ucykge1xuXHR2YXIgdmFsdWUgPSBlbnN1cmVWYWx1ZShkZXNjKSAmJiBlbnN1cmVQbGFpbkZ1bmN0aW9uKGRlc2MudmFsdWUpLCBkZ3M7XG5cdGRncyA9IGNvcHkoZGVzYyk7XG5cdGRlbGV0ZSBkZ3Mud3JpdGFibGU7XG5cdGRlbGV0ZSBkZ3MudmFsdWU7XG5cdGRncy5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFvcHRpb25zLm92ZXJ3cml0ZURlZmluaXRpb24gJiYgaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkgcmV0dXJuIHZhbHVlO1xuXHRcdGRlc2MudmFsdWUgPSBiaW5kLmNhbGwodmFsdWUsIG9wdGlvbnMucmVzb2x2ZUNvbnRleHQgPyBvcHRpb25zLnJlc29sdmVDb250ZXh0KHRoaXMpIDogdGhpcyk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZGVzYyk7XG5cdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdH07XG5cdHJldHVybiBkZ3M7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm9wcy8qLCBvcHRpb25zKi8pIHtcblx0dmFyIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKGFyZ3VtZW50c1sxXSk7XG5cdGlmIChpc1ZhbHVlKG9wdGlvbnMucmVzb2x2ZUNvbnRleHQpKSBlbnN1cmVQbGFpbkZ1bmN0aW9uKG9wdGlvbnMucmVzb2x2ZUNvbnRleHQpO1xuXHRyZXR1cm4gbWFwKHByb3BzLCBmdW5jdGlvbiAoZGVzYywgbmFtZSkgeyByZXR1cm4gZGVmaW5lKG5hbWUsIGRlc2MsIG9wdGlvbnMpOyB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgICAgICAgICA9IHJlcXVpcmUoXCJ0eXBlL3ZhbHVlL2lzXCIpXG4gICwgaXNQbGFpbkZ1bmN0aW9uID0gcmVxdWlyZShcInR5cGUvcGxhaW4tZnVuY3Rpb24vaXNcIilcbiAgLCBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvYXNzaWduXCIpXG4gICwgbm9ybWFsaXplT3B0cyAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCIpXG4gICwgY29udGFpbnMgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nLyMvY29udGFpbnNcIik7XG5cbnZhciBkID0gKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRzY3IsIHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgdywgb3B0aW9ucywgZGVzYztcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IHR5cGVvZiBkc2NyICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdHZhbHVlID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuXHR9XG5cdGlmIChpc1ZhbHVlKGRzY3IpKSB7XG5cdFx0YyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJjXCIpO1xuXHRcdGUgPSBjb250YWlucy5jYWxsKGRzY3IsIFwiZVwiKTtcblx0XHR3ID0gY29udGFpbnMuY2FsbChkc2NyLCBcIndcIik7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IHcgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fVxuXG5cdGRlc2MgPSB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlLCB3cml0YWJsZTogdyB9O1xuXHRyZXR1cm4gIW9wdGlvbnMgPyBkZXNjIDogYXNzaWduKG5vcm1hbGl6ZU9wdHMob3B0aW9ucyksIGRlc2MpO1xufSk7XG5cbmQuZ3MgPSBmdW5jdGlvbiAoZHNjciwgZ2V0LCBzZXQvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBjLCBlLCBvcHRpb25zLCBkZXNjO1xuXHRpZiAodHlwZW9mIGRzY3IgIT09IFwic3RyaW5nXCIpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IGdldDtcblx0XHRnZXQgPSBkc2NyO1xuXHRcdGRzY3IgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbM107XG5cdH1cblx0aWYgKCFpc1ZhbHVlKGdldCkpIHtcblx0XHRnZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzUGxhaW5GdW5jdGlvbihnZXQpKSB7XG5cdFx0b3B0aW9ucyA9IGdldDtcblx0XHRnZXQgPSBzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzVmFsdWUoc2V0KSkge1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICghaXNQbGFpbkZ1bmN0aW9uKHNldCkpIHtcblx0XHRvcHRpb25zID0gc2V0O1xuXHRcdHNldCA9IHVuZGVmaW5lZDtcblx0fVxuXHRpZiAoaXNWYWx1ZShkc2NyKSkge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsIFwiY1wiKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCBcImVcIik7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IHRydWU7XG5cdFx0ZSA9IGZhbHNlO1xuXHR9XG5cblx0ZGVzYyA9IHsgZ2V0OiBnZXQsIHNldDogc2V0LCBjb25maWd1cmFibGU6IGMsIGVudW1lcmFibGU6IGUgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn07XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGlmdCA9IHJlcXVpcmUoJ3N0cmVhbS1zaGlmdCcpXG5cbnZhciBTSUdOQUxfRkxVU0ggPSAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSlcbiAgPyBCdWZmZXIuZnJvbShbMF0pXG4gIDogbmV3IEJ1ZmZlcihbMF0pXG5cbnZhciBvbnVuY29yayA9IGZ1bmN0aW9uKHNlbGYsIGZuKSB7XG4gIGlmIChzZWxmLl9jb3JrZWQpIHNlbGYub25jZSgndW5jb3JrJywgZm4pXG4gIGVsc2UgZm4oKVxufVxuXG52YXIgYXV0b0Rlc3Ryb3kgPSBmdW5jdGlvbiAoc2VsZiwgZXJyKSB7XG4gIGlmIChzZWxmLl9hdXRvRGVzdHJveSkgc2VsZi5kZXN0cm95KGVycilcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uKHNlbGYsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikgYXV0b0Rlc3Ryb3koc2VsZiwgZXJyLm1lc3NhZ2UgPT09ICdwcmVtYXR1cmUgY2xvc2UnID8gbnVsbCA6IGVycilcbiAgICBlbHNlIGlmIChlbmQgJiYgIXNlbGYuX2VuZGVkKSBzZWxmLmVuZCgpXG4gIH1cbn1cblxudmFyIGVuZCA9IGZ1bmN0aW9uKHdzLCBmbikge1xuICBpZiAoIXdzKSByZXR1cm4gZm4oKVxuICBpZiAod3MuX3dyaXRhYmxlU3RhdGUgJiYgd3MuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSkgcmV0dXJuIHdzLmVuZChmbilcbiAgd3MuZW5kKClcbiAgZm4oKVxufVxuXG52YXIgdG9TdHJlYW1zMiA9IGZ1bmN0aW9uKHJzKSB7XG4gIHJldHVybiBuZXcgKHN0cmVhbS5SZWFkYWJsZSkoe29iamVjdE1vZGU6dHJ1ZSwgaGlnaFdhdGVyTWFyazoxNn0pLndyYXAocnMpXG59XG5cbnZhciBEdXBsZXhpZnkgPSBmdW5jdGlvbih3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleGlmeSkpIHJldHVybiBuZXcgRHVwbGV4aWZ5KHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cylcbiAgc3RyZWFtLkR1cGxleC5jYWxsKHRoaXMsIG9wdHMpXG5cbiAgdGhpcy5fd3JpdGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlID0gbnVsbFxuICB0aGlzLl9yZWFkYWJsZTIgPSBudWxsXG5cbiAgdGhpcy5fYXV0b0Rlc3Ryb3kgPSAhb3B0cyB8fCBvcHRzLmF1dG9EZXN0cm95ICE9PSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuZGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZEVuZCA9ICFvcHRzIHx8IG9wdHMuZW5kICE9PSBmYWxzZVxuICB0aGlzLl9jb3JrZWQgPSAxIC8vIHN0YXJ0IGNvcmtlZFxuICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX3Vud3JpdGUgPSBudWxsXG4gIHRoaXMuX3VucmVhZCA9IG51bGxcbiAgdGhpcy5fZW5kZWQgPSBmYWxzZVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAod3JpdGFibGUpIHRoaXMuc2V0V3JpdGFibGUod3JpdGFibGUpXG4gIGlmIChyZWFkYWJsZSkgdGhpcy5zZXRSZWFkYWJsZShyZWFkYWJsZSlcbn1cblxuaW5oZXJpdHMoRHVwbGV4aWZ5LCBzdHJlYW0uRHVwbGV4KVxuXG5EdXBsZXhpZnkub2JqID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTZcbiAgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCsrdGhpcy5fY29ya2VkID09PSAxKSB0aGlzLmVtaXQoJ2NvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fY29ya2VkICYmIC0tdGhpcy5fY29ya2VkID09PSAwKSB0aGlzLmVtaXQoJ3VuY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0V3JpdGFibGUgPSBmdW5jdGlvbih3cml0YWJsZSkge1xuICBpZiAodGhpcy5fdW53cml0ZSkgdGhpcy5fdW53cml0ZSgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHdyaXRhYmxlICYmIHdyaXRhYmxlLmRlc3Ryb3kpIHdyaXRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHdyaXRhYmxlID09PSBudWxsIHx8IHdyaXRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3Mod3JpdGFibGUsIHt3cml0YWJsZTp0cnVlLCByZWFkYWJsZTpmYWxzZX0sIGRlc3Ryb3llcih0aGlzLCB0aGlzLl9mb3J3YXJkRW5kKSlcblxuICB2YXIgb25kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbmRyYWluID0gc2VsZi5fb25kcmFpblxuICAgIHNlbGYuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fd3JpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbilcbiAgICB1bmVuZCgpXG4gIH1cblxuICBpZiAodGhpcy5fdW53cml0ZSkgcHJvY2Vzcy5uZXh0VGljayhvbmRyYWluKSAvLyBmb3JjZSBhIGRyYWluIG9uIHN0cmVhbSByZXNldCB0byBhdm9pZCBsaXZlbG9ja3NcblxuICB0aGlzLl93cml0YWJsZSA9IHdyaXRhYmxlXG4gIHRoaXMuX3dyaXRhYmxlLm9uKCdkcmFpbicsIG9uZHJhaW4pXG4gIHRoaXMuX3Vud3JpdGUgPSBjbGVhclxuXG4gIHRoaXMudW5jb3JrKCkgLy8gYWx3YXlzIHVuY29yayBzZXRXcml0YWJsZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFJlYWRhYmxlID0gZnVuY3Rpb24ocmVhZGFibGUpIHtcbiAgaWYgKHRoaXMuX3VucmVhZCkgdGhpcy5fdW5yZWFkKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAocmVhZGFibGUgJiYgcmVhZGFibGUuZGVzdHJveSkgcmVhZGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocmVhZGFibGUgPT09IG51bGwgfHwgcmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gICAgdGhpcy5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyhyZWFkYWJsZSwge3dyaXRhYmxlOmZhbHNlLCByZWFkYWJsZTp0cnVlfSwgZGVzdHJveWVyKHRoaXMpKVxuXG4gIHZhciBvbnJlYWRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZm9yd2FyZCgpXG4gIH1cblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnB1c2gobnVsbClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fcmVhZGFibGUgPSByZWFkYWJsZVxuICB0aGlzLl9yZWFkYWJsZTIgPSByZWFkYWJsZS5fcmVhZGFibGVTdGF0ZSA/IHJlYWRhYmxlIDogdG9TdHJlYW1zMihyZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbignZW5kJywgb25lbmQpXG4gIHRoaXMuX3VucmVhZCA9IGNsZWFyXG5cbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZvcndhcmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZvcndhcmRpbmcgfHwgIXRoaXMuX3JlYWRhYmxlMiB8fCAhdGhpcy5fZHJhaW5lZCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGRhdGFcblxuICB3aGlsZSAodGhpcy5fZHJhaW5lZCAmJiAoZGF0YSA9IHNoaWZ0KHRoaXMuX3JlYWRhYmxlMikpICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSBjb250aW51ZVxuICAgIHRoaXMuX2RyYWluZWQgPSB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIpXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIHZhciBvbmRyYWluID0gdGhpcy5fb25kcmFpblxuICAgIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oZXJyKVxuICAgIGVsc2UgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIGlmICh0aGlzLl9mb3J3YXJkRGVzdHJveSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZSAmJiB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KSB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KClcbiAgICBpZiAodGhpcy5fd3JpdGFibGUgJiYgdGhpcy5fd3JpdGFibGUuZGVzdHJveSkgdGhpcy5fd3JpdGFibGUuZGVzdHJveSgpXG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKClcbiAgaWYgKHRoaXMuX2NvcmtlZCkgcmV0dXJuIG9udW5jb3JrKHRoaXMsIHRoaXMuX3dyaXRlLmJpbmQodGhpcywgZGF0YSwgZW5jLCBjYikpXG4gIGlmIChkYXRhID09PSBTSUdOQUxfRkxVU0gpIHJldHVybiB0aGlzLl9maW5pc2goY2IpXG4gIGlmICghdGhpcy5fd3JpdGFibGUpIHJldHVybiBjYigpXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlLndyaXRlKGRhdGEpID09PSBmYWxzZSkgdGhpcy5fb25kcmFpbiA9IGNiXG4gIGVsc2UgY2IoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbihjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5lbWl0KCdwcmVlbmQnKVxuICBvbnVuY29yayh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBlbmQoc2VsZi5fZm9yd2FyZEVuZCAmJiBzZWxmLl93cml0YWJsZSwgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBoYXh4IHRvIG5vdCBlbWl0IHByZWZpbmlzaCB0d2ljZVxuICAgICAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPT09IGZhbHNlKSBzZWxmLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgb251bmNvcmsoc2VsZiwgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKG51bGwsIG51bGwsIGRhdGEpXG4gIGlmICh0eXBlb2YgZW5jID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQoZGF0YSwgbnVsbCwgZW5jKVxuICB0aGlzLl9lbmRlZCA9IHRydWVcbiAgaWYgKGRhdGEpIHRoaXMud3JpdGUoZGF0YSlcbiAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZykgdGhpcy53cml0ZShTSUdOQUxfRkxVU0gpXG4gIHJldHVybiBzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNiKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleGlmeVxuIiwidmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxudmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzQ2hpbGRQcm9jZXNzID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc3RkaW8gJiYgQXJyYXkuaXNBcnJheShzdHJlYW0uc3RkaW8pICYmIHN0cmVhbS5zdGRpby5sZW5ndGggPT09IDNcbn07XG5cbnZhciBlb3MgPSBmdW5jdGlvbihzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuXHRpZiAoIW9wdHMpIG9wdHMgPSB7fTtcblxuXHRjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG5cblx0dmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXHR2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cdHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgKG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZSk7XG5cdHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgKG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZSk7XG5cdHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcblxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcblx0fTtcblxuXHR2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR3cml0YWJsZSA9IGZhbHNlO1xuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcblx0fTtcblxuXHR2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcblx0XHRyZWFkYWJsZSA9IGZhbHNlO1xuXHRcdGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcblx0fTtcblxuXHR2YXIgb25leGl0ID0gZnVuY3Rpb24oZXhpdENvZGUpIHtcblx0XHRjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXhpdENvZGUgPyBuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICcgKyBleGl0Q29kZSkgOiBudWxsKTtcblx0fTtcblxuXHR2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuXHR9O1xuXG5cdHZhciBvbmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0cHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlbmV4dHRpY2spO1xuXHR9O1xuXG5cdHZhciBvbmNsb3NlbmV4dHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoY2FuY2VsbGVkKSByZXR1cm47XG5cdFx0aWYgKHJlYWRhYmxlICYmICEocnMgJiYgKHJzLmVuZGVkICYmICFycy5kZXN0cm95ZWQpKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0XHRpZiAod3JpdGFibGUgJiYgISh3cyAmJiAod3MuZW5kZWQgJiYgIXdzLmRlc3Ryb3llZCkpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHR9O1xuXG5cdHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdH07XG5cblx0aWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG5cdFx0c3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO1xuXHRcdGVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0fSBlbHNlIGlmICh3cml0YWJsZSAmJiAhd3MpIHsgLy8gbGVnYWN5IHN0cmVhbXNcblx0XHRzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHR9XG5cblx0aWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7XG5cblx0c3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG5cdHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHRpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcblx0c3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRjYW5jZWxsZWQgPSB0cnVlO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdFx0aWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uZXhpdCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIi8vIEluc3BpcmVkIGJ5IEdvb2dsZSBDbG9zdXJlOlxuLy8gaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9cbi8vIGNsb3N1cmVfZ29vZ19hcnJheV9hcnJheS5qcy5odG1sI2dvb2cuYXJyYXkuY2xlYXJcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB2YWx1ZSA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YWx1ZSh0aGlzKS5sZW5ndGggPSAwO1xuXHRyZXR1cm4gdGhpcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG51bWJlcklzTmFOICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci9pcy1uYW5cIilcbiAgLCB0b1Bvc0ludCAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9udW1iZXIvdG8tcG9zLWludGVnZXJcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIilcbiAgLCBpbmRleE9mICAgICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG4gICwgb2JqSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgYWJzICAgICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIGZsb29yICAgICAgICAgICAgID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXgqLykge1xuXHR2YXIgaSwgbGVuZ3RoLCBmcm9tSW5kZXgsIHZhbDtcblx0aWYgKCFudW1iZXJJc05hTihzZWFyY2hFbGVtZW50KSkgcmV0dXJuIGluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRsZW5ndGggPSB0b1Bvc0ludCh2YWx1ZSh0aGlzKS5sZW5ndGgpO1xuXHRmcm9tSW5kZXggPSBhcmd1bWVudHNbMV07XG5cdGlmIChpc05hTihmcm9tSW5kZXgpKSBmcm9tSW5kZXggPSAwO1xuXHRlbHNlIGlmIChmcm9tSW5kZXggPj0gMCkgZnJvbUluZGV4ID0gZmxvb3IoZnJvbUluZGV4KTtcblx0ZWxzZSBmcm9tSW5kZXggPSB0b1Bvc0ludCh0aGlzLmxlbmd0aCkgLSBmbG9vcihhYnMoZnJvbUluZGV4KSk7XG5cblx0Zm9yIChpID0gZnJvbUluZGV4OyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRpZiAob2JqSGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBpKSkge1xuXHRcdFx0dmFsID0gdGhpc1tpXTtcblx0XHRcdGlmIChudW1iZXJJc05hTih2YWwpKSByZXR1cm4gaTsgLy8gSnNsaW50OiBpZ25vcmVcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBBcnJheS5mcm9tIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGZyb20gPSBBcnJheS5mcm9tLCBhcnIsIHJlc3VsdDtcblx0aWYgKHR5cGVvZiBmcm9tICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0YXJyID0gW1wicmF6XCIsIFwiZHdhXCJdO1xuXHRyZXN1bHQgPSBmcm9tKGFycik7XG5cdHJldHVybiBCb29sZWFuKHJlc3VsdCAmJiByZXN1bHQgIT09IGFyciAmJiByZXN1bHRbMV0gPT09IFwiZHdhXCIpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvclxuICAsIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzRnVuY3Rpb24gICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWZ1bmN0aW9uXCIpXG4gICwgdG9Qb3NJbnQgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCIpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgaXNWYWx1ZSAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L2lzLXZhbHVlXCIpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIGlzQXJyYXkgICAgICAgID0gQXJyYXkuaXNBcnJheVxuICAsIGNhbGwgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZXNjICAgICAgICAgICA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlMaWtlLyosIG1hcEZuLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1hcEZuID0gYXJndW1lbnRzWzFdXG5cdCAgLCB0aGlzQXJnID0gYXJndW1lbnRzWzJdXG5cdCAgLCBDb250ZXh0XG5cdCAgLCBpXG5cdCAgLCBqXG5cdCAgLCBhcnJcblx0ICAsIGxlbmd0aFxuXHQgICwgY29kZVxuXHQgICwgaXRlcmF0b3Jcblx0ICAsIHJlc3VsdFxuXHQgICwgZ2V0SXRlcmF0b3Jcblx0ICAsIHZhbHVlO1xuXG5cdGFycmF5TGlrZSA9IE9iamVjdCh2YWxpZFZhbHVlKGFycmF5TGlrZSkpO1xuXG5cdGlmIChpc1ZhbHVlKG1hcEZuKSkgY2FsbGFibGUobWFwRm4pO1xuXHRpZiAoIXRoaXMgfHwgdGhpcyA9PT0gQXJyYXkgfHwgIWlzRnVuY3Rpb24odGhpcykpIHtcblx0XHQvLyBSZXN1bHQ6IFBsYWluIGFycmF5XG5cdFx0aWYgKCFtYXBGbikge1xuXHRcdFx0aWYgKGlzQXJndW1lbnRzKGFycmF5TGlrZSkpIHtcblx0XHRcdFx0Ly8gU291cmNlOiBBcmd1bWVudHNcblx0XHRcdFx0bGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gMSkgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIGFycmF5TGlrZSk7XG5cdFx0XHRcdGFyciA9IG5ldyBBcnJheSgxKTtcblx0XHRcdFx0YXJyWzBdID0gYXJyYXlMaWtlWzBdO1xuXHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFycmF5XG5cdFx0XHRcdGFyciA9IG5ldyBBcnJheSgobGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aCkpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIGFycltpXSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gW107XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUmVzdWx0OiBOb24gcGxhaW4gYXJyYXlcblx0XHRDb250ZXh0ID0gdGhpcztcblx0fVxuXG5cdGlmICghaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0aWYgKChnZXRJdGVyYXRvciA9IGFycmF5TGlrZVtpdGVyYXRvclN5bWJvbF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFNvdXJjZTogSXRlcmF0b3Jcblx0XHRcdGl0ZXJhdG9yID0gY2FsbGFibGUoZ2V0SXRlcmF0b3IpLmNhbGwoYXJyYXlMaWtlKTtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaSkgOiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHRsZW5ndGggPSBpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJyYXlMaWtlKSkge1xuXHRcdFx0Ly8gU291cmNlOiBTdHJpbmdcblx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQoKTtcblx0XHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFsdWUgPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdGlmIChpICsgMSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcblx0XHRcdFx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHZhbHVlICs9IGFycmF5TGlrZVsrK2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHZhbHVlLCBqKSA6IHZhbHVlO1xuXHRcdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGosIGRlc2MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycltqXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCsrajtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGo7XG5cdFx0fVxuXHR9XG5cdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFNvdXJjZTogYXJyYXkgb3IgYXJyYXktbGlrZVxuXHRcdGxlbmd0aCA9IHRvUG9zSW50KGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dChsZW5ndGgpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgYXJyYXlMaWtlW2ldLCBpKSA6IGFycmF5TGlrZVtpXTtcblx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycltpXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoQ29udGV4dCkge1xuXHRcdGRlc2MudmFsdWUgPSBudWxsO1xuXHRcdGFyci5sZW5ndGggPSBsZW5ndGg7XG5cdH1cblx0cmV0dXJuIGFycjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAsIGlkID0gb2JqVG9TdHJpbmcuY2FsbCgoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZDsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICwgaXNGdW5jdGlvblN0cmluZ1RhZyA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eW29iamVjdCBbQS1aYS16MC05XSpGdW5jdGlvbl0kLyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiBpc0Z1bmN0aW9uU3RyaW5nVGFnKG9ialRvU3RyaW5nLmNhbGwodmFsdWUpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHt9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE1hdGguc2lnbiA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzaWduID0gTWF0aC5zaWduO1xuXHRpZiAodHlwZW9mIHNpZ24gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gc2lnbigxMCkgPT09IDEgJiYgc2lnbigtMjApID09PSAtMTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSAwKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiB2YWx1ZSA+IDAgPyAxIDogLTE7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE51bWJlci5pc05hTiA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBudW1iZXJJc05hTiA9IE51bWJlci5pc05hTjtcblx0aWYgKHR5cGVvZiBudW1iZXJJc05hTiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAhbnVtYmVySXNOYU4oe30pICYmIG51bWJlcklzTmFOKE5hTikgJiYgIW51bWJlcklzTmFOKDM0KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc2lnbiAgPSByZXF1aXJlKFwiLi4vbWF0aC9zaWduXCIpXG4gICwgYWJzICAgPSBNYXRoLmFic1xuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIDA7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKHZhbHVlID09PSAwIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHNpZ24odmFsdWUpICogZmxvb3IoYWJzKHZhbHVlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKFwiLi90by1pbnRlZ2VyXCIpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBtYXgoMCwgdG9JbnRlZ2VyKHZhbHVlKSk7IH07XG4iLCIvLyBJbnRlcm5hbCBtZXRob2QsIHVzZWQgYnkgaXRlcmF0aW9uIGZ1bmN0aW9ucy5cbi8vIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2gga2V5LXZhbHVlIHBhaXIgZm91bmQgaW4gb2JqZWN0XG4vLyBPcHRpb25hbGx5IHRha2VzIGNvbXBhcmVGbiB0byBpdGVyYXRlIG9iamVjdCBpbiBzcGVjaWZpYyBvcmRlclxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNhbGxhYmxlICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLXZhbHVlXCIpXG4gICwgYmluZCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICAsIGNhbGwgICAgICAgICAgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBrZXlzICAgICAgICAgICAgICAgICAgICA9IE9iamVjdC5rZXlzXG4gICwgb2JqUHJvcGVydHlJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGRlZlZhbCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKG9iaiwgY2IvKiwgdGhpc0FyZywgY29tcGFyZUZuKi8pIHtcblx0XHR2YXIgbGlzdCwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgY29tcGFyZUZuID0gYXJndW1lbnRzWzNdO1xuXHRcdG9iaiA9IE9iamVjdCh2YWx1ZShvYmopKTtcblx0XHRjYWxsYWJsZShjYik7XG5cblx0XHRsaXN0ID0ga2V5cyhvYmopO1xuXHRcdGlmIChjb21wYXJlRm4pIHtcblx0XHRcdGxpc3Quc29ydCh0eXBlb2YgY29tcGFyZUZuID09PSBcImZ1bmN0aW9uXCIgPyBiaW5kLmNhbGwoY29tcGFyZUZuLCBvYmopIDogdW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIikgbWV0aG9kID0gbGlzdFttZXRob2RdO1xuXHRcdHJldHVybiBjYWxsLmNhbGwobWV0aG9kLCBsaXN0LCBmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuXHRcdFx0aWYgKCFvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KSkgcmV0dXJuIGRlZlZhbDtcblx0XHRcdHJldHVybiBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIG9ialtrZXldLCBrZXksIG9iaiwgaW5kZXgpO1xuXHRcdH0pO1xuXHR9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sIG9iajtcblx0aWYgKHR5cGVvZiBhc3NpZ24gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRvYmogPSB7IGZvbzogXCJyYXpcIiB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogXCJkd2FcIiB9LCB7IHRyenk6IFwidHJ6eVwiIH0pO1xuXHRyZXR1cm4gb2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSA9PT0gXCJyYXpkd2F0cnp5XCI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlzICA9IHJlcXVpcmUoXCIuLi9rZXlzXCIpXG4gICwgdmFsdWUgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBtYXggICA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZXN0LCBzcmMvKiwg4oCmc3JjbiovKSB7XG5cdHZhciBlcnJvciwgaSwgbGVuZ3RoID0gbWF4KGFyZ3VtZW50cy5sZW5ndGgsIDIpLCBhc3NpZ247XG5cdGRlc3QgPSBPYmplY3QodmFsdWUoZGVzdCkpO1xuXHRhc3NpZ24gPSBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Rba2V5XSA9IHNyY1trZXldO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZTtcblx0XHR9XG5cdH07XG5cdGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRrZXlzKHNyYykuZm9yRWFjaChhc3NpZ24pO1xuXHR9XG5cdGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB0aHJvdyBlcnJvcjtcblx0cmV0dXJuIGRlc3Q7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhRnJvbSAgPSByZXF1aXJlKFwiLi4vYXJyYXkvZnJvbVwiKVxuICAsIGFzc2lnbiA9IHJlcXVpcmUoXCIuL2Fzc2lnblwiKVxuICAsIHZhbHVlICA9IHJlcXVpcmUoXCIuL3ZhbGlkLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmovKiwgcHJvcGVydHlOYW1lcywgb3B0aW9ucyovKSB7XG5cdHZhciBjb3B5ID0gT2JqZWN0KHZhbHVlKG9iaikpLCBwcm9wZXJ0eU5hbWVzID0gYXJndW1lbnRzWzFdLCBvcHRpb25zID0gT2JqZWN0KGFyZ3VtZW50c1syXSk7XG5cdGlmIChjb3B5ICE9PSBvYmogJiYgIXByb3BlcnR5TmFtZXMpIHJldHVybiBjb3B5O1xuXHR2YXIgcmVzdWx0ID0ge307XG5cdGlmIChwcm9wZXJ0eU5hbWVzKSB7XG5cdFx0YUZyb20ocHJvcGVydHlOYW1lcywgZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuXHRcdFx0aWYgKG9wdGlvbnMuZW5zdXJlIHx8IHByb3BlcnR5TmFtZSBpbiBvYmopIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gb2JqW3Byb3BlcnR5TmFtZV07XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0YXNzaWduKHJlc3VsdCwgb2JqKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIFdvcmthcm91bmQgZm9yIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTI4MDRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBzaGltO1xuXG5pZiAoIXJlcXVpcmUoXCIuL3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWRcIikoKSkge1xuXHRzaGltID0gcmVxdWlyZShcIi4vc2V0LXByb3RvdHlwZS1vZi9zaGltXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBudWxsT2JqZWN0LCBwb2x5UHJvcHMsIGRlc2M7XG5cdGlmICghc2hpbSkgcmV0dXJuIGNyZWF0ZTtcblx0aWYgKHNoaW0ubGV2ZWwgIT09IDEpIHJldHVybiBjcmVhdGU7XG5cblx0bnVsbE9iamVjdCA9IHt9O1xuXHRwb2x5UHJvcHMgPSB7fTtcblx0ZGVzYyA9IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuXHRcdFx0cG9seVByb3BzW25hbWVdID0ge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cG9seVByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHBvbHlQcm9wcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNoaW0sIFwibnVsbFBvbHlmaWxsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogbnVsbE9iamVjdFxuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKHByb3RvdHlwZSA9PT0gbnVsbCA/IG51bGxPYmplY3QgOiBwcm90b3R5cGUsIHByb3BzKTtcblx0fTtcbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9faXRlcmF0ZVwiKShcImZvckVhY2hcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIG1hcCA9IHsgZnVuY3Rpb246IHRydWUsIG9iamVjdDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKGlzVmFsdWUodmFsdWUpICYmIG1hcFt0eXBlb2YgdmFsdWVdKSB8fCBmYWxzZTsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VuZGVmaW5lZCA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9ub29wXCIpKCk7IC8vIFN1cHBvcnQgRVMzIGVuZ2luZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgIT09IF91bmRlZmluZWQgJiYgdmFsICE9PSBudWxsOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE9iamVjdC5rZXlzIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dHJ5IHtcblx0XHRPYmplY3Qua2V5cyhcInByaW1pdGl2ZVwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi9pcy12YWx1ZVwiKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBrZXlzKGlzVmFsdWUob2JqZWN0KSA/IE9iamVjdChvYmplY3QpIDogb2JqZWN0KTsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIGZvckVhY2ggID0gcmVxdWlyZShcIi4vZm9yLWVhY2hcIilcbiAgLCBjYWxsICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNiLyosIHRoaXNBcmcqLykge1xuXHR2YXIgcmVzdWx0ID0ge30sIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG5cdGNhbGxhYmxlKGNiKTtcblx0Zm9yRWFjaChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCB0YXJnZXRPYmosIGluZGV4KSB7XG5cdFx0cmVzdWx0W2tleV0gPSBjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHZhbHVlLCBrZXksIHRhcmdldE9iaiwgaW5kZXgpO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzMS8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAoIWlzVmFsdWUob3B0aW9ucykpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJnLyosIOKApmFyZ3MqLykge1xuXHR2YXIgc2V0ID0gY3JlYXRlKG51bGwpO1xuXHRmb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbiAobmFtZSkgeyBzZXRbbmFtZV0gPSB0cnVlOyB9KTtcblx0cmV0dXJuIHNldDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gT2JqZWN0LnNldFByb3RvdHlwZU9mIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIHBsYWluT2JqZWN0ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qIEN1c3RvbUNyZWF0ZSovKSB7XG5cdHZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiwgY3VzdG9tQ3JlYXRlID0gYXJndW1lbnRzWzBdIHx8IGNyZWF0ZTtcblx0aWYgKHR5cGVvZiBzZXRQcm90b3R5cGVPZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnZXRQcm90b3R5cGVPZihzZXRQcm90b3R5cGVPZihjdXN0b21DcmVhdGUobnVsbCksIHBsYWluT2JqZWN0KSkgPT09IHBsYWluT2JqZWN0O1xufTtcbiIsIi8qIGVzbGludCBuby1wcm90bzogXCJvZmZcIiAqL1xuXG4vLyBCaWcgdGhhbmtzIHRvIEBXZWJSZWZsZWN0aW9uIGZvciBzb3J0aW5nIHRoaXMgb3V0XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uLzU1OTM1NTRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09iamVjdCAgICAgICAgID0gcmVxdWlyZShcIi4uL2lzLW9iamVjdFwiKVxuICAsIHZhbHVlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vdmFsaWQtdmFsdWVcIilcbiAgLCBvYmpJc1Byb3RvdHlwZU9mID0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mXG4gICwgZGVmaW5lUHJvcGVydHkgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIG51bGxEZXNjICAgICAgICAgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH1cbiAgLCB2YWxpZGF0ZTtcblxudmFsaWRhdGUgPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0dmFsdWUob2JqKTtcblx0aWYgKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBpc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4gb2JqO1xuXHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvdG90eXBlIG11c3QgYmUgbnVsbCBvciBhbiBvYmplY3RcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoc3RhdHVzKSB7XG5cdHZhciBmbiwgc2V0O1xuXHRpZiAoIXN0YXR1cykgcmV0dXJuIG51bGw7XG5cdGlmIChzdGF0dXMubGV2ZWwgPT09IDIpIHtcblx0XHRpZiAoc3RhdHVzLnNldCkge1xuXHRcdFx0c2V0ID0gc3RhdHVzLnNldDtcblx0XHRcdGZuID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHRcdHNldC5jYWxsKHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKSwgcHJvdG90eXBlKTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZuID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHRcdHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKS5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmbiA9IGZ1bmN0aW9uIHNlbGYob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdHZhciBpc051bGxCYXNlO1xuXHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpO1xuXHRcdFx0aXNOdWxsQmFzZSA9IG9iaklzUHJvdG90eXBlT2YuY2FsbChzZWxmLm51bGxQb2x5ZmlsbCwgb2JqKTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWxldGUgc2VsZi5udWxsUG9seWZpbGwuX19wcm90b19fO1xuXHRcdFx0aWYgKHByb3RvdHlwZSA9PT0gbnVsbCkgcHJvdG90eXBlID0gc2VsZi5udWxsUG9seWZpbGw7XG5cdFx0XHRvYmouX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlZmluZVByb3BlcnR5KHNlbGYubnVsbFBvbHlmaWxsLCBcIl9fcHJvdG9fX1wiLCBudWxsRGVzYyk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJsZXZlbFwiLCB7XG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IHN0YXR1cy5sZXZlbFxuXHR9KTtcbn0pKFxuXHQoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0bXBPYmoxID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdCAgLCB0bXBPYmoyID0ge31cblx0XHQgICwgc2V0XG5cdFx0ICAsIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsIFwiX19wcm90b19fXCIpO1xuXG5cdFx0aWYgKGRlc2MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNldCA9IGRlc2Muc2V0OyAvLyBPcGVyYSBjcmFzaGVzIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0c2V0LmNhbGwodG1wT2JqMSwgdG1wT2JqMik7XG5cdFx0XHR9IGNhdGNoIChpZ25vcmUpIHt9XG5cdFx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBzZXQ6IHNldCwgbGV2ZWw6IDIgfTtcblx0XHR9XG5cblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDIgfTtcblxuXHRcdHRtcE9iajEgPSB7fTtcblx0XHR0bXBPYmoxLl9fcHJvdG9fXyA9IHRtcE9iajI7XG5cdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgbGV2ZWw6IDEgfTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSkoKVxuKTtcblxucmVxdWlyZShcIi4uL2NyZWF0ZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0cmV0dXJuIGZuO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBudWxsIG9yIHVuZGVmaW5lZFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBTdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3RyID0gXCJyYXpkd2F0cnp5XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHN0ci5jb250YWlucyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBzdHIuY29udGFpbnMoXCJkd2FcIikgPT09IHRydWUgJiYgc3RyLmNvbnRhaW5zKFwiZm9vXCIpID09PSBmYWxzZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGluZGV4T2YgPSBTdHJpbmcucHJvdG90eXBlLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaFN0cmluZy8qLCBwb3NpdGlvbiovKSB7XG5cdHJldHVybiBpbmRleE9mLmNhbGwodGhpcywgc2VhcmNoU3RyaW5nLCBhcmd1bWVudHNbMV0pID4gLTE7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChcIlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHxcblx0XHQodmFsdWUgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdFx0KHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZCkpIHx8XG5cdFx0ZmFsc2Vcblx0KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilcbiAgLCBjb250YWlucyAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCIpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIilcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoXCIuL1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBBcnJheUl0ZXJhdG9yO1xuXG5BcnJheUl0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBraW5kKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBBcnJheUl0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIGFycik7XG5cdGlmICgha2luZCkga2luZCA9IFwidmFsdWVcIjtcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCBcImtleSt2YWx1ZVwiKSkga2luZCA9IFwia2V5K3ZhbHVlXCI7XG5cdGVsc2UgaWYgKGNvbnRhaW5zLmNhbGwoa2luZCwgXCJrZXlcIikpIGtpbmQgPSBcImtleVwiO1xuXHRlbHNlIGtpbmQgPSBcInZhbHVlXCI7XG5cdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19raW5kX19cIiwgZChcIlwiLCBraW5kKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihBcnJheUl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbi8vIEludGVybmFsICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSBkb2Vzbid0IGV4cG9zZSBpdHMgY29uc3RydWN0b3JcbmRlbGV0ZSBBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuQXJyYXlJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSBcInZhbHVlXCIpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdGlmICh0aGlzLl9fa2luZF9fID09PSBcImtleSt2YWx1ZVwiKSByZXR1cm4gW2ksIHRoaXMuX19saXN0X19baV1dO1xuXHRcdHJldHVybiBpO1xuXHR9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShBcnJheUl0ZXJhdG9yLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKFwiY1wiLCBcIkFycmF5IEl0ZXJhdG9yXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBjYWxsYWJsZSAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIGlzU3RyaW5nICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIGdldCAgICAgICAgID0gcmVxdWlyZShcIi4vZ2V0XCIpO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCwgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgY2IgLyosIHRoaXNBcmcqLykge1xuXHR2YXIgbW9kZSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXSwgcmVzdWx0LCBkb0JyZWFrLCBicm9rZW4sIGksIGxlbmd0aCwgY2hhciwgY29kZTtcblx0aWYgKGlzQXJyYXkoaXRlcmFibGUpIHx8IGlzQXJndW1lbnRzKGl0ZXJhYmxlKSkgbW9kZSA9IFwiYXJyYXlcIjtcblx0ZWxzZSBpZiAoaXNTdHJpbmcoaXRlcmFibGUpKSBtb2RlID0gXCJzdHJpbmdcIjtcblx0ZWxzZSBpdGVyYWJsZSA9IGdldChpdGVyYWJsZSk7XG5cblx0Y2FsbGFibGUoY2IpO1xuXHRkb0JyZWFrID0gZnVuY3Rpb24gKCkge1xuXHRcdGJyb2tlbiA9IHRydWU7XG5cdH07XG5cdGlmIChtb2RlID09PSBcImFycmF5XCIpIHtcblx0XHRzb21lLmNhbGwoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwgZG9CcmVhayk7XG5cdFx0XHRyZXR1cm4gYnJva2VuO1xuXHRcdH0pO1xuXHRcdHJldHVybjtcblx0fVxuXHRpZiAobW9kZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGxlbmd0aCA9IGl0ZXJhYmxlLmxlbmd0aDtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdGNoYXIgPSBpdGVyYWJsZVtpXTtcblx0XHRcdGlmIChpICsgMSA8IGxlbmd0aCkge1xuXHRcdFx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIGNoYXIgKz0gaXRlcmFibGVbKytpXTtcblx0XHRcdH1cblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgY2hhciwgZG9CcmVhayk7XG5cdFx0XHRpZiAoYnJva2VuKSBicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHJlc3VsdCA9IGl0ZXJhYmxlLm5leHQoKTtcblxuXHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCByZXN1bHQudmFsdWUsIGRvQnJlYWspO1xuXHRcdGlmIChicm9rZW4pIHJldHVybjtcblx0XHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCIpXG4gICwgQXJyYXlJdGVyYXRvciAgPSByZXF1aXJlKFwiLi9hcnJheVwiKVxuICAsIFN0cmluZ0l0ZXJhdG9yID0gcmVxdWlyZShcIi4vc3RyaW5nXCIpXG4gICwgaXRlcmFibGUgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC1pdGVyYWJsZVwiKVxuICAsIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIikuaXRlcmF0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAodHlwZW9mIGl0ZXJhYmxlKG9iailbaXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBvYmpbaXRlcmF0b3JTeW1ib2xdKCk7XG5cdGlmIChpc0FyZ3VtZW50cyhvYmopKSByZXR1cm4gbmV3IEFycmF5SXRlcmF0b3Iob2JqKTtcblx0aWYgKGlzU3RyaW5nKG9iaikpIHJldHVybiBuZXcgU3RyaW5nSXRlcmF0b3Iob2JqKTtcblx0cmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbGVhciAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIilcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9hc3NpZ25cIilcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIGF1dG9CaW5kID0gcmVxdWlyZShcImQvYXV0by1iaW5kXCIpXG4gICwgU3ltYm9sICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIEl0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdG9yID0gZnVuY3Rpb24gKGxpc3QsIGNvbnRleHQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEl0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2xpc3RfXzogZChcIndcIiwgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKFwid1wiLCBjb250ZXh0KSxcblx0XHRfX25leHRJbmRleF9fOiBkKFwid1wiLCAwKVxuXHR9KTtcblx0aWYgKCFjb250ZXh0KSByZXR1cm47XG5cdGNhbGxhYmxlKGNvbnRleHQub24pO1xuXHRjb250ZXh0Lm9uKFwiX2FkZFwiLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oXCJfZGVsZXRlXCIsIHRoaXMuX29uRGVsZXRlKTtcblx0Y29udGV4dC5vbihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcbn07XG5cbi8vIEludGVybmFsICVJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdGFzc2lnbihcblx0XHR7XG5cdFx0XHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX19yZWRvX18uc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xpc3RfXy5sZW5ndGgpIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHRcdFx0dGhpcy5fdW5CaW5kKCk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9KSxcblx0XHRcdG5leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlUmVzdWx0KHRoaXMuX25leHQoKSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0XHRyZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3Jlc29sdmUoaSkgfTtcblx0XHRcdH0pLFxuXHRcdFx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0XHR9KSxcblx0XHRcdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl9fbGlzdF9fID0gbnVsbDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX19yZWRvX187XG5cdFx0XHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9hZGRcIiwgdGhpcy5fb25BZGQpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9kZWxldGVcIiwgdGhpcy5fb25EZWxldGUpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXyA9IG51bGw7XG5cdFx0XHR9KSxcblx0XHRcdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIFwiW29iamVjdCBcIiArICh0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgXCJPYmplY3RcIikgKyBcIl1cIjtcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRhdXRvQmluZCh7XG5cdFx0XHRfb25BZGQ6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykge1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19yZWRvX19cIiwgZChcImNcIiwgW2luZGV4XSkpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdFx0XHRpZiAocmVkbyA+PSBpbmRleCkgdGhpcy5fX3JlZG9fX1tpXSA9ICsrcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkRlbGV0ZTogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0LS10aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5pbmRleE9mKGluZGV4KTtcblx0XHRcdFx0aWYgKGkgIT09IC0xKSB0aGlzLl9fcmVkb19fLnNwbGljZShpLCAxKTtcblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBqKSB7XG5cdFx0XHRcdFx0aWYgKHJlZG8gPiBpbmRleCkgdGhpcy5fX3JlZG9fX1tqXSA9IC0tcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWRvX18pIGNsZWFyLmNhbGwodGhpcy5fX3JlZG9fXyk7XG5cdFx0XHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdFx0XHR9KVxuXHRcdH0pXG5cdClcbik7XG5cbmRlZmluZVByb3BlcnR5KFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdFN5bWJvbC5pdGVyYXRvcixcblx0ZChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pXG4pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzVmFsdWUgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2lzLXZhbHVlXCIpXG4gICwgaXNTdHJpbmcgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nXCIpO1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvclxuICAsIGlzQXJyYXkgICAgICAgID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNTdHJpbmcodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzQXJndW1lbnRzKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiB0eXBlb2YgdmFsdWVbaXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCI7XG59O1xuIiwiLy8gVGhhbmtzIEBtYXRoaWFzYnluZW5zXG4vLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUjaXRlcmF0aW5nLW92ZXItc3ltYm9sc1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIilcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZShcIi4vXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIFN0cmluZ0l0ZXJhdG9yO1xuXG5TdHJpbmdJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RyaW5nSXRlcmF0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgJ25ldydcIik7XG5cdHN0ciA9IFN0cmluZyhzdHIpO1xuXHRJdGVyYXRvci5jYWxsKHRoaXMsIHN0cik7XG5cdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19sZW5ndGhfX1wiLCBkKFwiXCIsIHN0ci5sZW5ndGgpKTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFN0cmluZ0l0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbi8vIEludGVybmFsICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSBkb2Vzbid0IGV4cG9zZSBpdHMgY29uc3RydWN0b3JcbmRlbGV0ZSBTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cblN0cmluZ0l0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdF9uZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19sZW5ndGhfXykgcmV0dXJuIHRoaXMuX19uZXh0SW5kZXhfXysrO1xuXHRcdHRoaXMuX3VuQmluZCgpO1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH0pLFxuXHRfcmVzb2x2ZTogZChmdW5jdGlvbiAoaSkge1xuXHRcdHZhciBjaGFyID0gdGhpcy5fX2xpc3RfX1tpXSwgY29kZTtcblx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fID09PSB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiBjaGFyO1xuXHRcdGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG5cdFx0aWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSByZXR1cm4gY2hhciArIHRoaXMuX19saXN0X19bdGhpcy5fX25leHRJbmRleF9fKytdO1xuXHRcdHJldHVybiBjaGFyO1xuXHR9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShTdHJpbmdJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZChcImNcIiwgXCJTdHJpbmcgSXRlcmF0b3JcIikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0l0ZXJhYmxlID0gcmVxdWlyZShcIi4vaXMtaXRlcmFibGVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pcy1pbXBsZW1lbnRlZCcpKCkgPyBNYXAgOiByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbWFwLCBpdGVyYXRvciwgcmVzdWx0O1xuXHRpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdC8vIFdlYktpdCBkb2Vzbid0IHN1cHBvcnQgYXJndW1lbnRzIGFuZCBjcmFzaGVzXG5cdFx0bWFwID0gbmV3IE1hcChbWydyYXonLCAnb25lJ10sIFsnZHdhJywgJ3R3byddLCBbJ3RyenknLCAndGhyZWUnXV0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChTdHJpbmcobWFwKSAhPT0gJ1tvYmplY3QgTWFwXScpIHJldHVybiBmYWxzZTtcblx0aWYgKG1hcC5zaXplICE9PSAzKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmNsZWFyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5lbnRyaWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZ2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmhhcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5rZXlzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnNldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC52YWx1ZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblxuXHRpdGVyYXRvciA9IG1hcC5lbnRyaWVzKCk7XG5cdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0aWYgKHJlc3VsdC5kb25lICE9PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXJlc3VsdC52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzBdICE9PSAncmF6JykgcmV0dXJuIGZhbHNlO1xuXHRpZiAocmVzdWx0LnZhbHVlWzFdICE9PSAnb25lJykgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIi8vIEV4cG9ydHMgdHJ1ZSBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBuYXRpdmUgYE1hcGAgaW1wbGVtZW50YXRpb24sXG4vLyB3aGF0ZXZlciB0aGF0IGlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKSkgPT09ICdbb2JqZWN0IE1hcF0nKTtcbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldCcpKCdrZXknLFxuXHQndmFsdWUnLCAna2V5K3ZhbHVlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZXRQcm90b3R5cGVPZiAgICA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgSXRlcmF0b3IgICAgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3InKVxuICAsIHRvU3RyaW5nVGFnU3ltYm9sID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpLnRvU3RyaW5nVGFnXG4gICwga2luZHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2l0ZXJhdG9yLWtpbmRzJylcblxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIHVuQmluZCA9IEl0ZXJhdG9yLnByb3RvdHlwZS5fdW5CaW5kXG4gICwgTWFwSXRlcmF0b3I7XG5cbk1hcEl0ZXJhdG9yID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWFwLCBraW5kKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBJdGVyYXRvcikpIHJldHVybiBuZXcgTWFwSXRlcmF0b3IobWFwLCBraW5kKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBtYXAuX19tYXBLZXlzRGF0YV9fLCBtYXApO1xuXHRpZiAoIWtpbmQgfHwgIWtpbmRzW2tpbmRdKSBraW5kID0gJ2tleSt2YWx1ZSc7XG5cdGRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdF9fa2luZF9fOiBkKCcnLCBraW5kKSxcblx0XHRfX3ZhbHVlc19fOiBkKCd3JywgbWFwLl9fbWFwVmFsdWVzRGF0YV9fKVxuXHR9KTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKE1hcEl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbk1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKE1hcEl0ZXJhdG9yKSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ3ZhbHVlJykgcmV0dXJuIHRoaXMuX192YWx1ZXNfX1tpXTtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gJ2tleScpIHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdHJldHVybiBbdGhpcy5fX2xpc3RfX1tpXSwgdGhpcy5fX3ZhbHVlc19fW2ldXTtcblx0fSksXG5cdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX192YWx1ZXNfXyA9IG51bGw7XG5cdFx0dW5CaW5kLmNhbGwodGhpcyk7XG5cdH0pLFxuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzsgfSlcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcEl0ZXJhdG9yLnByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsXG5cdGQoJ2MnLCAnTWFwIEl0ZXJhdG9yJykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xlYXIgICAgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L2FycmF5LyMvY2xlYXInKVxuICAsIGVJbmRleE9mICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2UtaW5kZXgtb2YnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZicpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZScpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZScpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBlZSAgICAgICAgICAgICA9IHJlcXVpcmUoJ2V2ZW50LWVtaXR0ZXInKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZSgnZXM2LXN5bWJvbCcpXG4gICwgaXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCdlczYtaXRlcmF0b3IvdmFsaWQtaXRlcmFibGUnKVxuICAsIGZvck9mICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL2Zvci1vZicpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKCcuL2xpYi9pdGVyYXRvcicpXG4gICwgaXNOYXRpdmUgICAgICAgPSByZXF1aXJlKCcuL2lzLW5hdGl2ZS1pbXBsZW1lbnRlZCcpXG5cbiAgLCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mXG4gICwgTWFwUG9seTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBQb2x5ID0gZnVuY3Rpb24gKC8qaXRlcmFibGUqLykge1xuXHR2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF0sIGtleXMsIHZhbHVlcywgc2VsZjtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcFBvbHkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJ1Y3RvciByZXF1aXJlcyBcXCduZXdcXCcnKTtcblx0aWYgKGlzTmF0aXZlICYmIHNldFByb3RvdHlwZU9mICYmIChNYXAgIT09IE1hcFBvbHkpKSB7XG5cdFx0c2VsZiA9IHNldFByb3RvdHlwZU9mKG5ldyBNYXAoKSwgZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXHR9IGVsc2Uge1xuXHRcdHNlbGYgPSB0aGlzO1xuXHR9XG5cdGlmIChpdGVyYWJsZSAhPSBudWxsKSBpdGVyYXRvcihpdGVyYWJsZSk7XG5cdGRlZmluZVByb3BlcnRpZXMoc2VsZiwge1xuXHRcdF9fbWFwS2V5c0RhdGFfXzogZCgnYycsIGtleXMgPSBbXSksXG5cdFx0X19tYXBWYWx1ZXNEYXRhX186IGQoJ2MnLCB2YWx1ZXMgPSBbXSlcblx0fSk7XG5cdGlmICghaXRlcmFibGUpIHJldHVybiBzZWxmO1xuXHRmb3JPZihpdGVyYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dmFyIGtleSA9IHZhbGlkVmFsdWUodmFsdWUpWzBdO1xuXHRcdHZhbHVlID0gdmFsdWVbMV07XG5cdFx0aWYgKGVJbmRleE9mLmNhbGwoa2V5cywga2V5KSAhPT0gLTEpIHJldHVybjtcblx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdH0sIHNlbGYpO1xuXHRyZXR1cm4gc2VsZjtcbn07XG5cbmlmIChpc05hdGl2ZSkge1xuXHRpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKE1hcFBvbHksIE1hcCk7XG5cdE1hcFBvbHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNYXAucHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGQoTWFwUG9seSlcblx0fSk7XG59XG5cbmVlKGRlZmluZVByb3BlcnRpZXMoTWFwUG9seS5wcm90b3R5cGUsIHtcblx0Y2xlYXI6IGQoZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoKSByZXR1cm47XG5cdFx0Y2xlYXIuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXyk7XG5cdFx0Y2xlYXIuY2FsbCh0aGlzLl9fbWFwVmFsdWVzRGF0YV9fKTtcblx0XHR0aGlzLmVtaXQoJ19jbGVhcicpO1xuXHR9KSxcblx0ZGVsZXRlOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpO1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBmYWxzZTtcblx0XHR0aGlzLl9fbWFwS2V5c0RhdGFfXy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdHRoaXMuX19tYXBWYWx1ZXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLmVtaXQoJ19kZWxldGUnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSksXG5cdGVudHJpZXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTsgfSksXG5cdGZvckVhY2g6IGQoZnVuY3Rpb24gKGNiLyosIHRoaXNBcmcqLykge1xuXHRcdHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdLCBpdGVyYXRvciwgcmVzdWx0O1xuXHRcdGNhbGxhYmxlKGNiKTtcblx0XHRpdGVyYXRvciA9IHRoaXMuZW50cmllcygpO1xuXHRcdHJlc3VsdCA9IGl0ZXJhdG9yLl9uZXh0KCk7XG5cdFx0d2hpbGUgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIHRoaXMuX19tYXBWYWx1ZXNEYXRhX19bcmVzdWx0XSxcblx0XHRcdFx0dGhpcy5fX21hcEtleXNEYXRhX19bcmVzdWx0XSwgdGhpcyk7XG5cdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdH1cblx0fSksXG5cdGdldDogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG5cdFx0cmV0dXJuIHRoaXMuX19tYXBWYWx1ZXNEYXRhX19baW5kZXhdO1xuXHR9KSxcblx0aGFzOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gKGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSkgIT09IC0xKTtcblx0fSksXG5cdGtleXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICdrZXknKTsgfSksXG5cdHNldDogZChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSksIGVtaXQ7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0aW5kZXggPSB0aGlzLl9fbWFwS2V5c0RhdGFfXy5wdXNoKGtleSkgLSAxO1xuXHRcdFx0ZW1pdCA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMuX19tYXBWYWx1ZXNEYXRhX19baW5kZXhdID0gdmFsdWU7XG5cdFx0aWYgKGVtaXQpIHRoaXMuZW1pdCgnX2FkZCcsIGluZGV4LCBrZXkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9KSxcblx0c2l6ZTogZC5ncyhmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbWFwS2V5c0RhdGFfXy5sZW5ndGg7IH0pLFxuXHR2YWx1ZXM6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpOyB9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwXSc7IH0pXG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwgZChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmVudHJpZXMoKTtcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBQb2x5LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCBkKCdjJywgJ01hcCcpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKClcblx0PyByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpLlN5bWJvbFxuXHQ6IHJlcXVpcmUoXCIuL3BvbHlmaWxsXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZShcImV4dC9nbG9iYWwtdGhpc1wiKVxuICAsIHZhbGlkVHlwZXMgPSB7IG9iamVjdDogdHJ1ZSwgc3ltYm9sOiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRzeW1ib2wgPSBTeW1ib2woXCJ0ZXN0IHN5bWJvbFwiKTtcblx0dHJ5IHsgU3RyaW5nKHN5bWJvbCk7IH1cblx0Y2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gUmV0dXJuICd0cnVlJyBhbHNvIGZvciBwb2x5ZmlsbHNcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wuaXRlcmF0b3JdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZ10pIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCF2YWx1ZS5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXHRpZiAodmFsdWUuY29uc3RydWN0b3IubmFtZSAhPT0gXCJTeW1ib2xcIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdmFsdWVbdmFsdWUuY29uc3RydWN0b3IudG9TdHJpbmdUYWddID09PSBcIlN5bWJvbFwiO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZCA9IHJlcXVpcmUoXCJkXCIpO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIG9ialByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbnZhciBjcmVhdGVkID0gY3JlYXRlKG51bGwpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzYykge1xuXHR2YXIgcG9zdGZpeCA9IDAsIG5hbWUsIGllMTFCdWdXb3JrYXJvdW5kO1xuXHR3aGlsZSAoY3JlYXRlZFtkZXNjICsgKHBvc3RmaXggfHwgXCJcIildKSArK3Bvc3RmaXg7XG5cdGRlc2MgKz0gcG9zdGZpeCB8fCBcIlwiO1xuXHRjcmVhdGVkW2Rlc2NdID0gdHJ1ZTtcblx0bmFtZSA9IFwiQEBcIiArIGRlc2M7XG5cdGRlZmluZVByb3BlcnR5KFxuXHRcdG9ialByb3RvdHlwZSxcblx0XHRuYW1lLFxuXHRcdGQuZ3MobnVsbCwgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQvLyBGb3IgSUUxMSBpc3N1ZSBzZWU6XG5cdFx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFja2RldGFpbC92aWV3LzE5Mjg1MDgvXG5cdFx0XHQvLyAgICBpZTExLWJyb2tlbi1nZXR0ZXJzLW9uLWRvbS1vYmplY3RzXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMlxuXHRcdFx0aWYgKGllMTFCdWdXb3JrYXJvdW5kKSByZXR1cm47XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IHRydWU7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCBkKHZhbHVlKSk7XG5cdFx0XHRpZTExQnVnV29ya2Fyb3VuZCA9IGZhbHNlO1xuXHRcdH0pXG5cdCk7XG5cdHJldHVybiBuYW1lO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZCAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBOYXRpdmVTeW1ib2wgPSByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpLlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU3ltYm9sUG9seWZpbGwpIHtcblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLCB7XG5cdFx0Ly8gVG8gZW5zdXJlIHByb3BlciBpbnRlcm9wZXJhYmlsaXR5IHdpdGggb3RoZXIgbmF0aXZlIGZ1bmN0aW9ucyAoZS5nLiBBcnJheS5mcm9tKVxuXHRcdC8vIGZhbGxiYWNrIHRvIGV2ZW50dWFsIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBnaXZlbiBzeW1ib2xcblx0XHRoYXNJbnN0YW5jZTogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmhhc0luc3RhbmNlKSB8fCBTeW1ib2xQb2x5ZmlsbChcImhhc0luc3RhbmNlXCIpXG5cdFx0KSxcblx0XHRpc0NvbmNhdFNwcmVhZGFibGU6IGQoXG5cdFx0XHRcIlwiLFxuXHRcdFx0KE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlKSB8fFxuXHRcdFx0XHRTeW1ib2xQb2x5ZmlsbChcImlzQ29uY2F0U3ByZWFkYWJsZVwiKVxuXHRcdCksXG5cdFx0aXRlcmF0b3I6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaXRlcmF0b3IpIHx8IFN5bWJvbFBvbHlmaWxsKFwiaXRlcmF0b3JcIikpLFxuXHRcdG1hdGNoOiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLm1hdGNoKSB8fCBTeW1ib2xQb2x5ZmlsbChcIm1hdGNoXCIpKSxcblx0XHRyZXBsYWNlOiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnJlcGxhY2UpIHx8IFN5bWJvbFBvbHlmaWxsKFwicmVwbGFjZVwiKSksXG5cdFx0c2VhcmNoOiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNlYXJjaCkgfHwgU3ltYm9sUG9seWZpbGwoXCJzZWFyY2hcIikpLFxuXHRcdHNwZWNpZXM6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BlY2llcykgfHwgU3ltYm9sUG9seWZpbGwoXCJzcGVjaWVzXCIpKSxcblx0XHRzcGxpdDogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGxpdCkgfHwgU3ltYm9sUG9seWZpbGwoXCJzcGxpdFwiKSksXG5cdFx0dG9QcmltaXRpdmU6IGQoXG5cdFx0XHRcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1ByaW1pdGl2ZSkgfHwgU3ltYm9sUG9seWZpbGwoXCJ0b1ByaW1pdGl2ZVwiKVxuXHRcdCksXG5cdFx0dG9TdHJpbmdUYWc6IGQoXG5cdFx0XHRcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC50b1N0cmluZ1RhZykgfHwgU3ltYm9sUG9seWZpbGwoXCJ0b1N0cmluZ1RhZ1wiKVxuXHRcdCksXG5cdFx0dW5zY29wYWJsZXM6IGQoXG5cdFx0XHRcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC51bnNjb3BhYmxlcykgfHwgU3ltYm9sUG9seWZpbGwoXCJ1bnNjb3BhYmxlc1wiKVxuXHRcdClcblx0fSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgdmFsaWRhdGVTeW1ib2wgPSByZXF1aXJlKFwiLi4vLi4vLi4vdmFsaWRhdGUtc3ltYm9sXCIpO1xuXG52YXIgcmVnaXN0cnkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTeW1ib2xQb2x5ZmlsbCkge1xuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwsIHtcblx0XHRmb3I6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKHJlZ2lzdHJ5W2tleV0pIHJldHVybiByZWdpc3RyeVtrZXldO1xuXHRcdFx0cmV0dXJuIChyZWdpc3RyeVtrZXldID0gU3ltYm9sUG9seWZpbGwoU3RyaW5nKGtleSkpKTtcblx0XHR9KSxcblx0XHRrZXlGb3I6IGQoZnVuY3Rpb24gKHN5bWJvbCkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdHZhbGlkYXRlU3ltYm9sKHN5bWJvbCk7XG5cdFx0XHRmb3IgKGtleSBpbiByZWdpc3RyeSkge1xuXHRcdFx0XHRpZiAocmVnaXN0cnlba2V5XSA9PT0gc3ltYm9sKSByZXR1cm4ga2V5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9KVxuXHR9KTtcbn07XG4iLCIvLyBFUzIwMTUgU3ltYm9sIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgKG9yIHBhcnRpYWxseSkgc3VwcG9ydCBpdFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGQgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCB2YWxpZGF0ZVN5bWJvbCAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlLXN5bWJvbFwiKVxuICAsIE5hdGl2ZVN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImV4dC9nbG9iYWwtdGhpc1wiKS5TeW1ib2xcbiAgLCBnZW5lcmF0ZU5hbWUgICAgICAgICA9IHJlcXVpcmUoXCIuL2xpYi9wcml2YXRlL2dlbmVyYXRlLW5hbWVcIilcbiAgLCBzZXR1cFN0YW5kYXJkU3ltYm9scyA9IHJlcXVpcmUoXCIuL2xpYi9wcml2YXRlL3NldHVwL3N0YW5kYXJkLXN5bWJvbHNcIilcbiAgLCBzZXR1cFN5bWJvbFJlZ2lzdHJ5ICA9IHJlcXVpcmUoXCIuL2xpYi9wcml2YXRlL3NldHVwL3N5bWJvbC1yZWdpc3RyeVwiKTtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGVcbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIFN5bWJvbFBvbHlmaWxsLCBIaWRkZW5TeW1ib2wsIGlzTmF0aXZlU2FmZTtcblxuaWYgKHR5cGVvZiBOYXRpdmVTeW1ib2wgPT09IFwiZnVuY3Rpb25cIikge1xuXHR0cnkge1xuXHRcdFN0cmluZyhOYXRpdmVTeW1ib2woKSk7XG5cdFx0aXNOYXRpdmVTYWZlID0gdHJ1ZTtcblx0fSBjYXRjaCAoaWdub3JlKSB7fVxufSBlbHNlIHtcblx0TmF0aXZlU3ltYm9sID0gbnVsbDtcbn1cblxuLy8gSW50ZXJuYWwgY29uc3RydWN0b3IgKG5vdCBvbmUgZXhwb3NlZCkgZm9yIGNyZWF0aW5nIFN5bWJvbCBpbnN0YW5jZXMuXG4vLyBUaGlzIG9uZSBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IGBzb21lU3ltYm9sIGluc3RhbmNlb2YgU3ltYm9sYCBhbHdheXMgcmV0dXJuIGZhbHNlXG5IaWRkZW5TeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBIaWRkZW5TeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3JcIik7XG5cdHJldHVybiBTeW1ib2xQb2x5ZmlsbChkZXNjcmlwdGlvbik7XG59O1xuXG4vLyBFeHBvc2VkIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyAocmV0dXJucyBpbnN0YW5jZXMgb2YgSGlkZGVuU3ltYm9sKVxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xQb2x5ZmlsbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTtcblx0aWYgKGlzTmF0aXZlU2FmZSkgcmV0dXJuIE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG5cdHN5bWJvbCA9IGNyZWF0ZShIaWRkZW5TeW1ib2wucHJvdG90eXBlKTtcblx0ZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFN0cmluZyhkZXNjcmlwdGlvbik7XG5cdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKHN5bWJvbCwge1xuXHRcdF9fZGVzY3JpcHRpb25fXzogZChcIlwiLCBkZXNjcmlwdGlvbiksXG5cdFx0X19uYW1lX186IGQoXCJcIiwgZ2VuZXJhdGVOYW1lKGRlc2NyaXB0aW9uKSlcblx0fSk7XG59O1xuXG5zZXR1cFN0YW5kYXJkU3ltYm9scyhTeW1ib2xQb2x5ZmlsbCk7XG5zZXR1cFN5bWJvbFJlZ2lzdHJ5KFN5bWJvbFBvbHlmaWxsKTtcblxuLy8gSW50ZXJuYWwgdHdlYWtzIGZvciByZWFsIHN5bWJvbCBwcm9kdWNlclxuZGVmaW5lUHJvcGVydGllcyhIaWRkZW5TeW1ib2wucHJvdG90eXBlLCB7XG5cdGNvbnN0cnVjdG9yOiBkKFN5bWJvbFBvbHlmaWxsKSxcblx0dG9TdHJpbmc6IGQoXCJcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX25hbWVfXzsgfSlcbn0pO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBleHBvc2VkIG9uIFN5bWJvbC5wcm90b3R5cGVcbi8vIFRoZXkgd29uJ3QgYmUgYWNjZXNzaWJsZSBvbiBwcm9kdWNlZCBzeW1ib2wgaW5zdGFuY2VzIGFzIHRoZXkgZGVyaXZlIGZyb20gSGlkZGVuU3ltYm9sLnByb3RvdHlwZVxuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIHtcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTeW1ib2wgKFwiICsgdmFsaWRhdGVTeW1ib2wodGhpcykuX19kZXNjcmlwdGlvbl9fICsgXCIpXCI7IH0pLFxuXHR2YWx1ZU9mOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlU3ltYm9sKHRoaXMpOyB9KVxufSk7XG5kZWZpbmVQcm9wZXJ0eShcblx0U3ltYm9sUG9seWZpbGwucHJvdG90eXBlLFxuXHRTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSxcblx0ZChcIlwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHN5bWJvbCA9IHZhbGlkYXRlU3ltYm9sKHRoaXMpO1xuXHRcdGlmICh0eXBlb2Ygc3ltYm9sID09PSBcInN5bWJvbFwiKSByZXR1cm4gc3ltYm9sO1xuXHRcdHJldHVybiBzeW1ib2wudG9TdHJpbmcoKTtcblx0fSlcbik7XG5kZWZpbmVQcm9wZXJ0eShTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCBkKFwiY1wiLCBcIlN5bWJvbFwiKSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdG9uIG9mIHRvUHJpbWl0aXZlIGFuZCB0b1N0cmluZ1RhZyBmb3IgcmV0dXJuZWQgc3ltYm9sIGluc3RhbmNlc1xuZGVmaW5lUHJvcGVydHkoXG5cdEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLFxuXHRkKFwiY1wiLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWddKVxuKTtcblxuLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdG8gZGVmaW5lIGB0b1ByaW1pdGl2ZWAgYXMgbGFzdCBvbmUsIGFzIHNvbWUgaW1wbGVtZW50YXRpb25zXG4vLyBpbXBsZW1lbnQgYHRvUHJpbWl0aXZlYCBuYXRpdmVseSB3aXRob3V0IGltcGxlbWVudGluZyBgdG9TdHJpbmdUYWdgIChvciBvdGhlciBzcGVjaWZpZWQgc3ltYm9scylcbi8vIEFuZCB0aGF0IG1heSBpbnZva2UgZXJyb3IgaW4gZGVmaW5pdGlvbiBmbG93OlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWtvby9lczYtc3ltYm9sL2lzc3Vlcy8xMyNpc3N1ZWNvbW1lbnQtMTY0MTQ2MTQ5XG5kZWZpbmVQcm9wZXJ0eShcblx0SGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsXG5cdGQoXCJjXCIsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZV0pXG4pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoXCIuL2lzLXN5bWJvbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgYSBzeW1ib2xcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIGNhbGxhYmxlID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuXG4gICwgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHksIGNhbGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgZGVzY3JpcHRvciA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfVxuXG4gICwgb24sIG9uY2UsIG9mZiwgZW1pdCwgbWV0aG9kcywgZGVzY3JpcHRvcnMsIGJhc2U7XG5cbm9uID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSB7XG5cdFx0ZGF0YSA9IGRlc2NyaXB0b3IudmFsdWUgPSBjcmVhdGUobnVsbCk7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgJ19fZWVfXycsIGRlc2NyaXB0b3IpO1xuXHRcdGRlc2NyaXB0b3IudmFsdWUgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0fVxuXHRpZiAoIWRhdGFbdHlwZV0pIGRhdGFbdHlwZV0gPSBsaXN0ZW5lcjtcblx0ZWxzZSBpZiAodHlwZW9mIGRhdGFbdHlwZV0gPT09ICdvYmplY3QnKSBkYXRhW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRlbHNlIGRhdGFbdHlwZV0gPSBbZGF0YVt0eXBlXSwgbGlzdGVuZXJdO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxub25jZSA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgb25jZSwgc2VsZjtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cdHNlbGYgPSB0aGlzO1xuXHRvbi5jYWxsKHRoaXMsIHR5cGUsIG9uY2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0b2ZmLmNhbGwoc2VsZiwgdHlwZSwgb25jZSk7XG5cdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0b25jZS5fX2VlT25jZUxpc3RlbmVyX18gPSBsaXN0ZW5lcjtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5vZmYgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIGRhdGEsIGxpc3RlbmVycywgY2FuZGlkYXRlLCBpO1xuXG5cdGNhbGxhYmxlKGxpc3RlbmVyKTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm4gdGhpcztcblx0ZGF0YSA9IHRoaXMuX19lZV9fO1xuXHRpZiAoIWRhdGFbdHlwZV0pIHJldHVybiB0aGlzO1xuXHRsaXN0ZW5lcnMgPSBkYXRhW3R5cGVdO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGZvciAoaSA9IDA7IChjYW5kaWRhdGUgPSBsaXN0ZW5lcnNbaV0pOyArK2kpIHtcblx0XHRcdGlmICgoY2FuZGlkYXRlID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0XHQoY2FuZGlkYXRlLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAyKSBkYXRhW3R5cGVdID0gbGlzdGVuZXJzW2kgPyAwIDogMV07XG5cdFx0XHRcdGVsc2UgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKChsaXN0ZW5lcnMgPT09IGxpc3RlbmVyKSB8fFxuXHRcdFx0XHQobGlzdGVuZXJzLl9fZWVPbmNlTGlzdGVuZXJfXyA9PT0gbGlzdGVuZXIpKSB7XG5cdFx0XHRkZWxldGUgZGF0YVt0eXBlXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHR2YXIgaSwgbCwgbGlzdGVuZXIsIGxpc3RlbmVycywgYXJncztcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19fZWVfXycpKSByZXR1cm47XG5cdGxpc3RlbmVycyA9IHRoaXMuX19lZV9fW3R5cGVdO1xuXHRpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuXG5cdGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnb2JqZWN0Jykge1xuXHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdGZvciAoaSA9IDE7IGkgPCBsOyArK2kpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG5cdFx0bGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG5cdFx0Zm9yIChpID0gMDsgKGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRhcHBseS5jYWxsKGxpc3RlbmVyLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRjYWxsLmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0YXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG5cdFx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSB7XG5cdFx0XHRcdGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fVxufTtcblxubWV0aG9kcyA9IHtcblx0b246IG9uLFxuXHRvbmNlOiBvbmNlLFxuXHRvZmY6IG9mZixcblx0ZW1pdDogZW1pdFxufTtcblxuZGVzY3JpcHRvcnMgPSB7XG5cdG9uOiBkKG9uKSxcblx0b25jZTogZChvbmNlKSxcblx0b2ZmOiBkKG9mZiksXG5cdGVtaXQ6IGQoZW1pdClcbn07XG5cbmJhc2UgPSBkZWZpbmVQcm9wZXJ0aWVzKHt9LCBkZXNjcmlwdG9ycyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uIChvKSB7XG5cdHJldHVybiAobyA9PSBudWxsKSA/IGNyZWF0ZShiYXNlKSA6IGRlZmluZVByb3BlcnRpZXMoT2JqZWN0KG8pLCBkZXNjcmlwdG9ycyk7XG59O1xuZXhwb3J0cy5tZXRob2RzID0gbWV0aG9kcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJ2YXIgbmFpdmVGYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYpIHJldHVybiBzZWxmO1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cpIHJldHVybiB3aW5kb3c7XG5cdHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCBgdGhpc2BcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzKSByZXR1cm4gdGhpcztcblxuXHQvLyBVbmV4cGVjdGVkIHN0cmljdCBtb2RlIChtYXkgaGFwcGVuIGlmIGUuZy4gYnVuZGxlZCBpbnRvIEVTTSBtb2R1bGUpXG5cblx0Ly8gVGhhbmtzIEBtYXRoaWFzYnluZW5zIC0+IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG5cdC8vIEluIGFsbCBFUzUrIGVuZ2luZXMgZ2xvYmFsIG9iamVjdCBpbmhlcml0cyBmcm9tIE9iamVjdC5wcm90b3R5cGVcblx0Ly8gKGlmIHlvdSBhcHByb2FjaGVkIG9uZSB0aGF0IGRvZXNuJ3QgcGxlYXNlIHJlcG9ydClcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX2dsb2JhbF9fXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFVuZm9ydHVuYXRlIGNhc2Ugb2YgT2JqZWN0LnByb3RvdHlwZSBiZWluZyBzZWFsZWQgKHZpYSBwcmV2ZW50RXh0ZW5zaW9ucywgc2VhbCBvciBmcmVlemUpXG5cdFx0cmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0fVxuXHR0cnkge1xuXHRcdC8vIFNhZmFyaSBjYXNlICh3aW5kb3cuX19nbG9iYWxfXyBpcyByZXNvbHZlZCB3aXRoIGdsb2JhbCBjb250ZXh0LCBidXQgX19nbG9iYWxfXyBkb2VzIG5vdClcblx0XHRpZiAoIV9fZ2xvYmFsX18pIHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIF9fZ2xvYmFsX187XG5cdH0gZmluYWxseSB7XG5cdFx0ZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19nbG9iYWxfXztcblx0fVxufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBnbG9iYWxUaGlzIDogcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb25cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIWdsb2JhbFRoaXMpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIGdsb2JhbFRoaXMuQXJyYXkgPT09IEFycmF5O1xufTtcbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwcyA9IG1vZHVsZS5leHBvcnRzXG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gIGlmIChodHRwLmhhc093blByb3BlcnR5KGtleSkpIGh0dHBzW2tleV0gPSBodHRwW2tleV1cbn1cblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gIHBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zKHBhcmFtcylcbiAgcmV0dXJuIGh0dHAucmVxdWVzdC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpXG59XG5cbmh0dHBzLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gIHBhcmFtcyA9IHZhbGlkYXRlUGFyYW1zKHBhcmFtcylcbiAgcmV0dXJuIGh0dHAuZ2V0LmNhbGwodGhpcywgcGFyYW1zLCBjYilcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYXJhbXMgKHBhcmFtcykge1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICB9XG4gIGlmICghcGFyYW1zLnByb3RvY29sKSB7XG4gICAgcGFyYW1zLnByb3RvY29sID0gJ2h0dHBzOidcbiAgfVxuICBpZiAocGFyYW1zLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgXCInICsgcGFyYW1zLnByb3RvY29sICsgJ1wiIG5vdCBzdXBwb3J0ZWQuIEV4cGVjdGVkIFwiaHR0cHM6XCInKVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvKiFcbiAqIGluLWFycmF5IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pbi1hcnJheT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbkFycmF5IChhcnIsIHZhbCkge1xuICBhcnIgPSBhcnIgfHwgW107XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldID09PSB2YWwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHtcblx0XHR2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTtcblx0XHRyZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMTtcblx0fVxuXHRpZiAoIWdPUEQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNCwgMjAxNSBTaW1vbiBMeWRlbGxcbi8vIFgxMSAo4oCcTUlU4oCdKSBMaWNlbnNlZC4gKFNlZSBMSUNFTlNFLilcblxuLy8gVGhpcyByZWdleCBjb21lcyBmcm9tIHJlZ2V4LmNvZmZlZSwgYW5kIGlzIGluc2VydGVkIGhlcmUgYnkgZ2VuZXJhdGUtaW5kZXguanNcbi8vIChydW4gYG5wbSBydW4gYnVpbGRgKS5cbm1vZHVsZS5leHBvcnRzID0gLygoWydcIl0pKD86KD8hXFwyfFxcXFwpLnxcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqKFxcMik/fGAoPzpbXmBcXFxcJF18XFxcXFtcXHNcXFNdfFxcJCg/IVxceyl8XFwkXFx7KD86W157fV18XFx7W159XSpcXH0/KSpcXH0/KSooYCk/KXwoXFwvXFwvLiopfChcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKihcXCpcXC8pPyl8KFxcLyg/IVxcKikoPzpcXFsoPzooPyFbXFxdXFxcXF0pLnxcXFxcLikqXFxdfCg/IVtcXC9cXF1cXFxcXSkufFxcXFwuKStcXC8oPzooPyFcXHMqKD86XFxifFtcXHUwMDgwLVxcdUZGRkYkXFxcXCdcIn4oe118WytcXC0hXSg/IT0pfFxcLj9cXGQpKXxbZ21peXVdezEsNX1cXGIoPyFbXFx1MDA4MC1cXHVGRkZGJFxcXFxdfFxccyooPzpbK1xcLSolJnxePD4hPT8oe118XFwvKD8hW1xcLypdKSkpKSl8KCg/OjBbeFhdW1xcZGEtZkEtRl0rfDBbb09dWzAtN10rfDBbYkJdWzAxXSt8KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/KSl8KCg/IVxcZCkoPzooPyFcXHMpWyRcXHdcXHUwMDgwLVxcdUZGRkZdfFxcXFx1W1xcZGEtZkEtRl17NH18XFxcXHVcXHtbXFxkYS1mQS1GXXsxLDZ9XFx9KSspfCgtLXxcXCtcXCt8JiZ8XFx8XFx8fD0+fFxcLnszfXwoPzpbK1xcLSpcXC8lJnxeXXw8ezEsMn18PnsxLDN9fCE9P3w9ezEsMn0pPT98Wz86fl18WzssLltcXF0oKXt9XSl8KFxccyspfCheJHxbXFxzXFxTXSkvZ1xuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaFRvVG9rZW4gPSBmdW5jdGlvbihtYXRjaCkge1xuICB2YXIgdG9rZW4gPSB7dHlwZTogXCJpbnZhbGlkXCIsIHZhbHVlOiBtYXRjaFswXX1cbiAgICAgICBpZiAobWF0Y2hbIDFdKSB0b2tlbi50eXBlID0gXCJzdHJpbmdcIiAsIHRva2VuLmNsb3NlZCA9ICEhKG1hdGNoWzNdIHx8IG1hdGNoWzRdKVxuICBlbHNlIGlmIChtYXRjaFsgNV0pIHRva2VuLnR5cGUgPSBcImNvbW1lbnRcIlxuICBlbHNlIGlmIChtYXRjaFsgNl0pIHRva2VuLnR5cGUgPSBcImNvbW1lbnRcIiwgdG9rZW4uY2xvc2VkID0gISFtYXRjaFs3XVxuICBlbHNlIGlmIChtYXRjaFsgOF0pIHRva2VuLnR5cGUgPSBcInJlZ2V4XCJcbiAgZWxzZSBpZiAobWF0Y2hbIDldKSB0b2tlbi50eXBlID0gXCJudW1iZXJcIlxuICBlbHNlIGlmIChtYXRjaFsxMF0pIHRva2VuLnR5cGUgPSBcIm5hbWVcIlxuICBlbHNlIGlmIChtYXRjaFsxMV0pIHRva2VuLnR5cGUgPSBcInB1bmN0dWF0b3JcIlxuICBlbHNlIGlmIChtYXRjaFsxMl0pIHRva2VuLnR5cGUgPSBcIndoaXRlc3BhY2VcIlxuICByZXR1cm4gdG9rZW5cbn1cbiIsInZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSBzcGFjZSA9IEFycmF5KHNwYWNlKzEpLmpvaW4oJyAnKTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKHBhcmVudCwga2V5LCBub2RlLCBsZXZlbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJztcbiAgICAgICAgdmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0cmluZ2lmeShub2RlLCBpLCBub2RlW2ldLCBsZXZlbCsxKSB8fCBqc29uLnN0cmluZ2lmeShudWxsKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBqc29uLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCsxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgICAgICAgICsgY29sb25TZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBrZXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcbiIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcbiIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG4vKiBQcm90b2NvbCAtIHByb3RvY29sIGNvbnN0YW50cyAqL1xudmFyIHByb3RvY29sID0gbW9kdWxlLmV4cG9ydHNcblxuLyogQ29tbWFuZCBjb2RlID0+IG1uZW1vbmljICovXG5wcm90b2NvbC50eXBlcyA9IHtcbiAgMDogJ3Jlc2VydmVkJyxcbiAgMTogJ2Nvbm5lY3QnLFxuICAyOiAnY29ubmFjaycsXG4gIDM6ICdwdWJsaXNoJyxcbiAgNDogJ3B1YmFjaycsXG4gIDU6ICdwdWJyZWMnLFxuICA2OiAncHVicmVsJyxcbiAgNzogJ3B1YmNvbXAnLFxuICA4OiAnc3Vic2NyaWJlJyxcbiAgOTogJ3N1YmFjaycsXG4gIDEwOiAndW5zdWJzY3JpYmUnLFxuICAxMTogJ3Vuc3ViYWNrJyxcbiAgMTI6ICdwaW5ncmVxJyxcbiAgMTM6ICdwaW5ncmVzcCcsXG4gIDE0OiAnZGlzY29ubmVjdCcsXG4gIDE1OiAncmVzZXJ2ZWQnXG59XG5cbi8qIE1uZW1vbmljID0+IENvbW1hbmQgY29kZSAqL1xucHJvdG9jb2wuY29kZXMgPSB7fVxuZm9yICh2YXIgayBpbiBwcm90b2NvbC50eXBlcykge1xuICB2YXIgdiA9IHByb3RvY29sLnR5cGVzW2tdXG4gIHByb3RvY29sLmNvZGVzW3ZdID0ga1xufVxuXG4vKiBIZWFkZXIgKi9cbnByb3RvY29sLkNNRF9TSElGVCA9IDRcbnByb3RvY29sLkNNRF9NQVNLID0gMHhGMFxucHJvdG9jb2wuRFVQX01BU0sgPSAweDA4XG5wcm90b2NvbC5RT1NfTUFTSyA9IDB4MDNcbnByb3RvY29sLlFPU19TSElGVCA9IDFcbnByb3RvY29sLlJFVEFJTl9NQVNLID0gMHgwMVxuXG4vKiBMZW5ndGggKi9cbnByb3RvY29sLkxFTkdUSF9NQVNLID0gMHg3RlxucHJvdG9jb2wuTEVOR1RIX0ZJTl9NQVNLID0gMHg4MFxuXG4vKiBDb25uYWNrICovXG5wcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9NQVNLID0gMHgwMVxucHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLlNFU1NJT05QUkVTRU5UX01BU0tdKVxucHJvdG9jb2wuQ09OTkFDS19IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Nvbm5hY2snXSA8PCBwcm90b2NvbC5DTURfU0hJRlRdKVxuXG4vKiBDb25uZWN0ICovXG5wcm90b2NvbC5VU0VSTkFNRV9NQVNLID0gMHg4MFxucHJvdG9jb2wuUEFTU1dPUkRfTUFTSyA9IDB4NDBcbnByb3RvY29sLldJTExfUkVUQUlOX01BU0sgPSAweDIwXG5wcm90b2NvbC5XSUxMX1FPU19NQVNLID0gMHgxOFxucHJvdG9jb2wuV0lMTF9RT1NfU0hJRlQgPSAzXG5wcm90b2NvbC5XSUxMX0ZMQUdfTUFTSyA9IDB4MDRcbnByb3RvY29sLkNMRUFOX1NFU1NJT05fTUFTSyA9IDB4MDJcbnByb3RvY29sLkNPTk5FQ1RfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydjb25uZWN0J10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuZnVuY3Rpb24gZ2VuSGVhZGVyICh0eXBlKSB7XG4gIHJldHVybiBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoZHVwKSB7XG4gICAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAocmV0YWluKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KFxuICAgICAgICAgIHByb3RvY29sLmNvZGVzW3R5cGVdIDw8IHByb3RvY29sLkNNRF9TSElGVCB8XG4gICAgICAgICAgKGR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMCkgfFxuICAgICAgICAgIHFvcyA8PCBwcm90b2NvbC5RT1NfU0hJRlQgfCByZXRhaW4sIDAsIHRydWUpXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLyogUHVibGlzaCAqL1xucHJvdG9jb2wuUFVCTElTSF9IRUFERVIgPSBnZW5IZWFkZXIoJ3B1Ymxpc2gnKVxuXG4vKiBTdWJzY3JpYmUgKi9cbnByb3RvY29sLlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3N1YnNjcmliZScpXG5cbi8qIFVuc3Vic2NyaWJlICovXG5wcm90b2NvbC5VTlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3Vuc3Vic2NyaWJlJylcblxuLyogQ29uZmlybWF0aW9ucyAqL1xucHJvdG9jb2wuQUNLUyA9IHtcbiAgdW5zdWJhY2s6IGdlbkhlYWRlcigndW5zdWJhY2snKSxcbiAgcHViYWNrOiBnZW5IZWFkZXIoJ3B1YmFjaycpLFxuICBwdWJjb21wOiBnZW5IZWFkZXIoJ3B1YmNvbXAnKSxcbiAgcHVicmVsOiBnZW5IZWFkZXIoJ3B1YnJlbCcpLFxuICBwdWJyZWM6IGdlbkhlYWRlcigncHVicmVjJylcbn1cblxucHJvdG9jb2wuU1VCQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snc3ViYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogUHJvdG9jb2wgdmVyc2lvbnMgKi9cbnByb3RvY29sLlZFUlNJT04zID0gQnVmZmVyLmZyb20oWzNdKVxucHJvdG9jb2wuVkVSU0lPTjQgPSBCdWZmZXIuZnJvbShbNF0pXG5cbi8qIFFvUyAqL1xucHJvdG9jb2wuUU9TID0gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAocW9zKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShbcW9zXSlcbn0pXG5cbi8qIEVtcHR5IHBhY2tldHMgKi9cbnByb3RvY29sLkVNUFRZID0ge1xuICBwaW5ncmVxOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3BpbmdyZXEnXSA8PCA0LCAwXSksXG4gIHBpbmdyZXNwOiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3BpbmdyZXNwJ10gPDwgNCwgMF0pLFxuICBkaXNjb25uZWN0OiBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2Rpc2Nvbm5lY3QnXSA8PCA0LCAwXSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciB3cml0ZVRvU3RyZWFtID0gcmVxdWlyZSgnLi93cml0ZVRvU3RyZWFtJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0KSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgQWNjdW11bGF0b3IoKVxuICB3cml0ZVRvU3RyZWFtKHBhY2tldCwgc3RyZWFtKVxuICByZXR1cm4gc3RyZWFtLmNvbmNhdCgpXG59XG5cbmZ1bmN0aW9uIEFjY3VtdWxhdG9yICgpIHtcbiAgdGhpcy5fYXJyYXkgPSBuZXcgQXJyYXkoMjApXG4gIHRoaXMuX2kgPSAwXG59XG5cbmluaGVyaXRzKEFjY3VtdWxhdG9yLCBFRSlcblxuQWNjdW11bGF0b3IucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuX2FycmF5W3RoaXMuX2krK10gPSBjaHVua1xuICByZXR1cm4gdHJ1ZVxufVxuXG5BY2N1bXVsYXRvci5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gMFxuICB2YXIgbGVuZ3RocyA9IG5ldyBBcnJheSh0aGlzLl9hcnJheS5sZW5ndGgpXG4gIHZhciBsaXN0ID0gdGhpcy5fYXJyYXlcbiAgdmFyIHBvcyA9IDBcbiAgdmFyIGlcbiAgdmFyIHJlc3VsdFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIGxlbmd0aHNbaV0gPSBsaXN0W2ldLmxlbmd0aFxuICAgIGVsc2UgbGVuZ3Roc1tpXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGxpc3RbaV0pXG5cbiAgICBsZW5ndGggKz0gbGVuZ3Roc1tpXVxuICB9XG5cbiAgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcblxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGggJiYgbGlzdFtpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIGxpc3RbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICBsaXN0W2ldLmNvcHkocmVzdWx0LCBwb3MpXG4gICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQud3JpdGUobGlzdFtpXSwgcG9zKVxuICAgICAgcG9zICs9IGxlbmd0aHNbaV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJylcbmV4cG9ydHMuZ2VuZXJhdGUgPSByZXF1aXJlKCcuL2dlbmVyYXRlJylcbmV4cG9ydHMud3JpdGVUb1N0cmVhbSA9IHJlcXVpcmUoJy4vd3JpdGVUb1N0cmVhbScpXG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgbWF4ID0gNjU1MzZcbnZhciBjYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyIChpKSB7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcbiAgYnVmZmVyLndyaXRlVUludDgoaSA+PiA4LCAwKVxuICBidWZmZXIud3JpdGVVSW50OChpICYgMHgwMEZGLCAwICsgMSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2FjaGUgKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgY2FjaGVbaV0gPSBnZW5lcmF0ZUJ1ZmZlcihpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZTogY2FjaGUsXG4gIGdlbmVyYXRlQ2FjaGU6IGdlbmVyYXRlQ2FjaGUsXG4gIGdlbmVyYXRlTnVtYmVyOiBnZW5lcmF0ZUJ1ZmZlclxufVxuIiwiXG5mdW5jdGlvbiBQYWNrZXQgKCkge1xuICB0aGlzLmNtZCA9IG51bGxcbiAgdGhpcy5yZXRhaW4gPSBmYWxzZVxuICB0aGlzLnFvcyA9IDBcbiAgdGhpcy5kdXAgPSBmYWxzZVxuICB0aGlzLmxlbmd0aCA9IC0xXG4gIHRoaXMudG9waWMgPSBudWxsXG4gIHRoaXMucGF5bG9hZCA9IG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYWNrZXRcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYmwgPSByZXF1aXJlKCdibCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBQYWNrZXQgPSByZXF1aXJlKCcuL3BhY2tldCcpXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5mdW5jdGlvbiBQYXJzZXIgKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VyKSkgcmV0dXJuIG5ldyBQYXJzZXIoKVxuXG4gIHRoaXMuX3N0YXRlcyA9IFtcbiAgICAnX3BhcnNlSGVhZGVyJyxcbiAgICAnX3BhcnNlTGVuZ3RoJyxcbiAgICAnX3BhcnNlUGF5bG9hZCcsXG4gICAgJ19uZXdQYWNrZXQnXG4gIF1cblxuICB0aGlzLl9yZXNldFN0YXRlKClcbn1cblxuaW5oZXJpdHMoUGFyc2VyLCBFRSlcblxuUGFyc2VyLnByb3RvdHlwZS5fcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wYWNrZXQgPSBuZXcgUGFja2V0KClcbiAgdGhpcy5lcnJvciA9IG51bGxcbiAgdGhpcy5fbGlzdCA9IGJsKClcbiAgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5lcnJvcikgdGhpcy5fcmVzZXRTdGF0ZSgpXG5cbiAgdGhpcy5fbGlzdC5hcHBlbmQoYnVmKVxuXG4gIHdoaWxlICgodGhpcy5wYWNrZXQubGVuZ3RoICE9PSAtMSB8fCB0aGlzLl9saXN0Lmxlbmd0aCA+IDApICYmXG4gICAgICAgICB0aGlzW3RoaXMuX3N0YXRlc1t0aGlzLl9zdGF0ZUNvdW50ZXJdXSgpICYmXG4gICAgICAgICAhdGhpcy5lcnJvcikge1xuICAgIHRoaXMuX3N0YXRlQ291bnRlcisrXG5cbiAgICBpZiAodGhpcy5fc3RhdGVDb3VudGVyID49IHRoaXMuX3N0YXRlcy5sZW5ndGgpIHRoaXMuX3N0YXRlQ291bnRlciA9IDBcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9saXN0Lmxlbmd0aFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUhlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIGJ5dGUgaW4gdGhlIGJ1ZmZlclxuICB2YXIgemVybyA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KDApXG4gIHRoaXMucGFja2V0LmNtZCA9IGNvbnN0YW50cy50eXBlc1t6ZXJvID4+IGNvbnN0YW50cy5DTURfU0hJRlRdXG4gIHRoaXMucGFja2V0LnJldGFpbiA9ICh6ZXJvICYgY29uc3RhbnRzLlJFVEFJTl9NQVNLKSAhPT0gMFxuICB0aGlzLnBhY2tldC5xb3MgPSAoemVybyA+PiBjb25zdGFudHMuUU9TX1NISUZUKSAmIGNvbnN0YW50cy5RT1NfTUFTS1xuICB0aGlzLnBhY2tldC5kdXAgPSAoemVybyAmIGNvbnN0YW50cy5EVVBfTUFTSykgIT09IDBcblxuICB0aGlzLl9saXN0LmNvbnN1bWUoMSlcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIGJ5dGUgaW4gdGhlIGxpc3RcbiAgdmFyIGJ5dGVzID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgbGVuZ3RoID0gMFxuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuICB2YXIgY3VycmVudFxuXG4gIHdoaWxlIChieXRlcyA8IDUpIHtcbiAgICBjdXJyZW50ID0gdGhpcy5fbGlzdC5yZWFkVUludDgoYnl0ZXMrKylcbiAgICBsZW5ndGggKz0gbXVsICogKGN1cnJlbnQgJiBjb25zdGFudHMuTEVOR1RIX01BU0spXG4gICAgbXVsICo9IDB4ODBcblxuICAgIGlmICgoY3VycmVudCAmIGNvbnN0YW50cy5MRU5HVEhfRklOX01BU0spID09PSAwKSBicmVha1xuICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8PSBieXRlcykge1xuICAgICAgcmVzdWx0ID0gZmFsc2VcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHRoaXMucGFja2V0Lmxlbmd0aCA9IGxlbmd0aFxuICAgIHRoaXMuX2xpc3QuY29uc3VtZShieXRlcylcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gZmFsc2VcblxuICAvLyBEbyB3ZSBoYXZlIGEgcGF5bG9hZD8gRG8gd2UgaGF2ZSBlbm91Z2ggZGF0YSB0byBjb21wbGV0ZSB0aGUgcGF5bG9hZD9cbiAgLy8gUElOR3MgaGF2ZSBubyBwYXlsb2FkXG4gIGlmICh0aGlzLnBhY2tldC5sZW5ndGggPT09IDAgfHwgdGhpcy5fbGlzdC5sZW5ndGggPj0gdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5fcG9zID0gMFxuXG4gICAgc3dpdGNoICh0aGlzLnBhY2tldC5jbWQpIHtcbiAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbm5lY3QoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnY29ubmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29ubmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgICAgdGhpcy5fcGFyc2VQdWJsaXNoKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICBjYXNlICdwdWJyZWMnOlxuICAgICAgY2FzZSAncHVicmVsJzpcbiAgICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgICB0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YnNjcmliZSgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICAgIHRoaXMuX3BhcnNlVW5zdWJzY3JpYmUoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVVuc3ViYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICAgIC8vIFRoZXNlIGFyZSBlbXB0eSwgbm90aGluZyB0byBkb1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCcpKVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvdG9jb2xJZCAvLyBQcm90b2NvbCBJRFxuICB2YXIgY2xpZW50SWQgLy8gQ2xpZW50IElEXG4gIHZhciB0b3BpYyAvLyBXaWxsIHRvcGljXG4gIHZhciBwYXlsb2FkIC8vIFdpbGwgcGF5bG9hZFxuICB2YXIgcGFzc3dvcmQgLy8gUGFzc3dvcmRcbiAgdmFyIHVzZXJuYW1lIC8vIFVzZXJuYW1lXG4gIHZhciBmbGFncyA9IHt9XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIC8vIFBhcnNlIHByb3RvY29sSWRcbiAgcHJvdG9jb2xJZCA9IHRoaXMuX3BhcnNlU3RyaW5nKClcblxuICBpZiAocHJvdG9jb2xJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBwcm90b2NvbElkJykpXG4gIGlmIChwcm90b2NvbElkICE9PSAnTVFUVCcgJiYgcHJvdG9jb2xJZCAhPT0gJ01RSXNkcCcpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbElkJykpXG4gIH1cblxuICBwYWNrZXQucHJvdG9jb2xJZCA9IHByb3RvY29sSWRcblxuICAvLyBQYXJzZSBjb25zdGFudHMgdmVyc2lvbiBudW1iZXJcbiAgaWYgKHRoaXMuX3BvcyA+PSB0aGlzLl9saXN0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcblxuICBwYWNrZXQucHJvdG9jb2xWZXJzaW9uID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKVxuXG4gIGlmIChwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSAzICYmIHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbCB2ZXJzaW9uJykpXG4gIH1cblxuICB0aGlzLl9wb3MrK1xuXG4gIGlmICh0aGlzLl9wb3MgPj0gdGhpcy5fbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuICB9XG5cbiAgLy8gUGFyc2UgY29ubmVjdCBmbGFnc1xuICBmbGFncy51c2VybmFtZSA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLlVTRVJOQU1FX01BU0spXG4gIGZsYWdzLnBhc3N3b3JkID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuUEFTU1dPUkRfTUFTSylcbiAgZmxhZ3Mud2lsbCA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLldJTExfRkxBR19NQVNLKVxuXG4gIGlmIChmbGFncy53aWxsKSB7XG4gICAgcGFja2V0LndpbGwgPSB7fVxuICAgIHBhY2tldC53aWxsLnJldGFpbiA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLldJTExfUkVUQUlOX01BU0spICE9PSAwXG4gICAgcGFja2V0LndpbGwucW9zID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuV0lMTF9RT1NfTUFTSykgPj4gY29uc3RhbnRzLldJTExfUU9TX1NISUZUXG4gIH1cblxuICBwYWNrZXQuY2xlYW4gPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5DTEVBTl9TRVNTSU9OX01BU0spICE9PSAwXG4gIHRoaXMuX3BvcysrXG5cbiAgLy8gUGFyc2Uga2VlcGFsaXZlXG4gIHBhY2tldC5rZWVwYWxpdmUgPSB0aGlzLl9wYXJzZU51bSgpXG4gIGlmIChwYWNrZXQua2VlcGFsaXZlID09PSAtMSkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcblxuICAvLyBQYXJzZSBjbGllbnRJZFxuICBjbGllbnRJZCA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgaWYgKGNsaWVudElkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuICBwYWNrZXQuY2xpZW50SWQgPSBjbGllbnRJZFxuXG4gIGlmIChmbGFncy53aWxsKSB7XG4gICAgLy8gUGFyc2Ugd2lsbCB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB3aWxsIHRvcGljJykpXG4gICAgcGFja2V0LndpbGwudG9waWMgPSB0b3BpY1xuXG4gICAgLy8gUGFyc2Ugd2lsbCBwYXlsb2FkXG4gICAgcGF5bG9hZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICBpZiAocGF5bG9hZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB3aWxsIHBheWxvYWQnKSlcbiAgICBwYWNrZXQud2lsbC5wYXlsb2FkID0gcGF5bG9hZFxuICB9XG5cbiAgLy8gUGFyc2UgdXNlcm5hbWVcbiAgaWYgKGZsYWdzLnVzZXJuYW1lKSB7XG4gICAgdXNlcm5hbWUgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHVzZXJuYW1lID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHVzZXJuYW1lJykpXG4gICAgcGFja2V0LnVzZXJuYW1lID0gdXNlcm5hbWVcbiAgfVxuXG4gIC8vIFBhcnNlIHBhc3N3b3JkXG4gIGlmIChmbGFncy5wYXNzd29yZCkge1xuICAgIHBhc3N3b3JkID0gdGhpcy5fcGFyc2VCdWZmZXIoKVxuICAgIGlmIChwYXNzd29yZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBwYXNzd29yZCcpKVxuICAgIHBhY2tldC5wYXNzd29yZCA9IHBhc3N3b3JkXG4gIH1cblxuICByZXR1cm4gcGFja2V0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29ubmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIDwgMikgcmV0dXJuIG51bGxcblxuICBwYWNrZXQuc2Vzc2lvblByZXNlbnQgPSAhISh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKykgJiBjb25zdGFudHMuU0VTU0lPTlBSRVNFTlRfTUFTSylcbiAgcGFja2V0LnJldHVybkNvZGUgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG5cbiAgaWYgKHBhY2tldC5yZXR1cm5Db2RlID09PSAtMSkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSByZXR1cm4gY29kZScpKVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVB1Ymxpc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICBwYWNrZXQudG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG5cbiAgaWYgKHBhY2tldC50b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICBpZiAocGFja2V0LnFvcyA+IDApIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIHBhY2tldC5wYXlsb2FkID0gdGhpcy5fbGlzdC5zbGljZSh0aGlzLl9wb3MsIHBhY2tldC5sZW5ndGgpXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgdmFyIHRvcGljXG4gIHZhciBxb3NcblxuICBpZiAocGFja2V0LnFvcyAhPT0gMSkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdXcm9uZyBzdWJzY3JpYmUgaGVhZGVyJykpXG4gIH1cblxuICBwYWNrZXQuc3Vic2NyaXB0aW9ucyA9IFtdXG5cbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSB7IHJldHVybiB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICAvLyBQYXJzZSB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gICAgaWYgKHRoaXMuX3BvcyA+PSBwYWNrZXQubGVuZ3RoKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignTWFsZm9ybWVkIFN1YnNjcmliZSBQYXlsb2FkJykpXG4gICAgcW9zID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspXG5cbiAgICAvLyBQdXNoIHBhaXIgdG8gc3Vic2NyaXB0aW9uc1xuICAgIHBhY2tldC5zdWJzY3JpcHRpb25zLnB1c2goeyB0b3BpYzogdG9waWMsIHFvczogcW9zIH0pXG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTdWJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGFja2V0LmdyYW50ZWQgPSBbXVxuXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFBhcnNlIGdyYW50ZWQgUW9TZXNcbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgIHRoaXMucGFja2V0LmdyYW50ZWQucHVzaCh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKykpXG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VVbnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IFtdXG5cbiAgLy8gUGFyc2UgbWVzc2FnZUlkXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIHdoaWxlICh0aGlzLl9wb3MgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgdmFyIHRvcGljXG5cbiAgICAvLyBQYXJzZSB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gICAgLy8gUHVzaCB0b3BpYyB0byB1bnN1YnNjcmlwdGlvbnNcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zLnB1c2godG9waWMpXG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VVbnN1YmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZU1lc3NhZ2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgcGFja2V0Lm1lc3NhZ2VJZCA9IHRoaXMuX3BhcnNlTnVtKClcblxuICBpZiAocGFja2V0Lm1lc3NhZ2VJZCA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3RyaW5nID0gZnVuY3Rpb24gKG1heWJlQnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLl9wYXJzZU51bSgpXG4gIHZhciByZXN1bHRcbiAgdmFyIGVuZCA9IGxlbmd0aCArIHRoaXMuX3Bvc1xuXG4gIGlmIChsZW5ndGggPT09IC0xIHx8IGVuZCA+IHRoaXMuX2xpc3QubGVuZ3RoIHx8IGVuZCA+IHRoaXMucGFja2V0Lmxlbmd0aCkgcmV0dXJuIG51bGxcblxuICByZXN1bHQgPSB0aGlzLl9saXN0LnRvU3RyaW5nKCd1dGY4JywgdGhpcy5fcG9zLCBlbmQpXG4gIHRoaXMuX3BvcyArPSBsZW5ndGhcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC5zbGljZSh0aGlzLl9wb3MsIGVuZClcblxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZU51bSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIC0gdGhpcy5fcG9zIDwgMikgcmV0dXJuIC0xXG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2xpc3QucmVhZFVJbnQxNkJFKHRoaXMuX3BvcylcbiAgdGhpcy5fcG9zICs9IDJcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX25ld1BhY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0KSB7XG4gICAgdGhpcy5fbGlzdC5jb25zdW1lKHRoaXMucGFja2V0Lmxlbmd0aClcbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHRoaXMucGFja2V0KVxuICB9XG5cbiAgdGhpcy5wYWNrZXQgPSBuZXcgUGFja2V0KClcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9lbWl0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZXJyb3IgPSBlcnJcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcHJvdG9jb2wgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBlbXB0eSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxudmFyIHplcm9CdWYgPSBCdWZmZXIuZnJvbShbMF0pXG52YXIgbnVtYmVycyA9IHJlcXVpcmUoJy4vbnVtYmVycycpXG52YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpLm5leHRUaWNrXG5cbnZhciBudW1DYWNoZSA9IG51bWJlcnMuY2FjaGVcbnZhciBnZW5lcmF0ZU51bWJlciA9IG51bWJlcnMuZ2VuZXJhdGVOdW1iZXJcbnZhciBnZW5lcmF0ZUNhY2hlID0gbnVtYmVycy5nZW5lcmF0ZUNhY2hlXG52YXIgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckNhY2hlZFxudmFyIHRvR2VuZXJhdGUgPSB0cnVlXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChwYWNrZXQsIHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmNvcmspIHtcbiAgICBzdHJlYW0uY29yaygpXG4gICAgbmV4dFRpY2sodW5jb3JrLCBzdHJlYW0pXG4gIH1cblxuICBpZiAodG9HZW5lcmF0ZSkge1xuICAgIHRvR2VuZXJhdGUgPSBmYWxzZVxuICAgIGdlbmVyYXRlQ2FjaGUoKVxuICB9XG5cbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XG4gICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICByZXR1cm4gY29ubmVjdChwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgIHJldHVybiBjb25uYWNrKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgcmV0dXJuIHB1Ymxpc2gocGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAncHViYWNrJzpcbiAgICBjYXNlICdwdWJyZWMnOlxuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbihwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgcmV0dXJuIHN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgcmV0dXJuIHN1YmFjayhwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUocGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAncGluZ3JlcSc6XG4gICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGVtcHR5UGFja2V0KHBhY2tldCwgc3RyZWFtKVxuICAgIGRlZmF1bHQ6XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1Vua25vd24gY29tbWFuZCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbi8qKlxuICogQ29udHJvbHMgbnVtYmVycyBjYWNoZS5cbiAqIFNldCB0byBcImZhbHNlXCIgdG8gYWxsb2NhdGUgYnVmZmVycyBvbi10aGUtZmxpZ2h0IGluc3RlYWQgb2YgcHJlLWdlbmVyYXRlZCBjYWNoZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2VuZXJhdGUsICdjYWNoZU51bWJlcnMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3cml0ZU51bWJlciA9PT0gd3JpdGVOdW1iZXJDYWNoZWRcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghbnVtQ2FjaGUgfHwgT2JqZWN0LmtleXMobnVtQ2FjaGUpLmxlbmd0aCA9PT0gMCkgdG9HZW5lcmF0ZSA9IHRydWVcbiAgICAgIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbiAgICB9IGVsc2Uge1xuICAgICAgdG9HZW5lcmF0ZSA9IGZhbHNlXG4gICAgICB3cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyR2VuZXJhdGVkXG4gICAgfVxuICB9XG59KVxuXG5mdW5jdGlvbiB1bmNvcmsgKHN0cmVhbSkge1xuICBzdHJlYW0udW5jb3JrKClcbn1cblxuZnVuY3Rpb24gY29ubmVjdCAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIHByb3RvY29sSWQgPSBzZXR0aW5ncy5wcm90b2NvbElkIHx8ICdNUVRUJ1xuICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uIHx8IDRcbiAgdmFyIHdpbGwgPSBzZXR0aW5ncy53aWxsXG4gIHZhciBjbGVhbiA9IHNldHRpbmdzLmNsZWFuXG4gIHZhciBrZWVwYWxpdmUgPSBzZXR0aW5ncy5rZWVwYWxpdmUgfHwgMFxuICB2YXIgY2xpZW50SWQgPSBzZXR0aW5ncy5jbGllbnRJZCB8fCAnJ1xuICB2YXIgdXNlcm5hbWUgPSBzZXR0aW5ncy51c2VybmFtZVxuICB2YXIgcGFzc3dvcmQgPSBzZXR0aW5ncy5wYXNzd29yZFxuXG4gIGlmIChjbGVhbiA9PT0gdW5kZWZpbmVkKSBjbGVhbiA9IHRydWVcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIE11c3QgYmUgYSBzdHJpbmcgYW5kIG5vbi1mYWxzeVxuICBpZiAoIXByb3RvY29sSWQgfHxcbiAgICAgKHR5cGVvZiBwcm90b2NvbElkICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKHByb3RvY29sSWQpKSkge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbElkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gcHJvdG9jb2xJZC5sZW5ndGggKyAyXG5cbiAgLy8gTXVzdCBiZSAzIG9yIDRcbiAgaWYgKHByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwcm90b2NvbFZlcnNpb24gIT09IDQpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDFcblxuICAvLyBDbGllbnRJZCBtaWdodCBiZSBvbWl0dGVkIGluIDMuMS4xLCBidXQgb25seSBpZiBjbGVhblNlc3Npb24gaXMgc2V0IHRvIDFcbiAgaWYgKCh0eXBlb2YgY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihjbGllbnRJZCkpICYmXG4gICAgIChjbGllbnRJZCB8fCBwcm90b2NvbFZlcnNpb24gPT09IDQpICYmIChjbGllbnRJZCB8fCBjbGVhbikpIHtcbiAgICBsZW5ndGggKz0gY2xpZW50SWQubGVuZ3RoICsgMlxuICB9IGVsc2Uge1xuICAgIGlmIChwcm90b2NvbFZlcnNpb24gPCA0KSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudElkIG11c3QgYmUgc3VwcGxpZWQgYmVmb3JlIDMuMS4xJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKChjbGVhbiAqIDEpID09PSAwKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2NsaWVudElkIG11c3QgYmUgZ2l2ZW4gaWYgY2xlYW5TZXNzaW9uIHNldCB0byAwJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBNdXN0IGJlIGEgdHdvIGJ5dGUgbnVtYmVyXG4gIGlmICh0eXBlb2Yga2VlcGFsaXZlICE9PSAnbnVtYmVyJyB8fFxuICAgICAga2VlcGFsaXZlIDwgMCB8fFxuICAgICAga2VlcGFsaXZlID4gNjU1MzUgfHxcbiAgICAgIGtlZXBhbGl2ZSAlIDEgIT09IDApIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQga2VlcGFsaXZlJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENvbm5lY3QgZmxhZ3NcbiAgbGVuZ3RoICs9IDFcblxuICAvLyBJZiB3aWxsIGV4aXN0cy4uLlxuICBpZiAod2lsbCkge1xuICAgIC8vIEl0IG11c3QgYmUgYW4gb2JqZWN0XG4gICAgaWYgKHR5cGVvZiB3aWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBJdCBtdXN0IGhhdmUgdG9waWMgdHlwZW9mIHN0cmluZ1xuICAgIGlmICghd2lsbC50b3BpYyB8fCB0eXBlb2Ygd2lsbC50b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsIHRvcGljJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHdpbGwudG9waWMpICsgMlxuICAgIH1cblxuICAgIC8vIFBheWxvYWRcbiAgICBpZiAod2lsbC5wYXlsb2FkICYmIHdpbGwucGF5bG9hZCkge1xuICAgICAgaWYgKHdpbGwucGF5bG9hZC5sZW5ndGggPj0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbGwucGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgod2lsbC5wYXlsb2FkKSArIDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggKz0gd2lsbC5wYXlsb2FkLmxlbmd0aCArIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwgcGF5bG9hZCcpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyBVc2VybmFtZVxuICB2YXIgcHJvdmlkZWRVc2VybmFtZSA9IGZhbHNlXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIodXNlcm5hbWUpKSB7XG4gICAgICBwcm92aWRlZFVzZXJuYW1lID0gdHJ1ZVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lKSArIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXJuYW1lJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBQYXNzd29yZFxuICBpZiAocGFzc3dvcmQgIT0gbnVsbCkge1xuICAgIGlmICghcHJvdmlkZWRVc2VybmFtZSkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVc2VybmFtZSBpcyByZXF1aXJlZCB0byB1c2UgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ09yQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgICAgbGVuZ3RoICs9IGJ5dGVMZW5ndGgocGFzc3dvcmQpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQ09OTkVDVF9IRUFERVIpXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIEdlbmVyYXRlIHByb3RvY29sIElEXG4gIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCBwcm90b2NvbElkKVxuICBzdHJlYW0ud3JpdGUoXG4gICAgcHJvdG9jb2xWZXJzaW9uID09PSA0ID8gcHJvdG9jb2wuVkVSU0lPTjQgOiBwcm90b2NvbC5WRVJTSU9OM1xuICApXG5cbiAgLy8gQ29ubmVjdCBmbGFnc1xuICB2YXIgZmxhZ3MgPSAwXG4gIGZsYWdzIHw9ICh1c2VybmFtZSAhPSBudWxsKSA/IHByb3RvY29sLlVTRVJOQU1FX01BU0sgOiAwXG4gIGZsYWdzIHw9IChwYXNzd29yZCAhPSBudWxsKSA/IHByb3RvY29sLlBBU1NXT1JEX01BU0sgOiAwXG4gIGZsYWdzIHw9ICh3aWxsICYmIHdpbGwucmV0YWluKSA/IHByb3RvY29sLldJTExfUkVUQUlOX01BU0sgOiAwXG4gIGZsYWdzIHw9ICh3aWxsICYmIHdpbGwucW9zKSA/IHdpbGwucW9zIDw8IHByb3RvY29sLldJTExfUU9TX1NISUZUIDogMFxuICBmbGFncyB8PSB3aWxsID8gcHJvdG9jb2wuV0lMTF9GTEFHX01BU0sgOiAwXG4gIGZsYWdzIHw9IGNsZWFuID8gcHJvdG9jb2wuQ0xFQU5fU0VTU0lPTl9NQVNLIDogMFxuXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbZmxhZ3NdKSlcblxuICAvLyBLZWVwYWxpdmVcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBrZWVwYWxpdmUpXG5cbiAgLy8gQ2xpZW50IElEXG4gIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCBjbGllbnRJZClcblxuICAvLyBXaWxsXG4gIGlmICh3aWxsKSB7XG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB3aWxsLnRvcGljKVxuICAgIHdyaXRlU3RyaW5nT3JCdWZmZXIoc3RyZWFtLCB3aWxsLnBheWxvYWQpXG4gIH1cblxuICAvLyBVc2VybmFtZSBhbmQgcGFzc3dvcmRcbiAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgdXNlcm5hbWUpXG4gIH1cbiAgaWYgKHBhc3N3b3JkICE9IG51bGwpIHtcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgcGFzc3dvcmQpXG4gIH1cbiAgLy8gVGhpcyBpcyBhIHNtYWxsIHBhY2tldCB0aGF0IGhhcHBlbnMgb25seSBvbmNlIG9uIGEgc3RyZWFtXG4gIC8vIFdlIGFzc3VtZSB0aGUgc3RyZWFtIGlzIGFsd2F5cyBmcmVlIHRvIHJlY2VpdmUgbW9yZSBkYXRhIGFmdGVyIHRoaXNcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gY29ubmFjayAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIHJjID0gc2V0dGluZ3MucmV0dXJuQ29kZVxuXG4gIC8vIENoZWNrIHJldHVybiBjb2RlXG4gIGlmICh0eXBlb2YgcmMgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHJldHVybiBjb2RlJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQ09OTkFDS19IRUFERVIpXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgMilcbiAgc3RyZWFtLndyaXRlKG9wdHMuc2Vzc2lvblByZXNlbnQgPyBwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgOiB6ZXJvQnVmKVxuXG4gIHJldHVybiBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3JjXSkpXG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2ggKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciBxb3MgPSBzZXR0aW5ncy5xb3MgfHwgMFxuICB2YXIgcmV0YWluID0gc2V0dGluZ3MucmV0YWluID8gcHJvdG9jb2wuUkVUQUlOX01BU0sgOiAwXG4gIHZhciB0b3BpYyA9IHNldHRpbmdzLnRvcGljXG4gIHZhciBwYXlsb2FkID0gc2V0dGluZ3MucGF5bG9hZCB8fCBlbXB0eVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIFRvcGljIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIEJ1ZmZlclxuICBpZiAodHlwZW9mIHRvcGljID09PSAnc3RyaW5nJykgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRvcGljKSArIDJcbiAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRvcGljKSkgbGVuZ3RoICs9IHRvcGljLmxlbmd0aCArIDJcbiAgZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHRvcGljJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBHZXQgdGhlIHBheWxvYWQgbGVuZ3RoXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBheWxvYWQpKSBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgocGF5bG9hZClcbiAgZWxzZSBsZW5ndGggKz0gcGF5bG9hZC5sZW5ndGhcblxuICAvLyBNZXNzYWdlIElEIG11c3QgYSBudW1iZXIgaWYgcW9zID4gMFxuICBpZiAocW9zICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocW9zKSBsZW5ndGggKz0gMlxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuUFVCTElTSF9IRUFERVJbcW9zXVtvcHRzLmR1cCA/IDEgOiAwXVtyZXRhaW4gPyAxIDogMF0pXG5cbiAgLy8gUmVtYWluaW5nIGxlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBUb3BpY1xuICB3cml0ZU51bWJlcihzdHJlYW0sIGJ5dGVMZW5ndGgodG9waWMpKVxuICBzdHJlYW0ud3JpdGUodG9waWMpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICBpZiAocW9zID4gMCkgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBQYXlsb2FkXG4gIHJldHVybiBzdHJlYW0ud3JpdGUocGF5bG9hZClcbn1cblxuLyogUHViYWNrLCBwdWJyZWMsIHB1YnJlbCBhbmQgcHViY29tcCAqL1xuZnVuY3Rpb24gY29uZmlybWF0aW9uIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgdHlwZSA9IHNldHRpbmdzLmNtZCB8fCAncHViYWNrJ1xuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IChzZXR0aW5ncy5kdXAgJiYgdHlwZSA9PT0gJ3B1YnJlbCcpID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciBxb3MgPSAwXG5cbiAgaWYgKHR5cGUgPT09ICdwdWJyZWwnKSBxb3MgPSAxXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQUNLU1t0eXBlXVtxb3NdW2R1cF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgMilcblxuICAvLyBNZXNzYWdlIElEXG4gIHJldHVybiB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUgKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBzdWJzID0gc2V0dGluZ3Muc3Vic2NyaXB0aW9uc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAyXG5cbiAgLy8gQ2hlY2sgc3Vic2NyaXB0aW9uc1xuICBpZiAodHlwZW9mIHN1YnMgPT09ICdvYmplY3QnICYmIHN1YnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgaXRvcGljID0gc3Vic1tpXS50b3BpY1xuICAgICAgdmFyIGlxb3MgPSBzdWJzW2ldLnFvc1xuXG4gICAgICBpZiAodHlwZW9mIGl0b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHRvcGljJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpcW9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgcW9zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoaXRvcGljKSArIDIgKyAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBHZW5lcmF0ZSBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlNVQlNDUklCRV9IRUFERVJbMV1bZHVwID8gMSA6IDBdWzBdKVxuXG4gIC8vIEdlbmVyYXRlIGxlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBtZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgdmFyIHJlc3VsdCA9IHRydWVcblxuICAvLyBHZW5lcmF0ZSBzdWJzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc3Vicy5sZW5ndGg7IGorKykge1xuICAgIHZhciBzdWIgPSBzdWJzW2pdXG4gICAgdmFyIGp0b3BpYyA9IHN1Yi50b3BpY1xuICAgIHZhciBqcW9zID0gc3ViLnFvc1xuXG4gICAgLy8gV3JpdGUgdG9waWMgc3RyaW5nXG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCBqdG9waWMpXG5cbiAgICAvLyBXcml0ZSBxb3NcbiAgICByZXN1bHQgPSBzdHJlYW0ud3JpdGUocHJvdG9jb2wuUU9TW2pxb3NdKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzdWJhY2sgKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgZ3JhbnRlZCA9IHNldHRpbmdzLmdyYW50ZWRcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENoZWNrIGdyYW50ZWQgcW9zIHZlY3RvclxuICBpZiAodHlwZW9mIGdyYW50ZWQgPT09ICdvYmplY3QnICYmIGdyYW50ZWQubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGdyYW50ZWRbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCQUNLX0hFQURFUilcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIHJldHVybiBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oZ3JhbnRlZCkpXG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgdW5zdWJzID0gc2V0dGluZ3MudW5zdWJzY3JpcHRpb25zXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCArPSAyXG4gIH1cbiAgLy8gQ2hlY2sgdW5zdWJzXG4gIGlmICh0eXBlb2YgdW5zdWJzID09PSAnb2JqZWN0JyAmJiB1bnN1YnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnN1YnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgdW5zdWJzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVuc3Vic1tpXSkgKyAyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB1bnN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuVU5TVUJTQ1JJQkVfSEVBREVSWzFdW2R1cCA/IDEgOiAwXVswXSlcblxuICAvLyBMZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIFVuc3Vic1xuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuICBmb3IgKHZhciBqID0gMDsgaiA8IHVuc3Vicy5sZW5ndGg7IGorKykge1xuICAgIHJlc3VsdCA9IHdyaXRlU3RyaW5nKHN0cmVhbSwgdW5zdWJzW2pdKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBlbXB0eVBhY2tldCAob3B0cywgc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUocHJvdG9jb2wuRU1QVFlbb3B0cy5jbWRdKVxufVxuXG4vKipcbiAqIGNhbGNMZW5ndGhMZW5ndGggLSBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgcmVtYWluaW5nXG4gKiBsZW5ndGggZmllbGRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsY0xlbmd0aExlbmd0aCAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCAxMjgpIHJldHVybiAxXG4gIGVsc2UgaWYgKGxlbmd0aCA+PSAxMjggJiYgbGVuZ3RoIDwgMTYzODQpIHJldHVybiAyXG4gIGVsc2UgaWYgKGxlbmd0aCA+PSAxNjM4NCAmJiBsZW5ndGggPCAyMDk3MTUyKSByZXR1cm4gM1xuICBlbHNlIGlmIChsZW5ndGggPj0gMjA5NzE1MiAmJiBsZW5ndGggPCAyNjg0MzU0NTYpIHJldHVybiA0XG4gIGVsc2UgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gZ2VuQnVmTGVuZ3RoIChsZW5ndGgpIHtcbiAgdmFyIGRpZ2l0ID0gMFxuICB2YXIgcG9zID0gMFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGNhbGNMZW5ndGhMZW5ndGgobGVuZ3RoKSlcblxuICBkbyB7XG4gICAgZGlnaXQgPSBsZW5ndGggJSAxMjggfCAwXG4gICAgbGVuZ3RoID0gbGVuZ3RoIC8gMTI4IHwgMFxuICAgIGlmIChsZW5ndGggPiAwKSBkaWdpdCA9IGRpZ2l0IHwgMHg4MFxuXG4gICAgYnVmZmVyLndyaXRlVUludDgoZGlnaXQsIHBvcysrKVxuICB9IHdoaWxlIChsZW5ndGggPiAwKVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiB3cml0ZUxlbmd0aCAtIHdyaXRlIGFuIE1RVFQgc3R5bGUgbGVuZ3RoIGZpZWxkIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8TnVtYmVyPiBsZW5ndGggLSBsZW5ndGggKD4wKVxuICogQHJldHVybnMgPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgbGVuZ3RoQ2FjaGUgPSB7fVxuZnVuY3Rpb24gd3JpdGVMZW5ndGggKHN0cmVhbSwgbGVuZ3RoKSB7XG4gIHZhciBidWZmZXIgPSBsZW5ndGhDYWNoZVtsZW5ndGhdXG5cbiAgaWYgKCFidWZmZXIpIHtcbiAgICBidWZmZXIgPSBnZW5CdWZMZW5ndGgobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPCAxNjM4NCkgbGVuZ3RoQ2FjaGVbbGVuZ3RoXSA9IGJ1ZmZlclxuICB9XG5cbiAgc3RyZWFtLndyaXRlKGJ1ZmZlcilcbn1cblxuLyoqXG4gKiB3cml0ZVN0cmluZyAtIHdyaXRlIGEgdXRmOCBzdHJpbmcgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IHN0cmluZyAtIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nIChzdHJlYW0sIHN0cmluZykge1xuICB2YXIgc3RybGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nKVxuICB3cml0ZU51bWJlcihzdHJlYW0sIHN0cmxlbilcblxuICBzdHJlYW0ud3JpdGUoc3RyaW5nLCAndXRmOCcpXG59XG5cbi8qKlxuICogd3JpdGVOdW1iZXIgLSB3cml0ZSBhIHR3byBieXRlIG51bWJlciB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gbnVtYmVyIC0gbnVtYmVyIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTnVtYmVyQ2FjaGVkIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKG51bUNhY2hlW251bWJlcl0pXG59XG5mdW5jdGlvbiB3cml0ZU51bWJlckdlbmVyYXRlZCAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZU51bWJlcihudW1iZXIpKVxufVxuXG4vKipcbiAqIHdyaXRlU3RyaW5nT3JCdWZmZXIgLSB3cml0ZSBhIFN0cmluZyBvciBCdWZmZXIgd2l0aCB0aGUgaXRzIGxlbmd0aCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiB0b1dyaXRlIC0gU3RyaW5nIG9yIEJ1ZmZlclxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ09yQnVmZmVyIChzdHJlYW0sIHRvV3JpdGUpIHtcbiAgaWYgKHR5cGVvZiB0b1dyaXRlID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgdG9Xcml0ZSlcbiAgfSBlbHNlIGlmICh0b1dyaXRlKSB7XG4gICAgd3JpdGVOdW1iZXIoc3RyZWFtLCB0b1dyaXRlLmxlbmd0aClcbiAgICBzdHJlYW0ud3JpdGUodG9Xcml0ZSlcbiAgfSBlbHNlIHdyaXRlTnVtYmVyKHN0cmVhbSwgMClcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYnVmT3JTdHJpbmcpIHtcbiAgaWYgKCFidWZPclN0cmluZykgcmV0dXJuIDBcbiAgZWxzZSBpZiAoYnVmT3JTdHJpbmcgaW5zdGFuY2VvZiBCdWZmZXIpIHJldHVybiBidWZPclN0cmluZy5sZW5ndGhcbiAgZWxzZSByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYnVmT3JTdHJpbmcpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT3JCdWZmZXIgKGZpZWxkKSB7XG4gIHJldHVybiB0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnIHx8IGZpZWxkIGluc3RhbmNlb2YgQnVmZmVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgU3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBtcXR0UGFja2V0ID0gcmVxdWlyZSgnbXF0dC1wYWNrZXQnKVxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuV3JpdGFibGVcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZUludGVydmFsID0gcmVxdWlyZSgncmVpbnRlcnZhbCcpXG52YXIgdmFsaWRhdGlvbnMgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb25zJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBzZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAvLyB3b3JrcyBpbiBub2RlIHYwLjhcbiAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaylcbn1cbnZhciBkZWZhdWx0Q29ubmVjdE9wdGlvbnMgPSB7XG4gIGtlZXBhbGl2ZTogNjAsXG4gIHJlc2NoZWR1bGVQaW5nczogdHJ1ZSxcbiAgcHJvdG9jb2xJZDogJ01RVFQnLFxuICBwcm90b2NvbFZlcnNpb246IDQsXG4gIHJlY29ubmVjdFBlcmlvZDogMTAwMCxcbiAgY29ubmVjdFRpbWVvdXQ6IDMwICogMTAwMCxcbiAgY2xlYW46IHRydWUsXG4gIHJlc3Vic2NyaWJlOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZCAoKSB7XG4gIHJldHVybiAnbXF0dGpzXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMiwgOClcbn1cblxuZnVuY3Rpb24gc2VuZFBhY2tldCAoY2xpZW50LCBwYWNrZXQsIGNiKSB7XG4gIGNsaWVudC5lbWl0KCdwYWNrZXRzZW5kJywgcGFja2V0KVxuXG4gIHZhciByZXN1bHQgPSBtcXR0UGFja2V0LndyaXRlVG9TdHJlYW0ocGFja2V0LCBjbGllbnQuc3RyZWFtKVxuXG4gIGlmICghcmVzdWx0ICYmIGNiKSB7XG4gICAgY2xpZW50LnN0cmVhbS5vbmNlKCdkcmFpbicsIGNiKVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoIChxdWV1ZSkge1xuICBpZiAocXVldWUpIHtcbiAgICBPYmplY3Qua2V5cyhxdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUlkKSB7XG4gICAgICBpZiAodHlwZW9mIHF1ZXVlW21lc3NhZ2VJZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcXVldWVbbWVzc2FnZUlkXShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpXG4gICAgICAgIGRlbGV0ZSBxdWV1ZVttZXNzYWdlSWRdXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZUFuZFNlbmQgKGNsaWVudCwgcGFja2V0LCBjYikge1xuICBjbGllbnQub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiBzdG9yZWRQYWNrZXQgKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXG4gICAgfVxuICAgIHNlbmRQYWNrZXQoY2xpZW50LCBwYWNrZXQsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBub3AgKCkge31cblxuLyoqXG4gKiBNcXR0Q2xpZW50IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSAtIHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbm5lY3Rpb24gb3B0aW9uc1xuICogKHNlZSBDb25uZWN0aW9uI2Nvbm5lY3QpXG4gKi9cbmZ1bmN0aW9uIE1xdHRDbGllbnQgKHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1xdHRDbGllbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBNcXR0Q2xpZW50KHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gRGVmYXVsdHNcbiAgZm9yIChrIGluIGRlZmF1bHRDb25uZWN0T3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zW2tdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zW2tdID0gZGVmYXVsdENvbm5lY3RPcHRpb25zW2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuY2xpZW50SWQgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5jbGllbnRJZCA9PT0gJ3N0cmluZycpID8gdGhpcy5vcHRpb25zLmNsaWVudElkIDogZGVmYXVsdElkKClcblxuICB0aGlzLnN0cmVhbUJ1aWxkZXIgPSBzdHJlYW1CdWlsZGVyXG5cbiAgLy8gSW5mbGlnaHQgbWVzc2FnZSBzdG9yYWdlc1xuICB0aGlzLm91dGdvaW5nU3RvcmUgPSB0aGlzLm9wdGlvbnMub3V0Z29pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuICB0aGlzLmluY29taW5nU3RvcmUgPSB0aGlzLm9wdGlvbnMuaW5jb21pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuXG4gIC8vIFNob3VsZCBRb1MgemVybyBtZXNzYWdlcyBiZSBxdWV1ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBicm9rZW4/XG4gIHRoaXMucXVldWVRb1NaZXJvID0gdGhpcy5vcHRpb25zLnF1ZXVlUW9TWmVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMub3B0aW9ucy5xdWV1ZVFvU1plcm9cblxuICAvLyBtYXAgb2Ygc3Vic2NyaWJlZCB0b3BpY3MgdG8gc3VwcG9ydCByZWNvbm5lY3Rpb25cbiAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MgPSB7fVxuXG4gIC8vIG1hcCBvZiBhIHN1YnNjcmliZSBtZXNzYWdlSWQgYW5kIGEgdG9waWNcbiAgdGhpcy5tZXNzYWdlSWRUb1RvcGljID0ge31cblxuICAvLyBQaW5nIHRpbWVyLCBzZXR1cCBpbiBfc2V0dXBQaW5nVGltZXJcbiAgdGhpcy5waW5nVGltZXIgPSBudWxsXG4gIC8vIElzIHRoZSBjbGllbnQgY29ubmVjdGVkP1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gIC8vIEFyZSB3ZSBkaXNjb25uZWN0aW5nP1xuICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAvLyBQYWNrZXQgcXVldWVcbiAgdGhpcy5xdWV1ZSA9IFtdXG4gIC8vIGNvbm5hY2sgdGltZXJcbiAgdGhpcy5jb25uYWNrVGltZXIgPSBudWxsXG4gIC8vIFJlY29ubmVjdCB0aW1lclxuICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuICAvKipcbiAgICogTWVzc2FnZUlEcyBzdGFydGluZyB3aXRoIDFcbiAgICogZW5zdXJlIHRoYXQgbmV4dElkIGlzIG1pbi4gMSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcXR0anMvTVFUVC5qcy9pc3N1ZXMvODEwXG4gICAqL1xuICB0aGlzLm5leHRJZCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDY1NTM1KSlcblxuICAvLyBJbmZsaWdodCBjYWxsYmFja3NcbiAgdGhpcy5vdXRnb2luZyA9IHt9XG5cbiAgLy8gTWFyayBjb25uZWN0ZWQgb24gY29ubmVjdFxuICB0aGlzLm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlXG4gICAgdmFyIG91dFN0b3JlID0gdGhpcy5vdXRnb2luZ1N0b3JlLmNyZWF0ZVN0cmVhbSgpXG5cbiAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgIG91dFN0b3JlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcbiAgICB9KVxuICAgIG91dFN0b3JlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIG91dFN0b3JlLmRlc3Ryb3koKVxuICAgICAgb3V0U3RvcmUgPSBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVEZWxpdmVyICgpIHtcbiAgICAgIC8vIGVkZ2UgY2FzZSwgd2Ugd3JhcHBlZCB0aGlzIHR3aWNlXG4gICAgICBpZiAoIW91dFN0b3JlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgcGFja2V0ID0gb3V0U3RvcmUucmVhZCgxKVxuICAgICAgdmFyIGNiXG5cbiAgICAgIGlmICghcGFja2V0KSB7XG4gICAgICAgIC8vIHJlYWQgd2hlbiBkYXRhIGlzIGF2YWlsYWJsZSBpbiB0aGUgZnV0dXJlXG4gICAgICAgIG91dFN0b3JlLm9uY2UoJ3JlYWRhYmxlJywgc3RvcmVEZWxpdmVyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gQXZvaWQgdW5uZWNlc3Nhcnkgc3RyZWFtIHJlYWQgb3BlcmF0aW9ucyB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgICAgaWYgKCF0aGF0LmRpc2Nvbm5lY3RpbmcgJiYgIXRoYXQucmVjb25uZWN0VGltZXIpIHtcbiAgICAgICAgY2IgPSB0aGF0Lm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdXG4gICAgICAgIHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSBmdW5jdGlvbiAoZXJyLCBzdGF0dXMpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3JpZ2luYWwgY2FsbGJhY2sgcGFzc2VkIGluIHRvIHB1Ymxpc2ggZ2V0cyBpbnZva2VkXG4gICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihlcnIsIHN0YXR1cylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdG9yZURlbGl2ZXIoKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuX3NlbmRQYWNrZXQocGFja2V0KVxuICAgICAgfSBlbHNlIGlmIChvdXRTdG9yZS5kZXN0cm95KSB7XG4gICAgICAgIG91dFN0b3JlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0YXJ0IGZsb3dpbmdcbiAgICBzdG9yZURlbGl2ZXIoKVxuICB9KVxuXG4gIC8vIE1hcmsgZGlzY29ubmVjdGVkIG9uIHN0cmVhbSBjbG9zZVxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuICB9KVxuXG4gIC8vIFNldHVwIHBpbmcgdGltZXJcbiAgdGhpcy5vbignY29ubmVjdCcsIHRoaXMuX3NldHVwUGluZ1RpbWVyKVxuXG4gIC8vIFNlbmQgcXVldWVkIHBhY2tldHNcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlXG5cbiAgICBmdW5jdGlvbiBkZWxpdmVyICgpIHtcbiAgICAgIHZhciBlbnRyeSA9IHF1ZXVlLnNoaWZ0KClcbiAgICAgIHZhciBwYWNrZXQgPSBudWxsXG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHBhY2tldCA9IGVudHJ5LnBhY2tldFxuXG4gICAgICB0aGF0Ll9zZW5kUGFja2V0KFxuICAgICAgICBwYWNrZXQsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZW50cnkuY2IpIHtcbiAgICAgICAgICAgIGVudHJ5LmNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsaXZlcigpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWxpdmVyKClcbiAgfSlcblxuICB2YXIgZmlyc3RDb25uZWN0aW9uID0gdHJ1ZVxuICAvLyByZXN1YnNjcmliZVxuICB0aGlzLm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghZmlyc3RDb25uZWN0aW9uICYmXG4gICAgICAgIHRoaXMub3B0aW9ucy5jbGVhbiAmJlxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9yZXN1YnNjcmliZVRvcGljcykubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcy5yZXN1YnNjcmliZSA9IHRydWVcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUodGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcyA9IHt9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RDb25uZWN0aW9uID0gZmFsc2VcbiAgfSlcblxuICAvLyBDbGVhciBwaW5nIHRpbWVyXG4gIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGF0LnBpbmdUaW1lciAhPT0gbnVsbCkge1xuICAgICAgdGhhdC5waW5nVGltZXIuY2xlYXIoKVxuICAgICAgdGhhdC5waW5nVGltZXIgPSBudWxsXG4gICAgfVxuICB9KVxuXG4gIC8vIFNldHVwIHJlY29ubmVjdCB0aW1lciBvbiBkaXNjb25uZWN0XG4gIHRoaXMub24oJ2Nsb3NlJywgdGhpcy5fc2V0dXBSZWNvbm5lY3QpXG5cbiAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fc2V0dXBTdHJlYW0oKVxufVxuaW5oZXJpdHMoTXF0dENsaWVudCwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuLyoqXG4gKiBzZXR1cCB0aGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhlIGlubmVyIHN0cmVhbS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29ubmVjdFBhY2tldFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlKClcbiAgdmFyIHBhcnNlciA9IG1xdHRQYWNrZXQucGFyc2VyKHRoaXMub3B0aW9ucylcbiAgdmFyIGNvbXBsZXRlUGFyc2UgPSBudWxsXG4gIHZhciBwYWNrZXRzID0gW11cblxuICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG5cbiAgdGhpcy5zdHJlYW0gPSB0aGlzLnN0cmVhbUJ1aWxkZXIodGhpcylcblxuICBwYXJzZXIub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBwYWNrZXRzLnB1c2gocGFja2V0KVxuICB9KVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrV29yayAoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayh3b3JrKVxuICB9XG5cbiAgZnVuY3Rpb24gd29yayAoKSB7XG4gICAgdmFyIHBhY2tldCA9IHBhY2tldHMuc2hpZnQoKVxuICAgIHZhciBkb25lID0gY29tcGxldGVQYXJzZVxuXG4gICAgaWYgKHBhY2tldCkge1xuICAgICAgdGhhdC5faGFuZGxlUGFja2V0KHBhY2tldCwgbmV4dFRpY2tXb3JrKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZVBhcnNlID0gbnVsbFxuICAgICAgZG9uZSgpXG4gICAgfVxuICB9XG5cbiAgd3JpdGFibGUuX3dyaXRlID0gZnVuY3Rpb24gKGJ1ZiwgZW5jLCBkb25lKSB7XG4gICAgY29tcGxldGVQYXJzZSA9IGRvbmVcbiAgICBwYXJzZXIucGFyc2UoYnVmKVxuICAgIHdvcmsoKVxuICB9XG5cbiAgdGhpcy5zdHJlYW0ucGlwZSh3cml0YWJsZSlcblxuICAvLyBTdXBwcmVzcyBjb25uZWN0aW9uIGVycm9yc1xuICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBub3ApXG5cbiAgLy8gRWNobyBzdHJlYW0gY2xvc2VcbiAgZW9zKHRoaXMuc3RyZWFtLCB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY2xvc2UnKSlcblxuICAvLyBTZW5kIGEgY29ubmVjdCBwYWNrZXRcbiAgY29ubmVjdFBhY2tldCA9IE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKVxuICBjb25uZWN0UGFja2V0LmNtZCA9ICdjb25uZWN0J1xuICAvLyBhdm9pZCBtZXNzYWdlIHF1ZXVlXG4gIHNlbmRQYWNrZXQodGhpcywgY29ubmVjdFBhY2tldClcblxuICAvLyBFY2hvIGNvbm5lY3Rpb24gZXJyb3JzXG4gIHBhcnNlci5vbignZXJyb3InLCB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZXJyb3InKSlcblxuICAvLyBtYW55IGRyYWluIGxpc3RlbmVycyBhcmUgbmVlZGVkIGZvciBxb3MgMSBjYWxsYmFja3MgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW50ZXJtaXR0ZW50XG4gIHRoaXMuc3RyZWFtLnNldE1heExpc3RlbmVycygxMDAwKVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcbiAgdGhpcy5jb25uYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGF0Ll9jbGVhblVwKHRydWUpXG4gIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0VGltZW91dClcbn1cblxuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGRvbmUpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXRyZWNlaXZlJywgcGFja2V0KVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgdGhpcy5faGFuZGxlUHVibGlzaChwYWNrZXQsIGRvbmUpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJjb21wJzpcbiAgICBjYXNlICdzdWJhY2snOlxuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgIHRoaXMuX2hhbmRsZUFjayhwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHVicmVsJzpcbiAgICAgIHRoaXMuX2hhbmRsZVB1YnJlbChwYWNrZXQsIGRvbmUpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Nvbm5hY2snOlxuICAgICAgdGhpcy5faGFuZGxlQ29ubmFjayhwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgdGhpcy5faGFuZGxlUGluZ3Jlc3AocGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAvLyBtYXliZSB3ZSBzaG91bGQgZG8gYW4gZXJyb3IgaGFuZGxpbmdcbiAgICAgIC8vIG9yIGp1c3QgbG9nIGl0XG4gICAgICBicmVha1xuICB9XG59XG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jaGVja0Rpc2Nvbm5lY3RpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdjbGllbnQgZGlzY29ubmVjdGluZycpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnQgZGlzY29ubmVjdGluZycpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5kaXNjb25uZWN0aW5nXG59XG5cbi8qKlxuICogcHVibGlzaCAtIHB1Ymxpc2ggPG1lc3NhZ2U+IHRvIDx0b3BpYz5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSB0b3BpYyB0byBwdWJsaXNoIHRvXG4gKiBAcGFyYW0ge1N0cmluZywgQnVmZmVyfSBtZXNzYWdlIC0gbWVzc2FnZSB0byBwdWJsaXNoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gcHVibGlzaCBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtOdW1iZXJ9IHFvcyAtIHFvcyBsZXZlbCB0byBwdWJsaXNoIG9uXG4gKiAgICB7Qm9vbGVhbn0gcmV0YWluIC0gd2hldGhlciBvciBub3QgdG8gcmV0YWluIHRoZSBtZXNzYWdlXG4gKiAgICB7Qm9vbGVhbn0gZHVwIC0gd2hldGhlciBvciBub3QgbWFyayBhIG1lc3NhZ2UgYXMgZHVwbGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gZnVuY3Rpb24oZXJyKXt9XG4gKiAgICBjYWxsZWQgd2hlbiBwdWJsaXNoIHN1Y2NlZWRzIG9yIGZhaWxzXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScpO1xuICogQGV4YW1wbGVcbiAqICAgICBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScsIHtxb3M6IDEsIHJldGFpbjogdHJ1ZSwgZHVwOiB0cnVlfSk7XG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScsIGNvbnNvbGUubG9nKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpYywgbWVzc2FnZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIHBhY2tldFxuXG4gIC8vIC5wdWJsaXNoKHRvcGljLCBwYXlsb2FkLCBjYik7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICAvLyBkZWZhdWx0IG9wdHNcbiAgdmFyIGRlZmF1bHRPcHRzID0ge3FvczogMCwgcmV0YWluOiBmYWxzZSwgZHVwOiBmYWxzZX1cbiAgb3B0cyA9IHh0ZW5kKGRlZmF1bHRPcHRzLCBvcHRzKVxuXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBhY2tldCA9IHtcbiAgICBjbWQ6ICdwdWJsaXNoJyxcbiAgICB0b3BpYzogdG9waWMsXG4gICAgcGF5bG9hZDogbWVzc2FnZSxcbiAgICBxb3M6IG9wdHMucW9zLFxuICAgIHJldGFpbjogb3B0cy5yZXRhaW4sXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKSxcbiAgICBkdXA6IG9wdHMuZHVwXG4gIH1cblxuICBzd2l0Y2ggKG9wdHMucW9zKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcblxuICAgICAgLy8gQWRkIHRvIGNhbGxiYWNrc1xuICAgICAgdGhpcy5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IGNhbGxiYWNrIHx8IG5vcFxuICAgICAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldCwgY2FsbGJhY2spXG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBzdWJzY3JpYmUgLSBzdWJzY3JpYmUgdG8gPHRvcGljPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheSwgT2JqZWN0fSB0b3BpYyAtIHRvcGljKHMpIHRvIHN1YnNjcmliZSB0bywgc3VwcG9ydHMgb2JqZWN0cyBpbiB0aGUgZm9ybSB7J3RvcGljJzogcW9zfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHN1YnNjcmlwdGlvbiBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtOdW1iZXJ9IHFvcyAtIHN1YnNjcmliZSBxb3MgbGV2ZWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIsIGdyYW50ZWQpe30gd2hlcmU6XG4gKiAgICB7RXJyb3J9IGVyciAtIHN1YnNjcmlwdGlvbiBlcnJvciAobm9uZSBhdCB0aGUgbW9tZW50ISlcbiAqICAgIHtBcnJheX0gZ3JhbnRlZCAtIGFycmF5IG9mIHt0b3BpYzogJ3QnLCBxb3M6IDB9XG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoJ3RvcGljJyk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIHtxb3M6IDF9KTtcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoeyd0b3BpYyc6IDAsICd0b3BpYzInOiAxfSwgY29uc29sZS5sb2cpO1xuICogQGV4YW1wbGUgY2xpZW50LnN1YnNjcmliZSgndG9waWMnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgdmFyIHN1YnMgPSBbXVxuICB2YXIgb2JqID0gYXJncy5zaGlmdCgpXG4gIHZhciByZXN1YnNjcmliZSA9IG9iai5yZXN1YnNjcmliZVxuICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpIHx8IG5vcFxuICB2YXIgb3B0cyA9IGFyZ3MucG9wKClcbiAgdmFyIGludmFsaWRUb3BpY1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBkZWxldGUgb2JqLnJlc3Vic2NyaWJlXG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgb2JqID0gW29ial1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0gY2FsbGJhY2tcbiAgICBjYWxsYmFjayA9IG5vcFxuICB9XG5cbiAgaW52YWxpZFRvcGljID0gdmFsaWRhdGlvbnMudmFsaWRhdGVUb3BpY3Mob2JqKVxuICBpZiAoaW52YWxpZFRvcGljICE9PSBudWxsKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMgJyArIGludmFsaWRUb3BpYykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBkZWZhdWx0T3B0cyA9IHsgcW9zOiAwIH1cbiAgb3B0cyA9IHh0ZW5kKGRlZmF1bHRPcHRzLCBvcHRzKVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodG9waWMpIHtcbiAgICAgIGlmICh0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY10gPCBvcHRzLnFvcyB8fFxuICAgICAgICAgICF0aGF0Ll9yZXN1YnNjcmliZVRvcGljcy5oYXNPd25Qcm9wZXJ0eSh0b3BpYykgfHxcbiAgICAgICAgICByZXN1YnNjcmliZSkge1xuICAgICAgICBzdWJzLnB1c2goe1xuICAgICAgICAgIHRvcGljOiB0b3BpYyxcbiAgICAgICAgICBxb3M6IG9wdHMucW9zXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBPYmplY3RcbiAgICAgIC5rZXlzKG9iailcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmICh0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1trXSA8IG9ialtrXSB8fFxuICAgICAgICAgICAgIXRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzLmhhc093blByb3BlcnR5KGspIHx8XG4gICAgICAgICAgICByZXN1YnNjcmliZSkge1xuICAgICAgICAgIHN1YnMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogayxcbiAgICAgICAgICAgIHFvczogb2JqW2tdXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIHBhY2tldCA9IHtcbiAgICBjbWQ6ICdzdWJzY3JpYmUnLFxuICAgIHN1YnNjcmlwdGlvbnM6IHN1YnMsXG4gICAgcW9zOiAxLFxuICAgIHJldGFpbjogZmFsc2UsXG4gICAgZHVwOiBmYWxzZSxcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpXG4gIH1cblxuICBpZiAoIXN1YnMubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgW10pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBzdWJzY3JpcHRpb25zIHRvIHJlc3Vic2NyaWJlIHRvIGluIGNhc2Ugb2YgZGlzY29ubmVjdFxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgdmFyIHRvcGljcyA9IFtdXG4gICAgc3Vicy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHtcbiAgICAgIGlmICh0aGF0Lm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID4gMCkge1xuICAgICAgICB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1tzdWIudG9waWNdID0gc3ViLnFvc1xuICAgICAgICB0b3BpY3MucHVzaChzdWIudG9waWMpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGF0Lm1lc3NhZ2VJZFRvVG9waWNbcGFja2V0Lm1lc3NhZ2VJZF0gPSB0b3BpY3NcbiAgfVxuXG4gIHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSBmdW5jdGlvbiAoZXJyLCBwYWNrZXQpIHtcbiAgICBpZiAoIWVycikge1xuICAgICAgdmFyIGdyYW50ZWQgPSBwYWNrZXQuZ3JhbnRlZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN1YnNbaV0ucW9zID0gZ3JhbnRlZFtpXVxuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrKGVyciwgc3VicylcbiAgfVxuXG4gIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogdW5zdWJzY3JpYmUgLSB1bnN1YnNjcmliZSBmcm9tIHRvcGljKHMpXG4gKlxuICogQHBhcmFtIHtTdHJpbmcsIEFycmF5fSB0b3BpYyAtIHRvcGljcyB0byB1bnN1YnNjcmliZSBmcm9tXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGJhY2sgZmlyZWQgb24gdW5zdWJhY2tcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICogQGV4YW1wbGUgY2xpZW50LnVuc3Vic2NyaWJlKCd0b3BpYycpO1xuICogQGV4YW1wbGUgY2xpZW50LnVuc3Vic2NyaWJlKCd0b3BpYycsIGNvbnNvbGUubG9nKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodG9waWMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYWNrZXQgPSB7XG4gICAgY21kOiAndW5zdWJzY3JpYmUnLFxuICAgIHFvczogMSxcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpXG4gIH1cbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub3BcblxuICBpZiAodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpZiAodHlwZW9mIHRvcGljID09PSAnc3RyaW5nJykge1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSBbdG9waWNdXG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvcGljID09PSAnb2JqZWN0JyAmJiB0b3BpYy5sZW5ndGgpIHtcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gdG9waWNcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucmVzdWJzY3JpYmUpIHtcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICBkZWxldGUgdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3NbdG9waWNdXG4gICAgfSlcbiAgfVxuXG4gIHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSBjYWxsYmFja1xuXG4gIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogZW5kIC0gY2xvc2UgY29ubmVjdGlvblxuICpcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIC0gZG8gbm90IHdhaXQgZm9yIGFsbCBpbi1mbGlnaHQgbWVzc2FnZXMgdG8gYmUgYWNrZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGVkIHdoZW4gdGhlIGNsaWVudCBoYXMgYmVlbiBjbG9zZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoZm9yY2UsIGNiKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGZvcmNlXG4gICAgZm9yY2UgPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VTdG9yZXMgKCkge1xuICAgIHRoYXQuZGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoYXQuaW5jb21pbmdTdG9yZS5jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Lm91dGdvaW5nU3RvcmUuY2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYi5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5lbWl0KCdlbmQnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIGlmICh0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCkge1xuICAgICAgdGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaCAoKSB7XG4gICAgLy8gZGVmZXIgY2xvc2VzU3RvcmVzIG9mIGFuIEkvTyBjeWNsZSxcbiAgICAvLyBqdXN0IHRvIG1ha2Ugc3VyZSB0aGluZ3MgYXJlXG4gICAgLy8gb2sgZm9yIHdlYnNvY2tldHNcbiAgICB0aGF0Ll9jbGVhblVwKGZvcmNlLCBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBjbG9zZVN0b3JlcykpXG4gIH1cblxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoaXMuX2NsZWFyUmVjb25uZWN0KClcblxuICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSB0cnVlXG5cbiAgaWYgKCFmb3JjZSAmJiBPYmplY3Qua2V5cyh0aGlzLm91dGdvaW5nKS5sZW5ndGggPiAwKSB7XG4gICAgLy8gd2FpdCAxMG1zLCBqdXN0IHRvIGJlIHN1cmUgd2UgcmVjZWl2ZWQgYWxsIG9mIGl0XG4gICAgdGhpcy5vbmNlKCdvdXRnb2luZ0VtcHR5Jywgc2V0VGltZW91dC5iaW5kKG51bGwsIGZpbmlzaCwgMTApKVxuICB9IGVsc2Uge1xuICAgIGZpbmlzaCgpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHJlbW92ZU91dGdvaW5nTWVzc2FnZSAtIHJlbW92ZSBhIG1lc3NhZ2UgaW4gb3V0Z29pbmcgc3RvcmVcbiAqIHRoZSBvdXRnb2luZyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoZSBFcnJvcignTWVzc2FnZSByZW1vdmVkJykgaWYgdGhlIG1lc3NhZ2UgaXMgcmVtb3ZlZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWQgLSBtZXNzYWdlSWQgdG8gcmVtb3ZlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqIEBleGFtcGxlIGNsaWVudC5yZW1vdmVPdXRnb2luZ01lc3NhZ2UoY2xpZW50LmdldExhc3RNZXNzYWdlSWQoKSk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnJlbW92ZU91dGdvaW5nTWVzc2FnZSA9IGZ1bmN0aW9uIChtaWQpIHtcbiAgdmFyIGNiID0gdGhpcy5vdXRnb2luZ1ttaWRdXG4gIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgdGhpcy5vdXRnb2luZ1N0b3JlLmRlbCh7bWVzc2FnZUlkOiBtaWR9LCBmdW5jdGlvbiAoKSB7XG4gICAgY2IobmV3IEVycm9yKCdNZXNzYWdlIHJlbW92ZWQnKSlcbiAgfSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiByZWNvbm5lY3QgLSBjb25uZWN0IGFnYWluIHVzaW5nIHRoZSBzYW1lIG9wdGlvbnMgYXMgY29ubmVjdCgpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHJlY29ubmVjdCBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtTdG9yZX0gaW5jb21pbmdTdG9yZSAtIGEgc3RvcmUgZm9yIHRoZSBpbmNvbWluZyBwYWNrZXRzXG4gKiAgICB7U3RvcmV9IG91dGdvaW5nU3RvcmUgLSBhIHN0b3JlIGZvciB0aGUgb3V0Z29pbmcgcGFja2V0c1xuICogICAgaWYgb3B0cyBpcyBub3QgZ2l2ZW4sIGN1cnJlbnQgc3RvcmVzIGFyZSB1c2VkXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgdGhhdC5vcHRpb25zLmluY29taW5nU3RvcmUgPSBvcHRzLmluY29taW5nU3RvcmVcbiAgICAgIHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlID0gb3B0cy5vdXRnb2luZ1N0b3JlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlID0gbnVsbFxuICAgICAgdGhhdC5vcHRpb25zLm91dGdvaW5nU3RvcmUgPSBudWxsXG4gICAgfVxuICAgIHRoYXQuaW5jb21pbmdTdG9yZSA9IHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG4gICAgdGhhdC5vdXRnb2luZ1N0b3JlID0gdGhhdC5vcHRpb25zLm91dGdvaW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcbiAgICB0aGF0LmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoYXQuZGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGF0Ll9kZWZlcnJlZFJlY29ubmVjdCA9IG51bGxcbiAgICB0aGF0Ll9yZWNvbm5lY3QoKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZyAmJiAhdGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICB0aGlzLl9kZWZlcnJlZFJlY29ubmVjdCA9IGZcbiAgfSBlbHNlIHtcbiAgICBmKClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIF9yZWNvbm5lY3QgLSBpbXBsZW1lbnQgcmVjb25uZWN0aW9uXG4gKiBAYXBpIHByaXZhdGVpc2hcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3JlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdyZWNvbm5lY3QnKVxuICB0aGlzLl9zZXR1cFN0cmVhbSgpXG59XG5cbi8qKlxuICogX3NldHVwUmVjb25uZWN0IC0gc2V0dXAgcmVjb25uZWN0IHRpbWVyXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCF0aGF0LmRpc2Nvbm5lY3RpbmcgJiYgIXRoYXQucmVjb25uZWN0VGltZXIgJiYgKHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPiAwKSkge1xuICAgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcpIHtcbiAgICAgIHRoaXMuZW1pdCgnb2ZmbGluZScpXG4gICAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWVcbiAgICB9XG4gICAgdGhhdC5yZWNvbm5lY3RUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuX3JlY29ubmVjdCgpXG4gICAgfSwgdGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZClcbiAgfVxufVxuXG4vKipcbiAqIF9jbGVhclJlY29ubmVjdCAtIGNsZWFyIHRoZSByZWNvbm5lY3QgdGltZXJcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NsZWFyUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWNvbm5lY3RUaW1lcilcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogX2NsZWFuVXAgLSBjbGVhbiB1cCBvbiBjb25uZWN0aW9uIGVuZFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jbGVhblVwID0gZnVuY3Rpb24gKGZvcmNlZCwgZG9uZSkge1xuICBpZiAoZG9uZSkge1xuICAgIHRoaXMuc3RyZWFtLm9uKCdjbG9zZScsIGRvbmUpXG4gIH1cblxuICBpZiAoZm9yY2VkKSB7XG4gICAgaWYgKCh0aGlzLm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID09PSAwKSAmJiB0aGlzLm9wdGlvbnMuY2xlYW4pIHtcbiAgICAgIGZsdXNoKHRoaXMub3V0Z29pbmcpXG4gICAgfVxuICAgIHRoaXMuc3RyZWFtLmRlc3Ryb3koKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NlbmRQYWNrZXQoXG4gICAgICB7IGNtZDogJ2Rpc2Nvbm5lY3QnIH0sXG4gICAgICBzZXRJbW1lZGlhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5zdHJlYW0uZW5kLmJpbmQodGhpcy5zdHJlYW0pXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgaWYgKCF0aGlzLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG4gICAgdGhpcy5fc2V0dXBSZWNvbm5lY3QoKVxuICB9XG5cbiAgaWYgKHRoaXMucGluZ1RpbWVyICE9PSBudWxsKSB7XG4gICAgdGhpcy5waW5nVGltZXIuY2xlYXIoKVxuICAgIHRoaXMucGluZ1RpbWVyID0gbnVsbFxuICB9XG5cbiAgaWYgKGRvbmUgJiYgIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5zdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgZG9uZSlcbiAgICBkb25lKClcbiAgfVxufVxuXG4vKipcbiAqIF9zZW5kUGFja2V0IC0gc2VuZCBvciBxdWV1ZSBhIHBhY2tldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBwYWNrZXQgdHlwZSAoc2VlIGBwcm90b2NvbGApXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgd2hlbiB0aGUgcGFja2V0IGlzIHNlbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2VuZFBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiKSB7XG4gIGlmICghdGhpcy5jb25uZWN0ZWQpIHtcbiAgICBpZiAoKChwYWNrZXQucW9zIHx8IDApID09PSAwICYmIHRoaXMucXVldWVRb1NaZXJvKSB8fCBwYWNrZXQuY21kICE9PSAncHVibGlzaCcpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7IHBhY2tldDogcGFja2V0LCBjYjogY2IgfSlcbiAgICB9IGVsc2UgaWYgKHBhY2tldC5xb3MgPiAwKSB7XG4gICAgICBjYiA9IHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF1cbiAgICAgIHRoaXMub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IgJiYgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKG5ldyBFcnJvcignTm8gY29ubmVjdGlvbiB0byBicm9rZXInKSlcbiAgICB9XG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFdoZW4gc2VuZGluZyBhIHBhY2tldCwgcmVzY2hlZHVsZSB0aGUgcGluZyB0aW1lclxuICB0aGlzLl9zaGlmdFBpbmdJbnRlcnZhbCgpXG5cbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XG4gICAgY2FzZSAncHVibGlzaCc6XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICBzdG9yZUFuZFNlbmQodGhpcywgcGFja2V0LCBjYilcbiAgICAgIHJldHVyblxuICAgIGRlZmF1bHQ6XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHN3aXRjaCAocGFja2V0LnFvcykge1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDE6XG4gICAgICBzdG9yZUFuZFNlbmQodGhpcywgcGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gICAgLyoqXG4gICAgICogbm8gbmVlZCBvZiBjYXNlIGhlcmUgc2luY2UgaXQgd2lsbCBiZSBjYXVnaHQgYnkgZGVmYXVsdFxuICAgICAqIGFuZCBqc2hpbnQgY29tcGx5IHRoYXQgYmVmb3JlIGRlZmF1bHQgaXQgbXVzdCBiZSBhIGJyZWFrXG4gICAgICogYW55d2F5IGl0IHdpbGwgcmVzdWx0IGluIC0xIGV2YWx1YXRpb25cbiAgICAgKi9cbiAgICBjYXNlIDA6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbmRQYWNrZXQodGhpcywgcGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuLyoqXG4gKiBfc2V0dXBQaW5nVGltZXIgLSBzZXR1cCB0aGUgcGluZyB0aW1lclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2V0dXBQaW5nVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGlmICghdGhpcy5waW5nVGltZXIgJiYgdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSkge1xuICAgIHRoaXMucGluZ1Jlc3AgPSB0cnVlXG4gICAgdGhpcy5waW5nVGltZXIgPSByZUludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuX2NoZWNrUGluZygpXG4gICAgfSwgdGhpcy5vcHRpb25zLmtlZXBhbGl2ZSAqIDEwMDApXG4gIH1cbn1cblxuLyoqXG4gKiBfc2hpZnRQaW5nSW50ZXJ2YWwgLSByZXNjaGVkdWxlIHRoZSBwaW5nIGludGVydmFsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zaGlmdFBpbmdJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGluZ1RpbWVyICYmIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgJiYgdGhpcy5vcHRpb25zLnJlc2NoZWR1bGVQaW5ncykge1xuICAgIHRoaXMucGluZ1RpbWVyLnJlc2NoZWR1bGUodGhpcy5vcHRpb25zLmtlZXBhbGl2ZSAqIDEwMDApXG4gIH1cbn1cbi8qKlxuICogX2NoZWNrUGluZyAtIGNoZWNrIGlmIGEgcGluZ3Jlc3AgaGFzIGNvbWUgYmFjaywgYW5kIHBpbmcgdGhlIHNlcnZlciBhZ2FpblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2hlY2tQaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5waW5nUmVzcCkge1xuICAgIHRoaXMucGluZ1Jlc3AgPSBmYWxzZVxuICAgIHRoaXMuX3NlbmRQYWNrZXQoeyBjbWQ6ICdwaW5ncmVxJyB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGRvIGEgZm9yY2VkIGNsZWFudXAgc2luY2Ugc29ja2V0IHdpbGwgYmUgaW4gYmFkIHNoYXBlXG4gICAgdGhpcy5fY2xlYW5VcCh0cnVlKVxuICB9XG59XG5cbi8qKlxuICogX2hhbmRsZVBpbmdyZXNwIC0gaGFuZGxlIGEgcGluZ3Jlc3BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVBpbmdyZXNwID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBpbmdSZXNwID0gdHJ1ZVxufVxuXG4vKipcbiAqIF9oYW5kbGVDb25uYWNrXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZUNvbm5hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciByYyA9IHBhY2tldC5yZXR1cm5Db2RlXG4gIHZhciBlcnJvcnMgPSBbXG4gICAgJycsXG4gICAgJ1VuYWNjZXB0YWJsZSBwcm90b2NvbCB2ZXJzaW9uJyxcbiAgICAnSWRlbnRpZmllciByZWplY3RlZCcsXG4gICAgJ1NlcnZlciB1bmF2YWlsYWJsZScsXG4gICAgJ0JhZCB1c2VybmFtZSBvciBwYXNzd29yZCcsXG4gICAgJ05vdCBhdXRob3JpemVkJ1xuICBdXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuXG4gIGlmIChyYyA9PT0gMCkge1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBwYWNrZXQpXG4gIH0gZWxzZSBpZiAocmMgPiAwKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiByZWZ1c2VkOiAnICsgZXJyb3JzW3JjXSlcbiAgICBlcnIuY29kZSA9IHJjXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQdWJsaXNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cbi8qXG50aG9zZSBsYXRlIDIgY2FzZSBzaG91bGQgYmUgcmV3cml0ZSB0byBjb21wbHkgd2l0aCBjb2Rpbmcgc3R5bGU6XG5cbmNhc2UgMTpcbmNhc2UgMDpcbiAgLy8gZG8gbm90IHdhaXQgc2VuZGluZyBhIHB1YmFja1xuICAvLyBubyBjYWxsYmFjayBwYXNzZWRcbiAgaWYgKDEgPT09IHFvcykge1xuICAgIHRoaXMuX3NlbmRQYWNrZXQoe1xuICAgICAgY21kOiAncHViYWNrJyxcbiAgICAgIG1lc3NhZ2VJZDogbWlkXG4gICAgfSk7XG4gIH1cbiAgLy8gZW1pdCB0aGUgbWVzc2FnZSBldmVudCBmb3IgYm90aCBxb3MgMSBhbmQgMFxuICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KTtcbiAgdGhpcy5oYW5kbGVNZXNzYWdlKHBhY2tldCwgZG9uZSk7XG4gIGJyZWFrO1xuZGVmYXVsdDpcbiAgLy8gZG8gbm90aGluZyBidXQgZXZlcnkgc3dpdGNoIG11cyBoYXZlIGEgZGVmYXVsdFxuICAvLyBsb2cgb3IgdGhyb3cgYW4gZXJyb3IgYWJvdXQgdW5rbm93biBxb3NcbiAgYnJlYWs7XG5cbmZvciBub3cgaSBqdXN0IHN1cHByZXNzZWQgdGhlIHdhcm5pbmdzXG4qL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVB1Ymxpc2ggPSBmdW5jdGlvbiAocGFja2V0LCBkb25lKSB7XG4gIGRvbmUgPSB0eXBlb2YgZG9uZSAhPT0gJ3VuZGVmaW5lZCcgPyBkb25lIDogbm9wXG4gIHZhciB0b3BpYyA9IHBhY2tldC50b3BpYy50b1N0cmluZygpXG4gIHZhciBtZXNzYWdlID0gcGFja2V0LnBheWxvYWRcbiAgdmFyIHFvcyA9IHBhY2tldC5xb3NcbiAgdmFyIG1pZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgc3dpdGNoIChxb3MpIHtcbiAgICBjYXNlIDI6XG4gICAgICB0aGlzLmluY29taW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YnJlYycsIG1lc3NhZ2VJZDogbWlkfSwgZG9uZSlcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnRcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpXG4gICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZShlcnIpXG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VuZCAncHViYWNrJyBpZiB0aGUgYWJvdmUgJ2hhbmRsZU1lc3NhZ2UnIG1ldGhvZCBleGVjdXRlZFxuICAgICAgICAvLyBzdWNjZXNzZnVsbHkuXG4gICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YmFjaycsIG1lc3NhZ2VJZDogbWlkfSwgZG9uZSlcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIGNhc2UgMDpcbiAgICAgIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnRcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpXG4gICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgLy8gbG9nIG9yIHRocm93IGFuIGVycm9yIGFib3V0IHVua25vd24gcW9zXG4gICAgICBicmVha1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIG1lc3NhZ2VzIHdpdGggYmFja3ByZXNzdXJlIHN1cHBvcnQsIG9uZSBhdCBhIHRpbWUuXG4gKiBPdmVycmlkZSBhdCB3aWxsLlxuICpcbiAqIEBwYXJhbSBQYWNrZXQgcGFja2V0IHRoZSBwYWNrZXRcbiAqIEBwYXJhbSBGdW5jdGlvbiBjYWxsYmFjayBjYWxsIHdoZW4gZmluaXNoZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAocGFja2V0LCBjYWxsYmFjaykge1xuICBjYWxsYmFjaygpXG59XG5cbi8qKlxuICogX2hhbmRsZUFja1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVBY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICB2YXIgbWlkID0gcGFja2V0Lm1lc3NhZ2VJZFxuICB2YXIgdHlwZSA9IHBhY2tldC5jbWRcbiAgdmFyIHJlc3BvbnNlID0gbnVsbFxuICB2YXIgY2IgPSB0aGlzLm91dGdvaW5nW21pZF1cbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCFjYikge1xuICAgIC8vIFNlcnZlciBzZW50IGFuIGFjayBpbiBlcnJvciwgaWdub3JlIGl0LlxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gUHJvY2Vzc1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdwdWJjb21wJzpcbiAgICAgIC8vIHNhbWUgdGhpbmcgYXMgcHViYWNrIGZvciBRb1MgMlxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICAvLyBDYWxsYmFjayAtIHdlJ3JlIGRvbmVcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21pZF1cbiAgICAgIHRoaXMub3V0Z29pbmdTdG9yZS5kZWwocGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHVicmVjJzpcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICBjbWQ6ICdwdWJyZWwnLFxuICAgICAgICBxb3M6IDIsXG4gICAgICAgIG1lc3NhZ2VJZDogbWlkXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NlbmRQYWNrZXQocmVzcG9uc2UpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgICBkZWxldGUgdGhpcy5vdXRnb2luZ1ttaWRdXG4gICAgICBpZiAocGFja2V0LmdyYW50ZWQubGVuZ3RoID09PSAxICYmIChwYWNrZXQuZ3JhbnRlZFswXSAmIDB4ODApICE9PSAwKSB7XG4gICAgICAgIC8vIHN1YmFjayB3aXRoIEZhaWx1cmUgc3RhdHVzXG4gICAgICAgIHZhciB0b3BpY3MgPSB0aGlzLm1lc3NhZ2VJZFRvVG9waWNbbWlkXVxuICAgICAgICBpZiAodG9waWNzKSB7XG4gICAgICAgICAgdG9waWNzLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3NbdG9waWNdXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2IobnVsbCwgcGFja2V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICBkZWxldGUgdGhpcy5vdXRnb2luZ1ttaWRdXG4gICAgICBjYihudWxsKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHBhY2tldCB0eXBlJykpXG4gIH1cblxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLm91dGdvaW5nKS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmVtaXQoJ291dGdvaW5nRW1wdHknKVxuICB9XG59XG5cbi8qKlxuICogX2hhbmRsZVB1YnJlbFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUHVicmVsID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSB0eXBlb2YgY2FsbGJhY2sgIT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBub3BcbiAgdmFyIG1pZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgdmFyIGNvbXAgPSB7Y21kOiAncHViY29tcCcsIG1lc3NhZ2VJZDogbWlkfVxuXG4gIHRoYXQuaW5jb21pbmdTdG9yZS5nZXQocGFja2V0LCBmdW5jdGlvbiAoZXJyLCBwdWIpIHtcbiAgICBpZiAoIWVyciAmJiBwdWIuY21kICE9PSAncHVicmVsJykge1xuICAgICAgdGhhdC5lbWl0KCdtZXNzYWdlJywgcHViLnRvcGljLCBwdWIucGF5bG9hZCwgcHViKVxuICAgICAgdGhhdC5pbmNvbWluZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5oYW5kbGVNZXNzYWdlKHB1YiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9zZW5kUGFja2V0KGNvbXAsIGNhbGxiYWNrKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBfbmV4dElkXG4gKiBAcmV0dXJuIHVuc2lnbmVkIGludFxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fbmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAvLyBpZCBiZWNvbWVzIGN1cnJlbnQgc3RhdGUgb2YgdGhpcy5uZXh0SWQgYW5kIGluY3JlbWVudHMgYWZ0ZXJ3YXJkc1xuICB2YXIgaWQgPSB0aGlzLm5leHRJZCsrXG4gIC8vIEVuc3VyZSAxNiBiaXQgdW5zaWduZWQgaW50IChtYXggNjU1MzUsIG5leHRJZCBnb3Qgb25lIGhpZ2hlcilcbiAgaWYgKHRoaXMubmV4dElkID09PSA2NTUzNikge1xuICAgIHRoaXMubmV4dElkID0gMVxuICB9XG4gIHJldHVybiBpZFxufVxuXG4vKipcbiAqIGdldExhc3RNZXNzYWdlSWRcbiAqIEByZXR1cm4gdW5zaWduZWQgaW50XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLmdldExhc3RNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5uZXh0SWQgPT09IDEpID8gNjU1MzUgOiAodGhpcy5uZXh0SWQgLSAxKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1xdHRDbGllbnRcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgTXF0dENsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudCcpXG52YXIgU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZScpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBwcm90b2NvbHMgPSB7fVxuXG5pZiAocHJvY2Vzcy50aXRsZSAhPT0gJ2Jyb3dzZXInKSB7XG4gIHByb3RvY29scy5tcXR0ID0gcmVxdWlyZSgnLi90Y3AnKVxuICBwcm90b2NvbHMudGNwID0gcmVxdWlyZSgnLi90Y3AnKVxuICBwcm90b2NvbHMuc3NsID0gcmVxdWlyZSgnLi90bHMnKVxuICBwcm90b2NvbHMudGxzID0gcmVxdWlyZSgnLi90bHMnKVxuICBwcm90b2NvbHMubXF0dHMgPSByZXF1aXJlKCcuL3RscycpXG59IGVsc2Uge1xuICBwcm90b2NvbHMud3ggPSByZXF1aXJlKCcuL3d4JylcbiAgcHJvdG9jb2xzLnd4cyA9IHJlcXVpcmUoJy4vd3gnKVxufVxuXG5wcm90b2NvbHMud3MgPSByZXF1aXJlKCcuL3dzJylcbnByb3RvY29scy53c3MgPSByZXF1aXJlKCcuL3dzJylcblxuLyoqXG4gKiBQYXJzZSB0aGUgYXV0aCBhdHRyaWJ1dGUgYW5kIG1lcmdlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXV0aE9wdGlvbnMgKG9wdHMpIHtcbiAgdmFyIG1hdGNoZXNcbiAgaWYgKG9wdHMuYXV0aCkge1xuICAgIG1hdGNoZXMgPSBvcHRzLmF1dGgubWF0Y2goL14oLispOiguKykkLylcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgb3B0cy51c2VybmFtZSA9IG1hdGNoZXNbMV1cbiAgICAgIG9wdHMucGFzc3dvcmQgPSBtYXRjaGVzWzJdXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMudXNlcm5hbWUgPSBvcHRzLmF1dGhcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBjb25uZWN0IC0gY29ubmVjdCB0byBhbiBNUVRUIGJyb2tlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Jyb2tlclVybF0gLSB1cmwgb2YgdGhlIGJyb2tlciwgb3B0aW9uYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gc2VlIE1xdHRDbGllbnQjY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gY29ubmVjdCAoYnJva2VyVXJsLCBvcHRzKSB7XG4gIGlmICgodHlwZW9mIGJyb2tlclVybCA9PT0gJ29iamVjdCcpICYmICFvcHRzKSB7XG4gICAgb3B0cyA9IGJyb2tlclVybFxuICAgIGJyb2tlclVybCA9IG51bGxcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgaWYgKGJyb2tlclVybCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmwucGFyc2UoYnJva2VyVXJsLCB0cnVlKVxuICAgIGlmIChwYXJzZWQucG9ydCAhPSBudWxsKSB7XG4gICAgICBwYXJzZWQucG9ydCA9IE51bWJlcihwYXJzZWQucG9ydClcbiAgICB9XG5cbiAgICBvcHRzID0geHRlbmQocGFyc2VkLCBvcHRzKVxuXG4gICAgaWYgKG9wdHMucHJvdG9jb2wgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcm90b2NvbCcpXG4gICAgfVxuICAgIG9wdHMucHJvdG9jb2wgPSBvcHRzLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpXG4gIH1cblxuICAvLyBtZXJnZSBpbiB0aGUgYXV0aCBvcHRpb25zIGlmIHN1cHBsaWVkXG4gIHBhcnNlQXV0aE9wdGlvbnMob3B0cylcblxuICAvLyBzdXBwb3J0IGNsaWVudElkIHBhc3NlZCBpbiB0aGUgcXVlcnkgc3RyaW5nIG9mIHRoZSB1cmxcbiAgaWYgKG9wdHMucXVlcnkgJiYgdHlwZW9mIG9wdHMucXVlcnkuY2xpZW50SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cy5jbGllbnRJZCA9IG9wdHMucXVlcnkuY2xpZW50SWRcbiAgfVxuXG4gIGlmIChvcHRzLmNlcnQgJiYgb3B0cy5rZXkpIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbCkge1xuICAgICAgaWYgKFsnbXF0dHMnLCAnd3NzJywgJ3d4cyddLmluZGV4T2Yob3B0cy5wcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgIHN3aXRjaCAob3B0cy5wcm90b2NvbCkge1xuICAgICAgICAgIGNhc2UgJ21xdHQnOlxuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9ICdtcXR0cydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnd3MnOlxuICAgICAgICAgICAgb3B0cy5wcm90b2NvbCA9ICd3c3MnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3d4JzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3hzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGZvciBzZWN1cmUgY29ubmVjdGlvbjogXCInICsgb3B0cy5wcm90b2NvbCArICdcIiEnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvbid0IGtub3cgd2hhdCBwcm90b2NvbCBoZSB3YW50IHRvIHVzZSwgbXF0dHMgb3Igd3NzXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2VjdXJlIHByb3RvY29sIGtleScpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwcm90b2NvbHNbb3B0cy5wcm90b2NvbF0pIHtcbiAgICB2YXIgaXNTZWN1cmUgPSBbJ21xdHRzJywgJ3dzcyddLmluZGV4T2Yob3B0cy5wcm90b2NvbCkgIT09IC0xXG4gICAgb3B0cy5wcm90b2NvbCA9IFtcbiAgICAgICdtcXR0JyxcbiAgICAgICdtcXR0cycsXG4gICAgICAnd3MnLFxuICAgICAgJ3dzcycsXG4gICAgICAnd3gnLFxuICAgICAgJ3d4cydcbiAgICBdLmZpbHRlcihmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgaWYgKGlzU2VjdXJlICYmIGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAvLyBTa2lwIGluc2VjdXJlIHByb3RvY29scyB3aGVuIHJlcXVlc3RpbmcgYSBzZWN1cmUgb25lLlxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiAodHlwZW9mIHByb3RvY29sc1trZXldID09PSAnZnVuY3Rpb24nKVxuICAgIH0pWzBdXG4gIH1cblxuICBpZiAob3B0cy5jbGVhbiA9PT0gZmFsc2UgJiYgIW9wdHMuY2xpZW50SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2xpZW50SWQgZm9yIHVuY2xlYW4gY2xpZW50cycpXG4gIH1cblxuICBpZiAob3B0cy5wcm90b2NvbCkge1xuICAgIG9wdHMuZGVmYXVsdFByb3RvY29sID0gb3B0cy5wcm90b2NvbFxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlciAoY2xpZW50KSB7XG4gICAgaWYgKG9wdHMuc2VydmVycykge1xuICAgICAgaWYgKCFjbGllbnQuX3JlY29ubmVjdENvdW50IHx8IGNsaWVudC5fcmVjb25uZWN0Q291bnQgPT09IG9wdHMuc2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCA9IDBcbiAgICAgIH1cblxuICAgICAgb3B0cy5ob3N0ID0gb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLmhvc3RcbiAgICAgIG9wdHMucG9ydCA9IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wb3J0XG4gICAgICBvcHRzLnByb3RvY29sID0gKCFvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucHJvdG9jb2wgPyBvcHRzLmRlZmF1bHRQcm90b2NvbCA6IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5wcm90b2NvbClcbiAgICAgIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RcblxuICAgICAgY2xpZW50Ll9yZWNvbm5lY3RDb3VudCsrXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3RvY29sc1tvcHRzLnByb3RvY29sXShjbGllbnQsIG9wdHMpXG4gIH1cblxuICByZXR1cm4gbmV3IE1xdHRDbGllbnQod3JhcHBlciwgb3B0cylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdFxubW9kdWxlLmV4cG9ydHMuTXF0dENsaWVudCA9IE1xdHRDbGllbnRcbm1vZHVsZS5leHBvcnRzLlN0b3JlID0gU3RvcmVcbiIsIid1c2Ugc3RyaWN0J1xudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG5cbi8qXG4gIHZhcmlhYmxlcyBwb3J0IGFuZCBob3N0IGNhbiBiZSByZW1vdmVkIHNpbmNlXG4gIHlvdSBoYXZlIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBpbiBvcHRzIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAoY2xpZW50LCBvcHRzKSB7XG4gIHZhciBwb3J0LCBob3N0XG4gIG9wdHMucG9ydCA9IG9wdHMucG9ydCB8fCAxODgzXG4gIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdCB8fCAnbG9jYWxob3N0J1xuXG4gIHBvcnQgPSBvcHRzLnBvcnRcbiAgaG9zdCA9IG9wdHMuaG9zdG5hbWVcblxuICByZXR1cm4gbmV0LmNyZWF0ZUNvbm5lY3Rpb24ocG9ydCwgaG9zdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcbiIsIid1c2Ugc3RyaWN0J1xudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpXG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAobXF0dENsaWVudCwgb3B0cykge1xuICB2YXIgY29ubmVjdGlvblxuICBvcHRzLnBvcnQgPSBvcHRzLnBvcnQgfHwgODg4M1xuICBvcHRzLmhvc3QgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdCB8fCAnbG9jYWxob3N0J1xuXG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgIT09IGZhbHNlXG5cbiAgZGVsZXRlIG9wdHMucGF0aFxuXG4gIGNvbm5lY3Rpb24gPSB0bHMuY29ubmVjdChvcHRzKVxuICAvKiBlc2xpbnQgbm8tdXNlLWJlZm9yZS1kZWZpbmU6IFsyLCBcIm5vZnVuY1wiXSAqL1xuICBjb25uZWN0aW9uLm9uKCdzZWN1cmVDb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLnJlamVjdFVuYXV0aG9yaXplZCAmJiAhY29ubmVjdGlvbi5hdXRob3JpemVkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdUTFMgbm90IGF1dGhvcml6ZWQnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVUTFNlcnJvcnMpXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRMU2Vycm9ycyAoZXJyKSB7XG4gICAgLy8gSG93IGNhbiBJIGdldCB2ZXJpZnkgdGhpcyBlcnJvciBpcyBhIHRscyBlcnJvcj9cbiAgICBpZiAob3B0cy5yZWplY3RVbmF1dGhvcml6ZWQpIHtcbiAgICAgIG1xdHRDbGllbnQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuXG4gICAgLy8gY2xvc2UgdGhpcyBjb25uZWN0aW9uIHRvIG1hdGNoIHRoZSBiZWhhdmlvdXIgb2YgbmV0XG4gICAgLy8gb3RoZXJ3aXNlIGFsbCB3ZSBnZXQgaXMgYW4gZXJyb3IgZnJvbSB0aGUgY29ubmVjdGlvblxuICAgIC8vIGFuZCBjbG9zZSBldmVudCBkb2Vzbid0IGZpcmUuIFRoaXMgaXMgYSB3b3JrIGFyb3VuZFxuICAgIC8vIHRvIGVuYWJsZSB0aGUgcmVjb25uZWN0IGNvZGUgdG8gd29yayB0aGUgc2FtZSBhcyB3aXRoXG4gICAgLy8gbmV0LmNyZWF0ZUNvbm5lY3Rpb25cbiAgICBjb25uZWN0aW9uLmVuZCgpXG4gIH1cblxuICBjb25uZWN0aW9uLm9uKCdlcnJvcicsIGhhbmRsZVRMU2Vycm9ycylcbiAgcmV0dXJuIGNvbm5lY3Rpb25cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0LXN0cmVhbScpXG52YXIgdXJsTW9kdWxlID0gcmVxdWlyZSgndXJsJylcbnZhciBXU1NfT1BUSU9OUyA9IFtcbiAgJ3JlamVjdFVuYXV0aG9yaXplZCcsXG4gICdjYScsXG4gICdjZXJ0JyxcbiAgJ2tleScsXG4gICdwZngnLFxuICAncGFzc3BocmFzZSdcbl1cbnZhciBJU19CUk9XU0VSID0gcHJvY2Vzcy50aXRsZSA9PT0gJ2Jyb3dzZXInXG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHVybCA9IG9wdHMucHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyAnOicgKyBvcHRzLnBvcnQgKyBvcHRzLnBhdGhcbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXG4gIH1cbiAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gJ3dzcycpIHtcbiAgICAgIG9wdHMucG9ydCA9IDQ0M1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnBvcnQgPSA4MFxuICAgIH1cbiAgfVxuICBpZiAoIW9wdHMucGF0aCkge1xuICAgIG9wdHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKCFvcHRzLndzT3B0aW9ucykge1xuICAgIG9wdHMud3NPcHRpb25zID0ge31cbiAgfVxuICBpZiAoIUlTX0JST1dTRVIgJiYgb3B0cy5wcm90b2NvbCA9PT0gJ3dzcycpIHtcbiAgICAvLyBBZGQgY2VydC9rZXkvY2EgZXRjIG9wdGlvbnNcbiAgICBXU1NfT1BUSU9OUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBpZiAob3B0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAhb3B0cy53c09wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgb3B0cy53c09wdGlvbnNbcHJvcF0gPSBvcHRzW3Byb3BdXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXQgKGNsaWVudCwgb3B0cykge1xuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcbiAgdmFyIHVybCA9IGJ1aWxkVXJsKG9wdHMsIGNsaWVudClcbiAgcmV0dXJuIHdlYnNvY2tldCh1cmwsIFt3ZWJzb2NrZXRTdWJQcm90b2NvbF0sIG9wdHMud3NPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKGNsaWVudCwgb3B0cykge1xuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcbn1cblxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyQnJvd3NlciAoY2xpZW50LCBvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RcbiAgfVxuXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIC8vIFRocm93aW5nIGFuIGVycm9yIGluIGEgV2ViIFdvcmtlciBpZiBubyBgaG9zdG5hbWVgIGlzIGdpdmVuLCBiZWNhdXNlIHdlXG4gICAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGBob3N0bmFtZWAgYXV0b21hdGljYWxseS4gIElmIGNvbm5lY3RpbmcgdG9cbiAgICAvLyBsb2NhbGhvc3QsIHBsZWFzZSBzdXBwbHkgdGhlIGBob3N0bmFtZWAgYXMgYW4gYXJndW1lbnQuXG4gICAgaWYgKHR5cGVvZiAoZG9jdW1lbnQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS4nKVxuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gdXJsTW9kdWxlLnBhcnNlKGRvY3VtZW50LlVSTClcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2VkLmhvc3RuYW1lXG5cbiAgICBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgb3B0cy5wb3J0ID0gcGFyc2VkLnBvcnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVdlYlNvY2tldChjbGllbnQsIG9wdHMpXG59XG5cbmlmIChJU19CUk9XU0VSKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyQnJvd3NlclxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWlsZEJ1aWxkZXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiBnbG9iYWwgd3ggKi9cbnZhciBzb2NrZXRPcGVuID0gZmFsc2VcbnZhciBzb2NrZXRNc2dRdWV1ZSA9IFtdXG5cbmZ1bmN0aW9uIHNlbmRTb2NrZXRNZXNzYWdlIChtc2cpIHtcbiAgaWYgKHNvY2tldE9wZW4pIHtcbiAgICB3eC5zZW5kU29ja2V0TWVzc2FnZSh7XG4gICAgICBkYXRhOiBtc2cuYnVmZmVyIHx8IG1zZ1xuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgc29ja2V0TXNnUXVldWUucHVzaChtc2cpXG4gIH1cbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0ICh1cmwsIHByb3RvY29scykge1xuICB2YXIgd3MgPSB7XG4gICAgT1BFTjogMSxcbiAgICBDTE9TSU5HOiAyLFxuICAgIENMT1NFRDogMyxcbiAgICByZWFkeVN0YXRlOiBzb2NrZXRPcGVuID8gMSA6IDAsXG4gICAgc2VuZDogc2VuZFNvY2tldE1lc3NhZ2UsXG4gICAgY2xvc2U6IHd4LmNsb3NlU29ja2V0LFxuICAgIG9ub3BlbjogbnVsbCxcbiAgICBvbm1lc3NhZ2U6IG51bGwsXG4gICAgb25jbG9zZTogbnVsbCxcbiAgICBvbmVycm9yOiBudWxsXG4gIH1cblxuICB3eC5jb25uZWN0U29ja2V0KHtcbiAgICB1cmw6IHVybCxcbiAgICBwcm90b2NvbHM6IHByb3RvY29sc1xuICB9KVxuICB3eC5vblNvY2tldE9wZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHdzLnJlYWR5U3RhdGUgPSB3cy5PUEVOXG4gICAgc29ja2V0T3BlbiA9IHRydWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvY2tldE1zZ1F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZW5kU29ja2V0TWVzc2FnZShzb2NrZXRNc2dRdWV1ZVtpXSlcbiAgICB9XG4gICAgc29ja2V0TXNnUXVldWUgPSBbXVxuXG4gICAgd3Mub25vcGVuICYmIHdzLm9ub3Blbi5hcHBseSh3cywgYXJndW1lbnRzKVxuICB9KVxuICB3eC5vblNvY2tldE1lc3NhZ2UoZnVuY3Rpb24gKHJlcykge1xuICAgIHdzLm9ubWVzc2FnZSAmJiB3cy5vbm1lc3NhZ2UuYXBwbHkod3MsIGFyZ3VtZW50cylcbiAgfSlcbiAgd3gub25Tb2NrZXRDbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgd3Mub25jbG9zZSAmJiB3cy5vbmNsb3NlLmFwcGx5KHdzLCBhcmd1bWVudHMpXG4gICAgd3MucmVhZHlTdGF0ZSA9IHdzLkNMT1NFRFxuICAgIHNvY2tldE9wZW4gPSBmYWxzZVxuICB9KVxuICB3eC5vblNvY2tldEVycm9yKGZ1bmN0aW9uICgpIHtcbiAgICB3cy5vbmVycm9yICYmIHdzLm9uZXJyb3IuYXBwbHkod3MsIGFyZ3VtZW50cylcbiAgICB3cy5yZWFkeVN0YXRlID0gd3MuQ0xPU0VEXG4gICAgc29ja2V0T3BlbiA9IGZhbHNlXG4gIH0pXG5cbiAgcmV0dXJuIHdzXG59XG5cbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCd3ZWJzb2NrZXQtc3RyZWFtJylcblxuZnVuY3Rpb24gYnVpbGRVcmwgKG9wdHMsIGNsaWVudCkge1xuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnd3hzJyA/ICd3c3MnIDogJ3dzJ1xuICB2YXIgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyBvcHRzLnBhdGhcbiAgaWYgKG9wdHMucG9ydCAmJiBvcHRzLnBvcnQgIT09IDgwICYmIG9wdHMucG9ydCAhPT0gNDQzKSB7XG4gICAgdXJsID0gcHJvdG9jb2wgKyAnOi8vJyArIG9wdHMuaG9zdG5hbWUgKyAnOicgKyBvcHRzLnBvcnQgKyBvcHRzLnBhdGhcbiAgfVxuICBpZiAodHlwZW9mIChvcHRzLnRyYW5zZm9ybVdzVXJsKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVybCA9IG9wdHMudHJhbnNmb3JtV3NVcmwodXJsLCBvcHRzLCBjbGllbnQpXG4gIH1cbiAgcmV0dXJuIHVybFxufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0T3B0cyAob3B0cykge1xuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gJ2xvY2FsaG9zdCdcbiAgfVxuICBpZiAoIW9wdHMucGF0aCkge1xuICAgIG9wdHMucGF0aCA9ICcvJ1xuICB9XG5cbiAgaWYgKCFvcHRzLndzT3B0aW9ucykge1xuICAgIG9wdHMud3NPcHRpb25zID0ge31cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXQgKGNsaWVudCwgb3B0cykge1xuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcbiAgdmFyIHVybCA9IGJ1aWxkVXJsKG9wdHMsIGNsaWVudClcbiAgcmV0dXJuIHdlYnNvY2tldChXZWJTb2NrZXQodXJsLCBbd2Vic29ja2V0U3ViUHJvdG9jb2xdKSlcbn1cblxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcbiAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGhvc3QuIFNwZWNpZnkgaG9zdCBtYW51YWxseS4nKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVdlYlNvY2tldChjbGllbnQsIG9wdHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyXG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcbnZhciBzdHJlYW1zT3B0cyA9IHsgb2JqZWN0TW9kZTogdHJ1ZSB9XG52YXIgZGVmYXVsdFN0b3JlT3B0aW9ucyA9IHtcbiAgY2xlYW46IHRydWVcbn1cblxuLyoqXG4gKiBlczYtbWFwIGNhbiBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgZXZlbiBpZiBFUyB2ZXJzaW9uIGlzIG9sZGVyLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNEZXNjcmlwdGlvblxuICogSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgYSBNYXAgd2hpY2ggaXMgYSBtYXAgb2YgYW4gb2JqZWN0LCBlc3BlY2lhbGx5XG4gKiBhIGRpY3Rpb25hcnkgb2YgZGljdGlvbmFyaWVzLCB3aWxsIG9ubHkgbWFwIHRvIHRoZSBvYmplY3QncyBpbnNlcnRpb25cbiAqIG9yZGVyLiBJbiBFUzIwMTUgdGhpcyBpcyBvcmRlcmVkIGZvciBvYmplY3RzIGJ1dCBmb3Igb2xkZXIgdmVyc2lvbnMgb2ZcbiAqIEVTLCB0aGlzIG1heSBiZSByYW5kb20gYW5kIG5vdCBvcmRlcmVkLlxuICpcbiAqL1xudmFyIE1hcCA9IHJlcXVpcmUoJ2VzNi1tYXAnKVxuXG4vKipcbiAqIEluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWVzc2FnZSBzdG9yZVxuICogVGhpcyBjYW4gYWN0dWFsbHkgYmUgc2F2ZWQgaW50byBmaWxlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gc3RvcmUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yZShvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8vIERlZmF1bHRzXG4gIHRoaXMub3B0aW9ucyA9IHh0ZW5kKGRlZmF1bHRTdG9yZU9wdGlvbnMsIG9wdGlvbnMpXG5cbiAgdGhpcy5faW5mbGlnaHRzID0gbmV3IE1hcCgpXG59XG5cbi8qKlxuICogQWRkcyBhIHBhY2tldCB0byB0aGUgc3RvcmUsIGEgcGFja2V0IGlzXG4gKiBhbnl0aGluZyB0aGF0IGhhcyBhIG1lc3NhZ2VJZCBwcm9wZXJ0eS5cbiAqXG4gKi9cblN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICB0aGlzLl9pbmZsaWdodHMuc2V0KHBhY2tldC5tZXNzYWdlSWQsIHBhY2tldClcblxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJlYW0gd2l0aCBhbGwgdGhlIHBhY2tldHMgaW4gdGhlIHN0b3JlXG4gKlxuICovXG5TdG9yZS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlKHN0cmVhbXNPcHRzKVxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgdmFyIHZhbHVlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIHRoaXMuX2luZmxpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpXG4gIH0pXG5cbiAgc3RyZWFtLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGVzdHJveWVkICYmIGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnB1c2godmFsdWVzW2krK10pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG4vKipcbiAqIGRlbGV0ZXMgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICB0aGlzLl9pbmZsaWdodHMuZGVsZXRlKHBhY2tldC5tZXNzYWdlSWQpXG4gICAgY2IobnVsbCwgcGFja2V0KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdtaXNzaW5nIHBhY2tldCcpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBnZXQgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICBjYihudWxsLCBwYWNrZXQpXG4gIH0gZWxzZSBpZiAoY2IpIHtcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBzdG9yZVxuICovXG5TdG9yZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgIHRoaXMuX2luZmxpZ2h0cyA9IG51bGxcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVmFsaWRhdGUgYSB0b3BpYyB0byBzZWUgaWYgaXQncyB2YWxpZCBvciBub3QuXG4gKiBBIHRvcGljIGlzIHZhbGlkIGlmIGl0IGZvbGxvdyBiZWxvdyBydWxlczpcbiAqIC0gUnVsZSAjMTogSWYgYW55IHBhcnQgb2YgdGhlIHRvcGljIGlzIG5vdCBgK2Agb3IgYCNgLCB0aGVuIGl0IG11c3Qgbm90IGNvbnRhaW4gYCtgIGFuZCAnIydcbiAqIC0gUnVsZSAjMjogUGFydCBgI2AgbXVzdCBiZSBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIG1haWxib3hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSBBIHRvcGljXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHRvcGljIGlzIHZhbGlkLCByZXR1cm5zIHRydWUuIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUb3BpYyAodG9waWMpIHtcbiAgdmFyIHBhcnRzID0gdG9waWMuc3BsaXQoJy8nKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydHNbaV0gPT09ICcrJykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAocGFydHNbaV0gPT09ICcjJykge1xuICAgICAgLy8gZm9yIFJ1bGUgIzJcbiAgICAgIHJldHVybiBpID09PSBwYXJ0cy5sZW5ndGggLSAxXG4gICAgfVxuXG4gICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJysnKSAhPT0gLTEgfHwgcGFydHNbaV0uaW5kZXhPZignIycpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbiBhcnJheSBvZiB0b3BpY3MgdG8gc2VlIGlmIGFueSBvZiB0aGVtIGlzIHZhbGlkIG9yIG5vdFxuICAqIEBwYXJhbSB7QXJyYXl9IHRvcGljcyAtIEFycmF5IG9mIHRvcGljc1xuICogQHJldHVybnMge1N0cmluZ30gSWYgdGhlIHRvcGljcyBpcyB2YWxpZCwgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHJldHVybnMgdGhlIGludmFsaWQgb25lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9waWNzICh0b3BpY3MpIHtcbiAgaWYgKHRvcGljcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ2VtcHR5X3RvcGljX2xpc3QnXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3BpY3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXZhbGlkYXRlVG9waWModG9waWNzW2ldKSkge1xuICAgICAgcmV0dXJuIHRvcGljc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdGVUb3BpY3M6IHZhbGlkYXRlVG9waWNzXG59XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5Jylcbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5KG9uY2UpXG5tb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdClcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlU3RyaWN0Jywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpIHJldHVybiBmLnZhbHVlXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuXG5mdW5jdGlvbiBvbmNlU3RyaWN0IChmbikge1xuICB2YXIgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZi5jYWxsZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZi5vbmNlRXJyb3IpXG4gICAgZi5jYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgdmFyIG5hbWUgPSBmbi5uYW1lIHx8ICdGdW5jdGlvbiB3cmFwcGVkIHdpdGggYG9uY2VgJ1xuICBmLm9uY2VFcnJvciA9IG5hbWUgKyBcIiBzaG91bGRuJ3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXCJcbiAgZi5jYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZlxufVxuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcblxuZXhwb3J0cy5ob21lZGlyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJy8nXG59O1xuIiwiLy8gJ3BhdGgnIG1vZHVsZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEgKG9ubHkgdGhlIHBvc2l4IHBhcnQpXG4vLyB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkocGF0aCkpO1xuICB9XG59XG5cbi8vIFJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCB3aXRoIGRpcmVjdG9yeSBuYW1lc1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgYWxsb3dBYm92ZVJvb3QpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICB2YXIgbGFzdFNsYXNoID0gLTE7XG4gIHZhciBkb3RzID0gMDtcbiAgdmFyIGNvZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKVxuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBlbHNlIGlmIChjb2RlID09PSA0NyAvKi8qLylcbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGNvZGUgPSA0NyAvKi8qLztcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHtcbiAgICAgICAgLy8gTk9PUFxuICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgLyouKi8gfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0NiAvKi4qLykge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXMgKz0gJy8uLic7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzID0gJy4uJztcbiAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICByZXMgKz0gJy8nICsgcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAvKi4qLyAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIF9mb3JtYXQoc2VwLCBwYXRoT2JqZWN0KSB7XG4gIHZhciBkaXIgPSBwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LnJvb3Q7XG4gIHZhciBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8IChwYXRoT2JqZWN0Lm5hbWUgfHwgJycpICsgKHBhdGhPYmplY3QuZXh0IHx8ICcnKTtcbiAgaWYgKCFkaXIpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoZGlyID09PSBwYXRoT2JqZWN0LnJvb3QpIHtcbiAgICByZXR1cm4gZGlyICsgYmFzZTtcbiAgfVxuICByZXR1cm4gZGlyICsgc2VwICsgYmFzZTtcbn1cblxudmFyIHBvc2l4ID0ge1xuICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnO1xuICAgIHZhciByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgdmFyIGN3ZDtcblxuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChpID49IDApXG4gICAgICAgIHBhdGggPSBhcmd1bWVudHNbaV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGN3ZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgIHBhdGggPSBjd2Q7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSk7XG5cbiAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnLic7XG4gICAgfVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuXG4gICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIHZhciB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGguY2hhckNvZGVBdChwYXRoLmxlbmd0aCAtIDEpID09PSA0NyAvKi8qLztcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCAhaXNBYnNvbHV0ZSk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgJiYgIWlzQWJzb2x1dGUpIHBhdGggPSAnLic7XG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMCAmJiB0cmFpbGluZ1NlcGFyYXRvcikgcGF0aCArPSAnLyc7XG5cbiAgICBpZiAoaXNBYnNvbHV0ZSkgcmV0dXJuICcvJyArIHBhdGg7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gIH0sXG5cbiAgam9pbjogZnVuY3Rpb24gam9pbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnLic7XG4gICAgdmFyIGpvaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGFzc2VydFBhdGgoYXJnKTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgam9pbmVkICs9ICcvJyArIGFyZztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuICcuJztcbiAgICByZXR1cm4gcG9zaXgubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG5cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgYXNzZXJ0UGF0aChmcm9tKTtcbiAgICBhc3NlcnRQYXRoKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgZnJvbSA9IHBvc2l4LnJlc29sdmUoZnJvbSk7XG4gICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciBmcm9tU3RhcnQgPSAxO1xuICAgIGZvciAoOyBmcm9tU3RhcnQgPCBmcm9tLmxlbmd0aDsgKytmcm9tU3RhcnQpIHtcbiAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgIHZhciBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgdG9TdGFydCA9IDE7XG4gICAgZm9yICg7IHRvU3RhcnQgPCB0by5sZW5ndGg7ICsrdG9TdGFydCkge1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHRvRW5kID0gdG8ubGVuZ3RoO1xuICAgIHZhciB0b0xlbiA9IHRvRW5kIC0gdG9TdGFydDtcblxuICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcbiAgICB2YXIgbGVuZ3RoID0gZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuO1xuICAgIHZhciBsYXN0Q29tbW9uU2VwID0gLTE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheidcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSByb290XG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhci9iYXonOyB0bz0nL2Zvby9iYXInXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvbyc7IHRvPScvJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xuICAgICAgdmFyIHRvQ29kZSA9IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpO1xuICAgICAgaWYgKGZyb21Db2RlICE9PSB0b0NvZGUpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZWxzZSBpZiAoZnJvbUNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2BcbiAgICAvLyBhbmQgYGZyb21gXG4gICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgIG91dCArPSAnLi4nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb3V0ICs9ICcvLi4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXG4gICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzXG4gICAgaWYgKG91dC5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG91dCArIHRvLnNsaWNlKHRvU3RhcnQgKyBsYXN0Q29tbW9uU2VwKTtcbiAgICBlbHNlIHtcbiAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSA0NyAvKi8qLylcbiAgICAgICAgKyt0b1N0YXJ0O1xuICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQpO1xuICAgIH1cbiAgfSxcblxuICBfbWFrZUxvbmc6IGZ1bmN0aW9uIF9tYWtlTG9uZyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgZGlybmFtZTogZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkgcmV0dXJuICcvLyc7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbiAgfSxcblxuICBiYXNlbmFtZTogZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0KSB7XG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBleHQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKGV4dC5sZW5ndGggPT09IHBhdGgubGVuZ3RoICYmIGV4dCA9PT0gcGF0aCkgcmV0dXJuICcnO1xuICAgICAgdmFyIGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgdmFyIGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgZXh0SWR4ID0gLTE7XG4gICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO2Vsc2UgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IHBhdGgubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgZXh0bmFtZTogZnVuY3Rpb24gZXh0bmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gIH0sXG5cbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBwYXRoT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIF9mb3JtYXQoJy8nLCBwYXRoT2JqZWN0KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gcmV0O1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBpc0Fic29sdXRlID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHN0YXJ0O1xuICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICByZXQucm9vdCA9ICcvJztcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuXG4gICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkgc3RhcnREb3QgPSBpO2Vsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBlbmQpO2Vsc2UgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKDEsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRQYXJ0ID4gMCkgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7ZWxzZSBpZiAoaXNBYnNvbHV0ZSkgcmV0LmRpciA9ICcvJztcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICB3aW4zMjogbnVsbCxcbiAgcG9zaXg6IG51bGxcbn07XG5cbnBvc2l4LnBvc2l4ID0gcG9zaXg7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXg7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIFJlSW50ZXJ2YWwgKGNhbGxiYWNrLCBpbnRlcnZhbCwgYXJncykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5fYXJncyA9IGFyZ3M7XG5cbiAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjYWxsYmFjaywgaW50ZXJ2YWwsIHRoaXMuX2FyZ3MpO1xuXG4gIHRoaXMucmVzY2hlZHVsZSA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuICAgIC8vIGlmIG5vIGludGVydmFsIGVudGVyZWQsIHVzZSB0aGUgaW50ZXJ2YWwgcGFzc2VkIGluIG9uIGNyZWF0aW9uXG4gICAgaWYgKCFpbnRlcnZhbClcbiAgICAgIGludGVydmFsID0gc2VsZi5faW50ZXJ2YWw7XG5cbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpXG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHNldEludGVydmFsKHNlbGYuX2NhbGxiYWNrLCBpbnRlcnZhbCwgc2VsZi5fYXJncyk7XG4gIH07XG5cbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgICAgc2VsZi5faW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuICBcbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgfVxuICAgIHNlbGYuX2NhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgIHNlbGYuX2ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIHNlbGYuX2FyZ3MgPSB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlSW50ZXJ2YWwgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIG5lZWRlZCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlcnZhbCBuZWVkZWQnKTtcblxuICB2YXIgYXJncztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZUludGVydmFsKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZUludGVydmFsO1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9yZXNwb25zZScpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQ2xpZW50UmVxdWVzdCA9IENsaWVudFJlcXVlc3Rcbmh0dHAuSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5nbG9iYWxBZ2VudCA9IG5ldyBodHRwLkFnZW50KClcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZVN0cmVhbSlcblxuZXhwb3J0cy53cml0YWJsZVN0cmVhbSA9IGlzRnVuY3Rpb24oZ2xvYmFsLldyaXRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLmFib3J0Q29udHJvbGxlciA9IGlzRnVuY3Rpb24oZ2xvYmFsLkFib3J0Q29udHJvbGxlcilcblxuLy8gVGhlIHhociByZXF1ZXN0IHRvIGV4YW1wbGUuY29tIG1heSB2aW9sYXRlIHNvbWUgcmVzdHJpY3RpdmUgQ1NQIGNvbmZpZ3VyYXRpb25zLFxuLy8gc28gaWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBgZmV0Y2hgLCBhdm9pZCBjYWxsaW5nIGdldFhIUigpXG4vLyBhbmQgYXNzdW1lIHN1cHBvcnQgZm9yIGNlcnRhaW4gZmVhdHVyZXMgYmVsb3cuXG52YXIgeGhyXG5mdW5jdGlvbiBnZXRYSFIgKCkge1xuXHQvLyBDYWNoZSB0aGUgeGhyIHZhbHVlXG5cdGlmICh4aHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHhoclxuXG5cdGlmIChnbG9iYWwuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHR4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHQvLyBJZiBYRG9tYWluUmVxdWVzdCBpcyBhdmFpbGFibGUgKGllIG9ubHksIHdoZXJlIHhociBtaWdodCBub3Qgd29ya1xuXHRcdC8vIGNyb3NzIGRvbWFpbiksIHVzZSB0aGUgcGFnZSBsb2NhdGlvbi4gT3RoZXJ3aXNlIHVzZSBleGFtcGxlLmNvbVxuXHRcdC8vIE5vdGU6IHRoaXMgZG9lc24ndCBhY3R1YWxseSBtYWtlIGFuIGh0dHAgcmVxdWVzdC5cblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5YRG9tYWluUmVxdWVzdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHhociA9IG51bGxcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VydmljZSB3b3JrZXJzIGRvbid0IGhhdmUgWEhSXG5cdFx0eGhyID0gbnVsbFxuXHR9XG5cdHJldHVybiB4aHJcbn1cblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR2YXIgeGhyID0gZ2V0WEhSKClcblx0aWYgKCF4aHIpIHJldHVybiBmYWxzZVxuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIElmIGZldGNoIGlzIHN1cHBvcnRlZCwgdGhlbiBhcnJheWJ1ZmZlciB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gY2hlY2tUeXBlU3VwcG9ydCgpLCBzaW5jZSB0aGF0IGNhbGxzIGdldFhIUigpLlxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGV4cG9ydHMuZmV0Y2ggfHwgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gb3ZlcnJpZGVNaW1lVHlwZSB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gZ2V0WEhSKCkuXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBleHBvcnRzLmZldGNoIHx8IChnZXRYSFIoKSA/IGlzRnVuY3Rpb24oZ2V0WEhSKCkub3ZlcnJpZGVNaW1lVHlwZSkgOiBmYWxzZSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRzZWxmLl9vbkZpbmlzaCgpXG5cdH0pXG59XG5cbmluaGVyaXRzKENsaWVudFJlcXVlc3QsIHN0cmVhbS5Xcml0YWJsZSlcblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHR2YXIgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cdC8vIFRoaXMgY2hlY2sgaXMgbm90IG5lY2Vzc2FyeSwgYnV0IGl0IHByZXZlbnRzIHdhcm5pbmdzIGZyb20gYnJvd3NlcnMgYWJvdXQgc2V0dGluZyB1bnNhZmVcblx0Ly8gaGVhZGVycy4gVG8gYmUgaG9uZXN0IEknbSBub3QgZW50aXJlbHkgc3VyZSBoaWRpbmcgdGhlc2Ugd2FybmluZ3MgaXMgYSBnb29kIHRoaW5nLCBidXRcblx0Ly8gaHR0cC1icm93c2VyaWZ5IGRpZCBpdCwgc28gSSB3aWxsIHRvby5cblx0aWYgKHVuc2FmZUhlYWRlcnMuaW5kZXhPZihsb3dlck5hbWUpICE9PSAtMSlcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9oZWFkZXJzW2xvd2VyTmFtZV0gPSB7XG5cdFx0bmFtZTogbmFtZSxcblx0XHR2YWx1ZTogdmFsdWVcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgaGVhZGVyID0gdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG5cdGlmIChoZWFkZXIpXG5cdFx0cmV0dXJuIGhlYWRlci52YWx1ZVxuXHRyZXR1cm4gbnVsbFxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0ZGVsZXRlIHNlbGYuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cdHZhciBvcHRzID0gc2VsZi5fb3B0c1xuXG5cdGlmICgndGltZW91dCcgaW4gb3B0cyAmJiBvcHRzLnRpbWVvdXQgIT09IDApIHtcblx0XHRzZWxmLnNldFRpbWVvdXQob3B0cy50aW1lb3V0KVxuXHR9XG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCbG9iKHNlbGYuX2JvZHksIHtcbiAgICAgICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cdC8vIGNyZWF0ZSBmbGF0dGVuZWQgbGlzdCBvZiBoZWFkZXJzXG5cdHZhciBoZWFkZXJzTGlzdCA9IFtdXG5cdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKGtleU5hbWUpIHtcblx0XHR2YXIgbmFtZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0ubmFtZVxuXHRcdHZhciB2YWx1ZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0udmFsdWVcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdl0pXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2YWx1ZV0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIHNpZ25hbCA9IG51bGxcblx0XHRpZiAoY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpIHtcblx0XHRcdHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cdFx0XHRzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuXHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIgPSBjb250cm9sbGVyXG5cblx0XHRcdGlmICgncmVxdWVzdFRpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy5yZXF1ZXN0VGltZW91dCAhPT0gMCkge1xuXHRcdFx0XHRzZWxmLl9mZXRjaFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0XHRcdGlmIChzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlcilcblx0XHRcdFx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblx0XHRcdFx0fSwgb3B0cy5yZXF1ZXN0VGltZW91dClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzTGlzdCxcblx0XHRcdGJvZHk6IGJvZHkgfHwgdW5kZWZpbmVkLFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHNpZ25hbDogc2lnbmFsXG5cdFx0fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXHRcdFx0c2VsZi5fcmVzZXRUaW1lcnMoZmFsc2UpXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9yZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzKSB7XG5cdFx0XHR4aHIudGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXRcblx0XHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlYWRlcnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuX3Jlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcyhzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlLCBzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxuXHRzZWxmLl9yZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcblx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHR9KVxuXG5cdHNlbGYuZW1pdCgncmVzcG9uc2UnLCBzZWxmLl9yZXNwb25zZSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0c2VsZi5fYm9keS5wdXNoKGNodW5rKVxuXHRjYigpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9yZXNldFRpbWVycyA9IGZ1bmN0aW9uIChkb25lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fc29ja2V0VGltZXIpXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdGlmIChkb25lKSB7XG5cdFx0Z2xvYmFsLmNsZWFyVGltZW91dChzZWxmLl9mZXRjaFRpbWVyKVxuXHRcdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdH0gZWxzZSBpZiAoc2VsZi5fc29ja2V0VGltZW91dCkge1xuXHRcdHNlbGYuX3NvY2tldFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCd0aW1lb3V0Jylcblx0XHR9LCBzZWxmLl9zb2NrZXRUaW1lb3V0KVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX2Rlc3Ryb3llZCA9IHRydWVcblx0c2VsZi5fcmVzZXRUaW1lcnModHJ1ZSlcblx0aWYgKHNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX3Jlc3BvbnNlLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl94aHIpXG5cdFx0c2VsZi5feGhyLmFib3J0KClcblx0ZWxzZSBpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuXG5cdGlmIChlcnIpXG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCwgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKGNiKVxuXHRcdHNlbGYub25jZSgndGltZW91dCcsIGNiKVxuXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSB0aW1lb3V0XG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRTb2NrZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtc2V0cmVxdWVzdGhlYWRlciUyOCUyOS1tZXRob2RcbnZhciB1bnNhZmVIZWFkZXJzID0gW1xuXHQnYWNjZXB0LWNoYXJzZXQnLFxuXHQnYWNjZXB0LWVuY29kaW5nJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsXG5cdCdjb25uZWN0aW9uJyxcblx0J2NvbnRlbnQtbGVuZ3RoJyxcblx0J2Nvb2tpZScsXG5cdCdjb29raWUyJyxcblx0J2RhdGUnLFxuXHQnZG50Jyxcblx0J2V4cGVjdCcsXG5cdCdob3N0Jyxcblx0J2tlZXAtYWxpdmUnLFxuXHQnb3JpZ2luJyxcblx0J3JlZmVyZXInLFxuXHQndGUnLFxuXHQndHJhaWxlcicsXG5cdCd0cmFuc2Zlci1lbmNvZGluZycsXG5cdCd1cGdyYWRlJyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlLCByZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHRcblx0XHRyZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlciwga2V5KXtcblx0XHRcdHNlbGYuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJcblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGtleSwgaGVhZGVyKVxuXHRcdH0pXG5cblx0XHRpZiAoY2FwYWJpbGl0eS53cml0YWJsZVN0cmVhbSkge1xuXHRcdFx0dmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKGZhbHNlKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdCgpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoc2VsZi5wdXNoKEJ1ZmZlci5mcm9tKGNodW5rKSkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWxmLl9yZXN1bWVGZXRjaCA9IHJlc29sdmVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0fSxcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzcG9uc2UuYm9keS5waXBlVG8od3JpdGFibGUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGNhdGNoIChlKSB7fSAvLyBwaXBlVG8gbWV0aG9kIGlzbid0IGRlZmluZWQuIENhbid0IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGZlYXR1cmUgdGVzdCB0aGlzXG5cdFx0fVxuXHRcdC8vIGZhbGxiYWNrIGZvciB3aGVuIHdyaXRhYmxlU3RyZWFtIG9yIHBpcGVUbyBhcmVuJ3QgYXZhaWxhYmxlXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdHJlc2V0VGltZXJzKHJlc3VsdC5kb25lKVxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20ocmVzdWx0LnZhbHVlKSlcblx0XHRcdFx0cmVhZCgpXG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRyZWFkKClcblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgcmVzb2x2ZSA9IHNlbGYuX3Jlc3VtZUZldGNoXG5cdGlmIChyZXNvbHZlKSB7XG5cdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSBudWxsXG5cdFx0cmVzb2x2ZSgpXG5cdH1cbn1cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uIChyZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgeGhyID0gc2VsZi5feGhyXG5cblx0dmFyIHJlc3BvbnNlID0gbnVsbFxuXHRzd2l0Y2ggKHNlbGYuX21vZGUpIHtcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSB8fCAheGhyLnJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQuc2xpY2Uoc2VsZi5fcG9zKSkpKVxuXHRcdFx0XHRcdHNlbGYuX3BvcyA9IHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdH1cblx0XHRcdC8vIHJlYWRlci5vbmVycm9yID0gPz8/IC8vIFRPRE86IHRoaXNcblx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihyZXNwb25zZSlcblx0XHRcdGJyZWFrXG5cdH1cblxuXHQvLyBUaGUgbXMtc3RyZWFtIGNhc2UgaGFuZGxlcyBlbmQgc2VwYXJhdGVseSBpbiByZWFkZXIub25sb2FkKClcblx0aWYgKHNlbGYuX3hoci5yZWFkeVN0YXRlID09PSByU3RhdGVzLkRPTkUgJiYgc2VsZi5fbW9kZSAhPT0gJ21zLXN0cmVhbScpIHtcblx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5cbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcblxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxuXG5cbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNoaWZ0XG5cbmZ1bmN0aW9uIHNoaWZ0IChzdHJlYW0pIHtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmICghcnMpIHJldHVybiBudWxsXG4gIHJldHVybiAocnMub2JqZWN0TW9kZSB8fCB0eXBlb2Ygc3RyZWFtLl9kdXBsZXhTdGF0ZSA9PT0gJ251bWJlcicpID8gc3RyZWFtLnJlYWQoKSA6IHN0cmVhbS5yZWFkKGdldFN0YXRlTGVuZ3RoKHJzKSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVMZW5ndGggKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgLy8gU2luY2Ugbm9kZSA2LjMuMCBzdGF0ZS5idWZmZXIgaXMgYSBCdWZmZXJMaXN0IG5vdCBhbiBhcnJheVxuICAgIGlmIChzdGF0ZS5idWZmZXIuaGVhZCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGhcbn1cbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKFwiLi4vcHJvdG90eXBlL2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwibGVuZ3RoXCIpKSByZXR1cm4gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUuY2FsbCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZS5hcHBseSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuICFpc1Byb3RvdHlwZSh2YWx1ZSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlICAgICAgID0gcmVxdWlyZShcIi4uL3ZhbHVlL2lzXCIpXG4gICwgaXNPYmplY3QgICAgICA9IHJlcXVpcmUoXCIuLi9vYmplY3QvaXNcIilcbiAgLCBzdHJpbmdDb2VyY2UgID0gcmVxdWlyZShcIi4uL3N0cmluZy9jb2VyY2VcIilcbiAgLCB0b1Nob3J0U3RyaW5nID0gcmVxdWlyZShcIi4vdG8tc2hvcnQtc3RyaW5nXCIpO1xuXG52YXIgcmVzb2x2ZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgdmFsdWUpIHtcblx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZShcIiV2XCIsIHRvU2hvcnRTdHJpbmcodmFsdWUpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0TWVzc2FnZSwgaW5wdXRPcHRpb25zKSB7XG5cdGlmICghaXNPYmplY3QoaW5wdXRPcHRpb25zKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZXNvbHZlTWVzc2FnZShkZWZhdWx0TWVzc2FnZSwgdmFsdWUpKTtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkge1xuXHRcdGlmIChcImRlZmF1bHRcIiBpbiBpbnB1dE9wdGlvbnMpIHJldHVybiBpbnB1dE9wdGlvbnNbXCJkZWZhdWx0XCJdO1xuXHRcdGlmIChpbnB1dE9wdGlvbnMuaXNPcHRpb25hbCkgcmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGVycm9yTWVzc2FnZSA9IHN0cmluZ0NvZXJjZShpbnB1dE9wdGlvbnMuZXJyb3JNZXNzYWdlKTtcblx0aWYgKCFpc1ZhbHVlKGVycm9yTWVzc2FnZSkpIGVycm9yTWVzc2FnZSA9IGRlZmF1bHRNZXNzYWdlO1xuXHR0aHJvdyBuZXcgVHlwZUVycm9yKHJlc29sdmVNZXNzYWdlKGVycm9yTWVzc2FnZSwgdmFsdWUpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR0cnkgeyByZXR1cm4gU3RyaW5nKHZhbHVlKTsgfVxuXHRcdGNhdGNoIChlcnJvcjIpIHsgcmV0dXJuIG51bGw7IH1cblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZShcIi4vc2FmZS10by1zdHJpbmdcIik7XG5cbnZhciByZU5ld0xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nID0gc2FmZVRvU3RyaW5nKHZhbHVlKTtcblx0aWYgKHN0cmluZyA9PT0gbnVsbCkgcmV0dXJuIFwiPE5vbi1jb2VyY2libGUgdG8gc3RyaW5nIHZhbHVlPlwiO1xuXHQvLyBUcmltIGlmIHRvbyBsb25nXG5cdGlmIChzdHJpbmcubGVuZ3RoID4gMTAwKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgOTkpICsgXCLigKZcIjtcblx0Ly8gUmVwbGFjZSBldmVudHVhbCBuZXcgbGluZXNcblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVOZXdMaW5lLCBmdW5jdGlvbiAoY2hhcikge1xuXHRcdHN3aXRjaCAoY2hhcikge1xuXHRcdFx0Y2FzZSBcIlxcblwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcblwiO1xuXHRcdFx0Y2FzZSBcIlxcclwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcclwiO1xuXHRcdFx0Y2FzZSBcIlxcdTIwMjhcIjpcblx0XHRcdFx0cmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cdFx0XHRjYXNlIFwiXFx1MjAyOVwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcdTIwMjlcIjtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlclwiKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gc3RyaW5nO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi92YWx1ZS9pc1wiKTtcblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgcG9zc2libGVUeXBlcyA9IHsgXCJvYmplY3RcIjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBcInVuZGVmaW5lZFwiOiB0cnVlIC8qIGRvY3VtZW50LmFsbCAqLyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHBvc3NpYmxlVHlwZXMsIHR5cGVvZiB2YWx1ZSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZXNvbHZlRXhjZXB0aW9uID0gcmVxdWlyZShcIi4uL2xpYi9yZXNvbHZlLWV4Y2VwdGlvblwiKVxuICAsIGlzICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdGlmIChpcyh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHJlc29sdmVFeGNlcHRpb24odmFsdWUsIFwiJXYgaXMgbm90IGEgcGxhaW4gZnVuY3Rpb25cIiwgYXJndW1lbnRzWzFdKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiLi4vZnVuY3Rpb24vaXNcIik7XG5cbnZhciBjbGFzc1JlID0gL15cXHMqY2xhc3NbXFxzey99XS8sIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBmYWxzZTtcblx0aWYgKGNsYXNzUmUudGVzdChmdW5jdGlvblRvU3RyaW5nLmNhbGwodmFsdWUpKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZShcIi4uL29iamVjdC9pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc09iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcblx0dHJ5IHtcblx0XHRpZiAoIXZhbHVlLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWU7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlICA9IHJlcXVpcmUoXCIuLi92YWx1ZS9pc1wiKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZShcIi4uL29iamVjdC9pc1wiKTtcblxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIG51bGw7XG5cdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0XHQvLyBSZWplY3QgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBjb2VyY2lvblxuXHRcdHZhciB2YWx1ZVRvU3RyaW5nID0gdmFsdWUudG9TdHJpbmc7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZVRvU3RyaW5nICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuXHRcdGlmICh2YWx1ZVRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZykgcmV0dXJuIG51bGw7XG5cdFx0Ly8gTm90ZTogSXQgY2FuIGJlIG9iamVjdCBjb21pbmcgZnJvbSBvdGhlciByZWFsbSwgc3RpbGwgYXMgdGhlcmUncyBubyBFUzMgYW5kIENTUCBjb21wbGlhbnRcblx0XHQvLyB3YXkgdG8gcmVzb2x2ZSBpdHMgcmVhbG0ncyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGl0J3MgbGVmdCBhcyBub3QgYWRkcmVzc2VkIGVkZ2UgY2FzZVxuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIFwiXCIgKyB2YWx1ZTsgLy8gRW5zdXJlIGltcGxpY2l0IGNvZXJjaW9uXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHJlc29sdmVFeGNlcHRpb24gPSByZXF1aXJlKFwiLi4vbGliL3Jlc29sdmUtZXhjZXB0aW9uXCIpXG4gICwgaXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0aWYgKGlzKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gcmVzb2x2ZUV4Y2VwdGlvbih2YWx1ZSwgXCJDYW5ub3QgdXNlICV2XCIsIGFyZ3VtZW50c1sxXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTMyBzYWZlXG52YXIgX3VuZGVmaW5lZCA9IHZvaWQgMDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBfdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciBXUyA9IHJlcXVpcmUoJ3dzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFN0cmVhbVxuXG5mdW5jdGlvbiBidWlsZFByb3h5IChvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgIG9iamVjdE1vZGU6IG9wdGlvbnMub2JqZWN0TW9kZVxuICB9KVxuXG4gIHByb3h5Ll93cml0ZSA9IHNvY2tldFdyaXRlXG4gIHByb3h5Ll9mbHVzaCA9IHNvY2tldEVuZFxuXG4gIHJldHVybiBwcm94eVxufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRTdHJlYW0odGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgdmFyIHN0cmVhbSwgc29ja2V0XG5cbiAgdmFyIGlzQnJvd3NlciA9IHByb2Nlc3MudGl0bGUgPT09ICdicm93c2VyJ1xuICB2YXIgaXNOYXRpdmUgPSAhIWdsb2JhbC5XZWJTb2NrZXRcbiAgdmFyIHNvY2tldFdyaXRlID0gaXNCcm93c2VyID8gc29ja2V0V3JpdGVCcm93c2VyIDogc29ja2V0V3JpdGVOb2RlXG5cbiAgaWYgKHByb3RvY29scyAmJiAhQXJyYXkuaXNBcnJheShwcm90b2NvbHMpICYmICdvYmplY3QnID09PSB0eXBlb2YgcHJvdG9jb2xzKSB7XG4gICAgLy8gYWNjZXB0IHRoZSBcIm9wdGlvbnNcIiBPYmplY3QgYXMgdGhlIDJuZCBhcmd1bWVudFxuICAgIG9wdGlvbnMgPSBwcm90b2NvbHNcbiAgICBwcm90b2NvbHMgPSBudWxsXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJvdG9jb2wgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5wcm90b2NvbCkpIHtcbiAgICAgIHByb3RvY29scyA9IG9wdGlvbnMucHJvdG9jb2w7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICBpZiAob3B0aW9ucy5vYmplY3RNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm9iamVjdE1vZGUgPSAhKG9wdGlvbnMuYmluYXJ5ID09PSB0cnVlIHx8IG9wdGlvbnMuYmluYXJ5ID09PSB1bmRlZmluZWQpXG4gIH1cblxuICB2YXIgcHJveHkgPSBidWlsZFByb3h5KG9wdGlvbnMsIHNvY2tldFdyaXRlLCBzb2NrZXRFbmQpXG5cbiAgaWYgKCFvcHRpb25zLm9iamVjdE1vZGUpIHtcbiAgICBwcm94eS5fd3JpdGV2ID0gd3JpdGV2XG4gIH1cblxuICAvLyBicm93c2VyIG9ubHk6IHNldHMgdGhlIG1heGltdW0gc29ja2V0IGJ1ZmZlciBzaXplIGJlZm9yZSB0aHJvdHRsaW5nXG4gIHZhciBidWZmZXJTaXplID0gb3B0aW9ucy5icm93c2VyQnVmZmVyU2l6ZSB8fCAxMDI0ICogNTEyXG5cbiAgLy8gYnJvd3NlciBvbmx5OiBob3cgbG9uZyB0byB3YWl0IHdoZW4gdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclRpbWVvdXQgfHwgMTAwMFxuXG4gIC8vIHVzZSBleGlzdGluZyBXZWJTb2NrZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICBzb2NrZXQgPSB0YXJnZXRcbiAgLy8gb3RoZXJ3aXNlIG1ha2UgYSBuZXcgb25lXG4gIH0gZWxzZSB7XG4gICAgLy8gc3BlY2lhbCBjb25zdHJ1Y3RvciB0cmVhdG1lbnQgZm9yIG5hdGl2ZSB3ZWJzb2NrZXRzIGluIGJyb3dzZXJzLCBzZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF4b2dkZW4vd2Vic29ja2V0LXN0cmVhbS9pc3N1ZXMvODJcbiAgICBpZiAoaXNOYXRpdmUgJiYgaXNCcm93c2VyKSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldCA9IG5ldyBXUyh0YXJnZXQsIHByb3RvY29scywgb3B0aW9ucylcbiAgICB9XG5cbiAgICBzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgfVxuXG4gIC8vIHdhcyBhbHJlYWR5IG9wZW4gd2hlbiBwYXNzZWQgaW5cbiAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBzb2NrZXQuT1BFTikge1xuICAgIHN0cmVhbSA9IHByb3h5XG4gIH0gZWxzZSBpZiAoaXNCcm93c2VyKSB7XG4gICAgc3RyZWFtID0gcHJveHlcbiAgICBzdHJlYW0uY29yaygpXG4gICAgc29ja2V0Lm9ub3BlbiA9IG9ub3BlbkJyb3dzZXJcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBkdXBsZXhpZnkub2JqKClcbiAgICBzb2NrZXQub25vcGVuID0gb25vcGVuXG4gIH1cblxuICBzdHJlYW0uc29ja2V0ID0gc29ja2V0XG5cbiAgc29ja2V0Lm9uY2xvc2UgPSBvbmNsb3NlXG4gIHNvY2tldC5vbmVycm9yID0gb25lcnJvclxuICBzb2NrZXQub25tZXNzYWdlID0gb25tZXNzYWdlXG5cbiAgcHJveHkub24oJ2Nsb3NlJywgZGVzdHJveSlcblxuICB2YXIgY29lcmNlVG9CdWZmZXIgPSAhb3B0aW9ucy5vYmplY3RNb2RlXG5cbiAgZnVuY3Rpb24gc29ja2V0V3JpdGVOb2RlKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICAvLyBhdm9pZCBlcnJvcnMsIHRoaXMgbmV2ZXIgaGFwcGVucyB1bmxlc3NcbiAgICAvLyBkZXN0cm95KCkgaXMgY2FsbGVkXG4gICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSBzb2NrZXQuT1BFTikge1xuICAgICAgbmV4dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29lcmNlVG9CdWZmZXIgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ3V0ZjgnKVxuICAgIH1cbiAgICBzb2NrZXQuc2VuZChjaHVuaywgbmV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvY2tldFdyaXRlQnJvd3NlcihjaHVuaywgZW5jLCBuZXh0KSB7XG4gICAgaWYgKHNvY2tldC5idWZmZXJlZEFtb3VudCA+IGJ1ZmZlclNpemUpIHtcbiAgICAgIHNldFRpbWVvdXQoc29ja2V0V3JpdGVCcm93c2VyLCBidWZmZXJUaW1lb3V0LCBjaHVuaywgZW5jLCBuZXh0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvZXJjZVRvQnVmZmVyICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICd1dGY4JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc29ja2V0LnNlbmQoY2h1bmspXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHJldHVybiBuZXh0KGVycilcbiAgICB9XG5cbiAgICBuZXh0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvY2tldEVuZChkb25lKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgICBkb25lKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ub3BlbigpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ub3BlbkJyb3dzZXIgKCkge1xuICAgIHN0cmVhbS51bmNvcmsoKVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH1cblxuICBmdW5jdGlvbiBvbm1lc3NhZ2UoZXZlbnQpIHtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICBlbHNlIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAndXRmOCcpXG4gICAgcHJveHkucHVzaChkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBzb2NrZXQuY2xvc2UoKVxuICB9XG5cbiAgLy8gdGhpcyBpcyB0byBiZSBlbmFibGVkIG9ubHkgaWYgb2JqZWN0TW9kZSBpcyBmYWxzZVxuICBmdW5jdGlvbiB3cml0ZXYgKGNodW5rcywgY2IpIHtcbiAgICB2YXIgYnVmZmVycyA9IG5ldyBBcnJheShjaHVua3MubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rc1tpXS5jaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyc1tpXSA9IEJ1ZmZlci5mcm9tKGNodW5rc1tpXSwgJ3V0ZjgnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyc1tpXSA9IGNodW5rc1tpXS5jaHVua1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3dyaXRlKEJ1ZmZlci5jb25jYXQoYnVmZmVycyksICdiaW5hcnknLCBjYilcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbn1cbiIsIlxudmFyIHdzID0gbnVsbFxuXG5pZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBNb3pXZWJTb2NrZXRcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3c1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBnW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7IHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFja1xuLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYVxuLy8gcHJlc3VtYWJseSBkaWZmZXJlbnQgY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXRcbi8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5LlxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHlcbmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7XG4gIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpXG5cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKVxuXG4gIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgd3JhcHBlcltrXSA9IGZuW2tdXG4gIH0pXG5cbiAgcmV0dXJuIHdyYXBwZXJcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIHZhciByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV1cbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7XG4gICAgICBPYmplY3Qua2V5cyhjYikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXRba10gPSBjYltrXVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBhdWRpby5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDE2LiBhdWRpb1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIHBhcnNlQXVkaW9UeXBlKHN0ciwgaW5wdXQsIG91dHB1dCkge1xuICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gIGlmIChzdHIuaW5kZXhPZignaW5wdXQnKSA+PSAwKSB7IHJlc3VsdCA9ICdNaWNyb3Bob25lJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2Rpc3BsYXkgYXVkaW8nKSA+PSAwKSB7IHJlc3VsdCA9ICdTcGVha2VyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3NwZWFrJykgPj0gMCkgeyByZXN1bHQgPSAnU3BlYWtlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdsYXV0JykgPj0gMCkgeyByZXN1bHQgPSAnU3BlYWtlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdsb3VkJykgPj0gMCkgeyByZXN1bHQgPSAnU3BlYWtlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoZWFkJykgPj0gMCkgeyByZXN1bHQgPSAnSGVhZHNldCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtaWMnKSA+PSAwKSB7IHJlc3VsdCA9ICdNaWNyb3Bob25lJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21pa3InKSA+PSAwKSB7IHJlc3VsdCA9ICdNaWNyb3Bob25lJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3Bob25lJykgPj0gMCkgeyByZXN1bHQgPSAnUGhvbmUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignY29udHJvbGwnKSA+PSAwKSB7IHJlc3VsdCA9ICdDb250cm9sbGVyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2xpbmUgbycpID49IDApIHsgcmVzdWx0ID0gJ0xpbmUgT3V0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2RpZ2l0YWwgbycpID49IDApIHsgcmVzdWx0ID0gJ0RpZ2l0YWwgT3V0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3NtYXJ0IHNvdW5kIHRlY2hub2xvZ3knKSA+PSAwKSB7IHJlc3VsdCA9ICdEaWdpdGFsIFNpZ25hbCBQcm9jZXNzb3InOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaGlnaCBkZWZpbml0aW9uIGF1ZGlvJykgPj0gMCkgeyByZXN1bHQgPSAnU291bmQgRHJpdmVyJzsgfVxuXG4gIGlmICghcmVzdWx0ICYmIG91dHB1dCkge1xuICAgIHJlc3VsdCA9ICdTcGVha2VyJztcbiAgfSBlbHNlIGlmICghcmVzdWx0ICYmIGlucHV0KSB7XG4gICAgcmVzdWx0ID0gJ01pY3JvcGhvbmUnO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gZ2V0TGludXhBdWRpb1BjaSgpIHtcbiAgbGV0IGNtZCA9ICdsc3BjaSAtdiAyPi9kZXYvbnVsbCc7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJ0cyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxuJyk7XG4gICAgcGFydHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IGxpbmVzID0gZWxlbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICBpZiAobGluZXMgJiYgbGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYXVkaW8nKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvID0ge307XG4gICAgICAgIGF1ZGlvLnNsb3RJZCA9IGxpbmVzWzBdLnNwbGl0KCcgJylbMF07XG4gICAgICAgIGF1ZGlvLmRyaXZlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdLZXJuZWwgZHJpdmVyIGluIHVzZScsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0tlcm5lbCBtb2R1bGVzJywgJzonLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYXVkaW8pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhBdWRpb1BjaU1NKGxpbmVzLCBhdWRpb1BDSSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgc2xvdElkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Nsb3QnKTtcblxuICBjb25zdCBwY2lNYXRjaCA9IGF1ZGlvUENJLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5zbG90SWQgPT09IHNsb3RJZDsgfSk7XG5cbiAgcmVzdWx0LmlkID0gc2xvdElkO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTRGV2aWNlJyk7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU1ZlbmRvcicpO1xuICByZXN1bHQucmV2aXNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmV2Jyk7XG4gIHJlc3VsdC5kcml2ZXIgPSBwY2lNYXRjaCAmJiBwY2lNYXRjaC5sZW5ndGggPT09IDEgJiYgcGNpTWF0Y2hbMF0uZHJpdmVyID8gcGNpTWF0Y2hbMF0uZHJpdmVyIDogJyc7XG4gIHJlc3VsdC5kZWZhdWx0ID0gbnVsbDtcbiAgcmVzdWx0LmNoYW5uZWwgPSAnUENJZSc7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VBdWRpb1R5cGUocmVzdWx0Lm5hbWUsIG51bGwsIG51bGwpO1xuICByZXN1bHQuaW4gPSBudWxsO1xuICByZXN1bHQub3V0ID0gbnVsbDtcbiAgcmVzdWx0LnN0YXR1cyA9ICdvbmxpbmUnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGFyd2luQ2hhbm5lbChzdHIpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gIGlmIChzdHIuaW5kZXhPZignYnVpbHRpbicpID49IDApIHsgcmVzdWx0ID0gJ0J1aWx0LUluJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2V4dGVybicpID49IDApIHsgcmVzdWx0ID0gJ0F1ZGlvLUphY2snOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaGRtaScpID49IDApIHsgcmVzdWx0ID0gJ0hETUknOyB9XG4gIGlmIChzdHIuaW5kZXhPZignZGlzcGxheXBvcnQnKSA+PSAwKSB7IHJlc3VsdCA9ICdEaXNwbGF5LVBvcnQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZigndXNiJykgPj0gMCkgeyByZXN1bHQgPSAnVVNCJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3BjaScpID49IDApIHsgcmVzdWx0ID0gJ1BDSWUnOyB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXJ3aW5BdWRpbyhhdWRpb09iamVjdCwgaWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGNoYW5uZWxTdHIgPSAoKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2VfdHJhbnNwb3J0IHx8ICcnKSArICcgJyArIChhdWRpb09iamVjdC5fbmFtZSB8fCAnJykpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmVzdWx0LmlkID0gaWQ7XG4gIHJlc3VsdC5uYW1lID0gYXVkaW9PYmplY3QuX25hbWU7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSBhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX21hbnVmYWN0dXJlcjtcbiAgcmVzdWx0LnJldmlzaW9uID0gbnVsbDtcbiAgcmVzdWx0LmRyaXZlciA9IG51bGw7XG4gIHJlc3VsdC5kZWZhdWx0ID0gISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RlZmF1bHRfYXVkaW9faW5wdXRfZGV2aWNlIHx8ICcnKSB8fCAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGVmYXVsdF9hdWRpb19vdXRwdXRfZGV2aWNlIHx8ICcnKTtcbiAgcmVzdWx0LmNoYW5uZWwgPSBwYXJzZURhcndpbkNoYW5uZWwoY2hhbm5lbFN0cik7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VBdWRpb1R5cGUocmVzdWx0Lm5hbWUsICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2VfaW5wdXQgfHwgJycpLCAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX291dHB1dCB8fCAnJykpO1xuICByZXN1bHQuaW4gPSAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX2lucHV0IHx8ICcnKTtcbiAgcmVzdWx0Lm91dCA9ICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZXZpY2Vfb3V0cHV0IHx8ICcnKTtcbiAgcmVzdWx0LnN0YXR1cyA9ICdvbmxpbmUnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luZG93c0F1ZGlvKGxpbmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBzdGF0dXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhdHVzSW5mbycsICc6Jyk7XG5cbiAgcmVzdWx0LmlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RldmljZUlEJywgJzonKTsgLy8gUE5QRGV2aWNlSUQ/P1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKTtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICByZXN1bHQucmV2aXNpb24gPSBudWxsO1xuICByZXN1bHQuZHJpdmVyID0gbnVsbDtcbiAgcmVzdWx0LmRlZmF1bHQgPSBudWxsO1xuICByZXN1bHQuY2hhbm5lbCA9IG51bGw7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VBdWRpb1R5cGUocmVzdWx0Lm5hbWUsIG51bGwsIG51bGwpO1xuICByZXN1bHQuaW4gPSBudWxsO1xuICByZXN1bHQub3V0ID0gbnVsbDtcbiAgcmVzdWx0LnN0YXR1cyA9IHN0YXR1cztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBhdWRpbyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGxldCBjbWQgPSAnbHNwY2kgLXZtbSAyPi9kZXYvbnVsbCc7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIC8vIFBDSVxuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvUENJID0gZ2V0TGludXhBdWRpb1BjaSgpO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxuJyk7XG4gICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGVsZW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NsYXNzJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2F1ZGlvJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gcGFyc2VMaW51eEF1ZGlvUGNpTU0obGluZXMsIGF1ZGlvUENJKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhdWRpbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciBTUEF1ZGlvRGF0YVR5cGUgLWpzb24nO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvdXRPYmogPSBKU09OLnBhcnNlKHN0ZG91dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgaWYgKG91dE9iai5TUEF1ZGlvRGF0YVR5cGUgJiYgb3V0T2JqLlNQQXVkaW9EYXRhVHlwZS5sZW5ndGggJiYgb3V0T2JqLlNQQXVkaW9EYXRhVHlwZVswXSAmJiBvdXRPYmouU1BBdWRpb0RhdGFUeXBlWzBdWydfaXRlbXMnXSAmJiBvdXRPYmouU1BBdWRpb0RhdGFUeXBlWzBdWydfaXRlbXMnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dE9iai5TUEF1ZGlvRGF0YVR5cGVbMF1bJ19pdGVtcyddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IHBhcnNlRGFyd2luQXVkaW8ob3V0T2JqLlNQQXVkaW9EYXRhVHlwZVswXVsnX2l0ZW1zJ11baV0sIGkpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXVkaW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1NvdW5kRGV2aWNlIHwgc2VsZWN0IERldmljZUlELFN0YXR1c0luZm8sTmFtZSxNYW51ZmFjdHVyZXIgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGVsZW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBpZiAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VXaW5kb3dzQXVkaW8obGluZXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuYXVkaW8gPSBhdWRpbztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVjaztcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGJhdHRlcnkuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA2LiBCYXR0ZXJ5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIHBhcnNlV2luQmF0dGVyeVBhcnQobGluZXMsIGRlc2lnbmVkQ2FwYWNpdHksIGZ1bGxDaGFyZ2VDYXBhY2l0eSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgbGV0IHN0YXR1cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCYXR0ZXJ5U3RhdHVzJywgJzonKS50cmltKCk7XG4gIC8vIDEgPSBcIkRpc2NoYXJnaW5nXCJcbiAgLy8gMiA9IFwiT24gQS9DXCJcbiAgLy8gMyA9IFwiRnVsbHkgQ2hhcmdlZFwiXG4gIC8vIDQgPSBcIkxvd1wiXG4gIC8vIDUgPSBcIkNyaXRpY2FsXCJcbiAgLy8gNiA9IFwiQ2hhcmdpbmdcIlxuICAvLyA3ID0gXCJDaGFyZ2luZyBIaWdoXCJcbiAgLy8gOCA9IFwiQ2hhcmdpbmcgTG93XCJcbiAgLy8gOSA9IFwiQ2hhcmdpbmcgQ3JpdGljYWxcIlxuICAvLyAxMCA9IFwiVW5kZWZpbmVkXCJcbiAgLy8gMTEgPSBcIlBhcnRpYWxseSBDaGFyZ2VkXCJcbiAgaWYgKHN0YXR1cyA+PSAwKSB7XG4gICAgY29uc3Qgc3RhdHVzVmFsdWUgPSBzdGF0dXMgPyBwYXJzZUludChzdGF0dXMpIDogMDtcbiAgICByZXN1bHQuc3RhdHVzID0gc3RhdHVzVmFsdWU7XG4gICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSB0cnVlO1xuICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IGZ1bGxDaGFyZ2VDYXBhY2l0eSB8fCBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVzaWduQ2FwYWNpdHknLCAnOicpIHx8IDApO1xuICAgIHJlc3VsdC5kZXNpZ25lZENhcGFjaXR5ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Rlc2lnbkNhcGFjaXR5JywgJzonKSB8fCBkZXNpZ25lZENhcGFjaXR5KTtcbiAgICByZXN1bHQudm9sdGFnZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXNpZ25Wb2x0YWdlJywgJzonKSB8fCAwKSAvIDEwMDAuMDtcbiAgICByZXN1bHQuY2FwYWNpdHlVbml0ID0gJ21XaCc7XG4gICAgcmVzdWx0LnBlcmNlbnQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRXN0aW1hdGVkQ2hhcmdlUmVtYWluaW5nJywgJzonKSB8fCAwKTtcbiAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gcGFyc2VJbnQocmVzdWx0Lm1heENhcGFjaXR5ICogcmVzdWx0LnBlcmNlbnQgLyAxMDApO1xuICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gKHN0YXR1c1ZhbHVlID49IDYgJiYgc3RhdHVzVmFsdWUgPD0gOSkgfHwgc3RhdHVzVmFsdWUgPT09IDExIHx8ICgoc3RhdHVzVmFsdWUgIT09IDMpICYmIChzdGF0dXNWYWx1ZSAhPT0gMSkgJiYgcmVzdWx0LnBlcmNlbnQgPCAxMDApO1xuICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IHJlc3VsdC5pc0NoYXJnaW5nIHx8IHN0YXR1c1ZhbHVlID09PSAyO1xuICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXZpY2VJRCcsICc6Jyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnN0YXR1cyA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGhhc0JhdHRlcnk6IGZhbHNlLFxuICAgICAgICBjeWNsZUNvdW50OiAwLFxuICAgICAgICBpc0NoYXJnaW5nOiBmYWxzZSxcbiAgICAgICAgZGVzaWduZWRDYXBhY2l0eTogMCxcbiAgICAgICAgbWF4Q2FwYWNpdHk6IDAsXG4gICAgICAgIGN1cnJlbnRDYXBhY2l0eTogMCxcbiAgICAgICAgdm9sdGFnZTogMCxcbiAgICAgICAgY2FwYWNpdHlVbml0OiAnJyxcbiAgICAgICAgcGVyY2VudDogMCxcbiAgICAgICAgdGltZVJlbWFpbmluZzogbnVsbCxcbiAgICAgICAgYWNDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICBtb2RlbDogJycsXG4gICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgIHNlcmlhbDogJydcbiAgICAgIH07XG5cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgbGV0IGJhdHRlcnlfcGF0aCA9ICcnO1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYygnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQkFUMS91ZXZlbnQnKSkge1xuICAgICAgICAgIGJhdHRlcnlfcGF0aCA9ICcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9CQVQxLyc7XG4gICAgICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYygnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQkFUMC91ZXZlbnQnKSkge1xuICAgICAgICAgIGJhdHRlcnlfcGF0aCA9ICcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9CQVQwLyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYWNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGFjUGF0aCA9ICcnO1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYygnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQUMvb25saW5lJykpIHtcbiAgICAgICAgICBhY1BhdGggPSAnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQUMvb25saW5lJztcbiAgICAgICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKCcvc3lzL2NsYXNzL3Bvd2VyX3N1cHBseS9BQzAvb25saW5lJykpIHtcbiAgICAgICAgICBhY1BhdGggPSAnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQUMwL29ubGluZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWNQYXRoKSB7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IGZzLnJlYWRGaWxlU3luYyhhY1BhdGgpO1xuICAgICAgICAgIGFjQ29ubmVjdGVkID0gZmlsZS50b1N0cmluZygpLnRyaW0oKSA9PT0gJzEnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhdHRlcnlfcGF0aCkge1xuICAgICAgICAgIGZzLnJlYWRGaWxlKGJhdHRlcnlfcGF0aCArICd1ZXZlbnQnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9TVEFUVVMnLCAnPScpLnRvTG93ZXJDYXNlKCkgPT09ICdjaGFyZ2luZycpO1xuICAgICAgICAgICAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSBhY0Nvbm5lY3RlZCB8fCByZXN1bHQuaXNDaGFyZ2luZztcbiAgICAgICAgICAgICAgcmVzdWx0LnZvbHRhZ2UgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1ZPTFRBR0VfTk9XJywgJz0nKSwgMTApIC8gMTAwMDAwMC4wO1xuICAgICAgICAgICAgICByZXN1bHQuY2FwYWNpdHlVbml0ID0gcmVzdWx0LnZvbHRhZ2UgPyAnbVdoJyA6ICdtQWgnO1xuICAgICAgICAgICAgICByZXN1bHQuY3ljbGVDb3VudCA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ1lDTEVfQ09VTlQnLCAnPScpLCAxMCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DSEFSR0VfRlVMTCcsICc9JywgdHJ1ZSwgdHJ1ZSksIDEwKSAvIDEwMDAuMCAqIChyZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGRlc2luZ2VkTWluVm9sdGFnZSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfVk9MVEFHRV9NSU5fREVTSUdOJywgJz0nKSwgMTApIC8gMTAwMDAwMC4wO1xuICAgICAgICAgICAgICByZXN1bHQuZGVzaWduZWRDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DSEFSR0VfRlVMTF9ERVNJR04nLCAnPScsIHRydWUsIHRydWUpLCAxMCkgLyAxMDAwLjAgKiAoZGVzaW5nZWRNaW5Wb2x0YWdlIHx8IHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DSEFSR0VfTk9XJywgJz0nKSwgMTApIC8gMTAwMC4wICogKHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQubWF4Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0VORVJHWV9GVUxMJywgJz0nLCB0cnVlLCB0cnVlKSwgMTApIC8gMTAwMC4wO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZXNpZ25lZENhcGFjaXR5ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9FTkVSR1lfRlVMTF9ERVNJR04nLCAnPScsIHRydWUsIHRydWUpLCAxMCkgLyAxMDAwLjAgfCByZXN1bHQubWF4Q2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfRU5FUkdZX05PVycsICc9JyksIDEwKSAvIDEwMDAuMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9DQVBBQ0lUWScsICc9Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuZXJneSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfRU5FUkdZX05PVycsICc9JyksIDEwKTtcbiAgICAgICAgICAgICAgY29uc3QgcG93ZXIgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1BPV0VSX05PVycsICc9JyksIDEwKTtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ1VSUkVOVF9OT1cnLCAnPScpLCAxMCk7XG5cbiAgICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnQgPSBwYXJzZUludCgnMCcgKyBwZXJjZW50LCAxMCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubWF4Q2FwYWNpdHkgJiYgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50ID0gMTAwLjAgKiByZXN1bHQuY3VycmVudENhcGFjaXR5IC8gcmVzdWx0Lm1heENhcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzQ2hhcmdpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGFzQmF0dGVyeSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVuZXJneSAmJiBwb3dlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aW1lUmVtYWluaW5nID0gTWF0aC5mbG9vcihlbmVyZ3kgLyBwb3dlciAqIDYwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50ICYmIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGltZVJlbWFpbmluZyA9IE1hdGguZmxvb3IocmVzdWx0LmN1cnJlbnRDYXBhY2l0eSAvIGN1cnJlbnQgKiA2MCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1RFQ0hOT0xPR1knLCAnPScpO1xuICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX01PREVMX05BTUUnLCAnPScpO1xuICAgICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9NQU5VRkFDVFVSRVInLCAnPScpO1xuICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9TRVJJQUxfTlVNQkVSJywgJz0nKTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdzeXNjdGwgLWkgaHcuYWNwaS5iYXR0ZXJ5IGh3LmFjcGkuYWNsaW5lJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgY29uc3QgYmF0dGVyaWVzID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmFjcGkuYmF0dGVyeS51bml0cycpLCAxMCk7XG4gICAgICAgICAgY29uc3QgcGVyY2VudCA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5hY3BpLmJhdHRlcnkubGlmZScpLCAxMCk7XG4gICAgICAgICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSAoYmF0dGVyaWVzID4gMCk7XG4gICAgICAgICAgcmVzdWx0LmN5Y2xlQ291bnQgPSBudWxsO1xuICAgICAgICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmFjcGkuYWNsaW5lJykgIT09ICcxJztcbiAgICAgICAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSByZXN1bHQuaXNDaGFyZ2luZztcbiAgICAgICAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBudWxsO1xuICAgICAgICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBudWxsO1xuICAgICAgICAgIHJlc3VsdC5jYXBhY2l0eVVuaXQgPSAndW5rbm93bic7XG4gICAgICAgICAgcmVzdWx0LnBlcmNlbnQgPSBiYXR0ZXJpZXMgPyBwZXJjZW50IDogbnVsbDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ2lvcmVnIC1uIEFwcGxlU21hcnRCYXR0ZXJ5IC1yIHwgZWdyZXAgXCJDeWNsZUNvdW50fElzQ2hhcmdpbmd8RGVzaWduQ2FwYWNpdHl8TWF4Q2FwYWNpdHl8Q3VycmVudENhcGFjaXR5fEJhdHRlcnlTZXJpYWxOdW1iZXJ8VGltZVJlbWFpbmluZ3xWb2x0YWdlXCI7IHBtc2V0IC1nIGJhdHQgfCBncmVwICUnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnJlcGxhY2UoLyArL2csICcnKS5yZXBsYWNlKC9cIisvZywgJycpLnJlcGxhY2UoLy0vZywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5jeWNsZUNvdW50ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2N5Y2xlY291bnQnLCAnPScpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQudm9sdGFnZSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x0YWdlJywgJz0nKSwgMTApIC8gMTAwMC4wO1xuICAgICAgICAgICAgcmVzdWx0LmNhcGFjaXR5VW5pdCA9IHJlc3VsdC52b2x0YWdlID8gJ21XaCcgOiAnbUFoJztcbiAgICAgICAgICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2FwcGxlcmF3bWF4Y2FwYWNpdHknLCAnPScpLCAxMCkgKiAocmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2FwcGxlcmF3Y3VycmVudGNhcGFjaXR5JywgJz0nKSwgMTApICogKHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNpZ25lZENhcGFjaXR5ID0gTWF0aC5yb3VuZChwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVzaWduQ2FwYWNpdHknLCAnPScpLCAxMCkgKiAocmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICdBcHBsZSc7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JhdHRlcnlTZXJpYWxOdW1iZXInLCAnPScpO1xuICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpbnRlcm5hbCcsICdCYXR0ZXJ5Jyk7XG4gICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHNbMF0pIHtcbiAgICAgICAgICAgICAgbGV0IHBhcnRzMiA9IHBhcnRzWzBdLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzMiAmJiBwYXJ0czJbMV0pIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gcGFyc2VGbG9hdChwYXJ0czJbMV0udHJpbSgpLnJlcGxhY2UoLyUvZywgJycpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzWzFdKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gKHBhcnRzWzFdLnRyaW0oKSA9PT0gJ2NoYXJnaW5nJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IChwYXJ0c1sxXS50cmltKCkgIT09ICdkaXNjaGFyZ2luZycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaXNjaGFyZ2luZycsICc9JykudG9Mb3dlckNhc2UoKSA9PT0gJ3llcyc7XG4gICAgICAgICAgICAgIHJlc3VsdC5hY0Nvbm5lY3RlZCA9IHJlc3VsdC5pc0NoYXJnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXhDYXBhY2l0eSAmJiByZXN1bHQuY3VycmVudENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAnTGktaW9uJztcbiAgICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnQgPSBwZXJjZW50ICE9PSBudWxsID8gcGVyY2VudCA6IE1hdGgucm91bmQoMTAwLjAgKiByZXN1bHQuY3VycmVudENhcGFjaXR5IC8gcmVzdWx0Lm1heENhcGFjaXR5KTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaXNDaGFyZ2luZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aW1lUmVtYWluaW5nID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RpbWVSZW1haW5pbmcnLCAnPScpLCAxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQmF0dGVyeSB8IHNlbGVjdCBCYXR0ZXJ5U3RhdHVzLCBEZXNpZ25DYXBhY2l0eSwgRGVzaWduVm9sdGFnZSwgRXN0aW1hdGVkQ2hhcmdlUmVtYWluaW5nLCBEZXZpY2VJRCB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCcoR2V0LUNpbUluc3RhbmNlIC1DbGFzcyBCYXR0ZXJ5U3RhdGljRGF0YSAtTmFtZXNwYWNlIFJPT1QvV01JKS5EZXNpZ25lZENhcGFjaXR5JykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCcoR2V0LUNpbUluc3RhbmNlIC1DbGFzcyBCYXR0ZXJ5RnVsbENoYXJnZWRDYXBhY2l0eSAtTmFtZXNwYWNlIFJPT1QvV01JKS5GdWxsQ2hhcmdlZENhcGFjaXR5JykpO1xuICAgICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICBsZXQgcGFydHMgPSBkYXRhLnJlc3VsdHNbMF0uc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgbGV0IGJhdHRlcmllcyA9IFtdO1xuICAgICAgICAgICAgICBjb25zdCBoYXNWYWx1ZSA9IHZhbHVlID0+IC9cXFMvLnRlc3QodmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKHBhcnRzW2ldKSAmJiAoIWJhdHRlcmllcy5sZW5ndGggfHwgIWhhc1ZhbHVlKHBhcnRzW2kgLSAxXSkpKSB7XG4gICAgICAgICAgICAgICAgICBiYXR0ZXJpZXMucHVzaChbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZShwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgIGJhdHRlcmllc1tiYXR0ZXJpZXMubGVuZ3RoIC0gMV0ucHVzaChwYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkZXNpZ25DYXBhY2l0aWVzID0gZGF0YS5yZXN1bHRzWzFdLnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIoZSA9PiBlKTtcbiAgICAgICAgICAgICAgbGV0IGZ1bGxDaGFyZ2VDYXBhY2l0aWVzID0gZGF0YS5yZXN1bHRzWzJdLnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIoZSA9PiBlKTtcbiAgICAgICAgICAgICAgaWYgKGJhdHRlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbEJhdHRlcmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0dGVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBiYXR0ZXJpZXNbaV1bMF0uc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGVzaWduZWRDYXBhY2l0eSA9IGRlc2lnbkNhcGFjaXRpZXMgJiYgZGVzaWduQ2FwYWNpdGllcy5sZW5ndGggPj0gKGkgKyAxKSAmJiBkZXNpZ25DYXBhY2l0aWVzW2ldID8gdXRpbC50b0ludChkZXNpZ25DYXBhY2l0aWVzW2ldKSA6IDA7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmdWxsQ2hhcmdlQ2FwYWNpdHkgPSBmdWxsQ2hhcmdlQ2FwYWNpdGllcyAmJiBmdWxsQ2hhcmdlQ2FwYWNpdGllcy5sZW5ndGggPj0gKGkgKyAxKSAmJiBmdWxsQ2hhcmdlQ2FwYWNpdGllc1tpXSA/IHV0aWwudG9JbnQoZnVsbENoYXJnZUNhcGFjaXRpZXNbaV0pIDogMDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlV2luQmF0dGVyeVBhcnQobGluZXMsIGRlc2lnbmVkQ2FwYWNpdHksIGZ1bGxDaGFyZ2VDYXBhY2l0eSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWZpcnN0ICYmIHBhcnNlZC5zdGF0dXMgPiAwICYmIHBhcnNlZC5zdGF0dXMgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gcGFyc2VkLmhhc0JhdHRlcnk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXhDYXBhY2l0eSA9IHBhcnNlZC5tYXhDYXBhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlc2lnbmVkQ2FwYWNpdHkgPSBwYXJzZWQuZGVzaWduZWRDYXBhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZvbHRhZ2UgPSBwYXJzZWQudm9sdGFnZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhcGFjaXR5VW5pdCA9IHBhcnNlZC5jYXBhY2l0eVVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50ID0gcGFyc2VkLnBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBwYXJzZWQuY3VycmVudENhcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaXNDaGFyZ2luZyA9IHBhcnNlZC5pc0NoYXJnaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSBwYXJzZWQuYWNDb25uZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHBhcnNlZC5tb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQuc3RhdHVzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQmF0dGVyaWVzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQmF0dGVyeTogcGFyc2VkLmhhc0JhdHRlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDYXBhY2l0eTogcGFyc2VkLm1heENhcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzaWduZWRDYXBhY2l0eTogcGFyc2VkLmRlc2lnbmVkQ2FwYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2x0YWdlOiBwYXJzZWQudm9sdGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcGFjaXR5VW5pdDogcGFyc2VkLmNhcGFjaXR5VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQ6IHBhcnNlZC5wZXJjZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENhcGFjaXR5OiBwYXJzZWQuY3VycmVudENhcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFyZ2luZzogcGFyc2VkLmlzQ2hhcmdpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNDb25uZWN0ZWQ6IHBhcnNlZC5hY0Nvbm5lY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJzZWQubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWw6ICcnXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0ICYmIGFkZGl0aW9uYWxCYXR0ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBhZGRpdGlvbmFsQmF0dGVyaWVzWzBdO1xuICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEJhdHRlcmllcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbEJhdHRlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRpdGlvbmFsQmF0dGVyaWVzID0gYWRkaXRpb25hbEJhdHRlcmllcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGF1ZGlvLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTcuIGJsdWV0b290aFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBwYXJzZUJsdWV0b290aFR5cGUoc3RyKSB7XG4gIGxldCByZXN1bHQgPSAnJztcblxuICBpZiAoc3RyLmluZGV4T2YoJ2tleWJvYXJkJykgPj0gMCkgeyByZXN1bHQgPSAnS2V5Ym9hcmQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbW91c2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdNb3VzZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdzcGVha2VyJykgPj0gMCkgeyByZXN1bHQgPSAnU3BlYWtlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoZWFkc2V0JykgPj0gMCkgeyByZXN1bHQgPSAnSGVhZHNldCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdwaG9uZScpID49IDApIHsgcmVzdWx0ID0gJ1Bob25lJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21hY2Jvb2snKSA+PSAwKSB7IHJlc3VsdCA9ICdDb21wdXRlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdpbWFjJykgPj0gMCkgeyByZXN1bHQgPSAnQ29tcHV0ZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaXBhZCcpID49IDApIHsgcmVzdWx0ID0gJ1RhYmxldCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCd3YXRjaCcpID49IDApIHsgcmVzdWx0ID0gJ1dhdGNoJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2hlYWRwaG9uZScpID49IDApIHsgcmVzdWx0ID0gJ0hlYWRzZXQnOyB9XG4gIC8vIHRvIGJlIGNvbnRpbnVlZCAuLi5cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJsdWV0b290aE1hbnVmYWN0dXJlcihzdHIpIHtcbiAgbGV0IHJlc3VsdCA9IHN0ci5zcGxpdCgnICcpWzBdO1xuICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHN0ci5pbmRleE9mKCdhcHBsZScpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2lwYWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdpbWFjJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaXBob25lJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbWFnaWMgbW91c2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtYWNib29rJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIC8vIHRvIGJlIGNvbnRpbnVlZCAuLi5cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4Qmx1ZXRvb3RoSW5mbyhsaW5lcywgbWFjQWRkcjEsIG1hY0FkZHIyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIHJlc3VsdC5kZXZpY2UgPSBudWxsO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJz0nKTtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IG51bGw7XG4gIHJlc3VsdC5tYWNEZXZpY2UgPSBtYWNBZGRyMTtcbiAgcmVzdWx0Lm1hY0hvc3QgPSBtYWNBZGRyMjtcbiAgcmVzdWx0LmJhdHRlcnlQZXJjZW50ID0gbnVsbDtcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUJsdWV0b290aFR5cGUocmVzdWx0Lm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIHJlc3VsdC5jb25uZWN0ZWQgPSBmYWxzZTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhcndpbkJsdWV0b290aERldmljZXMoYmx1ZXRvb3RoT2JqZWN0LCBtYWNBZGRyMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgdHlwZVN0ciA9ICgoYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9taW5vckNsYXNzT2ZEZXZpY2Vfc3RyaW5nIHx8IGJsdWV0b290aE9iamVjdC5kZXZpY2VfbWFqb3JDbGFzc09mRGV2aWNlX3N0cmluZyB8fCBibHVldG9vdGhPYmplY3QuZGV2aWNlX21pbm9yVHlwZSB8fCAnJykgKyAoYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9uYW1lIHx8ICcnKSkudG9Mb3dlckNhc2UoKTtcblxuICByZXN1bHQuZGV2aWNlID0gYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9zZXJ2aWNlcyB8fCAnJztcbiAgcmVzdWx0Lm5hbWUgPSBibHVldG9vdGhPYmplY3QuZGV2aWNlX25hbWUgfHwgJyc7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSBibHVldG9vdGhPYmplY3QuZGV2aWNlX21hbnVmYWN0dXJlciB8fCBwYXJzZUJsdWV0b290aE1hbnVmYWN0dXJlcihibHVldG9vdGhPYmplY3QuZGV2aWNlX25hbWUgfHwgJycpIHx8ICcnO1xuICByZXN1bHQubWFjRGV2aWNlID0gKGJsdWV0b290aE9iamVjdC5kZXZpY2VfYWRkciB8fCBibHVldG9vdGhPYmplY3QuZGV2aWNlX2FkZHJlc3MgfHwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnOicpO1xuICByZXN1bHQubWFjSG9zdCA9IG1hY0FkZHIyO1xuICByZXN1bHQuYmF0dGVyeVBlcmNlbnQgPSBibHVldG9vdGhPYmplY3QuZGV2aWNlX2JhdHRlcnlQZXJjZW50IHx8IG51bGw7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VCbHVldG9vdGhUeXBlKHR5cGVTdHIpO1xuICByZXN1bHQuY29ubmVjdGVkID0gYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9pc2Nvbm5lY3RlZCA9PT0gJ2F0dHJpYl9ZZXMnIHx8IGZhbHNlO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luZG93c0JsdWV0b290aChsaW5lcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICByZXN1bHQuZGV2aWNlID0gbnVsbDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6Jyk7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgcmVzdWx0Lm1hY0RldmljZSA9IG51bGw7XG4gIHJlc3VsdC5tYWNIb3N0ID0gbnVsbDtcbiAgcmVzdWx0LmJhdHRlcnlQZXJjZW50ID0gbnVsbDtcbiAgcmVzdWx0LnR5cGUgPSBwYXJzZUJsdWV0b290aFR5cGUocmVzdWx0Lm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIHJlc3VsdC5jb25uZWN0ZWQgPSBudWxsO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJsdWV0b290aERldmljZXMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgLy8gZ2V0IGZpbGVzIGluIC92YXIvbGliL2JsdWV0b290aC8gcmVjdXJzaXZlXG4gICAgICAgIGNvbnN0IGJ0RmlsZXMgPSB1dGlsLmdldEZpbGVzSW5QYXRoKCcvdmFyL2xpYi9ibHVldG9vdGgvJyk7XG4gICAgICAgIGJ0RmlsZXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZShlbGVtZW50KTtcbiAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBlbGVtZW50LnNwbGl0KCcvJyk7XG4gICAgICAgICAgY29uc3QgbWFjQWRkcjEgPSBwYXRoUGFydHMubGVuZ3RoID49IDYgPyBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDJdIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBtYWNBZGRyMiA9IHBhdGhQYXJ0cy5sZW5ndGggPj0gNyA/IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gM10gOiBudWxsO1xuICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvRmlsZSA9IGZzLnJlYWRGaWxlU3luYyhlbGVtZW50LCB7IGVuY29kaW5nOiAndXRmOCcgfSkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VMaW51eEJsdWV0b290aEluZm8oaW5mb0ZpbGUsIG1hY0FkZHIxLCBtYWNBZGRyMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRldGVybWluZSBcImNvbm5lY3RlZFwiIHdpdGggaGNpdG9vbCBjb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBoZGljb24gPSBleGVjU3luYygnaGNpdG9vbCBjb24nKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbaV0ubWFjRGV2aWNlICYmIHJlc3VsdFtpXS5tYWNEZXZpY2UubGVuZ3RoID4gMTAgJiYgaGRpY29uLmluZGV4T2YocmVzdWx0W2ldLm1hY0RldmljZS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtpXS5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciBTUEJsdWV0b290aERhdGFUeXBlIC1qc29uJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2JqID0gSlNPTi5wYXJzZShzdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGlmIChvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZS5sZW5ndGggJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV90aXRsZSddICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfdGl0bGUnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBtaXNzaW5nOiBob3N0IEJUIEFkYXB0ZXIgbWFjQWRkciAoKVxuICAgICAgICAgICAgICAgIGxldCBtYWNBZGRyMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydsb2NhbF9kZXZpY2VfdGl0bGUnXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5sb2NhbF9kZXZpY2VfdGl0bGUuZ2VuZXJhbF9hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICBtYWNBZGRyMiA9IG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmxvY2FsX2RldmljZV90aXRsZS5nZW5lcmFsX2FkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICc6Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfdGl0bGUnXS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqS2V5ID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmpLZXkgJiYgb2JqS2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lck9iamVjdCA9IG9ialtvYmpLZXlbMF1dO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iamVjdC5kZXZpY2VfbmFtZSA9IG9iaktleVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmx1ZXRvb3RoRGV2aWNlID0gcGFyc2VEYXJ3aW5CbHVldG9vdGhEZXZpY2VzKGlubmVyT2JqZWN0LCBtYWNBZGRyMik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsdWV0b290aERldmljZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlLmxlbmd0aCAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX2Nvbm5lY3RlZCddICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfY29ubmVjdGVkJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFjQWRkcjIgPSBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMgJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzLmNvbnRyb2xsZXJfYWRkcmVzcyA/IG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcy5jb250cm9sbGVyX2FkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICc6JykgOiBudWxsO1xuICAgICAgICAgICAgICAgIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfY29ubmVjdGVkJ10uZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaktleSA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqS2V5ICYmIG9iaktleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJPYmplY3QgPSBvYmpbb2JqS2V5WzBdXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmplY3QuZGV2aWNlX25hbWUgPSBvYmpLZXlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqZWN0LmRldmljZV9pc2Nvbm5lY3RlZCA9ICdhdHRyaWJfWWVzJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmx1ZXRvb3RoRGV2aWNlID0gcGFyc2VEYXJ3aW5CbHVldG9vdGhEZXZpY2VzKGlubmVyT2JqZWN0LCBtYWNBZGRyMik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsdWV0b290aERldmljZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlLmxlbmd0aCAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX25vdF9jb25uZWN0ZWQnXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX25vdF9jb25uZWN0ZWQnXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWNBZGRyMiA9IG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcyAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMuY29udHJvbGxlcl9hZGRyZXNzID8gb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzLmNvbnRyb2xsZXJfYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJzonKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9ub3RfY29ubmVjdGVkJ10uZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaktleSA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqS2V5ICYmIG9iaktleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJPYmplY3QgPSBvYmpbb2JqS2V5WzBdXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmplY3QuZGV2aWNlX25hbWUgPSBvYmpLZXlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqZWN0LmRldmljZV9pc2Nvbm5lY3RlZCA9ICdhdHRyaWJfTm8nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibHVldG9vdGhEZXZpY2UgPSBwYXJzZURhcndpbkJsdWV0b290aERldmljZXMoaW5uZXJPYmplY3QsIG1hY0FkZHIyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmx1ZXRvb3RoRGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1BOUEVudGl0eSB8IHNlbGVjdCBQTlBDbGFzcywgTmFtZSwgTWFudWZhY3R1cmVyIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgcGFydHMuZm9yRWFjaCgocGFydCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodXRpbC5nZXRWYWx1ZShwYXJ0LnNwbGl0KCdcXG4nKSwgJ1BOUENsYXNzJywgJzonKSA9PT0gJ0JsdWV0b290aCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZVdpbmRvd3NCbHVldG9vdGgocGFydC5zcGxpdCgnXFxuJykpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfbmV0YnNkIHx8IF9vcGVuYnNkIHx8IF9zdW5vcykge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ibHVldG9vdGhEZXZpY2VzID0gYmx1ZXRvb3RoRGV2aWNlcztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gY3B1LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gNC4gQ1BVXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxubGV0IF9jcHVfc3BlZWQgPSAwO1xubGV0IF9jdXJyZW50X2NwdSA9IHtcbiAgdXNlcjogMCxcbiAgbmljZTogMCxcbiAgc3lzdGVtOiAwLFxuICBpZGxlOiAwLFxuICBpcnE6IDAsXG4gIGxvYWQ6IDAsXG4gIHRpY2s6IDAsXG4gIG1zOiAwLFxuICBjdXJyZW50TG9hZDogMCxcbiAgY3VycmVudExvYWRVc2VyOiAwLFxuICBjdXJyZW50TG9hZFN5c3RlbTogMCxcbiAgY3VycmVudExvYWROaWNlOiAwLFxuICBjdXJyZW50TG9hZElkbGU6IDAsXG4gIGN1cnJlbnRMb2FkSXJxOiAwLFxuICByYXdDdXJyZW50TG9hZDogMCxcbiAgcmF3Q3VycmVudExvYWRVc2VyOiAwLFxuICByYXdDdXJyZW50TG9hZFN5c3RlbTogMCxcbiAgcmF3Q3VycmVudExvYWROaWNlOiAwLFxuICByYXdDdXJyZW50TG9hZElkbGU6IDAsXG4gIHJhd0N1cnJlbnRMb2FkSXJxOiAwXG59O1xubGV0IF9jcHVzID0gW107XG5sZXQgX2NvcmVjb3VudCA9IDA7XG5cbmNvbnN0IEFNREJhc2VGcmVxdWVuY2llcyA9IHtcbiAgJzgzNDYnOiAnMS44JyxcbiAgJzgzNDcnOiAnMS45JyxcbiAgJzgzNTAnOiAnMi4wJyxcbiAgJzgzNTQnOiAnMi4yJyxcbiAgJzgzNTZ8U0UnOiAnMi40JyxcbiAgJzgzNTYnOiAnMi4zJyxcbiAgJzgzNjAnOiAnMi41JyxcbiAgJzIzNzInOiAnMi4xJyxcbiAgJzIzNzMnOiAnMi4xJyxcbiAgJzIzNzQnOiAnMi4yJyxcbiAgJzIzNzYnOiAnMi4zJyxcbiAgJzIzNzcnOiAnMi4zJyxcbiAgJzIzNzgnOiAnMi40JyxcbiAgJzIzNzknOiAnMi40JyxcbiAgJzIzODAnOiAnMi41JyxcbiAgJzIzODEnOiAnMi41JyxcbiAgJzIzODInOiAnMi42JyxcbiAgJzIzODQnOiAnMi43JyxcbiAgJzIzODYnOiAnMi44JyxcbiAgJzIzODcnOiAnMi44JyxcbiAgJzIzODknOiAnMi45JyxcbiAgJzIzOTMnOiAnMy4xJyxcbiAgJzgzNzQnOiAnMi4yJyxcbiAgJzgzNzYnOiAnMi4zJyxcbiAgJzgzNzgnOiAnMi40JyxcbiAgJzgzNzknOiAnMi40JyxcbiAgJzgzODAnOiAnMi41JyxcbiAgJzgzODEnOiAnMi41JyxcbiAgJzgzODInOiAnMi42JyxcbiAgJzgzODQnOiAnMi43JyxcbiAgJzgzODYnOiAnMi44JyxcbiAgJzgzODcnOiAnMi44JyxcbiAgJzgzODknOiAnMi45JyxcbiAgJzgzOTMnOiAnMy4xJyxcbiAgJzI0MTlFRSc6ICcxLjgnLFxuICAnMjQyM0hFJzogJzIuMCcsXG4gICcyNDI1SEUnOiAnMi4xJyxcbiAgJzI0MjcnOiAnMi4yJyxcbiAgJzI0MzEnOiAnMi40JyxcbiAgJzI0MzUnOiAnMi42JyxcbiAgJzI0MzlTRSc6ICcyLjgnLFxuICAnODQyNUhFJzogJzIuMScsXG4gICc4NDMxJzogJzIuNCcsXG4gICc4NDM1JzogJzIuNicsXG4gICc4NDM5U0UnOiAnMi44JyxcbiAgJzQxMjInOiAnMi4yJyxcbiAgJzQxMzAnOiAnMi42JyxcbiAgJzQxNjJFRSc6ICcxLjcnLFxuICAnNDE2NEVFJzogJzEuOCcsXG4gICc0MTcwSEUnOiAnMi4xJyxcbiAgJzQxNzRIRSc6ICcyLjMnLFxuICAnNDE3NkhFJzogJzIuNCcsXG4gICc0MTgwJzogJzIuNicsXG4gICc0MTg0JzogJzIuOCcsXG4gICc2MTI0SEUnOiAnMS44JyxcbiAgJzYxMjhIRSc6ICcyLjAnLFxuICAnNjEzMkhFJzogJzIuMicsXG4gICc2MTI4JzogJzIuMCcsXG4gICc2MTM0JzogJzIuMycsXG4gICc2MTM2JzogJzIuNCcsXG4gICc2MTQwJzogJzIuNicsXG4gICc2MTY0SEUnOiAnMS43JyxcbiAgJzYxNjZIRSc6ICcxLjgnLFxuICAnNjE2OCc6ICcxLjknLFxuICAnNjE3Mic6ICcyLjEnLFxuICAnNjE3NCc6ICcyLjInLFxuICAnNjE3Nic6ICcyLjMnLFxuICAnNjE3NlNFJzogJzIuMycsXG4gICc2MTgwU0UnOiAnMi41JyxcbiAgJzMyNTAnOiAnMi41JyxcbiAgJzMyNjAnOiAnMi43JyxcbiAgJzMyODAnOiAnMi40JyxcbiAgJzQyMjYnOiAnMi43JyxcbiAgJzQyMjgnOiAnMi44JyxcbiAgJzQyMzAnOiAnMi45JyxcbiAgJzQyMzQnOiAnMy4xJyxcbiAgJzQyMzgnOiAnMy4zJyxcbiAgJzQyNDAnOiAnMy40JyxcbiAgJzQyNTYnOiAnMS42JyxcbiAgJzQyNzQnOiAnMi41JyxcbiAgJzQyNzYnOiAnMi42JyxcbiAgJzQyODAnOiAnMi44JyxcbiAgJzQyODQnOiAnMy4wJyxcbiAgJzYyMDQnOiAnMy4zJyxcbiAgJzYyMTInOiAnMi42JyxcbiAgJzYyMjAnOiAnMy4wJyxcbiAgJzYyMzQnOiAnMi40JyxcbiAgJzYyMzgnOiAnMi42JyxcbiAgJzYyNjJIRSc6ICcxLjYnLFxuICAnNjI3Mic6ICcyLjEnLFxuICAnNjI3NCc6ICcyLjInLFxuICAnNjI3Nic6ICcyLjMnLFxuICAnNjI3OCc6ICcyLjQnLFxuICAnNjI4MlNFJzogJzIuNicsXG4gICc2Mjg0U0UnOiAnMi43JyxcbiAgJzYzMDgnOiAnMy41JyxcbiAgJzYzMjAnOiAnMi44JyxcbiAgJzYzMjgnOiAnMy4yJyxcbiAgJzYzMzhQJzogJzIuMycsXG4gICc2MzQ0JzogJzIuNicsXG4gICc2MzQ4JzogJzIuOCcsXG4gICc2MzY2JzogJzEuOCcsXG4gICc2MzcwUCc6ICcyLjAnLFxuICAnNjM3Nic6ICcyLjMnLFxuICAnNjM3OCc6ICcyLjQnLFxuICAnNjM4MCc6ICcyLjUnLFxuICAnNjM4Nic6ICcyLjgnLFxuICAnRlh8NDEwMCc6ICczLjYnLFxuICAnRlh8NDEyMCc6ICczLjknLFxuICAnRlh8NDEzMCc6ICczLjgnLFxuICAnRlh8NDE1MCc6ICczLjgnLFxuICAnRlh8NDE3MCc6ICc0LjInLFxuICAnRlh8NjEwMCc6ICczLjMnLFxuICAnRlh8NjEyMCc6ICczLjYnLFxuICAnRlh8NjEzMCc6ICczLjYnLFxuICAnRlh8NjIwMCc6ICczLjgnLFxuICAnRlh8ODEwMCc6ICcyLjgnLFxuICAnRlh8ODEyMCc6ICczLjEnLFxuICAnRlh8ODE0MCc6ICczLjInLFxuICAnRlh8ODE1MCc6ICczLjYnLFxuICAnRlh8ODE3MCc6ICczLjknLFxuICAnRlh8NDMwMCc6ICczLjgnLFxuICAnRlh8NDMyMCc6ICc0LjAnLFxuICAnRlh8NDM1MCc6ICc0LjInLFxuICAnRlh8NjMwMCc6ICczLjUnLFxuICAnRlh8NjM1MCc6ICczLjknLFxuICAnRlh8ODMwMCc6ICczLjMnLFxuICAnRlh8ODMxMCc6ICczLjQnLFxuICAnRlh8ODMyMCc6ICczLjUnLFxuICAnRlh8ODM1MCc6ICc0LjAnLFxuICAnRlh8ODM3MCc6ICc0LjAnLFxuICAnRlh8OTM3MCc6ICc0LjQnLFxuICAnRlh8OTU5MCc6ICc0LjcnLFxuICAnRlh8ODMyMEUnOiAnMy4yJyxcbiAgJ0ZYfDgzNzBFJzogJzMuMycsXG5cbiAgLy8gWkVOIERlc2t0b3AgQ1BVc1xuICAnMTIwMCc6ICczLjEnLFxuICAnUHJvIDEyMDAnOiAnMy4xJyxcbiAgJzEzMDBYJzogJzMuNScsXG4gICdQcm8gMTMwMCc6ICczLjUnLFxuICAnMTQwMCc6ICczLjInLFxuICAnMTUwMFgnOiAnMy41JyxcbiAgJ1BybyAxNTAwJzogJzMuNScsXG4gICcxNjAwJzogJzMuMicsXG4gICcxNjAwWCc6ICczLjYnLFxuICAnUHJvIDE2MDAnOiAnMy4yJyxcbiAgJzE3MDAnOiAnMy4wJyxcbiAgJ1BybyAxNzAwJzogJzMuMCcsXG4gICcxNzAwWCc6ICczLjQnLFxuICAnUHJvIDE3MDBYJzogJzMuNCcsXG4gICcxODAwWCc6ICczLjYnLFxuICAnMTkwMFgnOiAnMy44JyxcbiAgJzE5MjAnOiAnMy4yJyxcbiAgJzE5MjBYJzogJzMuNScsXG4gICcxOTUwWCc6ICczLjQnLFxuXG4gIC8vIFpFTiBEZXNrdG9wIEFQVXNcbiAgJzIwMEdFJzogJzMuMicsXG4gICdQcm8gMjAwR0UnOiAnMy4yJyxcbiAgJzIyMEdFJzogJzMuNCcsXG4gICcyNDBHRSc6ICczLjUnLFxuICAnMzAwMEcnOiAnMy41JyxcbiAgJzMwMEdFJzogJzMuNCcsXG4gICczMDUwR0UnOiAnMy40JyxcbiAgJzIyMDBHJzogJzMuNScsXG4gICdQcm8gMjIwMEcnOiAnMy41JyxcbiAgJzIyMDBHRSc6ICczLjInLFxuICAnUHJvIDIyMDBHRSc6ICczLjInLFxuICAnMjQwMEcnOiAnMy42JyxcbiAgJ1BybyAyNDAwRyc6ICczLjYnLFxuICAnMjQwMEdFJzogJzMuMicsXG4gICdQcm8gMjQwMEdFJzogJzMuMicsXG5cbiAgLy8gWkVOIE1vYmlsZSBBUFVzXG4gICdQcm8gMjAwVSc6ICcyLjMnLFxuICAnMzAwVSc6ICcyLjQnLFxuICAnMjIwMFUnOiAnMi41JyxcbiAgJzMyMDBVJzogJzIuNicsXG4gICcyMzAwVSc6ICcyLjAnLFxuICAnUHJvIDIzMDBVJzogJzIuMCcsXG4gICcyNTAwVSc6ICcyLjAnLFxuICAnUHJvIDI1MDBVJzogJzIuMicsXG4gICcyNjAwSCc6ICczLjInLFxuICAnMjcwMFUnOiAnMi4wJyxcbiAgJ1BybyAyNzAwVSc6ICcyLjInLFxuICAnMjgwMEgnOiAnMy4zJyxcblxuICAvLyBaRU4gU2VydmVyIFByb2Nlc3NvcnNcbiAgJzczNTEnOiAnMi40JyxcbiAgJzczNTFQJzogJzIuNCcsXG4gICc3NDAxJzogJzIuMCcsXG4gICc3NDAxUCc6ICcyLjAnLFxuICAnNzU1MVAnOiAnMi4wJyxcbiAgJzc1NTEnOiAnMi4wJyxcbiAgJzcyNTEnOiAnMi4xJyxcbiAgJzcyNjEnOiAnMi41JyxcbiAgJzcyODEnOiAnMi4xJyxcbiAgJzczMDEnOiAnMi4yJyxcbiAgJzczNzEnOiAnMy4xJyxcbiAgJzc0NTEnOiAnMi4zJyxcbiAgJzc1MDEnOiAnMi4wJyxcbiAgJzc1NzEnOiAnMi4yJyxcbiAgJzc2MDEnOiAnMi4yJyxcblxuICAvLyBaRU4gRW1iZWRkZWQgUHJvY2Vzc29yc1xuICAnVjE1MDBCJzogJzIuMicsXG4gICdWMTc4MEInOiAnMy4zNScsXG4gICdWMTIwMkInOiAnMi4zJyxcbiAgJ1YxNDA0SSc6ICcyLjAnLFxuICAnVjE2MDVCJzogJzIuMCcsXG4gICdWMTc1NkInOiAnMy4yNScsXG4gICdWMTgwN0InOiAnMy4zNScsXG5cbiAgJzMxMDEnOiAnMi4xJyxcbiAgJzMxNTEnOiAnMi43JyxcbiAgJzMyMDEnOiAnMS41JyxcbiAgJzMyNTEnOiAnMi41JyxcbiAgJzMyNTUnOiAnMi41JyxcbiAgJzMzMDEnOiAnMi4wJyxcbiAgJzMzNTEnOiAnMS45JyxcbiAgJzM0MDEnOiAnMS44NScsXG4gICczNDUxJzogJzIuMTUnLFxuXG4gIC8vIFpFTisgRGVza3RvcFxuICAnMTIwMHxBRic6ICczLjEnLFxuICAnMjMwMFgnOiAnMy41JyxcbiAgJzI1MDBYJzogJzMuNicsXG4gICcyNjAwJzogJzMuNCcsXG4gICcyNjAwRSc6ICczLjEnLFxuICAnMTYwMHxBRic6ICczLjInLFxuICAnMjYwMFgnOiAnMy42JyxcbiAgJzI3MDAnOiAnMy4yJyxcbiAgJzI3MDBFJzogJzIuOCcsXG4gICdQcm8gMjcwMCc6ICczLjInLFxuICAnMjcwMFgnOiAnMy43JyxcbiAgJ1BybyAyNzAwWCc6ICczLjYnLFxuICAnMjkyMFgnOiAnMy41JyxcbiAgJzI5NTBYJzogJzMuNScsXG4gICcyOTcwV1gnOiAnMy4wJyxcbiAgJzI5OTBXWCc6ICczLjAnLFxuXG4gIC8vIFpFTisgRGVza3RvcCBBUFVcbiAgJ1BybyAzMDBHRSc6ICczLjQnLFxuICAnUHJvIDMxMjVHRSc6ICczLjQnLFxuICAnMzE1MEcnOiAnMy41JyxcbiAgJ1BybyAzMTUwRyc6ICczLjUnLFxuICAnMzE1MEdFJzogJzMuMycsXG4gICdQcm8gMzE1MEdFJzogJzMuMycsXG4gICczMjAwRyc6ICczLjYnLFxuICAnUHJvIDMyMDBHJzogJzMuNicsXG4gICczMjAwR0UnOiAnMy4zJyxcbiAgJ1BybyAzMjAwR0UnOiAnMy4zJyxcbiAgJzMzNTBHJzogJzMuNicsXG4gICdQcm8gMzM1MEcnOiAnMy42JyxcbiAgJzMzNTBHRSc6ICczLjMnLFxuICAnUHJvIDMzNTBHRSc6ICczLjMnLFxuICAnMzQwMEcnOiAnMy43JyxcbiAgJ1BybyAzNDAwRyc6ICczLjcnLFxuICAnMzQwMEdFJzogJzMuMycsXG4gICdQcm8gMzQwMEdFJzogJzMuMycsXG5cbiAgLy8gWkVOKyBNb2JpbGVcbiAgJzMzMDBVJzogJzIuMScsXG4gICdQUk8gMzMwMFUnOiAnMi4xJyxcbiAgJzM0NTBVJzogJzIuMScsXG4gICczNTAwVSc6ICcyLjEnLFxuICAnUFJPIDM1MDBVJzogJzIuMScsXG4gICczNTAwQyc6ICcyLjEnLFxuICAnMzU1MEgnOiAnMi4xJyxcbiAgJzM1ODBVJzogJzIuMScsXG4gICczNzAwVSc6ICcyLjMnLFxuICAnUFJPIDM3MDBVJzogJzIuMycsXG4gICczNzAwQyc6ICcyLjMnLFxuICAnMzc1MEgnOiAnMi4zJyxcbiAgJzM3ODBVJzogJzIuMycsXG5cbiAgLy8gWkVOMiBEZXNrdG9wIENQVVNcbiAgJzMxMDAnOiAnMy42JyxcbiAgJzMzMDBYJzogJzMuOCcsXG4gICczNTAwJzogJzMuNicsXG4gICczNTAwWCc6ICczLjYnLFxuICAnMzYwMCc6ICczLjYnLFxuICAnUHJvIDM2MDAnOiAnMy42JyxcbiAgJzM2MDBYJzogJzMuOCcsXG4gICczNjAwWFQnOiAnMy44JyxcbiAgJ1BybyAzNzAwJzogJzMuNicsXG4gICczNzAwWCc6ICczLjYnLFxuICAnMzgwMFgnOiAnMy45JyxcbiAgJzM4MDBYVCc6ICczLjknLFxuICAnMzkwMCc6ICczLjEnLFxuICAnUHJvIDM5MDAnOiAnMy4xJyxcbiAgJzM5MDBYJzogJzMuOCcsXG4gICczOTAwWFQnOiAnMy44JyxcbiAgJzM5NTBYJzogJzMuNScsXG4gICczOTYwWCc6ICczLjgnLFxuICAnMzk3MFgnOiAnMy43JyxcbiAgJzM5OTBYJzogJzIuOScsXG4gICczOTQ1V1gnOiAnNC4wJyxcbiAgJzM5NTVXWCc6ICczLjknLFxuICAnMzk3NVdYJzogJzMuNScsXG4gICczOTk1V1gnOiAnMi43JyxcblxuICAvLyBaRU4yIERlc2t0b3AgQVBVc1xuICAnNDMwMEdFJzogJzMuNScsXG4gICdQcm8gNDMwMEdFJzogJzMuNScsXG4gICc0MzAwRyc6ICczLjgnLFxuICAnUHJvIDQzMDBHJzogJzMuOCcsXG4gICc0NjAwR0UnOiAnMy4zJyxcbiAgJ1BybyA0NjUwR0UnOiAnMy4zJyxcbiAgJzQ2MDBHJzogJzMuNycsXG4gICdQcm8gNDY1MEcnOiAnMy43JyxcbiAgJzQ3MDBHRSc6ICczLjEnLFxuICAnUHJvIDQ3NTBHRSc6ICczLjEnLFxuICAnNDcwMEcnOiAnMy42JyxcbiAgJ1BybyA0NzUwRyc6ICczLjYnLFxuICAnNDMwMFUnOiAnMi43JyxcbiAgJzQ0NTBVJzogJzIuNScsXG4gICdQcm8gNDQ1MFUnOiAnMi41JyxcbiAgJzQ1MDBVJzogJzIuMycsXG4gICc0NjAwVSc6ICcyLjEnLFxuICAnUFJPIDQ2NTBVJzogJzIuMScsXG4gICc0NjgwVSc6ICcyLjEnLFxuICAnNDYwMEhTJzogJzMuMCcsXG4gICc0NjAwSCc6ICczLjAnLFxuICAnNDcwMFUnOiAnMi4wJyxcbiAgJ1BSTyA0NzUwVSc6ICcxLjcnLFxuICAnNDgwMFUnOiAnMS44JyxcbiAgJzQ4MDBIUyc6ICcyLjknLFxuICAnNDgwMEgnOiAnMi45JyxcbiAgJzQ5MDBIUyc6ICczLjAnLFxuICAnNDkwMEgnOiAnMy4zJyxcbiAgJzUzMDBVJzogJzIuNicsXG4gICc1NTAwVSc6ICcyLjEnLFxuICAnNTcwMFUnOiAnMS44JyxcblxuICAvLyBaRU4yIC0gRVBZQ1xuICAnNzIzMlAnOiAnMy4xJyxcbiAgJzczMDJQJzogJzMuMCcsXG4gICc3NDAyUCc6ICcyLjgnLFxuICAnNzUwMlAnOiAnMi41JyxcbiAgJzc3MDJQJzogJzIuMCcsXG4gICc3MjUyJzogJzMuMScsXG4gICc3MjYyJzogJzMuMicsXG4gICc3MjcyJzogJzIuOScsXG4gICc3MjgyJzogJzIuOCcsXG4gICc3MzAyJzogJzMuMCcsXG4gICc3MzUyJzogJzIuMycsXG4gICc3NDAyJzogJzIuOCcsXG4gICc3NDUyJzogJzIuMzUnLFxuICAnNzUwMic6ICcyLjUnLFxuICAnNzUzMic6ICcyLjQnLFxuICAnNzU0Mic6ICcyLjknLFxuICAnNzU1Mic6ICcyLjInLFxuICAnNzY0Mic6ICcyLjMnLFxuICAnNzY2Mic6ICcyLjAnLFxuICAnNzcwMic6ICcyLjAnLFxuICAnNzc0Mic6ICcyLjI1JyxcbiAgJzdIMTInOiAnMi42JyxcbiAgJzdGMzInOiAnMy43JyxcbiAgJzdGNTInOiAnMy41JyxcbiAgJzdGNzInOiAnMy4yJyxcblxuICAvLyBFcHljIChNaWxhbilcblxuICAnNzc2Myc6ICcyLjQ1JyxcbiAgJzc3MTMnOiAnMi4wJyxcbiAgJzc3MTNQJzogJzIuMCcsXG4gICc3NjYzJzogJzIuMCcsXG4gICc3NjQzJzogJzIuMycsXG4gICc3NUYzJzogJzIuOTUnLFxuICAnNzU0Myc6ICcyLjgnLFxuICAnNzU0M1AnOiAnMi44JyxcbiAgJzc1MTMnOiAnMi42JyxcbiAgJzc0NTMnOiAnMi43NScsXG4gICc3NEYzJzogJzMuMicsXG4gICc3NDQzJzogJzIuODUnLFxuICAnNzQ0M1AnOiAnMi44NScsXG4gICc3NDEzJzogJzIuNjUnLFxuICAnNzNGMyc6ICczLjUnLFxuICAnNzM0Myc6ICczLjInLFxuICAnNzMxMyc6ICczLjAnLFxuICAnNzMxM1AnOiAnMy4wJyxcbiAgJzcyRjMnOiAnMy43JyxcblxuICAvLyBaRU4zXG4gICc1NjAwWCc6ICczLjcnLFxuICAnNTgwMFgnOiAnMy44JyxcbiAgJzU5MDBYJzogJzMuNycsXG4gICc1OTUwWCc6ICczLjQnXG59O1xuXG5cbmNvbnN0IHNvY2tldFR5cGVzID0ge1xuICAxOiAnT3RoZXInLFxuICAyOiAnVW5rbm93bicsXG4gIDM6ICdEYXVnaHRlciBCb2FyZCcsXG4gIDQ6ICdaSUYgU29ja2V0JyxcbiAgNTogJ1JlcGxhY2VtZW50L1BpZ2d5IEJhY2snLFxuICA2OiAnTm9uZScsXG4gIDc6ICdMSUYgU29ja2V0JyxcbiAgODogJ1Nsb3QgMScsXG4gIDk6ICdTbG90IDInLFxuICAxMDogJzM3MCBQaW4gU29ja2V0JyxcbiAgMTE6ICdTbG90IEEnLFxuICAxMjogJ1Nsb3QgTScsXG4gIDEzOiAnNDIzJyxcbiAgMTQ6ICdBIChTb2NrZXQgNDYyKScsXG4gIDE1OiAnNDc4JyxcbiAgMTY6ICc3NTQnLFxuICAxNzogJzk0MCcsXG4gIDE4OiAnOTM5JyxcbiAgMTk6ICdtUEdBNjA0JyxcbiAgMjA6ICdMR0E3NzEnLFxuICAyMTogJ0xHQTc3NScsXG4gIDIyOiAnUzEnLFxuICAyMzogJ0FNMicsXG4gIDI0OiAnRiAoMTIwNyknLFxuICAyNTogJ0xHQTEzNjYnLFxuICAyNjogJ0czNCcsXG4gIDI3OiAnQU0zJyxcbiAgMjg6ICdDMzInLFxuICAyOTogJ0xHQTExNTYnLFxuICAzMDogJ0xHQTE1NjcnLFxuICAzMTogJ1BHQTk4OEEnLFxuICAzMjogJ0JHQTEyODgnLFxuICAzMzogJ3JQR0E5ODhCJyxcbiAgMzQ6ICdCR0ExMDIzJyxcbiAgMzU6ICdCR0ExMjI0JyxcbiAgMzY6ICdMR0ExMTU1JyxcbiAgMzc6ICdMR0ExMzU2JyxcbiAgMzg6ICdMR0EyMDExJyxcbiAgMzk6ICdGUzEnLFxuICA0MDogJ0ZTMicsXG4gIDQxOiAnRk0xJyxcbiAgNDI6ICdGTTInLFxuICA0MzogJ0xHQTIwMTEtMycsXG4gIDQ0OiAnTEdBMTM1Ni0zJyxcbiAgNDU6ICdMR0ExMTUwJyxcbiAgNDY6ICdCR0ExMTY4JyxcbiAgNDc6ICdCR0ExMjM0JyxcbiAgNDg6ICdCR0ExMzY0JyxcbiAgNDk6ICdBTTQnLFxuICA1MDogJ0xHQTExNTEnLFxuICA1MTogJ0JHQTEzNTYnLFxuICA1MjogJ0JHQTE0NDAnLFxuICA1MzogJ0JHQTE1MTUnLFxuICA1NDogJ0xHQTM2NDctMScsXG4gIDU1OiAnU1AzJyxcbiAgNTY6ICdTUDNyMicsXG4gIDU3OiAnTEdBMjA2NicsXG4gIDU4OiAnQkdBMTM5MicsXG4gIDU5OiAnQkdBMTUxMCcsXG4gIDYwOiAnQkdBMTUyOCcsXG4gIDYxOiAnTEdBNDE4OScsXG4gIDYyOiAnTEdBMTIwMCcsXG4gIDYzOiAnTEdBNDY3NycsXG59O1xuXG5jb25zdCBzb2NrZXRUeXBlc0J5TmFtZSA9IHtcbiAgJ0xHQTExNTAnOiAnaTctNTc3NUMgaTMtNDM0MCBpMy00MTcwIEczMjUwIGkzLTQxNjBUIGkzLTQxNjAgRTMtMTIzMSBHMzI1OCBHMzI0MCBpNy00NzkwUyBpNy00NzkwSyBpNy00NzkwIGk1LTQ2OTBLIGk1LTQ2OTAgaTUtNDU5MFQgaTUtNDU5MFMgaTUtNDU5MCBpNS00NDYwIGkzLTQzNjAgaTMtNDE1MCBHMTgyMCBHMzQyMCBHMzIyMCBpNy00NzcxIGk1LTQ0NDAgaTMtNDMzMCBpMy00MTMwVCBpMy00MTMwIEUzLTEyMzAgaTctNDc3MFMgaTctNDc3MEsgaTctNDc3MCBpNS00NjcwSyBpNS00NjcwIGk1LTQ1NzBUIGk1LTQ1NzBTIGk1LTQ1NzAgaTUtNDQzMCcsXG4gICdMR0ExMTUxJzogJ2k5LTk5MDBLUyBFLTIyODhHIEUtMjIyNCBHNTQyMCBpOS05OTAwVCBpOS05OTAwIGk3LTk3MDBUIGk3LTk3MDBGIGk3LTk3MDBFIGk3LTk3MDAgaTUtOTYwMCBpNS05NTAwVCBpNS05NTAwRiBpNS05NTAwIGk1LTk0MDBUIGkzLTkzNTBLIGkzLTkzMDAgaTMtOTEwMFQgaTMtOTEwMEYgaTMtOTEwMCBHNDkzMCBpOS05OTAwS0YgaTctOTcwMEtGIGk1LTk2MDBLRiBpNS05NDAwRiBpNS05NDAwIGkzLTkzNTBLRiBpOS05OTAwSyBpNy05NzAwSyBpNS05NjAwSyBHNTUwMCBHNTQwMCBpNy04NzAwVCBpNy04MDg2SyBpNS04NjAwIGk1LTg1MDBUIGk1LTg1MDAgaTUtODQwMFQgaTMtODMwMCBpMy04MTAwVCBHNDkwMCBpNy04NzAwSyBpNy04NzAwIGk1LTg2MDBLIGk1LTg0MDAgaTMtODM1MEsgaTMtODEwMCBFMy0xMjcwIEc0NjAwIEc0NTYwIGk3LTc3MDBUIGk3LTc3MDBLIGk3LTc3MDAgaTUtNzYwMEsgaTUtNzYwMCBpNS03NTAwVCBpNS03NTAwIGk1LTc0MDAgaTMtNzM1MEsgaTMtNzMwMCBpMy03MTAwVCBpMy03MTAwIEczOTMwIEczOTAwIEc0NDAwIGk3LTY3MDBUIGk3LTY3MDBLIGk3LTY3MDAgaTUtNjYwMEsgaTUtNjYwMCBpNS02NTAwVCBpNS02NTAwIGk1LTY0MDBUIGk1LTY0MDAgaTMtNjMwMCBpMy02MTAwVCBpMy02MTAwIEUzLTEyNzAgRTMtMTI3MCBUNDUwMCBUNDQwMCcsXG4gICcxMTU1JzogJ0c0NDAgRzQ2MCBHNDY1IEc0NzAgRzUzMFQgRzU0MFQgRzU1MFQgRzE2MTBUIEcxNjIwVCBHNTMwIEc1NDAgRzE2MTAgRzU1MCBHMTYyMCBHNTU1IEcxNjMwIGkzLTIxMDBUIGkzLTIxMjBUIGkzLTMyMjBUIGkzLTMyNDBUIGkzLTMyNTBUIGkzLTIxMDAgaTMtMjEwNSBpMy0yMTAyIGkzLTMyMTAgaTMtMzIyMCBpMy0yMTI1IGkzLTIxMjAgaTMtMzIyNSBpMy0yMTMwIGkzLTMyNDUgaTMtMzI0MCBpMy0zMjUwIGk1LTM1NzBUIGk1LTI1MDBUIGk1LTI0MDBTIGk1LTI0MDVTIGk1LTIzOTBUIGk1LTMzMzBTIGk1LTI1MDBTIGk1LTMzMzVTIGk1LTIzMDAgaTUtMzQ1MFMgaTUtMzM0MFMgaTUtMzQ3MFMgaTUtMzQ3NVMgaTUtMzQ3MFQgaTUtMjMxMCBpNS0zNTUwUyBpNS0yMzIwIGk1LTMzMzAgaTUtMzM1MFAgaTUtMzQ1MCBpNS0yNDAwIGk1LTMzNDAgaTUtMzU3MFMgaTUtMjM4MFAgaTUtMjQ1MFAgaTUtMzQ3MCBpNS0yNTAwSyBpNS0zNTUwIGk1LTI1MDAgaTUtMzU3MCBpNS0zNTcwSyBpNS0yNTUwSyBpNy0zNzcwVCBpNy0yNjAwUyBpNy0zNzcwUyBpNy0yNjAwSyBpNy0yNjAwIGk3LTM3NzAgaTctMzc3MEsgaTctMjcwMEsgRzYyMFQgRzYzMFQgRzY0MFQgRzIwMjBUIEc2NDVUIEcyMTAwVCBHMjAzMFQgRzYyMiBHODYwVCBHNjIwIEc2MzIgRzIxMjBUIEc2MzAgRzY0MCBHMjAxMCBHODQwIEcyMDIwIEc4NTAgRzY0NSBHMjAzMCBHODYwIEcyMTIwIEc4NzAgRzIxMzAgRzIxNDAgRTMtMTIyMEwgRTMtMTIyMEwgRTMtMTI2MEwgRTMtMTI2NUwgRTMtMTIyMCBFMy0xMjI1IEUzLTEyMjAgRTMtMTIzNSBFMy0xMjI1IEUzLTEyMzAgRTMtMTIzMCBFMy0xMjQwIEUzLTEyNDUgRTMtMTI3MCBFMy0xMjc1IEUzLTEyNDAgRTMtMTI0NSBFMy0xMjcwIEUzLTEyODAgRTMtMTI3NSBFMy0xMjkwIEUzLTEyODAgRTMtMTI5MCdcbn07XG5cbmZ1bmN0aW9uIGdldFNvY2tldFR5cGVzQnlOYW1lKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvY2tldFR5cGVzQnlOYW1lKSB7XG4gICAgY29uc3QgbmFtZXMgPSBzb2NrZXRUeXBlc0J5TmFtZVtrZXldLnNwbGl0KCcgJyk7XG4gICAgbmFtZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZihlbGVtZW50KSA+PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcHVNYW51ZmFjdHVyZXIoc3RyKSB7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChzdHIuaW5kZXhPZignaW50ZWwnKSA+PSAwKSB7IHJlc3VsdCA9ICdJbnRlbCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdhbWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdBTUQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZigncWVtdScpID49IDApIHsgcmVzdWx0ID0gJ1FFTVUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaHlnb24nKSA+PSAwKSB7IHJlc3VsdCA9ICdIeWdvbic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdjZW50YXVyJykgPj0gMCkgeyByZXN1bHQgPSAnV2luQ2hpcC9WaWEnOyB9XG4gIGlmIChzdHIuaW5kZXhPZigndm13YXJlJykgPj0gMCkgeyByZXN1bHQgPSAnVk13YXJlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ1hlbicpID49IDApIHsgcmVzdWx0ID0gJ1hlbiBIeXBlcnZpc29yJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3RjZycpID49IDApIHsgcmVzdWx0ID0gJ1FFTVUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignYXBwbGUnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcHVCcmFuZE1hbnVmYWN0dXJlcihyZXMpIHtcbiAgcmVzLmJyYW5kID0gcmVzLmJyYW5kLnJlcGxhY2UoL1xcKFJcXCkrL2csICfCricpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gIHJlcy5icmFuZCA9IHJlcy5icmFuZC5yZXBsYWNlKC9cXChUTVxcKSsvZywgJ+KEoicpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gIHJlcy5icmFuZCA9IHJlcy5icmFuZC5yZXBsYWNlKC9cXChDXFwpKy9nLCAnwqknKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICByZXMuYnJhbmQgPSByZXMuYnJhbmQucmVwbGFjZSgvQ1BVKy9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgcmVzLm1hbnVmYWN0dXJlciA9IGNwdU1hbnVmYWN0dXJlcihyZXMuYnJhbmQpO1xuXG4gIGxldCBwYXJ0cyA9IHJlcy5icmFuZC5zcGxpdCgnICcpO1xuICBwYXJ0cy5zaGlmdCgpO1xuICByZXMuYnJhbmQgPSBwYXJ0cy5qb2luKCcgJyk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFNRFNwZWVkKGJyYW5kKSB7XG4gIGxldCByZXN1bHQgPSAnMCc7XG4gIGZvciAobGV0IGtleSBpbiBBTURCYXNlRnJlcXVlbmNpZXMpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChBTURCYXNlRnJlcXVlbmNpZXMsIGtleSkpIHtcbiAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgnfCcpO1xuICAgICAgbGV0IGZvdW5kID0gMDtcbiAgICAgIHBhcnRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmIChicmFuZC5pbmRleE9mKGl0ZW0pID4gLTEpIHtcbiAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3VuZCA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IEFNREJhc2VGcmVxdWVuY2llc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VGbG9hdChyZXN1bHQpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIC0gYnJhbmQsIHNwZWVkXG5cbmZ1bmN0aW9uIGdldENwdSgpIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IFVOS05PV04gPSAndW5rbm93bic7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBtYW51ZmFjdHVyZXI6IFVOS05PV04sXG4gICAgICAgIGJyYW5kOiBVTktOT1dOLFxuICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICBmYW1pbHk6ICcnLFxuICAgICAgICBtb2RlbDogJycsXG4gICAgICAgIHN0ZXBwaW5nOiAnJyxcbiAgICAgICAgcmV2aXNpb246ICcnLFxuICAgICAgICB2b2x0YWdlOiAnJyxcbiAgICAgICAgc3BlZWQ6IDAsXG4gICAgICAgIHNwZWVkTWluOiAwLFxuICAgICAgICBzcGVlZE1heDogMCxcbiAgICAgICAgZ292ZXJub3I6ICcnLFxuICAgICAgICBjb3JlczogdXRpbC5jb3JlcygpLFxuICAgICAgICBwaHlzaWNhbENvcmVzOiB1dGlsLmNvcmVzKCksXG4gICAgICAgIHBlcmZvcm1hbmNlQ29yZXM6IHV0aWwuY29yZXMoKSxcbiAgICAgICAgZWZmaWNpZW5jeUNvcmVzOiAwLFxuICAgICAgICBwcm9jZXNzb3JzOiAxLFxuICAgICAgICBzb2NrZXQ6ICcnLFxuICAgICAgICBmbGFnczogJycsXG4gICAgICAgIHZpcnR1YWxpemF0aW9uOiBmYWxzZSxcbiAgICAgICAgY2FjaGU6IHt9XG4gICAgICB9O1xuICAgICAgY3B1RmxhZ3MoKS50aGVuKGZsYWdzID0+IHtcbiAgICAgICAgcmVzdWx0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHJlc3VsdC52aXJ0dWFsaXphdGlvbiA9IGZsYWdzLmluZGV4T2YoJ3ZteCcpID4gLTEgfHwgZmxhZ3MuaW5kZXhPZignc3ZtJykgPiAtMTtcbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBleGVjKCdzeXNjdGwgbWFjaGRlcC5jcHUgaHcuY3B1ZnJlcXVlbmN5X21heCBody5jcHVmcmVxdWVuY3lfbWluIGh3LnBhY2thZ2VzIGh3LnBoeXNpY2FsY3B1X21heCBody5uY3B1IGh3LnRiZnJlcXVlbmN5IGh3LmNwdWZhbWlseSBody5jcHVzdWJmYW1pbHknLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxsaW5lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuY3B1LmJyYW5kX3N0cmluZycpO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxsaW5lUGFydHMgPSBtb2RlbGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IG1vZGVsbGluZVBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkID0gbW9kZWxsaW5lUGFydHNbMV0gPyBtb2RlbGxpbmVQYXJ0c1sxXS50cmltKCkgOiAnMCc7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBwYXJzZUZsb2F0KHNwZWVkLnJlcGxhY2UoL0dIeisvZywgJycpKTtcbiAgICAgICAgICAgIGxldCB0YkZyZXF1ZW5jeSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody50YmZyZXF1ZW5jeScpIC8gMTAwMDAwMDAwMC4wO1xuICAgICAgICAgICAgdGJGcmVxdWVuY3kgPSB0YkZyZXF1ZW5jeSA8IDAuMSA/IHRiRnJlcXVlbmN5ICogMTAwIDogdGJGcmVxdWVuY3k7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWQgPSByZXN1bHQuc3BlZWQgPT09IDAgPyB0YkZyZXF1ZW5jeSA6IHJlc3VsdC5zcGVlZDtcblxuICAgICAgICAgICAgX2NwdV9zcGVlZCA9IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNwdUJyYW5kTWFudWZhY3R1cmVyKHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNaW4gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1ZnJlcXVlbmN5X21pbicpID8gKHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVmcmVxdWVuY3lfbWluJykgLyAxMDAwMDAwMDAwLjApIDogcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWF4ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdWZyZXF1ZW5jeV9tYXgnKSA/ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1ZnJlcXVlbmN5X21heCcpIC8gMTAwMDAwMDAwMC4wKSA6IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5jcHUudmVuZG9yJykgfHwgJ0FwcGxlJztcbiAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5jcHUuZmFtaWx5JykgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdWZhbWlseScpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuY3B1Lm1vZGVsJyk7XG4gICAgICAgICAgICByZXN1bHQuc3RlcHBpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFjaGRlcC5jcHUuc3RlcHBpbmcnKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1c3ViZmFtaWx5Jyk7XG4gICAgICAgICAgICByZXN1bHQudmlydHVhbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY291bnRQcm9jZXNzb3JzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LnBhY2thZ2VzJyk7XG4gICAgICAgICAgICBjb25zdCBjb3VudENvcmVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LnBoeXNpY2FsY3B1X21heCcpO1xuICAgICAgICAgICAgY29uc3QgY291bnRUaHJlYWRzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3Lm5jcHUnKTtcbiAgICAgICAgICAgIGlmIChvcy5hcmNoKCkgPT09ICdhcm02NCcpIHtcbiAgICAgICAgICAgICAgY29uc3QgY2x1c3RlcnMgPSBleGVjU3luYygnaW9yZWcgLWMgSU9QbGF0Zm9ybURldmljZSAtZCAzIC1yIHwgZ3JlcCBjbHVzdGVyLXR5cGUnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgZWZmaWNpZW5jeUNvcmVzID0gY2x1c3RlcnMuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKCdcIkVcIicpID49IDApLmxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybWFuY2VDb3JlcyA9IGNsdXN0ZXJzLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZignXCJQXCInKSA+PSAwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSAnU09DJztcbiAgICAgICAgICAgICAgcmVzdWx0LmVmZmljaWVuY3lDb3JlcyA9IGVmZmljaWVuY3lDb3JlcztcbiAgICAgICAgICAgICAgcmVzdWx0LnBlcmZvcm1hbmNlQ29yZXMgPSBwZXJmb3JtYW5jZUNvcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50UHJvY2Vzc29ycykge1xuICAgICAgICAgICAgICByZXN1bHQucHJvY2Vzc29ycyA9IHBhcnNlSW50KGNvdW50UHJvY2Vzc29ycykgfHwgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudENvcmVzICYmIGNvdW50VGhyZWFkcykge1xuICAgICAgICAgICAgICByZXN1bHQuY29yZXMgPSBwYXJzZUludChjb3VudFRocmVhZHMpIHx8IHV0aWwuY29yZXMoKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsQ29yZXMgPSBwYXJzZUludChjb3VudENvcmVzKSB8fCB1dGlsLmNvcmVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHVDYWNoZSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICByZXN1bHQuY2FjaGUgPSByZXM7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICBsZXQgbW9kZWxsaW5lID0gJyc7XG4gICAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgICAgaWYgKG9zLmNwdXMoKVswXSAmJiBvcy5jcHVzKClbMF0ubW9kZWwpIHsgbW9kZWxsaW5lID0gb3MuY3B1cygpWzBdLm1vZGVsOyB9XG4gICAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBsc2NwdTsgZWNobyAtbiBcIkdvdmVybm9yOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy9zeXN0ZW0vY3B1L2NwdTAvY3B1ZnJlcS9zY2FsaW5nX2dvdmVybm9yIDI+L2Rldi9udWxsOyBlY2hvOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsbGluZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCBuYW1lJykgfHwgbW9kZWxsaW5lO1xuICAgICAgICAgICAgY29uc3QgbW9kZWxsaW5lUGFydHMgPSBtb2RlbGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IG1vZGVsbGluZVBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IG1vZGVsbGluZVBhcnRzWzFdID8gcGFyc2VGbG9hdChtb2RlbGxpbmVQYXJ0c1sxXS50cmltKCkpIDogMDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDAgJiYgKHJlc3VsdC5icmFuZC5pbmRleE9mKCdBTUQnKSA+IC0xIHx8IHJlc3VsdC5icmFuZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3J5emVuJykgPiAtMSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gZ2V0QU1EU3BlZWQocmVzdWx0LmJyYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGdldENwdUN1cnJlbnRTcGVlZFN5bmMoKTtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYXZnICE9PSAwKSB7IHJlc3VsdC5zcGVlZCA9IGN1cnJlbnQuYXZnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY3B1X3NwZWVkID0gcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWluID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjcHUgbWluIG1oeicpLnJlcGxhY2UoLywvZywgJy4nKSkgLyAxMC4wKSAvIDEwMDtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1heCA9IE1hdGgucm91bmQocGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY3B1IG1heCBtaHonKS5yZXBsYWNlKC8sL2csICcuJykpIC8gMTAuMCkgLyAxMDA7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGNwdUJyYW5kTWFudWZhY3R1cmVyKHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQudmVuZG9yID0gY3B1TWFudWZhY3R1cmVyKHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZW5kb3IgaWQnKSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY3B1IGZhbWlseScpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsOicpO1xuICAgICAgICAgICAgcmVzdWx0LnN0ZXBwaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N0ZXBwaW5nJyk7XG4gICAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY3B1IHJldmlzaW9uJyk7XG4gICAgICAgICAgICByZXN1bHQuY2FjaGUubDFkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wxZCBjYWNoZScpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMWQpIHsgcmVzdWx0LmNhY2hlLmwxZCA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMWQpICogKHJlc3VsdC5jYWNoZS5sMWQuaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHJlc3VsdC5jYWNoZS5sMWQuaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7IH1cbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDFpIGNhY2hlJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwxaSkgeyByZXN1bHQuY2FjaGUubDFpID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwxaSkgKiAocmVzdWx0LmNhY2hlLmwxaS5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocmVzdWx0LmNhY2hlLmwxaS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTsgfVxuICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wyIGNhY2hlJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwyKSB7IHJlc3VsdC5jYWNoZS5sMiA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMikgKiAocmVzdWx0LmNhY2hlLmwyLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChyZXN1bHQuY2FjaGUubDIuaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7IH1cbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMyBjYWNoZScpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMykgeyByZXN1bHQuY2FjaGUubDMgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDMpICogKHJlc3VsdC5jYWNoZS5sMy5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocmVzdWx0LmNhY2hlLmwzLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpOyB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRocmVhZHNQZXJDb3JlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3RocmVhZChzKSBwZXIgY29yZScpIHx8ICcxJztcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvcnMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc29ja2V0KHMpJykgfHwgJzEnO1xuICAgICAgICAgICAgbGV0IHRocmVhZHNQZXJDb3JlSW50ID0gcGFyc2VJbnQodGhyZWFkc1BlckNvcmUsIDEwKTsgLy8gdGhyZWFkcyBwZXIgY29kZSAobm9ybWFsbHkgb25seSBmb3IgcGVyZm9ybWFuY2UgY29yZXMpXG4gICAgICAgICAgICBsZXQgcHJvY2Vzc29yc0ludCA9IHBhcnNlSW50KHByb2Nlc3NvcnMsIDEwKSB8fCAxOyAgLy8gbnVtYmVyIG9mIHNvY2tldHMgLyAgcHJvY2Vzc29yIHVuaXRzIGluIG1hY2hpbmUgKG5vcm1hbGx5IDEpXG4gICAgICAgICAgICBjb25zdCBjb3Jlc1BlclNvY2tldCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjb3JlKHMpIHBlciBzb2NrZXQnKSwgMTApOyAvLyBudW1iZXIgb2YgY29yZXMgKGUuZy4gMTYgb24gaTEyOTAwKVxuICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsQ29yZXMgPSBjb3Jlc1BlclNvY2tldCA/IGNvcmVzUGVyU29ja2V0ICogcHJvY2Vzc29yc0ludCA6IHJlc3VsdC5jb3JlcyAvIHRocmVhZHNQZXJDb3JlSW50O1xuICAgICAgICAgICAgcmVzdWx0LnBlcmZvcm1hbmNlQ29yZXMgPSB0aHJlYWRzUGVyQ29yZUludCA+IDEgPyByZXN1bHQuY29yZXMgLSByZXN1bHQucGh5c2ljYWxDb3JlcyA6IHJlc3VsdC5jb3JlcztcbiAgICAgICAgICAgIHJlc3VsdC5lZmZpY2llbmN5Q29yZXMgPSB0aHJlYWRzUGVyQ29yZUludCA+IDEgPyByZXN1bHQuY29yZXMgLSAodGhyZWFkc1BlckNvcmVJbnQgKiByZXN1bHQucGVyZm9ybWFuY2VDb3JlcykgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LnByb2Nlc3NvcnMgPSBwcm9jZXNzb3JzSW50O1xuICAgICAgICAgICAgcmVzdWx0LmdvdmVybm9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2dvdmVybm9yJykgfHwgJyc7XG5cbiAgICAgICAgICAgIC8vIFRlc3QgUmFzcGJlcnJ5XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZlbmRvciA9PT0gJ0FSTScpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXNScGkgPSBmcy5yZWFkRmlsZVN5bmMoJy9wcm9jL2NwdWluZm8nKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgclBJUmV2aXNpb24gPSB1dGlsLmRlY29kZVBpQ3B1aW5mbyhsaW5lc1JwaSk7XG4gICAgICAgICAgICAgIGlmIChyUElSZXZpc2lvbi5tb2RlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3Jhc3BiZXJyeScpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gcmVzdWx0Lm1hbnVmYWN0dXJlcjtcbiAgICAgICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gclBJUmV2aXNpb24ubWFudWZhY3R1cmVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IHJQSVJldmlzaW9uLnByb2Nlc3NvcjtcbiAgICAgICAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSByUElSZXZpc2lvbi5yZXZpc2lvbkNvZGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9ICdTT0MnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNvY2tldCB0eXBlXG4gICAgICAgICAgICBsZXQgbGluZXMyID0gW107XG4gICAgICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSDigJN0IDQgMj4vZGV2L251bGwgfCBncmVwIFwiVXBncmFkZTogU29ja2V0XCI7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvcjIsIHN0ZG91dDIpIHtcbiAgICAgICAgICAgICAgbGluZXMyID0gc3Rkb3V0Mi50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVzMiAmJiBsaW5lczIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnVXBncmFkZScpLnJlcGxhY2UoJ1NvY2tldCcsICcnKS50cmltKCkgfHwgcmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIGxldCBtb2RlbGxpbmUgPSAnJztcbiAgICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgICBpZiAob3MuY3B1cygpWzBdICYmIG9zLmNwdXMoKVswXS5tb2RlbCkgeyBtb2RlbGxpbmUgPSBvcy5jcHVzKClbMF0ubW9kZWw7IH1cbiAgICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCA0OyBkbWlkZWNvZGUgLXQgNyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgbGV0IGNhY2hlID0gW107XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnIyBkbWlkZWNvZGUnKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gZGF0YS5sZW5ndGggPiAxID8gZGF0YVsxXSA6ICcnO1xuICAgICAgICAgICAgICBjYWNoZSA9IGRhdGEubGVuZ3RoID4gMiA/IGRhdGFbMl0uc3BsaXQoJ0NhY2hlIEluZm9ybWF0aW9uJykgOiBbXTtcblxuICAgICAgICAgICAgICBsaW5lcyA9IHByb2Nlc3Nvci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYnJhbmQgPSBtb2RlbGxpbmUuc3BsaXQoJ0AnKVswXS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBtb2RlbGxpbmUuc3BsaXQoJ0AnKVsxXSA/IHBhcnNlRmxvYXQobW9kZWxsaW5lLnNwbGl0KCdAJylbMV0udHJpbSgpKSA6IDA7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwICYmIChyZXN1bHQuYnJhbmQuaW5kZXhPZignQU1EJykgPiAtMSB8fCByZXN1bHQuYnJhbmQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyeXplbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IGdldEFNRFNwZWVkKHJlc3VsdC5icmFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRDcHVDdXJyZW50U3BlZWRTeW5jKCk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50LmF2ZyAhPT0gMCkgeyByZXN1bHQuc3BlZWQgPSBjdXJyZW50LmF2ZzsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NwdV9zcGVlZCA9IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1pbiA9IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1heCA9IE1hdGgucm91bmQocGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWF4IHNwZWVkJykucmVwbGFjZSgvTWh6L2csICcnKSkgLyAxMC4wKSAvIDEwMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gY3B1QnJhbmRNYW51ZmFjdHVyZXIocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSBjcHVNYW51ZmFjdHVyZXIodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicpKTtcbiAgICAgICAgICAgIGxldCBzaWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICBzaWcgPSBzaWcuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNpZ1tpXSA9IHNpZ1tpXS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gdXRpbC5nZXRWYWx1ZShzaWcsICdGYW1pbHknLCAnICcsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShzaWcsICdNb2RlbCcsICcgJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQuc3RlcHBpbmcgPSB1dGlsLmdldFZhbHVlKHNpZywgJ1N0ZXBwaW5nJywgJyAnLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9ICcnO1xuICAgICAgICAgICAgY29uc3Qgdm9sdGFnZSA9IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHRhZ2UnKSk7XG4gICAgICAgICAgICByZXN1bHQudm9sdGFnZSA9IGlzTmFOKHZvbHRhZ2UpID8gJycgOiB2b2x0YWdlLnRvRml4ZWQoMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxpbmVzID0gY2FjaGVbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsZXQgY2FjaGVUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NvY2tldCBEZXNpZ25hdGlvbicpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnICcsICctJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgY2FjaGVUeXBlID0gY2FjaGVUeXBlLmxlbmd0aCA/IGNhY2hlVHlwZVswXSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBzaXplUGFydHMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW5zdGFsbGVkIFNpemUnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KHNpemVQYXJ0c1swXSwgMTApO1xuICAgICAgICAgICAgICBjb25zdCB1bml0ID0gc2l6ZVBhcnRzLmxlbmd0aCA+IDEgPyBzaXplUGFydHNbMV0gOiAna2InO1xuICAgICAgICAgICAgICBzaXplID0gc2l6ZSAqICh1bml0ID09PSAna2InID8gMTAyNCA6ICh1bml0ID09PSAnbWInID8gMTAyNCAqIDEwMjQgOiAodW5pdCA9PT0gJ2diJyA/IDEwMjQgKiAxMDI0ICogMTAyNCA6IDEpKSk7XG4gICAgICAgICAgICAgIGlmIChjYWNoZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVUeXBlID09PSAnbDEnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlICsgJ2QnXSA9IHNpemUgLyAyO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZSArICdpJ10gPSBzaXplIC8gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZV0gPSBzaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29ja2V0IHR5cGVcbiAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVXBncmFkZScpLnJlcGxhY2UoJ1NvY2tldCcsICcnKS50cmltKCk7XG4gICAgICAgICAgICAvLyAjIHRocmVhZHMgLyAjIGNvcmVzXG4gICAgICAgICAgICBjb25zdCB0aHJlYWRDb3VudCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd0aHJlYWQgY291bnQnKS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBjb3JlQ291bnQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY29yZSBjb3VudCcpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChjb3JlQ291bnQgJiYgdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzID0gcGFyc2VJbnQodGhyZWFkQ291bnQsIDEwKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnBoeXNpY2FsQ29yZXMgPSBwYXJzZUludChjb3JlQ291bnQsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9wcm9jZXNzb3IgfCBzZWxlY3QgTmFtZSwgUmV2aXNpb24sIEwyQ2FjaGVTaXplLCBMM0NhY2hlU2l6ZSwgTWFudWZhY3R1cmVyLCBNYXhDbG9ja1NwZWVkLCBEZXNjcmlwdGlvbiwgVXBncmFkZU1ldGhvZCwgQ2FwdGlvbiwgTnVtYmVyT2ZMb2dpY2FsUHJvY2Vzc29ycywgTnVtYmVyT2ZDb3JlcyB8IGZsJykpO1xuICAgICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9DYWNoZU1lbW9yeSB8IHNlbGVjdCBDYWNoZVR5cGUsSW5zdGFsbGVkU2l6ZSxMZXZlbCB8IGZsJykpO1xuICAgICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJyhHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ29tcHV0ZXJTeXN0ZW0pLkh5cGVydmlzb3JQcmVzZW50JykpO1xuXG4gICAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhWzBdLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IG5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6JykgfHwgJyc7XG4gICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gbmFtZS5zcGxpdCgnQCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBuYW1lLnNwbGl0KCdAJylbMV0gPyBwYXJzZUZsb2F0KG5hbWUuc3BsaXQoJ0AnKVsxXS50cmltKCkpIDogMDtcbiAgICAgICAgICAgICAgICBfY3B1X3NwZWVkID0gcmVzdWx0LnNwZWVkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IG5hbWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3B1QnJhbmRNYW51ZmFjdHVyZXIocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3JldmlzaW9uJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxZCA9IDA7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWkgPSAwO1xuICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDJjYWNoZXNpemUnLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDNjYWNoZXNpemUnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwyKSB7IHJlc3VsdC5jYWNoZS5sMiA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMiwgMTApICogMTAyNDsgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlLmwzKSB7IHJlc3VsdC5jYWNoZS5sMyA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMywgMTApICogMTAyNDsgfVxuICAgICAgICAgICAgICByZXN1bHQudmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1heCA9IE1hdGgucm91bmQocGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWF4Y2xvY2tzcGVlZCcsICc6JykucmVwbGFjZSgvLC9nLCAnLicpKSAvIDEwLjApIC8gMTAwO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwICYmIChyZXN1bHQuYnJhbmQuaW5kZXhPZignQU1EJykgPiAtMSB8fCByZXN1bHQuYnJhbmQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyeXplbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gZ2V0QU1EU3BlZWQocmVzdWx0LmJyYW5kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gcmVzdWx0LnNwZWVkTWF4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1pbiA9IHJlc3VsdC5zcGVlZDtcblxuICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZGVzY3JpcHRpb24nLCAnOicpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb25baV0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdmYW1pbHknKSAmJiAoaSArIDEpIDwgZGVzY3JpcHRpb24ubGVuZ3RoICYmIGRlc2NyaXB0aW9uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IGRlc2NyaXB0aW9uW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uW2ldLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbW9kZWwnKSAmJiAoaSArIDEpIDwgZGVzY3JpcHRpb24ubGVuZ3RoICYmIGRlc2NyaXB0aW9uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gZGVzY3JpcHRpb25baSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb25baV0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdzdGVwcGluZycpICYmIChpICsgMSkgPCBkZXNjcmlwdGlvbi5sZW5ndGggJiYgZGVzY3JpcHRpb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuc3RlcHBpbmcgPSBkZXNjcmlwdGlvbltpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHNvY2tldCB0eXBlXG4gICAgICAgICAgICAgIGNvbnN0IHNvY2tldElkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VwZ3JhZGVNZXRob2QnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAoc29ja2V0VHlwZXNbc29ja2V0SWRdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldCA9IHNvY2tldFR5cGVzW3NvY2tldElkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzb2NrZXRCeU5hbWUgPSBnZXRTb2NrZXRUeXBlc0J5TmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHNvY2tldEJ5TmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSBzb2NrZXRCeU5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIyB0aHJlYWRzIC8gIyBjb3Jlc1xuICAgICAgICAgICAgICBjb25zdCBjb3VudFByb2Nlc3NvcnMgPSB1dGlsLmNvdW50TGluZXMobGluZXMsICdDYXB0aW9uJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50VGhyZWFkcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOdW1iZXJPZkxvZ2ljYWxQcm9jZXNzb3JzJywgJzonKTtcbiAgICAgICAgICAgICAgY29uc3QgY291bnRDb3JlcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOdW1iZXJPZkNvcmVzJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKGNvdW50UHJvY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9jZXNzb3JzID0gcGFyc2VJbnQoY291bnRQcm9jZXNzb3JzKSB8fCAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb3VudENvcmVzICYmIGNvdW50VGhyZWFkcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3JlcyA9IHBhcnNlSW50KGNvdW50VGhyZWFkcykgfHwgdXRpbC5jb3JlcygpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbENvcmVzID0gcGFyc2VJbnQoY291bnRDb3JlcykgfHwgdXRpbC5jb3JlcygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb3VudFByb2Nlc3NvcnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzID0gcmVzdWx0LmNvcmVzICogY291bnRQcm9jZXNzb3JzO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbENvcmVzID0gcmVzdWx0LnBoeXNpY2FsQ29yZXMgKiBjb3VudFByb2Nlc3NvcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBkYXRhWzFdLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHBhcnQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYWNoZVR5cGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMZXZlbCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbGxlZFNpemUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW5zdGFsbGVkU2l6ZScpO1xuICAgICAgICAgICAgICAgIC8vIEwxIEluc3RydWN0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzMnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFpID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMMSBEYXRhXG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnNCcpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWQgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEwxIGFsbFxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzUnICYmICFyZXN1bHQuY2FjaGUubDFpICYmICFyZXN1bHQuY2FjaGUubDFkKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFpID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApIC8gMjtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWQgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGh5cGVydiA9IGRhdGFbMl0gPyBkYXRhWzJdLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICAgICAgICByZXN1bHQudmlydHVhbGl6YXRpb24gPSBoeXBlcnYuaW5kZXhPZigndHJ1ZScpICE9PSAtMTtcblxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgLSBQcm9jZXNzb3IgRGF0YVxuXG5mdW5jdGlvbiBjcHUoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGdldENwdSgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNwdSA9IGNwdTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSAtIGN1cnJlbnQgc3BlZWQgLSBpbiBHSHpcblxuZnVuY3Rpb24gZ2V0Q3B1Q3VycmVudFNwZWVkU3luYygpIHtcblxuICBsZXQgY3B1cyA9IG9zLmNwdXMoKTtcbiAgbGV0IG1pbkZyZXEgPSA5OTk5OTk5OTk7XG4gIGxldCBtYXhGcmVxID0gMDtcbiAgbGV0IGF2Z0ZyZXEgPSAwO1xuICBsZXQgY29yZXMgPSBbXTtcblxuICBpZiAoY3B1cyAmJiBjcHVzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgaW4gY3B1cykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoY3B1cywgaSkpIHtcbiAgICAgICAgbGV0IGZyZXEgPSBjcHVzW2ldLnNwZWVkID4gMTAwID8gKGNwdXNbaV0uc3BlZWQgKyAxKSAvIDEwMDAgOiBjcHVzW2ldLnNwZWVkIC8gMTA7XG4gICAgICAgIGF2Z0ZyZXEgPSBhdmdGcmVxICsgZnJlcTtcbiAgICAgICAgaWYgKGZyZXEgPiBtYXhGcmVxKSB7IG1heEZyZXEgPSBmcmVxOyB9XG4gICAgICAgIGlmIChmcmVxIDwgbWluRnJlcSkgeyBtaW5GcmVxID0gZnJlcTsgfVxuICAgICAgICBjb3Jlcy5wdXNoKHBhcnNlRmxvYXQoZnJlcS50b0ZpeGVkKDIpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF2Z0ZyZXEgPSBhdmdGcmVxIC8gY3B1cy5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogcGFyc2VGbG9hdChtaW5GcmVxLnRvRml4ZWQoMikpLFxuICAgICAgbWF4OiBwYXJzZUZsb2F0KG1heEZyZXEudG9GaXhlZCgyKSksXG4gICAgICBhdmc6IHBhcnNlRmxvYXQoKGF2Z0ZyZXEpLnRvRml4ZWQoMikpLFxuICAgICAgY29yZXM6IGNvcmVzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAwLFxuICAgICAgYXZnOiAwLFxuICAgICAgY29yZXM6IGNvcmVzXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcHVDdXJyZW50U3BlZWQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBnZXRDcHVDdXJyZW50U3BlZWRTeW5jKCk7XG4gICAgICBpZiAocmVzdWx0LmF2ZyA9PT0gMCAmJiBfY3B1X3NwZWVkICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJDcHVTcGVlZCA9IHBhcnNlRmxvYXQoX2NwdV9zcGVlZCk7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBtaW46IGN1cnJDcHVTcGVlZCxcbiAgICAgICAgICBtYXg6IGN1cnJDcHVTcGVlZCxcbiAgICAgICAgICBhdmc6IGN1cnJDcHVTcGVlZCxcbiAgICAgICAgICBjb3JlczogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNwdUN1cnJlbnRTcGVlZCA9IGNwdUN1cnJlbnRTcGVlZDtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSAtIHRlbXBlcmF0dXJlXG4vLyBpZiBzZW5zb3JzIGFyZSBpbnN0YWxsZWRcblxuZnVuY3Rpb24gY3B1VGVtcGVyYXR1cmUoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG1haW46IG51bGwsXG4gICAgICAgIGNvcmVzOiBbXSxcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBzb2NrZXQ6IFtdLFxuICAgICAgICBjaGlwc2V0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAvLyBDUFUgQ2hpcHNldCwgU29ja2V0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY21kID0gJ2NhdCAvc3lzL2NsYXNzL3RoZXJtYWwvdGhlcm1hbF96b25lKi90eXBlICAyPi9kZXYvbnVsbDsgZWNobyBcIi0tLS0tXCI7IGNhdCAvc3lzL2NsYXNzL3RoZXJtYWwvdGhlcm1hbF96b25lKi90ZW1wIDI+L2Rldi9udWxsOyc7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJy0tLS0tXFxuJyk7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0c1swXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5lczIgPSBwYXJ0c1sxXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ2FjcGknKSAmJiBsaW5lczJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0LnB1c2goTWF0aC5yb3VuZChwYXJzZUludChsaW5lczJbaV0sIDEwKSAvIDEwMCkgLyAxMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgncGNoJykgJiYgbGluZXMyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNoaXBzZXQgPSBNYXRoLnJvdW5kKHBhcnNlSW50KGxpbmVzMltpXSwgMTApIC8gMTAwKSAvIDEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbWQgPSAnZm9yIG1vbiBpbiAvc3lzL2NsYXNzL2h3bW9uL2h3bW9uKjsgZG8gZm9yIGxhYmVsIGluIFwiJG1vblwiL3RlbXAqX2xhYmVsOyBkbyBpZiBbIC1mICRsYWJlbCBdOyB0aGVuIHZhbHVlPSR7bGFiZWwlXyp9X2lucHV0OyBlY2hvICQoY2F0IFwiJGxhYmVsXCIpX19fJChjYXQgXCIkdmFsdWVcIik7IGZpOyBkb25lOyBkb25lOyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBzdGRvdXQgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHRkaWVQb3MgPSBzdGRvdXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd0ZGllJyk7XG4gICAgICAgICAgICBpZiAodGRpZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnN1YnN0cmluZyh0ZGllUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJ19fXycpO1xuICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmxlbmd0aCA+IDEgJiYgcGFydHNbMV0gPyBwYXJ0c1sxXSA6ICcwJztcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIChsYWJlbCA9PT0gdW5kZWZpbmVkIHx8IChsYWJlbCAmJiBsYWJlbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NvcmUnKSkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzLnB1c2goTWF0aC5yb3VuZChwYXJzZUludCh2YWx1ZSwgMTApIC8gMTAwKSAvIDEwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiBsYWJlbCAmJiByZXN1bHQubWFpbiA9PT0gbnVsbCAmJiAobGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwYWNrYWdlJykgPj0gMCB8fCBsYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3BoeXNpY2FsJykgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IE1hdGgucm91bmQocGFyc2VJbnQodmFsdWUsIDEwKSAvIDEwMCkgLyAxMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuY29yZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1haW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IE1hdGgucm91bmQocmVzdWx0LmNvcmVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcmVzdWx0LmNvcmVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IG1heHRtcCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJlc3VsdC5jb3Jlcyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYXggPSAobWF4dG1wID4gcmVzdWx0Lm1haW4pID8gbWF4dG1wIDogcmVzdWx0Lm1haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm1haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gcmVzdWx0Lm1haW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjKCdzZW5zb3JzJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBsZXQgdGRpZVRlbXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXdTZWN0aW9uU3RhcnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgc2VjdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlY3Rpb25TdGFydHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTZWN0aW9uU3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2FjcGknKSkgeyBzZWN0aW9uID0gJ2FjcGknOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3BjaCcpKSB7IHNlY3Rpb24gPSAncGNoJzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjb3JlJykpIHsgc2VjdGlvbiA9ICdjb3JlJzsgfVxuICAgICAgICAgICAgICAgICAgICBuZXdTZWN0aW9uU3RhcnRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSAvWystXShbXsKwXSopL2c7XG4gICAgICAgICAgICAgICAgICBsZXQgdGVtcHMgPSBsaW5lLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdFBhcnQgPSBsaW5lLnNwbGl0KCc6JylbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uID09PSAnYWNwaScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29ja2V0IHRlbXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydC5pbmRleE9mKCdURU1QJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldC5wdXNoKHBhcnNlRmxvYXQodGVtcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWN0aW9uID09PSAncGNoJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGlwc2V0IHRlbXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydC5pbmRleE9mKCdURU1QJykgIT09IC0xICYmICFyZXN1bHQuY2hpcHNldCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jaGlwc2V0ID0gcGFyc2VGbG9hdCh0ZW1wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIGNwdSB0ZW1wXG4gICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmluZGV4T2YoJ1BIWVNJQ0FMJykgIT09IC0xIHx8IGZpcnN0UGFydC5pbmRleE9mKCdQQUNLQUdFJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gcGFyc2VGbG9hdCh0ZW1wcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmluZGV4T2YoJ0NPUkUgJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3Jlcy5wdXNoKHBhcnNlRmxvYXQodGVtcHMpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuaW5kZXhPZignVERJRScpICE9PSAtMSAmJiB0ZGllVGVtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0ZGllVGVtcCA9IHBhcnNlRmxvYXQodGVtcHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY29yZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBNYXRoLnJvdW5kKHJlc3VsdC5jb3Jlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHJlc3VsdC5jb3Jlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgbGV0IG1heHRtcCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHJlc3VsdC5jb3Jlcyk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gKG1heHRtcCA+IHJlc3VsdC5tYWluKSA/IG1heHRtcCA6IHJlc3VsdC5tYWluO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1haW4gPT09IG51bGwgJiYgdGRpZVRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSB0ZGllVGVtcDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHRkaWVUZW1wO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1haW4gIT09IG51bGwgfHwgcmVzdWx0Lm1heCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnMuc3RhdCgnL3N5cy9jbGFzcy90aGVybWFsL3RoZXJtYWxfem9uZTAvdGVtcCcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmcy5yZWFkRmlsZSgnL3N5cy9jbGFzcy90aGVybWFsL3RoZXJtYWxfem9uZTAvdGVtcCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gcGFyc2VGbG9hdChsaW5lc1swXSkgLyAxMDAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gcmVzdWx0Lm1haW47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBleGVjKCcvb3B0L3ZjL2Jpbi92Y2dlbmNtZCBtZWFzdXJlX3RlbXAnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzWzBdLmluZGV4T2YoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBwYXJzZUZsb2F0KGxpbmVzWzBdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHJlc3VsdC5tYWluO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ3N5c2N0bCBkZXYuY3B1IHwgZ3JlcCB0ZW1wJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcCA9IHBhcnNlRmxvYXQocGFydHNbMV0ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wID4gcmVzdWx0Lm1heCkgeyByZXN1bHQubWF4ID0gdGVtcDsgfVxuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIHRlbXA7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzLnB1c2godGVtcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb3Jlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBNYXRoLnJvdW5kKHN1bSAvIHJlc3VsdC5jb3Jlcy5sZW5ndGggKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAvKlxuICAgICAgICBsZXQgb3N4VGVtcCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy9vc3hUZW1wID0gcmVxdWlyZSgnb3N4LXRlbXBlcmF0dXJlLXNlbnNvcicpO1xuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIG9zeFRlbXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvc3hUZW1wKSB7XG4gICAgICAgICAgLy9yZXN1bHQgPSBvc3hUZW1wLmNwdVRlbXBlcmF0dXJlKCk7XG4gICAgICAgICAgLy8gcm91bmQgdG8gMiBkaWdpdHNcbiAgICAgICAgICBpZiAocmVzdWx0Lm1haW4pIHtcbiAgICAgICAgICAgIHJlc3VsdC5tYWluID0gTWF0aC5yb3VuZChyZXN1bHQubWFpbiAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQubWF4KSB7XG4gICAgICAgICAgICByZXN1bHQubWF4ID0gTWF0aC5yb3VuZChyZXN1bHQubWF4ICogMTAwKSAvIDEwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5jb3JlcyAmJiByZXN1bHQuY29yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5jb3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZXN1bHQuY29yZXNbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdC5jb3Jlc1tpXSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAqL1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBNU0FjcGlfVGhlcm1hbFpvbmVUZW1wZXJhdHVyZSAtTmFtZXNwYWNlIFwicm9vdC93bWlcIiB8IFNlbGVjdCBDdXJyZW50VGVtcGVyYXR1cmUnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJykuZmlsdGVyKChsaW5lLCBpZHgpID0+IGlkeCA+IDApO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gKHBhcnNlSW50KGxpbmUsIDEwKSAtIDI3MzIpIC8gMTA7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0Lm1heCkgeyByZXN1bHQubWF4ID0gdmFsdWU7IH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3Jlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gc3VtIC8gcmVzdWx0LmNvcmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNwdVRlbXBlcmF0dXJlID0gY3B1VGVtcGVyYXR1cmU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgRmxhZ3NcblxuZnVuY3Rpb24gY3B1RmxhZ3MoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoJ3JlZyBxdWVyeSBcIkhLRVlfTE9DQUxfTUFDSElORVxcXFxIQVJEV0FSRVxcXFxERVNDUklQVElPTlxcXFxTeXN0ZW1cXFxcQ2VudHJhbFByb2Nlc3NvclxcXFwwXCIgL3YgRmVhdHVyZVNldCcsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBmbGFnX2hleCA9IHN0ZG91dC5zcGxpdCgnMHgnKS5wb3AoKS50cmltKCk7XG4gICAgICAgICAgICAgIGxldCBmbGFnX2Jpbl91bnBhZGRlZCA9IHBhcnNlSW50KGZsYWdfaGV4LCAxNikudG9TdHJpbmcoMik7XG4gICAgICAgICAgICAgIGxldCBmbGFnX2JpbiA9ICcwJy5yZXBlYXQoMzIgLSBmbGFnX2Jpbl91bnBhZGRlZC5sZW5ndGgpICsgZmxhZ19iaW5fdW5wYWRkZWQ7XG4gICAgICAgICAgICAgIC8vIGVtcHR5IGZsYWdzIGFyZSB0aGUgcmVzZXJ2ZWQgZmllbGRzIGluIHRoZSBDUFVJRCBmZWF0dXJlIGJpdCBsaXN0XG4gICAgICAgICAgICAgIC8vIGFzIGZvdW5kIG9uIHdpa2lwZWRpYTpcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ1BVSURcbiAgICAgICAgICAgICAgbGV0IGFsbF9mbGFncyA9IFtcbiAgICAgICAgICAgICAgICAnZnB1JywgJ3ZtZScsICdkZScsICdwc2UnLCAndHNjJywgJ21zcicsICdwYWUnLCAnbWNlJywgJ2N4OCcsICdhcGljJyxcbiAgICAgICAgICAgICAgICAnJywgJ3NlcCcsICdtdHJyJywgJ3BnZScsICdtY2EnLCAnY21vdicsICdwYXQnLCAncHNlLTM2JywgJ3BzbicsICdjbGZzaCcsXG4gICAgICAgICAgICAgICAgJycsICdkcycsICdhY3BpJywgJ21teCcsICdmeHNyJywgJ3NzZScsICdzc2UyJywgJ3NzJywgJ2h0dCcsICd0bScsICdpYTY0JywgJ3BiZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBhbGxfZmxhZ3MubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ19iaW5bZl0gPT09ICcxJyAmJiBhbGxfZmxhZ3NbZl0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnICsgYWxsX2ZsYWdzW2ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgbHNjcHU7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnNwbGl0KCc6JylbMF0udG9VcHBlckNhc2UoKS5pbmRleE9mKCdGTEFHUycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGluZS5zcGxpdCgnOicpWzFdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICBmcy5yZWFkRmlsZSgnL3Byb2MvY3B1aW5mbycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZlYXR1cmVzJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgNCAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgZmxhZ3MgPSBbXTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFx0RmxhZ3M6Jyk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS5zcGxpdCgnXFx0VmVyc2lvbjonKVswXS5zcGxpdCgnXFxuJykgOiBbXTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgbGV0IGZsYWcgPSAobGluZS5pbmRleE9mKCcoJykgPyBsaW5lLnNwbGl0KCcoJylbMF0udG9Mb3dlckNhc2UoKSA6ICcnKS50cmltKCkucmVwbGFjZSgvXFx0L2csICcnKTtcbiAgICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmxhZ3Muam9pbignICcpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N5c2N0bCBtYWNoZGVwLmNwdS5mZWF0dXJlcycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbMF0uaW5kZXhPZignbWFjaGRlcC5jcHUuZmVhdHVyZXM6JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxpbmVzWzBdLnNwbGl0KCc6JylbMV0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jcHVGbGFncyA9IGNwdUZsYWdzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIENhY2hlXG5cbmZ1bmN0aW9uIGNwdUNhY2hlKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGwxZDogbnVsbCxcbiAgICAgICAgbDFpOiBudWxsLFxuICAgICAgICBsMjogbnVsbCxcbiAgICAgICAgbDM6IG51bGwsXG4gICAgICB9O1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgbHNjcHU7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9VcHBlckNhc2UoKS5pbmRleE9mKCdMMUQgQ0FDSEUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWQgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTDFJIENBQ0hFJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubDFpID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0wyIENBQ0hFJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubDIgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTDMgQ0FDSEUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMyA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IDcgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGNhY2hlID0gW107XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHN0ZG91dC50b1N0cmluZygpO1xuICAgICAgICAgICAgY2FjaGUgPSBkYXRhLnNwbGl0KCdDYWNoZSBJbmZvcm1hdGlvbicpO1xuICAgICAgICAgICAgY2FjaGUuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBjYWNoZVtpXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgY2FjaGVUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NvY2tldCBEZXNpZ25hdGlvbicpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnICcsICctJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGNhY2hlVHlwZSA9IGNhY2hlVHlwZS5sZW5ndGggPyBjYWNoZVR5cGVbMF0gOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHNpemVQYXJ0cyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnN0YWxsZWQgU2l6ZScpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KHNpemVQYXJ0c1swXSwgMTApO1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IHNpemVQYXJ0cy5sZW5ndGggPiAxID8gc2l6ZVBhcnRzWzFdIDogJ2tiJztcbiAgICAgICAgICAgIHNpemUgPSBzaXplICogKHVuaXQgPT09ICdrYicgPyAxMDI0IDogKHVuaXQgPT09ICdtYicgPyAxMDI0ICogMTAyNCA6ICh1bml0ID09PSAnZ2InID8gMTAyNCAqIDEwMjQgKiAxMDI0IDogMSkpKTtcbiAgICAgICAgICAgIGlmIChjYWNoZVR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGNhY2hlVHlwZSA9PT0gJ2wxJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGUgKyAnZCddID0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZSArICdpJ10gPSBzaXplIC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlXSA9IHNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3lzY3RsIGh3LmwxaWNhY2hlc2l6ZSBody5sMWRjYWNoZXNpemUgaHcubDJjYWNoZXNpemUgaHcubDNjYWNoZXNpemUnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdody5sMWljYWNoZXNpemUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubDFkID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h3LmwxZGNhY2hlc2l6ZScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sMWkgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHcubDJjYWNoZXNpemUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubDIgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHcubDNjYWNoZXNpemUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubDMgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX3Byb2Nlc3NvciB8IHNlbGVjdCBMMkNhY2hlU2l6ZSwgTDNDYWNoZVNpemUgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmwxZCA9IDA7XG4gICAgICAgICAgICAgIHJlc3VsdC5sMWkgPSAwO1xuICAgICAgICAgICAgICByZXN1bHQubDIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDJjYWNoZXNpemUnLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQubDMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDNjYWNoZXNpemUnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmwyKSB7IHJlc3VsdC5sMiA9IHBhcnNlSW50KHJlc3VsdC5sMiwgMTApICogMTAyNDsgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LmwzKSB7IHJlc3VsdC5sMyA9IHBhcnNlSW50KHJlc3VsdC5sMywgMTApICogMTAyNDsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ2FjaGVNZW1vcnkgfCBzZWxlY3QgQ2FjaGVUeXBlLEluc3RhbGxlZFNpemUsTGV2ZWwgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYWNoZVR5cGUnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxldmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xldmVsJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YWxsZWRTaXplID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0luc3RhbGxlZFNpemUnKTtcbiAgICAgICAgICAgICAgICAgIC8vIEwxIEluc3RydWN0aW9uc1xuICAgICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAnMycgJiYgY2FjaGVUeXBlID09PSAnMycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxaSA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEwxIERhdGFcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWQgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBMMSBhbGxcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzUnICYmICFyZXN1bHQubDFpICYmICFyZXN1bHQubDFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWkgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubDFkID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApIC8gMjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNwdUNhY2hlID0gY3B1Q2FjaGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgLSBjdXJyZW50IGxvYWQgLSBpbiAlXG5cbmZ1bmN0aW9uIGdldExvYWQoKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgbG9hZHMgPSBvcy5sb2FkYXZnKCkubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IC8gdXRpbC5jb3JlcygpOyB9KTtcbiAgICAgIGxldCBhdmdMb2FkID0gcGFyc2VGbG9hdCgoTWF0aC5tYXguYXBwbHkoTWF0aCwgbG9hZHMpKS50b0ZpeGVkKDIpKTtcbiAgICAgIGxldCByZXN1bHQgPSB7fTtcblxuICAgICAgbGV0IG5vdyA9IERhdGUubm93KCkgLSBfY3VycmVudF9jcHUubXM7XG4gICAgICBpZiAobm93ID49IDIwMCkge1xuICAgICAgICBfY3VycmVudF9jcHUubXMgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBjcHVzID0gb3MuY3B1cygpO1xuICAgICAgICBsZXQgdG90YWxVc2VyID0gMDtcbiAgICAgICAgbGV0IHRvdGFsU3lzdGVtID0gMDtcbiAgICAgICAgbGV0IHRvdGFsTmljZSA9IDA7XG4gICAgICAgIGxldCB0b3RhbElycSA9IDA7XG4gICAgICAgIGxldCB0b3RhbElkbGUgPSAwO1xuICAgICAgICBsZXQgY29yZXMgPSBbXTtcbiAgICAgICAgX2NvcmVjb3VudCA9IChjcHVzICYmIGNwdXMubGVuZ3RoKSA/IGNwdXMubGVuZ3RoIDogMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9jb3JlY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNwdSA9IGNwdXNbaV0udGltZXM7XG4gICAgICAgICAgdG90YWxVc2VyICs9IGNwdS51c2VyO1xuICAgICAgICAgIHRvdGFsU3lzdGVtICs9IGNwdS5zeXM7XG4gICAgICAgICAgdG90YWxOaWNlICs9IGNwdS5uaWNlO1xuICAgICAgICAgIHRvdGFsSWRsZSArPSBjcHUuaWRsZTtcbiAgICAgICAgICB0b3RhbElycSArPSBjcHUuaXJxO1xuICAgICAgICAgIGxldCB0bXBUaWNrID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLnRvdGFsVGljayA/IF9jcHVzW2ldLnRvdGFsVGljayA6IDApO1xuICAgICAgICAgIGxldCB0bXBMb2FkID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLnRvdGFsTG9hZCA/IF9jcHVzW2ldLnRvdGFsTG9hZCA6IDApO1xuICAgICAgICAgIGxldCB0bXBVc2VyID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLnVzZXIgPyBfY3B1c1tpXS51c2VyIDogMCk7XG4gICAgICAgICAgbGV0IHRtcFN5c3RlbSA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS5zeXMgPyBfY3B1c1tpXS5zeXMgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wTmljZSA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS5uaWNlID8gX2NwdXNbaV0ubmljZSA6IDApO1xuICAgICAgICAgIGxldCB0bXBJZGxlID0gKF9jcHVzICYmIF9jcHVzW2ldICYmIF9jcHVzW2ldLmlkbGUgPyBfY3B1c1tpXS5pZGxlIDogMCk7XG4gICAgICAgICAgbGV0IHRtcElycSA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS5pcnEgPyBfY3B1c1tpXS5pcnEgOiAwKTtcbiAgICAgICAgICBfY3B1c1tpXSA9IGNwdTtcbiAgICAgICAgICBfY3B1c1tpXS50b3RhbFRpY2sgPSBfY3B1c1tpXS51c2VyICsgX2NwdXNbaV0uc3lzICsgX2NwdXNbaV0ubmljZSArIF9jcHVzW2ldLmlycSArIF9jcHVzW2ldLmlkbGU7XG4gICAgICAgICAgX2NwdXNbaV0udG90YWxMb2FkID0gX2NwdXNbaV0udXNlciArIF9jcHVzW2ldLnN5cyArIF9jcHVzW2ldLm5pY2UgKyBfY3B1c1tpXS5pcnE7XG4gICAgICAgICAgX2NwdXNbaV0uY3VycmVudFRpY2sgPSBfY3B1c1tpXS50b3RhbFRpY2sgLSB0bXBUaWNrO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWQgPSAoX2NwdXNbaV0udG90YWxMb2FkIC0gdG1wTG9hZCk7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZFVzZXIgPSAoX2NwdXNbaV0udXNlciAtIHRtcFVzZXIpO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWRTeXN0ZW0gPSAoX2NwdXNbaV0uc3lzIC0gdG1wU3lzdGVtKTtcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkTmljZSA9IChfY3B1c1tpXS5uaWNlIC0gdG1wTmljZSk7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZElkbGUgPSAoX2NwdXNbaV0uaWRsZSAtIHRtcElkbGUpO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWRJcnEgPSAoX2NwdXNbaV0uaXJxIC0gdG1wSXJxKTtcbiAgICAgICAgICBjb3Jlc1tpXSA9IHt9O1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWQgPSBfY3B1c1tpXS5sb2FkIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZFVzZXIgPSBfY3B1c1tpXS5sb2FkVXNlciAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRTeXN0ZW0gPSBfY3B1c1tpXS5sb2FkU3lzdGVtIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZE5pY2UgPSBfY3B1c1tpXS5sb2FkTmljZSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRJZGxlID0gX2NwdXNbaV0ubG9hZElkbGUgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkSXJxID0gX2NwdXNbaV0ubG9hZElycSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWQgPSBfY3B1c1tpXS5sb2FkO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRVc2VyID0gX2NwdXNbaV0ubG9hZFVzZXI7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZFN5c3RlbSA9IF9jcHVzW2ldLmxvYWRTeXN0ZW07XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZE5pY2UgPSBfY3B1c1tpXS5sb2FkTmljZTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkSWRsZSA9IF9jcHVzW2ldLmxvYWRJZGxlO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRJcnEgPSBfY3B1c1tpXS5sb2FkSXJxO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbFRpY2sgPSB0b3RhbFVzZXIgKyB0b3RhbFN5c3RlbSArIHRvdGFsTmljZSArIHRvdGFsSXJxICsgdG90YWxJZGxlO1xuICAgICAgICBsZXQgdG90YWxMb2FkID0gdG90YWxVc2VyICsgdG90YWxTeXN0ZW0gKyB0b3RhbE5pY2UgKyB0b3RhbElycTtcbiAgICAgICAgbGV0IGN1cnJlbnRUaWNrID0gdG90YWxUaWNrIC0gX2N1cnJlbnRfY3B1LnRpY2s7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBhdmdMb2FkOiBhdmdMb2FkLFxuICAgICAgICAgIGN1cnJlbnRMb2FkOiAodG90YWxMb2FkIC0gX2N1cnJlbnRfY3B1LmxvYWQpIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgY3VycmVudExvYWRVc2VyOiAodG90YWxVc2VyIC0gX2N1cnJlbnRfY3B1LnVzZXIpIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgY3VycmVudExvYWRTeXN0ZW06ICh0b3RhbFN5c3RlbSAtIF9jdXJyZW50X2NwdS5zeXN0ZW0pIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgY3VycmVudExvYWROaWNlOiAodG90YWxOaWNlIC0gX2N1cnJlbnRfY3B1Lm5pY2UpIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgY3VycmVudExvYWRJZGxlOiAodG90YWxJZGxlIC0gX2N1cnJlbnRfY3B1LmlkbGUpIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgY3VycmVudExvYWRJcnE6ICh0b3RhbElycSAtIF9jdXJyZW50X2NwdS5pcnEpIC8gY3VycmVudFRpY2sgKiAxMDAsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWQ6ICh0b3RhbExvYWQgLSBfY3VycmVudF9jcHUubG9hZCksXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRVc2VyOiAodG90YWxVc2VyIC0gX2N1cnJlbnRfY3B1LnVzZXIpLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkU3lzdGVtOiAodG90YWxTeXN0ZW0gLSBfY3VycmVudF9jcHUuc3lzdGVtKSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZE5pY2U6ICh0b3RhbE5pY2UgLSBfY3VycmVudF9jcHUubmljZSksXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJZGxlOiAodG90YWxJZGxlIC0gX2N1cnJlbnRfY3B1LmlkbGUpLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSXJxOiAodG90YWxJcnEgLSBfY3VycmVudF9jcHUuaXJxKSxcbiAgICAgICAgICBjcHVzOiBjb3Jlc1xuICAgICAgICB9O1xuICAgICAgICBfY3VycmVudF9jcHUgPSB7XG4gICAgICAgICAgdXNlcjogdG90YWxVc2VyLFxuICAgICAgICAgIG5pY2U6IHRvdGFsTmljZSxcbiAgICAgICAgICBzeXN0ZW06IHRvdGFsU3lzdGVtLFxuICAgICAgICAgIGlkbGU6IHRvdGFsSWRsZSxcbiAgICAgICAgICBpcnE6IHRvdGFsSXJxLFxuICAgICAgICAgIHRpY2s6IHRvdGFsVGljayxcbiAgICAgICAgICBsb2FkOiB0b3RhbExvYWQsXG4gICAgICAgICAgbXM6IF9jdXJyZW50X2NwdS5tcyxcbiAgICAgICAgICBjdXJyZW50TG9hZDogcmVzdWx0LmN1cnJlbnRMb2FkLFxuICAgICAgICAgIGN1cnJlbnRMb2FkVXNlcjogcmVzdWx0LmN1cnJlbnRMb2FkVXNlcixcbiAgICAgICAgICBjdXJyZW50TG9hZFN5c3RlbTogcmVzdWx0LmN1cnJlbnRMb2FkU3lzdGVtLFxuICAgICAgICAgIGN1cnJlbnRMb2FkTmljZTogcmVzdWx0LmN1cnJlbnRMb2FkTmljZSxcbiAgICAgICAgICBjdXJyZW50TG9hZElkbGU6IHJlc3VsdC5jdXJyZW50TG9hZElkbGUsXG4gICAgICAgICAgY3VycmVudExvYWRJcnE6IHJlc3VsdC5jdXJyZW50TG9hZElycSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZDogcmVzdWx0LnJhd0N1cnJlbnRMb2FkLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkVXNlcjogcmVzdWx0LnJhd0N1cnJlbnRMb2FkVXNlcixcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFN5c3RlbTogcmVzdWx0LnJhd0N1cnJlbnRMb2FkU3lzdGVtLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkTmljZTogcmVzdWx0LnJhd0N1cnJlbnRMb2FkTmljZSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElkbGU6IHJlc3VsdC5yYXdDdXJyZW50TG9hZElkbGUsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJcnE6IHJlc3VsdC5yYXdDdXJyZW50TG9hZElycSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb3JlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9jb3JlY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvcmVzW2ldID0ge307XG4gICAgICAgICAgY29yZXNbaV0ubG9hZCA9IF9jcHVzW2ldLmxvYWQgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkVXNlciA9IF9jcHVzW2ldLmxvYWRVc2VyIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZFN5c3RlbSA9IF9jcHVzW2ldLmxvYWRTeXN0ZW0gLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkTmljZSA9IF9jcHVzW2ldLmxvYWROaWNlIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZElkbGUgPSBfY3B1c1tpXS5sb2FkSWRsZSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRJcnEgPSBfY3B1c1tpXS5sb2FkSXJxIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZCA9IF9jcHVzW2ldLmxvYWQ7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZFVzZXIgPSBfY3B1c1tpXS5sb2FkVXNlcjtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkU3lzdGVtID0gX2NwdXNbaV0ubG9hZFN5c3RlbTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkTmljZSA9IF9jcHVzW2ldLmxvYWROaWNlO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRJZGxlID0gX2NwdXNbaV0ubG9hZElkbGU7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZElycSA9IF9jcHVzW2ldLmxvYWRJcnE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGF2Z0xvYWQ6IGF2Z0xvYWQsXG4gICAgICAgICAgY3VycmVudExvYWQ6IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZCxcbiAgICAgICAgICBjdXJyZW50TG9hZFVzZXI6IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZFVzZXIsXG4gICAgICAgICAgY3VycmVudExvYWRTeXN0ZW06IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZFN5c3RlbSxcbiAgICAgICAgICBjdXJyZW50TG9hZE5pY2U6IF9jdXJyZW50X2NwdS5jdXJyZW50TG9hZE5pY2UsXG4gICAgICAgICAgY3VycmVudExvYWRJZGxlOiBfY3VycmVudF9jcHUuY3VycmVudExvYWRJZGxlLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSXJxOiBfY3VycmVudF9jcHUuY3VycmVudExvYWRJcnEsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWQ6IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZCxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFVzZXI6IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZFVzZXIsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRTeXN0ZW06IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZFN5c3RlbSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZE5pY2U6IF9jdXJyZW50X2NwdS5yYXdDdXJyZW50TG9hZE5pY2UsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJZGxlOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWRJZGxlLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSXJxOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWRJcnEsXG4gICAgICAgICAgY3B1czogY29yZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGN1cnJlbnRMb2FkKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBnZXRMb2FkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3VycmVudExvYWQgPSBjdXJyZW50TG9hZDtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBTIC0gZnVsbCBsb2FkXG4vLyBzaW5jZSBib290dXBcblxuZnVuY3Rpb24gZ2V0RnVsbExvYWQoKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGNvbnN0IGNwdXMgPSBvcy5jcHVzKCk7XG4gICAgICBsZXQgdG90YWxVc2VyID0gMDtcbiAgICAgIGxldCB0b3RhbFN5c3RlbSA9IDA7XG4gICAgICBsZXQgdG90YWxOaWNlID0gMDtcbiAgICAgIGxldCB0b3RhbElycSA9IDA7XG4gICAgICBsZXQgdG90YWxJZGxlID0gMDtcblxuICAgICAgbGV0IHJlc3VsdCA9IDA7XG5cbiAgICAgIGlmIChjcHVzICYmIGNwdXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjcHVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY3B1ID0gY3B1c1tpXS50aW1lcztcbiAgICAgICAgICB0b3RhbFVzZXIgKz0gY3B1LnVzZXI7XG4gICAgICAgICAgdG90YWxTeXN0ZW0gKz0gY3B1LnN5cztcbiAgICAgICAgICB0b3RhbE5pY2UgKz0gY3B1Lm5pY2U7XG4gICAgICAgICAgdG90YWxJcnEgKz0gY3B1LmlycTtcbiAgICAgICAgICB0b3RhbElkbGUgKz0gY3B1LmlkbGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsVGlja3MgPSB0b3RhbElkbGUgKyB0b3RhbElycSArIHRvdGFsTmljZSArIHRvdGFsU3lzdGVtICsgdG90YWxVc2VyO1xuICAgICAgICByZXN1bHQgPSAodG90YWxUaWNrcyAtIHRvdGFsSWRsZSkgLyB0b3RhbFRpY2tzICogMTAwLjA7XG5cbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGxMb2FkKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBnZXRGdWxsTG9hZCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmZ1bGxMb2FkID0gZnVsbExvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGRvY2tlci5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDEzLiBEb2NrZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgRG9ja2VyU29ja2V0ID0gcmVxdWlyZSgnLi9kb2NrZXJTb2NrZXQnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuXG5sZXQgX2RvY2tlcl9jb250YWluZXJfc3RhdHMgPSB7fTtcbmxldCBfZG9ja2VyX3NvY2tldDtcbmxldCBfZG9ja2VyX2xhc3RfcmVhZCA9IDA7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdldCBjb250YWluZXJzIChwYXJhbWV0ZXIgYWxsOiBnZXQgYWxzbyBpbmFjdGl2ZS9leGl0ZWQgY29udGFpbmVycylcblxuZnVuY3Rpb24gZG9ja2VySW5mbyhjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgX2RvY2tlcl9zb2NrZXQuZ2V0SW5mbygoZGF0YSkgPT4ge1xuICAgICAgICByZXN1bHQuaWQgPSBkYXRhLklEO1xuICAgICAgICByZXN1bHQuY29udGFpbmVycyA9IGRhdGEuQ29udGFpbmVycztcbiAgICAgICAgcmVzdWx0LmNvbnRhaW5lcnNSdW5uaW5nID0gZGF0YS5Db250YWluZXJzUnVubmluZztcbiAgICAgICAgcmVzdWx0LmNvbnRhaW5lcnNQYXVzZWQgPSBkYXRhLkNvbnRhaW5lcnNQYXVzZWQ7XG4gICAgICAgIHJlc3VsdC5jb250YWluZXJzU3RvcHBlZCA9IGRhdGEuQ29udGFpbmVyc1N0b3BwZWQ7XG4gICAgICAgIHJlc3VsdC5pbWFnZXMgPSBkYXRhLkltYWdlcztcbiAgICAgICAgcmVzdWx0LmRyaXZlciA9IGRhdGEuRHJpdmVyO1xuICAgICAgICByZXN1bHQubWVtb3J5TGltaXQgPSBkYXRhLk1lbW9yeUxpbWl0O1xuICAgICAgICByZXN1bHQuc3dhcExpbWl0ID0gZGF0YS5Td2FwTGltaXQ7XG4gICAgICAgIHJlc3VsdC5rZXJuZWxNZW1vcnkgPSBkYXRhLktlcm5lbE1lbW9yeTtcbiAgICAgICAgcmVzdWx0LmNwdUNmc1BlcmlvZCA9IGRhdGEuQ3B1Q2ZzUGVyaW9kO1xuICAgICAgICByZXN1bHQuY3B1Q2ZzUXVvdGEgPSBkYXRhLkNwdUNmc1F1b3RhO1xuICAgICAgICByZXN1bHQuY3B1U2hhcmVzID0gZGF0YS5DUFVTaGFyZXM7XG4gICAgICAgIHJlc3VsdC5jcHVTZXQgPSBkYXRhLkNQVVNldDtcbiAgICAgICAgcmVzdWx0LmlwdjRGb3J3YXJkaW5nID0gZGF0YS5JUHY0Rm9yd2FyZGluZztcbiAgICAgICAgcmVzdWx0LmJyaWRnZU5mSXB0YWJsZXMgPSBkYXRhLkJyaWRnZU5mSXB0YWJsZXM7XG4gICAgICAgIHJlc3VsdC5icmlkZ2VOZklwNnRhYmxlcyA9IGRhdGEuQnJpZGdlTmZJcDZ0YWJsZXM7XG4gICAgICAgIHJlc3VsdC5kZWJ1ZyA9IGRhdGEuRGVidWc7XG4gICAgICAgIHJlc3VsdC5uZmQgPSBkYXRhLk5GZDtcbiAgICAgICAgcmVzdWx0Lm9vbUtpbGxEaXNhYmxlID0gZGF0YS5Pb21LaWxsRGlzYWJsZTtcbiAgICAgICAgcmVzdWx0Lm5nb3JvdXRpbmVzID0gZGF0YS5OR29yb3V0aW5lcztcbiAgICAgICAgcmVzdWx0LnN5c3RlbVRpbWUgPSBkYXRhLlN5c3RlbVRpbWU7XG4gICAgICAgIHJlc3VsdC5sb2dnaW5nRHJpdmVyID0gZGF0YS5Mb2dnaW5nRHJpdmVyO1xuICAgICAgICByZXN1bHQuY2dyb3VwRHJpdmVyID0gZGF0YS5DZ3JvdXBEcml2ZXI7XG4gICAgICAgIHJlc3VsdC5uRXZlbnRzTGlzdGVuZXIgPSBkYXRhLk5FdmVudHNMaXN0ZW5lcjtcbiAgICAgICAgcmVzdWx0Lmtlcm5lbFZlcnNpb24gPSBkYXRhLktlcm5lbFZlcnNpb247XG4gICAgICAgIHJlc3VsdC5vcGVyYXRpbmdTeXN0ZW0gPSBkYXRhLk9wZXJhdGluZ1N5c3RlbTtcbiAgICAgICAgcmVzdWx0Lm9zVHlwZSA9IGRhdGEuT1NUeXBlO1xuICAgICAgICByZXN1bHQuYXJjaGl0ZWN0dXJlID0gZGF0YS5BcmNoaXRlY3R1cmU7XG4gICAgICAgIHJlc3VsdC5uY3B1ID0gZGF0YS5OQ1BVO1xuICAgICAgICByZXN1bHQubWVtVG90YWwgPSBkYXRhLk1lbVRvdGFsO1xuICAgICAgICByZXN1bHQuZG9ja2VyUm9vdERpciA9IGRhdGEuRG9ja2VyUm9vdERpcjtcbiAgICAgICAgcmVzdWx0Lmh0dHBQcm94eSA9IGRhdGEuSHR0cFByb3h5O1xuICAgICAgICByZXN1bHQuaHR0cHNQcm94eSA9IGRhdGEuSHR0cHNQcm94eTtcbiAgICAgICAgcmVzdWx0Lm5vUHJveHkgPSBkYXRhLk5vUHJveHk7XG4gICAgICAgIHJlc3VsdC5uYW1lID0gZGF0YS5OYW1lO1xuICAgICAgICByZXN1bHQubGFiZWxzID0gZGF0YS5MYWJlbHM7XG4gICAgICAgIHJlc3VsdC5leHBlcmltZW50YWxCdWlsZCA9IGRhdGEuRXhwZXJpbWVudGFsQnVpbGQ7XG4gICAgICAgIHJlc3VsdC5zZXJ2ZXJWZXJzaW9uID0gZGF0YS5TZXJ2ZXJWZXJzaW9uO1xuICAgICAgICByZXN1bHQuY2x1c3RlclN0b3JlID0gZGF0YS5DbHVzdGVyU3RvcmU7XG4gICAgICAgIHJlc3VsdC5jbHVzdGVyQWR2ZXJ0aXNlID0gZGF0YS5DbHVzdGVyQWR2ZXJ0aXNlO1xuICAgICAgICByZXN1bHQuZGVmYXVsdFJ1bnRpbWUgPSBkYXRhLkRlZmF1bHRSdW50aW1lO1xuICAgICAgICByZXN1bHQubGl2ZVJlc3RvcmVFbmFibGVkID0gZGF0YS5MaXZlUmVzdG9yZUVuYWJsZWQ7XG4gICAgICAgIHJlc3VsdC5pc29sYXRpb24gPSBkYXRhLklzb2xhdGlvbjtcbiAgICAgICAgcmVzdWx0LmluaXRCaW5hcnkgPSBkYXRhLkluaXRCaW5hcnk7XG4gICAgICAgIHJlc3VsdC5wcm9kdWN0TGljZW5zZSA9IGRhdGEuUHJvZHVjdExpY2Vuc2U7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJJbmZvID0gZG9ja2VySW5mbztcblxuZnVuY3Rpb24gZG9ja2VySW1hZ2VzKGFsbCwgY2FsbGJhY2spIHtcblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihhbGwpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gYWxsO1xuICAgIGFsbCA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYWxsID09PSAnc3RyaW5nJyAmJiBhbGwgPT09ICd0cnVlJykge1xuICAgIGFsbCA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhbGwgIT09ICdib29sZWFuJyAmJiBhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFsbCA9IGZhbHNlO1xuICB9XG5cbiAgYWxsID0gYWxsIHx8IGZhbHNlO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG5cbiAgICAgIF9kb2NrZXJfc29ja2V0Lmxpc3RJbWFnZXMoYWxsLCBkYXRhID0+IHtcbiAgICAgICAgbGV0IGRvY2tlckltYWdlcyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY2tlckltYWdlcyA9IGRhdGE7XG4gICAgICAgICAgaWYgKGRvY2tlckltYWdlcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9ja2VySW1hZ2VzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBkb2NrZXJJbWFnZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBkb2NrZXJJbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lk5hbWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbGVtZW50Lk5hbWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBlbGVtZW50Lk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lk5hbWUgPSBlbGVtZW50Lk5hbWVzWzBdLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya2xvYWQucHVzaChkb2NrZXJJbWFnZXNJbnNwZWN0KGVsZW1lbnQuSWQudHJpbSgpLCBlbGVtZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh3b3JrbG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29udGFpbmVyIGluc3BlY3QgKGZvciBvbmUgY29udGFpbmVyKVxuXG5mdW5jdGlvbiBkb2NrZXJJbWFnZXNJbnNwZWN0KGltYWdlSUQsIHBheWxvYWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpbWFnZUlEID0gaW1hZ2VJRCB8fCAnJztcbiAgICAgIGlmICh0eXBlb2YgaW1hZ2VJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGltYWdlSURTYW5pdGl6ZWQgPSAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhpbWFnZUlELCB0cnVlKSkudHJpbSgpO1xuICAgICAgaWYgKGltYWdlSURTYW5pdGl6ZWQpIHtcblxuICAgICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZG9ja2VyX3NvY2tldC5pbnNwZWN0SW1hZ2UoaW1hZ2VJRFNhbml0aXplZC50cmltKCksIGRhdGEgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuSWQsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcjogZGF0YS5Db250YWluZXIsXG4gICAgICAgICAgICAgIGNvbW1lbnQ6IGRhdGEuQ29tbWVudCxcbiAgICAgICAgICAgICAgb3M6IGRhdGEuT3MsXG4gICAgICAgICAgICAgIGFyY2hpdGVjdHVyZTogZGF0YS5BcmNoaXRlY3R1cmUsXG4gICAgICAgICAgICAgIHBhcmVudDogZGF0YS5QYXJlbnQsXG4gICAgICAgICAgICAgIGRvY2tlclZlcnNpb246IGRhdGEuRG9ja2VyVmVyc2lvbixcbiAgICAgICAgICAgICAgc2l6ZTogZGF0YS5TaXplLFxuICAgICAgICAgICAgICBzaGFyZWRTaXplOiBwYXlsb2FkLlNoYXJlZFNpemUsXG4gICAgICAgICAgICAgIHZpcnR1YWxTaXplOiBkYXRhLlZpcnR1YWxTaXplLFxuICAgICAgICAgICAgICBhdXRob3I6IGRhdGEuQXV0aG9yLFxuICAgICAgICAgICAgICBjcmVhdGVkOiBkYXRhLkNyZWF0ZWQgPyBNYXRoLnJvdW5kKG5ldyBEYXRlKGRhdGEuQ3JlYXRlZCkuZ2V0VGltZSgpIC8gMTAwMCkgOiAwLFxuICAgICAgICAgICAgICBjb250YWluZXJDb25maWc6IGRhdGEuQ29udGFpbmVyQ29uZmlnID8gZGF0YS5Db250YWluZXJDb25maWcgOiB7fSxcbiAgICAgICAgICAgICAgZ3JhcGhEcml2ZXI6IGRhdGEuR3JhcGhEcml2ZXIgPyBkYXRhLkdyYXBoRHJpdmVyIDoge30sXG4gICAgICAgICAgICAgIHJlcG9EaWdlc3RzOiBkYXRhLlJlcG9EaWdlc3RzID8gZGF0YS5SZXBvRGlnZXN0cyA6IHt9LFxuICAgICAgICAgICAgICByZXBvVGFnczogZGF0YS5SZXBvVGFncyA/IGRhdGEuUmVwb1RhZ3MgOiB7fSxcbiAgICAgICAgICAgICAgY29uZmlnOiBkYXRhLkNvbmZpZyA/IGRhdGEuQ29uZmlnIDoge30sXG4gICAgICAgICAgICAgIHJvb3RGUzogZGF0YS5Sb290RlMgPyBkYXRhLlJvb3RGUyA6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VySW1hZ2VzID0gZG9ja2VySW1hZ2VzO1xuXG5mdW5jdGlvbiBkb2NrZXJDb250YWluZXJzKGFsbCwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiBpbkNvbnRhaW5lcnMoY29udGFpbmVycywgaWQpIHtcbiAgICBsZXQgZmlsdGVyZWQgPSBjb250YWluZXJzLmZpbHRlcihvYmogPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIElkXG4gICAgICAgKi9cbiAgICAgIHJldHVybiAob2JqLklkICYmIChvYmouSWQgPT09IGlkKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIChmaWx0ZXJlZC5sZW5ndGggPiAwKTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGFsbCkgJiYgIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBhbGw7XG4gICAgYWxsID0gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBhbGwgPT09ICdzdHJpbmcnICYmIGFsbCA9PT0gJ3RydWUnKSB7XG4gICAgYWxsID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGFsbCAhPT0gJ2Jvb2xlYW4nICYmIGFsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYWxsID0gZmFsc2U7XG4gIH1cblxuICBhbGwgPSBhbGwgfHwgZmFsc2U7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcblxuICAgICAgX2RvY2tlcl9zb2NrZXQubGlzdENvbnRhaW5lcnMoYWxsLCBkYXRhID0+IHtcbiAgICAgICAgbGV0IGRvY2tlcl9jb250YWluZXJzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9ja2VyX2NvbnRhaW5lcnMgPSBkYXRhO1xuICAgICAgICAgIGlmIChkb2NrZXJfY29udGFpbmVycyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9ja2VyX2NvbnRhaW5lcnMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGRvY2tlcl9jb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEdDIGluIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gX2RvY2tlcl9jb250YWluZXJfc3RhdHMpIHtcbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoX2RvY2tlcl9jb250YWluZXJfc3RhdHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluQ29udGFpbmVycyhkb2NrZXJfY29udGFpbmVycywga2V5KSkgeyBkZWxldGUgX2RvY2tlcl9jb250YWluZXJfc3RhdHNba2V5XTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvY2tlcl9jb250YWluZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5OYW1lcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudC5OYW1lcykgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgZWxlbWVudC5OYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5OYW1lID0gZWxlbWVudC5OYW1lc1swXS5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtsb2FkLnB1c2goZG9ja2VyQ29udGFpbmVySW5zcGVjdChlbGVtZW50LklkLnRyaW0oKSwgZWxlbWVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod29ya2xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gR0MgaW4gX2RvY2tlcl9jb250YWluZXJfc3RhdHNcbiAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gX2RvY2tlcl9jb250YWluZXJfc3RhdHMpIHtcbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9kb2NrZXJfY29udGFpbmVyX3N0YXRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmICghaW5Db250YWluZXJzKGRvY2tlcl9jb250YWluZXJzLCBrZXkpKSB7IGRlbGV0ZSBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0c1trZXldOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb250YWluZXIgaW5zcGVjdCAoZm9yIG9uZSBjb250YWluZXIpXG5cbmZ1bmN0aW9uIGRvY2tlckNvbnRhaW5lckluc3BlY3QoY29udGFpbmVySUQsIHBheWxvYWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb250YWluZXJJRCA9IGNvbnRhaW5lcklEIHx8ICcnO1xuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lcklkU2FuaXRpemVkID0gKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJycgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoY29udGFpbmVySUQsIHRydWUpKS50cmltKCk7XG4gICAgICBpZiAoY29udGFpbmVySWRTYW5pdGl6ZWQpIHtcblxuICAgICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZG9ja2VyX3NvY2tldC5nZXRJbnNwZWN0KGNvbnRhaW5lcklkU2FuaXRpemVkLnRyaW0oKSwgZGF0YSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBpZDogcGF5bG9hZC5JZCxcbiAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5OYW1lLFxuICAgICAgICAgICAgICBpbWFnZTogcGF5bG9hZC5JbWFnZSxcbiAgICAgICAgICAgICAgaW1hZ2VJRDogcGF5bG9hZC5JbWFnZUlELFxuICAgICAgICAgICAgICBjb21tYW5kOiBwYXlsb2FkLkNvbW1hbmQsXG4gICAgICAgICAgICAgIGNyZWF0ZWQ6IHBheWxvYWQuQ3JlYXRlZCxcbiAgICAgICAgICAgICAgc3RhcnRlZDogZGF0YS5TdGF0ZSAmJiBkYXRhLlN0YXRlLlN0YXJ0ZWRBdCA/IE1hdGgucm91bmQobmV3IERhdGUoZGF0YS5TdGF0ZS5TdGFydGVkQXQpLmdldFRpbWUoKSAvIDEwMDApIDogMCxcbiAgICAgICAgICAgICAgZmluaXNoZWQ6IGRhdGEuU3RhdGUgJiYgZGF0YS5TdGF0ZS5GaW5pc2hlZEF0ICYmICFkYXRhLlN0YXRlLkZpbmlzaGVkQXQuc3RhcnRzV2l0aCgnMDAwMS0wMS0wMScpID8gTWF0aC5yb3VuZChuZXcgRGF0ZShkYXRhLlN0YXRlLkZpbmlzaGVkQXQpLmdldFRpbWUoKSAvIDEwMDApIDogMCxcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBkYXRhLkNyZWF0ZWQgPyBkYXRhLkNyZWF0ZWQgOiAnJyxcbiAgICAgICAgICAgICAgc3RhcnRlZEF0OiBkYXRhLlN0YXRlICYmIGRhdGEuU3RhdGUuU3RhcnRlZEF0ID8gZGF0YS5TdGF0ZS5TdGFydGVkQXQgOiAnJyxcbiAgICAgICAgICAgICAgZmluaXNoZWRBdDogZGF0YS5TdGF0ZSAmJiBkYXRhLlN0YXRlLkZpbmlzaGVkQXQgJiYgIWRhdGEuU3RhdGUuRmluaXNoZWRBdC5zdGFydHNXaXRoKCcwMDAxLTAxLTAxJykgPyBkYXRhLlN0YXRlLkZpbmlzaGVkQXQgOiAnJyxcbiAgICAgICAgICAgICAgc3RhdGU6IHBheWxvYWQuU3RhdGUsXG4gICAgICAgICAgICAgIHJlc3RhcnRDb3VudDogZGF0YS5SZXN0YXJ0Q291bnQgfHwgMCxcbiAgICAgICAgICAgICAgcGxhdGZvcm06IGRhdGEuUGxhdGZvcm0gfHwgJycsXG4gICAgICAgICAgICAgIGRyaXZlcjogZGF0YS5Ecml2ZXIgfHwgJycsXG4gICAgICAgICAgICAgIHBvcnRzOiBwYXlsb2FkLlBvcnRzLFxuICAgICAgICAgICAgICBtb3VudHM6IHBheWxvYWQuTW91bnRzLFxuICAgICAgICAgICAgICAvLyBob3N0Y29uZmlnOiBwYXlsb2FkLkhvc3RDb25maWcsXG4gICAgICAgICAgICAgIC8vIG5ldHdvcms6IHBheWxvYWQuTmV0d29ya1NldHRpbmdzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJDb250YWluZXJzID0gZG9ja2VyQ29udGFpbmVycztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGhlbHBlciBmdW5jdGlvbnMgZm9yIGNhbGN1bGF0aW9uIG9mIGRvY2tlciBzdGF0c1xuXG5mdW5jdGlvbiBkb2NrZXJfY2FsY0NQVVBlcmNlbnQoY3B1X3N0YXRzLCBwcmVjcHVfc3RhdHMpIHtcbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQHByb3BlcnR5IHtvYmplY3R9ICBjcHVfdXNhZ2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBjcHVfdXNhZ2UudG90YWxfdXNhZ2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9ICBzeXN0ZW1fY3B1X3VzYWdlXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgY3B1X3VzYWdlXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICBjcHVfdXNhZ2UucGVyY3B1X3VzYWdlXG4gICAqL1xuXG4gIGlmICghX3dpbmRvd3MpIHtcbiAgICBsZXQgY3B1UGVyY2VudCA9IDAuMDtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGNoYW5nZSBmb3IgdGhlIGNwdSB1c2FnZSBvZiB0aGUgY29udGFpbmVyIGluIGJldHdlZW4gcmVhZGluZ3NcbiAgICBsZXQgY3B1RGVsdGEgPSBjcHVfc3RhdHMuY3B1X3VzYWdlLnRvdGFsX3VzYWdlIC0gcHJlY3B1X3N0YXRzLmNwdV91c2FnZS50b3RhbF91c2FnZTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGNoYW5nZSBmb3IgdGhlIGVudGlyZSBzeXN0ZW0gYmV0d2VlbiByZWFkaW5nc1xuICAgIGxldCBzeXN0ZW1EZWx0YSA9IGNwdV9zdGF0cy5zeXN0ZW1fY3B1X3VzYWdlIC0gcHJlY3B1X3N0YXRzLnN5c3RlbV9jcHVfdXNhZ2U7XG5cbiAgICBpZiAoc3lzdGVtRGVsdGEgPiAwLjAgJiYgY3B1RGVsdGEgPiAwLjApIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY2hhbmdlIGZvciB0aGUgY3B1IHVzYWdlIG9mIHRoZSBjb250YWluZXIgaW4gYmV0d2VlbiByZWFkaW5nc1xuICAgICAgaWYgKHByZWNwdV9zdGF0cy5vbmxpbmVfY3B1cykge1xuICAgICAgICBjcHVQZXJjZW50ID0gKGNwdURlbHRhIC8gc3lzdGVtRGVsdGEpICogcHJlY3B1X3N0YXRzLm9ubGluZV9jcHVzICogMTAwLjA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3B1UGVyY2VudCA9IChjcHVEZWx0YSAvIHN5c3RlbURlbHRhKSAqIGNwdV9zdGF0cy5jcHVfdXNhZ2UucGVyY3B1X3VzYWdlLmxlbmd0aCAqIDEwMC4wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjcHVQZXJjZW50O1xuICB9IGVsc2Uge1xuICAgIGxldCBuYW5vU2VjTm93ID0gdXRpbC5uYW5vU2Vjb25kcygpO1xuICAgIGxldCBjcHVQZXJjZW50ID0gMC4wO1xuICAgIGlmIChfZG9ja2VyX2xhc3RfcmVhZCA+IDApIHtcbiAgICAgIGxldCBwb3NzSW50ZXJ2YWxzID0gKG5hbm9TZWNOb3cgLSBfZG9ja2VyX2xhc3RfcmVhZCk7IC8vICAvIDEwMCAqIG9zLmNwdXMoKS5sZW5ndGg7XG4gICAgICBsZXQgaW50ZXJ2YWxzVXNlZCA9IGNwdV9zdGF0cy5jcHVfdXNhZ2UudG90YWxfdXNhZ2UgLSBwcmVjcHVfc3RhdHMuY3B1X3VzYWdlLnRvdGFsX3VzYWdlO1xuICAgICAgaWYgKHBvc3NJbnRlcnZhbHMgPiAwKSB7XG4gICAgICAgIGNwdVBlcmNlbnQgPSAxMDAuMCAqIGludGVydmFsc1VzZWQgLyBwb3NzSW50ZXJ2YWxzO1xuICAgICAgfVxuICAgIH1cbiAgICBfZG9ja2VyX2xhc3RfcmVhZCA9IG5hbm9TZWNOb3c7XG4gICAgcmV0dXJuIGNwdVBlcmNlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9ja2VyX2NhbGNOZXR3b3JrSU8obmV0d29ya3MpIHtcbiAgbGV0IHJ4O1xuICBsZXQgd3g7XG4gIGZvciAobGV0IGtleSBpbiBuZXR3b3Jrcykge1xuICAgIC8vIHNraXAgbG9vcCBpZiB0aGUgcHJvcGVydHkgaXMgZnJvbSBwcm90b3R5cGVcbiAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwobmV0d29ya3MsIGtleSkpIHsgY29udGludWU7IH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIHJ4X2J5dGVzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICB0eF9ieXRlc1xuICAgICAqL1xuICAgIGxldCBvYmogPSBuZXR3b3Jrc1trZXldO1xuICAgIHJ4ID0gK29iai5yeF9ieXRlcztcbiAgICB3eCA9ICtvYmoudHhfYnl0ZXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByeCxcbiAgICB3eFxuICB9O1xufVxuXG5mdW5jdGlvbiBkb2NrZXJfY2FsY0Jsb2NrSU8oYmxraW9fc3RhdHMpIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICByOiAwLFxuICAgIHc6IDBcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZVxuICAgKiBAcHJvcGVydHkge0FycmF5fSAgaW9fc2VydmljZV9ieXRlc19yZWN1cnNpdmVcbiAgICovXG4gIGlmIChibGtpb19zdGF0cyAmJiBibGtpb19zdGF0cy5pb19zZXJ2aWNlX2J5dGVzX3JlY3Vyc2l2ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxraW9fc3RhdHMuaW9fc2VydmljZV9ieXRlc19yZWN1cnNpdmUpID09PSAnW29iamVjdCBBcnJheV0nICYmIGJsa2lvX3N0YXRzLmlvX3NlcnZpY2VfYnl0ZXNfcmVjdXJzaXZlLmxlbmd0aCA+IDApIHtcbiAgICBibGtpb19zdGF0cy5pb19zZXJ2aWNlX2J5dGVzX3JlY3Vyc2l2ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgb3BcbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgdmFsdWVcbiAgICAgICAqL1xuXG4gICAgICBpZiAoZWxlbWVudC5vcCAmJiBlbGVtZW50Lm9wLnRvTG93ZXJDYXNlKCkgPT09ICdyZWFkJyAmJiBlbGVtZW50LnZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC5yICs9IGVsZW1lbnQudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5vcCAmJiBlbGVtZW50Lm9wLnRvTG93ZXJDYXNlKCkgPT09ICd3cml0ZScgJiYgZWxlbWVudC52YWx1ZSkge1xuICAgICAgICByZXN1bHQudyArPSBlbGVtZW50LnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRvY2tlckNvbnRhaW5lclN0YXRzKGNvbnRhaW5lcklEcywgY2FsbGJhY2spIHtcblxuICBsZXQgY29udGFpbmVyQXJyYXkgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICAgICAgaWYgKHV0aWwuaXNGdW5jdGlvbihjb250YWluZXJJRHMpICYmICFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNvbnRhaW5lcklEcztcbiAgICAgICAgY29udGFpbmVyQXJyYXkgPSBbJyonXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lcklEcyA9IGNvbnRhaW5lcklEcyB8fCAnKic7XG4gICAgICAgIGlmICh0eXBlb2YgY29udGFpbmVySURzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhbXSk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lcklEc1Nhbml0aXplZCA9ICcnO1xuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQuX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQuX19wcm90b19fLnJlcGxhY2UgPSB1dGlsLnN0cmluZ1JlcGxhY2U7XG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZC5fX3Byb3RvX18udHJpbSA9IHV0aWwuc3RyaW5nVHJpbTtcblxuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSBjb250YWluZXJJRHM7XG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZCA9IGNvbnRhaW5lcklEc1Nhbml0aXplZC50cmltKCk7XG4gICAgICAgIGlmIChjb250YWluZXJJRHNTYW5pdGl6ZWQgIT09ICcqJykge1xuICAgICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZCA9ICcnO1xuICAgICAgICAgIGNvbnN0IHMgPSAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhjb250YWluZXJJRHMsIHRydWUpKS50cmltKCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHNbaV0uX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICAgICAgICBjb25zdCBzbCA9IHNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHNsICYmIHNsWzBdICYmICFzbFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZCA9IGNvbnRhaW5lcklEc1Nhbml0aXplZCArIHNsWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkID0gY29udGFpbmVySURzU2FuaXRpemVkLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLywrL2csICd8Jyk7XG4gICAgICAgIGNvbnRhaW5lckFycmF5ID0gY29udGFpbmVySURzU2FuaXRpemVkLnNwbGl0KCd8Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgaWYgKGNvbnRhaW5lckFycmF5Lmxlbmd0aCAmJiBjb250YWluZXJBcnJheVswXS50cmltKCkgPT09ICcqJykge1xuICAgICAgICBjb250YWluZXJBcnJheSA9IFtdO1xuICAgICAgICBkb2NrZXJDb250YWluZXJzKCkudGhlbihhbGxDb250YWluZXJzID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBjb250YWluZXIgb2YgYWxsQ29udGFpbmVycykge1xuICAgICAgICAgICAgY29udGFpbmVyQXJyYXkucHVzaChjb250YWluZXIuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbmVyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBkb2NrZXJDb250YWluZXJTdGF0cyhjb250YWluZXJBcnJheS5qb2luKCcsJykpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGNvbnRhaW5lcklEIG9mIGNvbnRhaW5lckFycmF5KSB7XG4gICAgICAgICAgd29ya2xvYWQucHVzaChkb2NrZXJDb250YWluZXJTdGF0c1NpbmdsZShjb250YWluZXJJRC50cmltKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya2xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29udGFpbmVyIHN0YXRzIChmb3Igb25lIGNvbnRhaW5lcilcblxuZnVuY3Rpb24gZG9ja2VyQ29udGFpbmVyU3RhdHNTaW5nbGUoY29udGFpbmVySUQpIHtcbiAgY29udGFpbmVySUQgPSBjb250YWluZXJJRCB8fCAnJztcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICBpZDogY29udGFpbmVySUQsXG4gICAgbWVtVXNhZ2U6IDAsXG4gICAgbWVtTGltaXQ6IDAsXG4gICAgbWVtUGVyY2VudDogMCxcbiAgICBjcHVQZXJjZW50OiAwLFxuICAgIHBpZHM6IDAsXG4gICAgbmV0SU86IHtcbiAgICAgIHJ4OiAwLFxuICAgICAgd3g6IDBcbiAgICB9LFxuICAgIGJsb2NrSU86IHtcbiAgICAgIHI6IDAsXG4gICAgICB3OiAwXG4gICAgfSxcbiAgICByZXN0YXJ0Q291bnQ6IDAsXG4gICAgY3B1U3RhdHM6IHt9LFxuICAgIHByZWNwdVN0YXRzOiB7fSxcbiAgICBtZW1vcnlTdGF0czoge30sXG4gICAgbmV0d29ya3M6IHt9LFxuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmIChjb250YWluZXJJRCkge1xuXG4gICAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kb2NrZXJfc29ja2V0LmdldEluc3BlY3QoY29udGFpbmVySUQsIGRhdGFJbnNwZWN0ID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2RvY2tlcl9zb2NrZXQuZ2V0U3RhdHMoY29udGFpbmVySUQsIGRhdGEgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBzdGF0cyA9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZW1Vc2FnZSA9IChzdGF0cy5tZW1vcnlfc3RhdHMgJiYgc3RhdHMubWVtb3J5X3N0YXRzLnVzYWdlID8gc3RhdHMubWVtb3J5X3N0YXRzLnVzYWdlIDogMCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWVtTGltaXQgPSAoc3RhdHMubWVtb3J5X3N0YXRzICYmIHN0YXRzLm1lbW9yeV9zdGF0cy5saW1pdCA/IHN0YXRzLm1lbW9yeV9zdGF0cy5saW1pdCA6IDApO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lbVBlcmNlbnQgPSAoc3RhdHMubWVtb3J5X3N0YXRzICYmIHN0YXRzLm1lbW9yeV9zdGF0cy51c2FnZSAmJiBzdGF0cy5tZW1vcnlfc3RhdHMubGltaXQgPyBzdGF0cy5tZW1vcnlfc3RhdHMudXNhZ2UgLyBzdGF0cy5tZW1vcnlfc3RhdHMubGltaXQgKiAxMDAuMCA6IDApO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNwdVBlcmNlbnQgPSAoc3RhdHMuY3B1X3N0YXRzICYmIHN0YXRzLnByZWNwdV9zdGF0cyA/IGRvY2tlcl9jYWxjQ1BVUGVyY2VudChzdGF0cy5jcHVfc3RhdHMsIHN0YXRzLnByZWNwdV9zdGF0cykgOiAwKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5waWRzID0gKHN0YXRzLnBpZHNfc3RhdHMgJiYgc3RhdHMucGlkc19zdGF0cy5jdXJyZW50ID8gc3RhdHMucGlkc19zdGF0cy5jdXJyZW50IDogMCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucmVzdGFydENvdW50ID0gKGRhdGFJbnNwZWN0LlJlc3RhcnRDb3VudCA/IGRhdGFJbnNwZWN0LlJlc3RhcnRDb3VudCA6IDApO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzLm5ldHdvcmtzKSB7IHJlc3VsdC5uZXRJTyA9IGRvY2tlcl9jYWxjTmV0d29ya0lPKHN0YXRzLm5ldHdvcmtzKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzLmJsa2lvX3N0YXRzKSB7IHJlc3VsdC5ibG9ja0lPID0gZG9ja2VyX2NhbGNCbG9ja0lPKHN0YXRzLmJsa2lvX3N0YXRzKTsgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNwdVN0YXRzID0gKHN0YXRzLmNwdV9zdGF0cyA/IHN0YXRzLmNwdV9zdGF0cyA6IHt9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcmVjcHVTdGF0cyA9IChzdGF0cy5wcmVjcHVfc3RhdHMgPyBzdGF0cy5wcmVjcHVfc3RhdHMgOiB7fSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWVtb3J5U3RhdHMgPSAoc3RhdHMubWVtb3J5X3N0YXRzID8gc3RhdHMubWVtb3J5X3N0YXRzIDoge30pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5ldHdvcmtzID0gKHN0YXRzLm5ldHdvcmtzID8gc3RhdHMubmV0d29ya3MgOiB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVyU3RhdHMgPSBkb2NrZXJDb250YWluZXJTdGF0cztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnRhaW5lciBwcm9jZXNzZXMgKGZvciBvbmUgY29udGFpbmVyKVxuXG5mdW5jdGlvbiBkb2NrZXJDb250YWluZXJQcm9jZXNzZXMoY29udGFpbmVySUQsIGNhbGxiYWNrKSB7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb250YWluZXJJRCA9IGNvbnRhaW5lcklEIHx8ICcnO1xuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXJJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRhaW5lcklkU2FuaXRpemVkID0gKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJycgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoY29udGFpbmVySUQsIHRydWUpKS50cmltKCk7XG5cbiAgICAgIGlmIChjb250YWluZXJJZFNhbml0aXplZCkge1xuXG4gICAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kb2NrZXJfc29ja2V0LmdldFByb2Nlc3Nlcyhjb250YWluZXJJZFNhbml0aXplZCwgZGF0YSA9PiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICBUaXRsZXNcbiAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSAgUHJvY2Vzc2VzXG4gICAgICAgICAgICoqL1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLlRpdGxlcyAmJiBkYXRhLlByb2Nlc3Nlcykge1xuICAgICAgICAgICAgICBsZXQgdGl0bGVzID0gZGF0YS5UaXRsZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbGV0IHBvc19waWQgPSB0aXRsZXMuaW5kZXhPZignUElEJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfcHBpZCA9IHRpdGxlcy5pbmRleE9mKCdQUElEJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfcGdpZCA9IHRpdGxlcy5pbmRleE9mKCdQR0lEJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfdnN6ID0gdGl0bGVzLmluZGV4T2YoJ1ZTWicpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3RpbWUgPSB0aXRsZXMuaW5kZXhPZignVElNRScpO1xuICAgICAgICAgICAgICBsZXQgcG9zX2VsYXBzZWQgPSB0aXRsZXMuaW5kZXhPZignRUxBUFNFRCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX25pID0gdGl0bGVzLmluZGV4T2YoJ05JJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfcnVzZXIgPSB0aXRsZXMuaW5kZXhPZignUlVTRVInKTtcbiAgICAgICAgICAgICAgbGV0IHBvc191c2VyID0gdGl0bGVzLmluZGV4T2YoJ1VTRVInKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19yZ3JvdXAgPSB0aXRsZXMuaW5kZXhPZignUkdST1VQJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfZ3JvdXAgPSB0aXRsZXMuaW5kZXhPZignR1JPVVAnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19zdGF0ID0gdGl0bGVzLmluZGV4T2YoJ1NUQVQnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19yc3MgPSB0aXRsZXMuaW5kZXhPZignUlNTJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfY29tbWFuZCA9IHRpdGxlcy5pbmRleE9mKCdDT01NQU5EJyk7XG5cbiAgICAgICAgICAgICAgZGF0YS5Qcm9jZXNzZXMuZm9yRWFjaChwcm9jZXNzID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBwaWRIb3N0OiAocG9zX3BpZCA+PSAwID8gcHJvY2Vzc1twb3NfcGlkXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHBwaWQ6IChwb3NfcHBpZCA+PSAwID8gcHJvY2Vzc1twb3NfcHBpZF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBwZ2lkOiAocG9zX3BnaWQgPj0gMCA/IHByb2Nlc3NbcG9zX3BnaWRdIDogJycpLFxuICAgICAgICAgICAgICAgICAgdXNlcjogKHBvc191c2VyID49IDAgPyBwcm9jZXNzW3Bvc191c2VyXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHJ1c2VyOiAocG9zX3J1c2VyID49IDAgPyBwcm9jZXNzW3Bvc19ydXNlcl0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBncm91cDogKHBvc19ncm91cCA+PSAwID8gcHJvY2Vzc1twb3NfZ3JvdXBdIDogJycpLFxuICAgICAgICAgICAgICAgICAgcmdyb3VwOiAocG9zX3Jncm91cCA+PSAwID8gcHJvY2Vzc1twb3Nfcmdyb3VwXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHN0YXQ6IChwb3Nfc3RhdCA+PSAwID8gcHJvY2Vzc1twb3Nfc3RhdF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICB0aW1lOiAocG9zX3RpbWUgPj0gMCA/IHByb2Nlc3NbcG9zX3RpbWVdIDogJycpLFxuICAgICAgICAgICAgICAgICAgZWxhcHNlZDogKHBvc19lbGFwc2VkID49IDAgPyBwcm9jZXNzW3Bvc19lbGFwc2VkXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIG5pY2U6IChwb3NfbmkgPj0gMCA/IHByb2Nlc3NbcG9zX25pXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHJzczogKHBvc19yc3MgPj0gMCA/IHByb2Nlc3NbcG9zX3Jzc10gOiAnJyksXG4gICAgICAgICAgICAgICAgICB2c3o6IChwb3NfdnN6ID49IDAgPyBwcm9jZXNzW3Bvc192c3pdIDogJycpLFxuICAgICAgICAgICAgICAgICAgY29tbWFuZDogKHBvc19jb21tYW5kID49IDAgPyBwcm9jZXNzW3Bvc19jb21tYW5kXSA6ICcnKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckNvbnRhaW5lclByb2Nlc3NlcyA9IGRvY2tlckNvbnRhaW5lclByb2Nlc3NlcztcblxuZnVuY3Rpb24gZG9ja2VyVm9sdW1lcyhjYWxsYmFjaykge1xuXG4gIGxldCByZXN1bHQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgfVxuICAgICAgX2RvY2tlcl9zb2NrZXQubGlzdFZvbHVtZXMoKGRhdGEpID0+IHtcbiAgICAgICAgbGV0IGRvY2tlclZvbHVtZXMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2NrZXJWb2x1bWVzID0gZGF0YTtcbiAgICAgICAgICBpZiAoZG9ja2VyVm9sdW1lcyAmJiBkb2NrZXJWb2x1bWVzLlZvbHVtZXMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY2tlclZvbHVtZXMuVm9sdW1lcykgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgZG9ja2VyVm9sdW1lcy5Wb2x1bWVzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgZG9ja2VyVm9sdW1lcy5Wb2x1bWVzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogZWxlbWVudC5OYW1lLFxuICAgICAgICAgICAgICAgIGRyaXZlcjogZWxlbWVudC5Ecml2ZXIsXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBlbGVtZW50LkxhYmVscyxcbiAgICAgICAgICAgICAgICBtb3VudHBvaW50OiBlbGVtZW50Lk1vdW50cG9pbnQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZWxlbWVudC5PcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LlNjb3BlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IGVsZW1lbnQuQ3JlYXRlZEF0ID8gTWF0aC5yb3VuZChuZXcgRGF0ZShlbGVtZW50LkNyZWF0ZWRBdCkuZ2V0VGltZSgpIC8gMTAwMCkgOiAwLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VyVm9sdW1lcyA9IGRvY2tlclZvbHVtZXM7XG5cbmZ1bmN0aW9uIGRvY2tlckFsbChjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGRvY2tlckNvbnRhaW5lcnModHJ1ZSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXN1bHQpID09PSAnW29iamVjdCBBcnJheV0nICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGwgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBkb2NrZXJDb250YWluZXJTdGF0cyhlbGVtZW50LmlkKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgLy8gaW5jbHVkZSBzdGF0cyBpbiBhcnJheVxuICAgICAgICAgICAgICBlbGVtZW50Lm1lbVVzYWdlID0gcmVzWzBdLm1lbVVzYWdlO1xuICAgICAgICAgICAgICBlbGVtZW50Lm1lbUxpbWl0ID0gcmVzWzBdLm1lbUxpbWl0O1xuICAgICAgICAgICAgICBlbGVtZW50Lm1lbVBlcmNlbnQgPSByZXNbMF0ubWVtUGVyY2VudDtcbiAgICAgICAgICAgICAgZWxlbWVudC5jcHVQZXJjZW50ID0gcmVzWzBdLmNwdVBlcmNlbnQ7XG4gICAgICAgICAgICAgIGVsZW1lbnQucGlkcyA9IHJlc1swXS5waWRzO1xuICAgICAgICAgICAgICBlbGVtZW50Lm5ldElPID0gcmVzWzBdLm5ldElPO1xuICAgICAgICAgICAgICBlbGVtZW50LmJsb2NrSU8gPSByZXNbMF0uYmxvY2tJTztcbiAgICAgICAgICAgICAgZWxlbWVudC5jcHVTdGF0cyA9IHJlc1swXS5jcHVTdGF0cztcbiAgICAgICAgICAgICAgZWxlbWVudC5wcmVjcHVTdGF0cyA9IHJlc1swXS5wcmVjcHVTdGF0cztcbiAgICAgICAgICAgICAgZWxlbWVudC5tZW1vcnlTdGF0cyA9IHJlc1swXS5tZW1vcnlTdGF0cztcbiAgICAgICAgICAgICAgZWxlbWVudC5uZXR3b3JrcyA9IHJlc1swXS5uZXR3b3JrcztcblxuICAgICAgICAgICAgICBkb2NrZXJDb250YWluZXJQcm9jZXNzZXMoZWxlbWVudC5pZCkudGhlbihwcm9jZXNzZXMgPT4ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvY2Vzc2VzID0gcHJvY2Vzc2VzO1xuXG4gICAgICAgICAgICAgICAgbCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIGFsbCBkb25lPz9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VyQWxsID0gZG9ja2VyQWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBkb2NrZXJTb2NrZXRzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTMuIERvY2tlclNvY2tldHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBpc1dpbiA9IHJlcXVpcmUoJ29zJykudHlwZSgpID09PSAnV2luZG93c19OVCc7XG5jb25zdCBzb2NrZXRQYXRoID0gaXNXaW4gPyAnLy8uL3BpcGUvZG9ja2VyX2VuZ2luZScgOiAnL3Zhci9ydW4vZG9ja2VyLnNvY2snO1xuXG5jbGFzcyBEb2NrZXJTb2NrZXQge1xuXG4gIGdldEluZm8oY2FsbGJhY2spIHtcbiAgICB0cnkge1xuXG4gICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2luZm8gSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgbGlzdEltYWdlcyhhbGwsIGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcblxuICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9pbWFnZXMvanNvbicgKyAoYWxsID8gJz9hbGw9MScgOiAnJykgKyAnIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGluc3BlY3RJbWFnZShpZCwgY2FsbGJhY2spIHtcbiAgICBpZCA9IGlkIHx8ICcnO1xuICAgIGlmIChpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2ltYWdlcy8nICsgaWQgKyAnL2pzb24/c3RyZWFtPTAgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBsaXN0Q29udGFpbmVycyhhbGwsIGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcblxuICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9jb250YWluZXJzL2pzb24nICsgKGFsbCA/ICc/YWxsPTEnIDogJycpICsgJyBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBnZXRTdGF0cyhpZCwgY2FsbGJhY2spIHtcbiAgICBpZCA9IGlkIHx8ICcnO1xuICAgIGlmIChpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2NvbnRhaW5lcnMvJyArIGlkICsgJy9zdGF0cz9zdHJlYW09MCBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGdldEluc3BlY3QoaWQsIGNhbGxiYWNrKSB7XG4gICAgaWQgPSBpZCB8fCAnJztcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9jb250YWluZXJzLycgKyBpZCArICcvanNvbj9zdHJlYW09MCBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb2Nlc3NlcyhpZCwgY2FsbGJhY2spIHtcbiAgICBpZCA9IGlkIHx8ICcnO1xuICAgIGlmIChpZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L2NvbnRhaW5lcnMvJyArIGlkICsgJy90b3A/cHNfYXJncz0tb3BpZCxwcGlkLHBnaWQsdnN6LHRpbWUsZXRpbWUsbmljZSxydXNlcix1c2VyLHJncm91cCxncm91cCxzdGF0LHJzcyxhcmdzIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgbGlzdFZvbHVtZXMoY2FsbGJhY2spIHtcbiAgICB0cnkge1xuXG4gICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgbGV0IGFsbGRhdGEgPSAnJztcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldC53cml0ZSgnR0VUIGh0dHA6L3ZvbHVtZXMgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRG9ja2VyU29ja2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBmaWxlc3lzdGVtLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gOC4gRmlsZSBTeXN0ZW1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IGV4ZWNQcm9taXNlU2F2ZSA9IHV0aWwucHJvbWlzaWZ5U2F2ZShyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5sZXQgX2ZzX3NwZWVkID0ge307XG5sZXQgX2Rpc2tfaW8gPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZTIC0gbW91bnRlZCBmaWxlIHN5c3RlbXNcblxuZnVuY3Rpb24gZnNTaXplKGNhbGxiYWNrKSB7XG5cbiAgbGV0IG1hY09zRGlza3MgPSBbXTtcbiAgbGV0IG9zTW91bnRzID0gW107XG5cbiAgZnVuY3Rpb24gZ2V0bWFjT3NGc1R5cGUoZnMpIHtcbiAgICBpZiAoIWZzLnN0YXJ0c1dpdGgoJy8nKSkgeyByZXR1cm4gJ05GUyc7IH1cbiAgICBjb25zdCBwYXJ0cyA9IGZzLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgZnNTaG9ydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG1hY09zRGlza3NTaW5nbGUgPSBtYWNPc0Rpc2tzLmZpbHRlcihpdGVtID0+IGl0ZW0uaW5kZXhPZihmc1Nob3J0KSA+PSAwKTtcbiAgICBpZiAobWFjT3NEaXNrc1NpbmdsZS5sZW5ndGggPT09IDEgJiYgbWFjT3NEaXNrc1NpbmdsZVswXS5pbmRleE9mKCdBUEZTJykgPj0gMCkgeyByZXR1cm4gJ0FQRlMnOyB9XG4gICAgcmV0dXJuICdIRlMnO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW51eFRtcEZzKGZzKSB7XG4gICAgY29uc3QgbGludXhUbXBGaWxlU3lzdGVtcyA9IFsncm9vdGZzJywgJ3VuaW9uZnMnLCAnc3F1YXNoZnMnLCAnY3JhbWZzJywgJ2luaXRyZCcsICdpbml0cmFtZnMnLCAnZGV2dG1wZnMnLCAndG1wZnMnLCAndWRldicsICdkZXZmcycsICdzcGVjZnMnLCAndHlwZScsICdhcHBpbWFnZWQnXTtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgbGludXhUbXBGaWxlU3lzdGVtcy5mb3JFYWNoKGxpbnV4RnMgPT4ge1xuICAgICAgaWYgKGZzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsaW51eEZzKSA+PSAwKSB7IHJlc3VsdCA9IHRydWU7IH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyTGluZXMoc3Rkb3V0KSB7XG4gICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGlmIChzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpbGVzeXN0ZW0nKSkge1xuICAgICAgbGV0IHJlbW92ZUxpbmVzID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldICYmIGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZmlsZXN5c3RlbScpKSB7XG4gICAgICAgICAgcmVtb3ZlTGluZXMgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUxpbmVzOyBpKyspIHtcbiAgICAgICAgbGluZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEZihsaW5lcykge1xuICAgIGxldCBkYXRhID0gW107XG4gICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgaWYgKGxpbmUgJiYgKChsaW5lWzBdLnN0YXJ0c1dpdGgoJy8nKSkgfHwgKGxpbmVbNl0gJiYgbGluZVs2XSA9PT0gJy8nKSB8fCAobGluZVswXS5pbmRleE9mKCcvJykgPiAwKSB8fCAobGluZVswXS5pbmRleE9mKCc6JykgPT09IDEpIHx8ICFfZGFyd2luICYmICFpc0xpbnV4VG1wRnMobGluZVsxXSkpKSB7XG4gICAgICAgICAgY29uc3QgZnMgPSBsaW5lWzBdO1xuICAgICAgICAgIGNvbnN0IGZzVHlwZSA9ICgoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpID8gbGluZVsxXSA6IGdldG1hY09zRnNUeXBlKGxpbmVbMF0pKTtcbiAgICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQoKChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgPyBsaW5lWzJdIDogbGluZVsxXSkpICogMTAyNDtcbiAgICAgICAgICBjb25zdCB1c2VkID0gcGFyc2VJbnQoKChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgPyBsaW5lWzNdIDogbGluZVsyXSkpICogMTAyNDtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSBwYXJzZUludCgoKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSA/IGxpbmVbNF0gOiBsaW5lWzNdKSkgKiAxMDI0O1xuICAgICAgICAgIGNvbnN0IHVzZSA9IHBhcnNlRmxvYXQoKDEwMC4wICogKHVzZWQgLyAodXNlZCArIGF2YWlsYWJsZSkpKS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICBsZXQgcncgPSBvc01vdW50cyAmJiBPYmplY3Qua2V5cyhvc01vdW50cykubGVuZ3RoID4gMCA/IG9zTW91bnRzW2ZzXSB8fCBmYWxzZSA6IG51bGw7XG4gICAgICAgICAgbGluZS5zcGxpY2UoMCwgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSA/IDYgOiA1KTtcbiAgICAgICAgICBjb25zdCBtb3VudCA9IGxpbmUuam9pbignICcpO1xuICAgICAgICAgIGlmICghZGF0YS5maW5kKGVsID0+IChlbC5mcyA9PT0gZnMgJiYgZWwudHlwZSA9PT0gZnNUeXBlKSkpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICB0eXBlOiBmc1R5cGUsXG4gICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgIHVzZWQsXG4gICAgICAgICAgICAgIGF2YWlsYWJsZSxcbiAgICAgICAgICAgICAgdXNlLFxuICAgICAgICAgICAgICBtb3VudCxcbiAgICAgICAgICAgICAgcndcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICcnO1xuICAgICAgICBtYWNPc0Rpc2tzID0gW107XG4gICAgICAgIG9zTW91bnRzID0ge307XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgY21kID0gJ2RmIC1rUCc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hY09zRGlza3MgPSBleGVjU3luYygnZGlza3V0aWwgbGlzdCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuICFsaW5lLnN0YXJ0c1dpdGgoJy8nKSAmJiBsaW5lLmluZGV4T2YoJzonKSA+IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4ZWNTeW5jKCdtb3VudCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3RhcnRzV2l0aCgnLycpO1xuICAgICAgICAgICAgfSkuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICBvc01vdW50c1tsaW5lLnNwbGl0KCcgJylbMF1dID0gbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3JlYWQtb25seScpID09PSAtMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgY21kID0gJ2RmIC1sa1BUeCBzcXVhc2hmcyc7XG4gICAgICAgICAgZXhlY1N5bmMoJ2NhdCAvcHJvYy9tb3VudHMgMj4vZGV2L251bGwnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGluZS5zdGFydHNXaXRoKCcvJyk7XG4gICAgICAgICAgfSkuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgb3NNb3VudHNbbGluZS5zcGxpdCgnICcpWzBdXSA9IGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdydycpID49IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICBjbWQgPSAnZGYgLWxrUFQnO1xuICAgICAgICAgIGV4ZWNTeW5jKCdtb3VudCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgIG9zTW91bnRzW2xpbmUuc3BsaXQoJyAnKVswXV0gPSBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmVhZC1vbmx5JykgPT09IC0xO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBmaWx0ZXJMaW5lcyhzdGRvdXQpO1xuICAgICAgICAgIGRhdGEgPSBwYXJzZURmKGxpbmVzKTtcbiAgICAgICAgICBpZiAoIWVycm9yIHx8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdkZiAta1BUJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBmaWx0ZXJMaW5lcyhzdGRvdXQpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJzZURmKGxpbmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB1dGlsLndtaWMoJ2xvZ2ljYWxkaXNrIGdldCBDYXB0aW9uLEZpbGVTeXN0ZW0sRnJlZVNwYWNlLFNpemUnKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9sb2dpY2FsZGlzayB8IHNlbGVjdCBBY2Nlc3MsQ2FwdGlvbixGaWxlU3lzdGVtLEZyZWVTcGFjZSxTaXplIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzaXplJywgJzonKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlZSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZyZWVzcGFjZScsICc6JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcHRpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FwdGlvbicsICc6Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcndWYWx1ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdhY2Nlc3MnLCAnOicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ3ID0gcndWYWx1ZSA/ICh1dGlsLnRvSW50KHJ3VmFsdWUpICE9PSAxKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZzOiBjYXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZmlsZXN5c3RlbScsICc6JyksXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHVzZWQ6IHNpemUgLSBmcmVlLFxuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGU6IGZyZWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZTogcGFyc2VGbG9hdCgoKDEwMC4wICogKHNpemUgLSBmcmVlKSkgLyBzaXplKS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICAgICAgICAgICAgbW91bnQ6IGNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJ3XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZnNTaXplID0gZnNTaXplO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRlMgLSBvcGVuIGZpbGVzIGNvdW50XG5cbmZ1bmN0aW9uIGZzT3BlbkZpbGVzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG1heDogbnVsbCxcbiAgICAgICAgYWxsb2NhdGVkOiBudWxsLFxuICAgICAgICBhdmFpbGFibGU6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzY3RsIC1pIGtlcm4ubWF4ZmlsZXMga2Vybi5udW1fZmlsZXMga2Vybi5vcGVuX2ZpbGVzJztcbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYXggPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5tYXhmaWxlcycsICc6JyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5hbGxvY2F0ZWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5udW1fZmlsZXMnLCAnOicpLCAxMCkgfHwgcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ub3Blbl9maWxlcycsICc6JyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5hdmFpbGFibGUgPSByZXN1bHQubWF4IC0gcmVzdWx0LmFsbG9jYXRlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBmcy5yZWFkRmlsZSgnL3Byb2Mvc3lzL2ZzL2ZpbGUtbnInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lc1swXSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnJlcGxhY2UoL1xccysvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFsbG9jYXRlZCA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF2YWlsYWJsZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHBhcnNlSW50KHBhcnRzWzJdLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuYXZhaWxhYmxlKSB7IHJlc3VsdC5hdmFpbGFibGUgPSByZXN1bHQubWF4IC0gcmVzdWx0LmFsbG9jYXRlZDsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnMucmVhZEZpbGUoJy9wcm9jL3N5cy9mcy9maWxlLW1heCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzWzBdKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWF4ID0gcGFyc2VJbnQobGluZXNbMF0sIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZnNPcGVuRmlsZXMgPSBmc09wZW5GaWxlcztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRpc2tzXG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMocykge1xuICByZXR1cm4gcGFyc2VJbnQocy5zdWJzdHIocy5pbmRleE9mKCcgKCcpICsgMiwgcy5pbmRleE9mKCcgQnl0ZXMpJykgLSAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZURldmljZXMobGluZXMpIHtcbiAgbGV0IGRldmljZXMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChsaW5lWzBdID09PSAnKicpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGlmICghZGV2aWNlc1tpXSkge1xuICAgICAgICAgICAgZGV2aWNlc1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgIGlkZW50aWZpZXI6ICcnLFxuICAgICAgICAgICAgICB0eXBlOiAnZGlzaycsXG4gICAgICAgICAgICAgIGZzVHlwZTogJycsXG4gICAgICAgICAgICAgIG1vdW50OiAnJyxcbiAgICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgICAgcGh5c2ljYWw6ICdIREQnLFxuICAgICAgICAgICAgICB1dWlkOiAnJyxcbiAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICBtb2RlbDogJycsXG4gICAgICAgICAgICAgIHNlcmlhbDogJycsXG4gICAgICAgICAgICAgIHJlbW92YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHByb3RvY29sOiAnJyxcbiAgICAgICAgICAgICAgZ3JvdXA6ICcnLFxuICAgICAgICAgICAgICBkZXZpY2U6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnRyaW0oKS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLyArL2csICcnKTtcbiAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICBpZiAoJ0RFVklDRUlERU5USUZJRVInID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLmlkZW50aWZpZXIgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnREVWSUNFTk9ERScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0ubmFtZSA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdWT0xVTUVOQU1FJyA9PT0gcGFydHNbMF0pIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1sxXS5pbmRleE9mKCdOb3QgYXBwbGljYWJsZScpID09PSAtMSkgeyBkZXZpY2VzW2ldLmxhYmVsID0gcGFydHNbMV07IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdQUk9UT0NPTCcgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0ucHJvdG9jb2wgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnRElTS1NJWkUnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnNpemUgPSBwYXJzZUJ5dGVzKHBhcnRzWzFdKTsgfVxuICAgICAgICAgIGlmICgnRklMRVNZU1RFTVBFUlNPTkFMSVRZJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5mc1R5cGUgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnTU9VTlRQT0lOVCcgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0ubW91bnQgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnVk9MVU1FVVVJRCcgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0udXVpZCA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgaWYgKCdSRUFELU9OTFlNRURJQScgPT09IHBhcnRzWzBdICYmIHBhcnRzWzFdID09PSAnWWVzJykgeyBkZXZpY2VzW2ldLnBoeXNpY2FsID0gJ0NEL0RWRCc7IH1cbiAgICAgICAgICBpZiAoJ1NPTElEU1RBVEUnID09PSBwYXJ0c1swXSAmJiBwYXJ0c1sxXSA9PT0gJ1llcycpIHsgZGV2aWNlc1tpXS5waHlzaWNhbCA9ICdTU0QnOyB9XG4gICAgICAgICAgaWYgKCdWSVJUVUFMJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS50eXBlID0gJ3ZpcnR1YWwnOyB9XG4gICAgICAgICAgaWYgKCdSRU1PVkFCTEVNRURJQScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0ucmVtb3ZhYmxlID0gKHBhcnRzWzFdID09PSAnUmVtb3ZhYmxlJyk7IH1cbiAgICAgICAgICBpZiAoJ1BBUlRJVElPTlRZUEUnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnR5cGUgPSAncGFydCc7IH1cbiAgICAgICAgICBpZiAoJ0RFVklDRS9NRURJQU5BTUUnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLm1vZGVsID0gcGFydHNbMV07IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXZpY2VzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJsayhsaW5lcykge1xuICBsZXQgZGF0YSA9IFtdO1xuXG4gIGxpbmVzLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxpbmUgPSBkZWNvZGVVUklDb21wb25lbnQobGluZS5yZXBsYWNlKC9cXFxceC9nLCAnJScpKTtcbiAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7XG4gICAgICBsZXQgZGlzayA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICAnbmFtZSc6IGRpc2submFtZSxcbiAgICAgICAgJ3R5cGUnOiBkaXNrLnR5cGUsXG4gICAgICAgICdmc1R5cGUnOiBkaXNrLmZzVHlwZSxcbiAgICAgICAgJ21vdW50JzogZGlzay5tb3VudHBvaW50LFxuICAgICAgICAnc2l6ZSc6IHBhcnNlSW50KGRpc2suc2l6ZSksXG4gICAgICAgICdwaHlzaWNhbCc6IChkaXNrLnR5cGUgPT09ICdkaXNrJyA/IChkaXNrLnJvdGEgPT09ICcwJyA/ICdTU0QnIDogJ0hERCcpIDogKGRpc2sudHlwZSA9PT0gJ3JvbScgPyAnQ0QvRFZEJyA6ICcnKSksXG4gICAgICAgICd1dWlkJzogZGlzay51dWlkLFxuICAgICAgICAnbGFiZWwnOiBkaXNrLmxhYmVsLFxuICAgICAgICAnbW9kZWwnOiAoZGlzay5tb2RlbCB8fCAnJykudHJpbSgpLFxuICAgICAgICAnc2VyaWFsJzogZGlzay5zZXJpYWwsXG4gICAgICAgICdyZW1vdmFibGUnOiBkaXNrLnJtID09PSAnMScsXG4gICAgICAgICdwcm90b2NvbCc6IGRpc2sudHJhbixcbiAgICAgICAgJ2dyb3VwJzogZGlzay5ncm91cCB8fCAnJyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHV0aWwubm9vcCgpO1xuICAgIH1cbiAgfSk7XG4gIGRhdGEgPSB1dGlsLnVuaXF1ZShkYXRhKTtcbiAgZGF0YSA9IHV0aWwuc29ydEJ5S2V5KGRhdGEsIFsndHlwZScsICduYW1lJ10pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlTWRhYm1EYXRhKGxpbmVzKSB7XG4gIGNvbnN0IHJhaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWRfbGV2ZWwnLCAnPScpO1xuICBjb25zdCBsYWJlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZF9uYW1lJywgJz0nKTsgLy8gPC0gZ2V0IGxhYmVsIGluZm9cbiAgY29uc3QgdXVpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZF91dWlkJywgJz0nKTsgLy8gPC0gZ2V0IHV1aWQgaW5mb1xuICBjb25zdCBtZW1iZXJzID0gW107XG4gIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdtZF9kZXZpY2VfZGV2JykgJiYgbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy9kZXYvJykgPiAwKSB7XG4gICAgICBtZW1iZXJzLnB1c2gobGluZS5zcGxpdCgnL2Rldi8nKVsxXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByYWlkLFxuICAgIGxhYmVsLFxuICAgIHV1aWQsXG4gICAgbWVtYmVyc1xuICB9O1xufVxuXG5mdW5jdGlvbiByYWlkTWF0Y2hMaW51eChkYXRhKSB7XG4gIC8vIGZvciBhbGwgYmxvY2sgZGV2aWNlcyBvZiB0eXBlIFwicmFpZCVcIlxuICBsZXQgcmVzdWx0ID0gZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoJ3JhaWQnKSkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGBtZGFkbSAtLWV4cG9ydCAtLWRldGFpbCAvZGV2LyR7ZWxlbWVudC5uYW1lfWApLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBtZERhdGEgPSBkZWNvZGVNZGFibURhdGEobGluZXMpO1xuXG4gICAgICAgIGVsZW1lbnQubGFiZWwgPSBtZERhdGEubGFiZWw7IC8vIDwtIGFzc2lnbiBsYWJlbCBpbmZvXG4gICAgICAgIGVsZW1lbnQudXVpZCA9IG1kRGF0YS51dWlkOyAvLyA8LSBhc3NpZ24gdXVpZCBpbmZvXG5cbiAgICAgICAgaWYgKG1kRGF0YS5tZW1iZXJzICYmIG1kRGF0YS5tZW1iZXJzLmxlbmd0aCAmJiBtZERhdGEucmFpZCA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChibG9ja2RldmljZSA9PiB7XG4gICAgICAgICAgICBpZiAoYmxvY2tkZXZpY2UuZnNUeXBlID09PSAnbGludXhfcmFpZF9tZW1iZXInICYmIG1kRGF0YS5tZW1iZXJzLmluZGV4T2YoYmxvY2tkZXZpY2UubmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICBibG9ja2RldmljZS5ncm91cCA9IGVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBibG9ja2RldmljZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2aWNlc0xpbnV4KGRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGRhdGEuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoJ2Rpc2snKSkge1xuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudC5uYW1lKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXRjaERldmljZXNMaW51eChkYXRhKSB7XG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICB0cnkge1xuICAgIGNvbnN0IGRldmljZXMgPSBnZXREZXZpY2VzTGludXgoZGF0YSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChibG9ja2RldmljZSA9PiB7XG4gICAgICBpZiAoYmxvY2tkZXZpY2UudHlwZS5zdGFydHNXaXRoKCdwYXJ0JykgfHwgYmxvY2tkZXZpY2UudHlwZS5zdGFydHNXaXRoKCdkaXNrJykpIHtcbiAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGlmIChibG9ja2RldmljZS5uYW1lLnN0YXJ0c1dpdGgoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGJsb2NrZGV2aWNlLmRldmljZSA9ICcvZGV2LycgKyBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmxvY2tkZXZpY2U7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXREZXZpY2VzTWFjKGRhdGEpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGRhdGEuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudC50eXBlLnN0YXJ0c1dpdGgoJ2Rpc2snKSkge1xuICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBlbGVtZW50Lm5hbWUsIG1vZGVsOiBlbGVtZW50Lm1vZGVsLCBkZXZpY2U6IGVsZW1lbnQubmFtZSB9KTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKCd2aXJ0dWFsJykpIHtcbiAgICAgIGxldCBkZXZpY2UgPSAnJztcbiAgICAgIHJlc3VsdC5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBpZiAoZS5tb2RlbCA9PT0gZWxlbWVudC5tb2RlbCkge1xuICAgICAgICAgIGRldmljZSA9IGUuZGV2aWNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkZXZpY2UpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBlbGVtZW50Lm5hbWUsIG1vZGVsOiBlbGVtZW50Lm1vZGVsLCBkZXZpY2UgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hEZXZpY2VzTWFjKGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IGRhdGE7XG4gIHRyeSB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGdldERldmljZXNNYWMoZGF0YSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChibG9ja2RldmljZSA9PiB7XG4gICAgICBpZiAoYmxvY2tkZXZpY2UudHlwZS5zdGFydHNXaXRoKCdwYXJ0JykgfHwgYmxvY2tkZXZpY2UudHlwZS5zdGFydHNXaXRoKCdkaXNrJykgfHwgYmxvY2tkZXZpY2UudHlwZS5zdGFydHNXaXRoKCd2aXJ0dWFsJykpIHtcbiAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGlmIChibG9ja2RldmljZS5uYW1lLnN0YXJ0c1dpdGgoZWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgICAgYmxvY2tkZXZpY2UuZGV2aWNlID0gZWxlbWVudC5kZXZpY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9ja2RldmljZTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldERldmljZXNXaW4oZGlza0RyaXZlcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZGlza0RyaXZlcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gZWxlbWVudC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgY29uc3QgZGV2aWNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RldmljZUlEJywgJzonKTtcbiAgICBsZXQgcGFydGl0aW9ucyA9IGVsZW1lbnQuc3BsaXQoJ0B7RGV2aWNlSUQ9Jyk7XG4gICAgaWYgKHBhcnRpdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgcGFydGl0aW9ucyA9IHBhcnRpdGlvbnMuc2xpY2UoMSk7XG4gICAgICBwYXJ0aXRpb25zLmZvckVhY2gocGFydGl0aW9uID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBwYXJ0aXRpb24uc3BsaXQoJzsnKVswXS50b1VwcGVyQ2FzZSgpLCBkZXZpY2UgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYXRjaERldmljZXNXaW4oZGF0YSwgZGlza0RyaXZlcykge1xuICBjb25zdCBkZXZpY2VzID0gZ2V0RGV2aWNlc1dpbihkaXNrRHJpdmVzKTtcbiAgZGF0YS5tYXAoZWxlbWVudCA9PiB7XG4gICAgY29uc3QgZmlsdGVyZXNEZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoKGUpID0+IHsgcmV0dXJuIGUubmFtZSA9PT0gZWxlbWVudC5uYW1lLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgIGlmIChmaWx0ZXJlc0RldmljZXMubGVuZ3RoID4gMCkge1xuICAgICAgZWxlbWVudC5kZXZpY2UgPSBmaWx0ZXJlc0RldmljZXNbMF0uZGV2aWNlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBibGtTdGRvdXRUb09iamVjdChzdGRvdXQpIHtcbiAgcmV0dXJuIHN0ZG91dC50b1N0cmluZygpXG4gICAgLnJlcGxhY2UoL05BTUU9L2csICd7XCJuYW1lXCI6JylcbiAgICAucmVwbGFjZSgvRlNUWVBFPS9nLCAnLFwiZnNUeXBlXCI6JylcbiAgICAucmVwbGFjZSgvVFlQRT0vZywgJyxcInR5cGVcIjonKVxuICAgIC5yZXBsYWNlKC9TSVpFPS9nLCAnLFwic2l6ZVwiOicpXG4gICAgLnJlcGxhY2UoL01PVU5UUE9JTlQ9L2csICcsXCJtb3VudHBvaW50XCI6JylcbiAgICAucmVwbGFjZSgvVVVJRD0vZywgJyxcInV1aWRcIjonKVxuICAgIC5yZXBsYWNlKC9ST1RBPS9nLCAnLFwicm90YVwiOicpXG4gICAgLnJlcGxhY2UoL1JPPS9nLCAnLFwicm9cIjonKVxuICAgIC5yZXBsYWNlKC9STT0vZywgJyxcInJtXCI6JylcbiAgICAucmVwbGFjZSgvVFJBTj0vZywgJyxcInRyYW5cIjonKVxuICAgIC5yZXBsYWNlKC9TRVJJQUw9L2csICcsXCJzZXJpYWxcIjonKVxuICAgIC5yZXBsYWNlKC9MQUJFTD0vZywgJyxcImxhYmVsXCI6JylcbiAgICAucmVwbGFjZSgvTU9ERUw9L2csICcsXCJtb2RlbFwiOicpXG4gICAgLnJlcGxhY2UoL09XTkVSPS9nLCAnLFwib3duZXJcIjonKVxuICAgIC5yZXBsYWNlKC9HUk9VUD0vZywgJyxcImdyb3VwXCI6JylcbiAgICAucmVwbGFjZSgvXFxuL2csICd9XFxuJyk7XG59XG5cbmZ1bmN0aW9uIGJsb2NrRGV2aWNlcyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSBbXTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vd2lraS51YnVudHV1c2Vycy5kZS9sc2Jsay9cbiAgICAgICAgLy8gZXhlYyhcImxzYmxrIC1ibyBOQU1FLFRZUEUsU0laRSxGU1RZUEUsTU9VTlRQT0lOVCxVVUlELFJPVEEsUk8sVFJBTixTRVJJQUwsTEFCRUwsTU9ERUwsT1dORVIsR1JPVVAsTU9ERSxBTElHTk1FTlQsTUlOLUlPLE9QVC1JTyxQSFktU0VDLExPRy1TRUMsU0NIRUQsUlEtU0laRSxSQSxXU0FNRVwiLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICBleGVjKCdsc2JsayAtYlBvIE5BTUUsVFlQRSxTSVpFLEZTVFlQRSxNT1VOVFBPSU5ULFVVSUQsUk9UQSxSTyxSTSxUUkFOLFNFUklBTCxMQUJFTCxNT0RFTCxPV05FUiAyPi9kZXYvbnVsbCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IGJsa1N0ZG91dFRvT2JqZWN0KHN0ZG91dCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgZGF0YSA9IHBhcnNlQmxrKGxpbmVzKTtcbiAgICAgICAgICAgIGRhdGEgPSByYWlkTWF0Y2hMaW51eChkYXRhKTtcbiAgICAgICAgICAgIGRhdGEgPSBtYXRjaERldmljZXNMaW51eChkYXRhKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ2xzYmxrIC1iUG8gTkFNRSxUWVBFLFNJWkUsRlNUWVBFLE1PVU5UUE9JTlQsVVVJRCxST1RBLFJPLFJNLExBQkVMLE1PREVMLE9XTkVSIDI+L2Rldi9udWxsJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBibGtTdGRvdXRUb09iamVjdChzdGRvdXQpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGFyc2VCbGsobGluZXMpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSByYWlkTWF0Y2hMaW51eChkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ2Rpc2t1dGlsIGluZm8gLWFsbCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIC8vIHBhcnNlIGxpbmVzIGludG8gdGVtcCBhcnJheSBvZiBkZXZpY2VzXG4gICAgICAgICAgICBkYXRhID0gcGFyc2VEZXZpY2VzKGxpbmVzKTtcbiAgICAgICAgICAgIGRhdGEgPSBtYXRjaERldmljZXNNYWMoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgZHJpdmV0eXBlcyA9IFsnVW5rbm93bicsICdOb1Jvb3QnLCAnUmVtb3ZhYmxlJywgJ0xvY2FsJywgJ05ldHdvcmsnLCAnQ0QvRFZEJywgJ1JBTSddO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHV0aWwud21pYygnbG9naWNhbGRpc2sgZ2V0IENhcHRpb24sRGVzY3JpcHRpb24sRGV2aWNlSUQsRHJpdmVUeXBlLEZpbGVTeXN0ZW0sRnJlZVNwYWNlLE5hbWUsU2l6ZSxWb2x1bWVOYW1lLFZvbHVtZVNlcmlhbE51bWJlciAvdmFsdWUnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgLy8gdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfbG9naWNhbGRpc2sgfCBzZWxlY3QgQ2FwdGlvbixEcml2ZVR5cGUsTmFtZSxGaWxlU3lzdGVtLFNpemUsVm9sdW1lU2VyaWFsTnVtYmVyLFZvbHVtZU5hbWUgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgLUNsYXNzTmFtZSBXaW4zMl9Mb2dpY2FsRGlzayB8IHNlbGVjdCBDYXB0aW9uLERyaXZlVHlwZSxOYW1lLEZpbGVTeXN0ZW0sU2l6ZSxWb2x1bWVTZXJpYWxOdW1iZXIsVm9sdW1lTmFtZSB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtV21pT2JqZWN0IC1DbGFzcyBXaW4zMl9kaXNrZHJpdmUgfCBTZWxlY3QtT2JqZWN0IC1Qcm9wZXJ0eSBQTlBEZXZpY2VJZCxEZXZpY2VJRCwgTW9kZWwsIFNpemUsIEB7TD1cXCdQYXJ0aXRpb25zXFwnOyBFPXskXy5HZXRSZWxhdGVkKFxcJ1dpbjMyX0Rpc2tQYXJ0aXRpb25cXCcpLkdldFJlbGF0ZWQoXFwnV2luMzJfTG9naWNhbERpc2tcXCcpIHwgU2VsZWN0LU9iamVjdCAtUHJvcGVydHkgRGV2aWNlSUQsIFZvbHVtZU5hbWUsIFNpemUsIEZyZWVTcGFjZX19IHwgZmwnKSk7XG4gICAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGxvZ2ljYWxEaXNrcyA9IHJlcy5yZXN1bHRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGxldCBkaXNrRHJpdmVzID0gcmVzLnJlc3VsdHNbMV0udG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgbG9naWNhbERpc2tzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBsZXQgZHJpdmV0eXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2RyaXZldHlwZScsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChkcml2ZXR5cGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpLFxuICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcHRpb24nLCAnOicpLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ2Rpc2snLFxuICAgICAgICAgICAgICAgICAgZnNUeXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZmlsZXN5c3RlbScsICc6JykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgIG1vdW50OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FwdGlvbicsICc6JyksXG4gICAgICAgICAgICAgICAgICBzaXplOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2l6ZScsICc6JyksXG4gICAgICAgICAgICAgICAgICBwaHlzaWNhbDogKGRyaXZldHlwZSA+PSAwICYmIGRyaXZldHlwZSA8PSA2KSA/IGRyaXZldHlwZXNbZHJpdmV0eXBlXSA6IGRyaXZldHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICB1dWlkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdW1lc2VyaWFsbnVtYmVyJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIGxhYmVsOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdW1lbmFtZScsICc6JyksXG4gICAgICAgICAgICAgICAgICBtb2RlbDogJycsXG4gICAgICAgICAgICAgICAgICBzZXJpYWw6IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x1bWVzZXJpYWxudW1iZXInLCAnOicpLFxuICAgICAgICAgICAgICAgICAgcmVtb3ZhYmxlOiBkcml2ZXR5cGUgPT09ICcyJyxcbiAgICAgICAgICAgICAgICAgIHByb3RvY29sOiAnJyxcbiAgICAgICAgICAgICAgICAgIGdyb3VwOiAnJyxcbiAgICAgICAgICAgICAgICAgIGRldmljZTogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBtYXRjaCBkZXZpY2VzXG4gICAgICAgICAgICBkYXRhID0gbWF0Y2hEZXZpY2VzV2luKGRhdGEsIGRpc2tEcml2ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIC8vIHdpbGwgZm9sbG93XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmJsb2NrRGV2aWNlcyA9IGJsb2NrRGV2aWNlcztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZTIC0gc3BlZWRcblxuZnVuY3Rpb24gY2FsY0ZzU3BlZWQocngsIHd4KSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgcng6IDAsXG4gICAgd3g6IDAsXG4gICAgdHg6IDAsXG4gICAgcnhfc2VjOiBudWxsLFxuICAgIHd4X3NlYzogbnVsbCxcbiAgICB0eF9zZWM6IG51bGwsXG4gICAgbXM6IDBcbiAgfTtcblxuICBpZiAoX2ZzX3NwZWVkICYmIF9mc19zcGVlZC5tcykge1xuICAgIHJlc3VsdC5yeCA9IHJ4O1xuICAgIHJlc3VsdC53eCA9IHd4O1xuICAgIHJlc3VsdC50eCA9IHJlc3VsdC5yeCArIHJlc3VsdC53eDtcbiAgICByZXN1bHQubXMgPSBEYXRlLm5vdygpIC0gX2ZzX3NwZWVkLm1zO1xuICAgIHJlc3VsdC5yeF9zZWMgPSAocmVzdWx0LnJ4IC0gX2ZzX3NwZWVkLmJ5dGVzX3JlYWQpIC8gKHJlc3VsdC5tcyAvIDEwMDApO1xuICAgIHJlc3VsdC53eF9zZWMgPSAocmVzdWx0Lnd4IC0gX2ZzX3NwZWVkLmJ5dGVzX3dyaXRlKSAvIChyZXN1bHQubXMgLyAxMDAwKTtcbiAgICByZXN1bHQudHhfc2VjID0gcmVzdWx0LnJ4X3NlYyArIHJlc3VsdC53eF9zZWM7XG4gICAgX2ZzX3NwZWVkLnJ4X3NlYyA9IHJlc3VsdC5yeF9zZWM7XG4gICAgX2ZzX3NwZWVkLnd4X3NlYyA9IHJlc3VsdC53eF9zZWM7XG4gICAgX2ZzX3NwZWVkLnR4X3NlYyA9IHJlc3VsdC50eF9zZWM7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX3JlYWQgPSByZXN1bHQucng7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX3dyaXRlID0gcmVzdWx0Lnd4O1xuICAgIF9mc19zcGVlZC5ieXRlc19vdmVyYWxsID0gcmVzdWx0LnJ4ICsgcmVzdWx0Lnd4O1xuICAgIF9mc19zcGVlZC5tcyA9IERhdGUubm93KCk7XG4gICAgX2ZzX3NwZWVkLmxhc3RfbXMgPSByZXN1bHQubXM7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnJ4ID0gcng7XG4gICAgcmVzdWx0Lnd4ID0gd3g7XG4gICAgcmVzdWx0LnR4ID0gcmVzdWx0LnJ4ICsgcmVzdWx0Lnd4O1xuICAgIF9mc19zcGVlZC5yeF9zZWMgPSBudWxsO1xuICAgIF9mc19zcGVlZC53eF9zZWMgPSBudWxsO1xuICAgIF9mc19zcGVlZC50eF9zZWMgPSBudWxsO1xuICAgIF9mc19zcGVlZC5ieXRlc19yZWFkID0gcmVzdWx0LnJ4O1xuICAgIF9mc19zcGVlZC5ieXRlc193cml0ZSA9IHJlc3VsdC53eDtcbiAgICBfZnNfc3BlZWQuYnl0ZXNfb3ZlcmFsbCA9IHJlc3VsdC5yeCArIHJlc3VsdC53eDtcbiAgICBfZnNfc3BlZWQubXMgPSBEYXRlLm5vdygpO1xuICAgIF9mc19zcGVlZC5sYXN0X21zID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmc1N0YXRzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoX3dpbmRvd3MgfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfc3Vub3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHJ4OiAwLFxuICAgICAgICB3eDogMCxcbiAgICAgICAgdHg6IDAsXG4gICAgICAgIHJ4X3NlYzogbnVsbCxcbiAgICAgICAgd3hfc2VjOiBudWxsLFxuICAgICAgICB0eF9zZWM6IG51bGwsXG4gICAgICAgIG1zOiAwXG4gICAgICB9O1xuXG4gICAgICBsZXQgcnggPSAwO1xuICAgICAgbGV0IHd4ID0gMDtcbiAgICAgIGlmICgoX2ZzX3NwZWVkICYmICFfZnNfc3BlZWQubXMpIHx8IChfZnNfc3BlZWQgJiYgX2ZzX3NwZWVkLm1zICYmIERhdGUubm93KCkgLSBfZnNfc3BlZWQubXMgPj0gNTAwKSkge1xuICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgLy8gZXhlYyhcImRmIC1rIHwgZ3JlcCAvZGV2L1wiLCBmdW5jdGlvbihlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgZXhlYygnbHNibGsgLXIgMj4vZGV2L251bGwgfCBncmVwIC8nLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsZXQgZnNfZmlsdGVyID0gW107XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGZzX2ZpbHRlci5pbmRleE9mKGxpbmVbMF0pID09PSAtMSkgeyBmc19maWx0ZXIucHVzaChsaW5lWzBdKTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IGZzX2ZpbHRlci5qb2luKCd8Jyk7XG4gICAgICAgICAgICAgIGV4ZWMoJ2NhdCAvcHJvYy9kaXNrc3RhdHMgfCBlZ3JlcCBcIicgKyBvdXRwdXQgKyAnXCInLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgcnggKz0gcGFyc2VJbnQobGluZVs1XSkgKiA1MTI7XG4gICAgICAgICAgICAgICAgICAgICAgd3ggKz0gcGFyc2VJbnQobGluZVs5XSkgKiA1MTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY0ZzU3BlZWQocngsIHd4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBleGVjKCdpb3JlZyAtYyBJT0Jsb2NrU3RvcmFnZURyaXZlciAtayBTdGF0aXN0aWNzIC1yIC13MCB8IHNlZCAtbiBcIi9JT0Jsb2NrU3RvcmFnZURyaXZlci8sL1N0YXRpc3RpY3MvcFwiIHwgZ3JlcCBcIlN0YXRpc3RpY3NcIiB8IHRyIC1jZCBcIjAxMjM0NTY3ODkwLFxcblwiJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICAgIHJ4ICs9IHBhcnNlSW50KGxpbmVbMl0pO1xuICAgICAgICAgICAgICAgICAgd3ggKz0gcGFyc2VJbnQobGluZVs5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY0ZzU3BlZWQocngsIHd4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQubXMgPSBfZnNfc3BlZWQubGFzdF9tcztcbiAgICAgICAgcmVzdWx0LnJ4ID0gX2ZzX3NwZWVkLmJ5dGVzX3JlYWQ7XG4gICAgICAgIHJlc3VsdC53eCA9IF9mc19zcGVlZC5ieXRlc193cml0ZTtcbiAgICAgICAgcmVzdWx0LnR4ID0gX2ZzX3NwZWVkLmJ5dGVzX3JlYWQgKyBfZnNfc3BlZWQuYnl0ZXNfd3JpdGU7XG4gICAgICAgIHJlc3VsdC5yeF9zZWMgPSBfZnNfc3BlZWQucnhfc2VjO1xuICAgICAgICByZXN1bHQud3hfc2VjID0gX2ZzX3NwZWVkLnd4X3NlYztcbiAgICAgICAgcmVzdWx0LnR4X3NlYyA9IF9mc19zcGVlZC50eF9zZWM7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5mc1N0YXRzID0gZnNTdGF0cztcblxuZnVuY3Rpb24gY2FsY0Rpc2tJTyhySU8sIHdJTywgcldhaXRUaW1lLCB3V2FpdFRpbWUsIHRXYWl0VGltZSkge1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIHJJTzogMCxcbiAgICB3SU86IDAsXG4gICAgdElPOiAwLFxuICAgIHJJT19zZWM6IG51bGwsXG4gICAgd0lPX3NlYzogbnVsbCxcbiAgICB0SU9fc2VjOiBudWxsLFxuICAgIHJXYWl0VGltZTogMCxcbiAgICB3V2FpdFRpbWU6IDAsXG4gICAgdFdhaXRUaW1lOiAwLFxuICAgIHJXYWl0UGVyY2VudDogbnVsbCxcbiAgICB3V2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgdFdhaXRQZXJjZW50OiBudWxsLFxuICAgIG1zOiAwXG4gIH07XG4gIGlmIChfZGlza19pbyAmJiBfZGlza19pby5tcykge1xuICAgIHJlc3VsdC5ySU8gPSBySU87XG4gICAgcmVzdWx0LndJTyA9IHdJTztcbiAgICByZXN1bHQudElPID0gcklPICsgd0lPO1xuICAgIHJlc3VsdC5tcyA9IERhdGUubm93KCkgLSBfZGlza19pby5tcztcbiAgICByZXN1bHQucklPX3NlYyA9IChyZXN1bHQucklPIC0gX2Rpc2tfaW8ucklPKSAvIChyZXN1bHQubXMgLyAxMDAwKTtcbiAgICByZXN1bHQud0lPX3NlYyA9IChyZXN1bHQud0lPIC0gX2Rpc2tfaW8ud0lPKSAvIChyZXN1bHQubXMgLyAxMDAwKTtcbiAgICByZXN1bHQudElPX3NlYyA9IHJlc3VsdC5ySU9fc2VjICsgcmVzdWx0LndJT19zZWM7XG4gICAgcmVzdWx0LnJXYWl0VGltZSA9IHJXYWl0VGltZTtcbiAgICByZXN1bHQud1dhaXRUaW1lID0gd1dhaXRUaW1lO1xuICAgIHJlc3VsdC50V2FpdFRpbWUgPSB0V2FpdFRpbWU7XG4gICAgcmVzdWx0LnJXYWl0UGVyY2VudCA9IChyZXN1bHQucldhaXRUaW1lIC0gX2Rpc2tfaW8ucldhaXRUaW1lKSAqIDEwMCAvIChyZXN1bHQubXMpO1xuICAgIHJlc3VsdC53V2FpdFBlcmNlbnQgPSAocmVzdWx0LndXYWl0VGltZSAtIF9kaXNrX2lvLndXYWl0VGltZSkgKiAxMDAgLyAocmVzdWx0Lm1zKTtcbiAgICByZXN1bHQudFdhaXRQZXJjZW50ID0gKHJlc3VsdC50V2FpdFRpbWUgLSBfZGlza19pby50V2FpdFRpbWUpICogMTAwIC8gKHJlc3VsdC5tcyk7XG4gICAgX2Rpc2tfaW8ucklPID0gcklPO1xuICAgIF9kaXNrX2lvLndJTyA9IHdJTztcbiAgICBfZGlza19pby5ySU9fc2VjID0gcmVzdWx0LnJJT19zZWM7XG4gICAgX2Rpc2tfaW8ud0lPX3NlYyA9IHJlc3VsdC53SU9fc2VjO1xuICAgIF9kaXNrX2lvLnRJT19zZWMgPSByZXN1bHQudElPX3NlYztcbiAgICBfZGlza19pby5yV2FpdFRpbWUgPSByV2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8ud1dhaXRUaW1lID0gd1dhaXRUaW1lO1xuICAgIF9kaXNrX2lvLnRXYWl0VGltZSA9IHRXYWl0VGltZTtcbiAgICBfZGlza19pby5yV2FpdFBlcmNlbnQgPSByZXN1bHQucldhaXRQZXJjZW50O1xuICAgIF9kaXNrX2lvLndXYWl0UGVyY2VudCA9IHJlc3VsdC53V2FpdFBlcmNlbnQ7XG4gICAgX2Rpc2tfaW8udFdhaXRQZXJjZW50ID0gcmVzdWx0LnRXYWl0UGVyY2VudDtcbiAgICBfZGlza19pby5sYXN0X21zID0gcmVzdWx0Lm1zO1xuICAgIF9kaXNrX2lvLm1zID0gRGF0ZS5ub3coKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucklPID0gcklPO1xuICAgIHJlc3VsdC53SU8gPSB3SU87XG4gICAgcmVzdWx0LnRJTyA9IHJJTyArIHdJTztcbiAgICByZXN1bHQucldhaXRUaW1lID0gcldhaXRUaW1lO1xuICAgIHJlc3VsdC53V2FpdFRpbWUgPSB3V2FpdFRpbWU7XG4gICAgcmVzdWx0LnRXYWl0VGltZSA9IHRXYWl0VGltZTtcbiAgICBfZGlza19pby5ySU8gPSBySU87XG4gICAgX2Rpc2tfaW8ud0lPID0gd0lPO1xuICAgIF9kaXNrX2lvLnJJT19zZWMgPSBudWxsO1xuICAgIF9kaXNrX2lvLndJT19zZWMgPSBudWxsO1xuICAgIF9kaXNrX2lvLnRJT19zZWMgPSBudWxsO1xuICAgIF9kaXNrX2lvLnJXYWl0VGltZSA9IHJXYWl0VGltZTtcbiAgICBfZGlza19pby53V2FpdFRpbWUgPSB3V2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8udFdhaXRUaW1lID0gdFdhaXRUaW1lO1xuICAgIF9kaXNrX2lvLnJXYWl0UGVyY2VudCA9IG51bGw7XG4gICAgX2Rpc2tfaW8ud1dhaXRQZXJjZW50ID0gbnVsbDtcbiAgICBfZGlza19pby50V2FpdFBlcmNlbnQgPSBudWxsO1xuICAgIF9kaXNrX2lvLmxhc3RfbXMgPSAwO1xuICAgIF9kaXNrX2lvLm1zID0gRGF0ZS5ub3coKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkaXNrc0lPKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBySU86IDAsXG4gICAgICAgIHdJTzogMCxcbiAgICAgICAgdElPOiAwLFxuICAgICAgICBySU9fc2VjOiBudWxsLFxuICAgICAgICB3SU9fc2VjOiBudWxsLFxuICAgICAgICB0SU9fc2VjOiBudWxsLFxuICAgICAgICByV2FpdFRpbWU6IDAsXG4gICAgICAgIHdXYWl0VGltZTogMCxcbiAgICAgICAgdFdhaXRUaW1lOiAwLFxuICAgICAgICByV2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgICAgIHdXYWl0UGVyY2VudDogbnVsbCxcbiAgICAgICAgdFdhaXRQZXJjZW50OiBudWxsLFxuICAgICAgICBtczogMFxuICAgICAgfTtcbiAgICAgIGxldCBySU8gPSAwO1xuICAgICAgbGV0IHdJTyA9IDA7XG4gICAgICBsZXQgcldhaXRUaW1lID0gMDtcbiAgICAgIGxldCB3V2FpdFRpbWUgPSAwO1xuICAgICAgbGV0IHRXYWl0VGltZSA9IDA7XG5cbiAgICAgIGlmICgoX2Rpc2tfaW8gJiYgIV9kaXNrX2lvLm1zKSB8fCAoX2Rpc2tfaW8gJiYgX2Rpc2tfaW8ubXMgJiYgRGF0ZS5ub3coKSAtIF9kaXNrX2lvLm1zID49IDUwMCkpIHtcbiAgICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgLy8gcHJpbnRzIEJsb2NrIGxheWVyIHN0YXRpc3RpY3MgZm9yIGFsbCBtb3VudGVkIHZvbHVtZXNcbiAgICAgICAgICAvLyB2YXIgY21kID0gXCJmb3IgbW91bnQgaW4gYGxzYmxrIHwgZ3JlcCAvIHwgc2VkIC1yICdzL+KUgiDilJTilIAvLycgfCBjdXQgLWQgJyAnIC1mIDFgOyBkbyBjYXQgL3N5cy9ibG9jay8kbW91bnQvc3RhdCB8IHNlZCAtciAncy8gKy87L2cnIHwgc2VkIC1yICdzL147Ly8nOyBkb25lXCI7XG4gICAgICAgICAgLy8gdmFyIGNtZCA9IFwiZm9yIG1vdW50IGluIGBsc2JsayB8IGdyZXAgLyB8IHNlZCAncy9b4pSC4pSU4pSA4pScXS8vZycgfCBhd2sgJ3skMT0kMX07MScgfCBjdXQgLWQgJyAnIC1mIDEgfCBzb3J0IC11YDsgZG8gY2F0IC9zeXMvYmxvY2svJG1vdW50L3N0YXQgfCBzZWQgLXIgJ3MvICsvOy9nJyB8IHNlZCAtciAncy9eOy8vJzsgZG9uZVwiO1xuICAgICAgICAgIGxldCBjbWQgPSAnZm9yIG1vdW50IGluIGBsc2JsayAyPi9kZXYvbnVsbCB8IGdyZXAgXCIgZGlzayBcIiB8IHNlZCBcInMvW+KUguKUlOKUgOKUnF0vL2dcIiB8IGF3ayBcXCd7JDE9JDF9OzFcXCcgfCBjdXQgLWQgXCIgXCIgLWYgMSB8IHNvcnQgLXVgOyBkbyBjYXQgL3N5cy9ibG9jay8kbW91bnQvc3RhdCB8IHNlZCAtciBcInMvICsvOy9nXCIgfCBzZWQgLXIgXCJzL147Ly9cIjsgZG9uZSc7XG5cbiAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdW0gci93SU8gb2YgYWxsIGRpc2tzIHRvIGNvbXB1dGUgYWxsIGRpc2tzIElPXG4gICAgICAgICAgICAgICAgbGV0IHN0YXRzID0gbGluZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgIHJJTyArPSBwYXJzZUludChzdGF0c1swXSk7XG4gICAgICAgICAgICAgICAgd0lPICs9IHBhcnNlSW50KHN0YXRzWzRdKTtcbiAgICAgICAgICAgICAgICByV2FpdFRpbWUgKz0gcGFyc2VJbnQoc3RhdHNbM10pO1xuICAgICAgICAgICAgICAgIHdXYWl0VGltZSArPSBwYXJzZUludChzdGF0c1s3XSk7XG4gICAgICAgICAgICAgICAgdFdhaXRUaW1lICs9IHBhcnNlSW50KHN0YXRzWzEwXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjRGlza0lPKHJJTywgd0lPLCByV2FpdFRpbWUsIHdXYWl0VGltZSwgdFdhaXRUaW1lKTtcblxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgZXhlYygnaW9yZWcgLWMgSU9CbG9ja1N0b3JhZ2VEcml2ZXIgLWsgU3RhdGlzdGljcyAtciAtdzAgfCBzZWQgLW4gXCIvSU9CbG9ja1N0b3JhZ2VEcml2ZXIvLC9TdGF0aXN0aWNzL3BcIiB8IGdyZXAgXCJTdGF0aXN0aWNzXCIgfCB0ciAtY2QgXCIwMTIzNDU2Nzg5MCxcXG5cIicsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgICBySU8gKz0gcGFyc2VJbnQobGluZVsxMF0pO1xuICAgICAgICAgICAgICAgICAgd0lPICs9IHBhcnNlSW50KGxpbmVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNEaXNrSU8ocklPLCB3SU8sIHJXYWl0VGltZSwgd1dhaXRUaW1lLCB0V2FpdFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5ySU8gPSBfZGlza19pby5ySU87XG4gICAgICAgIHJlc3VsdC53SU8gPSBfZGlza19pby53SU87XG4gICAgICAgIHJlc3VsdC50SU8gPSBfZGlza19pby5ySU8gKyBfZGlza19pby53SU87XG4gICAgICAgIHJlc3VsdC5tcyA9IF9kaXNrX2lvLmxhc3RfbXM7XG4gICAgICAgIHJlc3VsdC5ySU9fc2VjID0gX2Rpc2tfaW8ucklPX3NlYztcbiAgICAgICAgcmVzdWx0LndJT19zZWMgPSBfZGlza19pby53SU9fc2VjO1xuICAgICAgICByZXN1bHQudElPX3NlYyA9IF9kaXNrX2lvLnRJT19zZWM7XG4gICAgICAgIHJlc3VsdC5yV2FpdFRpbWUgPSBfZGlza19pby5yV2FpdFRpbWU7XG4gICAgICAgIHJlc3VsdC53V2FpdFRpbWUgPSBfZGlza19pby53V2FpdFRpbWU7XG4gICAgICAgIHJlc3VsdC50V2FpdFRpbWUgPSBfZGlza19pby50V2FpdFRpbWU7XG4gICAgICAgIHJlc3VsdC5yV2FpdFBlcmNlbnQgPSBfZGlza19pby5yV2FpdFBlcmNlbnQ7XG4gICAgICAgIHJlc3VsdC53V2FpdFBlcmNlbnQgPSBfZGlza19pby53V2FpdFBlcmNlbnQ7XG4gICAgICAgIHJlc3VsdC50V2FpdFBlcmNlbnQgPSBfZGlza19pby50V2FpdFBlcmNlbnQ7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kaXNrc0lPID0gZGlza3NJTztcblxuZnVuY3Rpb24gZGlza0xheW91dChjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIGdldFZlbmRvckZyb21Nb2RlbChtb2RlbCkge1xuICAgIGNvbnN0IGRpc2tNYW51ZmFjdHVyZXJzID0gW1xuICAgICAgeyBwYXR0ZXJuOiAnV0VTVEVSTi4qJywgbWFudWZhY3R1cmVyOiAnV2VzdGVybiBEaWdpdGFsJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXldEQy4qJywgbWFudWZhY3R1cmVyOiAnV2VzdGVybiBEaWdpdGFsJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnV0QuKicsIG1hbnVmYWN0dXJlcjogJ1dlc3Rlcm4gRGlnaXRhbCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ1RPU0hJQkEuKicsIG1hbnVmYWN0dXJlcjogJ1Rvc2hpYmEnIH0sXG4gICAgICB7IHBhdHRlcm46ICdISVRBQ0hJLionLCBtYW51ZmFjdHVyZXI6ICdIaXRhY2hpJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXklDLionLCBtYW51ZmFjdHVyZXI6ICdIaXRhY2hpJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXkhUUy4qJywgbWFudWZhY3R1cmVyOiAnSGl0YWNoaScgfSxcbiAgICAgIHsgcGF0dGVybjogJ1NBTkRJU0suKicsIG1hbnVmYWN0dXJlcjogJ1NhbkRpc2snIH0sXG4gICAgICB7IHBhdHRlcm46ICdLSU5HU1RPTi4qJywgbWFudWZhY3R1cmVyOiAnS2luZ3N0b24gVGVjaG5vbG9neScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15TT05ZLionLCBtYW51ZmFjdHVyZXI6ICdTb255JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnVFJBTlNDRU5ELionLCBtYW51ZmFjdHVyZXI6ICdUcmFuc2NlbmQnIH0sXG4gICAgICB7IHBhdHRlcm46ICdTQU1TVU5HLionLCBtYW51ZmFjdHVyZXI6ICdTYW1zdW5nJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXlNUKD8hSVxcXFwgKS4qJywgbWFudWZhY3R1cmVyOiAnU2VhZ2F0ZScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15TVElcXFxcIC4qJywgbWFudWZhY3R1cmVyOiAnU2ltcGxlVGVjaCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ15ELi4uLS4qJywgbWFudWZhY3R1cmVyOiAnSUJNJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXklCTS4qJywgbWFudWZhY3R1cmVyOiAnSUJNJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXkZVSklUU1UuKicsIG1hbnVmYWN0dXJlcjogJ0Z1aml0c3UnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeTVAuKicsIG1hbnVmYWN0dXJlcjogJ0Z1aml0c3UnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeTUsuKicsIG1hbnVmYWN0dXJlcjogJ1Rvc2hpYmEnIH0sXG4gICAgICB7IHBhdHRlcm46ICdNQVhUTy4qJywgbWFudWZhY3R1cmVyOiAnTWF4dG9yJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnUElPTkVFUi4qJywgbWFudWZhY3R1cmVyOiAnUGlvbmVlcicgfSxcbiAgICAgIHsgcGF0dGVybjogJ1BISUxJUFMuKicsIG1hbnVmYWN0dXJlcjogJ1BoaWxpcHMnIH0sXG4gICAgICB7IHBhdHRlcm46ICdRVUFOVFVNLionLCBtYW51ZmFjdHVyZXI6ICdRdWFudHVtIFRlY2hub2xvZ3knIH0sXG4gICAgICB7IHBhdHRlcm46ICdGSVJFQkFMTC4qJywgbWFudWZhY3R1cmVyOiAnUXVhbnR1bSBUZWNobm9sb2d5JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXlZCT1guKicsIG1hbnVmYWN0dXJlcjogJ1ZpcnR1YWxCb3gnIH0sXG4gICAgICB7IHBhdHRlcm46ICdDT1JTQUlSLionLCBtYW51ZmFjdHVyZXI6ICdDb3JzYWlyIENvbXBvbmVudHMnIH0sXG4gICAgICB7IHBhdHRlcm46ICdDUlVDSUFMLionLCBtYW51ZmFjdHVyZXI6ICdDcnVjaWFsJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnRUNNLionLCBtYW51ZmFjdHVyZXI6ICdFQ00nIH0sXG4gICAgICB7IHBhdHRlcm46ICdJTlRFTC4qJywgbWFudWZhY3R1cmVyOiAnSU5URUwnIH0sXG4gICAgICB7IHBhdHRlcm46ICdFVk8uKicsIG1hbnVmYWN0dXJlcjogJ1NhbXN1bmcnIH0sXG4gICAgICB7IHBhdHRlcm46ICdBUFBMRS4qJywgbWFudWZhY3R1cmVyOiAnQXBwbGUnIH0sXG4gICAgXTtcblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsID0gbW9kZWwudG9VcHBlckNhc2UoKTtcbiAgICAgIGRpc2tNYW51ZmFjdHVyZXJzLmZvckVhY2goKG1hbnVmYWN0dXJlcikgPT4ge1xuICAgICAgICBjb25zdCByZSA9IFJlZ0V4cChtYW51ZmFjdHVyZXIucGF0dGVybik7XG4gICAgICAgIGlmIChyZS50ZXN0KG1vZGVsKSkgeyByZXN1bHQgPSBtYW51ZmFjdHVyZXIubWFudWZhY3R1cmVyOyB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBjb25zdCBjb21taXRSZXN1bHQgPSByZXMgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSByZXNbaV0uQlNETmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH07XG5cbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGxldCBjbWQgPSAnJztcblxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBsZXQgY21kRnVsbFNtYXJ0ID0gJyc7XG5cbiAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBsc2JsayAtYWJsSk8gMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dCA9IHN0ZG91dC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBbXTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRKU09OID0gSlNPTi5wYXJzZShvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRKU09OICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwob3V0SlNPTiwgJ2Jsb2NrZGV2aWNlcycpKSB7XG4gICAgICAgICAgICAgICAgICBkZXZpY2VzID0gb3V0SlNPTi5ibG9ja2RldmljZXMuZmlsdGVyKGl0ZW0gPT4geyByZXR1cm4gKGl0ZW0udHlwZSA9PT0gJ2Rpc2snKSAmJiBpdGVtLnNpemUgPiAwICYmIChpdGVtLm1vZGVsICE9PSBudWxsIHx8IChpdGVtLm1vdW50cG9pbnQgPT09IG51bGwgJiYgaXRlbS5sYWJlbCA9PT0gbnVsbCAmJiBpdGVtLmZzdHlwZSA9PT0gbnVsbCAmJiBpdGVtLnBhcnR0eXBlID09PSBudWxsICYmIGl0ZW0ucGF0aCAmJiBpdGVtLnBhdGguaW5kZXhPZignL3JhbScpICE9PSAwICYmIGl0ZW0ucGF0aC5pbmRleE9mKCcvbG9vcCcpICE9PSAwICYmIGl0ZW1bJ2Rpc2MtbWF4J10gJiYgaXRlbVsnZGlzYy1tYXgnXSAhPT0gMCkpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbGRlciB2ZXJzaW9uIG9mIGxzYmxrXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0MiA9IGV4ZWNTeW5jKCdleHBvcnQgTENfQUxMPUM7IGxzYmxrIC1iUG8gTkFNRSxUWVBFLFNJWkUsRlNUWVBFLE1PVU5UUE9JTlQsVVVJRCxST1RBLFJPLFJNLExBQkVMLE1PREVMLE9XTkVSLEdST1VQIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGJsa1N0ZG91dFRvT2JqZWN0KG91dDIpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VCbGsobGluZXMpO1xuICAgICAgICAgICAgICAgIGRldmljZXMgPSBkYXRhLmZpbHRlcihpdGVtID0+IHsgcmV0dXJuIChpdGVtLnR5cGUgPT09ICdkaXNrJykgJiYgaXRlbS5zaXplID4gMCAmJiAoKGl0ZW0ubW9kZWwgIT09IG51bGwgJiYgaXRlbS5tb2RlbCAhPT0gJycpIHx8IChpdGVtLm1vdW50ID09PSAnJyAmJiBpdGVtLmxhYmVsID09PSAnJyAmJiBpdGVtLmZzVHlwZSA9PT0gJycpKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVkaXVtVHlwZSA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJTRE5hbWUgPSAnL2Rldi8nICsgZGV2aWNlLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9naWNhbCA9IGRldmljZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBtZWRpdW1UeXBlID0gZXhlY1N5bmMoJ2NhdCAvc3lzL2Jsb2NrLycgKyBsb2dpY2FsICsgJy9xdWV1ZS9yb3RhdGlvbmFsIDI+L2Rldi9udWxsJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmZhY2VUeXBlID0gZGV2aWNlLnRyYW4gPyBkZXZpY2UudHJhbi50b1VwcGVyQ2FzZSgpLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcmZhY2VUeXBlID09PSAnTlZNRScpIHtcbiAgICAgICAgICAgICAgICAgIG1lZGl1bVR5cGUgPSAnMic7XG4gICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlID0gJ1BDSWUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBkZXZpY2U6IEJTRE5hbWUsXG4gICAgICAgICAgICAgICAgICB0eXBlOiAobWVkaXVtVHlwZSA9PT0gJzAnID8gJ1NTRCcgOiAobWVkaXVtVHlwZSA9PT0gJzEnID8gJ0hEJyA6IChtZWRpdW1UeXBlID09PSAnMicgPyAnTlZNZScgOiAoZGV2aWNlLm1vZGVsICYmIGRldmljZS5tb2RlbC5pbmRleE9mKCdTU0QnKSA+IC0xID8gJ1NTRCcgOiAoZGV2aWNlLm1vZGVsICYmIGRldmljZS5tb2RlbC5pbmRleE9mKCdOVk0nKSA+IC0xID8gJ05WTWUnIDogJ0hEJykpKSkpLFxuICAgICAgICAgICAgICAgICAgbmFtZTogZGV2aWNlLm1vZGVsIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwoZGV2aWNlLm1vZGVsKSB8fCAoZGV2aWNlLnZlbmRvciA/IGRldmljZS52ZW5kb3IudHJpbSgpIDogJycpLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogZGV2aWNlLnNpemUgfHwgMCxcbiAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2VjdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdG90YWxDeWxpbmRlcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0b3RhbEhlYWRzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdG90YWxTZWN0b3JzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdG90YWxUcmFja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0cmFja3NQZXJDeWxpbmRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlY3RvcnNQZXJUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZpcm13YXJlUmV2aXNpb246IGRldmljZS5yZXYgPyBkZXZpY2UucmV2LnRyaW0oKSA6ICcnLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiBkZXZpY2Uuc2VyaWFsID8gZGV2aWNlLnNlcmlhbC50cmltKCkgOiAnJyxcbiAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGU6IGludGVyZmFjZVR5cGUsXG4gICAgICAgICAgICAgICAgICBzbWFydFN0YXR1czogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBCU0ROYW1lOiBCU0ROYW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY21kICs9IGBwcmludGYgXCJcXG4ke0JTRE5hbWV9fFwiOyBzbWFydGN0bCAtSCAke0JTRE5hbWV9IHwgZ3JlcCBvdmVyYWxsO2A7XG4gICAgICAgICAgICAgICAgY21kRnVsbFNtYXJ0ICs9IGAke2NtZEZ1bGxTbWFydCA/ICdwcmludGYgXCIsXCI7JyA6ICcnfXNtYXJ0Y3RsIC1hIC1qICR7QlNETmFtZX07YDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjaGVjayBTLk0uQS5SLlQuIHN0YXR1c1xuICAgICAgICAgIGlmIChjbWRGdWxsU21hcnQpIHtcbiAgICAgICAgICAgIGV4ZWMoY21kRnVsbFNtYXJ0LCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShgWyR7c3Rkb3V0fV1gKTtcbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZGlzayA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBkaXNrQlNETmFtZSA9IGRpc2suc21hcnRjdGwuYXJndltkaXNrLnNtYXJ0Y3RsLmFyZ3YubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0uQlNETmFtZSA9PT0gZGlza0JTRE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnRTdGF0dXMgPSAoZGlzay5zbWFydF9zdGF0dXMucGFzc2VkID8gJ09rJyA6IChkaXNrLnNtYXJ0X3N0YXR1cy5wYXNzZWQgPT09IGZhbHNlID8gJ1ByZWRpY3RlZCBGYWlsdXJlJyA6ICd1bmtub3duJykpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNrLnRlbXBlcmF0dXJlICYmIGRpc2sudGVtcGVyYXR1cmUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnRlbXBlcmF0dXJlID0gZGlzay50ZW1wZXJhdHVyZS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnREYXRhID0gZGlzaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbW1pdFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtZCkge1xuICAgICAgICAgICAgICAgICAgY21kID0gY21kICsgJ3ByaW50ZiBcIlxcblwiJztcbiAgICAgICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCU0ROYW1lID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMyID0gcGFydHNbMV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzMi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czJbMV0gPSBwYXJ0czJbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSBwYXJ0czJbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5CU0ROYW1lID09PSBCU0ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydFN0YXR1cyA9IChzdGF0dXMgPT09ICdwYXNzZWQnID8gJ09rJyA6IChzdGF0dXMgPT09ICdmYWlsZWQhJyA/ICdQcmVkaWN0ZWQgRmFpbHVyZScgOiAndW5rbm93bicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb21taXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21taXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzeXN0ZW1fcHJvZmlsZXIgU1BTZXJpYWxBVEFEYXRhVHlwZSBTUE5WTWVEYXRhVHlwZSBTUFVTQkRhdGFUeXBlJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgLy8gc3BsaXQgYnkgdHlwZTpcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGxldCBsaW5lc1NBVEEgPSBbXTtcbiAgICAgICAgICAgIGxldCBsaW5lc05WTWUgPSBbXTtcbiAgICAgICAgICAgIGxldCBsaW5lc1VTQiA9IFtdO1xuICAgICAgICAgICAgbGV0IGRhdGFUeXBlID0gJ1NBVEEnO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxpbmUgPT09ICdOVk1FeHByZXNzOicpIHsgZGF0YVR5cGUgPSAnTlZNZSc7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAobGluZSA9PT0gJ1VTQjonKSB7IGRhdGFUeXBlID0gJ1VTQic7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAobGluZSA9PT0gJ1NBVEEvU0FUQSBFeHByZXNzOicpIHsgZGF0YVR5cGUgPSAnU0FUQSc7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdTQVRBJykgeyBsaW5lc1NBVEEucHVzaChsaW5lKTsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ05WTWUnKSB7IGxpbmVzTlZNZS5wdXNoKGxpbmUpOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnVVNCJykgeyBsaW5lc1VTQi5wdXNoKGxpbmUpOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFNlcmlhbCBBVEEgRHJpdmVzXG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gbGluZXNTQVRBLmpvaW4oJ1xcbicpLnNwbGl0KCcgUGh5c2ljYWwgSW50ZXJjb25uZWN0OiAnKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGRldmljZSA9ICdJbnRlcmZhY2VUeXBlOiAnICsgZGV2aWNlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVkaXVtVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNZWRpdW0gVHlwZScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVTdHIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FwYWNpdHknLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCU0ROYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTRCBOYW1lJywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVTdHIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBzaXplVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHNpemVTdHIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0ci5tYXRjaCgvXFwoKFteKV0rKVxcKS8pWzFdLnJlcGxhY2UoL1xcLi9nLCAnJykucmVwbGFjZSgvLC9nLCAnJykucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc21hcnRTdGF0dXNTdHJpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUy5NLkEuUi5ULiBzdGF0dXMnLCAnOicsIHRydWUpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgZGV2aWNlOiBCU0ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1lZGl1bVR5cGUuc3RhcnRzV2l0aCgnU29saWQnKSA/ICdTU0QnIDogJ0hEJyxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hbnVmYWN0dXJlcicsICc6JywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2VjdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ3lsaW5kZXJzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsSGVhZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxTZWN0b3JzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1BlckN5bGluZGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHNlY3RvcnNQZXJUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJtd2FyZVJldmlzaW9uOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmV2aXNpb24nLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWwgTnVtYmVyJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0ludGVyZmFjZVR5cGUnLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBzbWFydFN0YXR1czogc21hcnRTdGF0dXNTdHJpbmcgPT09ICd2ZXJpZmllZCcgPyAnT0snIDogc21hcnRTdGF0dXNTdHJpbmcgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIEJTRE5hbWU6IEJTRE5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IGNtZCArICdwcmludGYgXCJcXG4nICsgQlNETmFtZSArICd8XCI7IGRpc2t1dGlsIGluZm8gL2Rldi8nICsgQlNETmFtZSArICcgfCBncmVwIFNNQVJUOyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5WTUUgRHJpdmVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGxpbmVzTlZNZS5qb2luKCdcXG4nKS5zcGxpdCgnXFxuXFxuICAgICAgICAgIENhcGFjaXR5OicpO1xuICAgICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlID0gJyFDYXBhY2l0eTogJyArIGRldmljZTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtXaWR0aCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsaW5rIHdpZHRoJywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVN0ciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICchY2FwYWNpdHknLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCU0ROYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTRCBOYW1lJywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVTdHIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBzaXplVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHNpemVTdHIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0ci5tYXRjaCgvXFwoKFteKV0rKVxcKS8pWzFdLnJlcGxhY2UoL1xcLi9nLCAnJykucmVwbGFjZSgvLC9nLCAnJykucmVwbGFjZSgvXFxzL2csICcnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc21hcnRTdGF0dXNTdHJpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUy5NLkEuUi5ULiBzdGF0dXMnLCAnOicsIHRydWUpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgZGV2aWNlOiBCU0ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOVk1lJyxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2VjdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ3lsaW5kZXJzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsSGVhZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxTZWN0b3JzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1BlckN5bGluZGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHNlY3RvcnNQZXJUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJtd2FyZVJldmlzaW9uOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmV2aXNpb24nLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWwgTnVtYmVyJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZTogKCdQQ0llICcgKyBsaW5rV2lkdGgpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBzbWFydFN0YXR1czogc21hcnRTdGF0dXNTdHJpbmcgPT09ICd2ZXJpZmllZCcgPyAnT0snIDogc21hcnRTdGF0dXNTdHJpbmcgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIEJTRE5hbWU6IEJTRE5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IGNtZCArICdwcmludGYgXCJcXG4nICsgQlNETmFtZSArICd8XCI7IGRpc2t1dGlsIGluZm8gL2Rldi8nICsgQlNETmFtZSArICcgfCBncmVwIFNNQVJUOyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVU0IgRHJpdmVzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGxpbmVzVVNCLmpvaW4oJ1xcbicpLnJlcGxhY2VBbGwoJ01lZGlhOlxcbiAnLCAnTW9kZWw6Jykuc3BsaXQoJ1xcblxcbiAgICAgICAgICBQcm9kdWN0IElEOicpO1xuICAgICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplU3RyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcGFjaXR5JywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlNETmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU0QgTmFtZScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplU3RyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc2l6ZVZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmIChzaXplU3RyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIubWF0Y2goL1xcKChbXildKylcXCkvKVsxXS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoLywvZywgJycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0cik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNtYXJ0U3RhdHVzU3RyaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1MuTS5BLlIuVC4gc3RhdHVzJywgJzonLCB0cnVlKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGRldmljZTogQlNETmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVVNCJyxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKS5yZXBsYWNlQWxsKCc6JywgJycpLFxuICAgICAgICAgICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JywgdHJ1ZSkudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWN0b3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxDeWxpbmRlcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxIZWFkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNlY3RvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxUcmFja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdHJhY2tzUGVyQ3lsaW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgc2VjdG9yc1BlclRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGZpcm13YXJlUmV2aXNpb246IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSZXZpc2lvbicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbCBOdW1iZXInLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlOiAnVVNCJyxcbiAgICAgICAgICAgICAgICAgICAgICBzbWFydFN0YXR1czogc21hcnRTdGF0dXNTdHJpbmcgPT09ICd2ZXJpZmllZCcgPyAnT0snIDogc21hcnRTdGF0dXNTdHJpbmcgfHwgJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIEJTRE5hbWU6IEJTRE5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNtZCA9IGNtZCArICdwcmludGYgXCJcXG4nICsgQlNETmFtZSArICd8XCI7IGRpc2t1dGlsIGluZm8gL2Rldi8nICsgQlNETmFtZSArICcgfCBncmVwIFNNQVJUOyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21kKSB7XG4gICAgICAgICAgICAgIGNtZCA9IGNtZCArICdwcmludGYgXCJcXG5cIic7XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBCU0ROYW1lID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzMiA9IHBhcnRzWzFdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzMi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzMlsxXSA9IHBhcnRzMlsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gcGFydHMyWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLkJTRE5hbWUgPT09IEJTRE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnRTdGF0dXMgPSAoc3RhdHVzID09PSAnbm90IHN1cHBvcnRlZCcgPyAnbm90IHN1cHBvcnRlZCcgOiAoc3RhdHVzID09PSAndmVyaWZpZWQnID8gJ09rJyA6IChzdGF0dXMgPT09ICdmYWlsaW5nJyA/ICdQcmVkaWN0ZWQgRmFpbHVyZScgOiAndW5rbm93bicpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtpXS5CU0ROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbaV0uQlNETmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0Rpc2tEcml2ZSB8IHNlbGVjdCBDYXB0aW9uLFNpemUsU3RhdHVzLFBOUERldmljZUlkLERldmljZUlkLEJ5dGVzUGVyU2VjdG9yLFRvdGFsQ3lsaW5kZXJzLFRvdGFsSGVhZHMsVG90YWxTZWN0b3JzLFRvdGFsVHJhY2tzLFRyYWNrc1BlckN5bGluZGVyLFNlY3RvcnNQZXJUcmFjayxGaXJtd2FyZVJldmlzaW9uLFNlcmlhbE51bWJlcixJbnRlcmZhY2VUeXBlIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1QaHlzaWNhbERpc2sgfCBzZWxlY3QgQnVzVHlwZSxNZWRpYVR5cGUsRnJpZW5kbHlOYW1lLE1vZGVsLFNlcmlhbE51bWJlcixTaXplIHwgZmwnKSk7XG4gICAgICAgICAgaWYgKHV0aWwuc21hcnRNb25Ub29sc0luc3RhbGxlZCgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBzbWFydERldiA9IEpTT04ucGFyc2UoZXhlY1N5bmMoJ3NtYXJ0Y3RsIC0tc2NhbiAtaicpKTtcbiAgICAgICAgICAgICAgaWYgKHNtYXJ0RGV2ICYmIHNtYXJ0RGV2LmRldmljZXMgJiYgc21hcnREZXYuZGV2aWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc21hcnREZXYuZGV2aWNlcy5mb3JFYWNoKChkZXYpID0+IHtcbiAgICAgICAgICAgICAgICAgIHdvcmtsb2FkLnB1c2goZXhlY1Byb21pc2VTYXZlKGBzbWFydGN0bCAtaiAtYSAke2Rldi5uYW1lfWAsIHV0aWwuZXhlY09wdHNXaW4pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBkZXZpY2VzID0gZGF0YS5yZXN1bHRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2l6ZScsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhdHVzJywgJzonKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBkZXZpY2U6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXZpY2VJZCcsICc6JyksICAvLyBjaGFuZ2VkIGZyb20gUE5QRGV2aWNlSWQgdG8gRGV2aWNlSUQgKGJlIGJlIGFibGUgdG8gbWF0Y2ggZGV2aWNlcylcbiAgICAgICAgICAgICAgICAgIHR5cGU6IGRldmljZS5pbmRleE9mKCdTU0QnKSA+IC0xID8gJ1NTRCcgOiAnSEQnLCAgLy8ganVzdCBhIHN0YXJ0aW5nIHBvaW50IC4uLiBiZXR0ZXI6IE1TRlRfUGh5c2ljYWxEaXNrIC0gTWVkaWEgVHlwZSAuLi4gc2VlIGJlbG93XG4gICAgICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JyksXG4gICAgICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JywgdHJ1ZSkudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IHBhcnNlSW50KHNpemUpLFxuICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWN0b3I6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdCeXRlc1BlclNlY3RvcicsICc6JykpLFxuICAgICAgICAgICAgICAgICAgdG90YWxDeWxpbmRlcnM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbEN5bGluZGVycycsICc6JykpLFxuICAgICAgICAgICAgICAgICAgdG90YWxIZWFkczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsSGVhZHMnLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2VjdG9yczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsU2VjdG9ycycsICc6JykpLFxuICAgICAgICAgICAgICAgICAgdG90YWxUcmFja3M6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbFRyYWNrcycsICc6JykpLFxuICAgICAgICAgICAgICAgICAgdHJhY2tzUGVyQ3lsaW5kZXI6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUcmFja3NQZXJDeWxpbmRlcicsICc6JykpLFxuICAgICAgICAgICAgICAgICAgc2VjdG9yc1BlclRyYWNrOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VjdG9yc1BlclRyYWNrJywgJzonKSksXG4gICAgICAgICAgICAgICAgICBmaXJtd2FyZVJldmlzaW9uOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRmlybXdhcmVSZXZpc2lvbicsICc6JykudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsTnVtYmVyJywgJzonKS50cmltKCksXG4gICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW50ZXJmYWNlVHlwZScsICc6JykudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgc21hcnRTdGF0dXM6IChzdGF0dXMgPT09ICdvaycgPyAnT2snIDogKHN0YXR1cyA9PT0gJ2RlZ3JhZGVkJyA/ICdEZWdyYWRlZCcgOiAoc3RhdHVzID09PSAncHJlZCBmYWlsJyA/ICdQcmVkaWN0ZWQgRmFpbHVyZScgOiAnVW5rbm93bicpKSksXG4gICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGF0YS5yZXN1bHRzWzFdLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBjb25zdCBzZXJpYWxOdW0gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsTnVtYmVyJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRnJpZW5kbHlOYW1lJywgJzonKS50cmltKCkucmVwbGFjZSgnTXNmdCAnLCAnTWljcm9zb2Z0Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2l6ZScsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNb2RlbCcsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBpbnRlcmZhY2VUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J1c1R5cGUnLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgbGV0IG1lZGlhVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNZWRpYVR5cGUnLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gJzMnIHx8IG1lZGlhVHlwZSA9PT0gJ0hERCcpIHsgbWVkaWFUeXBlID0gJ0hEJzsgfVxuICAgICAgICAgICAgICBpZiAobWVkaWFUeXBlID09PSAnNCcpIHsgbWVkaWFUeXBlID0gJ1NTRCc7IH1cbiAgICAgICAgICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gJzUnKSB7IG1lZGlhVHlwZSA9ICdTQ00nOyB9XG4gICAgICAgICAgICAgIGlmIChtZWRpYVR5cGUgPT09ICdVbnNwZWNpZmllZCcgJiYgKG1vZGVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndmlydHVhbCcpID4gLTEgfHwgbW9kZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2Ym94JykgPiAtMSkpIHsgbWVkaWFUeXBlID0gJ1ZpcnR1YWwnOyB9XG4gICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSB1dGlsLmZpbmRPYmplY3RCeUtleShyZXN1bHQsICdzZXJpYWxOdW0nLCBzZXJpYWxOdW0pO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAtMSB8fCBzZXJpYWxOdW0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBpID0gdXRpbC5maW5kT2JqZWN0QnlLZXkocmVzdWx0LCAnbmFtZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnR5cGUgPSBtZWRpYVR5cGU7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbaV0uaW50ZXJmYWNlVHlwZSA9IGludGVyZmFjZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFMuTS5BLlIuVFxuICAgICAgICAgICAgZGF0YS5yZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBkYXRhLnJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRhdGEucmVzdWx0cy5mb3JFYWNoKChzbWFydFN0cikgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzbWFydERhdGEgPSBKU09OLnBhcnNlKHNtYXJ0U3RyKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzbWFydERhdGEuc2VyaWFsX251bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxOdW0gPSBzbWFydERhdGEuc2VyaWFsX251bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSB1dGlsLmZpbmRPYmplY3RCeUtleShyZXN1bHQsICdzZXJpYWxOdW0nLCBzZXJpYWxOdW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydFN0YXR1cyA9IChzbWFydERhdGEuc21hcnRfc3RhdHVzICYmIHNtYXJ0RGF0YS5zbWFydF9zdGF0dXMucGFzc2VkID8gJ09rJyA6IChzbWFydERhdGEuc21hcnRfc3RhdHVzICYmIHNtYXJ0RGF0YS5zbWFydF9zdGF0dXMucGFzc2VkID09PSBmYWxzZSA/ICdQcmVkaWN0ZWQgRmFpbHVyZScgOiAndW5rbm93bicpKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc21hcnREYXRhLnRlbXBlcmF0dXJlICYmIHNtYXJ0RGF0YS50ZW1wZXJhdHVyZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0udGVtcGVyYXR1cmUgPSBzbWFydERhdGEudGVtcGVyYXR1cmUuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0RGF0YSA9IHNtYXJ0RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRpc2tMYXlvdXQgPSBkaXNrTGF5b3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBncmFwaGljcy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDcuIEdyYXBoaWNzIChjb250cm9sbGVyLCBkaXNwbGF5KVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5sZXQgX252aWRpYVNtaVBhdGggPSAnJztcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxubGV0IF9yZXNvbHV0aW9uWCA9IDA7XG5sZXQgX3Jlc29sdXRpb25ZID0gMDtcbmxldCBfcGl4ZWxEZXB0aCA9IDA7XG5sZXQgX3JlZnJlc2hSYXRlID0gMDtcblxuY29uc3QgdmlkZW9UeXBlcyA9IHtcbiAgJy0yJzogJ1VOSU5JVElBTElaRUQnLFxuICAnLTEnOiAnT1RIRVInLFxuICAnMCc6ICdIRDE1JyxcbiAgJzEnOiAnU1ZJREVPJyxcbiAgJzInOiAnQ29tcG9zaXRlIHZpZGVvJyxcbiAgJzMnOiAnQ29tcG9uZW50IHZpZGVvJyxcbiAgJzQnOiAnRFZJJyxcbiAgJzUnOiAnSERNSScsXG4gICc2JzogJ0xWRFMnLFxuICAnOCc6ICdEX0pQTicsXG4gICc5JzogJ1NESScsXG4gICcxMCc6ICdEUCcsXG4gICcxMSc6ICdEUCBlbWJlZGRlZCcsXG4gICcxMic6ICdVREknLFxuICAnMTMnOiAnVURJIGVtYmVkZGVkJyxcbiAgJzE0JzogJ1NEVFZET05HTEUnLFxuICAnMTUnOiAnTUlSQUNBU1QnLFxuICAnMjE0NzQ4MzY0OCc6ICdJTlRFUk5BTCdcbn07XG5cbmZ1bmN0aW9uIGdldFZlbmRvckZyb21Nb2RlbChtb2RlbCkge1xuICBjb25zdCBtYW51ZmFjdHVyZXJzID0gW1xuICAgIHsgcGF0dGVybjogJ15MRy4rJywgbWFudWZhY3R1cmVyOiAnTEcnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkJFTlEuKycsIG1hbnVmYWN0dXJlcjogJ0JlblEnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkFTVVMuKycsIG1hbnVmYWN0dXJlcjogJ0FzdXMnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkRFTEwuKycsIG1hbnVmYWN0dXJlcjogJ0RlbGwnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXlNBTVNVTkcuKycsIG1hbnVmYWN0dXJlcjogJ1NhbXN1bmcnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXlZJRVdTT04uKycsIG1hbnVmYWN0dXJlcjogJ1ZpZXdTb25pYycgfSxcbiAgICB7IHBhdHRlcm46ICdeU09OWS4rJywgbWFudWZhY3R1cmVyOiAnU29ueScgfSxcbiAgICB7IHBhdHRlcm46ICdeQUNFUi4rJywgbWFudWZhY3R1cmVyOiAnQWNlcicgfSxcbiAgICB7IHBhdHRlcm46ICdeQU9DLisnLCBtYW51ZmFjdHVyZXI6ICdBT0MgTW9uaXRvcnMnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkhQLisnLCBtYW51ZmFjdHVyZXI6ICdIUCcgfSxcbiAgICB7IHBhdHRlcm46ICdeRUlaTy4/JywgbWFudWZhY3R1cmVyOiAnRWl6bycgfSxcbiAgICB7IHBhdHRlcm46ICdeUEhJTElQUy4/JywgbWFudWZhY3R1cmVyOiAnUGhpbGlwcycgfSxcbiAgICB7IHBhdHRlcm46ICdeSUlZQU1BLj8nLCBtYW51ZmFjdHVyZXI6ICdJaXlhbWEnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXlNIQVJQLj8nLCBtYW51ZmFjdHVyZXI6ICdTaGFycCcgfSxcbiAgICB7IHBhdHRlcm46ICdeTkVDLj8nLCBtYW51ZmFjdHVyZXI6ICdORUMnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkxFTk9WTy4/JywgbWFudWZhY3R1cmVyOiAnTGVub3ZvJyB9LFxuICAgIHsgcGF0dGVybjogJ0NPTVBBUS4/JywgbWFudWZhY3R1cmVyOiAnQ29tcGFxJyB9LFxuICAgIHsgcGF0dGVybjogJ0FQUExFLj8nLCBtYW51ZmFjdHVyZXI6ICdBcHBsZScgfSxcbiAgICB7IHBhdHRlcm46ICdJTlRFTC4/JywgbWFudWZhY3R1cmVyOiAnSW50ZWwnIH0sXG4gICAgeyBwYXR0ZXJuOiAnQU1ELj8nLCBtYW51ZmFjdHVyZXI6ICdBTUQnIH0sXG4gICAgeyBwYXR0ZXJuOiAnTlZJRElBLj8nLCBtYW51ZmFjdHVyZXI6ICdOVkRJQScgfSxcbiAgXTtcblxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmIChtb2RlbCkge1xuICAgIG1vZGVsID0gbW9kZWwudG9VcHBlckNhc2UoKTtcbiAgICBtYW51ZmFjdHVyZXJzLmZvckVhY2goKG1hbnVmYWN0dXJlcikgPT4ge1xuICAgICAgY29uc3QgcmUgPSBSZWdFeHAobWFudWZhY3R1cmVyLnBhdHRlcm4pO1xuICAgICAgaWYgKHJlLnRlc3QobW9kZWwpKSB7IHJlc3VsdCA9IG1hbnVmYWN0dXJlci5tYW51ZmFjdHVyZXI7IH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRWZW5kb3JGcm9tSWQoaWQpIHtcbiAgY29uc3QgdmVuZG9ycyA9IHtcbiAgICAnNjEwJzogJ0FwcGxlJyxcbiAgICAnMWU2ZCc6ICdMRycsXG4gICAgJzEwYWMnOiAnREVMTCcsXG4gICAgJzRkZDknOiAnU29ueScsXG4gICAgJzM4YTMnOiAnTkVDJyxcbiAgfTtcbiAgcmV0dXJuIHZlbmRvcnNbaWRdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiB2ZW5kb3JUb0lkKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHN0ciA9IChzdHIgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChzdHIuaW5kZXhPZignYXBwbGUnKSA+PSAwKSB7IHJlc3VsdCA9ICcweDA1YWMnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdudmlkaWEnKSA+PSAwKSB7IHJlc3VsdCA9ICcweDEwZGUnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdpbnRlbCcpID49IDApIHsgcmVzdWx0ID0gJzB4ODA4Nic7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2F0aScpID49IDAgfHwgc3RyLmluZGV4T2YoJ2FtZCcpID49IDApIHsgcmVzdWx0ID0gJzB4MTAwMic7IH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRNZXRhbFZlcnNpb24oaWQpIHtcbiAgY29uc3QgZmFtaWxpZXMgPSB7XG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5bWFjMSc6ICdtYWMxJyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHltYWMyJzogJ21hYzInLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlMSc6ICdhcHBsZTEnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlMic6ICdhcHBsZTInLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlMyc6ICdhcHBsZTMnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlNCc6ICdhcHBsZTQnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlNSc6ICdhcHBsZTUnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlNic6ICdhcHBsZTYnLFxuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseWFwcGxlNyc6ICdhcHBsZTcnLFxuICAgICdzcGRpc3BsYXlzX21ldGFsZmVhdHVyZXNldGZhbWlseTExJzogJ2ZhbWlseTFfdjEnLFxuICAgICdzcGRpc3BsYXlzX21ldGFsZmVhdHVyZXNldGZhbWlseTEyJzogJ2ZhbWlseTFfdjInLFxuICAgICdzcGRpc3BsYXlzX21ldGFsZmVhdHVyZXNldGZhbWlseTEzJzogJ2ZhbWlseTFfdjMnLFxuICAgICdzcGRpc3BsYXlzX21ldGFsZmVhdHVyZXNldGZhbWlseTE0JzogJ2ZhbWlseTFfdjQnLFxuICAgICdzcGRpc3BsYXlzX21ldGFsZmVhdHVyZXNldGZhbWlseTIxJzogJ2ZhbWlseTJfdjEnXG4gIH07XG4gIHJldHVybiBmYW1pbGllc1tpZF0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIGdyYXBoaWNzKGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc0RhcndpbihncmFwaGljc0Fycikge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGNvbnRyb2xsZXJzOiBbXSxcbiAgICAgIGRpc3BsYXlzOiBbXVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGdyYXBoaWNzQXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgLy8gY29udHJvbGxlcnNcbiAgICAgICAgY29uc3QgYnVzID0gKChpdGVtLnNwcGNpX2J1cyB8fCAnJykuaW5kZXhPZignYnVpbHRpbicpID4gLTEgPyAnQnVpbHQtSW4nIDogKChpdGVtLnNwcGNpX2J1cyB8fCAnJykuaW5kZXhPZigncGNpZScpID4gLTEgPyAnUENJZScgOiAnJykpO1xuICAgICAgICBjb25zdCB2cmFtID0gKHBhcnNlSW50KChpdGVtLnNwZGlzcGxheXNfdnJhbSB8fCAnJyksIDEwKSB8fCAwKSAqICgoKGl0ZW0uc3BkaXNwbGF5c192cmFtIHx8ICcnKS5pbmRleE9mKCdHQicpID4gLTEpID8gMTAyNCA6IDEpO1xuICAgICAgICBjb25zdCB2cmFtRHluID0gKHBhcnNlSW50KChpdGVtLnNwZGlzcGxheXNfdnJhbV9zaGFyZWQgfHwgJycpLCAxMCkgfHwgMCkgKiAoKChpdGVtLnNwZGlzcGxheXNfdnJhbV9zaGFyZWQgfHwgJycpLmluZGV4T2YoJ0dCJykgPiAtMSkgPyAxMDI0IDogMSk7XG4gICAgICAgIGxldCBtZXRhbFZlcnNpb24gPSBnZXRNZXRhbFZlcnNpb24oaXRlbS5zcGRpc3BsYXlzX21ldGFsIHx8IGl0ZW0uc3BkaXNwbGF5c19tZXRhbGZhbWlseSB8fCAnJyk7XG4gICAgICAgIHJlcy5jb250cm9sbGVycy5wdXNoKHtcbiAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbChpdGVtLnNwZGlzcGxheXNfdmVuZG9yIHx8ICcnKSB8fCBpdGVtLnNwZGlzcGxheXNfdmVuZG9yIHx8ICcnLFxuICAgICAgICAgIG1vZGVsOiBpdGVtLnNwcGNpX21vZGVsIHx8ICcnLFxuICAgICAgICAgIGJ1cyxcbiAgICAgICAgICB2cmFtRHluYW1pYzogYnVzID09PSAnQnVpbHQtSW4nLFxuICAgICAgICAgIHZyYW06IHZyYW0gfHwgdnJhbUR5biB8fCBudWxsLFxuICAgICAgICAgIGRldmljZUlkOiBpdGVtWydzcGRpc3BsYXlzX2RldmljZS1pZCddIHx8ICcnLFxuICAgICAgICAgIHZlbmRvcklkOiBpdGVtWydzcGRpc3BsYXlzX3ZlbmRvci1pZCddIHx8IHZlbmRvclRvSWQoKGl0ZW1bJ3NwZGlzcGxheXNfdmVuZG9yJ10gfHwgJycpICsgKGl0ZW0uc3BwY2lfbW9kZWwgfHwgJycpKSxcbiAgICAgICAgICBleHRlcm5hbDogKGl0ZW0uc3BwY2lfZGV2aWNlX3R5cGUgPT09ICdzcGRpc3BsYXlzX2VncHUnKSxcbiAgICAgICAgICBjb3JlczogaXRlbVsnc3BwY2lfY29yZXMnXSB8fCBudWxsLFxuICAgICAgICAgIG1ldGFsVmVyc2lvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkaXNwbGF5c1xuICAgICAgICBpZiAoaXRlbS5zcGRpc3BsYXlzX25kcnZzICYmIGl0ZW0uc3BkaXNwbGF5c19uZHJ2cy5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtLnNwZGlzcGxheXNfbmRydnMuZm9yRWFjaChmdW5jdGlvbiAoZGlzcGxheUl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25UeXBlID0gZGlzcGxheUl0ZW1bJ3NwZGlzcGxheXNfY29ubmVjdGlvbl90eXBlJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzb2x1dGlvblBhcnRzID0gKGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19yZXNvbHV0aW9uJ10gfHwgJycpLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzb2x1dGlvbiA9IGN1cnJlbnRSZXNvbHV0aW9uUGFydHNbMF0uc3BsaXQoJ3gnKTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsUGFydHMgPSAoZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX3BpeGVscyddIHx8ICcnKS5zcGxpdCgneCcpO1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxEZXB0aFN0cmluZyA9IGRpc3BsYXlJdGVtWydzcGRpc3BsYXlzX2RlcHRoJ10gfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWwgPSBkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheS1zZXJpYWwtbnVtYmVyJ10gfHwgZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXktc2VyaWFsLW51bWJlcjInXSB8fCBudWxsO1xuICAgICAgICAgICAgcmVzLmRpc3BsYXlzLnB1c2goe1xuICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21JZChkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheS12ZW5kb3ItaWQnXSB8fCAnJykgfHwgZ2V0VmVuZG9yRnJvbU1vZGVsKGRpc3BsYXlJdGVtWydfbmFtZSddIHx8ICcnKSxcbiAgICAgICAgICAgICAgdmVuZG9ySWQ6IGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5LXZlbmRvci1pZCddIHx8ICcnLFxuICAgICAgICAgICAgICBtb2RlbDogZGlzcGxheUl0ZW1bJ19uYW1lJ10gfHwgJycsXG4gICAgICAgICAgICAgIHByb2R1Y3Rpb25ZZWFyOiBkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheS15ZWFyJ10gfHwgbnVsbCxcbiAgICAgICAgICAgICAgc2VyaWFsOiBzZXJpYWwgIT09ICcwJyA/IHNlcmlhbCA6IG51bGwsXG4gICAgICAgICAgICAgIGRpc3BsYXlJZDogZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXlJRCddIHx8IG51bGwsXG4gICAgICAgICAgICAgIG1haW46IGRpc3BsYXlJdGVtWydzcGRpc3BsYXlzX21haW4nXSA/IGRpc3BsYXlJdGVtWydzcGRpc3BsYXlzX21haW4nXSA9PT0gJ3NwZGlzcGxheXNfeWVzJyA6IGZhbHNlLFxuICAgICAgICAgICAgICBidWlsdGluOiAoZGlzcGxheUl0ZW1bJ3NwZGlzcGxheXNfZGlzcGxheV90eXBlJ10gfHwgJycpLmluZGV4T2YoJ2J1aWx0LWluJykgPiAtMSxcbiAgICAgICAgICAgICAgY29ubmVjdGlvbjogKChjb25uZWN0aW9uVHlwZS5pbmRleE9mKCdfaW50ZXJuYWwnKSA+IC0xKSA/ICdJbnRlcm5hbCcgOiAoKGNvbm5lY3Rpb25UeXBlLmluZGV4T2YoJ19kaXNwbGF5cG9ydCcpID4gLTEpID8gJ0Rpc3BsYXkgUG9ydCcgOiAoKGNvbm5lY3Rpb25UeXBlLmluZGV4T2YoJ19oZG1pJykgPiAtMSkgPyAnSERNSScgOiBudWxsKSkpLFxuICAgICAgICAgICAgICBzaXplWDogbnVsbCxcbiAgICAgICAgICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICAgICAgICAgIHBpeGVsRGVwdGg6IChwaXhlbERlcHRoU3RyaW5nID09PSAnQ0dTVGhpcnR5Qml0Q29sb3InID8gMzAgOiAocGl4ZWxEZXB0aFN0cmluZyA9PT0gJ0NHU1RoaXJ0eXR3b0JpdENvbG9yJyA/IDMyIDogKHBpeGVsRGVwdGhTdHJpbmcgPT09ICdDR1NUd2VudHlmb3VyQml0Q29sb3InID8gMjQgOiBudWxsKSkpLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uWDogcGl4ZWxQYXJ0cy5sZW5ndGggPiAxID8gcGFyc2VJbnQocGl4ZWxQYXJ0c1swXSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgcmVzb2x1dGlvblk6IHBpeGVsUGFydHMubGVuZ3RoID4gMSA/IHBhcnNlSW50KHBpeGVsUGFydHNbMV0sIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNYOiBjdXJyZW50UmVzb2x1dGlvbi5sZW5ndGggPiAxID8gcGFyc2VJbnQoY3VycmVudFJlc29sdXRpb25bMF0sIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNZOiBjdXJyZW50UmVzb2x1dGlvbi5sZW5ndGggPiAxID8gcGFyc2VJbnQoY3VycmVudFJlc29sdXRpb25bMV0sIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgICAgICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgICAgICAgICBjdXJyZW50UmVmcmVzaFJhdGU6IGN1cnJlbnRSZXNvbHV0aW9uUGFydHMubGVuZ3RoID4gMSA/IHBhcnNlSW50KGN1cnJlbnRSZXNvbHV0aW9uUGFydHNbMV0sIDEwKSA6IG51bGwsXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzTGludXhDb250cm9sbGVycyhsaW5lcykge1xuICAgIGxldCBjb250cm9sbGVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50Q29udHJvbGxlciA9IHtcbiAgICAgIHZlbmRvcjogJycsXG4gICAgICBtb2RlbDogJycsXG4gICAgICBidXM6ICcnLFxuICAgICAgYnVzQWRkcmVzczogJycsXG4gICAgICB2cmFtOiBudWxsLFxuICAgICAgdnJhbUR5bmFtaWM6IGZhbHNlLFxuICAgICAgcGNpSUQ6ICcnXG4gICAgfTtcbiAgICBsZXQgaXNHcmFwaGljc0NvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAvLyBQQ0kgYnVzIElEc1xuICAgIGxldCBwY2lJRHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgcGNpSURzID0gZXhlY1N5bmMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IDkgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCB8IGdyZXAgXCJCdXMgQWRkcmVzczogXCInKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGNpSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBjaUlEc1tpXSA9IHBjaUlEc1tpXS5yZXBsYWNlKCdCdXMgQWRkcmVzczonLCAnJykucmVwbGFjZSgnMDAwMDonLCAnJykudHJpbSgpO1xuICAgICAgfVxuICAgICAgcGNpSURzID0gcGNpSURzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsICE9IG51bGwgJiYgZWw7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgaWYgKCcnICE9PSBsaW5lLnRyaW0oKSkge1xuICAgICAgICBpZiAoJyAnICE9PSBsaW5lWzBdICYmICdcXHQnICE9PSBsaW5lWzBdKSB7ICAgICAgICAvLyBmaXJzdCBsaW5lIG9mIG5ldyBlbnRyeVxuICAgICAgICAgIGxldCBpc0V4dGVybmFsID0gKHBjaUlEcy5pbmRleE9mKGxpbmUuc3BsaXQoJyAnKVswXSkgPj0gMCk7XG4gICAgICAgICAgbGV0IHZnYXBvcyA9IGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgdmdhICcpO1xuICAgICAgICAgIGxldCBfM2Rjb250cm9sbGVycG9zID0gbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJzNkIGNvbnRyb2xsZXInKTtcbiAgICAgICAgICBpZiAodmdhcG9zICE9PSAtMSB8fCBfM2Rjb250cm9sbGVycG9zICE9PSAtMSkgeyAgICAgICAgIC8vIFZHQVxuICAgICAgICAgICAgaWYgKF8zZGNvbnRyb2xsZXJwb3MgIT09IC0xICYmIHZnYXBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdmdhcG9zID0gXzNkY29udHJvbGxlcnBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgfHwgY3VycmVudENvbnRyb2xsZXIubW9kZWwgfHwgY3VycmVudENvbnRyb2xsZXIuYnVzIHx8IGN1cnJlbnRDb250cm9sbGVyLnZyYW0gIT09IG51bGwgfHwgY3VycmVudENvbnRyb2xsZXIudnJhbUR5bmFtaWMpIHsgLy8gYWxyZWFkeSBhIGNvbnRyb2xsZXIgZm91bmRcbiAgICAgICAgICAgICAgY29udHJvbGxlcnMucHVzaChjdXJyZW50Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyID0ge1xuICAgICAgICAgICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgICAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICAgICAgICAgIGJ1czogJycsXG4gICAgICAgICAgICAgICAgYnVzQWRkcmVzczogJycsXG4gICAgICAgICAgICAgICAgdnJhbTogbnVsbCxcbiAgICAgICAgICAgICAgICB2cmFtRHluYW1pYzogZmFsc2UsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBjaUlEQ2FuZGlkYXRlID0gbGluZS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgaWYgKC9bXFxkYS1mQS1GXXsyfTpbXFxkYS1mQS1GXXsyfVxcLltcXGRhLWZBLUZdLy50ZXN0KHBjaUlEQ2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5idXNBZGRyZXNzID0gcGNpSURDYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0dyYXBoaWNzQ29udHJvbGxlciA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZW5kcG9zID0gbGluZS5zZWFyY2goL1xcW1swLTlhLWZdezR9OlswLTlhLWZdezR9XXwkLyk7XG4gICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cih2Z2Fwb3MsIGVuZHBvcyAtIHZnYXBvcykuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLmJ1c0FkZHJlc3MgPSBsaW5lLnN1YnN0cigwLCB2Z2Fwb3MpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICBpZiAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjb3Jwb3JhdGlvbicpID49IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgPSBwYXJ0c1sxXS5zdWJzdHIoMCwgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjb3Jwb3JhdGlvbicpICsgMTEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5tb2RlbCA9IHBhcnRzWzFdLnN1YnN0cihwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2NvcnBvcmF0aW9uJykgKyAxMSwgMjAwKS50cmltKCkuc3BsaXQoJygnKVswXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5idXMgPSAocGNpSURzLmxlbmd0aCA+IDAgJiYgaXNFeHRlcm5hbCkgPyAnUENJZScgOiAnT25ib2FyZCc7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudnJhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudnJhbUR5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBpbmMuJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICgocGFydHNbMV0ubWF0Y2goL10vZykgfHwgW10pLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciA9IHBhcnRzWzFdLnN1YnN0cigwLCBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ10nKSArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLm1vZGVsID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignXScpICsgMSwgMjAwKS50cmltKCkuc3BsaXQoJygnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciA9IHBhcnRzWzFdLnN1YnN0cigwLCBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBpbmMuJykgKyA1KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5tb2RlbCA9IHBhcnRzWzFdLnN1YnN0cihwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBpbmMuJykgKyA1LCAyMDApLnRyaW0oKS5zcGxpdCgnKCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIuYnVzID0gKHBjaUlEcy5sZW5ndGggPiAwICYmIGlzRXh0ZXJuYWwpID8gJ1BDSWUnIDogJ09uYm9hcmQnO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZyYW1EeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgbHRkLicpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcnRzWzFdLm1hdGNoKC9dL2cpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgPSBwYXJ0c1sxXS5zdWJzdHIoMCwgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCddJykgKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5tb2RlbCA9IHBhcnRzWzFdLnN1YnN0cihwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ10nKSArIDEsIDIwMCkudHJpbSgpLnNwbGl0KCcoJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgPSBwYXJ0c1sxXS5zdWJzdHIoMCwgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgbHRkLicpICsgNSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIubW9kZWwgPSBwYXJ0c1sxXS5zdWJzdHIocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgbHRkLicpICsgNSwgMjAwKS50cmltKCkuc3BsaXQoJygnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNHcmFwaGljc0NvbnRyb2xsZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzR3JhcGhpY3NDb250cm9sbGVyKSB7IC8vIHdpdGhpbiBWR0EgZGV0YWlsc1xuICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBwYXJ0c1swXS5yZXBsYWNlKC8gKy9nLCAnJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdkZXZpY2VuYW1lJykgIT09IC0xICYmIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignb25ib2FyZCcpICE9PSAtMSkgeyBjdXJyZW50Q29udHJvbGxlci5idXMgPSAnT25ib2FyZCc7IH1cbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBwYXJ0c1swXS5yZXBsYWNlKC8gKy9nLCAnJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyZWdpb24nKSAhPT0gLTEgJiYgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdtZW1vcnknKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBtZW1wYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBpZiAobWVtcGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52cmFtID0gcGFyc2VJbnQobWVtcGFydHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGN1cnJlbnRDb250cm9sbGVyLnZlbmRvciB8fCBjdXJyZW50Q29udHJvbGxlci5tb2RlbCB8fCBjdXJyZW50Q29udHJvbGxlci5idXMgfHwgY3VycmVudENvbnRyb2xsZXIuYnVzQWRkcmVzcyB8fCBjdXJyZW50Q29udHJvbGxlci52cmFtICE9PSBudWxsIHx8IGN1cnJlbnRDb250cm9sbGVyLnZyYW1EeW5hbWljKSB7IC8vIGFscmVhZHkgYSBjb250cm9sbGVyIGZvdW5kXG4gICAgICBjb250cm9sbGVycy5wdXNoKGN1cnJlbnRDb250cm9sbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIChjb250cm9sbGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzTGludXhDbGluZm8oY29udHJvbGxlcnMsIGxpbmVzKSB7XG4gICAgY29uc3QgZmllbGRQYXR0ZXJuID0gL1xcWyhbXlxcXV0rKVxcXVxccysoXFx3KylcXHMrKC4qKS87XG4gICAgY29uc3QgZGV2aWNlcyA9IGxpbmVzLnJlZHVjZSgoZGV2aWNlcywgbGluZSkgPT4ge1xuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZFBhdHRlcm4uZXhlYyhsaW5lLnRyaW0oKSk7XG4gICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgaWYgKCFkZXZpY2VzW2ZpZWxkWzFdXSkge1xuICAgICAgICAgIGRldmljZXNbZmllbGRbMV1dID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGV2aWNlc1tmaWVsZFsxXV1bZmllbGRbMl1dID0gZmllbGRbM107XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9LCB7fSk7XG4gICAgZm9yIChsZXQgZGV2aWNlSWQgaW4gZGV2aWNlcykge1xuICAgICAgY29uc3QgZGV2aWNlID0gZGV2aWNlc1tkZXZpY2VJZF07XG4gICAgICBpZiAoZGV2aWNlWydDTF9ERVZJQ0VfVFlQRSddID09PSAnQ0xfREVWSUNFX1RZUEVfR1BVJykge1xuICAgICAgICBsZXQgYnVzQWRkcmVzcztcbiAgICAgICAgaWYgKGRldmljZVsnQ0xfREVWSUNFX1RPUE9MT0dZX0FNRCddKSB7XG4gICAgICAgICAgY29uc3QgYmRmID0gZGV2aWNlWydDTF9ERVZJQ0VfVE9QT0xPR1lfQU1EJ10ubWF0Y2goL1thLXpBLVowLTldKzpcXGQrXFwuXFxkKy8pO1xuICAgICAgICAgIGlmIChiZGYpIHtcbiAgICAgICAgICAgIGJ1c0FkZHJlc3MgPSBiZGZbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRldmljZVsnQ0xfREVWSUNFX1BDSV9CVVNfSURfTlYnXSAmJiBkZXZpY2VbJ0NMX0RFVklDRV9QQ0lfU0xPVF9JRF9OViddKSB7XG4gICAgICAgICAgY29uc3QgYnVzID0gcGFyc2VJbnQoZGV2aWNlWydDTF9ERVZJQ0VfUENJX0JVU19JRF9OViddKTtcbiAgICAgICAgICBjb25zdCBzbG90ID0gcGFyc2VJbnQoZGV2aWNlWydDTF9ERVZJQ0VfUENJX1NMT1RfSURfTlYnXSk7XG4gICAgICAgICAgaWYgKCFpc05hTihidXMpICYmICFpc05hTihzbG90KSkge1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1cyAmIDB4ZmY7XG4gICAgICAgICAgICBjb25zdCBkID0gKHNsb3QgPj4gMykgJiAweGZmO1xuICAgICAgICAgICAgY29uc3QgZiA9IHNsb3QgJiAweDA3O1xuICAgICAgICAgICAgYnVzQWRkcmVzcyA9IGAke2IudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2QudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfS4ke2Z9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1c0FkZHJlc3MpIHtcbiAgICAgICAgICBsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzLmZpbmQoY29udHJvbGxlciA9PiBjb250cm9sbGVyLmJ1c0FkZHJlc3MgPT09IGJ1c0FkZHJlc3MpO1xuICAgICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlciA9IHtcbiAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICAgICAgICBidXM6ICcnLFxuICAgICAgICAgICAgICBidXNBZGRyZXNzLFxuICAgICAgICAgICAgICB2cmFtOiBudWxsLFxuICAgICAgICAgICAgICB2cmFtRHluYW1pYzogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLnZlbmRvciA9IGRldmljZVsnQ0xfREVWSUNFX1ZFTkRPUiddO1xuICAgICAgICAgIGlmIChkZXZpY2VbJ0NMX0RFVklDRV9CT0FSRF9OQU1FX0FNRCddKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLm1vZGVsID0gZGV2aWNlWydDTF9ERVZJQ0VfQk9BUkRfTkFNRV9BTUQnXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5tb2RlbCA9IGRldmljZVsnQ0xfREVWSUNFX05BTUUnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVtb3J5ID0gcGFyc2VJbnQoZGV2aWNlWydDTF9ERVZJQ0VfR0xPQkFMX01FTV9TSVpFJ10pO1xuICAgICAgICAgIGlmICghaXNOYU4obWVtb3J5KSkge1xuICAgICAgICAgICAgY29udHJvbGxlci52cmFtID0gTWF0aC5yb3VuZChtZW1vcnkgLyAxMDI0IC8gMTAyNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE52aWRpYVNtaSgpIHtcbiAgICBpZiAoX252aWRpYVNtaVBhdGgpIHtcbiAgICAgIHJldHVybiBfbnZpZGlhU21pUGF0aDtcbiAgICB9XG5cbiAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJhc2VQYXRoID0gdXRpbC5XSU5ESVIgKyAnXFxcXFN5c3RlbTMyXFxcXERyaXZlclN0b3JlXFxcXEZpbGVSZXBvc2l0b3J5JztcbiAgICAgICAgLy8gZmluZCBhbGwgZGlyZWN0b3JpZXMgdGhhdCBoYXZlIGFuIG52aWRpYS1zbWkuZXhlIGZpbGVcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlRGlycyA9IGZzLnJlYWRkaXJTeW5jKGJhc2VQYXRoKS5maWx0ZXIoZGlyID0+IHtcbiAgICAgICAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoW2Jhc2VQYXRoLCBkaXJdLmpvaW4oJy8nKSkuaW5jbHVkZXMoJ252aWRpYS1zbWkuZXhlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1c2UgdGhlIGRpcmVjdG9yeSB3aXRoIHRoZSBtb3N0IHJlY2VudGx5IGNyZWF0ZWQgbnZpZGlhLXNtaS5leGUgZmlsZVxuICAgICAgICBjb25zdCB0YXJnZXREaXIgPSBjYW5kaWRhdGVEaXJzLnJlZHVjZSgocHJldkRpciwgY3VycmVudERpcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzTnZpZGlhU21pID0gZnMuc3RhdFN5bmMoW2Jhc2VQYXRoLCBwcmV2RGlyLCAnbnZpZGlhLXNtaS5leGUnXS5qb2luKCcvJykpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnROdmlkaWFTbWkgPSBmcy5zdGF0U3luYyhbYmFzZVBhdGgsIGN1cnJlbnREaXIsICdudmlkaWEtc21pLmV4ZSddLmpvaW4oJy8nKSk7XG4gICAgICAgICAgcmV0dXJuIChwcmV2aW91c052aWRpYVNtaS5jdGltZU1zID4gY3VycmVudE52aWRpYVNtaS5jdGltZU1zKSA/IHByZXZEaXIgOiBjdXJyZW50RGlyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFyZ2V0RGlyKSB7XG4gICAgICAgICAgX252aWRpYVNtaVBhdGggPSBbYmFzZVBhdGgsIHRhcmdldERpciwgJ252aWRpYS1zbWkuZXhlJ10uam9pbignLycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2xpbnV4KSB7XG4gICAgICBfbnZpZGlhU21pUGF0aCA9ICdudmlkaWEtc21pJztcbiAgICB9XG4gICAgcmV0dXJuIF9udmlkaWFTbWlQYXRoO1xuICB9XG5cbiAgZnVuY3Rpb24gbnZpZGlhU21pKG9wdGlvbnMpIHtcbiAgICBjb25zdCBudmlkaWFTbWlFeGUgPSBnZXROdmlkaWFTbWkoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLmV4ZWNPcHRzV2luO1xuICAgIGlmIChudmlkaWFTbWlFeGUpIHtcbiAgICAgIGNvbnN0IG52aWRpYVNtaU9wdHMgPSAnLS1xdWVyeS1ncHU9ZHJpdmVyX3ZlcnNpb24scGNpLnN1Yl9kZXZpY2VfaWQsbmFtZSxwY2kuYnVzX2lkLGZhbi5zcGVlZCxtZW1vcnkudG90YWwsbWVtb3J5LnVzZWQsbWVtb3J5LmZyZWUsdXRpbGl6YXRpb24uZ3B1LHV0aWxpemF0aW9uLm1lbW9yeSx0ZW1wZXJhdHVyZS5ncHUsdGVtcGVyYXR1cmUubWVtb3J5LHBvd2VyLmRyYXcscG93ZXIubGltaXQsY2xvY2tzLmdyLGNsb2Nrcy5tZW0gLS1mb3JtYXQ9Y3N2LG5vaGVhZGVyLG5vdW5pdHMnO1xuICAgICAgY29uc3QgY21kID0gbnZpZGlhU21pRXhlICsgJyAnICsgbnZpZGlhU21pT3B0cyArIChfbGludXggPyAnICAyPi9kZXYvbnVsbCcgOiAnJyk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBleGVjU3luYyhjbWQsIG9wdGlvbnMpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiBudmlkaWFEZXZpY2VzKCkge1xuXG4gICAgZnVuY3Rpb24gc2FmZVBhcnNlTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAoW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGRvdXQgPSBudmlkaWFTbWkoKTtcbiAgICBpZiAoIXN0ZG91dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGdwdXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKTtcbiAgICBsZXQgcmVzdWx0cyA9IGdwdXMubWFwKGdwdSA9PiB7XG4gICAgICBjb25zdCBzcGxpdHRlZERhdGEgPSBncHUuc3BsaXQoJywgJykubWFwKHZhbHVlID0+IHZhbHVlLmluY2x1ZGVzKCdOL0EnKSA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbiAgICAgIGlmIChzcGxpdHRlZERhdGEubGVuZ3RoID09PSAxNikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRyaXZlclZlcnNpb246IHNwbGl0dGVkRGF0YVswXSxcbiAgICAgICAgICBzdWJEZXZpY2VJZDogc3BsaXR0ZWREYXRhWzFdLFxuICAgICAgICAgIG5hbWU6IHNwbGl0dGVkRGF0YVsyXSxcbiAgICAgICAgICBwY2lCdXM6IHNwbGl0dGVkRGF0YVszXSxcbiAgICAgICAgICBmYW5TcGVlZDogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs0XSksXG4gICAgICAgICAgbWVtb3J5VG90YWw6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbNV0pLFxuICAgICAgICAgIG1lbW9yeVVzZWQ6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbNl0pLFxuICAgICAgICAgIG1lbW9yeUZyZWU6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbN10pLFxuICAgICAgICAgIHV0aWxpemF0aW9uR3B1OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzhdKSxcbiAgICAgICAgICB1dGlsaXphdGlvbk1lbW9yeTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs5XSksXG4gICAgICAgICAgdGVtcGVyYXR1cmVHcHU6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTBdKSxcbiAgICAgICAgICB0ZW1wZXJhdHVyZU1lbW9yeTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxMV0pLFxuICAgICAgICAgIHBvd2VyRHJhdzogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxMl0pLFxuICAgICAgICAgIHBvd2VyTGltaXQ6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTNdKSxcbiAgICAgICAgICBjbG9ja0NvcmU6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTRdKSxcbiAgICAgICAgICBjbG9ja01lbW9yeTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVsxNV0pLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgcmV0dXJuICgncGNpQnVzJyBpbiBpdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ29udHJvbGxlck52aWRpYShjb250cm9sbGVyLCBudmlkaWEpIHtcbiAgICBpZiAobnZpZGlhLmRyaXZlclZlcnNpb24pIHsgY29udHJvbGxlci5kcml2ZXJWZXJzaW9uID0gbnZpZGlhLmRyaXZlclZlcnNpb247IH1cbiAgICBpZiAobnZpZGlhLnN1YkRldmljZUlkKSB7IGNvbnRyb2xsZXIuc3ViRGV2aWNlSWQgPSBudmlkaWEuc3ViRGV2aWNlSWQ7IH1cbiAgICBpZiAobnZpZGlhLm5hbWUpIHsgY29udHJvbGxlci5uYW1lID0gbnZpZGlhLm5hbWU7IH1cbiAgICBpZiAobnZpZGlhLnBjaUJ1cykgeyBjb250cm9sbGVyLnBjaUJ1cyA9IG52aWRpYS5wY2lCdXM7IH1cbiAgICBpZiAobnZpZGlhLmZhblNwZWVkKSB7IGNvbnRyb2xsZXIuZmFuU3BlZWQgPSBudmlkaWEuZmFuU3BlZWQ7IH1cbiAgICBpZiAobnZpZGlhLm1lbW9yeVRvdGFsKSB7XG4gICAgICBjb250cm9sbGVyLm1lbW9yeVRvdGFsID0gbnZpZGlhLm1lbW9yeVRvdGFsO1xuICAgICAgY29udHJvbGxlci52cmFtID0gbnZpZGlhLm1lbW9yeVRvdGFsO1xuICAgICAgY29udHJvbGxlci52cmFtRHluYW1pYyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobnZpZGlhLm1lbW9yeVVzZWQpIHsgY29udHJvbGxlci5tZW1vcnlVc2VkID0gbnZpZGlhLm1lbW9yeVVzZWQ7IH1cbiAgICBpZiAobnZpZGlhLm1lbW9yeUZyZWUpIHsgY29udHJvbGxlci5tZW1vcnlGcmVlID0gbnZpZGlhLm1lbW9yeUZyZWU7IH1cbiAgICBpZiAobnZpZGlhLnV0aWxpemF0aW9uR3B1KSB7IGNvbnRyb2xsZXIudXRpbGl6YXRpb25HcHUgPSBudmlkaWEudXRpbGl6YXRpb25HcHU7IH1cbiAgICBpZiAobnZpZGlhLnV0aWxpemF0aW9uTWVtb3J5KSB7IGNvbnRyb2xsZXIudXRpbGl6YXRpb25NZW1vcnkgPSBudmlkaWEudXRpbGl6YXRpb25NZW1vcnk7IH1cbiAgICBpZiAobnZpZGlhLnRlbXBlcmF0dXJlR3B1KSB7IGNvbnRyb2xsZXIudGVtcGVyYXR1cmVHcHUgPSBudmlkaWEudGVtcGVyYXR1cmVHcHU7IH1cbiAgICBpZiAobnZpZGlhLnRlbXBlcmF0dXJlTWVtb3J5KSB7IGNvbnRyb2xsZXIudGVtcGVyYXR1cmVNZW1vcnkgPSBudmlkaWEudGVtcGVyYXR1cmVNZW1vcnk7IH1cbiAgICBpZiAobnZpZGlhLnBvd2VyRHJhdykgeyBjb250cm9sbGVyLnBvd2VyRHJhdyA9IG52aWRpYS5wb3dlckRyYXc7IH1cbiAgICBpZiAobnZpZGlhLnBvd2VyTGltaXQpIHsgY29udHJvbGxlci5wb3dlckxpbWl0ID0gbnZpZGlhLnBvd2VyTGltaXQ7IH1cbiAgICBpZiAobnZpZGlhLmNsb2NrQ29yZSkgeyBjb250cm9sbGVyLmNsb2NrQ29yZSA9IG52aWRpYS5jbG9ja0NvcmU7IH1cbiAgICBpZiAobnZpZGlhLmNsb2NrTWVtb3J5KSB7IGNvbnRyb2xsZXIuY2xvY2tNZW1vcnkgPSBudmlkaWEuY2xvY2tNZW1vcnk7IH1cbiAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNMaW51eEVkaWQoZWRpZCkge1xuICAgIC8vIHBhcnNlbiBFRElEXG4gICAgLy8gLS0+IG1vZGVsXG4gICAgLy8gLS0+IHJlc29sdXRpb254XG4gICAgLy8gLS0+IHJlc29sdXRpb255XG4gICAgLy8gLS0+IGJ1aWx0aW4gPSBmYWxzZVxuICAgIC8vIC0tPiBwaXhlbGRlcHRoICg/KVxuICAgIC8vIC0tPiBzaXpleFxuICAgIC8vIC0tPiBzaXpleVxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICB2ZW5kb3I6ICcnLFxuICAgICAgbW9kZWw6ICcnLFxuICAgICAgZGV2aWNlTmFtZTogJycsXG4gICAgICBtYWluOiBmYWxzZSxcbiAgICAgIGJ1aWx0aW46IGZhbHNlLFxuICAgICAgY29ubmVjdGlvbjogJycsXG4gICAgICBzaXplWDogbnVsbCxcbiAgICAgIHNpemVZOiBudWxsLFxuICAgICAgcGl4ZWxEZXB0aDogbnVsbCxcbiAgICAgIHJlc29sdXRpb25YOiBudWxsLFxuICAgICAgcmVzb2x1dGlvblk6IG51bGwsXG4gICAgICBjdXJyZW50UmVzWDogbnVsbCxcbiAgICAgIGN1cnJlbnRSZXNZOiBudWxsLFxuICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgY3VycmVudFJlZnJlc2hSYXRlOiBudWxsXG4gICAgfTtcbiAgICAvLyBmaW5kIGZpcnN0IFwiRGV0YWlsZWQgVGltaW5nIERlc2NyaXB0aW9uXCJcbiAgICBsZXQgc3RhcnQgPSAxMDg7XG4gICAgaWYgKGVkaWQuc3Vic3RyKHN0YXJ0LCA2KSA9PT0gJzAwMDAwMCcpIHtcbiAgICAgIHN0YXJ0ICs9IDM2O1xuICAgIH1cbiAgICBpZiAoZWRpZC5zdWJzdHIoc3RhcnQsIDYpID09PSAnMDAwMDAwJykge1xuICAgICAgc3RhcnQgKz0gMzY7XG4gICAgfVxuICAgIGlmIChlZGlkLnN1YnN0cihzdGFydCwgNikgPT09ICcwMDAwMDAnKSB7XG4gICAgICBzdGFydCArPSAzNjtcbiAgICB9XG4gICAgaWYgKGVkaWQuc3Vic3RyKHN0YXJ0LCA2KSA9PT0gJzAwMDAwMCcpIHtcbiAgICAgIHN0YXJ0ICs9IDM2O1xuICAgIH1cbiAgICByZXN1bHQucmVzb2x1dGlvblggPSBwYXJzZUludCgnMHgwJyArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgOCwgMSkgKyBlZGlkLnN1YnN0cihzdGFydCArIDQsIDIpKTtcbiAgICByZXN1bHQucmVzb2x1dGlvblkgPSBwYXJzZUludCgnMHgwJyArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMTQsIDEpICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAxMCwgMikpO1xuICAgIHJlc3VsdC5zaXplWCA9IHBhcnNlSW50KCcweDAnICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAyOCwgMSkgKyBlZGlkLnN1YnN0cihzdGFydCArIDI0LCAyKSk7XG4gICAgcmVzdWx0LnNpemVZID0gcGFyc2VJbnQoJzB4MCcgKyBlZGlkLnN1YnN0cihzdGFydCArIDI5LCAxKSArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMjYsIDIpKTtcbiAgICAvLyBtb25pdG9yIG5hbWVcbiAgICBzdGFydCA9IGVkaWQuaW5kZXhPZignMDAwMDAwZmMwMCcpOyAvLyBmaW5kIGZpcnN0IFwiTW9uaXRvciBEZXNjcmlwdGlvbiBEYXRhXCJcbiAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgbGV0IG1vZGVsX3JhdyA9IGVkaWQuc3Vic3RyKHN0YXJ0ICsgMTAsIDI2KTtcbiAgICAgIGlmIChtb2RlbF9yYXcuaW5kZXhPZignMGEnKSAhPT0gLTEpIHtcbiAgICAgICAgbW9kZWxfcmF3ID0gbW9kZWxfcmF3LnN1YnN0cigwLCBtb2RlbF9yYXcuaW5kZXhPZignMGEnKSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobW9kZWxfcmF3Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICByZXN1bHQubW9kZWwgPSBtb2RlbF9yYXcubWF0Y2goLy57MSwyfS9nKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHYsIDE2KSk7XG4gICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5tb2RlbCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc0xpbnV4RGlzcGxheXMobGluZXMsIGRlcHRoKSB7XG4gICAgbGV0IGRpc3BsYXlzID0gW107XG4gICAgbGV0IGN1cnJlbnREaXNwbGF5ID0ge1xuICAgICAgdmVuZG9yOiAnJyxcbiAgICAgIG1vZGVsOiAnJyxcbiAgICAgIGRldmljZU5hbWU6ICcnLFxuICAgICAgbWFpbjogZmFsc2UsXG4gICAgICBidWlsdGluOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICBzaXplWTogbnVsbCxcbiAgICAgIHBpeGVsRGVwdGg6IG51bGwsXG4gICAgICByZXNvbHV0aW9uWDogbnVsbCxcbiAgICAgIHJlc29sdXRpb25ZOiBudWxsLFxuICAgICAgY3VycmVudFJlc1g6IG51bGwsXG4gICAgICBjdXJyZW50UmVzWTogbnVsbCxcbiAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgIGN1cnJlbnRSZWZyZXNoUmF0ZTogbnVsbFxuICAgIH07XG4gICAgbGV0IGlzX2VkaWQgPSBmYWxzZTtcbiAgICBsZXQgaXNfY3VycmVudCA9IGZhbHNlO1xuICAgIGxldCBlZGlkX3JhdyA9ICcnO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykgeyAgICAgICAgLy8gc3RhcnQgd2l0aCBzZWNvbmQgbGluZVxuICAgICAgaWYgKCcnICE9PSBsaW5lc1tpXS50cmltKCkpIHtcbiAgICAgICAgaWYgKCcgJyAhPT0gbGluZXNbaV1bMF0gJiYgJ1xcdCcgIT09IGxpbmVzW2ldWzBdICYmIGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGNvbm5lY3RlZCAnKSAhPT0gLTEpIHsgICAgICAgIC8vIGZpcnN0IGxpbmUgb2YgbmV3IGVudHJ5XG4gICAgICAgICAgaWYgKGN1cnJlbnREaXNwbGF5Lm1vZGVsIHx8IGN1cnJlbnREaXNwbGF5Lm1haW4gfHwgY3VycmVudERpc3BsYXkuYnVpbHRpbiB8fCBjdXJyZW50RGlzcGxheS5jb25uZWN0aW9uIHx8IGN1cnJlbnREaXNwbGF5LnNpemVYICE9PSBudWxsIHx8IGN1cnJlbnREaXNwbGF5LnBpeGVsRGVwdGggIT09IG51bGwgfHwgY3VycmVudERpc3BsYXkucmVzb2x1dGlvblggIT09IG51bGwpIHsgICAgICAgICAvLyBwdXNoIGxhc3QgZGlzcGxheSB0byBhcnJheVxuICAgICAgICAgICAgZGlzcGxheXMucHVzaChjdXJyZW50RGlzcGxheSk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheSA9IHtcbiAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICAgICAgICBtYWluOiBmYWxzZSxcbiAgICAgICAgICAgICAgYnVpbHRpbjogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgICAgICAgICBzaXplWDogbnVsbCxcbiAgICAgICAgICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICAgICAgICAgIHBpeGVsRGVwdGg6IG51bGwsXG4gICAgICAgICAgICAgIHJlc29sdXRpb25YOiBudWxsLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uWTogbnVsbCxcbiAgICAgICAgICAgICAgY3VycmVudFJlc1g6IG51bGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNZOiBudWxsLFxuICAgICAgICAgICAgICBwb3NpdGlvblg6IDAsXG4gICAgICAgICAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgICAgICAgICAgY3VycmVudFJlZnJlc2hSYXRlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lc1tpXS5zcGxpdCgnICcpO1xuICAgICAgICAgIGN1cnJlbnREaXNwbGF5LmNvbm5lY3Rpb24gPSBwYXJ0c1swXTtcbiAgICAgICAgICBjdXJyZW50RGlzcGxheS5tYWluID0gbGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgcHJpbWFyeSAnKSA+PSAwO1xuICAgICAgICAgIGN1cnJlbnREaXNwbGF5LmJ1aWx0aW4gPSAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdlZHAnKSA+PSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byByZWFkIEVESUQgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKGlzX2VkaWQpIHtcbiAgICAgICAgICBpZiAobGluZXNbaV0uc2VhcmNoKC9cXFN8JC8pID4gc3RhcnQpIHtcbiAgICAgICAgICAgIGVkaWRfcmF3ICs9IGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJzZW4gRURJRFxuICAgICAgICAgICAgbGV0IGVkaWRfZGVjb2RlZCA9IHBhcnNlTGluZXNMaW51eEVkaWQoZWRpZF9yYXcpO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkudmVuZG9yID0gZWRpZF9kZWNvZGVkLnZlbmRvcjtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5Lm1vZGVsID0gZWRpZF9kZWNvZGVkLm1vZGVsO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkucmVzb2x1dGlvblggPSBlZGlkX2RlY29kZWQucmVzb2x1dGlvblg7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5yZXNvbHV0aW9uWSA9IGVkaWRfZGVjb2RlZC5yZXNvbHV0aW9uWTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnNpemVYID0gZWRpZF9kZWNvZGVkLnNpemVYO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkuc2l6ZVkgPSBlZGlkX2RlY29kZWQuc2l6ZVk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5waXhlbERlcHRoID0gZGVwdGg7XG4gICAgICAgICAgICBpc19lZGlkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2VkaWQ6JykgPj0gMCkge1xuICAgICAgICAgIGlzX2VkaWQgPSB0cnVlO1xuICAgICAgICAgIHN0YXJ0ID0gbGluZXNbaV0uc2VhcmNoKC9cXFN8JC8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJypjdXJyZW50JykgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHBhcnRzMSA9IGxpbmVzW2ldLnNwbGl0KCcoJyk7XG4gICAgICAgICAgaWYgKHBhcnRzMSAmJiBwYXJ0czEubGVuZ3RoID4gMSAmJiBwYXJ0czFbMF0uaW5kZXhPZigneCcpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc1BhcnRzID0gcGFydHMxWzBdLnRyaW0oKS5zcGxpdCgneCcpO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkuY3VycmVudFJlc1ggPSB1dGlsLnRvSW50KHJlc1BhcnRzWzBdKTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LmN1cnJlbnRSZXNZID0gdXRpbC50b0ludChyZXNQYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzX2N1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19jdXJyZW50ICYmIGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2xvY2snKSA+PSAwICYmIGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHonKSA+PSAwICYmIGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndjogaGVpZ2h0JykgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHBhcnRzMSA9IGxpbmVzW2ldLnNwbGl0KCdjbG9jaycpO1xuICAgICAgICAgIGlmIChwYXJ0czEgJiYgcGFydHMxLmxlbmd0aCA+IDEgJiYgcGFydHMxWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHonKSA+PSAwKSB7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5jdXJyZW50UmVmcmVzaFJhdGUgPSB1dGlsLnRvSW50KHBhcnRzMVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzX2N1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1c2hlbiBkaXNwbGF5c1xuICAgIGlmIChjdXJyZW50RGlzcGxheS5tb2RlbCB8fCBjdXJyZW50RGlzcGxheS5tYWluIHx8IGN1cnJlbnREaXNwbGF5LmJ1aWx0aW4gfHwgY3VycmVudERpc3BsYXkuY29ubmVjdGlvbiB8fCBjdXJyZW50RGlzcGxheS5zaXplWCAhPT0gbnVsbCB8fCBjdXJyZW50RGlzcGxheS5waXhlbERlcHRoICE9PSBudWxsIHx8IGN1cnJlbnREaXNwbGF5LnJlc29sdXRpb25YICE9PSBudWxsKSB7ICAvLyBzdGlsbCBpbmZvcm1hdGlvbiB0aGVyZVxuICAgICAgZGlzcGxheXMucHVzaChjdXJyZW50RGlzcGxheSk7XG4gICAgfVxuICAgIHJldHVybiBkaXNwbGF5cztcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uIHN0YXJ0cyBoZXJlXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgY29udHJvbGxlcnM6IFtdLFxuICAgICAgICBkaXNwbGF5czogW11cbiAgICAgIH07XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciAteG1sIC1kZXRhaWxMZXZlbCBmdWxsIFNQRGlzcGxheXNEYXRhVHlwZSc7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHN0ZG91dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUxpbmVzRGFyd2luKHV0aWwucGxpc3RQYXJzZXIob3V0cHV0KVswXS5faXRlbXMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ZG91dCA9IGV4ZWNTeW5jKCdkZWZhdWx0cyByZWFkIC9MaWJyYXJ5L1ByZWZlcmVuY2VzL2NvbS5hcHBsZS53aW5kb3dzZXJ2ZXIucGxpc3QgMj4vZGV2L251bGw7ZGVmYXVsdHMgcmVhZCAvTGlicmFyeS9QcmVmZXJlbmNlcy9jb20uYXBwbGUud2luZG93c2VydmVyLmRpc3BsYXlzLnBsaXN0IDI+L2Rldi9udWxsOyBlY2hvIFwiXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IChzdGRvdXQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBvYmogPSB1dGlsLnBsaXN0UmVhZGVyKG91dHB1dCk7XG4gICAgICAgICAgICBpZiAob2JqWydEaXNwbGF5QW55VXNlclNldHMnXSAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWydDb25maWdzJ10gJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVsnQ29uZmlncyddWzBdICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bJ0NvbmZpZ3MnXVswXVsnRGlzcGxheUNvbmZpZyddKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWydDb25maWdzJ11bMF1bJ0Rpc3BsYXlDb25maWcnXTtcbiAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICBjdXJyZW50LmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob1snQ3VycmVudEluZm8nXSAmJiAnT3JpZ2luWCcgaW4gb1snQ3VycmVudEluZm8nXSAmJiByZXN1bHQuZGlzcGxheXMgJiYgcmVzdWx0LmRpc3BsYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbaV0ucG9zaXRpb25YID0gb1snQ3VycmVudEluZm8nXVsnT3JpZ2luWCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob1snQ3VycmVudEluZm8nXSAmJiAnT3JpZ2luWScgaW4gb1snQ3VycmVudEluZm8nXSAmJiByZXN1bHQuZGlzcGxheXMgJiYgcmVzdWx0LmRpc3BsYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbaV0ucG9zaXRpb25ZID0gb1snQ3VycmVudEluZm8nXVsnT3JpZ2luWSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ10gJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXS5sZW5ndGggPiAwICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bMF0ubGVuZ3RoID4gMCAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWzBdWzBdWydEaXNwbGF5SUQnXSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVswXTtcbiAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICBjdXJyZW50LmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoJ09yaWdpblgnIGluIG8gJiYgcmVzdWx0LmRpc3BsYXlzICYmIHJlc3VsdC5kaXNwbGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzW2ldLnBvc2l0aW9uWCA9IG9bJ09yaWdpblgnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdPcmlnaW5ZJyBpbiBvICYmIHJlc3VsdC5kaXNwbGF5cyAmJiByZXN1bHQuZGlzcGxheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1tpXS5wb3NpdGlvblkgPSBvWydPcmlnaW5ZJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvWydNb2RlJ10gJiYgJ0JpdHNQZXJQaXhlbCcgaW4gb1snTW9kZSddICYmIHJlc3VsdC5kaXNwbGF5cyAmJiByZXN1bHQuZGlzcGxheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1tpXS5waXhlbERlcHRoID0gb1snTW9kZSddWydCaXRzUGVyUGl4ZWwnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIC8vIFJhc3BiZXJyeTogaHR0cHM6Ly9lbGludXgub3JnL1JQSV92Y2dlbmNtZF91c2FnZVxuICAgICAgICBpZiAodXRpbC5pc1Jhc3BiZXJyeSgpICYmIHV0aWwuaXNSYXNwYmlhbigpKSB7XG4gICAgICAgICAgbGV0IGNtZCA9ICdmYnNldCAtcyB8IGdyZXAgXFwnbW9kZSBcIlxcJzsgdmNnZW5jbWQgZ2V0X21lbSBncHU7IHR2c2VydmljZSAtczsgdHZzZXJ2aWNlIC1uOyc7XG4gICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMyAmJiBsaW5lc1swXS5pbmRleE9mKCdtb2RlIFwiJykgPj0gLTEgJiYgbGluZXNbMl0uaW5kZXhPZignMHgxMjAwMGEnKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0ucmVwbGFjZSgnbW9kZScsICcnKS5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgbW9kZWw6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkZXZpY2VfbmFtZScsICc9JyksXG4gICAgICAgICAgICAgICAgICBtYWluOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYnVpbHRpbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiAnSERNSScsXG4gICAgICAgICAgICAgICAgICBzaXplWDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNpemVZOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcGl4ZWxEZXB0aDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHJlc29sdXRpb25YOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvblk6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UmVzWDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNZOiBudWxsLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb25ZOiAwLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFJlZnJlc2hSYXRlOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxICYmIHN0ZG91dC50b1N0cmluZygpLmluZGV4T2YoJ2dwdT0nKSA+PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmVuZG9yOiAnQnJvYWRjb20nLFxuICAgICAgICAgICAgICAgIG1vZGVsOiAnVmlkZW9Db3JlIElWJyxcbiAgICAgICAgICAgICAgICBidXM6ICcnLFxuICAgICAgICAgICAgICAgIHZyYW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdncHUnLCAnPScpLnJlcGxhY2UoJ00nLCAnJyksXG4gICAgICAgICAgICAgICAgdnJhbUR5bmFtaWM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgY21kID0gJ2xzcGNpIC12dnYgIDI+L2Rldi9udWxsJztcbiAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMgPSBwYXJzZUxpbmVzTGludXhDb250cm9sbGVycyhsaW5lcyk7XG4gICAgICAgICAgICAgIGNvbnN0IG52aWRpYURhdGEgPSBudmlkaWFEZXZpY2VzKCk7XG4gICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIHJld3JpdHRlbiAuLi4gdXNpbmcgbm8gc3ByZWFkIG9wZXJhdG9yc1xuICAgICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMgPSByZXN1bHQuY29udHJvbGxlcnMubWFwKChjb250cm9sbGVyKSA9PiB7IC8vIG1hdGNoIGJ5IGJ1c0FkZHJlc3NcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VDb250cm9sbGVyTnZpZGlhKGNvbnRyb2xsZXIsIG52aWRpYURhdGEuZmluZCgoY29udHIpID0+IGNvbnRyLnBjaUJ1cy50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGNvbnRyb2xsZXIuYnVzQWRkcmVzcy50b0xvd2VyQ2FzZSgpKSkgfHwge30pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjbWQgPSAnY2xpbmZvIC0tcmF3JztcbiAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycyA9IHBhcnNlTGluZXNMaW51eENsaW5mbyhyZXN1bHQuY29udHJvbGxlcnMsIGxpbmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgY21kID0gJ3hkcHlpbmZvIDI+L2Rldi9udWxsIHwgZ3JlcCBcXCdkZXB0aCBvZiByb290IHdpbmRvd1xcJyB8IGF3ayBcXCd7IHByaW50ICQ1IH1cXCcnO1xuICAgICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSAwO1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGRlcHRoID0gcGFyc2VJbnQobGluZXNbMF0pIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjbWQgPSAneHJhbmRyIC0tdmVyYm9zZSAyPi9kZXYvbnVsbCc7XG4gICAgICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzID0gcGFyc2VMaW5lc0xpbnV4RGlzcGxheXMobGluZXMsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcblxuICAgICAgICAvLyBodHRwczovL2Jsb2dzLnRlY2huZXQubWljcm9zb2Z0LmNvbS9oZXlzY3JpcHRpbmdndXkvMjAxMy8xMC8wMy91c2UtcG93ZXJzaGVsbC10by1kaXNjb3Zlci1tdWx0aS1tb25pdG9yLWluZm9ybWF0aW9uL1xuICAgICAgICAvLyBodHRwczovL2RldmJsb2dzLm1pY3Jvc29mdC5jb20vc2NyaXB0aW5nL3VzZS1wb3dlcnNoZWxsLXRvLWRpc2NvdmVyLW11bHRpLW1vbml0b3ItaW5mb3JtYXRpb24vXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIHdpbjMyX1ZpZGVvQ29udHJvbGxlciB8IGZsIConKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ2dwIFwiSEtMTTpcXFxcU1lTVEVNXFxcXENvbnRyb2xTZXQwMDFcXFxcQ29udHJvbFxcXFxDbGFzc1xcXFx7NGQzNmU5NjgtZTMyNS0xMWNlLWJmYzEtMDgwMDJiZTEwMzE4fVxcXFwqXCIgLUVycm9yQWN0aW9uIFNpbGVudGx5Q29udGludWUgfCB3aGVyZSBNYXRjaGluZ0RldmljZUlkICRudWxsIC1ORSB8IHNlbGVjdCBNYXRjaGluZ0RldmljZUlkLEhhcmR3YXJlSW5mb3JtYXRpb24ucXdNZW1vcnlTaXplIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSB3aW4zMl9kZXNrdG9wbW9uaXRvciB8IGZsIConKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSAtTmFtZXNwYWNlIHJvb3RcXFxcd21pIC1DbGFzc05hbWUgV21pTW9uaXRvckJhc2ljRGlzcGxheVBhcmFtcyB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdBZGQtVHlwZSAtQXNzZW1ibHlOYW1lIFN5c3RlbS5XaW5kb3dzLkZvcm1zOyBbU3lzdGVtLldpbmRvd3MuRm9ybXMuU2NyZWVuXTo6QWxsU2NyZWVucycpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIC1OYW1lc3BhY2Ugcm9vdFxcXFx3bWkgLUNsYXNzTmFtZSBXbWlNb25pdG9yQ29ubmVjdGlvblBhcmFtcyB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdnd21pIFdtaU1vbml0b3JJRCAtTmFtZXNwYWNlIHJvb3RcXFxcd21pIHwgRm9yRWFjaC1PYmplY3QgeygoJF8uTWFudWZhY3R1cmVyTmFtZSAtbm90bWF0Y2ggMCB8IGZvcmVhY2gge1tjaGFyXSRffSkgLWpvaW4gXCJcIikgKyBcInxcIiArICgoJF8uUHJvZHVjdENvZGVJRCAtbm90bWF0Y2ggMCB8IGZvcmVhY2gge1tjaGFyXSRffSkgLWpvaW4gXCJcIikgKyBcInxcIiArICgoJF8uVXNlckZyaWVuZGx5TmFtZSAtbm90bWF0Y2ggMCB8IGZvcmVhY2gge1tjaGFyXSRffSkgLWpvaW4gXCJcIikgKyBcInxcIiArICgoJF8uU2VyaWFsTnVtYmVySUQgLW5vdG1hdGNoIDAgfCBmb3JlYWNoIHtbY2hhcl0kX30pIC1qb2luIFwiXCIpICsgXCJ8XCIgKyAkXy5JbnN0YW5jZU5hbWV9JykpO1xuXG4gICAgICAgICAgY29uc3QgbnZpZGlhRGF0YSA9IG52aWRpYURldmljZXMoKTtcblxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnRyb2xsZXIgKyB2cmFtXG4gICAgICAgICAgICBsZXQgY3NlY3Rpb25zID0gZGF0YVswXS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBsZXQgdnNlY3Rpb25zID0gZGF0YVsxXS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMgPSBwYXJzZUxpbmVzV2luZG93c0NvbnRyb2xsZXJzKGNzZWN0aW9ucywgdnNlY3Rpb25zKTtcbiAgICAgICAgICAgIHJlc3VsdC5jb250cm9sbGVycyA9IHJlc3VsdC5jb250cm9sbGVycy5tYXAoKGNvbnRyb2xsZXIpID0+IHsgLy8gbWF0Y2ggYnkgc3ViRGV2aWNlSWRcbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudmVuZG9yLnRvTG93ZXJDYXNlKCkgPT09ICdudmlkaWEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlQ29udHJvbGxlck52aWRpYShjb250cm9sbGVyLCBudmlkaWFEYXRhLmZpbmQoZGV2aWNlID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCB3aW5kb3dzU3ViRGV2aWNlSWQgPSAoY29udHJvbGxlci5zdWJEZXZpY2VJZCB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG52aWRpYVN1YkRldmljZUlkUGFydHMgPSBkZXZpY2Uuc3ViRGV2aWNlSWQuc3BsaXQoJ3gnKTtcbiAgICAgICAgICAgICAgICAgIGxldCBudmlkaWFTdWJEZXZpY2VJZCA9IG52aWRpYVN1YkRldmljZUlkUGFydHMubGVuZ3RoID4gMSA/IG52aWRpYVN1YkRldmljZUlkUGFydHNbMV0udG9Mb3dlckNhc2UoKSA6IG52aWRpYVN1YkRldmljZUlkUGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aERpZmZlcmVuY2UgPSBNYXRoLmFicyh3aW5kb3dzU3ViRGV2aWNlSWQubGVuZ3RoIC0gbnZpZGlhU3ViRGV2aWNlSWQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dzU3ViRGV2aWNlSWQubGVuZ3RoID4gbnZpZGlhU3ViRGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoRGlmZmVyZW5jZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbnZpZGlhU3ViRGV2aWNlSWQgPSAnMCcgKyBudmlkaWFTdWJEZXZpY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dzU3ViRGV2aWNlSWQubGVuZ3RoIDwgbnZpZGlhU3ViRGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoRGlmZmVyZW5jZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2luZG93c1N1YkRldmljZUlkID0gJzAnICsgd2luZG93c1N1YkRldmljZUlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93c1N1YkRldmljZUlkID09PSBudmlkaWFTdWJEZXZpY2VJZDtcbiAgICAgICAgICAgICAgICB9KSB8fCB7fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBkaXNwbGF5c1xuICAgICAgICAgICAgbGV0IGRzZWN0aW9ucyA9IGRhdGFbMl0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgLy8gcmVzdWx0LmRpc3BsYXlzID0gcGFyc2VMaW5lc1dpbmRvd3NEaXNwbGF5cyhkc2VjdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRzZWN0aW9uc1swXS50cmltKCkgPT09ICcnKSB7IGRzZWN0aW9ucy5zaGlmdCgpOyB9XG4gICAgICAgICAgICBpZiAoZHNlY3Rpb25zLmxlbmd0aCAmJiBkc2VjdGlvbnNbZHNlY3Rpb25zLmxlbmd0aCAtIDFdLnRyaW0oKSA9PT0gJycpIHsgZHNlY3Rpb25zLnBvcCgpOyB9XG5cbiAgICAgICAgICAgIC8vIG1vbml0b3IgKHBvd2Vyc2hlbGwpXG4gICAgICAgICAgICBsZXQgbXNlY3Rpb25zID0gZGF0YVszXS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KCdBY3RpdmUgJyk7XG4gICAgICAgICAgICBtc2VjdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gZm9ybXMuc2NyZWVucyAocG93ZXJzaGVsbClcbiAgICAgICAgICAgIGxldCBzc2VjdGlvbnMgPSBkYXRhWzRdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoJ0JpdHNQZXJQaXhlbCAnKTtcbiAgICAgICAgICAgIHNzZWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBjb25uZWN0aW9uIHBhcmFtcyAocG93ZXJzaGVsbCkgLSB2aWRlbyB0eXBlXG4gICAgICAgICAgICBsZXQgdHNlY3Rpb25zID0gZGF0YVs1XS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICB0c2VjdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gbW9uaXRvciBJRCAocG93ZXJzaGVsbCkgLSBtb2RlbCAvIHZlbmRvclxuICAgICAgICAgICAgY29uc3QgcmVzID0gZGF0YVs2XS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KC9cXG4vKTtcbiAgICAgICAgICAgIGxldCBpc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGVsZW1lbnQuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIGlzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZlbmRvcjogcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICBjb2RlOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbDogcGFydHNbM10sXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkOiBwYXJ0c1s0XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzID0gcGFyc2VMaW5lc1dpbmRvd3NEaXNwbGF5c1Bvd2Vyc2hlbGwoc3NlY3Rpb25zLCBtc2VjdGlvbnMsIGRzZWN0aW9ucywgdHNlY3Rpb25zLCBpc2VjdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmRpc3BsYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBpZiAoX3Jlc29sdXRpb25YKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzWzBdLnJlc29sdXRpb25YID0gX3Jlc29sdXRpb25YO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRpc3BsYXlzWzBdLmN1cnJlbnRSZXNYKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbMF0uY3VycmVudFJlc1ggPSBfcmVzb2x1dGlvblg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfcmVzb2x1dGlvblkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbMF0ucmVzb2x1dGlvblkgPSBfcmVzb2x1dGlvblk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kaXNwbGF5c1swXS5jdXJyZW50UmVzWSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzWzBdLmN1cnJlbnRSZXNZID0gX3Jlc29sdXRpb25ZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3BpeGVsRGVwdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbMF0ucGl4ZWxEZXB0aCA9IF9waXhlbERlcHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuZGlzcGxheXMgPSByZXN1bHQuZGlzcGxheXMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBpZiAoX3JlZnJlc2hSYXRlICYmICFlbGVtZW50LmN1cnJlbnRSZWZyZXNoUmF0ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY3VycmVudFJlZnJlc2hSYXRlID0gX3JlZnJlc2hSYXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc1dpbmRvd3NDb250cm9sbGVycyhzZWN0aW9ucywgdmVjdGlvbnMpIHtcbiAgICBjb25zdCBtZW1vcnlTaXplcyA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiB2ZWN0aW9ucykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwodmVjdGlvbnMsIGkpKSB7XG4gICAgICAgIGlmICh2ZWN0aW9uc1tpXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSB2ZWN0aW9uc1tpXS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoaW5nRGV2aWNlSWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWF0Y2hpbmdEZXZpY2VJZCcpLm1hdGNoKC9QQ0lcXFxcKFZFTl9bMC05QS1GXXs0fSkmKERFVl9bMC05QS1GXXs0fSkoPzomKFNVQlNZU19bMC05QS1GXXs4fSkpPyg/OiYoUkVWX1swLTlBLUZdezJ9KSk/L2kpO1xuICAgICAgICAgIGlmIChtYXRjaGluZ0RldmljZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBxdWFkV29yZG1lbW9yeVNpemUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnSGFyZHdhcmVJbmZvcm1hdGlvbi5xd01lbW9yeVNpemUnKSk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHF1YWRXb3JkbWVtb3J5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgbGV0IGRldmljZUlkID0gbWF0Y2hpbmdEZXZpY2VJZFsxXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgbWF0Y2hpbmdEZXZpY2VJZFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdEZXZpY2VJZFszXSkge1xuICAgICAgICAgICAgICAgIGRldmljZUlkICs9ICcmJyArIG1hdGNoaW5nRGV2aWNlSWRbM10udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdEZXZpY2VJZFs0XSkge1xuICAgICAgICAgICAgICAgIGRldmljZUlkICs9ICcmJyArIG1hdGNoaW5nRGV2aWNlSWRbNF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZW1vcnlTaXplc1tkZXZpY2VJZF0gPSBxdWFkV29yZG1lbW9yeVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGNvbnRyb2xsZXJzID0gW107XG4gICAgZm9yIChsZXQgaSBpbiBzZWN0aW9ucykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoc2VjdGlvbnMsIGkpKSB7XG4gICAgICAgIGlmIChzZWN0aW9uc1tpXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc2VjdGlvbnNbaV0udHJpbSgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsZXQgcG5wRGV2aWNlSWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE5QRGV2aWNlSUQnLCAnOicpLm1hdGNoKC9QQ0lcXFxcKFZFTl9bMC05QS1GXXs0fSkmKERFVl9bMC05QS1GXXs0fSkoPzomKFNVQlNZU19bMC05QS1GXXs4fSkpPyg/OiYoUkVWX1swLTlBLUZdezJ9KSk/L2kpO1xuICAgICAgICAgIGxldCBzdWJEZXZpY2VJZCA9IG51bGw7XG4gICAgICAgICAgbGV0IG1lbW9yeVNpemUgPSBudWxsO1xuICAgICAgICAgIGlmIChwbnBEZXZpY2VJZCkge1xuICAgICAgICAgICAgc3ViRGV2aWNlSWQgPSBwbnBEZXZpY2VJZFszXSB8fCAnJztcbiAgICAgICAgICAgIGlmIChzdWJEZXZpY2VJZCkge1xuICAgICAgICAgICAgICBzdWJEZXZpY2VJZCA9IHN1YkRldmljZUlkLnNwbGl0KCdfJylbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoIFBDSSBkZXZpY2UgaWRlbnRpZmllciAodGhlcmUncyBhbiBvcmRlciBvZiBpbmNyZWFzaW5nIGdlbmVyYWxpdHkpOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvd2luZG93cy1oYXJkd2FyZS9kcml2ZXJzL2luc3RhbGwvaWRlbnRpZmllcnMtZm9yLXBjaS1kZXZpY2VzXG5cbiAgICAgICAgICAgIC8vIFBDSVxcVkVOX3YoNCkmREVWX2QoNCkmU1VCU1lTX3MoNCluKDQpJlJFVl9yKDIpXG4gICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA9PSBudWxsICYmIHBucERldmljZUlkWzNdICYmIHBucERldmljZUlkWzRdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcG5wRGV2aWNlSWRbMV0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzJdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFszXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbNF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobWVtb3J5U2l6ZXMsIGRldmljZUlkKSkge1xuICAgICAgICAgICAgICAgIG1lbW9yeVNpemUgPSBtZW1vcnlTaXplc1tkZXZpY2VJZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUENJXFxWRU5fdig0KSZERVZfZCg0KSZTVUJTWVNfcyg0KW4oNClcbiAgICAgICAgICAgIGlmIChtZW1vcnlTaXplID09IG51bGwgJiYgcG5wRGV2aWNlSWRbM10pIHtcbiAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBwbnBEZXZpY2VJZFsxXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbMl0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzNdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW9yeVNpemVzLCBkZXZpY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gbWVtb3J5U2l6ZXNbZGV2aWNlSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBDSVxcVkVOX3YoNCkmREVWX2QoNCkmUkVWX3IoMilcbiAgICAgICAgICAgIGlmIChtZW1vcnlTaXplID09IG51bGwgJiYgcG5wRGV2aWNlSWRbNF0pIHtcbiAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBwbnBEZXZpY2VJZFsxXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbMl0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzRdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW9yeVNpemVzLCBkZXZpY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gbWVtb3J5U2l6ZXNbZGV2aWNlSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBDSVxcVkVOX3YoNCkmREVWX2QoNClcbiAgICAgICAgICAgIGlmIChtZW1vcnlTaXplID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGV2aWNlSWQgPSBwbnBEZXZpY2VJZFsxXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobWVtb3J5U2l6ZXMsIGRldmljZUlkKSkge1xuICAgICAgICAgICAgICAgIG1lbW9yeVNpemUgPSBtZW1vcnlTaXplc1tkZXZpY2VJZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250cm9sbGVycy5wdXNoKHtcbiAgICAgICAgICAgIHZlbmRvcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0FkYXB0ZXJDb21wYXRpYmlsaXR5JywgJzonKSxcbiAgICAgICAgICAgIG1vZGVsOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6JyksXG4gICAgICAgICAgICBidXM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQTlBEZXZpY2VJRCcsICc6Jykuc3RhcnRzV2l0aCgnUENJJykgPyAnUENJJyA6ICcnLFxuICAgICAgICAgICAgdnJhbTogKG1lbW9yeVNpemUgPT0gbnVsbCA/IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0FkYXB0ZXJSQU0nLCAnOicpKSA6IG1lbW9yeVNpemUpIC8gMTAyNCAvIDEwMjQsXG4gICAgICAgICAgICB2cmFtRHluYW1pYzogKHV0aWwuZ2V0VmFsdWUobGluZXMsICdWaWRlb01lbW9yeVR5cGUnLCAnOicpID09PSAnMicpLFxuICAgICAgICAgICAgc3ViRGV2aWNlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfcmVzb2x1dGlvblggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDdXJyZW50SG9yaXpvbnRhbFJlc29sdXRpb24nLCAnOicpKSB8fCBfcmVzb2x1dGlvblg7XG4gICAgICAgICAgX3Jlc29sdXRpb25ZID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3VycmVudFZlcnRpY2FsUmVzb2x1dGlvbicsICc6JykpIHx8IF9yZXNvbHV0aW9uWTtcbiAgICAgICAgICBfcmVmcmVzaFJhdGUgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDdXJyZW50UmVmcmVzaFJhdGUnLCAnOicpKSB8fCBfcmVmcmVzaFJhdGU7XG4gICAgICAgICAgX3BpeGVsRGVwdGggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDdXJyZW50Qml0c1BlclBpeGVsJywgJzonKSkgfHwgX3BpeGVsRGVwdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc1dpbmRvd3NEaXNwbGF5c1Bvd2Vyc2hlbGwoc3NlY3Rpb25zLCBtc2VjdGlvbnMsIGRzZWN0aW9ucywgdHNlY3Rpb25zLCBpc2VjdGlvbnMpIHtcbiAgICBsZXQgZGlzcGxheXMgPSBbXTtcbiAgICBsZXQgdmVuZG9yID0gJyc7XG4gICAgbGV0IG1vZGVsID0gJyc7XG4gICAgbGV0IGRldmljZUlEID0gJyc7XG4gICAgbGV0IHJlc29sdXRpb25YID0gMDtcbiAgICBsZXQgcmVzb2x1dGlvblkgPSAwO1xuICAgIGlmIChkc2VjdGlvbnMgJiYgZHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgbGV0IGxpbmVzRGlzcGxheSA9IGRzZWN0aW9uc1swXS5zcGxpdCgnXFxuJyk7XG4gICAgICB2ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzRGlzcGxheSwgJ01vbml0b3JNYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzRGlzcGxheSwgJ05hbWUnLCAnOicpO1xuICAgICAgZGV2aWNlSUQgPSB1dGlsLmdldFZhbHVlKGxpbmVzRGlzcGxheSwgJ1BOUERldmljZUlEJywgJzonKS5yZXBsYWNlKC8mYW1wOy9nLCAnJicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXNvbHV0aW9uWCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lc0Rpc3BsYXksICdTY3JlZW5XaWR0aCcsICc6JykpO1xuICAgICAgcmVzb2x1dGlvblkgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXNEaXNwbGF5LCAnU2NyZWVuSGVpZ2h0JywgJzonKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3NlY3Rpb25zW2ldLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgc3NlY3Rpb25zW2ldID0gJ0JpdHNQZXJQaXhlbCAnICsgc3NlY3Rpb25zW2ldO1xuICAgICAgICBtc2VjdGlvbnNbaV0gPSAnQWN0aXZlICcgKyBtc2VjdGlvbnNbaV07XG4gICAgICAgIC8vIHRzZWN0aW9ucyBjYW4gYmUgZW1wdHkgT1IgdW5kZWZpbmVkIG9uIGVhcmxpZXIgdmVyc2lvbnMgb2YgcG93ZXJzaGVsbCAoPD0yLjApXG4gICAgICAgIC8vIFRhZyBjb25uZWN0aW9uIHR5cGUgYXMgVU5LTk9XTiBieSBkZWZhdWx0IGlmIHRoaXMgaW5mb3JtYXRpb24gaXMgbWlzc2luZ1xuICAgICAgICBpZiAodHNlY3Rpb25zLmxlbmd0aCA9PT0gMCB8fCB0c2VjdGlvbnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRzZWN0aW9uc1tpXSA9ICdVbmtub3duJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZXNTY3JlZW4gPSBzc2VjdGlvbnNbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICBsZXQgbGluZXNNb25pdG9yID0gbXNlY3Rpb25zW2ldLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICBsZXQgbGluZXNDb25uZWN0aW9uID0gdHNlY3Rpb25zW2ldLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgYml0c1BlclBpeGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lc1NjcmVlbiwgJ0JpdHNQZXJQaXhlbCcpO1xuICAgICAgICBjb25zdCBib3VuZHMgPSB1dGlsLmdldFZhbHVlKGxpbmVzU2NyZWVuLCAnQm91bmRzJykucmVwbGFjZSgneycsICcnKS5yZXBsYWNlKCd9JywgJycpLnJlcGxhY2UoLz0vZywgJzonKS5zcGxpdCgnLCcpO1xuICAgICAgICBjb25zdCBwcmltYXJ5ID0gdXRpbC5nZXRWYWx1ZShsaW5lc1NjcmVlbiwgJ1ByaW1hcnknKTtcbiAgICAgICAgY29uc3Qgc2l6ZVggPSB1dGlsLmdldFZhbHVlKGxpbmVzTW9uaXRvciwgJ01heEhvcml6b250YWxJbWFnZVNpemUnKTtcbiAgICAgICAgY29uc3Qgc2l6ZVkgPSB1dGlsLmdldFZhbHVlKGxpbmVzTW9uaXRvciwgJ01heFZlcnRpY2FsSW1hZ2VTaXplJyk7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlTmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXNNb25pdG9yLCAnSW5zdGFuY2VOYW1lJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdmlkZW9PdXRwdXRUZWNobm9sb2d5ID0gdXRpbC5nZXRWYWx1ZShsaW5lc0Nvbm5lY3Rpb24sICdWaWRlb091dHB1dFRlY2hub2xvZ3knKTtcbiAgICAgICAgY29uc3QgZGV2aWNlTmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXNTY3JlZW4sICdEZXZpY2VOYW1lJyk7XG4gICAgICAgIGxldCBkaXNwbGF5VmVuZG9yID0gJyc7XG4gICAgICAgIGxldCBkaXNwbGF5TW9kZWwgPSAnJztcbiAgICAgICAgaXNlY3Rpb25zLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuaW5zdGFuY2VJZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoaW5zdGFuY2VOYW1lKSAmJiB2ZW5kb3Iuc3RhcnRzV2l0aCgnKCcpICYmIG1vZGVsLnN0YXJ0c1dpdGgoJ1BuUCcpKSB7XG4gICAgICAgICAgICBkaXNwbGF5VmVuZG9yID0gZWxlbWVudC52ZW5kb3I7XG4gICAgICAgICAgICBkaXNwbGF5TW9kZWwgPSBlbGVtZW50Lm1vZGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BsYXlzLnB1c2goe1xuICAgICAgICAgIHZlbmRvcjogaW5zdGFuY2VOYW1lLnN0YXJ0c1dpdGgoZGV2aWNlSUQpICYmIGRpc3BsYXlWZW5kb3IgPT09ICcnID8gdmVuZG9yIDogZGlzcGxheVZlbmRvcixcbiAgICAgICAgICBtb2RlbDogaW5zdGFuY2VOYW1lLnN0YXJ0c1dpdGgoZGV2aWNlSUQpICYmIGRpc3BsYXlNb2RlbCA9PT0gJycgPyBtb2RlbCA6IGRpc3BsYXlNb2RlbCxcbiAgICAgICAgICBkZXZpY2VOYW1lLFxuICAgICAgICAgIG1haW46IHByaW1hcnkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnLFxuICAgICAgICAgIGJ1aWx0aW46IHZpZGVvT3V0cHV0VGVjaG5vbG9neSA9PT0gJzIxNDc0ODM2NDgnLFxuICAgICAgICAgIGNvbm5lY3Rpb246IHZpZGVvT3V0cHV0VGVjaG5vbG9neSAmJiB2aWRlb1R5cGVzW3ZpZGVvT3V0cHV0VGVjaG5vbG9neV0gPyB2aWRlb1R5cGVzW3ZpZGVvT3V0cHV0VGVjaG5vbG9neV0gOiAnJyxcbiAgICAgICAgICByZXNvbHV0aW9uWDogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ1dpZHRoJywgJzonKSksXG4gICAgICAgICAgcmVzb2x1dGlvblk6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdIZWlnaHQnLCAnOicpKSxcbiAgICAgICAgICBzaXplWDogc2l6ZVggPyBwYXJzZUludChzaXplWCwgMTApIDogbnVsbCxcbiAgICAgICAgICBzaXplWTogc2l6ZVkgPyBwYXJzZUludChzaXplWSwgMTApIDogbnVsbCxcbiAgICAgICAgICBwaXhlbERlcHRoOiBiaXRzUGVyUGl4ZWwsXG4gICAgICAgICAgY3VycmVudFJlc1g6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdXaWR0aCcsICc6JykpLFxuICAgICAgICAgIGN1cnJlbnRSZXNZOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnSGVpZ2h0JywgJzonKSksXG4gICAgICAgICAgcG9zaXRpb25YOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnWCcsICc6JykpLFxuICAgICAgICAgIHBvc2l0aW9uWTogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ1knLCAnOicpKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgdmVuZG9yLFxuICAgICAgICBtb2RlbCxcbiAgICAgICAgbWFpbjogdHJ1ZSxcbiAgICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICAgIHNpemVZOiBudWxsLFxuICAgICAgICByZXNvbHV0aW9uWCxcbiAgICAgICAgcmVzb2x1dGlvblksXG4gICAgICAgIHBpeGVsRGVwdGg6IG51bGwsXG4gICAgICAgIGN1cnJlbnRSZXNYOiByZXNvbHV0aW9uWCxcbiAgICAgICAgY3VycmVudFJlc1k6IHJlc29sdXRpb25ZLFxuICAgICAgICBwb3NpdGlvblg6IDAsXG4gICAgICAgIHBvc2l0aW9uWTogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkaXNwbGF5cztcbiAgfVxufVxuXG5leHBvcnRzLmdyYXBoaWNzID0gZ3JhcGhpY3M7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGluZGV4LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENvbnRyaWJ1dG9yczogIEd1aWxsYXVtZSBMZWdyYWluIChodHRwczovL2dpdGh1Yi5jb20vZ2xlZ3JhaW4pXG4vLyAgICAgICAgICAgICAgICBSaWNjYXJkbyBOb3ZhZ2xpYSAoaHR0cHM6Ly9naXRodWIuY29tL3JpY2h5MjQpXG4vLyAgICAgICAgICAgICAgICBRdWVudGluIEJ1c3V0dGlsIChodHRwczovL2dpdGh1Yi5jb20vQnV6dXQpXG4vLyAgICAgICAgICAgICAgICBMYXBzaW8gKGh0dHBzOi8vZ2l0aHViLmNvbS9sYXBzaW8pXG4vLyAgICAgICAgICAgICAgICBjc3kgKGh0dHBzOi8vZ2l0aHViLmNvbS9jc3kxOTgzKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlcGVuZGVuY2llc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBsaWJfdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBzeXN0ZW0gPSByZXF1aXJlKCcuL3N5c3RlbScpO1xuY29uc3Qgb3NJbmZvID0gcmVxdWlyZSgnLi9vc2luZm8nKTtcbmNvbnN0IGNwdSA9IHJlcXVpcmUoJy4vY3B1Jyk7XG5jb25zdCBtZW1vcnkgPSByZXF1aXJlKCcuL21lbW9yeScpO1xuY29uc3QgYmF0dGVyeSA9IHJlcXVpcmUoJy4vYmF0dGVyeScpO1xuY29uc3QgZ3JhcGhpY3MgPSByZXF1aXJlKCcuL2dyYXBoaWNzJyk7XG5jb25zdCBmaWxlc3lzdGVtID0gcmVxdWlyZSgnLi9maWxlc3lzdGVtJyk7XG5jb25zdCBuZXR3b3JrID0gcmVxdWlyZSgnLi9uZXR3b3JrJyk7XG5jb25zdCB3aWZpID0gcmVxdWlyZSgnLi93aWZpJyk7XG5jb25zdCBwcm9jZXNzZXMgPSByZXF1aXJlKCcuL3Byb2Nlc3NlcycpO1xuY29uc3QgdXNlcnMgPSByZXF1aXJlKCcuL3VzZXJzJyk7XG5jb25zdCBpbnRlcm5ldCA9IHJlcXVpcmUoJy4vaW50ZXJuZXQnKTtcbmNvbnN0IGRvY2tlciA9IHJlcXVpcmUoJy4vZG9ja2VyJyk7XG5jb25zdCB2Ym94ID0gcmVxdWlyZSgnLi92aXJ0dWFsYm94Jyk7XG5jb25zdCBwcmludGVyID0gcmVxdWlyZSgnLi9wcmludGVyJyk7XG5jb25zdCB1c2IgPSByZXF1aXJlKCcuL3VzYicpO1xuY29uc3QgYXVkaW8gPSByZXF1aXJlKCcuL2F1ZGlvJyk7XG5jb25zdCBibHVldG9vdGggPSByZXF1aXJlKCcuL2JsdWV0b290aCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGluaXRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuaWYgKF93aW5kb3dzKSB7XG4gIHV0aWwuZ2V0Q29kZXBhZ2UoKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2VuZXJhbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2ZXJzaW9uKCkge1xuICByZXR1cm4gbGliX3ZlcnNpb247XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdldCBzdGF0aWMgYW5kIGR5bmFtaWMgZGF0YSAoYWxsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0IHN0YXRpYyBkYXRhIC0gdGhleSBzaG91bGQgbm90IGNoYW5nZSB1bnRpbCByZXN0YXJ0ZWRcblxuZnVuY3Rpb24gZ2V0U3RhdGljRGF0YShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgZGF0YSA9IHt9O1xuXG4gICAgICBkYXRhLnZlcnNpb24gPSB2ZXJzaW9uKCk7XG5cbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgc3lzdGVtLnN5c3RlbSgpLFxuICAgICAgICBzeXN0ZW0uYmlvcygpLFxuICAgICAgICBzeXN0ZW0uYmFzZWJvYXJkKCksXG4gICAgICAgIHN5c3RlbS5jaGFzc2lzKCksXG4gICAgICAgIG9zSW5mby5vc0luZm8oKSxcbiAgICAgICAgb3NJbmZvLnV1aWQoKSxcbiAgICAgICAgb3NJbmZvLnZlcnNpb25zKCksXG4gICAgICAgIGNwdS5jcHUoKSxcbiAgICAgICAgY3B1LmNwdUZsYWdzKCksXG4gICAgICAgIGdyYXBoaWNzLmdyYXBoaWNzKCksXG4gICAgICAgIG5ldHdvcmsubmV0d29ya0ludGVyZmFjZXMoKSxcbiAgICAgICAgbWVtb3J5Lm1lbUxheW91dCgpLFxuICAgICAgICBmaWxlc3lzdGVtLmRpc2tMYXlvdXQoKVxuICAgICAgXSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEuc3lzdGVtID0gcmVzWzBdO1xuICAgICAgICBkYXRhLmJpb3MgPSByZXNbMV07XG4gICAgICAgIGRhdGEuYmFzZWJvYXJkID0gcmVzWzJdO1xuICAgICAgICBkYXRhLmNoYXNzaXMgPSByZXNbM107XG4gICAgICAgIGRhdGEub3MgPSByZXNbNF07XG4gICAgICAgIGRhdGEudXVpZCA9IHJlc1s1XTtcbiAgICAgICAgZGF0YS52ZXJzaW9ucyA9IHJlc1s2XTtcbiAgICAgICAgZGF0YS5jcHUgPSByZXNbN107XG4gICAgICAgIGRhdGEuY3B1LmZsYWdzID0gcmVzWzhdO1xuICAgICAgICBkYXRhLmdyYXBoaWNzID0gcmVzWzldO1xuICAgICAgICBkYXRhLm5ldCA9IHJlc1sxMF07XG4gICAgICAgIGRhdGEubWVtTGF5b3V0ID0gcmVzWzExXTtcbiAgICAgICAgZGF0YS5kaXNrTGF5b3V0ID0gcmVzWzEyXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdldCBhbGwgZHluYW1pYyBkYXRhIC0gZS5nLiBmb3IgbW9uaXRvcmluZyBhZ2VudHNcbi8vIG1heSB0YWtlIHNvbWUgc2Vjb25kcyB0byBnZXQgYWxsIGRhdGFcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAyIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBuZWVkZWRcbi8vIC0gc3J2OiBcdFx0Y29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc2VydmljZXMgdG8gbW9uaXRvciBlLmcuIFwibXlzcWwsIGFwYWNoZSwgcG9zdGdyZXNxbFwiXG4vLyAtIGlmYWNlOlx0ZGVmaW5lIG5ldHdvcmsgaW50ZXJmYWNlIGZvciB3aGljaCB5b3UgbGlrZSB0byBtb25pdG9yIG5ldHdvcmsgc3BlZWQgZS5nLiBcImV0aDBcIlxuXG5mdW5jdGlvbiBnZXREeW5hbWljRGF0YShzcnYsIGlmYWNlLCBjYWxsYmFjaykge1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oaWZhY2UpKSB7XG4gICAgY2FsbGJhY2sgPSBpZmFjZTtcbiAgICBpZmFjZSA9ICcnO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oc3J2KSkge1xuICAgIGNhbGxiYWNrID0gc3J2O1xuICAgIHNydiA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGlmYWNlID0gaWZhY2UgfHwgbmV0d29yay5nZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuICAgICAgc3J2ID0gc3J2IHx8ICcnO1xuXG4gICAgICAvLyB1c2UgY2xvc3VyZSB0byB0cmFjayDGkiBjb21wbGV0aW9uXG4gICAgICBsZXQgZnVuY3Rpb25Qcm9jZXNzZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgdG90YWxGdW5jdGlvbnMgPSAxNTtcbiAgICAgICAgaWYgKF93aW5kb3dzKSB7IHRvdGFsRnVuY3Rpb25zID0gMTM7IH1cbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHsgdG90YWxGdW5jdGlvbnMgPSAxMTsgfVxuICAgICAgICBpZiAoX3N1bm9zKSB7IHRvdGFsRnVuY3Rpb25zID0gNjsgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKC0tdG90YWxGdW5jdGlvbnMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAgICAgbGV0IGRhdGEgPSB7fTtcblxuICAgICAgLy8gZ2V0IHRpbWVcbiAgICAgIGRhdGEudGltZSA9IG9zSW5mby50aW1lKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9ICB2ZXJzaW9uc1xuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICB2ZXJzaW9ucy5ub2RlXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIHZlcnNpb25zLnY4XG4gICAgICAgKi9cbiAgICAgIGRhdGEubm9kZSA9IHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgICAgIGRhdGEudjggPSBwcm9jZXNzLnZlcnNpb25zLnY4O1xuXG4gICAgICBjcHUuY3B1Q3VycmVudFNwZWVkKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEuY3B1Q3VycmVudFNwZWVkID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHVzZXJzLnVzZXJzKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEudXNlcnMgPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcblxuICAgICAgcHJvY2Vzc2VzLnByb2Nlc3NlcygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLnByb2Nlc3NlcyA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjcHUuY3VycmVudExvYWQoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5jdXJyZW50TG9hZCA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIV9zdW5vcykge1xuICAgICAgICBjcHUuY3B1VGVtcGVyYXR1cmUoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLnRlbXAgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX29wZW5ic2QgJiYgIV9mcmVlYnNkICYmICFfbmV0YnNkICYmICFfc3Vub3MpIHtcbiAgICAgICAgbmV0d29yay5uZXR3b3JrU3RhdHMoaWZhY2UpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEubmV0d29ya1N0YXRzID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9zdW5vcykge1xuICAgICAgICBuZXR3b3JrLm5ldHdvcmtDb25uZWN0aW9ucygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEubmV0d29ya0Nvbm5lY3Rpb25zID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBtZW1vcnkubWVtKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEubWVtID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghX3N1bm9zKSB7XG4gICAgICAgIGJhdHRlcnkoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLmJhdHRlcnkgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3N1bm9zKSB7XG4gICAgICAgIHByb2Nlc3Nlcy5zZXJ2aWNlcyhzcnYpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEuc2VydmljZXMgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3N1bm9zKSB7XG4gICAgICAgIGZpbGVzeXN0ZW0uZnNTaXplKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5mc1NpemUgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3dpbmRvd3MgJiYgIV9vcGVuYnNkICYmICFfZnJlZWJzZCAmJiAhX25ldGJzZCAmJiAhX3N1bm9zKSB7XG4gICAgICAgIGZpbGVzeXN0ZW0uZnNTdGF0cygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEuZnNTdGF0cyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfd2luZG93cyAmJiAhX29wZW5ic2QgJiYgIV9mcmVlYnNkICYmICFfbmV0YnNkICYmICFfc3Vub3MpIHtcbiAgICAgICAgZmlsZXN5c3RlbS5kaXNrc0lPKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5kaXNrc0lPID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9vcGVuYnNkICYmICFfZnJlZWJzZCAmJiAhX25ldGJzZCAmJiAhX3N1bm9zKSB7XG4gICAgICAgIHdpZmkud2lmaU5ldHdvcmtzKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS53aWZpTmV0d29ya3MgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGludGVybmV0LmluZXRMYXRlbmN5KCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEuaW5ldExhdGVuY3kgPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBnZXQgYWxsIGRhdGEgYXQgb25jZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIDIgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG5lZWRlZFxuLy8gLSBzcnY6IFx0XHRjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBzZXJ2aWNlcyB0byBtb25pdG9yIGUuZy4gXCJteXNxbCwgYXBhY2hlLCBwb3N0Z3Jlc3FsXCJcbi8vIC0gaWZhY2U6XHRkZWZpbmUgbmV0d29yayBpbnRlcmZhY2UgZm9yIHdoaWNoIHlvdSBsaWtlIHRvIG1vbml0b3IgbmV0d29yayBzcGVlZCBlLmcuIFwiZXRoMFwiXG5cbmZ1bmN0aW9uIGdldEFsbERhdGEoc3J2LCBpZmFjZSwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBkYXRhID0ge307XG5cbiAgICAgIGlmIChpZmFjZSAmJiB1dGlsLmlzRnVuY3Rpb24oaWZhY2UpICYmICFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGlmYWNlO1xuICAgICAgICBpZmFjZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3J2ICYmIHV0aWwuaXNGdW5jdGlvbihzcnYpICYmICFpZmFjZSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzcnY7XG4gICAgICAgIHNydiA9ICcnO1xuICAgICAgICBpZmFjZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBnZXRTdGF0aWNEYXRhKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEgPSByZXM7XG4gICAgICAgIGdldER5bmFtaWNEYXRhKHNydiwgaWZhY2UpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGtleSBpbiByZXMpIHtcbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcywga2V5KSkge1xuICAgICAgICAgICAgICBkYXRhW2tleV0gPSByZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldCh2YWx1ZU9iamVjdCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCBhbGxQcm9taXNlcyA9IE9iamVjdC5rZXlzKHZhbHVlT2JqZWN0KVxuICAgICAgICAuZmlsdGVyKGZ1bmMgPT4gKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgZnVuYykpKVxuICAgICAgICAubWFwKGZ1bmMgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHZhbHVlT2JqZWN0W2Z1bmNdLnN1YnN0cmluZyh2YWx1ZU9iamVjdFtmdW5jXS5sYXN0SW5kZXhPZignKCcpICsgMSwgdmFsdWVPYmplY3RbZnVuY10ubGFzdEluZGV4T2YoJyknKSk7XG4gICAgICAgICAgbGV0IGZ1bmNXaXRob3V0UGFyYW1zID0gZnVuYy5pbmRleE9mKCcpJykgPj0gMCA/IGZ1bmMuc3BsaXQoJyknKVsxXS50cmltKCkgOiBmdW5jO1xuICAgICAgICAgIGZ1bmNXaXRob3V0UGFyYW1zID0gZnVuYy5pbmRleE9mKCd8JykgPj0gMCA/IGZ1bmMuc3BsaXQoJ3wnKVswXS50cmltKCkgOiBmdW5jV2l0aG91dFBhcmFtcztcbiAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0c1tmdW5jV2l0aG91dFBhcmFtc10ocGFyYW1zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHNbZnVuY1dpdGhvdXRQYXJhbXNdKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICBQcm9taXNlLmFsbChhbGxQcm9taXNlcykudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVPYmplY3QpIHtcbiAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZU9iamVjdCwga2V5KSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGtleSkgJiYgZGF0YS5sZW5ndGggPiBpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVPYmplY3Rba2V5XSA9PT0gJyonIHx8IHZhbHVlT2JqZWN0W2tleV0gPT09ICdhbGwnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBrZXlzID0gdmFsdWVPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgbGV0IGZpbHRlciA9ICcnO1xuICAgICAgICAgICAgICBsZXQgZmlsdGVyUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBhcmFtc1xuICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCcpJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGtleXMgPSBrZXlzLnNwbGl0KCcpJylbMV0udHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4dHJhY3QgZmlsdGVyIGFuZCByZW1vdmUgaXQgZnJvbSBrZXlzXG4gICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoJ3wnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyID0ga2V5cy5zcGxpdCgnfCcpWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJQYXJ0cyA9IGZpbHRlci5zcGxpdCgnOicpO1xuXG4gICAgICAgICAgICAgICAga2V5cyA9IGtleXMuc3BsaXQoJ3wnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5cyA9IGtleXMucmVwbGFjZSgvLC9nLCAnICcpLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2ldKSkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0IGlzIGluIGFuIGFycmF5LCBnbyB0aHJvdWdoIGFsbCBlbGVtZW50cyBvZiBhcnJheSBhbmQgcGljayBvbmx5IHRoZSByaWdodCBvbmVzXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGRhdGFbaV0uZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRpYWxSZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIChrZXlzWzBdID09PSAnKicgfHwga2V5c1swXSA9PT0gJ2FsbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFJlcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudCwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFJlc1trXSA9IGVsZW1lbnRba107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBmaWx0ZXIsIHRoZW4ganVzdCB0YWtlIHRob3NlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwocGFydGlhbFJlcywgZmlsdGVyUGFydHNbMF0udHJpbSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gcGFydGlhbFJlc1tmaWx0ZXJQYXJ0c1swXS50cmltKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gcGFyc2VGbG9hdChmaWx0ZXJQYXJ0c1sxXS50cmltKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbEFycmF5LnB1c2gocGFydGlhbFJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLnRvTG93ZXJDYXNlKCkgPT09IGZpbHRlclBhcnRzWzFdLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbEFycmF5LnB1c2gocGFydGlhbFJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGFydGlhbEFycmF5LnB1c2gocGFydGlhbFJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHBhcnRpYWxBcnJheTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhW2ldLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxSZXNba10gPSBkYXRhW2ldW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcGFydGlhbFJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWVPYmplY3QsIGludGVydmFsLCBjYWxsYmFjaykge1xuICBsZXQgX2RhdGEgPSBudWxsO1xuXG4gIGNvbnN0IHJlc3VsdCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBnZXQodmFsdWVPYmplY3QpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeShfZGF0YSkgIT09IEpTT04uc3RyaW5naWZ5KGRhdGEpKSB7XG4gICAgICAgIF9kYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBpbnRlcnZhbCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGV4cG9ydCBhbGwgbGlic1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuZXhwb3J0cy5zeXN0ZW0gPSBzeXN0ZW0uc3lzdGVtO1xuZXhwb3J0cy5iaW9zID0gc3lzdGVtLmJpb3M7XG5leHBvcnRzLmJhc2Vib2FyZCA9IHN5c3RlbS5iYXNlYm9hcmQ7XG5leHBvcnRzLmNoYXNzaXMgPSBzeXN0ZW0uY2hhc3NpcztcblxuZXhwb3J0cy50aW1lID0gb3NJbmZvLnRpbWU7XG5leHBvcnRzLm9zSW5mbyA9IG9zSW5mby5vc0luZm87XG5leHBvcnRzLnZlcnNpb25zID0gb3NJbmZvLnZlcnNpb25zO1xuZXhwb3J0cy5zaGVsbCA9IG9zSW5mby5zaGVsbDtcbmV4cG9ydHMudXVpZCA9IG9zSW5mby51dWlkO1xuXG5leHBvcnRzLmNwdSA9IGNwdS5jcHU7XG5leHBvcnRzLmNwdUZsYWdzID0gY3B1LmNwdUZsYWdzO1xuZXhwb3J0cy5jcHVDYWNoZSA9IGNwdS5jcHVDYWNoZTtcbmV4cG9ydHMuY3B1Q3VycmVudFNwZWVkID0gY3B1LmNwdUN1cnJlbnRTcGVlZDtcbmV4cG9ydHMuY3B1VGVtcGVyYXR1cmUgPSBjcHUuY3B1VGVtcGVyYXR1cmU7XG5leHBvcnRzLmN1cnJlbnRMb2FkID0gY3B1LmN1cnJlbnRMb2FkO1xuZXhwb3J0cy5mdWxsTG9hZCA9IGNwdS5mdWxsTG9hZDtcblxuZXhwb3J0cy5tZW0gPSBtZW1vcnkubWVtO1xuZXhwb3J0cy5tZW1MYXlvdXQgPSBtZW1vcnkubWVtTGF5b3V0O1xuXG5leHBvcnRzLmJhdHRlcnkgPSBiYXR0ZXJ5O1xuXG5leHBvcnRzLmdyYXBoaWNzID0gZ3JhcGhpY3MuZ3JhcGhpY3M7XG5cbmV4cG9ydHMuZnNTaXplID0gZmlsZXN5c3RlbS5mc1NpemU7XG5leHBvcnRzLmZzT3BlbkZpbGVzID0gZmlsZXN5c3RlbS5mc09wZW5GaWxlcztcbmV4cG9ydHMuYmxvY2tEZXZpY2VzID0gZmlsZXN5c3RlbS5ibG9ja0RldmljZXM7XG5leHBvcnRzLmZzU3RhdHMgPSBmaWxlc3lzdGVtLmZzU3RhdHM7XG5leHBvcnRzLmRpc2tzSU8gPSBmaWxlc3lzdGVtLmRpc2tzSU87XG5leHBvcnRzLmRpc2tMYXlvdXQgPSBmaWxlc3lzdGVtLmRpc2tMYXlvdXQ7XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZURlZmF1bHQgPSBuZXR3b3JrLm5ldHdvcmtJbnRlcmZhY2VEZWZhdWx0O1xuZXhwb3J0cy5uZXR3b3JrR2F0ZXdheURlZmF1bHQgPSBuZXR3b3JrLm5ldHdvcmtHYXRld2F5RGVmYXVsdDtcbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXMgPSBuZXR3b3JrLm5ldHdvcmtJbnRlcmZhY2VzO1xuZXhwb3J0cy5uZXR3b3JrU3RhdHMgPSBuZXR3b3JrLm5ldHdvcmtTdGF0cztcbmV4cG9ydHMubmV0d29ya0Nvbm5lY3Rpb25zID0gbmV0d29yay5uZXR3b3JrQ29ubmVjdGlvbnM7XG5cbmV4cG9ydHMud2lmaU5ldHdvcmtzID0gd2lmaS53aWZpTmV0d29ya3M7XG5leHBvcnRzLndpZmlJbnRlcmZhY2VzID0gd2lmaS53aWZpSW50ZXJmYWNlcztcbmV4cG9ydHMud2lmaUNvbm5lY3Rpb25zID0gd2lmaS53aWZpQ29ubmVjdGlvbnM7XG5cbmV4cG9ydHMuc2VydmljZXMgPSBwcm9jZXNzZXMuc2VydmljZXM7XG5leHBvcnRzLnByb2Nlc3NlcyA9IHByb2Nlc3Nlcy5wcm9jZXNzZXM7XG5leHBvcnRzLnByb2Nlc3NMb2FkID0gcHJvY2Vzc2VzLnByb2Nlc3NMb2FkO1xuXG5leHBvcnRzLnVzZXJzID0gdXNlcnMudXNlcnM7XG5cbmV4cG9ydHMuaW5ldENoZWNrc2l0ZSA9IGludGVybmV0LmluZXRDaGVja3NpdGU7XG5leHBvcnRzLmluZXRMYXRlbmN5ID0gaW50ZXJuZXQuaW5ldExhdGVuY3k7XG5cbmV4cG9ydHMuZG9ja2VySW5mbyA9IGRvY2tlci5kb2NrZXJJbmZvO1xuZXhwb3J0cy5kb2NrZXJJbWFnZXMgPSBkb2NrZXIuZG9ja2VySW1hZ2VzO1xuZXhwb3J0cy5kb2NrZXJDb250YWluZXJzID0gZG9ja2VyLmRvY2tlckNvbnRhaW5lcnM7XG5leHBvcnRzLmRvY2tlckNvbnRhaW5lclN0YXRzID0gZG9ja2VyLmRvY2tlckNvbnRhaW5lclN0YXRzO1xuZXhwb3J0cy5kb2NrZXJDb250YWluZXJQcm9jZXNzZXMgPSBkb2NrZXIuZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzO1xuZXhwb3J0cy5kb2NrZXJWb2x1bWVzID0gZG9ja2VyLmRvY2tlclZvbHVtZXM7XG5leHBvcnRzLmRvY2tlckFsbCA9IGRvY2tlci5kb2NrZXJBbGw7XG5cbmV4cG9ydHMudmJveEluZm8gPSB2Ym94LnZib3hJbmZvO1xuXG5leHBvcnRzLnByaW50ZXIgPSBwcmludGVyLnByaW50ZXI7XG5cbmV4cG9ydHMudXNiID0gdXNiLnVzYjtcblxuZXhwb3J0cy5hdWRpbyA9IGF1ZGlvLmF1ZGlvO1xuZXhwb3J0cy5ibHVldG9vdGhEZXZpY2VzID0gYmx1ZXRvb3RoLmJsdWV0b290aERldmljZXM7XG5cbmV4cG9ydHMuZ2V0U3RhdGljRGF0YSA9IGdldFN0YXRpY0RhdGE7XG5leHBvcnRzLmdldER5bmFtaWNEYXRhID0gZ2V0RHluYW1pY0RhdGE7XG5leHBvcnRzLmdldEFsbERhdGEgPSBnZXRBbGxEYXRhO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xuXG5leHBvcnRzLnBvd2VyU2hlbGxTdGFydCA9IHV0aWwucG93ZXJTaGVsbFN0YXJ0O1xuZXhwb3J0cy5wb3dlclNoZWxsUmVsZWFzZSA9IHV0aWwucG93ZXJTaGVsbFJlbGVhc2U7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGludGVybmV0LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTIuIEludGVybmV0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjaGVjayBpZiBleHRlcm5hbCBzaXRlIGlzIGF2YWlsYWJsZVxuXG5mdW5jdGlvbiBpbmV0Q2hlY2tzaXRlKHVybCwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBtczogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgbGV0IHVybFNhbml0aXplZCA9ICcnO1xuICAgICAgY29uc3QgcyA9IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyh1cmwsIHRydWUpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzW2ldLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgICBjb25zdCBzbCA9IHNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoc2wgJiYgc2xbMF0gJiYgIXNsWzFdICYmIHNsWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXJsU2FuaXRpemVkID0gdXJsU2FuaXRpemVkICsgc2xbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQudXJsID0gdXJsU2FuaXRpemVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHVybFNhbml0aXplZCAmJiAhdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkpIHtcbiAgICAgICAgICB1cmxTYW5pdGl6ZWQuX19wcm90b19fLnN0YXJ0c1dpdGggPSB1dGlsLnN0cmluZ1N0YXJ0V2l0aDtcbiAgICAgICAgICBpZiAodXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2ZpbGU6JykgfHwgdXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2dvcGhlcjonKSB8fCB1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgndGVsbmV0OicpIHx8IHVybFNhbml0aXplZC5zdGFydHNXaXRoKCdtYWlsdG86JykgfHwgdXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ25ld3M6JykgfHwgdXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ25udHA6JykpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4gfHwgX3N1bm9zKSB7XG4gICAgICAgICAgICBsZXQgYXJncyA9IFsnLUknLCAnLS1jb25uZWN0LXRpbWVvdXQnLCAnNScsICctbScsICc1J107XG4gICAgICAgICAgICBhcmdzLnB1c2godXJsU2FuaXRpemVkKTtcbiAgICAgICAgICAgIGxldCBjbWQgPSAnY3VybCc7XG4gICAgICAgICAgICB1dGlsLmV4ZWNTYWZlKGNtZCwgYXJncykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IHN0YXR1c0NvZGUgPSBsaW5lc1swXSAmJiBsaW5lc1swXS5pbmRleE9mKCcgJykgPj0gMCA/IHBhcnNlSW50KGxpbmVzWzBdLnNwbGl0KCcgJylbMV0sIDEwKSA6IDQwNDtcbiAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHN0YXR1c0NvZGUgfHwgNDA0O1xuICAgICAgICAgICAgICByZXN1bHQub2sgPSAoc3RhdHVzQ29kZSA9PT0gMjAwIHx8IHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIgfHwgc3RhdHVzQ29kZSA9PT0gMzA0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1zID0gKHJlc3VsdC5vayA/IERhdGUubm93KCkgLSB0IDogbnVsbCk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHsgICAvLyBpZiB0aGlzIGlzIHN0YWJsZSwgdGhpcyBjYW4gYmUgdXNlZCBmb3IgYWxsIE9TIHR5cGVzXG4gICAgICAgICAgICBjb25zdCBodHRwID0gKHVybFNhbml0aXplZC5zdGFydHNXaXRoKCdodHRwczonKSA/IHJlcXVpcmUoJ2h0dHBzJykgOiByZXF1aXJlKCdodHRwJykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaHR0cC5nZXQodXJsU2FuaXRpemVkLCAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHN0YXR1c0NvZGUgfHwgNDA0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vayA9IChzdGF0dXNDb2RlID09PSAyMDAgfHwgc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHN0YXR1c0NvZGUgPT09IDMwMiB8fCBzdGF0dXNDb2RlID09PSAzMDQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgcmVzLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1zID0gKHJlc3VsdC5vayA/IERhdGUubm93KCkgLSB0IDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXMub24oJ2RhdGEnLCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tcyA9IChyZXN1bHQub2sgPyBEYXRlLm5vdygpIC0gdCA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuaW5ldENoZWNrc2l0ZSA9IGluZXRDaGVja3NpdGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjaGVjayBpbmV0IGxhdGVuY3lcblxuZnVuY3Rpb24gaW5ldExhdGVuY3koaG9zdCwgY2FsbGJhY2spIHtcblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihob3N0KSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGhvc3Q7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaG9zdCA9IGhvc3QgfHwgJzguOC44LjgnO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBsZXQgaG9zdFNhbml0aXplZCA9ICcnO1xuICAgICAgY29uc3QgcyA9ICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICc4LjguOC44JyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhob3N0LCB0cnVlKSkudHJpbSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgIGlmICghKHNbaV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICBzW2ldLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgICBjb25zdCBzbCA9IHNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoc2wgJiYgc2xbMF0gJiYgIXNsWzFdKSB7XG4gICAgICAgICAgICBob3N0U2FuaXRpemVkID0gaG9zdFNhbml0aXplZCArIHNsWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9zdFNhbml0aXplZC5fX3Byb3RvX18uc3RhcnRzV2l0aCA9IHV0aWwuc3RyaW5nU3RhcnRXaXRoO1xuICAgICAgaWYgKGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnZmlsZTonKSB8fCBob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2dvcGhlcjonKSB8fCBob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ3RlbG5ldDonKSB8fCBob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ21haWx0bzonKSB8fCBob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ25ld3M6JykgfHwgaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCdubnRwOicpKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXJhbXM7XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2Rhcndpbikge1xuICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgcGFyYW1zID0gWyctYycsICcyJywgJy13JywgJzMnLCBob3N0U2FuaXRpemVkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIHBhcmFtcyA9IFsnLWMnLCAnMicsICctdCcsICczJywgaG9zdFNhbml0aXplZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBwYXJhbXMgPSBbJy1jMicsICctdDMnLCBob3N0U2FuaXRpemVkXTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwaW5nJywgcGFyYW1zKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJykuZmlsdGVyKChsaW5lKSA9PiAobGluZS5pbmRleE9mKCdydHQnKSA+PSAwIHx8IGxpbmUuaW5kZXhPZigncm91bmQtdHJpcCcpID49IDAgfHwgbGluZS5pbmRleE9mKCdhdmcnKSA+PSAwKSkuam9pbignXFxuJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lcy5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVbMV0uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFsnLXMnLCAnLWEnLCBob3N0U2FuaXRpemVkLCAnNTYnLCAnMiddO1xuICAgICAgICBjb25zdCBmaWx0ID0gJ2F2Zyc7XG4gICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BpbmcnLCBwYXJhbXMsIHsgdGltZW91dDogMzAwMCB9KS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmRleE9mKGZpbHQpID49IDApLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZVsxXS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlRmxvYXQocGFydHNbMV0ucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbaG9zdFNhbml0aXplZCwgJy1uJywgJzEnXTtcbiAgICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwaW5nJywgcGFyYW1zLCB1dGlsLmV4ZWNPcHRzV2luKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgbGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmICgobGluZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9tcy9nKSB8fCBbXSkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbCA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGwubGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KGxbbC5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5pbmV0TGF0ZW5jeSA9IGluZXRMYXRlbmN5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBtZW1vcnkuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA1LiBNZW1vcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5jb25zdCBPU1hfUkFNX21hbnVmYWN0dXJlcnMgPSB7XG4gICcweDAxNEYnOiAnVHJhbnNjZW5kIEluZm9ybWF0aW9uJyxcbiAgJzB4MkMwMCc6ICdNaWNyb24gVGVjaG5vbG9neSBJbmMuJyxcbiAgJzB4ODAyQyc6ICdNaWNyb24gVGVjaG5vbG9neSBJbmMuJyxcbiAgJzB4ODBBRCc6ICdIeW5peCBTZW1pY29uZHVjdG9yIEluYy4nLFxuICAnMHg4MENFJzogJ1NhbXN1bmcgRWxlY3Ryb25pY3MgSW5jLicsXG4gICcweEFEMDAnOiAnSHluaXggU2VtaWNvbmR1Y3RvciBJbmMuJyxcbiAgJzB4Q0UwMCc6ICdTYW1zdW5nIEVsZWN0cm9uaWNzIEluYy4nLFxuICAnMHgwMkZFJzogJ0VscGlkYScsXG4gICcweDUxMDUnOiAnUWltb25kYSBBRyBpLiBJbi4nLFxuICAnMHg4NTUxJzogJ1FpbW9uZGEgQUcgaS4gSW4uJyxcbiAgJzB4ODU5Qic6ICdDcnVjaWFsJyxcbiAgJzB4MDRDRCc6ICdHLVNraWxsJ1xufTtcblxuY29uc3QgTElOVVhfUkFNX21hbnVmYWN0dXJlcnMgPSB7XG4gICcwMTdBJzogJ0FwYWNlcicsXG4gICcwMTk4JzogJ0h5cGVyWCcsXG4gICcwMjlFJzogJ0NvcnNhaXInLFxuICAnMDRDQic6ICdBLURBVEEnLFxuICAnMDRDRCc6ICdHLVNraWxsJyxcbiAgJzA1OUInOiAnQ3J1Y2lhbCcsXG4gICcwMENFJzogJ1NhbXN1bmcnLFxuICAnMTMxNSc6ICdDcnV0aWFsJyxcbiAgJzAxNEYnOiAnVHJhbnNjZW5kIEluZm9ybWF0aW9uJyxcbiAgJzJDMDAnOiAnTWljcm9uIFRlY2hub2xvZ3kgSW5jLicsXG4gICc4MDJDJzogJ01pY3JvbiBUZWNobm9sb2d5IEluYy4nLFxuICAnODBBRCc6ICdIeW5peCBTZW1pY29uZHVjdG9yIEluYy4nLFxuICAnODBDRSc6ICdTYW1zdW5nIEVsZWN0cm9uaWNzIEluYy4nLFxuICAnQUQwMCc6ICdIeW5peCBTZW1pY29uZHVjdG9yIEluYy4nLFxuICAnQ0UwMCc6ICdTYW1zdW5nIEVsZWN0cm9uaWNzIEluYy4nLFxuICAnMDJGRSc6ICdFbHBpZGEnLFxuICAnNTEwNSc6ICdRaW1vbmRhIEFHIGkuIEluLicsXG4gICc4NTUxJzogJ1FpbW9uZGEgQUcgaS4gSW4uJyxcbiAgJzg1OUInOiAnQ3J1Y2lhbCdcbn07XG5cbi8vIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICBSIEEgTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgSCBEICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX19ffCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHwgICAgICAgIGFjdGl2ZSAgICAgICAgICAgICBidWZmZXJzL2NhY2hlICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX3xfX19fX19fX198X19fX19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgdXNlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmVlICAgfCAgIHVzZWQgICAgICAgZnJlZSAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgc3dhcCAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX3xcblxuLy8gZnJlZSAob2xkZXIgdmVyc2lvbnMpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAjIGZyZWVcbi8vICAgICAgICAgICAgICB0b3RhbCAgICAgICB1c2VkICAgICAgICBmcmVlICAgICBzaGFyZWQgICAgYnVmZmVycyAgICAgY2FjaGVkXG4vLyBNZW06ICAgICAgICAgMTYwMzggKDEpICAgMTU2NTMgKDIpICAgMzg0ICgzKSAgMCAoNCkgICAgIDIzNiAoNSkgICAgIDE0Nzg4ICg2KVxuLy8gLS8rIGJ1ZmZlcnMvY2FjaGU6ICAgICAgIDYyOCAoNykgICAgIDE1NDA5ICg4KVxuLy8gU3dhcDogICAgICAgIDE2MzcxICAgICAgICAgODMgICAgICAxNjI4OFxuLy9cbi8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgUiBBIE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbi8vIHwgYWN0aXZlICgyLSg1KzYpID0gNykgfCAgYXZhaWxhYmxlICgzKzUrNiA9IDgpICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19ffFxuLy8gfCAgICAgICAgYWN0aXZlICAgICAgICB8ICBidWZmZXJzL2NhY2hlICg1KzYpICAgIHwgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgIHVzZWQgKDIpICAgICAgICAgICAgICAgICAgICAgfCBmcmVlICgzKSAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICgxKSAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuXG4vL1xuLy8gZnJlZSAoc2luY2UgZnJlZSB2b24gcHJvY3BzLW5nIDMuMy4xMClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICMgZnJlZVxuLy8gICAgICAgICAgICAgIHRvdGFsICAgICAgIHVzZWQgICAgICAgIGZyZWUgICAgIHNoYXJlZCAgICBidWZmZXJzL2NhY2hlICAgYXZhaWxhYmxlXG4vLyBNZW06ICAgICAgICAgMTYwMzggKDEpICAgNjI4ICgyKSAgICAgMzg2ICgzKSAgMCAoNCkgICAgIDE1MDI0ICg1KSAgICAgMTQ3ODggKDYpXG4vLyBTd2FwOiAgICAgICAgMTYzNzEgICAgICAgICA4MyAgICAgIDE2Mjg4XG4vL1xuLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICAgICBSIEEgTSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgYXZhaWxhYmxlICg2KSBlc3RpbWF0ZWQgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX198XG4vLyB8ICAgICBhY3RpdmUgKDIpICAgICAgIHwgICBidWZmZXJzL2NhY2hlICg1KSAgICAgfCBmcmVlICgzKSAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICgxKSAgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffFxuLy9cbi8vIFJlZmVyZW5jZTogaHR0cDovL3d3dy5zb2Z0d2FyZS1hcmNoaXRlY3QubmV0L2Jsb2cvYXJ0aWNsZS9kYXRlLzIwMTUvMDYvMTIvLTgyNmM2ZTUwNTIuaHRtbFxuXG4vLyAvcHJvY3MvbWVtaW5mbyAtIHNhbXBsZSAoYWxsIGluIGtCKVxuLy9cbi8vIE1lbVRvdGFsOiAzMjgwNjM4MCBrQlxuLy8gTWVtRnJlZTogMTc5Nzc3NDQga0Jcbi8vIE1lbUF2YWlsYWJsZTogMTk3Njg5NzIga0Jcbi8vIEJ1ZmZlcnM6IDUxNzAyOCBrQlxuLy8gQ2FjaGVkOiAyMTYxODc2IGtCXG4vLyBTd2FwQ2FjaGVkOiA0NTYga0Jcbi8vIEFjdGl2ZTogMTIwODExNzYga0Jcbi8vIEluYWN0aXZlOiAyMTY0NjE2IGtCXG4vLyBBY3RpdmUoYW5vbik6IDEwODMyODg0IGtCXG4vLyBJbmFjdGl2ZShhbm9uKTogMTQ3NzI3MiBrQlxuLy8gQWN0aXZlKGZpbGUpOiAxMjQ4MjkyIGtCXG4vLyBJbmFjdGl2ZShmaWxlKTogNjg3MzQ0IGtCXG4vLyBVbmV2aWN0YWJsZTogMCBrQlxuLy8gTWxvY2tlZDogMCBrQlxuLy8gU3dhcFRvdGFsOiAxNjc2ODg5MiBrQlxuLy8gU3dhcEZyZWU6IDE2NzY4MzA0IGtCXG4vLyBEaXJ0eTogMjY4IGtCXG4vLyBXcml0ZWJhY2s6IDAga0Jcbi8vIEFub25QYWdlczogMTE1Njg4MzIga0Jcbi8vIE1hcHBlZDogNzE5OTkyIGtCXG4vLyBTaG1lbTogNzQzMjcyIGtCXG4vLyBTbGFiOiAzMzU3MTYga0Jcbi8vIFNSZWNsYWltYWJsZTogMjU2MzY0IGtCXG4vLyBTVW5yZWNsYWltOiA3OTM1MiBrQlxuXG5mdW5jdGlvbiBtZW0oY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgdG90YWw6IG9zLnRvdGFsbWVtKCksXG4gICAgICAgIGZyZWU6IG9zLmZyZWVtZW0oKSxcbiAgICAgICAgdXNlZDogb3MudG90YWxtZW0oKSAtIG9zLmZyZWVtZW0oKSxcblxuICAgICAgICBhY3RpdmU6IG9zLnRvdGFsbWVtKCkgLSBvcy5mcmVlbWVtKCksICAgICAvLyB0ZW1wb3JhcmlseSAoZmFsbGJhY2spXG4gICAgICAgIGF2YWlsYWJsZTogb3MuZnJlZW1lbSgpLCAgICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyaWx5IChmYWxsYmFjaylcbiAgICAgICAgYnVmZmVyczogMCxcbiAgICAgICAgY2FjaGVkOiAwLFxuICAgICAgICBzbGFiOiAwLFxuICAgICAgICBidWZmY2FjaGU6IDAsXG5cbiAgICAgICAgc3dhcHRvdGFsOiAwLFxuICAgICAgICBzd2FwdXNlZDogMCxcbiAgICAgICAgc3dhcGZyZWU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgZnMucmVhZEZpbGUoJy9wcm9jL21lbWluZm8nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0LnRvdGFsID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21lbXRvdGFsJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC50b3RhbCA9IHJlc3VsdC50b3RhbCA/IHJlc3VsdC50b3RhbCAqIDEwMjQgOiBvcy50b3RhbG1lbSgpO1xuICAgICAgICAgICAgcmVzdWx0LmZyZWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWVtZnJlZScpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuZnJlZSA9IHJlc3VsdC5mcmVlID8gcmVzdWx0LmZyZWUgKiAxMDI0IDogb3MuZnJlZW1lbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnVzZWQgPSByZXN1bHQudG90YWwgLSByZXN1bHQuZnJlZTtcblxuICAgICAgICAgICAgcmVzdWx0LmJ1ZmZlcnMgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnYnVmZmVycycpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuYnVmZmVycyA9IHJlc3VsdC5idWZmZXJzID8gcmVzdWx0LmJ1ZmZlcnMgKiAxMDI0IDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FjaGVkJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZWQgPSByZXN1bHQuY2FjaGVkID8gcmVzdWx0LmNhY2hlZCAqIDEwMjQgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LnNsYWIgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2xhYicpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuc2xhYiA9IHJlc3VsdC5zbGFiID8gcmVzdWx0LnNsYWIgKiAxMDI0IDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5idWZmY2FjaGUgPSByZXN1bHQuYnVmZmVycyArIHJlc3VsdC5jYWNoZWQgKyByZXN1bHQuc2xhYjtcblxuICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZW1hdmFpbGFibGUnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmF2YWlsYWJsZSA9IGF2YWlsYWJsZSA/IGF2YWlsYWJsZSAqIDEwMjQgOiByZXN1bHQuZnJlZSArIHJlc3VsdC5idWZmY2FjaGU7XG4gICAgICAgICAgICByZXN1bHQuYWN0aXZlID0gcmVzdWx0LnRvdGFsIC0gcmVzdWx0LmF2YWlsYWJsZTtcblxuICAgICAgICAgICAgcmVzdWx0LnN3YXB0b3RhbCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzd2FwdG90YWwnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXB0b3RhbCA9IHJlc3VsdC5zd2FwdG90YWwgPyByZXN1bHQuc3dhcHRvdGFsICogMTAyNCA6IDA7XG4gICAgICAgICAgICByZXN1bHQuc3dhcGZyZWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3dhcGZyZWUnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXBmcmVlID0gcmVzdWx0LnN3YXBmcmVlID8gcmVzdWx0LnN3YXBmcmVlICogMTAyNCA6IDA7XG4gICAgICAgICAgICByZXN1bHQuc3dhcHVzZWQgPSByZXN1bHQuc3dhcHRvdGFsIC0gcmVzdWx0LnN3YXBmcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCcvc2Jpbi9zeXNjdGwgaHcucmVhbG1lbSBody5waHlzbWVtIHZtLnN0YXRzLnZtLnZfcGFnZV9jb3VudCB2bS5zdGF0cy52bS52X3dpcmVfY291bnQgdm0uc3RhdHMudm0udl9hY3RpdmVfY291bnQgdm0uc3RhdHMudm0udl9pbmFjdGl2ZV9jb3VudCB2bS5zdGF0cy52bS52X2NhY2hlX2NvdW50IHZtLnN0YXRzLnZtLnZfZnJlZV9jb3VudCB2bS5zdGF0cy52bS52X3BhZ2Vfc2l6ZScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgcGFnZXNpemUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm0uc3RhdHMudm0udl9wYWdlX3NpemUnKSwgMTApO1xuICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm0uc3RhdHMudm0udl9pbmFjdGl2ZV9jb3VudCcpLCAxMCkgKiBwYWdlc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZtLnN0YXRzLnZtLnZfY2FjaGVfY291bnQnKSwgMTApICogcGFnZXNpemU7XG5cbiAgICAgICAgICAgIHJlc3VsdC50b3RhbCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5yZWFsbWVtJyksIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQudG90YWwpKSB7IHJlc3VsdC50b3RhbCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5waHlzbWVtJyksIDEwKTsgfVxuICAgICAgICAgICAgcmVzdWx0LmZyZWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm0uc3RhdHMudm0udl9mcmVlX2NvdW50JyksIDEwKSAqIHBhZ2VzaXplO1xuICAgICAgICAgICAgcmVzdWx0LmJ1ZmZjYWNoZSA9IGluYWN0aXZlICsgY2FjaGU7XG4gICAgICAgICAgICByZXN1bHQuYXZhaWxhYmxlID0gcmVzdWx0LmJ1ZmZjYWNoZSArIHJlc3VsdC5mcmVlO1xuICAgICAgICAgICAgcmVzdWx0LmFjdGl2ZSA9IHJlc3VsdC50b3RhbCAtIHJlc3VsdC5mcmVlIC0gcmVzdWx0LmJ1ZmZjYWNoZTtcblxuICAgICAgICAgICAgcmVzdWx0LnN3YXB0b3RhbCA9IDA7XG4gICAgICAgICAgICByZXN1bHQuc3dhcGZyZWUgPSAwO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXB1c2VkID0gMDtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBwYWdlU2l6ZSA9IDQwOTY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHN5c1BwYWdlU2l6ZSA9IHV0aWwudG9JbnQoZXhlY1N5bmMoJ3N5c2N0bCAtbiB2bS5wYWdlc2l6ZScpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHBhZ2VTaXplID0gc3lzUHBhZ2VTaXplIHx8IHBhZ2VTaXplO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhlYygndm1fc3RhdCAyPi9kZXYvbnVsbCB8IGdyZXAgXCJQYWdlcyBhY3RpdmVcIicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICByZXN1bHQuYWN0aXZlID0gcGFyc2VJbnQobGluZXNbMF0uc3BsaXQoJzonKVsxXSwgMTApICogcGFnZVNpemU7XG4gICAgICAgICAgICByZXN1bHQuYnVmZmNhY2hlID0gcmVzdWx0LnVzZWQgLSByZXN1bHQuYWN0aXZlO1xuICAgICAgICAgICAgcmVzdWx0LmF2YWlsYWJsZSA9IHJlc3VsdC5mcmVlICsgcmVzdWx0LmJ1ZmZjYWNoZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYygnc3lzY3RsIC1uIHZtLnN3YXB1c2FnZSAyPi9kZXYvbnVsbCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RsaW5lID0gbGluZXNbMF0ucmVwbGFjZSgvLC9nLCAnLicpLnJlcGxhY2UoL00vZywgJycpO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lQXJyYXkgPSBmaXJzdGxpbmUudHJpbSgpLnNwbGl0KCcgICcpO1xuICAgICAgICAgICAgICAgIGxpbmVBcnJheS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd0b3RhbCcpICE9PSAtMSkgeyByZXN1bHQuc3dhcHRvdGFsID0gcGFyc2VGbG9hdChsaW5lLnNwbGl0KCc9JylbMV0udHJpbSgpKSAqIDEwMjQgKiAxMDI0OyB9XG4gICAgICAgICAgICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3VzZWQnKSAhPT0gLTEpIHsgcmVzdWx0LnN3YXB1c2VkID0gcGFyc2VGbG9hdChsaW5lLnNwbGl0KCc9JylbMV0udHJpbSgpKSAqIDEwMjQgKiAxMDI0OyB9XG4gICAgICAgICAgICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZyZWUnKSAhPT0gLTEpIHsgcmVzdWx0LnN3YXBmcmVlID0gcGFyc2VGbG9hdChsaW5lLnNwbGl0KCc9JylbMV0udHJpbSgpKSAqIDEwMjQgKiAxMDI0OyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBzd2FwdG90YWwgPSAwO1xuICAgICAgICBsZXQgc3dhcHVzZWQgPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1BhZ2VGaWxlVXNhZ2UgfCBTZWxlY3QgQWxsb2NhdGVkQmFzZVNpemUsIEN1cnJlbnRVc2FnZScpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpLmZpbHRlcigobGluZSwgaWR4KSA9PiBpZHggPiAwKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnNwbGl0KC9cXHNcXHMrLyk7XG4gICAgICAgICAgICAgICAgICBzd2FwdG90YWwgPSBzd2FwdG90YWwgKyAocGFyc2VJbnQobGluZVswXSwgMTApIHx8IDApO1xuICAgICAgICAgICAgICAgICAgc3dhcHVzZWQgPSBzd2FwdXNlZCArIChwYXJzZUludChsaW5lWzFdLCAxMCkgfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdG90YWwgPSBzd2FwdG90YWwgKiAxMDI0ICogMTAyNDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdXNlZCA9IHN3YXB1c2VkICogMTAyNCAqIDEwMjQ7XG4gICAgICAgICAgICByZXN1bHQuc3dhcGZyZWUgPSByZXN1bHQuc3dhcHRvdGFsIC0gcmVzdWx0LnN3YXB1c2VkO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubWVtID0gbWVtO1xuXG5mdW5jdGlvbiBtZW1MYXlvdXQoY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXJEYXJ3aW4obWFuSWQpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChPU1hfUkFNX21hbnVmYWN0dXJlcnMsIG1hbklkKSkge1xuICAgICAgcmV0dXJuIChPU1hfUkFNX21hbnVmYWN0dXJlcnNbbWFuSWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hbklkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWFudWZhY3R1cmVyTGludXgobWFuSWQpIHtcbiAgICBjb25zdCBtYW5JZFNlYXJjaCA9IG1hbklkLnJlcGxhY2UoJzB4JywgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKG1hbklkU2VhcmNoLmxlbmd0aCA9PT0gNCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKExJTlVYX1JBTV9tYW51ZmFjdHVyZXJzLCBtYW5JZFNlYXJjaCkpIHtcbiAgICAgIHJldHVybiAoTElOVVhfUkFNX21hbnVmYWN0dXJlcnNbbWFuSWRTZWFyY2hdKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hbklkO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IG1lbW9yeSAyPi9kZXYvbnVsbCB8IGdyZXAgLWlFIFwiU2l6ZTp8VHlwZXxTcGVlZHxNYW51ZmFjdHVyZXJ8Rm9ybSBGYWN0b3J8TG9jYXRvcnxNZW1vcnkgRGV2aWNlfFNlcmlhbCBOdW1iZXJ8Vm9sdGFnZXxQYXJ0IE51bWJlclwiOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBkZXZpY2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ01lbW9yeSBEZXZpY2UnKTtcbiAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemVTdHJpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2l6ZScpO1xuICAgICAgICAgICAgICBjb25zdCBzaXplID0gc2l6ZVN0cmluZy5pbmRleE9mKCdHQicpID49IDAgPyBwYXJzZUludChzaXplU3RyaW5nLCAxMCkgKiAxMDI0ICogMTAyNCAqIDEwMjQgOiBwYXJzZUludChzaXplU3RyaW5nLCAxMCkgKiAxMDI0ICogMTAyNDtcbiAgICAgICAgICAgICAgbGV0IGJhbmsgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQmFuayBMb2NhdG9yJyk7XG4gICAgICAgICAgICAgIGlmIChiYW5rLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYmFkJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGJhbmsgPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NpemUnKSwgMTApID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbCBXaWR0aCcpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhV2lkdGggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdEYXRhIFdpZHRoJykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICBiYW5rLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1R5cGU6JyksXG4gICAgICAgICAgICAgICAgICBlY2M6IGRhdGFXaWR0aCAmJiB0b3RhbFdpZHRoID8gdG90YWxXaWR0aCA+IGRhdGFXaWR0aCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogKHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWd1cmVkIENsb2NrIFNwZWVkOicpID8gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZ3VyZWQgQ2xvY2sgU3BlZWQ6JyksIDEwKSA6ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3BlZWQ6JykgPyBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3BlZWQ6JyksIDEwKSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGb3JtIEZhY3RvcjonKSxcbiAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogZ2V0TWFudWZhY3R1cmVyTGludXgodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hbnVmYWN0dXJlcjonKSksXG4gICAgICAgICAgICAgICAgICBwYXJ0TnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFydCBOdW1iZXI6JyksXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWwgTnVtYmVyOicpLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZ3VyZWQgVm9sdGFnZTonKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01pbmltdW0gVm9sdGFnZTonKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01heGltdW0gVm9sdGFnZTonKSkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgICAgICAgYmFuayxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdFbXB0eScsXG4gICAgICAgICAgICAgICAgICBlY2M6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiAwLFxuICAgICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Zvcm0gRmFjdG9yOicpLFxuICAgICAgICAgICAgICAgICAgcGFydE51bTogJycsXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06ICcnLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1heDogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBzaXplOiBvcy50b3RhbG1lbSgpLFxuICAgICAgICAgICAgICBiYW5rOiAnJyxcbiAgICAgICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgICAgIGVjYzogbnVsbCxcbiAgICAgICAgICAgICAgY2xvY2tTcGVlZDogMCxcbiAgICAgICAgICAgICAgZm9ybUZhY3RvcjogJycsXG4gICAgICAgICAgICAgIHBhcnROdW06ICcnLFxuICAgICAgICAgICAgICBzZXJpYWxOdW06ICcnLFxuICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgdm9sdGFnZU1pbjogbnVsbCxcbiAgICAgICAgICAgICAgdm9sdGFnZU1heDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUcnkgUmFzcGJlcnJ5IFBJXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsZXQgc3Rkb3V0ID0gZXhlY1N5bmMoJ2NhdCAvcHJvYy9jcHVpbmZvIDI+L2Rldi9udWxsJyk7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2hhcmR3YXJlJywgJzonLCB0cnVlKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBsZXQgdmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdyZXZpc2lvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICBpZiAobW9kZWwgPT09ICdCQ00yODM1JyB8fCBtb2RlbCA9PT0gJ0JDTTI3MDgnIHx8IG1vZGVsID09PSAnQkNNMjcwOScgfHwgbW9kZWwgPT09ICdCQ00yODM1JyB8fCBtb2RlbCA9PT0gJ0JDTTI4MzcnKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbG9ja1NwZWVkID0ge1xuICAgICAgICAgICAgICAgICAgJzAnOiA0MDAsXG4gICAgICAgICAgICAgICAgICAnMSc6IDQ1MCxcbiAgICAgICAgICAgICAgICAgICcyJzogNDUwLFxuICAgICAgICAgICAgICAgICAgJzMnOiAzMjAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0udHlwZSA9ICdMUEREUjInO1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS50eXBlID0gdmVyc2lvbiAmJiB2ZXJzaW9uWzJdICYmIHZlcnNpb25bMl0gPT09ICczJyA/ICdMUEREUjQnIDogcmVzdWx0WzBdLnR5cGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLmVjYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS5jbG9ja1NwZWVkID0gdmVyc2lvbiAmJiB2ZXJzaW9uWzJdICYmIGNsb2NrU3BlZWRbdmVyc2lvblsyXV0gfHwgNDAwO1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS5jbG9ja1NwZWVkID0gdmVyc2lvbiAmJiB2ZXJzaW9uWzRdICYmIHZlcnNpb25bNF0gPT09ICdkJyA/IDUwMCA6IHJlc3VsdFswXS5jbG9ja1NwZWVkO1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS5mb3JtRmFjdG9yID0gJ1NvQyc7XG5cbiAgICAgICAgICAgICAgICBzdGRvdXQgPSBleGVjU3luYygndmNnZW5jbWQgZ2V0X2NvbmZpZyBzZHJhbV9mcmVxIDI+L2Rldi9udWxsJyk7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgbGV0IGZyZXEgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2RyYW1fZnJlcScsICc9JywgdHJ1ZSksIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChmcmVxKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbMF0uY2xvY2tTcGVlZCA9IGZyZXE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3Rkb3V0ID0gZXhlY1N5bmMoJ3ZjZ2VuY21kIG1lYXN1cmVfdm9sdHMgc2RyYW1fcCAyPi9kZXYvbnVsbCcpO1xuICAgICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxldCB2b2x0YWdlID0gcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdCcsICc9JywgdHJ1ZSkpIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHZvbHRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFswXS52b2x0YWdlQ29uZmlndXJlZCA9IHZvbHRhZ2U7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbMF0udm9sdGFnZU1pbiA9IHZvbHRhZ2U7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbMF0udm9sdGFnZU1heCA9IHZvbHRhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3lzdGVtX3Byb2ZpbGVyIFNQTWVtb3J5RGF0YVR5cGUnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbExpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgZWNjU3RhdHVzID0gdXRpbC5nZXRWYWx1ZShhbGxMaW5lcywgJ2VjYycsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxldCBkZXZpY2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJyAgICAgICAgQkFOSyAnKTtcbiAgICAgICAgICAgIGxldCBoYXNCYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBkZXZpY2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJyAgICAgICAgRElNTScpO1xuICAgICAgICAgICAgICBoYXNCYW5rID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCBiYW5rID0gKGhhc0JhbmsgPyAnQkFOSyAnIDogJ0RJTU0nKSArIGxpbmVzWzBdLnRyaW0oKS5zcGxpdCgnLycpWzBdO1xuICAgICAgICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBTaXplJykpO1xuICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgICAgICAgICBiYW5rOiBiYW5rLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBUeXBlOicpLFxuICAgICAgICAgICAgICAgICAgZWNjOiBlY2NTdGF0dXMgPyBlY2NTdGF0dXMgPT09ICdlbmFibGVkJyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIFNwZWVkOicpLCAxMCksXG4gICAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogZ2V0TWFudWZhY3R1cmVyRGFyd2luKHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgTWFudWZhY3R1cmVyOicpKSxcbiAgICAgICAgICAgICAgICAgIHBhcnROdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgUGFydCBOdW1iZXI6JyksXG4gICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgU2VyaWFsIE51bWJlcjonKSxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgICAgICAgIGJhbms6IGJhbmssXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnRW1wdHknLFxuICAgICAgICAgICAgICAgICAgZWNjOiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogMCxcbiAgICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6ICcnLFxuICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgICAgICAgICAgIHBhcnROdW06ICcnLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiAnJyxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICBNZW1vcnk6JykpO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICBUeXBlOicpO1xuICAgICAgICAgICAgaWYgKHNpemUgJiYgdHlwZSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSAqIDEwMjQgKiAxMDI0ICogMTAyNCxcbiAgICAgICAgICAgICAgICBiYW5rOiAnMCcsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBlY2M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IDAsXG4gICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogJycsXG4gICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiAnQXBwbGUnLFxuICAgICAgICAgICAgICAgIHBhcnROdW06ICcnLFxuICAgICAgICAgICAgICAgIHNlcmlhbE51bTogJycsXG4gICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogbnVsbCxcbiAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBudWxsLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBjb25zdCBtZW1vcnlUeXBlcyA9ICdVbmtub3dufE90aGVyfERSQU18U3luY2hyb25vdXMgRFJBTXxDYWNoZSBEUkFNfEVET3xFRFJBTXxWUkFNfFNSQU18UkFNfFJPTXxGTEFTSHxFRVBST018RkVQUk9NfEVQUk9NfENEUkFNfDNEUkFNfFNEUkFNfFNHUkFNfFJEUkFNfEREUnxERFIyfEREUjIgRkItRElNTXxSZXNlcnZlZHxERFIzfEZCRDJ8RERSNHxMUEREUnxMUEREUjJ8TFBERFIzfExQRERSNCcuc3BsaXQoJ3wnKTtcbiAgICAgICAgY29uc3QgRm9ybUZhY3RvcnMgPSAnVW5rbm93bnxPdGhlcnxTSVB8RElQfFpJUHxTT0p8UHJvcHJpZXRhcnl8U0lNTXxESU1NfFRTT1B8UEdBfFJJTU18U09ESU1NfFNSSU1NfFNNRHxTU01QfFFGUHxUUUZQfFNPSUN8TENDfFBMQ0N8QkdBfEZQQkdBfExHQScuc3BsaXQoJ3wnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1BoeXNpY2FsTWVtb3J5IHwgc2VsZWN0IERhdGFXaWR0aCxUb3RhbFdpZHRoLENhcGFjaXR5LEJhbmtMYWJlbCxNZW1vcnlUeXBlLFNNQklPU01lbW9yeVR5cGUsQ29uZmlndXJlZENsb2NrU3BlZWQsRm9ybUZhY3RvcixNYW51ZmFjdHVyZXIsUGFydE51bWJlcixTZXJpYWxOdW1iZXIsQ29uZmlndXJlZFZvbHRhZ2UsTWluVm9sdGFnZSxNYXhWb2x0YWdlIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVdpZHRoID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGF0YVdpZHRoJywgJzonKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RvdGFsV2lkdGgnLCAnOicpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcGFjaXR5JywgJzonKSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYmFuazogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JhbmtMYWJlbCcsICc6JyksIC8vIEJhbmtMYWJlbFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZW1vcnlUeXBlc1twYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWVtb3J5VHlwZScsICc6JyksIDEwKSB8fCBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU01CSU9TTWVtb3J5VHlwZScsICc6JyksIDEwKV0sXG4gICAgICAgICAgICAgICAgICAgIGVjYzogZGF0YVdpZHRoICYmIHRvdGFsV2lkdGggPyB0b3RhbFdpZHRoID4gZGF0YVdpZHRoIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWd1cmVkQ2xvY2tTcGVlZCcsICc6JyksIDEwKSB8fCBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3BlZWQnLCAnOicpLCAxMCkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogRm9ybUZhY3RvcnNbcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Zvcm1GYWN0b3InLCAnOicpLCAxMCkgfHwgMF0sXG4gICAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hbnVmYWN0dXJlcicsICc6JyksXG4gICAgICAgICAgICAgICAgICAgIHBhcnROdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYXJ0TnVtYmVyJywgJzonKSxcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsTnVtYmVyJywgJzonKSxcbiAgICAgICAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IChwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlndXJlZFZvbHRhZ2UnLCAnOicpLCAxMCkgfHwgMCkgLyAxMDAwLjAsXG4gICAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IChwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWluVm9sdGFnZScsICc6JyksIDEwKSB8fCAwKSAvIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgICAgdm9sdGFnZU1heDogKHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYXhWb2x0YWdlJywgJzonKSwgMTApIHx8IDApIC8gMTAwMC4wLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5tZW1MYXlvdXQgPSBtZW1MYXlvdXQ7XG5cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gbmV0d29yay5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDkuIE5ldHdvcmtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5sZXQgX25ldHdvcmsgPSB7fTtcbmxldCBfZGVmYXVsdF9pZmFjZSA9ICcnO1xubGV0IF9pZmFjZXMgPSB7fTtcbmxldCBfZGhjcE5pY3MgPSBbXTtcbmxldCBfbmV0d29ya0ludGVyZmFjZXMgPSBbXTtcbmxldCBfbWFjID0ge307XG5sZXQgcGF0aFRvSXA7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCkge1xuXG4gIGxldCBpZmFjZW5hbWUgPSAnJztcbiAgbGV0IGlmYWNlbmFtZUZpcnN0ID0gJyc7XG4gIHRyeSB7XG4gICAgbGV0IGlmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG5cbiAgICBsZXQgc2NvcGVpZCA9IDk5OTk7XG5cbiAgICAvLyBmYWxsYmFjayAtIFwiZmlyc3RcIiBleHRlcm5hbCBpbnRlcmZhY2UgKHNvcnRlZCBieSBzY29wZWlkKVxuICAgIGZvciAobGV0IGRldiBpbiBpZmFjZXMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgZGV2KSkge1xuICAgICAgICBpZmFjZXNbZGV2XS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5pbnRlcm5hbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmYWNlbmFtZUZpcnN0ID0gaWZhY2VuYW1lRmlyc3QgfHwgZGV2OyAvLyBmYWxsYmFjayBpZiBubyBzY29wZWlkXG4gICAgICAgICAgICBpZiAoZGV0YWlscy5zY29wZWlkICYmIGRldGFpbHMuc2NvcGVpZCA8IHNjb3BlaWQpIHtcbiAgICAgICAgICAgICAgaWZhY2VuYW1lID0gZGV2O1xuICAgICAgICAgICAgICBzY29wZWlkID0gZGV0YWlscy5zY29wZWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmYWNlbmFtZSA9IGlmYWNlbmFtZSB8fCBpZmFjZW5hbWVGaXJzdCB8fCAnJztcblxuICAgIGlmIChfd2luZG93cykge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuaW5ldGRhZW1vbi5jb20vdHV0b3JpYWxzL2ludGVybmV0L2lwL3JvdXRpbmcvZGVmYXVsdF9yb3V0ZS5zaHRtbFxuICAgICAgbGV0IGRlZmF1bHRJcCA9ICcnO1xuICAgICAgY29uc3QgY21kID0gJ25ldHN0YXQgLXInO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoY21kLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQob3MuRU9MKTtcbiAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJzAuMC4wLjAgMC4wLjAuMCcpID4gLTEgJiYgISgvW2EtekEtWl0vLnRlc3QobGluZSkpKSB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICBkZWZhdWx0SXAgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGRlZmF1bHRJcCkge1xuICAgICAgICBmb3IgKGxldCBkZXYgaW4gaWZhY2VzKSB7XG4gICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBkZXYpKSB7XG4gICAgICAgICAgICBpZmFjZXNbZGV2XS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuYWRkcmVzcyAmJiBkZXRhaWxzLmFkZHJlc3MgPT09IGRlZmF1bHRJcCkge1xuICAgICAgICAgICAgICAgIGlmYWNlbmFtZSA9IGRldjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfbGludXgpIHtcbiAgICAgIGxldCBjbWQgPSAnaXAgcm91dGUgMj4gL2Rldi9udWxsIHwgZ3JlcCBkZWZhdWx0JztcbiAgICAgIGxldCByZXN1bHQgPSBleGVjU3luYyhjbWQpO1xuICAgICAgbGV0IHBhcnRzID0gcmVzdWx0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnNwbGl0KC9cXHMrLyk7XG4gICAgICBpZiAocGFydHNbMF0gPT09ICdub25lJyAmJiBwYXJ0c1s1XSkge1xuICAgICAgICBpZmFjZW5hbWUgPSBwYXJ0c1s1XTtcbiAgICAgIH0gZWxzZSBpZiAocGFydHNbNF0pIHtcbiAgICAgICAgaWZhY2VuYW1lID0gcGFydHNbNF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpZmFjZW5hbWUuaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgaWZhY2VuYW1lID0gaWZhY2VuYW1lLnNwbGl0KCc6JylbMV0udHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2RhcndpbiB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9zdW5vcykge1xuICAgICAgbGV0IGNtZCA9ICcnO1xuICAgICAgaWYgKF9saW51eCkgeyBjbWQgPSAnaXAgcm91dGUgMj4gL2Rldi9udWxsIHwgZ3JlcCBkZWZhdWx0IHwgYXdrIFxcJ3twcmludCAkNX1cXCcnOyB9XG4gICAgICBpZiAoX2RhcndpbikgeyBjbWQgPSAncm91dGUgLW4gZ2V0IGRlZmF1bHQgMj4vZGV2L251bGwgfCBncmVwIGludGVyZmFjZTogfCBhd2sgXFwne3ByaW50ICQyfVxcJyc7IH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9zdW5vcykgeyBjbWQgPSAncm91dGUgZ2V0IDAuMC4wLjAgfCBncmVwIGludGVyZmFjZTonOyB9XG4gICAgICBsZXQgcmVzdWx0ID0gZXhlY1N5bmMoY21kKTtcbiAgICAgIGlmYWNlbmFtZSA9IHJlc3VsdC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgIGlmIChpZmFjZW5hbWUuaW5kZXhPZignOicpID4gLTEpIHtcbiAgICAgICAgaWZhY2VuYW1lID0gaWZhY2VuYW1lLnNwbGl0KCc6JylbMV0udHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIGlmIChpZmFjZW5hbWUpIHsgX2RlZmF1bHRfaWZhY2UgPSBpZmFjZW5hbWU7IH1cbiAgcmV0dXJuIF9kZWZhdWx0X2lmYWNlO1xufVxuXG5leHBvcnRzLmdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlID0gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2U7XG5cbmZ1bmN0aW9uIGdldE1hY0FkZHJlc3NlcygpIHtcbiAgbGV0IGlmYWNlID0gJyc7XG4gIGxldCBtYWMgPSAnJztcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICBpZiAodHlwZW9mIHBhdGhUb0lwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBleGVjU3luYygnd2hpY2ggaXAnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5pbmRleE9mKCc6JykgPT09IC0xICYmIGxpbmVzWzBdLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICAgIHBhdGhUb0lwID0gbGluZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFRvSXAgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwYXRoVG9JcCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgJyArICgocGF0aFRvSXApID8gcGF0aFRvSXAgKyAnIGxpbmsgc2hvdyB1cCcgOiAnL3NiaW4vaWZjb25maWcnKSArICc7IHVuc2V0IExDX0FMTCc7XG4gICAgICBsZXQgcmVzID0gZXhlY1N5bmMoY21kKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gcmVzLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZXNbaV0gJiYgbGluZXNbaV1bMF0gIT09ICcgJykge1xuICAgICAgICAgIGlmIChwYXRoVG9JcCkge1xuICAgICAgICAgICAgbGV0IG5leHRsaW5lID0gbGluZXNbaSArIDFdLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgaWYgKG5leHRsaW5lWzBdID09PSAnbGluay9ldGhlcicpIHtcbiAgICAgICAgICAgICAgaWZhY2UgPSBsaW5lc1tpXS5zcGxpdCgnICcpWzFdO1xuICAgICAgICAgICAgICBpZmFjZSA9IGlmYWNlLnNsaWNlKDAsIGlmYWNlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBtYWMgPSBuZXh0bGluZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWZhY2UgPSBsaW5lc1tpXS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgbWFjID0gbGluZXNbaV0uc3BsaXQoJ0hXYWRkciAnKVsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaWZhY2UgJiYgbWFjKSB7XG4gICAgICAgICAgICByZXN1bHRbaWZhY2VdID0gbWFjLnRyaW0oKTtcbiAgICAgICAgICAgIGlmYWNlID0gJyc7XG4gICAgICAgICAgICBtYWMgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9kYXJ3aW4pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY21kID0gJy9zYmluL2lmY29uZmlnJztcbiAgICAgIGxldCByZXMgPSBleGVjU3luYyhjbWQpO1xuICAgICAgY29uc3QgbGluZXMgPSByZXMudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXSAmJiBsaW5lc1tpXVswXSAhPT0gJ1xcdCcgJiYgbGluZXNbaV0uaW5kZXhPZignOicpID4gMCkge1xuICAgICAgICAgIGlmYWNlID0gbGluZXNbaV0uc3BsaXQoJzonKVswXTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lc1tpXS5pbmRleE9mKCdcXHRldGhlciAnKSA9PT0gMCkge1xuICAgICAgICAgIG1hYyA9IGxpbmVzW2ldLnNwbGl0KCdcXHRldGhlciAnKVsxXTtcbiAgICAgICAgICBpZiAoaWZhY2UgJiYgbWFjKSB7XG4gICAgICAgICAgICByZXN1bHRbaWZhY2VdID0gbWFjLnRyaW0oKTtcbiAgICAgICAgICAgIGlmYWNlID0gJyc7XG4gICAgICAgICAgICBtYWMgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbmV0d29ya0ludGVyZmFjZURlZmF1bHQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZURlZmF1bHQgPSBuZXR3b3JrSW50ZXJmYWNlRGVmYXVsdDtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE5FVCAtIGludGVyZmFjZXNcblxuZnVuY3Rpb24gcGFyc2VMaW5lc1dpbmRvd3NOaWNzKHNlY3Rpb25zLCBuY29uZmlnc2VjdGlvbnMpIHtcbiAgbGV0IG5pY3MgPSBbXTtcbiAgZm9yIChsZXQgaSBpbiBzZWN0aW9ucykge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlY3Rpb25zLCBpKSkge1xuXG4gICAgICBpZiAoc2VjdGlvbnNbaV0udHJpbSgpICE9PSAnJykge1xuXG4gICAgICAgIGxldCBsaW5lcyA9IHNlY3Rpb25zW2ldLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGxldCBsaW5lc05pY0NvbmZpZyA9IG5jb25maWdzZWN0aW9ucyAmJiBuY29uZmlnc2VjdGlvbnNbaV0gPyBuY29uZmlnc2VjdGlvbnNbaV0udHJpbSgpLnNwbGl0KCdcXHJcXG4nKSA6IFtdO1xuICAgICAgICBsZXQgbmV0RW5hYmxlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOZXRFbmFibGVkJywgJzonKTtcbiAgICAgICAgbGV0IGFkYXB0ZXJUeXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0FkYXB0ZXJUeXBlSUQnLCAnOicpID09PSAnOScgPyAnd2lyZWxlc3MnIDogJ3dpcmVkJztcbiAgICAgICAgbGV0IGlmYWNlbmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOYW1lJywgJzonKS5yZXBsYWNlKC9cXF0vZywgJyknKS5yZXBsYWNlKC9cXFsvZywgJygnKTtcbiAgICAgICAgbGV0IGlmYWNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05ldENvbm5lY3Rpb25JRCcsICc6JykucmVwbGFjZSgvXFxdL2csICcpJykucmVwbGFjZSgvXFxbL2csICcoJyk7XG4gICAgICAgIGlmIChpZmFjZW5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aS1maScpID49IDAgfHwgaWZhY2VuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2lyZWxlc3MnKSA+PSAwKSB7XG4gICAgICAgICAgYWRhcHRlclR5cGUgPSAnd2lyZWxlc3MnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXRFbmFibGVkICE9PSAnJykge1xuICAgICAgICAgIGNvbnN0IHNwZWVkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NwZWVkJywgJzonKS50cmltKCksIDEwKSAvIDEwMDAwMDA7XG4gICAgICAgICAgbmljcy5wdXNoKHtcbiAgICAgICAgICAgIG1hYzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01BQ0FkZHJlc3MnLCAnOicpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBkaGNwOiB1dGlsLmdldFZhbHVlKGxpbmVzTmljQ29uZmlnLCAnZGhjcEVuYWJsZWQnLCAnOicpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyxcbiAgICAgICAgICAgIG5hbWU6IGlmYWNlbmFtZSxcbiAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgbmV0RW5hYmxlZDogbmV0RW5hYmxlZCA9PT0gJ1RSVUUnLFxuICAgICAgICAgICAgc3BlZWQ6IGlzTmFOKHNwZWVkKSA/IG51bGwgOiBzcGVlZCxcbiAgICAgICAgICAgIG9wZXJzdGF0ZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05ldENvbm5lY3Rpb25TdGF0dXMnLCAnOicpID09PSAnMicgPyAndXAnIDogJ2Rvd24nLFxuICAgICAgICAgICAgdHlwZTogYWRhcHRlclR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmljcztcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c05pY3MoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGNtZCA9ICdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfTmV0d29ya0FkYXB0ZXIgfCBmbCAqJyArICc7IGVjaG8gXFwnIy0jLSMtI1xcJzsnO1xuICAgICAgY21kICs9ICdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfTmV0d29ya0FkYXB0ZXJDb25maWd1cmF0aW9uIHwgZmwgREhDUEVuYWJsZWQnICsgJyc7XG4gICAgICB0cnkge1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoY21kKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJyMtIy0jLSMnKTtcbiAgICAgICAgICBjb25zdCBuc2VjdGlvbnMgPSAoZGF0YVswXSB8fCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICBjb25zdCBuY29uZmlnc2VjdGlvbnMgPSAoZGF0YVsxXSB8fCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnNlTGluZXNXaW5kb3dzTmljcyhuc2VjdGlvbnMsIG5jb25maWdzZWN0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzRE5Tc3VmZml4ZXMoKSB7XG5cbiAgbGV0IGlmYWNlID0ge307XG5cbiAgbGV0IGRuc1N1ZmZpeGVzID0ge1xuICAgIHByaW1hcnlETlM6ICcnLFxuICAgIGV4aXRDb2RlOiAwLFxuICAgIGlmYWNlczogW10sXG4gIH07XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBpcGNvbmZpZyA9IGV4ZWNTeW5jKCdpcGNvbmZpZyAvYWxsJywgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgY29uc3QgaXBjb25maWdBcnJheSA9IGlwY29uZmlnLnNwbGl0KCdcXHJcXG5cXHJcXG4nKTtcblxuICAgIGlwY29uZmlnQXJyYXkuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcblxuICAgICAgaWYgKGluZGV4ID09IDEpIHtcbiAgICAgICAgY29uc3QgbG9uZ1ByaW1hcnlETlMgPSBlbGVtZW50LnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdETlMnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByaW1hcnlETlMgPSBsb25nUHJpbWFyeUROU1swXS5zdWJzdHJpbmcobG9uZ1ByaW1hcnlETlNbMF0ubGFzdEluZGV4T2YoJzonKSArIDEpO1xuICAgICAgICBkbnNTdWZmaXhlcy5wcmltYXJ5RE5TID0gcHJpbWFyeUROUy50cmltKCk7XG4gICAgICAgIGlmICghZG5zU3VmZml4ZXMucHJpbWFyeUROUykgeyBkbnNTdWZmaXhlcy5wcmltYXJ5RE5TID0gJ05vdCBkZWZpbmVkJzsgfVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID4gMSkge1xuICAgICAgICBpZiAoaW5kZXggJSAyID09IDApIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5zdWJzdHJpbmcoZWxlbWVudC5sYXN0SW5kZXhPZignICcpICsgMSkucmVwbGFjZSgnOicsICcnKTtcbiAgICAgICAgICBpZmFjZS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uU3BlY2lmaWNETlMgPSBlbGVtZW50LnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ0ROUycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGRuc1N1ZmZpeCA9IGNvbm5lY3Rpb25TcGVjaWZpY0ROU1swXS5zdWJzdHJpbmcoY29ubmVjdGlvblNwZWNpZmljRE5TWzBdLmxhc3RJbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgICBpZmFjZS5kbnNTdWZmaXggPSBkbnNTdWZmaXgudHJpbSgpO1xuICAgICAgICAgIGRuc1N1ZmZpeGVzLmlmYWNlcy5wdXNoKGlmYWNlKTtcbiAgICAgICAgICBpZmFjZSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG5zU3VmZml4ZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW1hcnlETlM6ICcnLFxuICAgICAgZXhpdENvZGU6IDAsXG4gICAgICBpZmFjZXM6IFtdLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c0lmYWNlRE5Tc3VmZml4KGlmYWNlcywgaWZhY2VuYW1lKSB7XG4gIGxldCBkbnNTdWZmaXggPSAnJztcbiAgLy8gQWRkaW5nICguKSB0byBlbnN1cmUgaWZhY2VuYW1lIGNvbXBhdGliaWxpdHkgd2hlbiBkdXBsaWNhdGVkIGlmYWNlLW5hbWVzXG4gIGNvbnN0IGludGVyZmFjZU5hbWUgPSBpZmFjZW5hbWUgKyAnLic7XG4gIHRyeSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkRuc1N1ZmZpeCA9IGlmYWNlcy5maWx0ZXIoKGlmYWNlKSA9PiB7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlTmFtZS5pbmNsdWRlcyhpZmFjZS5uYW1lICsgJy4nKTtcbiAgICB9KS5tYXAoKGlmYWNlKSA9PiBpZmFjZS5kbnNTdWZmaXgpO1xuICAgIGlmIChjb25uZWN0aW9uRG5zU3VmZml4WzBdKSB7XG4gICAgICBkbnNTdWZmaXggPSBjb25uZWN0aW9uRG5zU3VmZml4WzBdO1xuICAgIH1cbiAgICBpZiAoIWRuc1N1ZmZpeCkgeyBkbnNTdWZmaXggPSAnJzsgfVxuICAgIHJldHVybiBkbnNTdWZmaXg7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzV2lyZWRQcm9maWxlc0luZm9ybWF0aW9uKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKCduZXRzaCBsYW4gc2hvdyBwcm9maWxlcycsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgIGNvbnN0IHByb2ZpbGVMaXN0ID0gcmVzdWx0LnNwbGl0KCdcXHJcXG5Qcm9maWxlIG9uIGludGVyZmFjZScpO1xuICAgIHJldHVybiBwcm9maWxlTGlzdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSAxICYmIGVycm9yLnN0ZG91dC5pbmNsdWRlcygnQXV0b0NvbmZpZycpKSB7XG4gICAgICByZXR1cm4gJ0Rpc2FibGVkJztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NXaXJlbGVzc0lmYWNlU1NJRChpbnRlcmZhY2VOYW1lKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoYG5ldHNoIHdsYW4gc2hvdyAgaW50ZXJmYWNlIG5hbWU9XCIke2ludGVyZmFjZU5hbWV9XCIgfCBmaW5kc3RyIFwiU1NJRFwiYCwgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgY29uc3QgU1NJRCA9IHJlc3VsdC5zcGxpdCgnXFxyXFxuJykuc2hpZnQoKTtcbiAgICBjb25zdCBwYXJzZVNTSUQgPSBTU0lELnNwbGl0KCc6JykucG9wKCk7XG4gICAgcmV0dXJuIHBhcnNlU1NJRDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dzSUVFRTgwMjF4KGNvbm5lY3Rpb25UeXBlLCBpZmFjZSwgaWZhY2VzKSB7XG4gIGxldCBpODAyMXggPSB7XG4gICAgc3RhdGU6ICdVbmtub3duJyxcbiAgICBwcm90b2NvbDogJ1Vua25vd24nLFxuICB9O1xuXG4gIGlmIChpZmFjZXMgPT09ICdEaXNhYmxlZCcpIHtcbiAgICBpODAyMXguc3RhdGUgPSAnRGlzYWJsZWQnO1xuICAgIGk4MDIxeC5wcm90b2NvbCA9ICdOb3QgZGVmaW5lZCc7XG4gICAgcmV0dXJuIGk4MDIxeDtcbiAgfVxuXG4gIGlmIChjb25uZWN0aW9uVHlwZSA9PSAnd2lyZWQnICYmIGlmYWNlcy5sZW5ndGggPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCA4MDIuMXggaW5mb3JtYXRpb24gYnkgaW50ZXJmYWNlIG5hbWVcbiAgICAgIGNvbnN0IGlmYWNlODAyMXhJbmZvID0gaWZhY2VzLmZpbmQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaW5jbHVkZXMoaWZhY2UgKyAnXFxyXFxuJyk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFycmF5SWZhY2U4MDIxeEluZm8gPSBpZmFjZTgwMjF4SW5mby5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICBjb25zdCBzdGF0ZTgwMjF4ID0gYXJyYXlJZmFjZTgwMjF4SW5mby5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmluY2x1ZGVzKCc4MDIuMXgnKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3RhdGU4MDIxeC5pbmNsdWRlcygnRGlzYWJsZWQnKSkge1xuICAgICAgICBpODAyMXguc3RhdGUgPSAnRGlzYWJsZWQnO1xuICAgICAgICBpODAyMXgucHJvdG9jb2wgPSAnTm90IGRlZmluZWQnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZTgwMjF4LmluY2x1ZGVzKCdFbmFibGVkJykpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2w4MDIxeCA9IGFycmF5SWZhY2U4MDIxeEluZm8uZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmluY2x1ZGVzKCdFQVAnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGk4MDIxeC5wcm90b2NvbCA9IHByb3RvY29sODAyMXguc3BsaXQoJzonKS5wb3AoKTtcbiAgICAgICAgaTgwMjF4LnN0YXRlID0gJ0VuYWJsZWQnO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gaTgwMjF4O1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb25uZWN0aW9uVHlwZSA9PSAnd2lyZWxlc3MnKSB7XG5cbiAgICBsZXQgaTgwMjF4U3RhdGUgPSAnJztcbiAgICBsZXQgaTgwMjF4UHJvdG9jb2wgPSAnJztcblxuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgU1NJRCA9IGdldFdpbmRvd3NXaXJlbGVzc0lmYWNlU1NJRChpZmFjZSk7XG4gICAgICBpZiAoU1NJRCAhPT0gJ1Vua25vd24nKSB7XG4gICAgICAgIGk4MDIxeFN0YXRlID0gZXhlY1N5bmMoYG5ldHNoIHdsYW4gc2hvdyBwcm9maWxlcyBcIiR7U1NJRH1cIiB8IGZpbmRzdHIgXCI4MDIuMVhcImAsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgICAgICBpODAyMXhQcm90b2NvbCA9IGV4ZWNTeW5jKGBuZXRzaCB3bGFuIHNob3cgcHJvZmlsZXMgXCIke1NTSUR9XCIgfCBmaW5kc3RyIFwiRUFQXCJgLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGk4MDIxeFN0YXRlLmluY2x1ZGVzKCc6JykgJiYgaTgwMjF4UHJvdG9jb2wuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICBpODAyMXguc3RhdGUgPSBpODAyMXhTdGF0ZS5zcGxpdCgnOicpLnBvcCgpO1xuICAgICAgICBpODAyMXgucHJvdG9jb2wgPSBpODAyMXhQcm90b2NvbC5zcGxpdCgnOicpLnBvcCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSAxICYmIGVycm9yLnN0ZG91dC5pbmNsdWRlcygnQXV0b0NvbmZpZycpKSB7XG4gICAgICAgIGk4MDIxeC5zdGF0ZSA9ICdEaXNhYmxlZCc7XG4gICAgICAgIGk4MDIxeC5wcm90b2NvbCA9ICdOb3QgZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTgwMjF4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpODAyMXg7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2VjdGlvbnNOaWNzKGxpbmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgc2VjdGlvbiA9IFtdO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKCFsaW5lLnN0YXJ0c1dpdGgoJ1xcdCcpICYmICFsaW5lLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgaWYgKHNlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHNlY3Rpb24pO1xuICAgICAgICBzZWN0aW9uID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIHNlY3Rpb24ucHVzaChsaW5lKTtcbiAgfSk7XG4gIGlmIChzZWN0aW9uLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKHNlY3Rpb24pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGluZXNEYXJ3aW5OaWNzKHNlY3Rpb25zKSB7XG4gIGxldCBuaWNzID0gW107XG4gIHNlY3Rpb25zLmZvckVhY2goc2VjdGlvbiA9PiB7XG4gICAgbGV0IG5pYyA9IHtcbiAgICAgIGlmYWNlOiAnJyxcbiAgICAgIG10dTogbnVsbCxcbiAgICAgIG1hYzogJycsXG4gICAgICBpcDY6ICcnLFxuICAgICAgaXA0OiAnJyxcbiAgICAgIHNwZWVkOiBudWxsLFxuICAgICAgdHlwZTogJycsXG4gICAgICBvcGVyc3RhdGU6ICcnLFxuICAgICAgZHVwbGV4OiAnJyxcbiAgICAgIGludGVybmFsOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZmlyc3QgPSBzZWN0aW9uWzBdO1xuICAgIG5pYy5pZmFjZSA9IGZpcnN0LnNwbGl0KCc6JylbMF0udHJpbSgpO1xuICAgIGxldCBwYXJ0cyA9IGZpcnN0LnNwbGl0KCc+IG10dScpO1xuICAgIG5pYy5tdHUgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFyc2VJbnQocGFydHNbMV0sIDEwKSA6IG51bGw7XG4gICAgaWYgKGlzTmFOKG5pYy5tdHUpKSB7XG4gICAgICBuaWMubXR1ID0gbnVsbDtcbiAgICB9XG4gICAgbmljLmludGVybmFsID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdsb29wYmFjaycpID4gLTE7XG4gICAgc2VjdGlvbi5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2V0aGVyICcpKSB7XG4gICAgICAgIG5pYy5tYWMgPSBsaW5lLnNwbGl0KCdldGhlciAnKVsxXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdpbmV0NiAnKSAmJiAhbmljLmlwNikge1xuICAgICAgICBuaWMuaXA2ID0gbGluZS5zcGxpdCgnaW5ldDYgJylbMV0udG9Mb3dlckNhc2UoKS5zcGxpdCgnJScpWzBdLnNwbGl0KCcgJylbMF07XG4gICAgICB9XG4gICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnaW5ldCAnKSAmJiAhbmljLmlwNCkge1xuICAgICAgICBuaWMuaXA0ID0gbGluZS5zcGxpdCgnaW5ldCAnKVsxXS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJylbMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHNwZWVkID0gdXRpbC5nZXRWYWx1ZShzZWN0aW9uLCAnbGluayByYXRlJyk7XG4gICAgbmljLnNwZWVkID0gc3BlZWQgPyBwYXJzZUZsb2F0KHNwZWVkKSA6IG51bGw7XG4gICAgaWYgKG5pYy5zcGVlZCA9PT0gbnVsbCkge1xuICAgICAgc3BlZWQgPSB1dGlsLmdldFZhbHVlKHNlY3Rpb24sICd1cGxpbmsgcmF0ZScpO1xuICAgICAgbmljLnNwZWVkID0gc3BlZWQgPyBwYXJzZUZsb2F0KHNwZWVkKSA6IG51bGw7XG4gICAgICBpZiAobmljLnNwZWVkICE9PSBudWxsICYmIHNwZWVkLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZ2JwcycpID49IDApIHtcbiAgICAgICAgbmljLnNwZWVkID0gbmljLnNwZWVkICogMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNwZWVkLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZ2JwcycpID49IDApIHtcbiAgICAgICAgbmljLnNwZWVkID0gbmljLnNwZWVkICogMTAwMDtcbiAgICAgIH1cbiAgICB9XG4gICAgbmljLnR5cGUgPSB1dGlsLmdldFZhbHVlKHNlY3Rpb24sICd0eXBlJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aS1maScpID4gLTEgPyAnd2lyZWxlc3MnIDogJ3dpcmVkJztcbiAgICBjb25zdCBvcGVyc3RhdGUgPSB1dGlsLmdldFZhbHVlKHNlY3Rpb24sICdzdGF0dXMnKS50b0xvd2VyQ2FzZSgpO1xuICAgIG5pYy5vcGVyc3RhdGUgPSAob3BlcnN0YXRlID09PSAnYWN0aXZlJyA/ICd1cCcgOiAob3BlcnN0YXRlID09PSAnaW5hY3RpdmUnID8gJ2Rvd24nIDogJ3Vua25vd24nKSk7XG4gICAgbmljLmR1cGxleCA9IHV0aWwuZ2V0VmFsdWUoc2VjdGlvbiwgJ21lZGlhJykudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoYWxmLWR1cGxleCcpID4gLTEgPyAnaGFsZicgOiAnZnVsbCc7XG4gICAgaWYgKG5pYy5pcDYgfHwgbmljLmlwNCB8fCBuaWMubWFjKSB7XG4gICAgICBuaWNzLnB1c2gobmljKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmljcztcbn1cblxuZnVuY3Rpb24gZ2V0RGFyd2luTmljcygpIHtcbiAgY29uc3QgY21kID0gJy9zYmluL2lmY29uZmlnIC12JztcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBuc2VjdGlvbnMgPSBzcGxpdFNlY3Rpb25zTmljcyhsaW5lcyk7XG4gICAgcmV0dXJuIChwYXJzZUxpbmVzRGFyd2luTmljcyhuc2VjdGlvbnMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMaW51eElmYWNlQ29ubmVjdGlvbk5hbWUoaW50ZXJmYWNlTmFtZSkge1xuICBjb25zdCBjbWQgPSBgbm1jbGkgZGV2aWNlIHN0YXR1cyAyPi9kZXYvbnVsbCB8IGdyZXAgJHtpbnRlcmZhY2VOYW1lfWA7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcmVzdWx0Rm9ybWF0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgY29uc3QgY29ubmVjdGlvbk5hbWVMaW5lcyA9IHJlc3VsdEZvcm1hdC5zcGxpdCgnICcpLnNsaWNlKDMpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25OYW1lID0gY29ubmVjdGlvbk5hbWVMaW5lcy5qb2luKCcgJyk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25OYW1lICE9ICctLScgPyBjb25uZWN0aW9uTmFtZSA6ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTGludXhEQ0hQSW50ZXJmYWNlcyhmaWxlKSB7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgdHJ5IHtcbiAgICBsZXQgY21kID0gYGNhdCAke2ZpbGV9IDI+IC9kZXYvbnVsbCB8IGdyZXAgJ2lmYWNlXFxcXHxzb3VyY2UnYDtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGluZXQgJykgPj0gMCAmJiBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGhjcCcpID49IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJ0c1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3NvdXJjZScpKSB7XG4gICAgICAgIGxldCBmaWxlID0gbGluZS5zcGxpdCgnICcpWzFdO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGNoZWNrTGludXhEQ0hQSW50ZXJmYWNlcyhmaWxlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRMaW51eERIQ1BOaWNzKCkge1xuICAvLyBhbHRlcm5hdGUgbWV0aG9kcyBnZXR0aW5nIGludGVyZmFjZXMgdXNpbmcgREhDUFxuICBsZXQgY21kID0gJ2lwIGEgMj4gL2Rldi9udWxsJztcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IG5zZWN0aW9ucyA9IHNwbGl0U2VjdGlvbnNOaWNzKGxpbmVzKTtcbiAgICByZXN1bHQgPSAocGFyc2VMaW51eERIQ1BOaWNzKG5zZWN0aW9ucykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBjaGVja0xpbnV4RENIUEludGVyZmFjZXMoJy9ldGMvbmV0d29yay9pbnRlcmZhY2VzJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4REhDUE5pY3Moc2VjdGlvbnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChzZWN0aW9ucyAmJiBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICBzZWN0aW9ucy5mb3JFYWNoKGxpbmVzID0+IHtcbiAgICAgIGlmIChsaW5lcyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMikge1xuICAgICAgICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyBpbmV0ICcpID49IDAgJiYgbGluZS5pbmRleE9mKCcgZHluYW1pYyAnKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzMiA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgY29uc3QgbmljID0gcGFydHMyW3BhcnRzMi5sZW5ndGggLSAxXS50cmltKCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5pYyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4SWZhY2VESENQc3RhdHVzKGlmYWNlLCBjb25uZWN0aW9uTmFtZSwgREhDUE5pY3MpIHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBpZiAoY29ubmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCBjbWQgPSBgbm1jbGkgY29ubmVjdGlvbiBzaG93IFwiJHtjb25uZWN0aW9uTmFtZX1cIiAyPi9kZXYvbnVsbCB8IGdyZXAgaXB2NC5tZXRob2Q7YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZXN1bHRGb3JtYXQgPSBsaW5lcy5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuXG4gICAgICBsZXQgZGhjU3RhdHVzID0gcmVzdWx0Rm9ybWF0LnNwbGl0KCcgJykuc2xpY2UoMSkudG9TdHJpbmcoKTtcbiAgICAgIHN3aXRjaCAoZGhjU3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIChESENQTmljcy5pbmRleE9mKGlmYWNlKSA+PSAwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChESENQTmljcy5pbmRleE9mKGlmYWNlKSA+PSAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXJ3aW5JZmFjZURIQ1BzdGF0dXMoaWZhY2UpIHtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICBjb25zdCBjbWQgPSBgaXBjb25maWcgZ2V0cGFja2V0IFwiJHtpZmFjZX1cIiAyPi9kZXYvbnVsbCB8IGdyZXAgbGVhc2VfdGltZTtgO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBpZiAobGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLnN0YXJ0c1dpdGgoJ2xlYXNlX3RpbWUnKSkge1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRMaW51eElmYWNlRE5Tc3VmZml4KGNvbm5lY3Rpb25OYW1lKSB7XG4gIGlmIChjb25uZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IGNtZCA9IGBubWNsaSBjb25uZWN0aW9uIHNob3cgXCIke2Nvbm5lY3Rpb25OYW1lfVwiIDI+L2Rldi9udWxsIHwgZ3JlcCBpcHY0LmRucy1zZWFyY2g7YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVzdWx0Rm9ybWF0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICBjb25zdCBkbnNTdWZmaXggPSByZXN1bHRGb3JtYXQuc3BsaXQoJyAnKS5zbGljZSgxKS50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGRuc1N1ZmZpeCA9PSAnLS0nID8gJ05vdCBkZWZpbmVkJyA6IGRuc1N1ZmZpeDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4SWZhY2VJRUVFODAyMXhBdXRoKGNvbm5lY3Rpb25OYW1lKSB7XG4gIGlmIChjb25uZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IGNtZCA9IGBubWNsaSBjb25uZWN0aW9uIHNob3cgXCIke2Nvbm5lY3Rpb25OYW1lfVwiIDI+L2Rldi9udWxsIHwgZ3JlcCA4MDItMXguZWFwO2A7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHJlc3VsdEZvcm1hdCA9IHJlc3VsdC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgY29uc3QgYXV0aGVudGljYXRpb25Qcm90b2NvbCA9IHJlc3VsdEZvcm1hdC5zcGxpdCgnICcpLnNsaWNlKDEpLnRvU3RyaW5nKCk7XG5cblxuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW9uUHJvdG9jb2wgPT0gJy0tJyA/ICcnIDogYXV0aGVudGljYXRpb25Qcm90b2NvbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gJ05vdCBkZWZpbmVkJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdOb3QgZGVmaW5lZCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGludXhJZmFjZUlFRUU4MDIxeFN0YXRlKGF1dGhlbnRpY2F0aW9uUHJvdG9jb2wpIHtcbiAgaWYgKGF1dGhlbnRpY2F0aW9uUHJvdG9jb2wpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpb25Qcm90b2NvbCA9PSAnTm90IGRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gJ0Rpc2FibGVkJztcbiAgICB9XG4gICAgcmV0dXJuICdFbmFibGVkJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RWaXJ0dWFsTmljKGlmYWNlLCBpZmFjZU5hbWUsIG1hYykge1xuICBjb25zdCB2aXJ0dWFsTWFjcyA9IFsnMDA6MDA6MDA6MDA6MDA6MDAnLCAnMDA6MDM6RkYnLCAnMDA6MDU6NjknLCAnMDA6MEM6MjknLCAnMDA6MEY6NEInLCAnMDA6MEY6NEInLCAnMDA6MTM6MDcnLCAnMDA6MTM6QkUnLCAnMDA6MTU6NWQnLCAnMDA6MTY6M0UnLCAnMDA6MUM6NDInLCAnMDA6MjE6RjYnLCAnMDA6MjE6RjYnLCAnMDA6MjQ6MEInLCAnMDA6MjQ6MEInLCAnMDA6NTA6NTYnLCAnMDA6QTA6QjEnLCAnMDA6RTA6QzgnLCAnMDg6MDA6MjcnLCAnMEE6MDA6MjcnLCAnMTg6OTI6MkMnLCAnMTY6REY6NDknLCAnM0M6RjM6OTInLCAnNTQ6NTI6MDAnLCAnRkM6MTU6OTcnXTtcbiAgaWYgKG1hYykge1xuICAgIHJldHVybiB2aXJ0dWFsTWFjcy5maWx0ZXIoaXRlbSA9PiB7IHJldHVybiBtYWMudG9VcHBlckNhc2UoKS50b1VwcGVyQ2FzZSgpLnN0YXJ0c1dpdGgoaXRlbS5zdWJzdHIoMCwgbWFjLmxlbmd0aCkpOyB9KS5sZW5ndGggPiAwIHx8XG4gICAgICBpZmFjZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyB2aXJ0dWFsICcpID4gLTEgfHxcbiAgICAgIGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyB2aXJ0dWFsICcpID4gLTEgfHxcbiAgICAgIGlmYWNlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndmV0aGVybmV0ICcpID4gLTEgfHxcbiAgICAgIGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3ZldGhlcm5ldCAnKSA+IC0xIHx8XG4gICAgICBpZmFjZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3ZldGgnKSB8fFxuICAgICAgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndmV0aCcpIHx8XG4gICAgICBpZmFjZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Zib3huZXQnKSB8fFxuICAgICAgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndmJveG5ldCcpO1xuICB9IGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuZnVuY3Rpb24gbmV0d29ya0ludGVyZmFjZXMoY2FsbGJhY2ssIHJlc2NhbiwgZGVmYXVsdFN0cmluZykge1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgZGVmYXVsdFN0cmluZyA9IGNhbGxiYWNrO1xuICAgIHJlc2NhbiA9IHRydWU7XG4gICAgY2FsbGJhY2sgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmVzY2FuID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBudWxsO1xuICAgIGRlZmF1bHRTdHJpbmcgPSAnJztcbiAgfVxuICBpZiAodHlwZW9mIHJlc2NhbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXNjYW4gPSB0cnVlO1xuICB9XG4gIGRlZmF1bHRTdHJpbmcgPSBkZWZhdWx0U3RyaW5nIHx8ICcnO1xuICBkZWZhdWx0U3RyaW5nID0gJycgKyBkZWZhdWx0U3RyaW5nO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgaWZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcblxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IG5pY3MgPSBbXTtcbiAgICAgIGxldCBkbnNTdWZmaXhlcyA9IFtdO1xuICAgICAgbGV0IG5pY3M4MDIxeEluZm8gPSBbXTtcbiAgICAgIC8vIHNlcGVyYXRlIGhhbmRsaW5nIGluIE9TWFxuICAgICAgaWYgKF9kYXJ3aW4gfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBpZiAoKEpTT04uc3RyaW5naWZ5KGlmYWNlcykgPT09IEpTT04uc3RyaW5naWZ5KF9pZmFjZXMpKSAmJiAhcmVzY2FuKSB7XG4gICAgICAgICAgLy8gbm8gY2hhbmdlcyAtIGp1c3QgcmV0dXJuIG9iamVjdFxuICAgICAgICAgIHJlc3VsdCA9IF9uZXR3b3JrSW50ZXJmYWNlcztcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRJbnRlcmZhY2UgPSBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuICAgICAgICAgIF9pZmFjZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlmYWNlcykpO1xuXG4gICAgICAgICAgbmljcyA9IGdldERhcndpbk5pY3MoKTtcblxuXG4gICAgICAgICAgbmljcy5mb3JFYWNoKG5pYyA9PiB7XG5cbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgbmljLmlmYWNlKSkge1xuICAgICAgICAgICAgICBpZmFjZXNbbmljLmlmYWNlXS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NCcgfHwgZGV0YWlscy5mYW1pbHkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgIG5pYy5pcDRzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjYnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICBuaWMuaXA2c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpZmFjZVNhbml0aXplZCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgcyA9IHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJy0tLScgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcobmljLmlmYWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWZhY2VTYW5pdGl6ZWQgPSBpZmFjZVNhbml0aXplZCArIHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBpZmFjZTogbmljLmlmYWNlLFxuICAgICAgICAgICAgICBpZmFjZU5hbWU6IG5pYy5pZmFjZSxcbiAgICAgICAgICAgICAgZGVmYXVsdDogbmljLmlmYWNlID09PSBkZWZhdWx0SW50ZXJmYWNlLFxuICAgICAgICAgICAgICBpcDQ6IG5pYy5pcDQsXG4gICAgICAgICAgICAgIGlwNHN1Ym5ldDogbmljLmlwNHN1Ym5ldCB8fCAnJyxcbiAgICAgICAgICAgICAgaXA2OiBuaWMuaXA2LFxuICAgICAgICAgICAgICBpcDZzdWJuZXQ6IG5pYy5pcDZzdWJuZXQgfHwgJycsXG4gICAgICAgICAgICAgIG1hYzogbmljLm1hYyxcbiAgICAgICAgICAgICAgaW50ZXJuYWw6IG5pYy5pbnRlcm5hbCxcbiAgICAgICAgICAgICAgdmlydHVhbDogbmljLmludGVybmFsID8gZmFsc2UgOiB0ZXN0VmlydHVhbE5pYyhuaWMuaWZhY2UsIG5pYy5pZmFjZSwgbmljLm1hYyksXG4gICAgICAgICAgICAgIG9wZXJzdGF0ZTogbmljLm9wZXJzdGF0ZSxcbiAgICAgICAgICAgICAgdHlwZTogbmljLnR5cGUsXG4gICAgICAgICAgICAgIGR1cGxleDogbmljLmR1cGxleCxcbiAgICAgICAgICAgICAgbXR1OiBuaWMubXR1LFxuICAgICAgICAgICAgICBzcGVlZDogbmljLnNwZWVkLFxuICAgICAgICAgICAgICBkaGNwOiBnZXREYXJ3aW5JZmFjZURIQ1BzdGF0dXMoaWZhY2VTYW5pdGl6ZWQpLFxuICAgICAgICAgICAgICBkbnNTdWZmaXg6ICcnLFxuICAgICAgICAgICAgICBpZWVlODAyMXhBdXRoOiAnJyxcbiAgICAgICAgICAgICAgaWVlZTgwMjF4U3RhdGU6ICcnLFxuICAgICAgICAgICAgICBjYXJyaWVyQ2hhbmdlczogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX25ldHdvcmtJbnRlcmZhY2VzID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChkZWZhdWx0U3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGVmYXVsdCcpID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBpZiAoKEpTT04uc3RyaW5naWZ5KGlmYWNlcykgPT09IEpTT04uc3RyaW5naWZ5KF9pZmFjZXMpKSAmJiAhcmVzY2FuKSB7XG4gICAgICAgICAgLy8gbm8gY2hhbmdlcyAtIGp1c3QgcmV0dXJuIG9iamVjdFxuICAgICAgICAgIHJlc3VsdCA9IF9uZXR3b3JrSW50ZXJmYWNlcztcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pZmFjZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlmYWNlcykpO1xuICAgICAgICAgIF9kaGNwTmljcyA9IGdldExpbnV4REhDUE5pY3MoKTtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0SW50ZXJmYWNlID0gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcbiAgICAgICAgICBmb3IgKGxldCBkZXYgaW4gaWZhY2VzKSB7XG4gICAgICAgICAgICBsZXQgaXA0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaXA0c3VibmV0ID0gJyc7XG4gICAgICAgICAgICBsZXQgaXA2ID0gJyc7XG4gICAgICAgICAgICBsZXQgaXA2c3VibmV0ID0gJyc7XG4gICAgICAgICAgICBsZXQgbWFjID0gJyc7XG4gICAgICAgICAgICBsZXQgZHVwbGV4ID0gJyc7XG4gICAgICAgICAgICBsZXQgbXR1ID0gJyc7XG4gICAgICAgICAgICBsZXQgc3BlZWQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNhcnJpZXJDaGFuZ2VzID0gMDtcbiAgICAgICAgICAgIGxldCBkaGNwID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZG5zU3VmZml4ID0gJyc7XG4gICAgICAgICAgICBsZXQgaWVlZTgwMjF4QXV0aCA9ICcnO1xuICAgICAgICAgICAgbGV0IGllZWU4MDIxeFN0YXRlID0gJyc7XG4gICAgICAgICAgICBsZXQgdHlwZSA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIGRldikpIHtcbiAgICAgICAgICAgICAgbGV0IGlmYWNlTmFtZSA9IGRldjtcbiAgICAgICAgICAgICAgaWZhY2VzW2Rldl0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjQnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICBpcDQgPSBkZXRhaWxzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICBpcDRzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjYnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlwNiB8fCBpcDYubWF0Y2goL15mZTgwOjovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXA2ID0gZGV0YWlscy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBpcDZzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hYyA9IGRldGFpbHMubWFjO1xuICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzEzNTgxIChub2RlIDguMSAtIG5vZGUgOC4yKVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVNYWluVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hYy5pbmRleE9mKCcwMDowMDowJykgPiAtMSAmJiAoX2xpbnV4IHx8IF9kYXJ3aW4pICYmICghZGV0YWlscy5pbnRlcm5hbCkgJiYgbm9kZU1haW5WZXJzaW9uID49IDggJiYgbm9kZU1haW5WZXJzaW9uIDw9IDExKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoX21hYykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9tYWMgPSBnZXRNYWNBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG1hYyA9IF9tYWNbZGV2XSB8fCAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsZXQgaWZhY2UgPSBkZXYuc3BsaXQoJzonKVswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgbGV0IGlmYWNlU2FuaXRpemVkID0gJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHMgPSB1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICctLS0nIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGlmYWNlKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWZhY2VTYW5pdGl6ZWQgPSBpZmFjZVNhbml0aXplZCArIHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwiYWRkcl9hc3NpZ25fdHlwZTogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9hZGRyX2Fzc2lnbl90eXBlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImFkZHJlc3M6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vYWRkcmVzcyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJhZGRyX2xlbjogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9hZGRyX2xlbiAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJicm9hZGNhc3Q6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vYnJvYWRjYXN0IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNhcnJpZXI6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vY2FycmllciAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjYXJyaWVyX2NoYW5nZXM6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vY2Fycmllcl9jaGFuZ2VzIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImRldl9pZDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9kZXZfaWQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZGV2X3BvcnQ6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZGV2X3BvcnQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZG9ybWFudDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9kb3JtYW50IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImR1cGxleDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9kdXBsZXggMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZmxhZ3M6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZmxhZ3MgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiZ3JvX2ZsdXNoX3RpbWVvdXQ6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZ3JvX2ZsdXNoX3RpbWVvdXQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiaWZhbGlhczogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9pZmFsaWFzIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImlmaW5kZXg6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vaWZpbmRleCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJpZmxpbms6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vaWZsaW5rIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImxpbmtfbW9kZTogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9saW5rX21vZGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwibXR1OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L210dSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJuZXRkZXZfZ3JvdXA6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vbmV0ZGV2X2dyb3VwIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcIm9wZXJzdGF0ZTogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9vcGVyc3RhdGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwicHJvdG9fZG93bjogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9wcm90b19kb3duIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInNwZWVkOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L3NwZWVkIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInR4X3F1ZXVlX2xlbjogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS90eF9xdWV1ZV9sZW4gMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwidHlwZTogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS90eXBlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcIndpcmVsZXNzOiBcIjsgY2F0IC9wcm9jL25ldC93aXJlbGVzcyAyPi9kZXYvbnVsbCB8IGdyZXAgJHtpZmFjZVNhbml0aXplZH07IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwid2lyZWxlc3NzcGVlZDogXCI7IGl3IGRldiAke2lmYWNlU2FuaXRpemVkfSBsaW5rIDI+JjEgfCBncmVwIGJpdHJhdGU7IGVjaG87YDtcblxuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbk5hbWUgPSBnZXRMaW51eElmYWNlQ29ubmVjdGlvbk5hbWUoaWZhY2VTYW5pdGl6ZWQpO1xuICAgICAgICAgICAgICAgIGRoY3AgPSBnZXRMaW51eElmYWNlREhDUHN0YXR1cyhpZmFjZVNhbml0aXplZCwgY29ubmVjdGlvbk5hbWUsIF9kaGNwTmljcyk7XG4gICAgICAgICAgICAgICAgZG5zU3VmZml4ID0gZ2V0TGludXhJZmFjZUROU3N1ZmZpeChjb25uZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4QXV0aCA9IGdldExpbnV4SWZhY2VJRUVFODAyMXhBdXRoKGNvbm5lY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhTdGF0ZSA9IGdldExpbnV4SWZhY2VJRUVFODAyMXhTdGF0ZShpZWVlODAyMXhBdXRoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGR1cGxleCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkdXBsZXgnKTtcbiAgICAgICAgICAgICAgZHVwbGV4ID0gZHVwbGV4LnN0YXJ0c1dpdGgoJ2NhdCcpID8gJycgOiBkdXBsZXg7XG4gICAgICAgICAgICAgIG10dSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtdHUnKSwgMTApO1xuICAgICAgICAgICAgICBsZXQgbXlzcGVlZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzcGVlZCcpLCAxMCk7XG4gICAgICAgICAgICAgIHNwZWVkID0gaXNOYU4obXlzcGVlZCkgPyBudWxsIDogbXlzcGVlZDtcbiAgICAgICAgICAgICAgbGV0IHdpcmVsZXNzc3BlZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnd2lyZWxlc3NzcGVlZCcpLnNwbGl0KCd0eCBiaXRyYXRlOiAnKTtcbiAgICAgICAgICAgICAgaWYgKHNwZWVkID09PSBudWxsICYmIHdpcmVsZXNzc3BlZWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgbXlzcGVlZCA9IHBhcnNlRmxvYXQod2lyZWxlc3NzcGVlZFsxXSk7XG4gICAgICAgICAgICAgICAgc3BlZWQgPSBpc05hTihteXNwZWVkKSA/IG51bGwgOiBteXNwZWVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhcnJpZXJDaGFuZ2VzID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcnJpZXJfY2hhbmdlcycpLCAxMCk7XG4gICAgICAgICAgICAgIGNvbnN0IG9wZXJzdGF0ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdvcGVyc3RhdGUnKTtcbiAgICAgICAgICAgICAgdHlwZSA9IG9wZXJzdGF0ZSA9PT0gJ3VwJyA/ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnd2lyZWxlc3MnKS50cmltKCkgPyAnd2lyZWxlc3MnIDogJ3dpcmVkJykgOiAndW5rbm93bic7XG4gICAgICAgICAgICAgIGlmIChpZmFjZVNhbml0aXplZCA9PT0gJ2xvJyB8fCBpZmFjZVNhbml0aXplZC5zdGFydHNXaXRoKCdib25kJykpIHsgdHlwZSA9ICd2aXJ0dWFsJzsgfVxuXG4gICAgICAgICAgICAgIGxldCBpbnRlcm5hbCA9IChpZmFjZXNbZGV2XSAmJiBpZmFjZXNbZGV2XVswXSkgPyBpZmFjZXNbZGV2XVswXS5pbnRlcm5hbCA6IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZGV2LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbG9vcGJhY2snKSA+IC0xIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2xvb3BiYWNrJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsID0gaW50ZXJuYWwgPyBmYWxzZSA6IHRlc3RWaXJ0dWFsTmljKGRldiwgaWZhY2VOYW1lLCBtYWMpO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgaWZhY2U6IGlmYWNlU2FuaXRpemVkLFxuICAgICAgICAgICAgICAgIGlmYWNlTmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBpZmFjZSA9PT0gZGVmYXVsdEludGVyZmFjZSxcbiAgICAgICAgICAgICAgICBpcDQsXG4gICAgICAgICAgICAgICAgaXA0c3VibmV0LFxuICAgICAgICAgICAgICAgIGlwNixcbiAgICAgICAgICAgICAgICBpcDZzdWJuZXQsXG4gICAgICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgICAgIGludGVybmFsLFxuICAgICAgICAgICAgICAgIHZpcnR1YWwsXG4gICAgICAgICAgICAgICAgb3BlcnN0YXRlLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZHVwbGV4LFxuICAgICAgICAgICAgICAgIG10dSxcbiAgICAgICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgICAgICBkaGNwLFxuICAgICAgICAgICAgICAgIGRuc1N1ZmZpeCxcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhBdXRoLFxuICAgICAgICAgICAgICAgIGllZWU4MDIxeFN0YXRlLFxuICAgICAgICAgICAgICAgIGNhcnJpZXJDaGFuZ2VzLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX25ldHdvcmtJbnRlcmZhY2VzID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChkZWZhdWx0U3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGVmYXVsdCcpID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoaXRlbSA9PiBpdGVtLmRlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGlmICgoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSA9PT0gSlNPTi5zdHJpbmdpZnkoX2lmYWNlcykpICYmICFyZXNjYW4pIHtcbiAgICAgICAgICAvLyBubyBjaGFuZ2VzIC0ganVzdCByZXR1cm4gb2JqZWN0XG4gICAgICAgICAgcmVzdWx0ID0gX25ldHdvcmtJbnRlcmZhY2VzO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lmYWNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWZhY2VzKSk7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEludGVyZmFjZSA9IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG5cbiAgICAgICAgICBnZXRXaW5kb3dzTmljcygpLnRoZW4oZnVuY3Rpb24gKG5pY3MpIHtcbiAgICAgICAgICAgIG5pY3MuZm9yRWFjaChuaWMgPT4ge1xuICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaWZhY2VzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgaWZhY2VzW2tleV0uZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkuaW5kZXhPZignbWFjJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWVbJ21hYyddID09PSBuaWMubWFjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZmFjZXNbbmljLm5hbWVdID0gW3sgbWFjOiBuaWMubWFjIH1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5pY3M4MDIxeEluZm8gPSBnZXRXaW5kb3dzV2lyZWRQcm9maWxlc0luZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBkbnNTdWZmaXhlcyA9IGdldFdpbmRvd3NETlNzdWZmaXhlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGV2IGluIGlmYWNlcykge1xuXG4gICAgICAgICAgICAgIGxldCBpZmFjZVNhbml0aXplZCA9ICcnO1xuICAgICAgICAgICAgICBjb25zdCBzID0gdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnLS0tJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhkZXYpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZmFjZVNhbml0aXplZCA9IGlmYWNlU2FuaXRpemVkICsgc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgaWZhY2UgPSBkZXY7XG4gICAgICAgICAgICAgIGxldCBpcDQgPSAnJztcbiAgICAgICAgICAgICAgbGV0IGlwNHN1Ym5ldCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgaXA2ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBpcDZzdWJuZXQgPSAnJztcbiAgICAgICAgICAgICAgbGV0IG1hYyA9ICcnO1xuICAgICAgICAgICAgICBsZXQgZHVwbGV4ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBtdHUgPSAnJztcbiAgICAgICAgICAgICAgbGV0IHNwZWVkID0gbnVsbDtcbiAgICAgICAgICAgICAgbGV0IGNhcnJpZXJDaGFuZ2VzID0gMDtcbiAgICAgICAgICAgICAgbGV0IG9wZXJzdGF0ZSA9ICdkb3duJztcbiAgICAgICAgICAgICAgbGV0IGRoY3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IGRuc1N1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgaWVlZTgwMjF4QXV0aCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgaWVlZTgwMjF4U3RhdGUgPSAnJztcbiAgICAgICAgICAgICAgbGV0IHR5cGUgPSAnJztcblxuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIGRldikpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWZhY2VOYW1lID0gZGV2O1xuICAgICAgICAgICAgICAgIGlmYWNlc1tkZXZdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjQnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlwNCA9IGRldGFpbHMuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgaXA0c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbHMuZmFtaWx5ID09PSAnSVB2NicgfHwgZGV0YWlscy5mYW1pbHkgPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpcDYgfHwgaXA2Lm1hdGNoKC9eZmU4MDo6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXA2ID0gZGV0YWlscy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgIGlwNnN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbWFjID0gZGV0YWlscy5tYWM7XG4gICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8xMzU4MSAobm9kZSA4LjEgLSBub2RlIDguMilcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVNYWluVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAobWFjLmluZGV4T2YoJzAwOjAwOjAnKSA+IC0xICYmIChfbGludXggfHwgX2RhcndpbikgJiYgKCFkZXRhaWxzLmludGVybmFsKSAmJiBub2RlTWFpblZlcnNpb24gPj0gOCAmJiBub2RlTWFpblZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKF9tYWMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIF9tYWMgPSBnZXRNYWNBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYWMgPSBfbWFjW2Rldl0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuXG4gICAgICAgICAgICAgICAgZG5zU3VmZml4ID0gZ2V0V2luZG93c0lmYWNlRE5Tc3VmZml4KGRuc1N1ZmZpeGVzLmlmYWNlcywgaWZhY2VTYW5pdGl6ZWQpO1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZEZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmljcy5mb3JFYWNoKGRldGFpbCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLm1hYyA9PT0gbWFjICYmICFmb3VuZEZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmYWNlID0gZGV0YWlsLmlmYWNlIHx8IGlmYWNlO1xuICAgICAgICAgICAgICAgICAgICBpZmFjZU5hbWUgPSBkZXRhaWwubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZGhjcCA9IGRldGFpbC5kaGNwO1xuICAgICAgICAgICAgICAgICAgICBvcGVyc3RhdGUgPSBkZXRhaWwub3BlcnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IGRldGFpbC5zcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRldGFpbC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChkZXYudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3bGFuJykgPj0gMCB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3bGFuJykgPj0gMCB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCc4MDIuMTFuJykgPj0gMCB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aXJlbGVzcycpID49IDAgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2ktZmknKSA+PSAwIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpZmknKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0eXBlID0gJ3dpcmVsZXNzJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBJRUVFODAyMXggPSBnZXRXaW5kb3dzSUVFRTgwMjF4KHR5cGUsIGlmYWNlU2FuaXRpemVkLCBuaWNzODAyMXhJbmZvKTtcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhBdXRoID0gSUVFRTgwMjF4LnByb3RvY29sO1xuICAgICAgICAgICAgICAgIGllZWU4MDIxeFN0YXRlID0gSUVFRTgwMjF4LnN0YXRlO1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcm5hbCA9IChpZmFjZXNbZGV2XSAmJiBpZmFjZXNbZGV2XVswXSkgPyBpZmFjZXNbZGV2XVswXS5pbnRlcm5hbCA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChkZXYudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdsb29wYmFjaycpID4gLTEgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbG9vcGJhY2snKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWwgPSBpbnRlcm5hbCA/IGZhbHNlIDogdGVzdFZpcnR1YWxOaWMoZGV2LCBpZmFjZU5hbWUsIG1hYyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICBpZmFjZU5hbWUsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBpZmFjZSA9PT0gZGVmYXVsdEludGVyZmFjZSxcbiAgICAgICAgICAgICAgICAgIGlwNCxcbiAgICAgICAgICAgICAgICAgIGlwNHN1Ym5ldCxcbiAgICAgICAgICAgICAgICAgIGlwNixcbiAgICAgICAgICAgICAgICAgIGlwNnN1Ym5ldCxcbiAgICAgICAgICAgICAgICAgIG1hYyxcbiAgICAgICAgICAgICAgICAgIGludGVybmFsLFxuICAgICAgICAgICAgICAgICAgdmlydHVhbCxcbiAgICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSxcbiAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICBkdXBsZXgsXG4gICAgICAgICAgICAgICAgICBtdHUsXG4gICAgICAgICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgICAgICAgIGRoY3AsXG4gICAgICAgICAgICAgICAgICBkbnNTdWZmaXgsXG4gICAgICAgICAgICAgICAgICBpZWVlODAyMXhBdXRoLFxuICAgICAgICAgICAgICAgICAgaWVlZTgwMjF4U3RhdGUsXG4gICAgICAgICAgICAgICAgICBjYXJyaWVyQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX25ldHdvcmtJbnRlcmZhY2VzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRTdHJpbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdkZWZhdWx0JykgPj0gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZWZhdWx0KTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzID0gbmV0d29ya0ludGVyZmFjZXM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBORVQgLSBTcGVlZFxuXG5mdW5jdGlvbiBjYWxjTmV0d29ya1NwZWVkKGlmYWNlLCByeF9ieXRlcywgdHhfYnl0ZXMsIG9wZXJzdGF0ZSwgcnhfZHJvcHBlZCwgcnhfZXJyb3JzLCB0eF9kcm9wcGVkLCB0eF9lcnJvcnMpIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICBpZmFjZSxcbiAgICBvcGVyc3RhdGUsXG4gICAgcnhfYnl0ZXMsXG4gICAgcnhfZHJvcHBlZCxcbiAgICByeF9lcnJvcnMsXG4gICAgdHhfYnl0ZXMsXG4gICAgdHhfZHJvcHBlZCxcbiAgICB0eF9lcnJvcnMsXG4gICAgcnhfc2VjOiBudWxsLFxuICAgIHR4X3NlYzogbnVsbCxcbiAgICBtczogMFxuICB9O1xuXG4gIGlmIChfbmV0d29ya1tpZmFjZV0gJiYgX25ldHdvcmtbaWZhY2VdLm1zKSB7XG4gICAgcmVzdWx0Lm1zID0gRGF0ZS5ub3coKSAtIF9uZXR3b3JrW2lmYWNlXS5tcztcbiAgICByZXN1bHQucnhfc2VjID0gKHJ4X2J5dGVzIC0gX25ldHdvcmtbaWZhY2VdLnJ4X2J5dGVzKSA+PSAwID8gKHJ4X2J5dGVzIC0gX25ldHdvcmtbaWZhY2VdLnJ4X2J5dGVzKSAvIChyZXN1bHQubXMgLyAxMDAwKSA6IDA7XG4gICAgcmVzdWx0LnR4X3NlYyA9ICh0eF9ieXRlcyAtIF9uZXR3b3JrW2lmYWNlXS50eF9ieXRlcykgPj0gMCA/ICh0eF9ieXRlcyAtIF9uZXR3b3JrW2lmYWNlXS50eF9ieXRlcykgLyAocmVzdWx0Lm1zIC8gMTAwMCkgOiAwO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5yeF9ieXRlcyA9IHJ4X2J5dGVzO1xuICAgIF9uZXR3b3JrW2lmYWNlXS50eF9ieXRlcyA9IHR4X2J5dGVzO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5yeF9zZWMgPSByZXN1bHQucnhfc2VjO1xuICAgIF9uZXR3b3JrW2lmYWNlXS50eF9zZWMgPSByZXN1bHQudHhfc2VjO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5tcyA9IERhdGUubm93KCk7XG4gICAgX25ldHdvcmtbaWZhY2VdLmxhc3RfbXMgPSByZXN1bHQubXM7XG4gICAgX25ldHdvcmtbaWZhY2VdLm9wZXJzdGF0ZSA9IG9wZXJzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIV9uZXR3b3JrW2lmYWNlXSkgeyBfbmV0d29ya1tpZmFjZV0gPSB7fTsgfVxuICAgIF9uZXR3b3JrW2lmYWNlXS5yeF9ieXRlcyA9IHJ4X2J5dGVzO1xuICAgIF9uZXR3b3JrW2lmYWNlXS50eF9ieXRlcyA9IHR4X2J5dGVzO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5yeF9zZWMgPSBudWxsO1xuICAgIF9uZXR3b3JrW2lmYWNlXS50eF9zZWMgPSBudWxsO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5tcyA9IERhdGUubm93KCk7XG4gICAgX25ldHdvcmtbaWZhY2VdLmxhc3RfbXMgPSAwO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5vcGVyc3RhdGUgPSBvcGVyc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbmV0d29ya1N0YXRzKGlmYWNlcywgY2FsbGJhY2spIHtcblxuICBsZXQgaWZhY2VzQXJyYXkgPSBbXTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKGlmYWNlcykgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gaWZhY2VzO1xuICAgICAgICBpZmFjZXNBcnJheSA9IFtnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZhY2VzICE9PSAnc3RyaW5nJyAmJiBpZmFjZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhbXSk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWZhY2VzID0gaWZhY2VzIHx8IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG5cbiAgICAgICAgaWZhY2VzLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgaWZhY2VzLl9fcHJvdG9fXy5yZXBsYWNlID0gdXRpbC5zdHJpbmdSZXBsYWNlO1xuICAgICAgICBpZmFjZXMuX19wcm90b19fLnRyaW0gPSB1dGlsLnN0cmluZ1RyaW07XG5cbiAgICAgICAgaWZhY2VzID0gaWZhY2VzLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLywrL2csICd8Jyk7XG4gICAgICAgIGlmYWNlc0FycmF5ID0gaWZhY2VzLnNwbGl0KCd8Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgaWYgKGlmYWNlc0FycmF5Lmxlbmd0aCAmJiBpZmFjZXNBcnJheVswXS50cmltKCkgPT09ICcqJykge1xuICAgICAgICBpZmFjZXNBcnJheSA9IFtdO1xuICAgICAgICBuZXR3b3JrSW50ZXJmYWNlcyhmYWxzZSkudGhlbihhbGxJRmFjZXMgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGlmYWNlIG9mIGFsbElGYWNlcykge1xuICAgICAgICAgICAgaWZhY2VzQXJyYXkucHVzaChpZmFjZS5pZmFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5ldHdvcmtTdGF0cyhpZmFjZXNBcnJheS5qb2luKCcsJykpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaWZhY2Ugb2YgaWZhY2VzQXJyYXkpIHtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKG5ldHdvcmtTdGF0c1NpbmdsZShpZmFjZS50cmltKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya2xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrU3RhdHNTaW5nbGUoaWZhY2UpIHtcblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzV2luZG93c1BlcmZEYXRhKHNlY3Rpb25zKSB7XG4gICAgbGV0IHBlcmZEYXRhID0gW107XG4gICAgZm9yIChsZXQgaSBpbiBzZWN0aW9ucykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoc2VjdGlvbnMsIGkpKSB7XG4gICAgICAgIGlmIChzZWN0aW9uc1tpXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc2VjdGlvbnNbaV0udHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICBwZXJmRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOYW1lJywgJzonKS5yZXBsYWNlKC9bKClbXFxdIF0rL2csICcnKS5yZXBsYWNlKC8jfFxcLy9nLCAnXycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICByeF9ieXRlczogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J5dGVzUmVjZWl2ZWRQZXJzZWMnLCAnOicpLCAxMCksXG4gICAgICAgICAgICByeF9lcnJvcnM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWNrZXRzUmVjZWl2ZWRFcnJvcnMnLCAnOicpLCAxMCksXG4gICAgICAgICAgICByeF9kcm9wcGVkOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFja2V0c1JlY2VpdmVkRGlzY2FyZGVkJywgJzonKSwgMTApLFxuICAgICAgICAgICAgdHhfYnl0ZXM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdCeXRlc1NlbnRQZXJzZWMnLCAnOicpLCAxMCksXG4gICAgICAgICAgICB0eF9lcnJvcnM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWNrZXRzT3V0Ym91bmRFcnJvcnMnLCAnOicpLCAxMCksXG4gICAgICAgICAgICB0eF9kcm9wcGVkOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFja2V0c091dGJvdW5kRGlzY2FyZGVkJywgJzonKSwgMTApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlcmZEYXRhO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgaWZhY2VTYW5pdGl6ZWQgPSAnJztcbiAgICAgIGNvbnN0IHMgPSB1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICctLS0nIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGlmYWNlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWZhY2VTYW5pdGl6ZWQgPSBpZmFjZVNhbml0aXplZCArIHNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaWZhY2U6IGlmYWNlU2FuaXRpemVkLFxuICAgICAgICBvcGVyc3RhdGU6ICd1bmtub3duJyxcbiAgICAgICAgcnhfYnl0ZXM6IDAsXG4gICAgICAgIHJ4X2Ryb3BwZWQ6IDAsXG4gICAgICAgIHJ4X2Vycm9yczogMCxcbiAgICAgICAgdHhfYnl0ZXM6IDAsXG4gICAgICAgIHR4X2Ryb3BwZWQ6IDAsXG4gICAgICAgIHR4X2Vycm9yczogMCxcbiAgICAgICAgcnhfc2VjOiBudWxsLFxuICAgICAgICB0eF9zZWM6IG51bGwsXG4gICAgICAgIG1zOiAwXG4gICAgICB9O1xuXG4gICAgICBsZXQgb3BlcnN0YXRlID0gJ3Vua25vd24nO1xuICAgICAgbGV0IHJ4X2J5dGVzID0gMDtcbiAgICAgIGxldCB0eF9ieXRlcyA9IDA7XG4gICAgICBsZXQgcnhfZHJvcHBlZCA9IDA7XG4gICAgICBsZXQgcnhfZXJyb3JzID0gMDtcbiAgICAgIGxldCB0eF9kcm9wcGVkID0gMDtcbiAgICAgIGxldCB0eF9lcnJvcnMgPSAwO1xuXG4gICAgICBsZXQgY21kLCBsaW5lcywgc3RhdHM7XG4gICAgICBpZiAoIV9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXSB8fCAoX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdICYmICFfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ubXMpIHx8IChfbmV0d29ya1tpZmFjZVNhbml0aXplZF0gJiYgX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLm1zICYmIERhdGUubm93KCkgLSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ubXMgPj0gNTAwKSkge1xuICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoJy9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCkpIHtcbiAgICAgICAgICAgIGNtZCA9XG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9vcGVyc3RhdGU7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy9yeF9ieXRlczsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3R4X2J5dGVzOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvcnhfZHJvcHBlZDsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3J4X2Vycm9yczsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3R4X2Ryb3BwZWQ7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy90eF9lcnJvcnM7ICc7XG4gICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSA9IGxpbmVzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByeF9ieXRlcyA9IHBhcnNlSW50KGxpbmVzWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgdHhfYnl0ZXMgPSBwYXJzZUludChsaW5lc1syXSwgMTApO1xuICAgICAgICAgICAgICAgIHJ4X2Ryb3BwZWQgPSBwYXJzZUludChsaW5lc1szXSwgMTApO1xuICAgICAgICAgICAgICAgIHJ4X2Vycm9ycyA9IHBhcnNlSW50KGxpbmVzWzRdLCAxMCk7XG4gICAgICAgICAgICAgICAgdHhfZHJvcHBlZCA9IHBhcnNlSW50KGxpbmVzWzVdLCAxMCk7XG4gICAgICAgICAgICAgICAgdHhfZXJyb3JzID0gcGFyc2VJbnQobGluZXNbNl0sIDEwKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNOZXR3b3JrU3BlZWQoaWZhY2VTYW5pdGl6ZWQsIHJ4X2J5dGVzLCB0eF9ieXRlcywgb3BlcnN0YXRlLCByeF9kcm9wcGVkLCByeF9lcnJvcnMsIHR4X2Ryb3BwZWQsIHR4X2Vycm9ycyk7XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIGNtZCA9ICduZXRzdGF0IC1pYm5kSSAnICsgaWZhY2VTYW5pdGl6ZWQ7ICAgLy8gbGd0bSBbanMvc2hlbGwtY29tbWFuZC1jb25zdHJ1Y3RlZC1mcm9tLWlucHV0XVxuICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgJiYgbGluZVswXSAmJiBsaW5lWzddICYmIGxpbmVbMTBdKSB7XG4gICAgICAgICAgICAgICAgICByeF9ieXRlcyA9IHJ4X2J5dGVzICsgcGFyc2VJbnQobGluZVs3XSk7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZVs2XS50cmltKCkgIT09ICctJykgeyByeF9kcm9wcGVkID0gcnhfZHJvcHBlZCArIHBhcnNlSW50KGxpbmVbNl0pOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobGluZVs1XS50cmltKCkgIT09ICctJykgeyByeF9lcnJvcnMgPSByeF9lcnJvcnMgKyBwYXJzZUludChsaW5lWzVdKTsgfVxuICAgICAgICAgICAgICAgICAgdHhfYnl0ZXMgPSB0eF9ieXRlcyArIHBhcnNlSW50KGxpbmVbMTBdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lWzEyXS50cmltKCkgIT09ICctJykgeyB0eF9kcm9wcGVkID0gdHhfZHJvcHBlZCArIHBhcnNlSW50KGxpbmVbMTJdKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbOV0udHJpbSgpICE9PSAnLScpIHsgdHhfZXJyb3JzID0gdHhfZXJyb3JzICsgcGFyc2VJbnQobGluZVs5XSk7IH1cbiAgICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSA9ICd1cCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNOZXR3b3JrU3BlZWQoaWZhY2VTYW5pdGl6ZWQsIHJ4X2J5dGVzLCB0eF9ieXRlcywgb3BlcnN0YXRlLCByeF9kcm9wcGVkLCByeF9lcnJvcnMsIHR4X2Ryb3BwZWQsIHR4X2Vycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICBjbWQgPSAnaWZjb25maWcgJyArIGlmYWNlU2FuaXRpemVkICsgJyB8IGdyZXAgXCJzdGF0dXNcIic7ICAgIC8vIGxndG0gW2pzL3NoZWxsLWNvbW1hbmQtY29uc3RydWN0ZWQtZnJvbS1pbnB1dF1cbiAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcGVyc3RhdGUgPSAoc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJzonKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0Lm9wZXJzdGF0ZSA9IChyZXN1bHQub3BlcnN0YXRlIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmVzdWx0Lm9wZXJzdGF0ZSA9IChyZXN1bHQub3BlcnN0YXRlID09PSAnYWN0aXZlJyA/ICd1cCcgOiAocmVzdWx0Lm9wZXJzdGF0ZSA9PT0gJ2luYWN0aXZlJyA/ICdkb3duJyA6ICd1bmtub3duJykpO1xuICAgICAgICAgICAgY21kID0gJ25ldHN0YXQgLWJkSSAnICsgaWZhY2VTYW5pdGl6ZWQ7ICAgLy8gbGd0bSBbanMvc2hlbGwtY29tbWFuZC1jb25zdHJ1Y3RlZC1mcm9tLWlucHV0XVxuICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBsZXNzIHRoYW4gMiBsaW5lcywgbm8gaW5mb3JtYXRpb24gZm9yIHRoaXMgaW50ZXJmYWNlIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxICYmIGxpbmVzWzFdLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNraXAgaGVhZGVyIGxpbmVcbiAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgc2Vjb25kIGxpbmUgYmVjYXVzZSBpdCBpcyB0aWVkIHRvIHRoZSBOSUMgaW5zdGVhZCBvZiB0aGUgaXB2NCBvciBpcHY2IGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgIHN0YXRzID0gbGluZXNbMV0ucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdHMubGVuZ3RoID4gMTEgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgIHJ4X2J5dGVzID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgNV0pO1xuICAgICAgICAgICAgICAgICAgcnhfZHJvcHBlZCA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDEwXSk7XG4gICAgICAgICAgICAgICAgICByeF9lcnJvcnMgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyA0XSk7XG4gICAgICAgICAgICAgICAgICB0eF9ieXRlcyA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDhdKTtcbiAgICAgICAgICAgICAgICAgIHR4X2Ryb3BwZWQgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyAxMF0pO1xuICAgICAgICAgICAgICAgICAgdHhfZXJyb3JzID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgN10pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY05ldHdvcmtTcGVlZChpZmFjZVNhbml0aXplZCwgcnhfYnl0ZXMsIHR4X2J5dGVzLCByZXN1bHQub3BlcnN0YXRlLCByeF9kcm9wcGVkLCByeF9lcnJvcnMsIHR4X2Ryb3BwZWQsIHR4X2Vycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgIGxldCBwZXJmRGF0YSA9IFtdO1xuICAgICAgICAgIGxldCBpZmFjZU5hbWUgPSBpZmFjZVNhbml0aXplZDtcblxuICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIERhdGFcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9QZXJmUmF3RGF0YV9UY3BpcF9OZXR3b3JrSW50ZXJmYWNlIHwgc2VsZWN0IE5hbWUsQnl0ZXNSZWNlaXZlZFBlcnNlYyxQYWNrZXRzUmVjZWl2ZWRFcnJvcnMsUGFja2V0c1JlY2VpdmVkRGlzY2FyZGVkLEJ5dGVzU2VudFBlcnNlYyxQYWNrZXRzT3V0Ym91bmRFcnJvcnMsUGFja2V0c091dGJvdW5kRGlzY2FyZGVkIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBzZWN0aW9ucyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgIHBlcmZEYXRhID0gcGFyc2VMaW5lc1dpbmRvd3NQZXJmRGF0YShwc2VjdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXR3b3JrIEludGVyZmFjZXNcbiAgICAgICAgICAgIG5ldHdvcmtJbnRlcmZhY2VzKGZhbHNlKS50aGVuKGludGVyZmFjZXMgPT4ge1xuICAgICAgICAgICAgICAvLyBnZXQgYnl0ZXMgc2VudCwgcmVjZWl2ZWQgZnJvbSBwZXJmRGF0YSBieSBuYW1lXG4gICAgICAgICAgICAgIHJ4X2J5dGVzID0gMDtcbiAgICAgICAgICAgICAgdHhfYnl0ZXMgPSAwO1xuICAgICAgICAgICAgICBwZXJmRGF0YS5mb3JFYWNoKGRldGFpbCA9PiB7XG4gICAgICAgICAgICAgICAgaW50ZXJmYWNlcy5mb3JFYWNoKGRldCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGRldC5pZmFjZS50b0xvd2VyQ2FzZSgpID09PSBpZmFjZVNhbml0aXplZC50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRldC5tYWMudG9Mb3dlckNhc2UoKSA9PT0gaWZhY2VTYW5pdGl6ZWQudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXQuaXA0LnRvTG93ZXJDYXNlKCkgPT09IGlmYWNlU2FuaXRpemVkLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0LmlwNi50b0xvd2VyQ2FzZSgpID09PSBpZmFjZVNhbml0aXplZC50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRldC5pZmFjZU5hbWUucmVwbGFjZSgvWygpW1xcXSBdKy9nLCAnJykucmVwbGFjZSgvI3xcXC8vZywgJ18nKS50b0xvd2VyQ2FzZSgpID09PSBpZmFjZVNhbml0aXplZC5yZXBsYWNlKC9bKClbXFxdIF0rL2csICcnKS5yZXBsYWNlKCcjJywgJ18nKS50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZGV0LmlmYWNlTmFtZS5yZXBsYWNlKC9bKClbXFxdIF0rL2csICcnKS5yZXBsYWNlKC8jfFxcLy9nLCAnXycpLnRvTG93ZXJDYXNlKCkgPT09IGRldGFpbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZmFjZU5hbWUgPSBkZXQuaWZhY2U7XG4gICAgICAgICAgICAgICAgICAgIHJ4X2J5dGVzID0gZGV0YWlsLnJ4X2J5dGVzO1xuICAgICAgICAgICAgICAgICAgICByeF9kcm9wcGVkID0gZGV0YWlsLnJ4X2Ryb3BwZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJ4X2Vycm9ycyA9IGRldGFpbC5yeF9lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIHR4X2J5dGVzID0gZGV0YWlsLnR4X2J5dGVzO1xuICAgICAgICAgICAgICAgICAgICB0eF9kcm9wcGVkID0gZGV0YWlsLnR4X2Ryb3BwZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR4X2Vycm9ycyA9IGRldGFpbC50eF9lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSA9IGRldC5vcGVyc3RhdGU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAocnhfYnl0ZXMgJiYgdHhfYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjTmV0d29ya1NwZWVkKGlmYWNlTmFtZSwgcGFyc2VJbnQocnhfYnl0ZXMpLCBwYXJzZUludCh0eF9ieXRlcyksIG9wZXJzdGF0ZSwgcnhfZHJvcHBlZCwgcnhfZXJyb3JzLCB0eF9kcm9wcGVkLCB0eF9lcnJvcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucnhfYnl0ZXMgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ucnhfYnl0ZXM7XG4gICAgICAgIHJlc3VsdC50eF9ieXRlcyA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS50eF9ieXRlcztcbiAgICAgICAgcmVzdWx0LnJ4X3NlYyA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5yeF9zZWM7XG4gICAgICAgIHJlc3VsdC50eF9zZWMgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0udHhfc2VjO1xuICAgICAgICByZXN1bHQubXMgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ubGFzdF9tcztcbiAgICAgICAgcmVzdWx0Lm9wZXJzdGF0ZSA9IF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5vcGVyc3RhdGU7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmV0d29ya1N0YXRzID0gbmV0d29ya1N0YXRzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTkVUIC0gY29ubmVjdGlvbnMgKHNvY2tldHMpXG5cbmZ1bmN0aW9uIGdldFByb2Nlc3NOYW1lKHByb2Nlc3NlcywgcGlkKSB7XG4gIGxldCBjbWQgPSAnJztcbiAgcHJvY2Vzc2VzLmZvckVhY2gobGluZSA9PiB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgaWQgPSBwYXJzZUludChwYXJ0c1swXSwgMTApIHx8IC0xO1xuICAgIGlmIChpZCA9PT0gcGlkKSB7XG4gICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgY21kID0gcGFydHMuam9pbignICcpLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICB9KTtcbiAgY21kID0gY21kLnNwbGl0KCcgLScpWzBdO1xuICAvLyByZXR1cm4gY21kO1xuICBjb25zdCBjbWRQYXJ0cyA9IGNtZC5zcGxpdCgnLycpO1xuICByZXR1cm4gY21kUGFydHNbY21kUGFydHMubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtDb25uZWN0aW9ucyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGxldCBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBuZXRzdGF0IC10dW5hcCB8IGdyZXAgXCJFU1RBQkxJU0hFRFxcXFx8U1lOX1NFTlRcXFxcfFNZTl9SRUNWXFxcXHxGSU5fV0FJVDFcXFxcfEZJTl9XQUlUMlxcXFx8VElNRV9XQUlUXFxcXHxDTE9TRVxcXFx8Q0xPU0VfV0FJVFxcXFx8TEFTVF9BQ0tcXFxcfExJU1RFTlxcXFx8Q0xPU0lOR1xcXFx8VU5LTk9XTlwiOyB1bnNldCBMQ19BTEwnO1xuICAgICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgeyBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBuZXRzdGF0IC1uYSB8IGdyZXAgXCJFU1RBQkxJU0hFRFxcXFx8U1lOX1NFTlRcXFxcfFNZTl9SRUNWXFxcXHxGSU5fV0FJVDFcXFxcfEZJTl9XQUlUMlxcXFx8VElNRV9XQUlUXFxcXHxDTE9TRVxcXFx8Q0xPU0VfV0FJVFxcXFx8TEFTVF9BQ0tcXFxcfExJU1RFTlxcXFx8Q0xPU0lOR1xcXFx8VU5LTk9XTlwiOyB1bnNldCBMQ19BTEwnOyB9XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGlmICghZXJyb3IgJiYgKGxpbmVzLmxlbmd0aCA+IDEgfHwgbGluZXNbMF0gIT0gJycpKSB7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxpcCA9IGxpbmVbM107XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FscG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBsb2NhbGFkZHJlc3MgPSBsaW5lWzNdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbHBvcnQgPSBsb2NhbGFkZHJlc3NbbG9jYWxhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgbG9jYWxhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgbG9jYWxpcCA9IGxvY2FsYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwZWVyaXAgPSBsaW5lWzRdO1xuICAgICAgICAgICAgICAgIGxldCBwZWVycG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBwZWVyYWRkcmVzcyA9IGxpbmVbNF0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAocGVlcmFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgcGVlcnBvcnQgPSBwZWVyYWRkcmVzc1twZWVyYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgIHBlZXJhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgcGVlcmlwID0gcGVlcmFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY29ubnN0YXRlID0gbGluZVs1XTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvYyA9IGxpbmVbNl0uc3BsaXQoJy8nKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGxpbmVbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxpcCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3J0OiBsb2NhbHBvcnQsXG4gICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBwZWVyaXAsXG4gICAgICAgICAgICAgICAgICAgIHBlZXJQb3J0OiBwZWVycG9ydCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGNvbm5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGlkOiBwcm9jWzBdICYmIHByb2NbMF0gIT09ICctJyA/IHBhcnNlSW50KHByb2NbMF0sIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6IHByb2NbMV0gPyBwcm9jWzFdLnNwbGl0KCcgJylbMF0uc3BsaXQoJzonKVswXSA6ICcnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtZCA9ICdzcyAtdHVuYXAgfCBncmVwIFwiRVNUQUJcXFxcfFNZTi1TRU5UXFxcXHxTWU4tUkVDVlxcXFx8RklOLVdBSVQxXFxcXHxGSU4tV0FJVDJcXFxcfFRJTUUtV0FJVFxcXFx8Q0xPU0VcXFxcfENMT1NFLVdBSVRcXFxcfExBU1QtQUNLXFxcXHxMSVNURU5cXFxcfENMT1NJTkdcIic7XG4gICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuXG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsaXAgPSBsaW5lWzRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGFkZHJlc3MgPSBsaW5lWzRdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2FscG9ydCA9IGxvY2FsYWRkcmVzc1tsb2NhbGFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsaXAgPSBsb2NhbGFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZWVyaXAgPSBsaW5lWzVdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVlcnBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlZXJhZGRyZXNzID0gbGluZVs1XS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlcmFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJwb3J0ID0gcGVlcmFkZHJlc3NbcGVlcmFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgcGVlcmFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVlcmlwID0gcGVlcmFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25uc3RhdGUgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnRVNUQUInKSB7IGNvbm5zdGF0ZSA9ICdFU1RBQkxJU0hFRCc7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ1RJTUUtV0FJVCcpIHsgY29ubnN0YXRlID0gJ1RJTUVfV0FJVCc7IH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSA3ICYmIGxpbmVbNl0uaW5kZXhPZigndXNlcnM6JykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9jID0gbGluZVs2XS5yZXBsYWNlKCd1c2VyczooKFwiJywgJycpLnJlcGxhY2UoL1wiL2csICcnKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBwcm9jWzBdLnNwbGl0KCcgJylbMF0uc3BsaXQoJzonKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZCA9IHBhcnNlSW50KHByb2NbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBsaW5lWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbGlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3J0OiBsb2NhbHBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogcGVlcmlwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlclBvcnQ6IHBlZXJwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IGNvbm5zdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIC8vIGxldCBjbWQgPSAnbmV0c3RhdCAtbmF0diB8IGdyZXAgXCJFU1RBQkxJU0hFRFxcXFx8U1lOX1NFTlRcXFxcfFNZTl9SRUNWXFxcXHxGSU5fV0FJVDFcXFxcfEZJTl9XQUlUMlxcXFx8VElNRV9XQUlUXFxcXHxDTE9TRVxcXFx8Q0xPU0VfV0FJVFxcXFx8TEFTVF9BQ0tcXFxcfExJU1RFTlxcXFx8Q0xPU0lOR1xcXFx8VU5LTk9XTlwiJztcbiAgICAgICAgbGV0IGNtZCA9ICduZXRzdGF0IC1uYXR2IHwgZ3JlcCBcInRjcDRcXFxcfHRjcDZcXFxcfHVkcDRcXFxcfHVkcDZcIic7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9ICdFU1RBQkxJU0hFRHxTWU5fU0VOVHxTWU5fUkVDVnxGSU5fV0FJVDF8RklOX1dBSVQyfFRJTUVfV0FJVHxDTE9TRXxDTE9TRV9XQUlUfExBU1RfQUNLfExJU1RFTnxDTE9TSU5HfFVOS05PV04nO1xuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGV4ZWMoJ3BzIC1heG8gcGlkLGNvbW1hbmQnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnIyLCBzdGRvdXQyKSB7XG4gICAgICAgICAgICAgIGxldCBwcm9jZXNzZXMgPSBzdGRvdXQyLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBwcm9jZXNzZXMgPSBwcm9jZXNzZXMubWFwKChsaW5lID0+IHsgcmV0dXJuIGxpbmUudHJpbSgpLnJlcGxhY2UoLyArL2csICcgJyk7IH0pKTtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGlwID0gbGluZVszXTtcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbHBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGFkZHJlc3MgPSBsaW5lWzNdLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxwb3J0ID0gbG9jYWxhZGRyZXNzW2xvY2FsYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGlwID0gbG9jYWxhZGRyZXNzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCBwZWVyaXAgPSBsaW5lWzRdO1xuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcmFkZHJlc3MgPSBsaW5lWzRdLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICBpZiAocGVlcmFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwZWVycG9ydCA9IHBlZXJhZGRyZXNzW3BlZXJhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBwZWVyYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcGVlcmlwID0gcGVlcmFkZHJlc3Muam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgaGFzU3RhdGUgPSBzdGF0ZXMuaW5kZXhPZihsaW5lWzVdKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgbGV0IGNvbm5zdGF0ZSA9IGhhc1N0YXRlID8gbGluZVs1XSA6ICdVTktOT1dOJztcbiAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSBwYXJzZUludChsaW5lWzggKyAoaGFzU3RhdGUgPyAwIDogLTEpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGxpbmVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbGlwLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9ydDogbG9jYWxwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBwZWVyaXAsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlclBvcnQ6IHBlZXJwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBjb25uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogZ2V0UHJvY2Vzc05hbWUocHJvY2Vzc2VzLCBwaWQpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBjbWQgPSAnbmV0c3RhdCAtbmFvJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKGNtZCwgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcblxuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG5cbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGlwID0gbGluZVsxXTtcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbHBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGFkZHJlc3MgPSBsaW5lWzFdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxwb3J0ID0gbG9jYWxhZGRyZXNzW2xvY2FsYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGlwID0gbG9jYWxhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxvY2FsaXAgPSBsb2NhbGlwLnJlcGxhY2UoL1xcWy9nLCAnJykucmVwbGFjZSgvXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgIGxldCBwZWVyaXAgPSBsaW5lWzJdO1xuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcmFkZHJlc3MgPSBsaW5lWzJdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAocGVlcmFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBwZWVycG9ydCA9IHBlZXJhZGRyZXNzW3BlZXJhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBwZWVyYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcGVlcmlwID0gcGVlcmFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcGVlcmlwID0gcGVlcmlwLnJlcGxhY2UoL1xcWy9nLCAnJykucmVwbGFjZSgvXFxdL2csICcnKTtcbiAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSB1dGlsLnRvSW50KGxpbmVbNF0pO1xuICAgICAgICAgICAgICAgICAgbGV0IGNvbm5zdGF0ZSA9IGxpbmVbM107XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnSEVSR0VTVEVMTFQnKSB7IGNvbm5zdGF0ZSA9ICdFU1RBQkxJU0hFRCc7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUuc3RhcnRzV2l0aCgnQUJIJykpIHsgY29ubnN0YXRlID0gJ0xJU1RFTic7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdTQ0hMSUVTU0VOX1dBUlRFTicpIHsgY29ubnN0YXRlID0gJ0NMT1NFX1dBSVQnOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnV0FSVEVORCcpIHsgY29ubnN0YXRlID0gJ1RJTUVfV0FJVCc7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdTWU5fR0VTRU5ERVQnKSB7IGNvbm5zdGF0ZSA9ICdTWU5fU0VOVCc7IH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ0xJU1RFTklORycpIHsgY29ubnN0YXRlID0gJ0xJU1RFTic7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdTWU5fUkVDRUlWRUQnKSB7IGNvbm5zdGF0ZSA9ICdTWU5fUkVDVic7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdGSU5fV0FJVF8xJykgeyBjb25uc3RhdGUgPSAnRklOX1dBSVQxJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ0ZJTl9XQUlUXzInKSB7IGNvbm5zdGF0ZSA9ICdGSU5fV0FJVDInOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobGluZVswXS50b0xvd2VyQ2FzZSgpICE9PSAndWRwJyAmJiBjb25uc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBsaW5lWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbGlwLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9ydDogbG9jYWxwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBwZWVyaXAsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlclBvcnQ6IHBlZXJwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBjb25uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lWzBdLnRvTG93ZXJDYXNlKCkgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogbGluZVswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxpcCxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvcnQ6IGxvY2FscG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogcGVlcmlwLFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJQb3J0OiBwZWVycG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBwYXJzZUludChsaW5lWzNdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2VzczogJydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uZXR3b3JrQ29ubmVjdGlvbnMgPSBuZXR3b3JrQ29ubmVjdGlvbnM7XG5cbmZ1bmN0aW9uIG5ldHdvcmtHYXRld2F5RGVmYXVsdChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGxldCBjbWQgPSAnaXAgcm91dGUgZ2V0IDEnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzICYmIGxpbmVzWzBdID8gbGluZXNbMF0gOiAnJztcbiAgICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnIHZpYSAnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgcGFydHMgPSBwYXJ0c1sxXS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdyb3V0ZSAtbiBnZXQgZGVmYXVsdCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICAgICAgICAgICAgICByZXN1bHQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZ2F0ZXdheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY21kID0gJ25ldHN0YXQgLXJuIHwgYXdrIFxcJy9kZWZhdWx0LyB7cHJpbnQgJDJ9XFwnJztcbiAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGluZXMuZmluZChsaW5lID0+ICgvXigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJC8udGVzdChsaW5lKSkpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoJ25ldHN0YXQgLXInLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdChvcy5FT0wpO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignMC4wLjAuMCAwLjAuMC4wJykgPiAtMSAmJiAhKC9bYS16QS1aXS8udGVzdChsaW5lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDUgJiYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDNdKS5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIC1DbGFzc05hbWUgV2luMzJfSVA0Um91dGVUYWJsZSB8IFdoZXJlLU9iamVjdCB7ICRfLkRlc3RpbmF0aW9uIC1lcSBcXCcwLjAuMC4wXFwnIC1hbmQgJF8uTWFzayAtZXEgXFwnMC4wLjAuMFxcJyB9JylcbiAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxICYmICFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ05leHRIb3AnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgZXhlYygnaXBjb25maWcnLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBsaW5lID0gbGluZS50cmltKCkucmVwbGFjZSgvXFwuIC9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBpZiAoKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnc3RhbmRhcmRnYXRlJykgfHwgcGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdnYXRld2F5JykgPiAtMSB8fCBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2VubGFjZScpID4gLTEpICYmIHBhcnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmVzdWx0ID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmV0d29ya0dhdGV3YXlEZWZhdWx0ID0gbmV0d29ya0dhdGV3YXlEZWZhdWx0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBvc2luZm8uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAzLiBPcGVyYXRpbmcgU3lzdGVtXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdldCBjdXJyZW50IHRpbWUgYW5kIE9TIHVwdGltZVxuXG5mdW5jdGlvbiB0aW1lKCkge1xuICBsZXQgdCA9IG5ldyBEYXRlKCkudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IERhdGUubm93KCksXG4gICAgdXB0aW1lOiBvcy51cHRpbWUoKSxcbiAgICB0aW1lem9uZTogKHQubGVuZ3RoID49IDcpID8gdFs1XSA6ICcnLFxuICAgIHRpbWV6b25lTmFtZTogSW50bCA/IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSA6ICh0Lmxlbmd0aCA+PSA3KSA/IHQuc2xpY2UoNikuam9pbignICcpLnJlcGxhY2UoL1xcKC9nLCAnJykucmVwbGFjZSgvXFwpL2csICcnKSA6ICcnXG4gIH07XG59XG5cbmV4cG9ydHMudGltZSA9IHRpbWU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHZXQgbG9nbyBmaWxlbmFtZSBvZiBPUyBkaXN0cmlidXRpb25cblxuZnVuY3Rpb24gZ2V0TG9nb0ZpbGUoZGlzdHJvKSB7XG4gIGRpc3RybyA9IGRpc3RybyB8fCAnJztcbiAgZGlzdHJvID0gZGlzdHJvLnRvTG93ZXJDYXNlKCk7XG4gIGxldCByZXN1bHQgPSBfcGxhdGZvcm07XG4gIGlmIChfd2luZG93cykge1xuICAgIHJlc3VsdCA9ICd3aW5kb3dzJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWFjIG9zJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2FwcGxlJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignYXJjaCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdhcmNoJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignY2VudG9zJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2NlbnRvcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2NvcmVvcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdjb3Jlb3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdkZWJpYW4nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZGViaWFuJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZGVlcGluJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2RlZXBpbic7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2VsZW1lbnRhcnknKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZWxlbWVudGFyeSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2ZlZG9yYScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdmZWRvcmEnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdnZW50b28nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZ2VudG9vJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWFnZWlhJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ21hZ2VpYSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21hbmRyaXZhJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ21hbmRyaXZhJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWFuamFybycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdtYW5qYXJvJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWludCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdtaW50JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbXgnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbXgnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdvcGVuYnNkJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ29wZW5ic2QnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdmcmVlYnNkJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2ZyZWVic2QnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdvcGVuc3VzZScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdvcGVuc3VzZSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3BjbGludXhvcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdwY2xpbnV4b3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdwdXBweScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdwdXBweSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3Jhc3BiaWFuJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3Jhc3BiaWFuJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncmVhY3RvcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdyZWFjdG9zJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncmVkaGF0JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3JlZGhhdCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3NsYWNrd2FyZScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdzbGFja3dhcmUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdzdWdhcicpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdzdWdhcic7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3N0ZWFtJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3N0ZWFtJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignc3VzZScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdzdXNlJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignbWF0ZScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICd1YnVudHUtbWF0ZSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2x1YnVudHUnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbHVidW50dSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3h1YnVudHUnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAneHVidW50dSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3VidW50dScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICd1YnVudHUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdzb2xhcmlzJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3NvbGFyaXMnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCd0YWlscycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICd0YWlscyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2ZlcmVuJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2ZlcmVub3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdyb2JvbGludXgnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncm9ib2xpbnV4JztcbiAgfSBlbHNlIGlmIChfbGludXggJiYgZGlzdHJvKSB7XG4gICAgcmVzdWx0ID0gZGlzdHJvLnRvTG93ZXJDYXNlKCkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRlFETlxuXG5mdW5jdGlvbiBnZXRGUUROKCkge1xuICBsZXQgZnFkbiA9IG9zLmhvc3RuYW1lO1xuICBpZiAoX2xpbnV4IHx8IF9kYXJ3aW4pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2hvc3RuYW1lIC1mJyk7XG4gICAgICBmcWRuID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQob3MuRU9MKVswXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH1cbiAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2hvc3RuYW1lJyk7XG4gICAgICBmcWRuID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQob3MuRU9MKVswXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH1cbiAgaWYgKF93aW5kb3dzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdlY2hvICVDT01QVVRFUk5BTUUlLiVVU0VSRE5TRE9NQUlOJScsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgICAgZnFkbiA9IHN0ZG91dC50b1N0cmluZygpLnJlcGxhY2UoJy4lVVNFUkROU0RPTUFJTiUnLCAnJykuc3BsaXQob3MuRU9MKVswXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZxZG47XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPUyBJbmZvcm1hdGlvblxuXG5mdW5jdGlvbiBvc0luZm8oY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG5cbiAgICAgICAgcGxhdGZvcm06IChfcGxhdGZvcm0gPT09ICd3aW4zMicgPyAnV2luZG93cycgOiBfcGxhdGZvcm0pLFxuICAgICAgICBkaXN0cm86ICd1bmtub3duJyxcbiAgICAgICAgcmVsZWFzZTogJ3Vua25vd24nLFxuICAgICAgICBjb2RlbmFtZTogJycsXG4gICAgICAgIGtlcm5lbDogb3MucmVsZWFzZSgpLFxuICAgICAgICBhcmNoOiBvcy5hcmNoKCksXG4gICAgICAgIGhvc3RuYW1lOiBvcy5ob3N0bmFtZSgpLFxuICAgICAgICBmcWRuOiBnZXRGUUROKCksXG4gICAgICAgIGNvZGVwYWdlOiAnJyxcbiAgICAgICAgbG9nb2ZpbGU6ICcnLFxuICAgICAgICBzZXJpYWw6ICcnLFxuICAgICAgICBidWlsZDogJycsXG4gICAgICAgIHNlcnZpY2VwYWNrOiAnJyxcbiAgICAgICAgdWVmaTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChfbGludXgpIHtcblxuICAgICAgICBleGVjKCdjYXQgL2V0Yy8qLXJlbGVhc2U7IGNhdCAvdXNyL2xpYi9vcy1yZWxlYXNlOyBjYXQgL2V0Yy9vcGVud3J0X3JlbGVhc2UnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIERJU1RSSUJfSURcbiAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIE5BTUVcbiAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIERJU1RSSUJfUkVMRUFTRVxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgVkVSU0lPTl9JRFxuICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgRElTVFJJQl9DT0RFTkFNRVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCByZWxlYXNlID0ge307XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJz0nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmVsZWFzZVtsaW5lLnNwbGl0KCc9JylbMF0udHJpbSgpLnRvVXBwZXJDYXNlKCldID0gbGluZS5zcGxpdCgnPScpWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgcmVsZWFzZVZlcnNpb24gPSAocmVsZWFzZS5WRVJTSU9OIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgbGV0IGNvZGVuYW1lID0gKHJlbGVhc2UuRElTVFJJQl9DT0RFTkFNRSB8fCByZWxlYXNlLlZFUlNJT05fQ09ERU5BTUUgfHwgJycpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICBpZiAocmVsZWFzZVZlcnNpb24uaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgICAgIGNvZGVuYW1lID0gcmVsZWFzZVZlcnNpb24uc3BsaXQoJygnKVsxXS5yZXBsYWNlKC9bKCldL2csICcnKS50cmltKCk7XG4gICAgICAgICAgICByZWxlYXNlVmVyc2lvbiA9IHJlbGVhc2VWZXJzaW9uLnNwbGl0KCcoJylbMF0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQuZGlzdHJvID0gKHJlbGVhc2UuRElTVFJJQl9JRCB8fCByZWxlYXNlLk5BTUUgfHwgJ3Vua25vd24nKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgcmVzdWx0LmxvZ29maWxlID0gZ2V0TG9nb0ZpbGUocmVzdWx0LmRpc3Rybyk7XG4gICAgICAgICAgcmVzdWx0LnJlbGVhc2UgPSAocmVsZWFzZVZlcnNpb24gfHwgcmVsZWFzZS5ESVNUUklCX1JFTEVBU0UgfHwgcmVsZWFzZS5WRVJTSU9OX0lEIHx8ICd1bmtub3duJykucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IGNvZGVuYW1lO1xuICAgICAgICAgIHJlc3VsdC5jb2RlcGFnZSA9IHV0aWwuZ2V0Q29kZXBhZ2UoKTtcbiAgICAgICAgICByZXN1bHQuYnVpbGQgPSAocmVsZWFzZS5CVUlMRF9JRCB8fCAnJykucmVwbGFjZSgvXCIvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICBpc1VlZmlMaW51eCgpLnRoZW4odWVmaSA9PiB7XG4gICAgICAgICAgICByZXN1bHQudWVmaSA9IHVlZmk7XG4gICAgICAgICAgICB1dWlkKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gZGF0YS5vcztcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuXG4gICAgICAgIGV4ZWMoJ3N5c2N0bCBrZXJuLm9zdHlwZSBrZXJuLm9zcmVsZWFzZSBrZXJuLm9zcmV2aXNpb24ga2Vybi5ob3N0dXVpZCBtYWNoZGVwLmJvb3RtZXRob2Qga2Vybi5nZW9tLmNvbmZ4bWwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBjb25zdCBkaXN0cm8gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5vc3R5cGUnKTtcbiAgICAgICAgICBjb25zdCBsb2dvZmlsZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm9zdHlwZScpO1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5vc3JlbGVhc2UnKS5zcGxpdCgnLScpWzBdO1xuICAgICAgICAgIGNvbnN0IHNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLnV1aWQnKTtcbiAgICAgICAgICBjb25zdCBib290bWV0aG9kID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuYm9vdG1ldGhvZCcpO1xuICAgICAgICAgIGNvbnN0IHVlZmlDb25mID0gc3Rkb3V0LnRvU3RyaW5nKCkuaW5kZXhPZignPHR5cGU+ZWZpPC90eXBlPicpID49IDA7XG4gICAgICAgICAgY29uc3QgdWVmaSA9IGJvb3RtZXRob2QgPyBib290bWV0aG9kLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndWVmaScpID49IDAgOiAodWVmaUNvbmYgPyB1ZWZpQ29uZiA6IG51bGwpO1xuICAgICAgICAgIHJlc3VsdC5kaXN0cm8gPSBkaXN0cm8gfHwgcmVzdWx0LmRpc3RybztcbiAgICAgICAgICByZXN1bHQubG9nb2ZpbGUgPSBsb2dvZmlsZSB8fCByZXN1bHQubG9nb2ZpbGU7XG4gICAgICAgICAgcmVzdWx0LnJlbGVhc2UgPSByZWxlYXNlIHx8IHJlc3VsdC5yZWxlYXNlO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSBzZXJpYWwgfHwgcmVzdWx0LnNlcmlhbDtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAnJztcbiAgICAgICAgICByZXN1bHQuY29kZXBhZ2UgPSB1dGlsLmdldENvZGVwYWdlKCk7XG4gICAgICAgICAgcmVzdWx0LnVlZmkgPSB1ZWZpIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3dfdmVyczsgc3lzY3RsIGtlcm4ub3N0eXBlIGtlcm4ub3NyZWxlYXNlIGtlcm4ub3NyZXZpc2lvbiBrZXJuLnV1aWQnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4udXVpZCcpO1xuICAgICAgICAgIHJlc3VsdC5kaXN0cm8gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvZHVjdE5hbWUnKTtcbiAgICAgICAgICByZXN1bHQucmVsZWFzZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9kdWN0VmVyc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5idWlsZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCdWlsZFZlcnNpb24nKTtcbiAgICAgICAgICByZXN1bHQubG9nb2ZpbGUgPSBnZXRMb2dvRmlsZShyZXN1bHQuZGlzdHJvKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAnbWFjT1MnO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC40JykgPiAtMSA/ICdNYWMgT1MgWCBUaWdlcicgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC41JykgPiAtMSA/ICdNYWMgT1MgWCBMZW9wYXJkJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjYnKSA+IC0xID8gJ01hYyBPUyBYIFNub3cgTGVvcGFyZCcgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC43JykgPiAtMSA/ICdNYWMgT1MgWCBMaW9uJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjgnKSA+IC0xID8gJ09TIFggTW91bnRhaW4gTGlvbicgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC45JykgPiAtMSA/ICdPUyBYIE1hdmVyaWNrcycgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xMCcpID4gLTEgPyAnT1MgWCBZb3NlbWl0ZScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xMScpID4gLTEgPyAnT1MgWCBFbCBDYXBpdGFuJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjEyJykgPiAtMSA/ICdtYWNPUyBTaWVycmEnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTMnKSA+IC0xID8gJ21hY09TIEhpZ2ggU2llcnJhJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjE0JykgPiAtMSA/ICdtYWNPUyBNb2phdmUnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTUnKSA+IC0xID8gJ21hY09TIENhdGFsaW5hJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLnN0YXJ0c1dpdGgoJzExLicpID8gJ21hY09TIEJpZyBTdXInIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2Uuc3RhcnRzV2l0aCgnMTIuJykgPyAnbWFjT1MgTW9udGVyZXknIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2Uuc3RhcnRzV2l0aCgnMTMuJykgPyAnbWFjT1MgVmVudHVyYScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC51ZWZpID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQuY29kZXBhZ2UgPSB1dGlsLmdldENvZGVwYWdlKCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICByZXN1bHQucmVsZWFzZSA9IHJlc3VsdC5rZXJuZWw7XG4gICAgICAgIGV4ZWMoJ3VuYW1lIC1vJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0LmRpc3RybyA9IGxpbmVzWzBdO1xuICAgICAgICAgIHJlc3VsdC5sb2dvZmlsZSA9IGdldExvZ29GaWxlKHJlc3VsdC5kaXN0cm8pO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICByZXN1bHQubG9nb2ZpbGUgPSBnZXRMb2dvRmlsZSgpO1xuICAgICAgICByZXN1bHQucmVsZWFzZSA9IHJlc3VsdC5rZXJuZWw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX09wZXJhdGluZ1N5c3RlbSB8IHNlbGVjdCBDYXB0aW9uLFNlcmlhbE51bWJlcixCdWlsZE51bWJlcixTZXJ2aWNlUGFja01ham9yVmVyc2lvbixTZXJ2aWNlUGFja01pbm9yVmVyc2lvbiB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCcoR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NvbXB1dGVyU3lzdGVtKS5IeXBlcnZpc29yUHJlc2VudCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnQWRkLVR5cGUgLUFzc2VtYmx5TmFtZSBTeXN0ZW0uV2luZG93cy5Gb3JtczsgW1N5c3RlbS5XaW5kb3dzLkZvcm1zLlN5c3RlbUluZm9ybWF0aW9uXTo6VGVybWluYWxTZXJ2ZXJTZXNzaW9uJykpO1xuICAgICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhLnJlc3VsdHNbMF0gPyBkYXRhLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJykgOiBbJyddO1xuICAgICAgICAgICAgcmVzdWx0LmRpc3RybyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbE51bWJlcicsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LmJ1aWxkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0J1aWxkTnVtYmVyJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc2VydmljZXBhY2sgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VydmljZVBhY2tNYWpvclZlcnNpb24nLCAnOicpLnRyaW0oKSArICcuJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJ2aWNlUGFja01pbm9yVmVyc2lvbicsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LmNvZGVwYWdlID0gdXRpbC5nZXRDb2RlcGFnZSgpO1xuICAgICAgICAgICAgY29uc3QgaHlwZXJ2ID0gZGF0YS5yZXN1bHRzWzFdID8gZGF0YS5yZXN1bHRzWzFdLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICAgICAgcmVzdWx0Lmh5cGVydmlzb3IgPSBoeXBlcnYuaW5kZXhPZigndHJ1ZScpICE9PSAtMTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBkYXRhLnJlc3VsdHNbMl0gPyBkYXRhLnJlc3VsdHNbMl0udG9TdHJpbmcoKSA6ICcnO1xuICAgICAgICAgICAgcmVzdWx0LnJlbW90ZVNlc3Npb24gPSAodGVybS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndHJ1ZScpID49IDApO1xuICAgICAgICAgICAgaXNVZWZpV2luZG93cygpLnRoZW4odWVmaSA9PiB7XG4gICAgICAgICAgICAgIHJlc3VsdC51ZWZpID0gdWVmaTtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm9zSW5mbyA9IG9zSW5mbztcblxuZnVuY3Rpb24gaXNVZWZpTGludXgoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgZnMuc3RhdCgnL3N5cy9maXJtd2FyZS9lZmknLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhlYygnZG1lc2cgfCBncmVwIC1FIFwiRUZJIHZcIicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5lcy5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1VlZmlXaW5kb3dzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV4ZWMoJ2ZpbmRzdHIgL0M6XCJEZXRlY3RlZCBib290IGVudmlyb25tZW50XCIgXCIld2luZGlyJVxcXFxQYW50aGVyXFxcXHNldHVwYWN0LmxvZ1wiJywgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxccicpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2VmaScpID49IDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdlY2hvICVmaXJtd2FyZV90eXBlJScsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gc3Rkb3V0LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2VmaScpID49IDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdmVyc2lvbnMoYXBwcywgY2FsbGJhY2spIHtcbiAgbGV0IHZlcnNpb25PYmplY3QgPSB7XG4gICAga2VybmVsOiBvcy5yZWxlYXNlKCksXG4gICAgb3BlbnNzbDogJycsXG4gICAgc3lzdGVtT3BlbnNzbDogJycsXG4gICAgc3lzdGVtT3BlbnNzbExpYjogJycsXG4gICAgbm9kZTogcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLFxuICAgIHY4OiBwcm9jZXNzLnZlcnNpb25zLnY4LFxuICAgIG5wbTogJycsXG4gICAgeWFybjogJycsXG4gICAgcG0yOiAnJyxcbiAgICBndWxwOiAnJyxcbiAgICBncnVudDogJycsXG4gICAgZ2l0OiAnJyxcbiAgICB0c2M6ICcnLFxuICAgIG15c3FsOiAnJyxcbiAgICByZWRpczogJycsXG4gICAgbW9uZ29kYjogJycsXG4gICAgYXBhY2hlOiAnJyxcbiAgICBuZ2lueDogJycsXG4gICAgcGhwOiAnJyxcbiAgICBkb2NrZXI6ICcnLFxuICAgIHBvc3RmaXg6ICcnLFxuICAgIHBvc3RncmVzcWw6ICcnLFxuICAgIHBlcmw6ICcnLFxuICAgIHB5dGhvbjogJycsXG4gICAgcHl0aG9uMzogJycsXG4gICAgcGlwOiAnJyxcbiAgICBwaXAzOiAnJyxcbiAgICBqYXZhOiAnJyxcbiAgICBnY2M6ICcnLFxuICAgIHZpcnR1YWxib3g6ICcnLFxuICAgIGJhc2g6ICcnLFxuICAgIHpzaDogJycsXG4gICAgZmlzaDogJycsXG4gICAgcG93ZXJzaGVsbDogJycsXG4gICAgZG90bmV0OiAnJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrVmVyc2lvblBhcmFtKGFwcHMpIHtcbiAgICBpZiAoYXBwcyA9PT0gJyonKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uczogdmVyc2lvbk9iamVjdCxcbiAgICAgICAgY291bnRlcjogMzBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcHBzKSkge1xuICAgICAgYXBwcyA9IGFwcHMudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLCsvZywgJ3wnKS5yZXBsYWNlKC8gL2csICd8Jyk7XG4gICAgICBhcHBzID0gYXBwcy5zcGxpdCgnfCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB2ZXJzaW9uczoge30sXG4gICAgICAgIGNvdW50ZXI6IDBcbiAgICAgIH07XG4gICAgICBhcHBzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdmVyc2lvbk9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbk9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGVsLnRvTG93ZXJDYXNlKCkgJiYgIXt9Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LnZlcnNpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb25zW2tleV0gPSB2ZXJzaW9uT2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29wZW5zc2wnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbnMuc3lzdGVtT3BlbnNzbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb25zLnN5c3RlbU9wZW5zc2xMaWIgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uc1trZXldKSB7IHJlc3VsdC5jb3VudGVyKys7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKHV0aWwuaXNGdW5jdGlvbihhcHBzKSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcHBzO1xuICAgICAgICBhcHBzID0gJyonO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwcyA9IGFwcHMgfHwgJyonO1xuICAgICAgICBpZiAodHlwZW9mIGFwcHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHt9KTsgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYXBwc09iaiA9IGNoZWNrVmVyc2lvblBhcmFtKGFwcHMpO1xuICAgICAgbGV0IHRvdGFsRnVuY3Rpb25zID0gYXBwc09iai5jb3VudGVyO1xuXG4gICAgICBsZXQgZnVuY3Rpb25Qcm9jZXNzZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICgtLXRvdGFsRnVuY3Rpb25zID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soYXBwc09iai52ZXJzaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGFwcHNPYmoudmVyc2lvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG5cbiAgICAgIGxldCBjbWQgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdvcGVuc3NsJykpIHtcbiAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm9wZW5zc2wgPSBwcm9jZXNzLnZlcnNpb25zLm9wZW5zc2w7XG4gICAgICAgICAgZXhlYygnb3BlbnNzbCB2ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IG9wZW5zc2xfc3RyaW5nID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgbGV0IG9wZW5zc2wgPSBvcGVuc3NsX3N0cmluZy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnN5c3RlbU9wZW5zc2wgPSBvcGVuc3NsLmxlbmd0aCA+IDAgPyBvcGVuc3NsWzFdIDogb3BlbnNzbFswXTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5zeXN0ZW1PcGVuc3NsTGliID0gb3BlbnNzbC5sZW5ndGggPiAwID8gb3BlbnNzbFswXSA6ICdvcGVuc3NsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ25wbScpKSB7XG4gICAgICAgICAgZXhlYygnbnBtIC12JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5ucG0gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwbTInKSkge1xuICAgICAgICAgIGNtZCA9ICdwbTInO1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgY21kICs9ICcuY21kJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYyhgJHtjbWR9IC12YCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IHBtMiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS50cmltKCk7XG4gICAgICAgICAgICAgIGlmICghcG0yLnN0YXJ0c1dpdGgoJ1tQTTJdJykpIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBtMiA9IHBtMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAneWFybicpKSB7XG4gICAgICAgICAgZXhlYygneWFybiAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnlhcm4gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdndWxwJykpIHtcbiAgICAgICAgICBjbWQgPSAnZ3VscCc7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICBjbWQgKz0gJy5jbWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjKGAke2NtZH0gLS12ZXJzaW9uYCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3VscCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5ndWxwID0gKGd1bHAudG9Mb3dlckNhc2UoKS5zcGxpdCgndmVyc2lvbicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICd0c2MnKSkge1xuICAgICAgICAgIGNtZCA9ICd0c2MnO1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgY21kICs9ICcuY21kJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYyhgJHtjbWR9IC0tdmVyc2lvbmAsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRzYyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy50c2MgPSAodHNjLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24nKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZ3J1bnQnKSkge1xuICAgICAgICAgIGNtZCA9ICdncnVudCc7XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICBjbWQgKz0gJy5jbWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleGVjKGAke2NtZH0gLS12ZXJzaW9uYCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3J1bnQgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ3J1bnQgPSAoZ3J1bnQudG9Mb3dlckNhc2UoKS5zcGxpdCgnY2xpIHYnKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZ2l0JykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvdXNyL2xvY2FsL0NlbGxhci9naXQnKSB8fCBmcy5leGlzdHNTeW5jKCcvb3B0L2hvbWVicmV3L2Jpbi9naXQnKTtcbiAgICAgICAgICAgIGlmICh1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkgfHwgZ2l0SG9tZWJyZXdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgZXhlYygnZ2l0IC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGdpdCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIGdpdCA9IChnaXQudG9Mb3dlckNhc2UoKS5zcGxpdCgndmVyc2lvbicpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmdpdCA9IChnaXQuc3BsaXQoJyAnKVswXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ2dpdCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdpdCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBnaXQgPSAoZ2l0LnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24nKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ2l0ID0gKGdpdC5zcGxpdCgnICcpWzBdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnYXBhY2hlJykpIHtcbiAgICAgICAgICBleGVjKCdhcGFjaGVjdGwgLXYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFwYWNoZSA9IChzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJycpLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuYXBhY2hlID0gKGFwYWNoZS5sZW5ndGggPiAxID8gYXBhY2hlWzFdLnJlcGxhY2UoJ0FwYWNoZScsICcnKS5yZXBsYWNlKCcvJywgJycpLnNwbGl0KCcoJylbMF0udHJpbSgpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnbmdpbngnKSkge1xuICAgICAgICAgIGV4ZWMoJ25naW54IC12IDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBuZ2lueCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5uZ2lueCA9IChuZ2lueC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ215c3FsJykpIHtcbiAgICAgICAgICBleGVjKCdteXNxbCAtVicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBteXNxbCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgbXlzcWwgPSBteXNxbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAobXlzcWwuaW5kZXhPZignLCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBteXNxbCA9IChteXNxbC5zcGxpdCgnLCcpWzBdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBteXNxbC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMubXlzcWwgPSAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobXlzcWwuaW5kZXhPZignIHZlciAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBteXNxbCA9IG15c3FsLnNwbGl0KCcgdmVyICcpWzFdO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5teXNxbCA9IG15c3FsLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwaHAnKSkge1xuICAgICAgICAgIGV4ZWMoJ3BocCAtdicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBocCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgbGV0IHBhcnRzID0gcGhwLnNwbGl0KCcoJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXS5pbmRleE9mKCctJykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5waHAgPSBwYXJ0c1swXS5yZXBsYWNlKC9bXjAtOS5dL2csICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3JlZGlzJykpIHtcbiAgICAgICAgICBleGVjKCdyZWRpcy1zZXJ2ZXIgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVkaXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcmVkaXMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5yZWRpcyA9IHV0aWwuZ2V0VmFsdWUocGFydHMsICd2JywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2RvY2tlcicpKSB7XG4gICAgICAgICAgZXhlYygnZG9ja2VyIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvY2tlciA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBkb2NrZXIuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5kb2NrZXIgPSBwYXJ0cy5sZW5ndGggPiAyICYmIHBhcnRzWzJdLmVuZHNXaXRoKCcsJykgPyBwYXJ0c1syXS5zbGljZSgwLCAtMSkgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3Bvc3RmaXgnKSkge1xuICAgICAgICAgIGV4ZWMoJ3Bvc3Rjb25mIC1kIHwgZ3JlcCBtYWlsX3ZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBwb3N0Zml4ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpIHx8IFtdO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RmaXggPSB1dGlsLmdldFZhbHVlKHBvc3RmaXgsICdtYWlsX3ZlcnNpb24nLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnbW9uZ29kYicpKSB7XG4gICAgICAgICAgZXhlYygnbW9uZ29kIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vbmdvZGIgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMubW9uZ29kYiA9IChtb25nb2RiLnRvTG93ZXJDYXNlKCkuc3BsaXQoJywnKVswXSB8fCAnJykucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwb3N0Z3Jlc3FsJykpIHtcbiAgICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgICBleGVjKCdsb2NhdGUgYmluL3Bvc3RncmVzJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzcWxCaW4gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuc29ydCgpO1xuICAgICAgICAgICAgICAgIGlmIChwb3N0Z3Jlc3FsQmluLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZXhlYyhwb3N0Z3Jlc3FsQmluW3Bvc3RncmVzcWxCaW4ubGVuZ3RoIC0gMV0gKyAnIC1WJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzcWwgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0uc3BsaXQoJyAnKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwgPSBwb3N0Z3Jlc3FsLmxlbmd0aCA/IHBvc3RncmVzcWxbcG9zdGdyZXNxbC5sZW5ndGggLSAxXSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlYygncHNxbCAtVicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzcWwgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0uc3BsaXQoJyAnKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsID0gcG9zdGdyZXNxbC5sZW5ndGggPyBwb3N0Z3Jlc3FsW3Bvc3RncmVzcWwubGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsID0gYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1NlcnZpY2UgfCBzZWxlY3QgY2FwdGlvbiB8IGZsJykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcnZpY2VTZWN0aW9ucyA9IHN0ZG91dC5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICAgIHNlcnZpY2VTZWN0aW9ucy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGl0ZW0udHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNydkNhcHRpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2FwdGlvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNydkNhcHRpb24uaW5kZXhPZigncG9zdGdyZXNxbCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHNydkNhcHRpb24uc3BsaXQoJyBzZXJ2ZXIgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbCA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhlYygncG9zdGdyZXMgLVYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzcWwgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0uc3BsaXQoJyAnKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbCA9IHBvc3RncmVzcWwubGVuZ3RoID8gcG9zdGdyZXNxbFtwb3N0Z3Jlc3FsLmxlbmd0aCAtIDFdIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncGVybCcpKSB7XG4gICAgICAgICAgZXhlYygncGVybCAtdicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBlcmwgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykgfHwgJyc7XG4gICAgICAgICAgICAgIHdoaWxlIChwZXJsLmxlbmd0aCA+IDAgJiYgcGVybFswXS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcGVybC5zaGlmdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwZXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBlcmwgPSBwZXJsWzBdLnNwbGl0KCcoJykucG9wKCkuc3BsaXQoJyknKVswXS5yZXBsYWNlKCd2JywgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdweXRob24nKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnc3dfdmVycycpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBvc1ZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvZHVjdFZlcnNpb24nLCAnOicpO1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMxID0gZnMuZXhpc3RzU3luYygnL3Vzci9sb2NhbC9DZWxsYXIvcHl0aG9uJyk7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0czIgPSBmcy5leGlzdHNTeW5jKCcvb3B0L2hvbWVicmV3L2Jpbi9weXRob24nKTtcbiAgICAgICAgICAgIGlmICgodXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpICYmIHV0aWwuc2VtdmVyQ29tcGFyZSgnMTIuMC4xJywgb3NWZXJzaW9uKSA8IDApIHx8IGdpdEhvbWVicmV3RXhpc3RzMSB8fCBnaXRIb21lYnJld0V4aXN0czIpIHtcbiAgICAgICAgICAgICAgY29uc3QgY21kID0gZ2l0SG9tZWJyZXdFeGlzdHMxID8gJy91c3IvbG9jYWwvQ2VsbGFyL3B5dGhvbiAtViAyPiYxJyA6IChnaXRIb21lYnJld0V4aXN0czIgPyAnL29wdC9ob21lYnJldy9iaW4vcHl0aG9uIC1WIDI+JjEnIDogJ3B5dGhvbiAtViAyPiYxJyk7XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucHl0aG9uID0gcHl0aG9uLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncHl0aG9uJywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdweXRob24gLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBweXRob24gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5weXRob24gPSBweXRob24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdweXRob24nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3B5dGhvbjMnKSkge1xuICAgICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgICBjb25zdCBnaXRIb21lYnJld0V4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy91c3IvbG9jYWwvQ2VsbGFyL3B5dGhvbjMnKSB8fCBmcy5leGlzdHNTeW5jKCcvb3B0L2hvbWVicmV3L2Jpbi9weXRob24zJyk7XG4gICAgICAgICAgICBpZiAodXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpIHx8IGdpdEhvbWVicmV3RXhpc3RzKSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ3B5dGhvbjMgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5weXRob24zID0gcHl0aG9uLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncHl0aG9uJywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdweXRob24zIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucHl0aG9uMyA9IHB5dGhvbi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3B5dGhvbicsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncGlwJykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvdXNyL2xvY2FsL0NlbGxhci9waXAnKSB8fCBmcy5leGlzdHNTeW5jKCcvb3B0L2hvbWVicmV3L2Jpbi9waXAnKTtcbiAgICAgICAgICAgIGlmICh1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkgfHwgZ2l0SG9tZWJyZXdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgZXhlYygncGlwIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBpcCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcGlwLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBpcCA9IHBhcnRzLmxlbmd0aCA+PSAyID8gcGFydHNbMV0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdwaXAgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBwaXAuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBpcCA9IHBhcnRzLmxlbmd0aCA+PSAyID8gcGFydHNbMV0gOiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwaXAzJykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvdXNyL2xvY2FsL0NlbGxhci9waXAzJykgfHwgZnMuZXhpc3RzU3luYygnL29wdC9ob21lYnJldy9iaW4vcGlwMycpO1xuICAgICAgICAgICAgaWYgKHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSB8fCBnaXRIb21lYnJld0V4aXN0cykge1xuICAgICAgICAgICAgICBleGVjKCdwaXAzIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBpcCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcGlwLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBpcDMgPSBwYXJ0cy5sZW5ndGggPj0gMiA/IHBhcnRzWzFdIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygncGlwMyAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpcCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBpcC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGlwMyA9IHBhcnRzLmxlbmd0aCA+PSAyID8gcGFydHNbMV0gOiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdqYXZhJykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYW55IEpWTSBpcyBpbnN0YWxsZWQgYnV0IGF2b2lkIGRpYWxvZyBib3ggdGhhdCBKYXZhIG5lZWRzIHRvIGJlIGluc3RhbGxlZFxuICAgICAgICAgICAgZXhlYygnL3Vzci9saWJleGVjL2phdmFfaG9tZSAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvciAmJiBzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ25vIGphdmEgcnVudGltZScpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdyB0aGlzIGNhbiBiZSBkb25lIHNhdmVseVxuICAgICAgICAgICAgICAgIGV4ZWMoJ2phdmEgLXZlcnNpb24gMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGphdmEgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gamF2YS5zcGxpdCgnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5qYXZhID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFydHNbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdqYXZhIC12ZXJzaW9uIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgamF2YSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGphdmEuc3BsaXQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5qYXZhID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFydHNbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZ2NjJykpIHtcbiAgICAgICAgICBpZiAoKF9kYXJ3aW4gJiYgdXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpKSB8fCAhX2Rhcndpbikge1xuICAgICAgICAgICAgZXhlYygnZ2NjIC1kdW1wdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmdjYyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS50cmltKCkgfHwgJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFwcHNPYmoudmVyc2lvbnMuZ2NjLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGVjKCdnY2MgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2NjID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdjYy5pbmRleE9mKCdnY2MnKSA+IC0xICYmIGdjYy5pbmRleE9mKCcpJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZ2NjLnNwbGl0KCcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5nY2MgPSBwYXJ0c1sxXS50cmltKCkgfHwgYXBwc09iai52ZXJzaW9ucy5nY2M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAndmlydHVhbGJveCcpKSB7XG4gICAgICAgICAgZXhlYyh1dGlsLmdldFZib3htYW5hZ2UoKSArICcgLXYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZib3ggPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdmJveC5zcGxpdCgncicpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnZpcnR1YWxib3ggPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2Jhc2gnKSkge1xuICAgICAgICAgIGV4ZWMoJ2Jhc2ggLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgdmVyc2lvbiAnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmJhc2ggPSBwYXJ0c1sxXS5zcGxpdCgnICcpWzBdLnNwbGl0KCcoJylbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3pzaCcpKSB7XG4gICAgICAgICAgZXhlYygnenNoIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnenNoICcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuenNoID0gcGFydHNbMV0uc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZmlzaCcpKSB7XG4gICAgICAgICAgZXhlYygnZmlzaCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyB2ZXJzaW9uICcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZmlzaCA9IHBhcnRzWzFdLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3Bvd2Vyc2hlbGwnKSkge1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCckUFNWZXJzaW9uVGFibGUnKS50aGVuKHN0ZG91dCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5yZXBsYWNlKC8gKy9nLCAnOicpKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3dlcnNoZWxsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3BzdmVyc2lvbicpO1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdkb3RuZXQnKSkge1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdnY2kgXCJIS0xNOlxcXFxTT0ZUV0FSRVxcXFxNaWNyb3NvZnRcXFxcTkVUIEZyYW1ld29yayBTZXR1cFxcXFxORFBcIiAtcmVjdXJzZSB8IGdwIC1uYW1lIFZlcnNpb24sUmVsZWFzZSAtRUEgMCB8IHdoZXJlIHsgJF8uUFNDaGlsZE5hbWUgLW1hdGNoIFwiXig/IVMpXFxcXHB7TH1cIn0gfCBzZWxlY3QgUFNDaGlsZE5hbWUsIFZlcnNpb24sIFJlbGVhc2UnKS50aGVuKHN0ZG91dCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBsZXQgZG90bmV0ID0gJyc7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBkb3RuZXQgPSBkb3RuZXQgfHwgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnY2xpZW50JykgJiYgcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzFdLnRyaW0oKSA6IChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Z1bGwnKSAmJiBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMV0udHJpbSgpIDogJycpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZG90bmV0ID0gZG90bmV0LnRyaW0oKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soYXBwc09iai52ZXJzaW9ucyk7IH1cbiAgICAgICAgcmVzb2x2ZShhcHBzT2JqLnZlcnNpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMudmVyc2lvbnMgPSB2ZXJzaW9ucztcblxuZnVuY3Rpb24gc2hlbGwoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgcmVzb2x2ZSgnY21kJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGV4ZWMoJ2VjaG8gJFNIRUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuc2hlbGwgPSBzaGVsbDtcblxuZnVuY3Rpb24gZ2V0VW5pcXVlTWFjQWRyZXNzZXMoKSB7XG4gIGxldCBtYWNzID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgaWZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcbiAgICBmb3IgKGxldCBkZXYgaW4gaWZhY2VzKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIGRldikpIHtcbiAgICAgICAgaWZhY2VzW2Rldl0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMubWFjICYmIGRldGFpbHMubWFjICE9PSAnMDA6MDA6MDA6MDA6MDA6MDAnKSB7XG4gICAgICAgICAgICBjb25zdCBtYWMgPSBkZXRhaWxzLm1hYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG1hY3MuaW5kZXhPZihtYWMpID09PSAtMSkge1xuICAgICAgICAgICAgICBtYWNzLnB1c2gobWFjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBtYWNzID0gbWFjcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYSA8IGIpIHsgcmV0dXJuIC0xOyB9XG4gICAgICBpZiAoYSA+IGIpIHsgcmV0dXJuIDE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbWFjcy5wdXNoKCcwMDowMDowMDowMDowMDowMCcpO1xuICB9XG4gIHJldHVybiBtYWNzO1xufVxuXG5mdW5jdGlvbiB1dWlkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBvczogJycsXG4gICAgICAgIGhhcmR3YXJlOiAnJyxcbiAgICAgICAgbWFjczogZ2V0VW5pcXVlTWFjQWRyZXNzZXMoKVxuICAgICAgfTtcbiAgICAgIGxldCBwYXJ0cztcblxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3lzdGVtX3Byb2ZpbGVyIFNQSGFyZHdhcmVEYXRhVHlwZSAtanNvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QganNvbk9iaiA9IEpTT04ucGFyc2Uoc3Rkb3V0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAoanNvbk9iai5TUEhhcmR3YXJlRGF0YVR5cGUgJiYganNvbk9iai5TUEhhcmR3YXJlRGF0YVR5cGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwSGFyZHdhcmUgPSBqc29uT2JqLlNQSGFyZHdhcmVEYXRhVHlwZVswXTtcbiAgICAgICAgICAgICAgICByZXN1bHQub3MgPSBzcEhhcmR3YXJlLnBsYXRmb3JtX1VVSUQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGFyZHdhcmUgPSBzcEhhcmR3YXJlLnNlcmlhbF9udW1iZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJvczogXCI7IGNhdCAvdmFyL2xpYi9kYnVzL21hY2hpbmUtaWQgMj4gL2Rldi9udWxsOyBlY2hvO1xuZWNobyAtbiBcIm9zOiBcIjsgY2F0IC9ldGMvbWFjaGluZS1pZCAyPiAvZGV2L251bGw7IGVjaG87XG5lY2hvIC1uIFwiaGFyZHdhcmU6IFwiOyBjYXQgL3N5cy9jbGFzcy9kbWkvaWQvcHJvZHVjdF91dWlkIDI+IC9kZXYvbnVsbDsgZWNobztgO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQub3MgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnb3MnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJlc3VsdC5oYXJkd2FyZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdoYXJkd2FyZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQuaGFyZHdhcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZnMucmVhZEZpbGVTeW5jKCcvcHJvYy9jcHVpbmZvJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbCcpO1xuICAgICAgICAgICAgcmVzdWx0LmhhcmR3YXJlID0gc2VyaWFsIHx8ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdzeXNjdGwgLWkga2Vybi5ob3N0aWQga2Vybi5ob3N0dXVpZCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0Lm9zID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4uaG9zdGlkJywgJzonKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJlc3VsdC5oYXJkd2FyZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLmhvc3R1dWlkJywgJzonKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQub3MuaW5kZXhPZigndW5rbm93bicpID49IDApIHsgcmVzdWx0Lm9zID0gJyc7IH1cbiAgICAgICAgICBpZiAocmVzdWx0LmhhcmR3YXJlLmluZGV4T2YoJ3Vua25vd24nKSA+PSAwKSB7IHJlc3VsdC5oYXJkd2FyZSA9ICcnOyB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIGxldCBzeXNkaXIgPSAnJXdpbmRpciVcXFxcU3lzdGVtMzInO1xuICAgICAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnaWEzMicgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3MuZW52LCAnUFJPQ0VTU09SX0FSQ0hJVEVXNjQzMicpKSB7XG4gICAgICAgICAgc3lzZGlyID0gJyV3aW5kaXIlXFxcXHN5c25hdGl2ZVxcXFxjbWQuZXhlIC9jICV3aW5kaXIlXFxcXFN5c3RlbTMyJztcbiAgICAgICAgfVxuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Db21wdXRlclN5c3RlbVByb2R1Y3QgfCBzZWxlY3QgVVVJRCB8IGZsJykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICByZXN1bHQuaGFyZHdhcmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndXVpZCcsICc6JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBleGVjKGAke3N5c2Rpcn1cXFxccmVnIHF1ZXJ5IFwiSEtFWV9MT0NBTF9NQUNISU5FXFxcXFNPRlRXQVJFXFxcXE1pY3Jvc29mdFxcXFxDcnlwdG9ncmFwaHlcIiAvdiBNYWNoaW5lR3VpZGAsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG5cXHInKVswXS5zcGxpdCgnUkVHX1NaJyk7XG4gICAgICAgICAgICByZXN1bHQub3MgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0ucmVwbGFjZSgvXFxyK3xcXG4rfFxccysvaWcsICcnKS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnV1aWQgPSB1dWlkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBwcmludGVycy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDE1LiBwcmludGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5jb25zdCB3aW5QcmludGVyU3RhdHVzID0ge1xuICAxOiAnT3RoZXInLFxuICAyOiAnVW5rbm93bicsXG4gIDM6ICdJZGxlJyxcbiAgNDogJ1ByaW50aW5nJyxcbiAgNTogJ1dhcm11cCcsXG4gIDY6ICdTdG9wcGVkIFByaW50aW5nJyxcbiAgNzogJ09mZmxpbmUnLFxufTtcblxuZnVuY3Rpb24gcGFyc2VMaW51eEN1cHNIZWFkZXIobGluZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGlmIChsaW5lcyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICBpZiAobGluZXNbMF0uaW5kZXhPZignIENVUFMgdicpID4gMCkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zcGxpdCgnIENVUFMgdicpO1xuICAgICAgcmVzdWx0LmN1cHNWZXJzaW9uID0gcGFydHNbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhDdXBzUHJpbnRlcihsaW5lcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgcHJpbnRlcklkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ByaW50ZXJJZCcsICcgJyk7XG4gIHJlc3VsdC5pZCA9IHByaW50ZXJJZCA/IHBhcnNlSW50KHByaW50ZXJJZCwgMTApIDogbnVsbDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW5mbycsICcgJyk7XG4gIHJlc3VsdC5tb2RlbCA9IGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbMF0gPyBsaW5lc1swXS5zcGxpdCgnICcpWzBdIDogJyc7XG4gIHJlc3VsdC51cmkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGV2aWNlVVJJJywgJyAnKTtcbiAgcmVzdWx0LnV1aWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVVVJRCcsICcgJyk7XG4gIHJlc3VsdC5zdGF0dXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhdGUnLCAnICcpO1xuICByZXN1bHQubG9jYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9jYXRpb24nLCAnICcpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbG9jYWwnKTtcbiAgcmVzdWx0LmRlZmF1bHQgPSBudWxsO1xuICByZXN1bHQuc2hhcmVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NoYXJlZCcsICcgJykudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd5ZXMnKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4THBzdGF0UHJpbnRlcihsaW5lcywgaWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHJlc3VsdC5pZCA9IGlkO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXNjcmlwdGlvbicsICc6JywgdHJ1ZSk7XG4gIHJlc3VsdC5tb2RlbCA9IGxpbmVzLmxlbmd0aCA+IDAgJiYgbGluZXNbMF0gPyBsaW5lc1swXS5zcGxpdCgnICcpWzBdIDogJyc7XG4gIHJlc3VsdC51cmkgPSBudWxsO1xuICByZXN1bHQudXVpZCA9IG51bGw7XG4gIHJlc3VsdC5zdGF0dXMgPSBsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzWzBdID8gKGxpbmVzWzBdLmluZGV4T2YoJyBpZGxlJykgPiAwID8gJ2lkbGUnIDogKGxpbmVzWzBdLmluZGV4T2YoJyBwcmludGluZycpID4gMCA/ICdwcmludGluZycgOiAndW5rbm93bicpKSA6IG51bGw7XG4gIHJlc3VsdC5sb2NhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb2NhdGlvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdsb2NhbCcpO1xuICByZXN1bHQuZGVmYXVsdCA9IG51bGw7XG4gIHJlc3VsdC5zaGFyZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2hhcmVkJywgJyAnKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3llcycpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGFyd2luUHJpbnRlcnMocHJpbnRlck9iamVjdCwgaWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHVyaVBhcnRzID0gcHJpbnRlck9iamVjdC51cmkuc3BsaXQoJy8nKTtcbiAgcmVzdWx0LmlkID0gaWQ7XG4gIHJlc3VsdC5uYW1lID0gcHJpbnRlck9iamVjdC5fbmFtZTtcbiAgcmVzdWx0Lm1vZGVsID0gdXJpUGFydHMubGVuZ3RoID8gdXJpUGFydHNbdXJpUGFydHMubGVuZ3RoIC0gMV0gOiAnJztcbiAgcmVzdWx0LnVyaSA9IHByaW50ZXJPYmplY3QudXJpO1xuICByZXN1bHQudXVpZCA9IG51bGw7XG4gIHJlc3VsdC5zdGF0dXMgPSBwcmludGVyT2JqZWN0LnN0YXR1cztcbiAgcmVzdWx0LmxvY2FsID0gcHJpbnRlck9iamVjdC5wcmludHNlcnZlciA9PT0gJ2xvY2FsJztcbiAgcmVzdWx0LmRlZmF1bHQgPSBwcmludGVyT2JqZWN0LmRlZmF1bHQgPT09ICd5ZXMnO1xuICByZXN1bHQuc2hhcmVkID0gcHJpbnRlck9iamVjdC5zaGFyZWQgPT09ICd5ZXMnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luZG93c1ByaW50ZXJzKGxpbmVzLCBpZCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgc3RhdHVzID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ByaW50ZXJTdGF0dXMnLCAnOicpLCAxMCk7XG5cbiAgcmVzdWx0LmlkID0gaWQ7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpO1xuICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRHJpdmVyTmFtZScsICc6Jyk7XG4gIHJlc3VsdC51cmkgPSBudWxsO1xuICByZXN1bHQudXVpZCA9IG51bGw7XG4gIHJlc3VsdC5zdGF0dXMgPSB3aW5QcmludGVyU3RhdHVzW3N0YXR1c10gPyB3aW5QcmludGVyU3RhdHVzW3N0YXR1c10gOiBudWxsO1xuICByZXN1bHQubG9jYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9jYWwnLCAnOicpLnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJztcbiAgcmVzdWx0LmRlZmF1bHQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVmYXVsdCcsICc6JykudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnO1xuICByZXN1bHQuc2hhcmVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NoYXJlZCcsICc6JykudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHByaW50ZXIoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBsZXQgY21kID0gJ2NhdCAvZXRjL2N1cHMvcHJpbnRlcnMuY29uZiAyPi9kZXYvbnVsbCc7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIC8vIHByaW50ZXJzLmNvbmZcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCc8UHJpbnRlciAnKTtcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZXJIZWFkZXIgPSBwYXJzZUxpbnV4Q3Vwc0hlYWRlcihwYXJ0c1swXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaW50ZXJzID0gcGFyc2VMaW51eEN1cHNQcmludGVyKHBhcnRzW2ldLnNwbGl0KCdcXG4nKSk7XG4gICAgICAgICAgICAgIGlmIChwcmludGVycy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRlcnMuZW5naW5lID0gJ0NVUFMnO1xuICAgICAgICAgICAgICAgIHByaW50ZXJzLmVuZ2luZVZlcnNpb24gPSBwcmludGVySGVhZGVyLmN1cHNWZXJzaW9uO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByaW50ZXJzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgICAgICBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBscHN0YXQgLWxwIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnO1xuICAgICAgICAgICAgICAvLyBscHN0YXRcbiAgICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSAoJ1xcbicgKyBzdGRvdXQudG9TdHJpbmcoKSkuc3BsaXQoJ1xcbnByaW50ZXIgJyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbnRlcnMgPSBwYXJzZUxpbnV4THBzdGF0UHJpbnRlcihwYXJ0c1tpXS5zcGxpdCgnXFxuJyksIGkpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJpbnRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciBTUFByaW50ZXJzRGF0YVR5cGUgLWpzb24nO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvdXRPYmogPSBKU09OLnBhcnNlKHN0ZG91dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgaWYgKG91dE9iai5TUFByaW50ZXJzRGF0YVR5cGUgJiYgb3V0T2JqLlNQUHJpbnRlcnNEYXRhVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dE9iai5TUFByaW50ZXJzRGF0YVR5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW50ZXIgPSBwYXJzZURhcndpblByaW50ZXJzKG91dE9iai5TUFByaW50ZXJzRGF0YVR5cGVbaV0sIGkpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJpbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUHJpbnRlciB8IHNlbGVjdCBQcmludGVyU3RhdHVzLE5hbWUsRHJpdmVyTmFtZSxMb2NhbCxEZWZhdWx0LFNoYXJlZCB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpbnRlciA9IHBhcnNlV2luZG93c1ByaW50ZXJzKHBhcnRzW2ldLnNwbGl0KCdcXG4nKSwgaSk7XG4gICAgICAgICAgICAgIGlmIChwcmludGVyLm5hbWUgfHwgcHJpbnRlci5tb2RlbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByaW50ZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucHJpbnRlciA9IHByaW50ZXI7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHByb2Nlc3Nlcy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDEwLiBQcm9jZXNzZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5jb25zdCBfcHJvY2Vzc2VzX2NwdSA9IHtcbiAgYWxsOiAwLFxuICBhbGxfdXRpbWU6IDAsXG4gIGFsbF9zdGltZTogMCxcbiAgbGlzdDoge30sXG4gIG1zOiAwLFxuICByZXN1bHQ6IHt9XG59O1xuY29uc3QgX3NlcnZpY2VzX2NwdSA9IHtcbiAgYWxsOiAwLFxuICBhbGxfdXRpbWU6IDAsXG4gIGFsbF9zdGltZTogMCxcbiAgbGlzdDoge30sXG4gIG1zOiAwLFxuICByZXN1bHQ6IHt9XG59O1xuY29uc3QgX3Byb2Nlc3NfY3B1ID0ge1xuICBhbGw6IDAsXG4gIGFsbF91dGltZTogMCxcbiAgYWxsX3N0aW1lOiAwLFxuICBsaXN0OiB7fSxcbiAgbXM6IDAsXG4gIHJlc3VsdDoge31cbn07XG5cbmNvbnN0IF93aW5TdGF0dXNWYWx1ZXMgPSB7XG4gICcwJzogJ3Vua25vd24nLFxuICAnMSc6ICdvdGhlcicsXG4gICcyJzogJ3JlYWR5JyxcbiAgJzMnOiAncnVubmluZycsXG4gICc0JzogJ2Jsb2NrZWQnLFxuICAnNSc6ICdzdXNwZW5kZWQgYmxvY2tlZCcsXG4gICc2JzogJ3N1c3BlbmRlZCByZWFkeScsXG4gICc3JzogJ3Rlcm1pbmF0ZWQnLFxuICAnOCc6ICdzdG9wcGVkJyxcbiAgJzknOiAnZ3Jvd2luZycsXG59O1xuXG5mdW5jdGlvbiBwYXJzZVRpbWVVbml4KHRpbWUpIHtcbiAgbGV0IHJlc3VsdCA9IHRpbWU7XG4gIGxldCBwYXJ0cyA9IHRpbWUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSA1KSB7XG4gICAgcmVzdWx0ID0gcGFydHNbNF0gKyAnLScgKyAoJzAnICsgKCdKQU5GRUJNQVJBUFJNQVlKVU5KVUxBVUdTRVBPQ1ROT1ZERUMnLmluZGV4T2YocGFydHNbMV0udG9VcHBlckNhc2UoKSkgLyAzICsgMSkpLnNsaWNlKC0yKSArICctJyArICgnMCcgKyBwYXJ0c1syXSkuc2xpY2UoLTIpICsgJyAnICsgcGFydHNbM107XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VFbGFwc2VkVGltZShldGltZSkge1xuICBsZXQgY3VycmVudCA9IG5ldyBEYXRlKCk7XG4gIGN1cnJlbnQgPSBuZXcgRGF0ZShjdXJyZW50LmdldFRpbWUoKSAtIGN1cnJlbnQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcblxuICBjb25zdCBlbGFwc2VkID0gZXRpbWUuc3BsaXQoJy0nKTtcblxuICBjb25zdCB0aW1lSW5kZXggPSBlbGFwc2VkLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGRheXMgPSB0aW1lSW5kZXggPiAwID8gcGFyc2VJbnQoZWxhcHNlZFt0aW1lSW5kZXggLSAxXSkgOiAwO1xuXG4gIGNvbnN0IHRpbWVTdHIgPSBlbGFwc2VkW3RpbWVJbmRleF0uc3BsaXQoJzonKTtcbiAgY29uc3QgaG91cnMgPSB0aW1lU3RyLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHRpbWVTdHJbMF0gfHwgMCkgOiAwO1xuICBjb25zdCBtaW5zID0gcGFyc2VJbnQodGltZVN0clt0aW1lU3RyLmxlbmd0aCA9PT0gMyA/IDEgOiAwXSB8fCAwKTtcbiAgY29uc3Qgc2VjcyA9IHBhcnNlSW50KHRpbWVTdHJbdGltZVN0ci5sZW5ndGggPT09IDMgPyAyIDogMV0gfHwgMCk7XG4gIGNvbnN0IG1zID0gKCgoKChkYXlzICogMjQgKyBob3VycykgKiA2MCkgKyBtaW5zKSAqIDYwICsgc2VjcykgKiAxMDAwKTtcblxuICBsZXQgcmVzID0gbmV3IERhdGUoY3VycmVudC5nZXRUaW1lKCkpO1xuICBsZXQgcmVzdWx0ID0gcmVzLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKSArICcgJyArIHJlcy50b0lTT1N0cmluZygpLnN1YnN0cmluZygxMSwgMTkpO1xuICB0cnkge1xuICAgIHJlcyA9IG5ldyBEYXRlKGN1cnJlbnQuZ2V0VGltZSgpIC0gbXMpO1xuICAgIHJlc3VsdCA9IHJlcy50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCkgKyAnICcgKyByZXMudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMTEsIDE5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQUyAtIHNlcnZpY2VzXG4vLyBwYXNzIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyB3aXRoIHNlcnZpY2VzIHRvIGNoZWNrIChteXNxbCwgYXBhY2hlLCBwb3N0Z3Jlc3FsLCAuLi4pXG4vLyB0aGlzIGZ1bmN0aW9uIGdpdmVzIGFuIGFycmF5IGJhY2ssIGlmIHRoZSBzZXJ2aWNlcyBhcmUgcnVubmluZy5cblxuZnVuY3Rpb24gc2VydmljZXMoc3J2LCBjYWxsYmFjaykge1xuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHNydikgJiYgIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBzcnY7XG4gICAgc3J2ID0gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygc3J2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soW10pOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNydikge1xuICAgICAgICBsZXQgc3J2U3RyaW5nID0gJyc7XG4gICAgICAgIHNydlN0cmluZy5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgIHNydlN0cmluZy5fX3Byb3RvX18ucmVwbGFjZSA9IHV0aWwuc3RyaW5nUmVwbGFjZTtcbiAgICAgICAgc3J2U3RyaW5nLl9fcHJvdG9fXy50cmltID0gdXRpbC5zdHJpbmdUcmltO1xuXG4gICAgICAgIGNvbnN0IHMgPSB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoc3J2KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3J2U3RyaW5nID0gc3J2U3RyaW5nICsgc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzcnZTdHJpbmcgPSBzcnZTdHJpbmcudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLCAvZywgJ3wnKS5yZXBsYWNlKC8sKy9nLCAnfCcpO1xuICAgICAgICBpZiAoc3J2U3RyaW5nID09PSAnJykge1xuICAgICAgICAgIHNydlN0cmluZyA9ICcqJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgJiYgc3J2U3RyaW5nICE9PSAnKicpIHtcbiAgICAgICAgICBzcnZTdHJpbmcgPSAnLS0tLS0tJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3J2cyA9IHNydlN0cmluZy5zcGxpdCgnfCcpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBkYXRhU3J2ID0gW107XG5cbiAgICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4pIHtcbiAgICAgICAgICBpZiAoKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSAmJiBzcnZTdHJpbmcgPT09ICcqJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdG1wc3J2ID0gZXhlY1N5bmMoJ3N5c3RlbWN0bCAtLWFsbCAtLXR5cGU9c2VydmljZSAtLW5vLWxlZ2VuZCAyPiAvZGV2L251bGwnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgc3J2cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdG1wc3J2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHMuc3BsaXQoJy5zZXJ2aWNlJylbMF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgcy5pbmRleE9mKCcgbm90LWZvdW5kICcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgc3J2cy5wdXNoKG5hbWUudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3J2U3RyaW5nID0gc3J2cy5qb2luKCd8Jyk7XG4gICAgICAgICAgICB9IGNhdGNoIChkKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3J2U3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wc3J2ID0gZXhlY1N5bmMoJ3NlcnZpY2UgLS1zdGF0dXMtYWxsIDI+IC9kZXYvbnVsbCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0bXBzcnYpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcy5zcGxpdCgnXScpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzcnZTdHJpbmcgKz0gKHNydlN0cmluZyAhPT0gJycgPyAnfCcgOiAnJykgKyBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNydnMgPSBzcnZTdHJpbmcuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzcnZTdHIgPSBleGVjU3luYygnbHMgL2V0Yy9pbml0LmQvIC1tIDI+IC9kZXYvbnVsbCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgc3J2U3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICBpZiAoc3J2U3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRtcHNydiA9IHNydlN0ci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdG1wc3J2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHMudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcnZTdHJpbmcgKz0gKHNydlN0cmluZyAhPT0gJycgPyAnfCcgOiAnJykgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcnZzID0gc3J2U3RyaW5nLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICAgICAgICAgICAgc3J2U3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgICBzcnZzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoX2RhcndpbikgJiYgc3J2U3RyaW5nID09PSAnKicpIHsgLy8gc2VydmljZSBlbnVtZXJhdGlvbiBub3QgeWV0IHN1cG9ydGVkIG9uIG1hYyBPU1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGFyZ3MgPSAoX2RhcndpbikgPyBbJy1jYXhvJywgJ3BjcHUscG1lbSxwaWQsY29tbWFuZCddIDogWyctYXhvJywgJ3BjcHUscG1lbSxwaWQsY29tbWFuZCddO1xuICAgICAgICAgIGlmIChzcnZTdHJpbmcgIT09ICcnICYmIHNydnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXRpbC5leGVjU2FmZSgncHMnLCBhcmdzKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5yZXBsYWNlKC8gKy9nLCAnICcpLnJlcGxhY2UoLywrL2csICcuJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHNydnMuZm9yRWFjaChmdW5jdGlvbiAoc3J2KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgcHM7XG4gICAgICAgICAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgICAgICAgICBwcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3J2KSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgJyArIHNydiArICc6JykgIT09IC0xKSB8fCAoZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy8nICsgc3J2KSAhPT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWQgPSBwLnRyaW0oKS5zcGxpdCgnICcpWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGlkcy5wdXNoKHBhcnNlSW50KHBpZCwgMTApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnYsXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IHBzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgIHBpZHM6IHBpZHMsXG4gICAgICAgICAgICAgICAgICAgIGNwdTogcGFyc2VGbG9hdCgocHMucmVkdWNlKGZ1bmN0aW9uIChwdiwgY3YpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHYgKyBwYXJzZUZsb2F0KGN2LnRyaW0oKS5zcGxpdCgnICcpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCkpLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgICAgICAgICBtZW06IHBhcnNlRmxvYXQoKHBzLnJlZHVjZShmdW5jdGlvbiAocHYsIGN2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB2ICsgcGFyc2VGbG9hdChjdi50cmltKCkuc3BsaXQoJyAnKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApKS50b0ZpeGVkKDIpKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgICAgICAgICAgLy8gY2FsYyBwcm9jZXNzX2NwdSAtIHBzIGlzIG5vdCBhY2N1cmF0ZSBpbiBsaW51eCFcbiAgICAgICAgICAgICAgICAgIGxldCBjbWQgPSAnY2F0IC9wcm9jL3N0YXQgfCBncmVwIFwiY3B1IFwiJztcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gcmVzdWx0W2ldLnBpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbWQgKz0gKCc7Y2F0IC9wcm9jLycgKyByZXN1bHRbaV0ucGlkc1tqXSArICcvc3RhdCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3Vycl9wcm9jZXNzZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgbGluZSAoYWxsIC0gL3Byb2Mvc3RhdClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbCA9IHBhcnNlUHJvY1N0YXQoY3Vycl9wcm9jZXNzZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdF9uZXcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFByb2Nlc3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY3Vycl9wcm9jZXNzZXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb2Nlc3MgPSBjYWxjUHJvY1N0YXRMaW51eChlbGVtZW50LCBhbGwsIF9zZXJ2aWNlc19jcHUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFByb2Nlc3MucGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdFBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiBpbiByZXN1bHRbaV0ucGlkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChyZXN1bHRbaV0ucGlkc1tqXSkgPT09IHBhcnNlSW50KHJlc3VsdFByb2Nlc3MucGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFBvcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5jcHUgKz0gcmVzdWx0UHJvY2Vzcy5jcHV1ICsgcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RfbmV3W3Jlc3VsdFByb2Nlc3MucGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3B1dTogcmVzdWx0UHJvY2Vzcy5jcHV1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjcHVzOiByZXN1bHRQcm9jZXNzLmNwdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHV0aW1lOiByZXN1bHRQcm9jZXNzLnV0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGltZTogcmVzdWx0UHJvY2Vzcy5zdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3V0aW1lOiByZXN1bHRQcm9jZXNzLmN1dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3N0aW1lOiByZXN1bHRQcm9jZXNzLmNzdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgX3NlcnZpY2VzX2NwdS5hbGwgPSBhbGw7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJ2aWNlc19jcHUubGlzdCA9IE9iamVjdC5hc3NpZ24oe30sIGxpc3RfbmV3KTtcbiAgICAgICAgICAgICAgICAgICAgX3NlcnZpY2VzX2NwdS5tcyA9IERhdGUubm93KCkgLSBfc2VydmljZXNfY3B1Lm1zO1xuICAgICAgICAgICAgICAgICAgICBfc2VydmljZXNfY3B1LnJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gWyctbycsICdjb21tJ107XG4gICAgICAgICAgICAgICAgdXRpbC5leGVjU2FmZSgncHMnLCBhcmdzKS50aGVuKChzdGRvdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnJlcGxhY2UoLyArL2csICcgJykucmVwbGFjZSgvLCsvZywgJy4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHNydnMuZm9yRWFjaChmdW5jdGlvbiAoc3J2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHBzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pbmRleE9mKHNydikgIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IHBzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcnZzLmZvckVhY2goZnVuY3Rpb24gKHNydikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB3aW5jb21tYW5kID0gJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9TZXJ2aWNlJztcbiAgICAgICAgICAgIGlmIChzcnZzWzBdICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgd2luY29tbWFuZCArPSAnIC1GaWx0ZXIgXCInO1xuICAgICAgICAgICAgICBzcnZzLmZvckVhY2goKHNydikgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmNvbW1hbmQgKz0gYE5hbWU9JyR7c3J2fScgb3IgYDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdpbmNvbW1hbmQgPSBgJHt3aW5jb21tYW5kLnNsaWNlKDAsIC00KX1cImA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5jb21tYW5kICs9ICcgfCBzZWxlY3QgTmFtZSxDYXB0aW9uLFN0YXJ0ZWQsU3RhcnRNb2RlLFByb2Nlc3NJZCB8IGZsJztcbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCh3aW5jb21tYW5kKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VydmljZVNlY3Rpb25zID0gc3Rkb3V0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgc2VydmljZVNlY3Rpb25zLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZWxlbWVudC50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3J2TmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOYW1lJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3J2Q2FwdGlvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXB0aW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGFydGVkJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0TW9kZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTdGFydE1vZGUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2Nlc3NJZCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcnZTdHJpbmcgPT09ICcqJyB8fCBzcnZzLmluZGV4T2Yoc3J2TmFtZSkgPj0gMCB8fCBzcnZzLmluZGV4T2Yoc3J2Q2FwdGlvbikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiAoc3RhcnRlZC50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiBzdGFydE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWRzOiBbcGlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGFTcnYucHVzaChzcnZOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhU3J2LnB1c2goc3J2Q2FwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNydlN0cmluZyAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc3J2c01pc3NpbmcgPSBzcnZzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVNydi5pbmRleE9mKGUpID09PSAtMTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc3J2c01pc3NpbmcuZm9yRWFjaChmdW5jdGlvbiAoc3J2TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3J2cy5mb3JFYWNoKGZ1bmN0aW9uIChzcnZOYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soW10pOyB9XG4gICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuXG5mdW5jdGlvbiBwYXJzZVByb2NTdGF0KGxpbmUpIHtcbiAgbGV0IHBhcnRzID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gIGxldCB1c2VyID0gKHBhcnRzLmxlbmd0aCA+PSAyID8gcGFyc2VJbnQocGFydHNbMV0pIDogMCk7XG4gIGxldCBuaWNlID0gKHBhcnRzLmxlbmd0aCA+PSAzID8gcGFyc2VJbnQocGFydHNbMl0pIDogMCk7XG4gIGxldCBzeXN0ZW0gPSAocGFydHMubGVuZ3RoID49IDQgPyBwYXJzZUludChwYXJ0c1szXSkgOiAwKTtcbiAgbGV0IGlkbGUgPSAocGFydHMubGVuZ3RoID49IDUgPyBwYXJzZUludChwYXJ0c1s0XSkgOiAwKTtcbiAgbGV0IGlvd2FpdCA9IChwYXJ0cy5sZW5ndGggPj0gNiA/IHBhcnNlSW50KHBhcnRzWzVdKSA6IDApO1xuICBsZXQgaXJxID0gKHBhcnRzLmxlbmd0aCA+PSA3ID8gcGFyc2VJbnQocGFydHNbNl0pIDogMCk7XG4gIGxldCBzb2Z0aXJxID0gKHBhcnRzLmxlbmd0aCA+PSA4ID8gcGFyc2VJbnQocGFydHNbN10pIDogMCk7XG4gIGxldCBzdGVhbCA9IChwYXJ0cy5sZW5ndGggPj0gOSA/IHBhcnNlSW50KHBhcnRzWzhdKSA6IDApO1xuICBsZXQgZ3Vlc3QgPSAocGFydHMubGVuZ3RoID49IDEwID8gcGFyc2VJbnQocGFydHNbOV0pIDogMCk7XG4gIGxldCBndWVzdF9uaWNlID0gKHBhcnRzLmxlbmd0aCA+PSAxMSA/IHBhcnNlSW50KHBhcnRzWzEwXSkgOiAwKTtcbiAgcmV0dXJuIHVzZXIgKyBuaWNlICsgc3lzdGVtICsgaWRsZSArIGlvd2FpdCArIGlycSArIHNvZnRpcnEgKyBzdGVhbCArIGd1ZXN0ICsgZ3Vlc3RfbmljZTtcbn1cblxuZnVuY3Rpb24gY2FsY1Byb2NTdGF0TGludXgobGluZSwgYWxsLCBfY3B1X29sZCkge1xuICBsZXQgc3RhdHBhcnRzID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcpJyk7XG4gIGlmIChzdGF0cGFydHMubGVuZ3RoID49IDIpIHtcbiAgICBsZXQgcGFydHMgPSBzdGF0cGFydHNbMV0uc3BsaXQoJyAnKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID49IDE2KSB7XG4gICAgICBsZXQgcGlkID0gcGFyc2VJbnQoc3RhdHBhcnRzWzBdLnNwbGl0KCcgJylbMF0pO1xuICAgICAgbGV0IHV0aW1lID0gcGFyc2VJbnQocGFydHNbMTJdKTtcbiAgICAgIGxldCBzdGltZSA9IHBhcnNlSW50KHBhcnRzWzEzXSk7XG4gICAgICBsZXQgY3V0aW1lID0gcGFyc2VJbnQocGFydHNbMTRdKTtcbiAgICAgIGxldCBjc3RpbWUgPSBwYXJzZUludChwYXJ0c1sxNV0pO1xuXG4gICAgICAvLyBjYWxjXG4gICAgICBsZXQgY3B1dSA9IDA7XG4gICAgICBsZXQgY3B1cyA9IDA7XG4gICAgICBpZiAoX2NwdV9vbGQuYWxsID4gMCAmJiBfY3B1X29sZC5saXN0W3BpZF0pIHtcbiAgICAgICAgY3B1dSA9ICh1dGltZSArIGN1dGltZSAtIF9jcHVfb2xkLmxpc3RbcGlkXS51dGltZSAtIF9jcHVfb2xkLmxpc3RbcGlkXS5jdXRpbWUpIC8gKGFsbCAtIF9jcHVfb2xkLmFsbCkgKiAxMDA7IC8vIHVzZXJcbiAgICAgICAgY3B1cyA9IChzdGltZSArIGNzdGltZSAtIF9jcHVfb2xkLmxpc3RbcGlkXS5zdGltZSAtIF9jcHVfb2xkLmxpc3RbcGlkXS5jc3RpbWUpIC8gKGFsbCAtIF9jcHVfb2xkLmFsbCkgKiAxMDA7IC8vIHN5c3RlbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3B1dSA9ICh1dGltZSArIGN1dGltZSkgLyAoYWxsKSAqIDEwMDsgLy8gdXNlclxuICAgICAgICBjcHVzID0gKHN0aW1lICsgY3N0aW1lKSAvIChhbGwpICogMTAwOyAvLyBzeXN0ZW1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBpZDogcGlkLFxuICAgICAgICB1dGltZTogdXRpbWUsXG4gICAgICAgIHN0aW1lOiBzdGltZSxcbiAgICAgICAgY3V0aW1lOiBjdXRpbWUsXG4gICAgICAgIGNzdGltZTogY3N0aW1lLFxuICAgICAgICBjcHV1OiBjcHV1LFxuICAgICAgICBjcHVzOiBjcHVzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaWQ6IDAsXG4gICAgICAgIHV0aW1lOiAwLFxuICAgICAgICBzdGltZTogMCxcbiAgICAgICAgY3V0aW1lOiAwLFxuICAgICAgICBjc3RpbWU6IDAsXG4gICAgICAgIGNwdXU6IDAsXG4gICAgICAgIGNwdXM6IDBcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBwaWQ6IDAsXG4gICAgICB1dGltZTogMCxcbiAgICAgIHN0aW1lOiAwLFxuICAgICAgY3V0aW1lOiAwLFxuICAgICAgY3N0aW1lOiAwLFxuICAgICAgY3B1dTogMCxcbiAgICAgIGNwdXM6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGNQcm9jU3RhdFdpbihwcm9jU3RhdCwgYWxsLCBfY3B1X29sZCkge1xuICAvLyBjYWxjXG4gIGxldCBjcHV1ID0gMDtcbiAgbGV0IGNwdXMgPSAwO1xuICBpZiAoX2NwdV9vbGQuYWxsID4gMCAmJiBfY3B1X29sZC5saXN0W3Byb2NTdGF0LnBpZF0pIHtcbiAgICBjcHV1ID0gKHByb2NTdGF0LnV0aW1lIC0gX2NwdV9vbGQubGlzdFtwcm9jU3RhdC5waWRdLnV0aW1lKSAvIChhbGwgLSBfY3B1X29sZC5hbGwpICogMTAwOyAvLyB1c2VyXG4gICAgY3B1cyA9IChwcm9jU3RhdC5zdGltZSAtIF9jcHVfb2xkLmxpc3RbcHJvY1N0YXQucGlkXS5zdGltZSkgLyAoYWxsIC0gX2NwdV9vbGQuYWxsKSAqIDEwMDsgLy8gc3lzdGVtXG4gIH0gZWxzZSB7XG4gICAgY3B1dSA9IChwcm9jU3RhdC51dGltZSkgLyAoYWxsKSAqIDEwMDsgLy8gdXNlclxuICAgIGNwdXMgPSAocHJvY1N0YXQuc3RpbWUpIC8gKGFsbCkgKiAxMDA7IC8vIHN5c3RlbVxuICB9XG4gIHJldHVybiB7XG4gICAgcGlkOiBwcm9jU3RhdC5waWQsXG4gICAgdXRpbWU6IHByb2NTdGF0LnV0aW1lLFxuICAgIHN0aW1lOiBwcm9jU3RhdC5zdGltZSxcbiAgICBjcHV1OiBjcHV1ID4gMCA/IGNwdXUgOiAwLFxuICAgIGNwdXM6IGNwdXMgPiAwID8gY3B1cyA6IDBcbiAgfTtcbn1cblxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBydW5uaW5nIHByb2Nlc3Nlc1xuXG5mdW5jdGlvbiBwcm9jZXNzZXMoY2FsbGJhY2spIHtcblxuICBsZXQgcGFyc2VkaGVhZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIGdldE5hbWUoY29tbWFuZCkge1xuICAgIGNvbW1hbmQgPSBjb21tYW5kIHx8ICcnO1xuICAgIGxldCByZXN1bHQgPSBjb21tYW5kLnNwbGl0KCcgJylbMF07XG4gICAgaWYgKHJlc3VsdC5zdWJzdHIoLTEpID09PSAnOicpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgcmVzdWx0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnN1YnN0cigwLCAxKSAhPT0gJ1snKSB7XG4gICAgICBsZXQgcGFydHMgPSByZXN1bHQuc3BsaXQoJy8nKTtcbiAgICAgIGlmIChpc05hTihwYXJzZUludChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkpKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGFydHNbMF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmUobGluZSkge1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IG9mZnNldDIgPSAwO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tDb2x1bW4oaSkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MjtcbiAgICAgIGlmIChwYXJzZWRoZWFkW2ldKSB7XG4gICAgICAgIG9mZnNldDIgPSBsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkW2ldLnRvICsgb2Zmc2V0LCAxMDAwMCkuaW5kZXhPZignICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0MiA9IDEwMDAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrQ29sdW1uKDApO1xuICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMF0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFswXS50byArIG9mZnNldDIpKTtcbiAgICBjaGVja0NvbHVtbigxKTtcbiAgICBjb25zdCBwcGlkID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFsxXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzFdLnRvICsgb2Zmc2V0MikpO1xuICAgIGNoZWNrQ29sdW1uKDIpO1xuICAgIGNvbnN0IGNwdSA9IHBhcnNlRmxvYXQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFsyXS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzJdLnRvICsgb2Zmc2V0MikucmVwbGFjZSgvLC9nLCAnLicpKTtcbiAgICBjaGVja0NvbHVtbigzKTtcbiAgICBjb25zdCBtZW0gPSBwYXJzZUZsb2F0KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbM10uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFszXS50byArIG9mZnNldDIpLnJlcGxhY2UoLywvZywgJy4nKSk7XG4gICAgY2hlY2tDb2x1bW4oNCk7XG4gICAgY29uc3QgcHJpb3JpdHkgPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzRdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbNF0udG8gKyBvZmZzZXQyKSk7XG4gICAgY2hlY2tDb2x1bW4oNSk7XG4gICAgY29uc3QgdnN6ID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs1XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzVdLnRvICsgb2Zmc2V0MikpO1xuICAgIGNoZWNrQ29sdW1uKDYpO1xuICAgIGNvbnN0IHJzcyA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbNl0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs2XS50byArIG9mZnNldDIpKTtcbiAgICBjaGVja0NvbHVtbig3KTtcbiAgICBjb25zdCBuaWNlID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs3XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzddLnRvICsgb2Zmc2V0MikpIHx8IDA7XG4gICAgY2hlY2tDb2x1bW4oOCk7XG4gICAgY29uc3Qgc3RhcnRlZCA9ICFfc3Vub3MgPyBwYXJzZUVsYXBzZWRUaW1lKGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbOF0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs4XS50byArIG9mZnNldDIpLnRyaW0oKSkgOiBwYXJzZVRpbWVVbml4KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbOF0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs4XS50byArIG9mZnNldDIpLnRyaW0oKSk7XG4gICAgY2hlY2tDb2x1bW4oOSk7XG4gICAgbGV0IHN0YXRlID0gbGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs5XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzldLnRvICsgb2Zmc2V0MikudHJpbSgpO1xuICAgIHN0YXRlID0gKHN0YXRlWzBdID09PSAnUicgPyAncnVubmluZycgOiAoc3RhdGVbMF0gPT09ICdTJyA/ICdzbGVlcGluZycgOiAoc3RhdGVbMF0gPT09ICdUJyA/ICdzdG9wcGVkJyA6IChzdGF0ZVswXSA9PT0gJ1cnID8gJ3BhZ2luZycgOiAoc3RhdGVbMF0gPT09ICdYJyA/ICdkZWFkJyA6IChzdGF0ZVswXSA9PT0gJ1onID8gJ3pvbWJpZScgOiAoKHN0YXRlWzBdID09PSAnRCcgfHwgc3RhdGVbMF0gPT09ICdVJykgPyAnYmxvY2tlZCcgOiAndW5rbm93bicpKSkpKSkpO1xuICAgIGNoZWNrQ29sdW1uKDEwKTtcbiAgICBsZXQgdHR5ID0gbGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFsxMF0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFsxMF0udG8gKyBvZmZzZXQyKS50cmltKCk7XG4gICAgaWYgKHR0eSA9PT0gJz8nIHx8IHR0eSA9PT0gJz8/JykgeyB0dHkgPSAnJzsgfVxuICAgIGNoZWNrQ29sdW1uKDExKTtcbiAgICBjb25zdCB1c2VyID0gbGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFsxMV0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFsxMV0udG8gKyBvZmZzZXQyKS50cmltKCk7XG4gICAgY2hlY2tDb2x1bW4oMTIpO1xuICAgIGxldCBjbWRQYXRoID0gJyc7XG4gICAgbGV0IGNvbW1hbmQgPSAnJztcbiAgICBsZXQgcGFyYW1zID0gJyc7XG4gICAgbGV0IGZ1bGxjb21tYW5kID0gbGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFsxMl0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFsxMl0udG8gKyBvZmZzZXQyKS50cmltKCk7XG4gICAgaWYgKGZ1bGxjb21tYW5kLnN1YnN0cihmdWxsY29tbWFuZC5sZW5ndGggLSAxKSA9PT0gJ10nKSB7IGZ1bGxjb21tYW5kID0gZnVsbGNvbW1hbmQuc2xpY2UoMCwgLTEpOyB9XG4gICAgaWYgKGZ1bGxjb21tYW5kLnN1YnN0cigwLCAxKSA9PT0gJ1snKSB7IGNvbW1hbmQgPSBmdWxsY29tbWFuZC5zdWJzdHJpbmcoMSk7IH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHAxID0gZnVsbGNvbW1hbmQuaW5kZXhPZignKCcpO1xuICAgICAgY29uc3QgcDIgPSBmdWxsY29tbWFuZC5pbmRleE9mKCcpJyk7XG4gICAgICBjb25zdCBwMyA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJy8nKTtcbiAgICAgIGNvbnN0IHA0ID0gZnVsbGNvbW1hbmQuaW5kZXhPZignOicpO1xuICAgICAgaWYgKHAxIDwgcDIgJiYgcDEgPCBwMyAmJiBwMyA8IHAyKSB7XG4gICAgICAgIGNvbW1hbmQgPSBmdWxsY29tbWFuZC5zcGxpdCgnICcpWzBdO1xuICAgICAgICBjb21tYW5kID0gY29tbWFuZC5yZXBsYWNlKC86L2csICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwNCA+IDAgJiYgKHAzID09PSAtMSB8fCBwMyA+IDMpKSB7XG4gICAgICAgICAgY29tbWFuZCA9IGZ1bGxjb21tYW5kLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgY29tbWFuZCA9IGNvbW1hbmQucmVwbGFjZSgvOi9nLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGZpZ3VyZSBvdXQgd2hlcmUgcGFyYW1ldGVyIHN0YXJ0c1xuICAgICAgICAgIGxldCBmaXJzdFBhcmFtUG9zID0gZnVsbGNvbW1hbmQuaW5kZXhPZignIC0nKTtcbiAgICAgICAgICBsZXQgZmlyc3RQYXJhbVBhdGhQb3MgPSBmdWxsY29tbWFuZC5pbmRleE9mKCcgLycpO1xuICAgICAgICAgIGZpcnN0UGFyYW1Qb3MgPSAoZmlyc3RQYXJhbVBvcyA+PSAwID8gZmlyc3RQYXJhbVBvcyA6IDEwMDAwKTtcbiAgICAgICAgICBmaXJzdFBhcmFtUGF0aFBvcyA9IChmaXJzdFBhcmFtUGF0aFBvcyA+PSAwID8gZmlyc3RQYXJhbVBhdGhQb3MgOiAxMDAwMCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RQb3MgPSBNYXRoLm1pbihmaXJzdFBhcmFtUG9zLCBmaXJzdFBhcmFtUGF0aFBvcyk7XG4gICAgICAgICAgbGV0IHRtcENvbW1hbmQgPSBmdWxsY29tbWFuZC5zdWJzdHIoMCwgZmlyc3RQb3MpO1xuICAgICAgICAgIGNvbnN0IHRtcFBhcmFtcyA9IGZ1bGxjb21tYW5kLnN1YnN0cihmaXJzdFBvcyk7XG4gICAgICAgICAgY29uc3QgbGFzdFNsYXNoUG9zID0gdG1wQ29tbWFuZC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgIGlmIChsYXN0U2xhc2hQb3MgPj0gMCkge1xuICAgICAgICAgICAgY21kUGF0aCA9IHRtcENvbW1hbmQuc3Vic3RyKDAsIGxhc3RTbGFzaFBvcyk7XG4gICAgICAgICAgICB0bXBDb21tYW5kID0gdG1wQ29tbWFuZC5zdWJzdHIobGFzdFNsYXNoUG9zICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpcnN0UG9zID09PSAxMDAwMCAmJiB0bXBDb21tYW5kLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRtcENvbW1hbmQuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihjbWRQYXRoLCBwYXJ0c1swXSkpKSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICBwYXJhbXMgPSAocGFydHMuam9pbignICcpICsgJyAnICsgdG1wUGFyYW1zKS50cmltKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21tYW5kID0gdG1wQ29tbWFuZC50cmltKCk7XG4gICAgICAgICAgICAgIHBhcmFtcyA9IHRtcFBhcmFtcy50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSB0bXBDb21tYW5kLnRyaW0oKTtcbiAgICAgICAgICAgIHBhcmFtcyA9IHRtcFBhcmFtcy50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHBpZDogcGlkLFxuICAgICAgcGFyZW50UGlkOiBwcGlkLFxuICAgICAgbmFtZTogX2xpbnV4ID8gZ2V0TmFtZShjb21tYW5kKSA6IGNvbW1hbmQsXG4gICAgICBjcHU6IGNwdSxcbiAgICAgIGNwdXU6IDAsXG4gICAgICBjcHVzOiAwLFxuICAgICAgbWVtOiBtZW0sXG4gICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICBtZW1Wc3o6IHZzeixcbiAgICAgIG1lbVJzczogcnNzLFxuICAgICAgbmljZTogbmljZSxcbiAgICAgIHN0YXJ0ZWQ6IHN0YXJ0ZWQsXG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICB0dHk6IHR0eSxcbiAgICAgIHVzZXI6IHVzZXIsXG4gICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBwYXRoOiBjbWRQYXRoXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb2Nlc3NlcyhsaW5lcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IGhlYWQgPSBsaW5lc1swXTtcbiAgICAgIHBhcnNlZGhlYWQgPSB1dGlsLnBhcnNlSGVhZChoZWFkLCA4KTtcbiAgICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUxpbmUobGluZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVByb2Nlc3NlczIobGluZXMpIHtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGVUaW1lKHRpbWUpIHtcbiAgICAgIGNvbnN0IG1vbnRoID0gKCcwJyArICh0aW1lLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpKS5zbGljZSgtMik7XG4gICAgICBjb25zdCB5ZWFyID0gdGltZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBkYXkgPSAoJzAnICsgdGltZS5nZXREYXRlKCkudG9TdHJpbmcoKSkuc2xpY2UoLTIpO1xuICAgICAgY29uc3QgaG91cnMgPSAoJzAnICsgdGltZS5nZXRIb3VycygpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgIGNvbnN0IG1pbnMgPSAoJzAnICsgdGltZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSkuc2xpY2UoLTIpO1xuICAgICAgY29uc3Qgc2VjcyA9ICgnMCcgKyB0aW1lLmdldFNlY29uZHMoKS50b1N0cmluZygpKS5zbGljZSgtMik7XG5cbiAgICAgIHJldHVybiAoeWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5ICsgJyAnICsgaG91cnMgKyAnOicgKyBtaW5zICsgJzonICsgc2Vjcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbGFwc2VkKGV0aW1lKSB7XG4gICAgICBsZXQgc3RhcnRlZCA9ICcnO1xuICAgICAgaWYgKGV0aW1lLmluZGV4T2YoJ2QnKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRfcGFydHMgPSBldGltZS5zcGxpdCgnZCcpO1xuICAgICAgICBzdGFydGVkID0gZm9ybWF0RGF0ZVRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIChlbGFwc2VkX3BhcnRzWzBdICogMjQgKyBlbGFwc2VkX3BhcnRzWzFdICogMSkgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgfSBlbHNlIGlmIChldGltZS5pbmRleE9mKCdoJykgPj0gMCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkX3BhcnRzID0gZXRpbWUuc3BsaXQoJ2gnKTtcbiAgICAgICAgc3RhcnRlZCA9IGZvcm1hdERhdGVUaW1lKG5ldyBEYXRlKERhdGUubm93KCkgLSAoZWxhcHNlZF9wYXJ0c1swXSAqIDYwICsgZWxhcHNlZF9wYXJ0c1sxXSAqIDEpICogNjAgKiAxMDAwKSk7XG4gICAgICB9IGVsc2UgaWYgKGV0aW1lLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRfcGFydHMgPSBldGltZS5zcGxpdCgnOicpO1xuICAgICAgICBzdGFydGVkID0gZm9ybWF0RGF0ZVRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIChlbGFwc2VkX3BhcnRzLmxlbmd0aCA+IDEgPyAoZWxhcHNlZF9wYXJ0c1swXSAqIDYwICsgZWxhcHNlZF9wYXJ0c1sxXSkgKiAxMDAwIDogZWxhcHNlZF9wYXJ0c1swXSAqIDEwMDApKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnRlZDtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUudHJpbSgpICE9PSAnJykge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCkucmVwbGFjZSgvICsvZywgJyAnKS5yZXBsYWNlKC8sKy9nLCAnLicpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHBhcnRzLnNsaWNlKDkpLmpvaW4oJyAnKTtcbiAgICAgICAgY29uc3QgcG1lbSA9IHBhcnNlRmxvYXQoKDEuMCAqIHBhcnNlSW50KHBhcnRzWzNdKSAqIDEwMjQgLyBvcy50b3RhbG1lbSgpKS50b0ZpeGVkKDEpKTtcbiAgICAgICAgY29uc3Qgc3RhcnRlZCA9IHBhcnNlRWxhcHNlZChwYXJ0c1s1XSk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIHBpZDogcGFyc2VJbnQocGFydHNbMF0pLFxuICAgICAgICAgIHBhcmVudFBpZDogcGFyc2VJbnQocGFydHNbMV0pLFxuICAgICAgICAgIG5hbWU6IGdldE5hbWUoY29tbWFuZCksXG4gICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgIGNwdXU6IDAsXG4gICAgICAgICAgY3B1czogMCxcbiAgICAgICAgICBtZW06IHBtZW0sXG4gICAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgICAgbWVtVnN6OiBwYXJzZUludChwYXJ0c1syXSksXG4gICAgICAgICAgbWVtUnNzOiBwYXJzZUludChwYXJ0c1szXSksXG4gICAgICAgICAgbmljZTogcGFyc2VJbnQocGFydHNbNF0pLFxuICAgICAgICAgIHN0YXJ0ZWQ6IHN0YXJ0ZWQsXG4gICAgICAgICAgc3RhdGU6IChwYXJ0c1s2XSA9PT0gJ1InID8gJ3J1bm5pbmcnIDogKHBhcnRzWzZdID09PSAnUycgPyAnc2xlZXBpbmcnIDogKHBhcnRzWzZdID09PSAnVCcgPyAnc3RvcHBlZCcgOiAocGFydHNbNl0gPT09ICdXJyA/ICdwYWdpbmcnIDogKHBhcnRzWzZdID09PSAnWCcgPyAnZGVhZCcgOiAocGFydHNbNl0gPT09ICdaJyA/ICd6b21iaWUnIDogKChwYXJ0c1s2XSA9PT0gJ0QnIHx8IHBhcnRzWzZdID09PSAnVScpID8gJ2Jsb2NrZWQnIDogJ3Vua25vd24nKSkpKSkpKSxcbiAgICAgICAgICB0dHk6IHBhcnRzWzddLFxuICAgICAgICAgIHVzZXI6IHBhcnRzWzhdLFxuICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgYWxsOiAwLFxuICAgICAgICBydW5uaW5nOiAwLFxuICAgICAgICBibG9ja2VkOiAwLFxuICAgICAgICBzbGVlcGluZzogMCxcbiAgICAgICAgdW5rbm93bjogMCxcbiAgICAgICAgbGlzdDogW11cbiAgICAgIH07XG5cbiAgICAgIGxldCBjbWQgPSAnJztcblxuICAgICAgaWYgKChfcHJvY2Vzc2VzX2NwdS5tcyAmJiBEYXRlLm5vdygpIC0gX3Byb2Nlc3Nlc19jcHUubXMgPj0gNTAwKSB8fCBfcHJvY2Vzc2VzX2NwdS5tcyA9PT0gMCkge1xuICAgICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2RhcndpbiB8fCBfc3Vub3MpIHtcbiAgICAgICAgICBpZiAoX2xpbnV4KSB7IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IHBzIC1heG8gcGlkOjExLHBwaWQ6MTEscGNwdTo2LHBtZW06Nixwcmk6NSx2c3o6MTEscnNzOjExLG5pOjUsZXRpbWU6MzAsc3RhdGU6NSx0dHk6MTUsdXNlcjoyMCxjb21tYW5kOyB1bnNldCBMQ19BTEwnOyB9XG4gICAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHsgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgcHMgLWF4byBwaWQscHBpZCxwY3B1LHBtZW0scHJpLHZzeixyc3MsbmksZXRpbWUsc3RhdGUsdHR5LHVzZXIsY29tbWFuZDsgdW5zZXQgTENfQUxMJzsgfVxuICAgICAgICAgIGlmIChfZGFyd2luKSB7IGNtZCA9ICdwcyAtYXhvIHBpZCxwcGlkLHBjcHUscG1lbSxwcmksdnN6PXRlbXBfdGl0bGVfMSxyc3M9dGVtcF90aXRsZV8yLG5pY2UsZXRpbWU9dGVtcF90aXRsZV8zLHN0YXRlLHR0eSx1c2VyLGNvbW1hbmQgLXInOyB9XG4gICAgICAgICAgaWYgKF9zdW5vcykgeyBjbWQgPSAncHMgLUFvIHBpZCxwcGlkLHBjcHUscG1lbSxwcmksdnN6LHJzcyxuaWNlLHN0aW1lLHMsdHR5LHVzZXIsY29tbSc7IH1cbiAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvciAmJiBzdGRvdXQudG9TdHJpbmcoKS50cmltKCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lmxpc3QgPSAocGFyc2VQcm9jZXNzZXMoc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpKSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmFsbCA9IHJlc3VsdC5saXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVzdWx0LnJ1bm5pbmcgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ3J1bm5pbmcnO1xuICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlc3VsdC5ibG9ja2VkID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdibG9ja2VkJztcbiAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICByZXN1bHQuc2xlZXBpbmcgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ3NsZWVwaW5nJztcbiAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjIHByb2Nlc3NfY3B1IC0gcHMgaXMgbm90IGFjY3VyYXRlIGluIGxpbnV4IVxuICAgICAgICAgICAgICAgIGNtZCA9ICdjYXQgL3Byb2Mvc3RhdCB8IGdyZXAgXCJjcHUgXCInO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0LmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNtZCArPSAoJztjYXQgL3Byb2MvJyArIGVsZW1lbnQucGlkICsgJy9zdGF0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBjdXJyX3Byb2Nlc3NlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgbGluZSAoYWxsIC0gL3Byb2Mvc3RhdClcbiAgICAgICAgICAgICAgICAgIGxldCBhbGwgPSBwYXJzZVByb2NTdGF0KGN1cnJfcHJvY2Vzc2VzLnNoaWZ0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICBsZXQgbGlzdF9uZXcgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRQcm9jZXNzID0ge307XG4gICAgICAgICAgICAgICAgICBjdXJyX3Byb2Nlc3Nlcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb2Nlc3MgPSBjYWxjUHJvY1N0YXRMaW51eChlbGVtZW50LCBhbGwsIF9wcm9jZXNzZXNfY3B1KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0UHJvY2Vzcy5waWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBjcHUgaW4gb3V0ZXIgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdFBvcyA9IHJlc3VsdC5saXN0Lm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5waWQ7IH0pLmluZGV4T2YocmVzdWx0UHJvY2Vzcy5waWQpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdSA9IHJlc3VsdFByb2Nlc3MuY3B1dSArIHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdXUgPSByZXN1bHRQcm9jZXNzLmNwdXU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHVzID0gcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgIGxpc3RfbmV3W3Jlc3VsdFByb2Nlc3MucGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IHJlc3VsdFByb2Nlc3MuY3B1dSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IHJlc3VsdFByb2Nlc3MuY3B1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aW1lOiByZXN1bHRQcm9jZXNzLnV0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHJlc3VsdFByb2Nlc3Muc3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRpbWU6IHJlc3VsdFByb2Nlc3MuY3V0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3N0aW1lOiByZXN1bHRQcm9jZXNzLmNzdGltZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyBzdG9yZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5hbGwgPSBhbGw7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5saXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgbGlzdF9uZXcpO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUubXMgPSBEYXRlLm5vdygpIC0gX3Byb2Nlc3Nlc19jcHUubXM7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5yZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY21kID0gJ3BzIC1vIHBpZCxwcGlkLHZzeixyc3MsbmljZSxldGltZSxzdGF0LHR0eSx1c2VyLGNvbW0nO1xuICAgICAgICAgICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgICAgICAgICAgY21kID0gJ3BzIC1vIHBpZCxwcGlkLHZzeixyc3MsbmljZSxldGltZSxzLHR0eSx1c2VyLGNvbW0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgbGluZXMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3QgPSBwYXJzZVByb2Nlc3NlczIobGluZXMpLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuYWxsID0gcmVzdWx0Lmxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnJ1bm5pbmcgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdydW5uaW5nJztcbiAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5ibG9ja2VkID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAnYmxvY2tlZCc7XG4gICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuc2xlZXBpbmcgPSByZXN1bHQubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdzbGVlcGluZyc7XG4gICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUHJvY2VzcyB8IHNlbGVjdC1PYmplY3QgUHJvY2Vzc0lkLFBhcmVudFByb2Nlc3NJZCxFeGVjdXRpb25TdGF0ZSxDYXB0aW9uLENvbW1hbmRMaW5lLEV4ZWN1dGFibGVQYXRoLFVzZXJNb2RlVGltZSxLZXJuZWxNb2RlVGltZSxXb3JraW5nU2V0U2l6ZSxQcmlvcml0eSxQYWdlRmlsZVVzYWdlLCBAe249XCJDcmVhdGlvbkRhdGVcIjtlPXskXy5DcmVhdGlvbkRhdGUuVG9TdHJpbmcoXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXCIpfX0gfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzU2VjdGlvbnMgPSBzdGRvdXQuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvY1N0YXRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RfbmV3ID0ge307XG4gICAgICAgICAgICAgICAgbGV0IGFsbGNwdXUgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBhbGxjcHVzID0gMDtcbiAgICAgICAgICAgICAgICBwcm9jZXNzU2VjdGlvbnMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBlbGVtZW50LnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvY2Vzc0lkJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50UGlkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhcmVudFByb2Nlc3NJZCcsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXR1c1ZhbHVlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0V4ZWN1dGlvblN0YXRlJywgJzonKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kTGluZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb21tYW5kTGluZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBhZGRpdGlvbmFsIGNvbW1hbmQgbGluZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGRpdGlvbmFsQ29tbWFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDb21tYW5kICYmIGxpbmUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRMaW5lICs9ICcgJyArIGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ29tbWFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NvbW1hbmRsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDb21tYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZFBhdGggPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRXhlY3V0YWJsZVBhdGgnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXRpbWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVXNlck1vZGVUaW1lJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RpbWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnS2VybmVsTW9kZVRpbWUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZW13ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1dvcmtpbmdTZXRTaXplJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBhbGxjcHV1ID0gYWxsY3B1dSArIHV0aW1lO1xuICAgICAgICAgICAgICAgICAgICBhbGxjcHVzID0gYWxsY3B1cyArIHN0aW1lO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWxsKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhdHVzVmFsdWUpIHsgcmVzdWx0LnVua25vd24rKzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVmFsdWUgPT09ICczJykgeyByZXN1bHQucnVubmluZysrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNWYWx1ZSA9PT0gJzQnIHx8IHN0YXR1c1ZhbHVlID09PSAnNScpIHsgcmVzdWx0LmJsb2NrZWQrKzsgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByb2NTdGF0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICB1dGltZTogdXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHN0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHV1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm9jcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRQaWQ6IHBhcmVudFBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHV1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtOiBtZW13IC8gb3MudG90YWxtZW0oKSAqIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ByaW9yaXR5JywgJzonLCB0cnVlKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbVZzejogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhZ2VGaWxlVXNhZ2UnLCAnOicsIHRydWUpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgbWVtUnNzOiBNYXRoLmZsb29yKHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdXb3JraW5nU2V0U2l6ZScsICc6JywgdHJ1ZSksIDEwKSAvIDEwMjQpLFxuICAgICAgICAgICAgICAgICAgICAgIG5pY2U6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NyZWF0aW9uRGF0ZScsICc6JywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICghc3RhdHVzVmFsdWUgPyBfd2luU3RhdHVzVmFsdWVzWzBdIDogX3dpblN0YXR1c1ZhbHVlc1tzdGF0dXNWYWx1ZV0pLFxuICAgICAgICAgICAgICAgICAgICAgIHR0eTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgdXNlcjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZExpbmUgfHwgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjb21tYW5kUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNsZWVwaW5nID0gcmVzdWx0LmFsbCAtIHJlc3VsdC5ydW5uaW5nIC0gcmVzdWx0LmJsb2NrZWQgLSByZXN1bHQudW5rbm93bjtcbiAgICAgICAgICAgICAgICByZXN1bHQubGlzdCA9IHByb2NzO1xuICAgICAgICAgICAgICAgIHByb2NTdGF0cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UHJvY2VzcyA9IGNhbGNQcm9jU3RhdFdpbihlbGVtZW50LCBhbGxjcHV1ICsgYWxsY3B1cywgX3Byb2Nlc3Nlc19jcHUpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwY3B1IGluIG91dGVyIGFycmF5XG4gICAgICAgICAgICAgICAgICBsZXQgbGlzdFBvcyA9IHJlc3VsdC5saXN0Lm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5waWQ7IH0pLmluZGV4T2YocmVzdWx0UHJvY2Vzcy5waWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHUgPSByZXN1bHRQcm9jZXNzLmNwdXUgKyByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdXUgPSByZXN1bHRQcm9jZXNzLmNwdXU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0W2xpc3RQb3NdLmNwdXMgPSByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgbGlzdF9uZXdbcmVzdWx0UHJvY2Vzcy5waWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBjcHV1OiByZXN1bHRQcm9jZXNzLmNwdXUsXG4gICAgICAgICAgICAgICAgICAgIGNwdXM6IHJlc3VsdFByb2Nlc3MuY3B1cyxcbiAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHJlc3VsdFByb2Nlc3MudXRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aW1lOiByZXN1bHRQcm9jZXNzLnN0aW1lXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgb2xkIHZhbHVlc1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LmFsbCA9IGFsbGNwdXUgKyBhbGxjcHVzO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LmFsbF91dGltZSA9IGFsbGNwdXU7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUuYWxsX3N0aW1lID0gYWxsY3B1cztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5saXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgbGlzdF9uZXcpO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1Lm1zID0gRGF0ZS5ub3coKSAtIF9wcm9jZXNzZXNfY3B1Lm1zO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LnJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKF9wcm9jZXNzZXNfY3B1LnJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShfcHJvY2Vzc2VzX2NwdS5yZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5wcm9jZXNzZXMgPSBwcm9jZXNzZXM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQUyAtIHByb2Nlc3MgbG9hZFxuLy8gZ2V0IGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGEgY2VydGFpbiBwcm9jZXNzXG4vLyAoUElELCBDUFUtVXNhZ2UgJSwgTWVtLVVzYWdlICUpXG5cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkKHByb2MsIGNhbGxiYWNrKSB7XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24ocHJvYykgJiYgIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBwcm9jO1xuICAgIHByb2MgPSAnJztcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBwcm9jID0gcHJvYyB8fCAnJztcblxuICAgICAgaWYgKHR5cGVvZiBwcm9jICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soW10pOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHByb2Nlc3Nlc1N0cmluZyA9ICcnO1xuICAgICAgcHJvY2Vzc2VzU3RyaW5nLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgIHByb2Nlc3Nlc1N0cmluZy5fX3Byb3RvX18ucmVwbGFjZSA9IHV0aWwuc3RyaW5nUmVwbGFjZTtcbiAgICAgIHByb2Nlc3Nlc1N0cmluZy5fX3Byb3RvX18udHJpbSA9IHV0aWwuc3RyaW5nVHJpbTtcblxuICAgICAgY29uc3QgcyA9IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhwcm9jKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvY2Vzc2VzU3RyaW5nID0gcHJvY2Vzc2VzU3RyaW5nICsgc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzZXNTdHJpbmcgPSBwcm9jZXNzZXNTdHJpbmcudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLCAvZywgJ3wnKS5yZXBsYWNlKC8sKy9nLCAnfCcpO1xuICAgICAgaWYgKHByb2Nlc3Nlc1N0cmluZyA9PT0gJycpIHtcbiAgICAgICAgcHJvY2Vzc2VzU3RyaW5nID0gJyonO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpICYmIHByb2Nlc3Nlc1N0cmluZyAhPT0gJyonKSB7XG4gICAgICAgIHByb2Nlc3Nlc1N0cmluZyA9ICctLS0tLS0nO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3NlcyA9IHByb2Nlc3Nlc1N0cmluZy5zcGxpdCgnfCcpO1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBjb25zdCBwcm9jU2FuaXRpemVkID0gdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhwcm9jKTtcblxuICAgICAgLy8gZnJvbSBoZXJlIG5ld1xuICAgICAgLy8gbGV0IHJlc3VsdCA9IHtcbiAgICAgIC8vICAgJ3Byb2MnOiBwcm9jU2FuaXRpemVkLFxuICAgICAgLy8gICAncGlkJzogbnVsbCxcbiAgICAgIC8vICAgJ2NwdSc6IDAsXG4gICAgICAvLyAgICdtZW0nOiAwXG4gICAgICAvLyB9O1xuICAgICAgaWYgKHByb2NTYW5pdGl6ZWQgJiYgcHJvY2Vzc2VzLmxlbmd0aCAmJiBwcm9jZXNzZXNbMF0gIT09ICctLS0tLS0nKSB7XG4gICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Qcm9jZXNzIHwgc2VsZWN0IFByb2Nlc3NJZCxDYXB0aW9uLFVzZXJNb2RlVGltZSxLZXJuZWxNb2RlVGltZSxXb3JraW5nU2V0U2l6ZSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb2Nlc3NTZWN0aW9ucyA9IHN0ZG91dC5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICAgIGxldCBwcm9jU3RhdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdF9uZXcgPSB7fTtcbiAgICAgICAgICAgICAgICBsZXQgYWxsY3B1dSA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGFsbGNwdXMgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1NlY3Rpb25zLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZWxlbWVudC50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGlkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2Nlc3NJZCcsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1dGltZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdVc2VyTW9kZVRpbWUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGltZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdLZXJuZWxNb2RlVGltZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lbSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdXb3JraW5nU2V0U2l6ZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsY3B1dSA9IGFsbGNwdXUgKyB1dGltZTtcbiAgICAgICAgICAgICAgICAgICAgYWxsY3B1cyA9IGFsbGNwdXMgKyBzdGltZTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jU3RhdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB1dGltZTogdXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHN0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHV1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvYykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9jLnRvTG93ZXJDYXNlKCkpID49IDAgJiYgIWluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBuYW1lID0gcHJvYztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZXNTdHJpbmcgPT09ICcqJyB8fCBpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvY2Vzc0ZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnByb2MudG9Mb3dlckNhc2UoKSA9PT0gcG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBpZHMucHVzaChwaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm1lbSArPSBtZW0gLyBvcy50b3RhbG1lbSgpICogMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByb2M6IHBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGlkczogW3BpZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtOiBtZW0gLyBvcy50b3RhbG1lbSgpICogMTAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBtaXNzaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZXNTdHJpbmcgIT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgbGV0IHByb2Nlc3Nlc01pc3NpbmcgPSBwcm9jZXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jU3RhdHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5hbWUpID49IDA7IH0pLmxlbmd0aCA9PT0gMDtcblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzZXNNaXNzaW5nLmZvckVhY2goZnVuY3Rpb24gKHByb2NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jOiBwcm9jTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwcm9jIHN0YXRzIGZvciBlYWNoIHByb2NcbiAgICAgICAgICAgICAgICBwcm9jU3RhdHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFByb2Nlc3MgPSBjYWxjUHJvY1N0YXRXaW4oZWxlbWVudCwgYWxsY3B1dSArIGFsbGNwdXMsIF9wcm9jZXNzX2NwdSk7XG5cbiAgICAgICAgICAgICAgICAgIGxldCBsaXN0UG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2pdLnBpZCA9PT0gcmVzdWx0UHJvY2Vzcy5waWQgfHwgcmVzdWx0W2pdLnBpZHMuaW5kZXhPZihyZXN1bHRQcm9jZXNzLnBpZCkgPj0gMCkgeyBsaXN0UG9zID0gajsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10uY3B1ICs9IHJlc3VsdFByb2Nlc3MuY3B1dSArIHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICBsaXN0X25ld1tyZXN1bHRQcm9jZXNzLnBpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNwdXU6IHJlc3VsdFByb2Nlc3MuY3B1dSxcbiAgICAgICAgICAgICAgICAgICAgY3B1czogcmVzdWx0UHJvY2Vzcy5jcHVzLFxuICAgICAgICAgICAgICAgICAgICB1dGltZTogcmVzdWx0UHJvY2Vzcy51dGltZSxcbiAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHJlc3VsdFByb2Nlc3Muc3RpbWVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LmFsbCA9IGFsbGNwdXUgKyBhbGxjcHVzO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5hbGxfdXRpbWUgPSBhbGxjcHV1O1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5hbGxfc3RpbWUgPSBhbGxjcHVzO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5saXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgbGlzdF9uZXcpO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5tcyA9IERhdGUubm93KCkgLSBfcHJvY2Vzc19jcHUubXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LnJlc3VsdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9kYXJ3aW4gfHwgX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbJy1heG8nLCAncGlkLHBwaWQscGNwdSxwbWVtLGNvbW0nXTtcbiAgICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwcycsIHBhcmFtcykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGxldCBwcm9jU3RhdHMgPSBbXTtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZXNTdHJpbmcgPT09ICcqJykgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZ3JlcCcpICE9PSAtMSkgeyByZXR1cm4gZmFsc2U7IH0gLy8gcmVtb3ZlIHRoaXM/P1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHByb2Nlc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kIHx8IChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpdGVtLnRvTG93ZXJDYXNlKCkpID49IDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbGluZS50cmltKCkucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgIHByb2NTdGF0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YVs0XS5zdWJzdHJpbmcoZGF0YVs0XS5sYXN0SW5kZXhPZignLycpICsgMSksXG4gICAgICAgICAgICAgICAgICAgIHBpZDogcGFyc2VJbnQoZGF0YVswXSkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgcHBpZDogcGFyc2VJbnQoZGF0YVsxXSkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgY3B1OiBwYXJzZUZsb2F0KGRhdGFbMl0ucmVwbGFjZSgnLCcsICcuJykpLFxuICAgICAgICAgICAgICAgICAgICBtZW06IHBhcnNlRmxvYXQoZGF0YVszXS5yZXBsYWNlKCcsJywgJy4nKSlcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcHJvY1N0YXRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdFBvcyA9IC0xO1xuICAgICAgICAgICAgICAgIGxldCBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihyZXN1bHRbal0ucHJvYy50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RQb3MgPSBqO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvYykge1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcm9jLnRvTG93ZXJDYXNlKCkpID49IDAgJiYgIWluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcHJvYztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3Nlc1N0cmluZyA9PT0gJyonKSB8fCBpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaXN0UG9zIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvYzogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBwaWQ6IGl0ZW0ucGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZHM6IFtpdGVtLnBpZF0sXG4gICAgICAgICAgICAgICAgICAgICAgY3B1OiBpdGVtLmNwdSxcbiAgICAgICAgICAgICAgICAgICAgICBtZW06IGl0ZW0ubWVtXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucHBpZCA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLnBpZCA9IGl0ZW0ucGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5waWRzLnB1c2goaXRlbS5waWQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10uY3B1ICs9IGl0ZW0uY3B1O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10ubWVtICs9IGl0ZW0ubWVtO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3Nlc1N0cmluZyAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIG1pc3NpbmcgcHJvY2Vzc2VzXG4gICAgICAgICAgICAgICAgbGV0IHByb2Nlc3Nlc01pc3NpbmcgPSBwcm9jZXNzZXMuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY1N0YXRzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihuYW1lKSA+PSAwOyB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VzTWlzc2luZy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9jTmFtZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwcm9jOiBwcm9jTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGlkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwaWRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjIHByb2Nlc3NfY3B1IC0gcHMgaXMgbm90IGFjY3VyYXRlIGluIGxpbnV4IVxuICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICBpdGVtLmNwdSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGNtZCA9ICdjYXQgL3Byb2Mvc3RhdCB8IGdyZXAgXCJjcHUgXCInO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIGluIHJlc3VsdFtpXS5waWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtZCArPSAoJztjYXQgL3Byb2MvJyArIHJlc3VsdFtpXS5waWRzW2pdICsgJy9zdGF0Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY3Vycl9wcm9jZXNzZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgKGFsbCAtIC9wcm9jL3N0YXQpXG4gICAgICAgICAgICAgICAgICBsZXQgYWxsID0gcGFyc2VQcm9jU3RhdChjdXJyX3Byb2Nlc3Nlcy5zaGlmdCgpKTtcblxuICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgbGV0IGxpc3RfbmV3ID0ge307XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UHJvY2VzcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgY3Vycl9wcm9jZXNzZXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9jZXNzID0gY2FsY1Byb2NTdGF0TGludXgoZWxlbWVudCwgYWxsLCBfcHJvY2Vzc19jcHUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRQcm9jZXNzLnBpZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCByZXN1bHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRJdGVtSWQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5waWRzLmluZGV4T2YocmVzdWx0UHJvY2Vzcy5waWQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0SXRlbUlkID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcGNwdSBpbiBvdXRlciByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0SXRlbUlkID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRJdGVtSWRdLmNwdSArPSByZXN1bHRQcm9jZXNzLmNwdXUgKyByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgbGlzdF9uZXdbcmVzdWx0UHJvY2Vzcy5waWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B1dTogcmVzdWx0UHJvY2Vzcy5jcHV1LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3B1czogcmVzdWx0UHJvY2Vzcy5jcHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHJlc3VsdFByb2Nlc3MudXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGltZTogcmVzdWx0UHJvY2Vzcy5zdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dGltZTogcmVzdWx0UHJvY2Vzcy5jdXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3RpbWU6IHJlc3VsdFByb2Nlc3MuY3N0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY3B1ID0gTWF0aC5yb3VuZChpdGVtLmNwdSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1LmFsbCA9IGFsbDtcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5saXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgbGlzdF9uZXcpO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3NfY3B1Lm1zID0gRGF0ZS5ub3coKSAtIF9wcm9jZXNzX2NwdS5tcztcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5yZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnByb2Nlc3NMb2FkID0gcHJvY2Vzc0xvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHN5c3RlbS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDIuIFN5c3RlbSAoSGFyZHdhcmUsIEJJT1MsIEJhc2UgQm9hcmQpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgZXhlY1Byb21pc2UgPSB1dGlsLnByb21pc2lmeShyZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBzeXN0ZW0oY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgbW9kZWw6ICdDb21wdXRlcicsXG4gICAgICAgIHZlcnNpb246ICcnLFxuICAgICAgICBzZXJpYWw6ICctJyxcbiAgICAgICAgdXVpZDogJy0nLFxuICAgICAgICBza3U6ICctJyxcbiAgICAgICAgdmlydHVhbDogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCBzeXN0ZW0gMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJyk7XG4gICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3QgbmFtZScpO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbCBudW1iZXInKTtcbiAgICAgICAgICByZXN1bHQudXVpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd1dWlkJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXN1bHQuc2t1ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NrdSBudW1iZXInKTtcbiAgICAgICAgICAvLyBOb24tUm9vdCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcInByb2R1Y3RfbmFtZTogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF9uYW1lIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInByb2R1Y3Rfc2VyaWFsOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3NlcmlhbCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJwcm9kdWN0X3V1aWQ6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfdXVpZCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJwcm9kdWN0X3ZlcnNpb246IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfdmVyc2lvbiAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJzeXNfdmVuZG9yOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9zeXNfdmVuZG9yIDI+L2Rldi9udWxsOyBlY2hvO2A7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSByZXN1bHQubWFudWZhY3R1cmVyID09PSAnJyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzeXNfdmVuZG9yJykgOiByZXN1bHQubWFudWZhY3R1cmVyO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gcmVzdWx0Lm1vZGVsID09PSAnJyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0X25hbWUnKSA6IHJlc3VsdC5tb2RlbDtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gcmVzdWx0LnZlcnNpb24gPT09ICcnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3RfdmVyc2lvbicpIDogcmVzdWx0LnZlcnNpb247XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gcmVzdWx0LnNlcmlhbCA9PT0gJycgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdF9zZXJpYWwnKSA6IHJlc3VsdC5zZXJpYWw7XG4gICAgICAgICAgICByZXN1bHQudXVpZCA9IHJlc3VsdC51dWlkID09PSAnJyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0X3V1aWQnKS50b0xvd2VyQ2FzZSgpIDogcmVzdWx0LnV1aWQ7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnNlcmlhbCB8fCByZXN1bHQuc2VyaWFsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5zZXJpYWwgPSAnLSc7IH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5tYW51ZmFjdHVyZXIgfHwgcmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQubWFudWZhY3R1cmVyID0gJyc7IH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5tb2RlbCB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0Lm1vZGVsID0gJ0NvbXB1dGVyJzsgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnZlcnNpb24gfHwgcmVzdWx0LnZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnZlcnNpb24gPSAnJzsgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnNrdSB8fCByZXN1bHQuc2t1LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5za3UgPSAnLSc7IH1cblxuICAgICAgICAgIC8vIGRldGVjdCB2aXJ0dWFsICgxKVxuICAgICAgICAgIGlmIChyZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpcnR1YWxib3gnIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpID09PSAna3ZtJyB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpcnR1YWwgbWFjaGluZScgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkgPT09ICdib2NocycgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndm13YXJlJykgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZHJvcGxldCcpKSB7XG4gICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZpcnR1YWxib3gnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsQm94JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAndm13YXJlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAna3ZtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYm9jaHMnOlxuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdib2Nocyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgndm13YXJlJykgfHwgcmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpID09PSAneGVuJykge1xuICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgY2FzZSAndm13YXJlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAneGVuJzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnWGVuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQudmlydHVhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgZGlza3NCeUlkID0gZXhlY1N5bmMoJ2xzIC0xIC9kZXYvZGlzay9ieS1pZC8gMj4vZGV2L251bGwnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICBpZiAoZGlza3NCeUlkLmluZGV4T2YoJ19RRU1VXycpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1FFTVUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkaXNrc0J5SWQuaW5kZXhPZignX1ZCT1hfJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbEJveCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnZpcnR1YWwgJiYgKG9zLnJlbGVhc2UoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21pY3Jvc29mdCcpID49IDAgfHwgb3MucmVsZWFzZSgpLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJ3dzbDInKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFZlcnNpb24gPSBwYXJzZUZsb2F0KG9zLnJlbGVhc2UoKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnTWljcm9zb2Z0JztcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9ICdXU0wnO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBrZXJuZWxWZXJzaW9uIDwgNC4xOSA/ICcxJyA6ICcyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBwcm9jSW5mbyA9IGV4ZWNTeW5jKCdkbWlkZWNvZGUgLXQgNCcpO1xuICAgICAgICAgICAgICBjb25zdCBwcm9jTGluZXMgPSBwcm9jSW5mby50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY01hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUocHJvY0xpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChwcm9jTWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd2aXJ0dWFsYm94JzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsQm94JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Ztd2FyZSc6XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVk13YXJlJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2t2bSc6XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvY2hzJzpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdib2Nocyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGV0ZWN0IGRvY2tlclxuICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKCcvLmRvY2tlcmVudicpIHx8IGZzLmV4aXN0c1N5bmMoJy8uZG9ja2VyaW5pdCcpKSB7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSAnRG9ja2VyIENvbnRhaW5lcic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnZG1lc2cgMj4vZGV2L251bGwgfCBncmVwIC1pRSBcInZpcnR1YWx8aHlwZXJ2aXNvclwiIHwgZ3JlcCAtaUUgXCJ2bXdhcmV8cWVtdXxrdm18eGVuXCIgfCBncmVwIC12aUUgXCJOZXN0ZWQgVmlydHVhbGl6YXRpb258L3ZpcnR1YWwvXCInKTtcbiAgICAgICAgICAgIC8vIGRldGVjdCB2aXJ0dWFsIG1hY2hpbmVzXG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1vZGVsID09PSAnQ29tcHV0ZXInKSB7IHJlc3VsdC5tb2RlbCA9ICdWaXJ0dWFsIG1hY2hpbmUnOyB9XG4gICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndm13YXJlJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncWVtdScpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdRRU1VJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd4ZW4nKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnWGVuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdrdm0nKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQubWFudWZhY3R1cmVyID09PSAnJyAmJiByZXN1bHQubW9kZWwgPT09ICdDb21wdXRlcicgJiYgcmVzdWx0LnZlcnNpb24gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBSYXNwYmVycnkgUGlcbiAgICAgICAgICAgIGZzLnJlYWRGaWxlKCcvcHJvYy9jcHVpbmZvJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaGFyZHdhcmUnLCAnOicsIHRydWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncmV2aXNpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWwnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsOicsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIHZhbHVlczogaHR0cHM6Ly9lbGludXgub3JnL1JQaV9IYXJkd2FyZUhpc3RvcnlcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy5yYXNwYmVycnlwaS5vcmcvZG9jdW1lbnRhdGlvbi9oYXJkd2FyZS9yYXNwYmVycnlwaS9yZXZpc2lvbi1jb2Rlcy9SRUFETUUubWRcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI4MzUnIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI3MDgnIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI3MDknIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI3MTAnIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI3MTEnIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI4MzYnIHx8IHJlc3VsdC5tb2RlbCA9PT0gJ0JDTTI4MzcnKSAmJiBtb2RlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3Jhc3BiZXJyeScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJQSVJldmlzaW9uID0gdXRpbC5kZWNvZGVQaUNwdWluZm8obGluZXMpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gclBJUmV2aXNpb24ubW9kZWw7XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHJQSVJldmlzaW9uLnJldmlzaW9uQ29kZTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnUmFzcGJlcnJ5IFBpIEZvdW5kYXRpb24nO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnJhc3BiZXJyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWFudWZhY3R1cmVyOiByUElSZXZpc2lvbi5tYW51ZmFjdHVyZXIsXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NvcjogclBJUmV2aXNpb24ucHJvY2Vzc29yLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiByUElSZXZpc2lvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbjogclBJUmV2aXNpb24ucmV2aXNpb25cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdpb3JlZyAtYyBJT1BsYXRmb3JtRXhwZXJ0RGV2aWNlIC1kIDInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnJlcGxhY2UoL1s8PlwiXS9nLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsJywgJz0nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpb3BsYXRmb3Jtc2VyaWFsbnVtYmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC51dWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lvcGxhdGZvcm11dWlkJywgJz0nLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNrdSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZC1pZCcsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ29tcHV0ZXJTeXN0ZW1Qcm9kdWN0IHwgc2VsZWN0IE5hbWUsVmVuZG9yLFZlcnNpb24sSWRlbnRpZnlpbmdOdW1iZXIsVVVJRCB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlbmRvcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaWRlbnRpZnlpbmdudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQudXVpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd1dWlkJywgJzonKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAvLyBkZXRlY3QgdmlydHVhbCAoMSlcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG1vZGVsID09PSAndmlydHVhbGJveCcgfHwgbW9kZWwgPT09ICdrdm0nIHx8IG1vZGVsID09PSAndmlydHVhbCBtYWNoaW5lJyB8fCBtb2RlbCA9PT0gJ2JvY2hzJyB8fCBtb2RlbC5zdGFydHNXaXRoKCd2bXdhcmUnKSB8fCBtb2RlbC5zdGFydHNXaXRoKCdxZW11JykgfHwgbW9kZWwuc3RhcnRzV2l0aCgncGFyYWxsZWxzJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3ZpcnR1YWxib3gnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbEJveCc7IH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgndm13YXJlJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7IH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgna3ZtJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7IH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgnYm9jaHMnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnYm9jaHMnOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3FlbXUnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnS1ZNJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdwYXJhbGxlbHMnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnUGFyYWxsZWxzJzsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IG1hbnVmYWN0dXJlciA9IHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCd2bXdhcmUnKSB8fCBtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgncWVtdScpIHx8IG1hbnVmYWN0dXJlciA9PT0gJ3hlbicgfHwgbWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3BhcmFsbGVscycpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgndm13YXJlJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7IH1cbiAgICAgICAgICAgICAgICBpZiAobWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3hlbicpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdYZW4nOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCdxZW11JykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7IH1cbiAgICAgICAgICAgICAgICBpZiAobWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3BhcmFsbGVscycpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdQYXJhbGxlbHMnOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgTVNfU3lzdGVtaW5mb3JtYXRpb24gLU5hbWVzcGFjZSBcInJvb3Qvd21pXCIgfCBzZWxlY3Qgc3lzdGVtc2t1IHwgZmwgJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuc2t1ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N5c3RlbXNrdScsICc6Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZpcnR1YWwpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX2Jpb3MgfCBzZWxlY3QgVmVyc2lvbiwgU2VyaWFsTnVtYmVyLCBTTUJJT1NCSU9TVmVyc2lvbicpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdWUlRVQUwnKSA+PSAwIHx8IGxpbmVzLmluZGV4T2YoJ0EgTSBJICcpID49IDAgfHwgbGluZXMuaW5kZXhPZignVmlydHVhbEJveCcpID49IDAgfHwgbGluZXMuaW5kZXhPZignVk1XYXJlJykgPj0gMCB8fCBsaW5lcy5pbmRleE9mKCdYZW4nKSA+PSAwIHx8IGxpbmVzLmluZGV4T2YoJ1BhcmFsbGVscycpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdWaXJ0dWFsQm94JykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsQm94JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdWTXdhcmUnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignWGVuJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdYZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1ZSVFVBTCcpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnSHlwZXItVic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignQSBNIEknKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWwgUEMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1BhcmFsbGVscycpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnUGFyYWxsZWxzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5zeXN0ZW0gPSBzeXN0ZW07XG5cbmZ1bmN0aW9uIGJpb3MoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIHJlbGVhc2VEYXRlOiAnJyxcbiAgICAgICAgcmV2aXNpb246ICcnLFxuICAgICAgfTtcbiAgICAgIGxldCBjbWQgPSAnJztcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgICAgIGNtZCA9ICdjYXQgL3Byb2MvY3B1aW5mbyB8IGdyZXAgU2VyaWFsJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgYmlvcyAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJztcbiAgICAgICAgfVxuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0LnZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdWZW5kb3InKTtcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdWZXJzaW9uJyk7XG4gICAgICAgICAgbGV0IGRhdGV0aW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JlbGVhc2UgRGF0ZScpO1xuICAgICAgICAgIHJlc3VsdC5yZWxlYXNlRGF0ZSA9IHV0aWwucGFyc2VEYXRlVGltZShkYXRldGltZSkuZGF0ZTtcbiAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQklPUyBSZXZpc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsTnVtYmVyJyk7XG4gICAgICAgICAgbGV0IGxhbmd1YWdlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0N1cnJlbnRseSBJbnN0YWxsZWQgTGFuZ3VhZ2UnKS5zcGxpdCgnfCcpWzBdO1xuICAgICAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICAgICAgcmVzdWx0Lmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggJiYgc3Rkb3V0LnRvU3RyaW5nKCkuaW5kZXhPZignQ2hhcmFjdGVyaXN0aWNzOicpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcgaXMgc3VwcG9ydGVkJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSBsaW5lLnNwbGl0KCcgaXMgc3VwcG9ydGVkJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vbi1Sb290IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwiYmlvc19kYXRlOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9iaW9zX2RhdGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYmlvc192ZW5kb3I6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2Jpb3NfdmVuZG9yIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJpb3NfdmVyc2lvbjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYmlvc192ZXJzaW9uIDI+L2Rldi9udWxsOyBlY2hvO2A7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSAhcmVzdWx0LnZlbmRvciA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdiaW9zX3ZlbmRvcicpIDogcmVzdWx0LnZlbmRvcjtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gIXJlc3VsdC52ZXJzaW9uID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Jpb3NfdmVyc2lvbicpIDogcmVzdWx0LnZlcnNpb247XG4gICAgICAgICAgICBkYXRldGltZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdiaW9zX2RhdGUnKTtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxlYXNlRGF0ZSA9ICFyZXN1bHQucmVsZWFzZURhdGUgPyB1dGlsLnBhcnNlRGF0ZVRpbWUoZGF0ZXRpbWUpLmRhdGUgOiByZXN1bHQucmVsZWFzZURhdGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIHJlc3VsdC52ZW5kb3IgPSAnQXBwbGUgSW5jLic7XG4gICAgICAgIGV4ZWMoXG4gICAgICAgICAgJ3N5c3RlbV9wcm9maWxlciBTUEhhcmR3YXJlRGF0YVR5cGUgLWpzb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgaGFyZHdhcmVEYXRhID0gSlNPTi5wYXJzZShzdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGlmIChoYXJkd2FyZURhdGEgJiYgaGFyZHdhcmVEYXRhLlNQSGFyZHdhcmVEYXRhVHlwZSAmJiBoYXJkd2FyZURhdGEuU1BIYXJkd2FyZURhdGFUeXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBib290Um9tVmVyc2lvbiA9IGhhcmR3YXJlRGF0YS5TUEhhcmR3YXJlRGF0YVR5cGVbMF0uYm9vdF9yb21fdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBib290Um9tVmVyc2lvbiA9IGJvb3RSb21WZXJzaW9uID8gYm9vdFJvbVZlcnNpb24uc3BsaXQoJygnKVswXS50cmltKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gYm9vdFJvbVZlcnNpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICByZXN1bHQudmVuZG9yID0gJ1N1biBNaWNyb3N5c3RlbXMnO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9iaW9zIHwgc2VsZWN0IERlc2NyaXB0aW9uLFZlcnNpb24sTWFudWZhY3R1cmVyLEB7bj1cIlJlbGVhc2VEYXRlXCI7ZT17JF8uUmVsZWFzZURhdGUuVG9TdHJpbmcoXCJ5eXl5LU1NLWRkXCIpfX0sQnVpbGROdW1iZXIsU2VyaWFsTnVtYmVyIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZGVzY3JpcHRpb24nLCAnOicpO1xuICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24uaW5kZXhPZignIFZlcnNpb24gJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uIFBob2VuaXggUk9NIEJJT1MgUExVUyBWZXJzaW9uIDEuMTAgQTA0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IGRlc2NyaXB0aW9uLnNwbGl0KCcgVmVyc2lvbiAnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBkZXNjcmlwdGlvbi5zcGxpdCgnIFZlcnNpb24gJylbMV0udHJpbSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLmluZGV4T2YoJyBWZXI6ICcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBCSU9TIERhdGU6IDA2LzI3LzE2IDE3OjUwOjE2IFZlcjogMS40LjVcbiAgICAgICAgICAgICAgICByZXN1bHQudmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBkZXNjcmlwdGlvbi5zcGxpdCgnIFZlcjogJylbMV0udHJpbSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJzonKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZURhdGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncmVsZWFzZWRhdGUnLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYnVpbGRudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5iaW9zID0gYmlvcztcblxuZnVuY3Rpb24gYmFzZWJvYXJkKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIHNlcmlhbDogJy0nLFxuICAgICAgICBhc3NldFRhZzogJy0nLFxuICAgICAgICBtZW1NYXg6IG51bGwsXG4gICAgICAgIG1lbVNsb3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgbGV0IGNtZCA9ICcnO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAgICAgY21kID0gJ2NhdCAvcHJvYy9jcHVpbmZvIHwgZ3JlcCBTZXJpYWwnO1xuICAgICAgICAgIC8vICdCQ00yNzA5JywgJ0JDTTI4MzUnLCAnQkNNMjcwOCcgLS0+XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IDIgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgd29ya2xvYWQucHVzaChleGVjUHJvbWlzZShjbWQpKTtcbiAgICAgICAgd29ya2xvYWQucHVzaChleGVjUHJvbWlzZSgnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgbWVtb3J5IDI+L2Rldi9udWxsJykpO1xuICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gZGF0YS5yZXN1bHRzWzBdID8gZGF0YS5yZXN1bHRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpIDogWycnXTtcbiAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hbnVmYWN0dXJlcicpO1xuICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9kdWN0IE5hbWUnKTtcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdWZXJzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWwgTnVtYmVyJyk7XG4gICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Fzc2V0IFRhZycpO1xuICAgICAgICAgIC8vIE5vbi1Sb290IHZhbHVlc1xuICAgICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwiYm9hcmRfYXNzZXRfdGFnOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9ib2FyZF9hc3NldF90YWcgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYm9hcmRfbmFtZTogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYm9hcmRfbmFtZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJib2FyZF9zZXJpYWw6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2JvYXJkX3NlcmlhbCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJib2FyZF92ZW5kb3I6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2JvYXJkX3ZlbmRvciAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJib2FyZF92ZXJzaW9uOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9ib2FyZF92ZXJzaW9uIDI+L2Rldi9udWxsOyBlY2hvO2A7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAhcmVzdWx0Lm1hbnVmYWN0dXJlciA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZF92ZW5kb3InKSA6IHJlc3VsdC5tYW51ZmFjdHVyZXI7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSAhcmVzdWx0Lm1vZGVsID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkX25hbWUnKSA6IHJlc3VsdC5tb2RlbDtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gIXJlc3VsdC52ZXJzaW9uID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkX3ZlcnNpb24nKSA6IHJlc3VsdC52ZXJzaW9uO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9ICFyZXN1bHQuc2VyaWFsID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkX3NlcmlhbCcpIDogcmVzdWx0LnNlcmlhbDtcbiAgICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9ICFyZXN1bHQuYXNzZXRUYWcgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmRfYXNzZXRfdGFnJykgOiByZXN1bHQuYXNzZXRUYWc7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuc2VyaWFsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5zZXJpYWwgPSAnLSc7IH1cbiAgICAgICAgICBpZiAocmVzdWx0LmFzc2V0VGFnLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5hc3NldFRhZyA9ICctJzsgfVxuXG4gICAgICAgICAgLy8gbWVtXG4gICAgICAgICAgbGluZXMgPSBkYXRhLnJlc3VsdHNbMV0gPyBkYXRhLnJlc3VsdHNbMV0udG9TdHJpbmcoKS5zcGxpdCgnXFxuJykgOiBbJyddO1xuICAgICAgICAgIHJlc3VsdC5tZW1NYXggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYXhpbXVtIENhcGFjaXR5JykpICogMTAyNCAqIDEwMjQgKiAxMDI0IHx8IG51bGw7XG4gICAgICAgICAgcmVzdWx0Lm1lbVNsb3RzID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTnVtYmVyIE9mIERldmljZXMnKSkgfHwgbnVsbDtcblxuICAgICAgICAgIC8vIHJhc3BiZXJyeVxuICAgICAgICAgIGxldCBsaW5lc1JwaSA9ICcnO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5lc1JwaSA9IGZzLnJlYWRGaWxlU3luYygnL3Byb2MvY3B1aW5mbycpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBoYXJkd2FyZSA9IHV0aWwuZ2V0VmFsdWUobGluZXNScGksICdoYXJkd2FyZScpO1xuICAgICAgICAgIGlmIChoYXJkd2FyZS5zdGFydHNXaXRoKCdCQ00nKSkge1xuICAgICAgICAgICAgY29uc3QgcnBpID0gdXRpbC5kZWNvZGVQaUNwdWluZm8obGluZXNScGkpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHJwaS5tYW51ZmFjdHVyZXI7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSAnUmFzcGJlcnJ5IFBpJztcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSBycGkuc2VyaWFsO1xuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBycGkudHlwZSArICcgLSAnICsgcnBpLnJldmlzaW9uO1xuICAgICAgICAgICAgcmVzdWx0Lm1lbU1heCA9IG9zLnRvdGFsbWVtKCk7XG4gICAgICAgICAgICByZXN1bHQubWVtU2xvdHMgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgIHdvcmtsb2FkLnB1c2goZXhlY1Byb21pc2UoJ2lvcmVnIC1jIElPUGxhdGZvcm1FeHBlcnREZXZpY2UgLWQgMicpKTtcbiAgICAgICAgd29ya2xvYWQucHVzaChleGVjUHJvbWlzZSgnc3lzdGVtX3Byb2ZpbGVyIFNQTWVtb3J5RGF0YVR5cGUnKSk7XG4gICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhLnJlc3VsdHNbMF0gPyBkYXRhLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5yZXBsYWNlKC9bPD5cIl0vZywgJycpLnNwbGl0KCdcXG4nKSA6IFsnJ107XG4gICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCcsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpb3BsYXRmb3Jtc2VyaWFsbnVtYmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmQtaWQnLCAnPScsIHRydWUpO1xuXG4gICAgICAgICAgLy8gbWVtXG4gICAgICAgICAgbGV0IGRldmljZXMgPSBkYXRhLnJlc3VsdHNbMV0gPyBkYXRhLnJlc3VsdHNbMV0udG9TdHJpbmcoKS5zcGxpdCgnICAgICAgICBCQU5LICcpIDogWycnXTtcbiAgICAgICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGRldmljZXMgPSBkYXRhLnJlc3VsdHNbMV0gPyBkYXRhLnJlc3VsdHNbMV0udG9TdHJpbmcoKS5zcGxpdCgnICAgICAgICBESU1NJykgOiBbJyddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgcmVzdWx0Lm1lbVNsb3RzID0gZGV2aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAob3MuYXJjaCgpID09PSAnYXJtNjQnKSB7XG4gICAgICAgICAgICByZXN1bHQubWVtU2xvdHMgPSAwO1xuICAgICAgICAgICAgcmVzdWx0Lm1lbU1heCA9IG9zLnRvdGFsbWVtKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICAgIGNvbnN0IHdpbjEwcGx1cyA9IHBhcnNlSW50KG9zLnJlbGVhc2UoKSkgPj0gMTA7XG4gICAgICAgICAgY29uc3QgbWF4Q2FwYWNpdHlBdHRyaWJ1dGUgPSB3aW4xMHBsdXMgPyAnTWF4Q2FwYWNpdHlFeCcgOiAnTWF4Q2FwYWNpdHknO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfYmFzZWJvYXJkIHwgc2VsZWN0IE1vZGVsLE1hbnVmYWN0dXJlcixQcm9kdWN0LFZlcnNpb24sU2VyaWFsTnVtYmVyLFBhcnROdW1iZXIsU0tVIHwgZmwnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoYEdldC1DaW1JbnN0YW5jZSBXaW4zMl9waHlzaWNhbG1lbW9yeWFycmF5IHwgc2VsZWN0ICR7bWF4Q2FwYWNpdHlBdHRyaWJ1dGV9LCBNZW1vcnlEZXZpY2VzIHwgZmxgKSk7XG4gICAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGEucmVzdWx0c1swXSA/IGRhdGEucmVzdWx0c1swXS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKSA6IFsnJ107XG5cbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCcsICc6Jyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5tb2RlbCkge1xuICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdCcsICc6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJzonKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsbnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwYXJ0bnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmFzc2V0VGFnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdza3UnLCAnOicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtZW1waHlzaWNhbFxuICAgICAgICAgICAgbGluZXMgPSBkYXRhLnJlc3VsdHNbMV0gPyBkYXRhLnJlc3VsdHNbMV0udG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJykgOiBbJyddO1xuICAgICAgICAgICAgcmVzdWx0Lm1lbU1heCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgbWF4Q2FwYWNpdHlBdHRyaWJ1dGUsICc6JykpICogKHdpbjEwcGx1cyA/IDEwMjQgOiAxKSB8fCBudWxsO1xuICAgICAgICAgICAgcmVzdWx0Lm1lbVNsb3RzID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWVtb3J5RGV2aWNlcycsICc6JykpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5iYXNlYm9hcmQgPSBiYXNlYm9hcmQ7XG5cbmZ1bmN0aW9uIGNoYXNzaXMoY2FsbGJhY2spIHtcbiAgY29uc3QgY2hhc3Npc1R5cGVzID0gWydPdGhlcicsXG4gICAgJ1Vua25vd24nLFxuICAgICdEZXNrdG9wJyxcbiAgICAnTG93IFByb2ZpbGUgRGVza3RvcCcsXG4gICAgJ1BpenphIEJveCcsXG4gICAgJ01pbmkgVG93ZXInLFxuICAgICdUb3dlcicsXG4gICAgJ1BvcnRhYmxlJyxcbiAgICAnTGFwdG9wJyxcbiAgICAnTm90ZWJvb2snLFxuICAgICdIYW5kIEhlbGQnLFxuICAgICdEb2NraW5nIFN0YXRpb24nLFxuICAgICdBbGwgaW4gT25lJyxcbiAgICAnU3ViIE5vdGVib29rJyxcbiAgICAnU3BhY2UtU2F2aW5nJyxcbiAgICAnTHVuY2ggQm94JyxcbiAgICAnTWFpbiBTeXN0ZW0gQ2hhc3NpcycsXG4gICAgJ0V4cGFuc2lvbiBDaGFzc2lzJyxcbiAgICAnU3ViQ2hhc3NpcycsXG4gICAgJ0J1cyBFeHBhbnNpb24gQ2hhc3NpcycsXG4gICAgJ1BlcmlwaGVyYWwgQ2hhc3NpcycsXG4gICAgJ1N0b3JhZ2UgQ2hhc3NpcycsXG4gICAgJ1JhY2sgTW91bnQgQ2hhc3NpcycsXG4gICAgJ1NlYWxlZC1DYXNlIFBDJyxcbiAgICAnTXVsdGktU3lzdGVtIENoYXNzaXMnLFxuICAgICdDb21wYWN0IFBDSScsXG4gICAgJ0FkdmFuY2VkIFRDQScsXG4gICAgJ0JsYWRlJyxcbiAgICAnQmxhZGUgRW5jbG9zdXJlJyxcbiAgICAnVGFibGV0JyxcbiAgICAnQ29udmVydGlibGUnLFxuICAgICdEZXRhY2hhYmxlJyxcbiAgICAnSW9UIEdhdGV3YXkgJyxcbiAgICAnRW1iZWRkZWQgUEMnLFxuICAgICdNaW5pIFBDJyxcbiAgICAnU3RpY2sgUEMnLFxuICBdO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICBtb2RlbDogJycsXG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICB2ZXJzaW9uOiAnJyxcbiAgICAgICAgc2VyaWFsOiAnLScsXG4gICAgICAgIGFzc2V0VGFnOiAnLScsXG4gICAgICAgIHNrdTogJycsXG4gICAgICB9O1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwiY2hhc3Npc19hc3NldF90YWc6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2NoYXNzaXNfYXNzZXRfdGFnIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNoYXNzaXNfc2VyaWFsOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9jaGFzc2lzX3NlcmlhbCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjaGFzc2lzX3R5cGU6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2NoYXNzaXNfdHlwZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjaGFzc2lzX3ZlbmRvcjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvY2hhc3Npc192ZW5kb3IgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2hhc3Npc192ZXJzaW9uOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9jaGFzc2lzX3ZlcnNpb24gMj4vZGV2L251bGw7IGVjaG87YDtcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhc3Npc192ZW5kb3InKTtcbiAgICAgICAgICBjb25zdCBjdHlwZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFzc2lzX3R5cGUnKS5yZXBsYWNlKC9cXEQvZywgJycpKTtcbiAgICAgICAgICByZXN1bHQudHlwZSA9IChjdHlwZSAmJiAhaXNOYU4oY3R5cGUpICYmIGN0eXBlIDwgY2hhc3Npc1R5cGVzLmxlbmd0aCkgPyBjaGFzc2lzVHlwZXNbY3R5cGUgLSAxXSA6ICcnO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYXNzaXNfdmVyc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhc3Npc19zZXJpYWwnKTtcbiAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhc3Npc19hc3NldF90YWcnKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQubWFudWZhY3R1cmVyID0gJy0nOyB9XG4gICAgICAgICAgaWYgKHJlc3VsdC52ZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC52ZXJzaW9uID0gJy0nOyB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5zZXJpYWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnNlcmlhbCA9ICctJzsgfVxuICAgICAgICAgIGlmIChyZXN1bHQuYXNzZXRUYWcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LmFzc2V0VGFnID0gJy0nOyB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdpb3JlZyAtYyBJT1BsYXRmb3JtRXhwZXJ0RGV2aWNlIC1kIDInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnJlcGxhY2UoL1s8PlwiXS9nLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnPScsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpb3BsYXRmb3Jtc2VyaWFsbnVtYmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZC1pZCcsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9TeXN0ZW1FbmNsb3N1cmUgfCBzZWxlY3QgTW9kZWwsTWFudWZhY3R1cmVyLENoYXNzaXNUeXBlcyxWZXJzaW9uLFNlcmlhbE51bWJlcixQYXJ0TnVtYmVyLFNLVSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG5cbiAgICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwnLCAnOicpO1xuICAgICAgICAgICAgICBjb25zdCBjdHlwZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDaGFzc2lzVHlwZXMnLCAnOicpLnJlcGxhY2UoL1xcRC9nLCAnJykpO1xuICAgICAgICAgICAgICByZXN1bHQudHlwZSA9IChjdHlwZSAmJiAhaXNOYU4oY3R5cGUpICYmIGN0eXBlIDwgY2hhc3Npc1R5cGVzLmxlbmd0aCkgPyBjaGFzc2lzVHlwZXNbY3R5cGUgLSAxXSA6ICcnO1xuICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWxudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncGFydG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5za3UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2t1JywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICctJzsgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnZlcnNpb24gPSAnLSc7IH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zZXJpYWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0LnNlcmlhbCA9ICctJzsgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0LmFzc2V0VGFnLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5hc3NldFRhZyA9ICctJzsgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY2hhc3NpcyA9IGNoYXNzaXM7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHVzYi5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDE2LiB1c2Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gZ2V0TGludXhVc2JUeXBlKHR5cGUsIG5hbWUpIHtcbiAgbGV0IHJlc3VsdCA9IHR5cGU7XG4gIGNvbnN0IHN0ciA9IChuYW1lICsgJyAnICsgdHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHN0ci5pbmRleE9mKCdjYW1lcmEnKSA+PSAwKSB7IHJlc3VsdCA9ICdDYW1lcmEnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdodWInKSA+PSAwKSB7IHJlc3VsdCA9ICdIdWInOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdrZXlicmQnKSA+PSAwKSB7IHJlc3VsdCA9ICdLZXlib2FyZCc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2tleWJvYXJkJykgPj0gMCkgeyByZXN1bHQgPSAnS2V5Ym9hcmQnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdtb3VzZScpID49IDApIHsgcmVzdWx0ID0gJ01vdXNlJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignc3RvcmEnKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignbWljJykgPj0gMCkgeyByZXN1bHQgPSAnTWljcm9waG9uZSc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2hlYWRzZXQnKSA+PSAwKSB7IHJlc3VsdCA9ICdBdWRpbyc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ2F1ZGlvJykgPj0gMCkgeyByZXN1bHQgPSAnQXVkaW8nOyB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eFVzYih1c2IpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGxpbmVzID0gdXNiLnNwbGl0KCdcXG4nKTtcbiAgaWYgKGxpbmVzICYmIGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5pbmRleE9mKCdEZXZpY2UnKSA+PSAwKSB7XG4gICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICAgIHJlc3VsdC5idXMgPSBwYXJzZUludChwYXJ0c1swXSwgMTApO1xuICAgIGlmIChwYXJ0c1syXSkge1xuICAgICAgcmVzdWx0LmRldmljZUlkID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmRldmljZUlkID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LmJ1cyA9IG51bGw7XG4gICAgcmVzdWx0LmRldmljZUlkID0gbnVsbDtcbiAgfVxuICBjb25zdCBpZFZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpZFZlbmRvcicsICcgJywgdHJ1ZSkudHJpbSgpO1xuICBsZXQgdmVuZG9yUGFydHMgPSBpZFZlbmRvci5zcGxpdCgnICcpO1xuICB2ZW5kb3JQYXJ0cy5zaGlmdCgpO1xuICBjb25zdCB2ZW5kb3IgPSB2ZW5kb3JQYXJ0cy5qb2luKCcgJyk7XG5cbiAgY29uc3QgaWRQcm9kdWN0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lkUHJvZHVjdCcsICcgJywgdHJ1ZSkudHJpbSgpO1xuICBsZXQgcHJvZHVjdFBhcnRzID0gaWRQcm9kdWN0LnNwbGl0KCcgJyk7XG4gIHByb2R1Y3RQYXJ0cy5zaGlmdCgpO1xuICBjb25zdCBwcm9kdWN0ID0gcHJvZHVjdFBhcnRzLmpvaW4oJyAnKTtcblxuICBjb25zdCBpbnRlcmZhY2VDbGFzcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdiSW50ZXJmYWNlQ2xhc3MnLCAnICcsIHRydWUpLnRyaW0oKTtcbiAgbGV0IGludGVyZmFjZUNsYXNzUGFydHMgPSBpbnRlcmZhY2VDbGFzcy5zcGxpdCgnICcpO1xuICBpbnRlcmZhY2VDbGFzc1BhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHVzYlR5cGUgPSBpbnRlcmZhY2VDbGFzc1BhcnRzLmpvaW4oJyAnKTtcblxuICBjb25zdCBpTWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lNYW51ZmFjdHVyZXInLCAnICcsIHRydWUpLnRyaW0oKTtcbiAgbGV0IGlNYW51ZmFjdHVyZXJQYXJ0cyA9IGlNYW51ZmFjdHVyZXIuc3BsaXQoJyAnKTtcbiAgaU1hbnVmYWN0dXJlclBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IG1hbnVmYWN0dXJlciA9IGlNYW51ZmFjdHVyZXJQYXJ0cy5qb2luKCcgJyk7XG5cbiAgcmVzdWx0LmlkID0gKGlkVmVuZG9yLnN0YXJ0c1dpdGgoJzB4JykgPyBpZFZlbmRvci5zcGxpdCgnICcpWzBdLnN1YnN0cigyLCAxMCkgOiAnJykgKyAnOicgKyAoaWRQcm9kdWN0LnN0YXJ0c1dpdGgoJzB4JykgPyBpZFByb2R1Y3Quc3BsaXQoJyAnKVswXS5zdWJzdHIoMiwgMTApIDogJycpO1xuICByZXN1bHQubmFtZSA9IHByb2R1Y3Q7XG4gIHJlc3VsdC50eXBlID0gZ2V0TGludXhVc2JUeXBlKHVzYlR5cGUsIHByb2R1Y3QpO1xuICByZXN1bHQucmVtb3ZhYmxlID0gbnVsbDtcbiAgcmVzdWx0LnZlbmRvciA9IHZlbmRvcjtcbiAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IG1hbnVmYWN0dXJlcjtcbiAgcmVzdWx0Lm1heFBvd2VyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01heFBvd2VyJywgJyAnLCB0cnVlKTtcbiAgcmVzdWx0LnNlcmlhbE51bWJlciA9IG51bGw7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGFyd2luVXNiVHlwZShuYW1lKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKG5hbWUuaW5kZXhPZignY2FtZXJhJykgPj0gMCkgeyByZXN1bHQgPSAnQ2FtZXJhJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3RvdWNoIGJhcicpID49IDApIHsgcmVzdWx0ID0gJ1RvdWNoIEJhcic7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdjb250cm9sbGVyJykgPj0gMCkgeyByZXN1bHQgPSAnQ29udHJvbGxlcic7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdoZWFkc2V0JykgPj0gMCkgeyByZXN1bHQgPSAnQXVkaW8nOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigna2V5Ym9hcmQnKSA+PSAwKSB7IHJlc3VsdCA9ICdLZXlib2FyZCc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCd0cmFja3BhZCcpID49IDApIHsgcmVzdWx0ID0gJ1RyYWNrcGFkJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3NlbnNvcicpID49IDApIHsgcmVzdWx0ID0gJ1NlbnNvcic7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdidGh1c2InKSA+PSAwKSB7IHJlc3VsdCA9ICdCbHVldG9vdGgnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignYnRoJykgPj0gMCkgeyByZXN1bHQgPSAnQmx1ZXRvb3RoJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3JmY29tbScpID49IDApIHsgcmVzdWx0ID0gJ0JsdWV0b290aCc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCd1c2JodWInKSA+PSAwKSB7IHJlc3VsdCA9ICdIdWInOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignIGh1YicpID49IDApIHsgcmVzdWx0ID0gJ0h1Yic7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdtb3VzZScpID49IDApIHsgcmVzdWx0ID0gJ01vdXNlJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ21pYycpID49IDApIHsgcmVzdWx0ID0gJ01pY3JvcGhvbmUnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigncmVtb3ZhYmxlJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBwYXJzZURhcndpblVzYih1c2IsIGlkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICByZXN1bHQuaWQgPSBpZDtcblxuICB1c2IgPSB1c2IucmVwbGFjZSgvIFxcfC9nLCAnJyk7XG4gIHVzYiA9IHVzYi50cmltKCk7XG4gIGxldCBsaW5lcyA9IHVzYi5zcGxpdCgnXFxuJyk7XG4gIGxpbmVzLnNoaWZ0KCk7XG4gIHRyeSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UoLz0vZywgJzonKTtcbiAgICAgIGlmIChsaW5lc1tpXSAhPT0gJ3snICYmIGxpbmVzW2ldICE9PSAnfScgJiYgbGluZXNbaSArIDFdICYmIGxpbmVzW2kgKyAxXS50cmltKCkgIT09ICd9Jykge1xuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldICsgJywnO1xuICAgICAgfVxuICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS5yZXBsYWNlKCc6IFllcywnLCAnOiBcIlllc1wiLCcpO1xuICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS5yZXBsYWNlKCc6IE5vLCcsICc6IFwiTm9cIiwnKTtcbiAgICB9XG4gICAgY29uc3QgdXNiT2JqID0gSlNPTi5wYXJzZShsaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgY29uc3QgcmVtb3ZhYmxlRHJpdmUgPSB1c2JPYmpbJ0J1aWx0LUluJ10udG9Mb3dlckNhc2UoKSAhPT0gJ3llcycgJiYgdXNiT2JqWydub24tcmVtb3ZhYmxlJ10udG9Mb3dlckNhc2UoKSA9PT0gJ25vJztcblxuICAgIHJlc3VsdC5idXMgPSBudWxsO1xuICAgIHJlc3VsdC5kZXZpY2VJZCA9IG51bGw7XG4gICAgcmVzdWx0LmlkID0gdXNiT2JqWydVU0IgQWRkcmVzcyddIHx8IG51bGw7XG4gICAgcmVzdWx0Lm5hbWUgPSB1c2JPYmpbJ2tVU0JQcm9kdWN0U3RyaW5nJ10gfHwgdXNiT2JqWydVU0IgUHJvZHVjdCBOYW1lJ10gfHwgbnVsbDtcbiAgICByZXN1bHQudHlwZSA9IGdldERhcndpblVzYlR5cGUoKHVzYk9ialsna1VTQlByb2R1Y3RTdHJpbmcnXSB8fCB1c2JPYmpbJ1VTQiBQcm9kdWN0IE5hbWUnXSB8fCAnJykudG9Mb3dlckNhc2UoKSArIChyZW1vdmFibGVEcml2ZSA/ICcgcmVtb3ZhYmxlJyA6ICcnKSk7XG4gICAgcmVzdWx0LnJlbW92YWJsZSA9IHVzYk9ialsnbm9uLXJlbW92YWJsZSddLnRvTG93ZXJDYXNlKCkgPT09ICdubyc7XG4gICAgcmVzdWx0LnZlbmRvciA9IHVzYk9ialsna1VTQlZlbmRvclN0cmluZyddIHx8IHVzYk9ialsnVVNCIFZlbmRvciBOYW1lJ10gfHwgbnVsbDtcbiAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXNiT2JqWydrVVNCVmVuZG9yU3RyaW5nJ10gfHwgdXNiT2JqWydVU0IgVmVuZG9yIE5hbWUnXSB8fCBudWxsO1xuICAgIHJlc3VsdC5tYXhQb3dlciA9IG51bGw7XG4gICAgcmVzdWx0LnNlcmlhbE51bWJlciA9IHVzYk9ialsna1VTQlNlcmlhbE51bWJlclN0cmluZyddIHx8IG51bGw7XG5cbiAgICBpZiAocmVzdWx0Lm5hbWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NVc2JUeXBlQ3JlYXRpb24oY3JlYXRpb25jbGFzcywgbmFtZSkge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmIChuYW1lLmluZGV4T2YoJ3N0b3JhZ2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3NwZWljaGVyJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCd1c2JodWInKSA+PSAwKSB7IHJlc3VsdCA9ICdIdWInOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZignc3RvcmFnZScpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZigndXNiY29udHJvbGxlcicpID49IDApIHsgcmVzdWx0ID0gJ0NvbnRyb2xsZXInOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZigna2V5Ym9hcmQnKSA+PSAwKSB7IHJlc3VsdCA9ICdLZXlib2FyZCc7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCdwb2ludGluZycpID49IDApIHsgcmVzdWx0ID0gJ01vdXNlJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ2Rpc2snKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NVc2IobGluZXMsIGlkKSB7XG4gIGNvbnN0IHVzYlR5cGUgPSBnZXRXaW5kb3dzVXNiVHlwZUNyZWF0aW9uKHV0aWwuZ2V0VmFsdWUobGluZXMsICdDcmVhdGlvbkNsYXNzTmFtZScsICc6JykudG9Mb3dlckNhc2UoKSwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpLnRvTG93ZXJDYXNlKCkpO1xuXG4gIGlmICh1c2JUeXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0LmJ1cyA9IG51bGw7XG4gICAgcmVzdWx0LmRldmljZUlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2RldmljZWlkJywgJzonKTtcbiAgICByZXN1bHQuaWQgPSBpZDtcbiAgICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKTtcbiAgICByZXN1bHQudHlwZSA9IHVzYlR5cGU7XG4gICAgcmVzdWx0LnJlbW92YWJsZSA9IG51bGw7XG4gICAgcmVzdWx0LnZlbmRvciA9IG51bGw7XG4gICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYW51ZmFjdHVyZXInLCAnOicpO1xuICAgIHJlc3VsdC5tYXhQb3dlciA9IG51bGw7XG4gICAgcmVzdWx0LnNlcmlhbE51bWJlciA9IG51bGw7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzYihjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBjb25zdCBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBsc3VzYiAtdiAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJztcbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCAqIDEyOCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gKCdcXG5cXG4nICsgc3Rkb3V0LnRvU3RyaW5nKCkpLnNwbGl0KCdcXG5cXG5CdXMgJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYiA9IHBhcnNlTGludXhVc2IocGFydHNbaV0pO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh1c2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ2lvcmVnIC1wIElPVVNCIC1jIEFwcGxlVVNCUm9vdEh1YkRldmljZSAtdzAgLWwnO1xuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0ICogMTI4IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSAoc3Rkb3V0LnRvU3RyaW5nKCkpLnNwbGl0KCcgKy1vICcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCB1c2IgPSBwYXJzZURhcndpblVzYihwYXJ0c1tpXSk7XG4gICAgICAgICAgICAgIGlmICh1c2IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1c2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIENJTV9Mb2dpY2FsRGV2aWNlIHwgd2hlcmUgeyAkXy5EZXNjcmlwdGlvbiAtbWF0Y2ggXCJVU0JcIn0gfCBzZWxlY3QgTmFtZSxDcmVhdGlvbkNsYXNzTmFtZSxEZXZpY2VJZCxNYW51ZmFjdHVyZXIgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYiA9IHBhcnNlV2luZG93c1VzYihwYXJ0c1tpXS5zcGxpdCgnXFxuJyksIGkpO1xuICAgICAgICAgICAgICBpZiAodXNiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godXNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMudXNiID0gdXNiO1xuXG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHVzZXJzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMTEuIFVzZXJzL1Nlc3Npb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIHBhcnNlVXNlcnNMaW51eChsaW5lcywgcGhhc2UpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBsZXQgcmVzdWx0X3dobyA9IFtdO1xuICBsZXQgcmVzdWx0X3cgPSB7fTtcbiAgbGV0IHdfZmlyc3QgPSB0cnVlO1xuICBsZXQgd19oZWFkZXIgPSBbXTtcbiAgbGV0IHdfcG9zID0gW107XG4gIGxldCB3aG9fbGluZSA9IHt9O1xuXG4gIGxldCBpc193aG9wYXJ0ID0gdHJ1ZTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmIChsaW5lID09PSAnLS0tJykge1xuICAgICAgaXNfd2hvcGFydCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbCA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuXG4gICAgICAvLyB3aG8gcGFydFxuICAgICAgaWYgKGlzX3dob3BhcnQpIHtcbiAgICAgICAgcmVzdWx0X3doby5wdXNoKHtcbiAgICAgICAgICB1c2VyOiBsWzBdLFxuICAgICAgICAgIHR0eTogbFsxXSxcbiAgICAgICAgICBkYXRlOiBsWzJdLFxuICAgICAgICAgIHRpbWU6IGxbM10sXG4gICAgICAgICAgaXA6IChsICYmIGwubGVuZ3RoID4gNCkgPyBsWzRdLnJlcGxhY2UoL1xcKC9nLCAnJykucmVwbGFjZSgvXFwpL2csICcnKSA6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdyBwYXJ0XG4gICAgICAgIGlmICh3X2ZpcnN0KSB7ICAgIC8vIGhlYWRlclxuICAgICAgICAgIHdfaGVhZGVyID0gbDtcbiAgICAgICAgICB3X2hlYWRlci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB3X3Bvcy5wdXNoKGxpbmUuaW5kZXhPZihpdGVtKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd19maXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNwbGl0IGJ5IHdfcG9zXG4gICAgICAgICAgcmVzdWx0X3cudXNlciA9IGxpbmUuc3Vic3RyaW5nKHdfcG9zWzBdLCB3X3Bvc1sxXSAtIDEpLnRyaW0oKTtcbiAgICAgICAgICByZXN1bHRfdy50dHkgPSBsaW5lLnN1YnN0cmluZyh3X3Bvc1sxXSwgd19wb3NbMl0gLSAxKS50cmltKCk7XG4gICAgICAgICAgcmVzdWx0X3cuaXAgPSBsaW5lLnN1YnN0cmluZyh3X3Bvc1syXSwgd19wb3NbM10gLSAxKS5yZXBsYWNlKC9cXCgvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykudHJpbSgpO1xuICAgICAgICAgIHJlc3VsdF93LmNvbW1hbmQgPSBsaW5lLnN1YnN0cmluZyh3X3Bvc1s3XSwgMTAwMCkudHJpbSgpO1xuICAgICAgICAgIC8vIGZpbmQgY29ycmVzcG9uZGluZyAnd2hvJyBsaW5lXG4gICAgICAgICAgd2hvX2xpbmUgPSByZXN1bHRfd2hvLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gKG9iai51c2VyLnN1YnN0cmluZygwLCA4KS50cmltKCkgPT09IHJlc3VsdF93LnVzZXIgJiYgb2JqLnR0eSA9PT0gcmVzdWx0X3cudHR5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAod2hvX2xpbmUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIHVzZXI6IHdob19saW5lWzBdLnVzZXIsXG4gICAgICAgICAgICAgIHR0eTogd2hvX2xpbmVbMF0udHR5LFxuICAgICAgICAgICAgICBkYXRlOiB3aG9fbGluZVswXS5kYXRlLFxuICAgICAgICAgICAgICB0aW1lOiB3aG9fbGluZVswXS50aW1lLFxuICAgICAgICAgICAgICBpcDogd2hvX2xpbmVbMF0uaXAsXG4gICAgICAgICAgICAgIGNvbW1hbmQ6IHJlc3VsdF93LmNvbW1hbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAwICYmIHBoYXNlID09PSAyKSB7XG4gICAgcmV0dXJuIHJlc3VsdF93aG87XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVzZXJzRGFyd2luKGxpbmVzKSB7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgbGV0IHJlc3VsdF93aG8gPSBbXTtcbiAgbGV0IHJlc3VsdF93ID0ge307XG4gIGxldCB3aG9fbGluZSA9IHt9O1xuXG4gIGxldCBpc193aG9wYXJ0ID0gdHJ1ZTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmIChsaW5lID09PSAnLS0tJykge1xuICAgICAgaXNfd2hvcGFydCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbCA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuXG4gICAgICAvLyB3aG8gcGFydFxuICAgICAgaWYgKGlzX3dob3BhcnQpIHtcbiAgICAgICAgcmVzdWx0X3doby5wdXNoKHtcbiAgICAgICAgICB1c2VyOiBsWzBdLFxuICAgICAgICAgIHR0eTogbFsxXSxcbiAgICAgICAgICBkYXRlOiAoJycgKyBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpICsgJy0nICsgKCcwJyArICgnSkFORkVCTUFSQVBSTUFZSlVOSlVMQVVHU0VQT0NUTk9WREVDJy5pbmRleE9mKGxbMl0udG9VcHBlckNhc2UoKSkgLyAzICsgMSkpLnNsaWNlKC0yKSArICctJyArICgnMCcgKyBsWzNdKS5zbGljZSgtMiksXG4gICAgICAgICAgdGltZTogbFs0XSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3IHBhcnRcbiAgICAgICAgLy8gc3BsaXQgYnkgd19wb3NcbiAgICAgICAgcmVzdWx0X3cudXNlciA9IGxbMF07XG4gICAgICAgIHJlc3VsdF93LnR0eSA9IGxbMV07XG4gICAgICAgIHJlc3VsdF93LmlwID0gKGxbMl0gIT09ICctJykgPyBsWzJdIDogJyc7XG4gICAgICAgIHJlc3VsdF93LmNvbW1hbmQgPSBsLnNsaWNlKDUsIDEwMDApLmpvaW4oJyAnKTtcbiAgICAgICAgLy8gZmluZCBjb3JyZXNwb25kaW5nICd3aG8nIGxpbmVcbiAgICAgICAgd2hvX2xpbmUgPSByZXN1bHRfd2hvLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuIChvYmoudXNlciA9PT0gcmVzdWx0X3cudXNlciAmJiAob2JqLnR0eS5zdWJzdHJpbmcoMywgMTAwMCkgPT09IHJlc3VsdF93LnR0eSB8fCBvYmoudHR5ID09PSByZXN1bHRfdy50dHkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aG9fbGluZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB1c2VyOiB3aG9fbGluZVswXS51c2VyLFxuICAgICAgICAgICAgdHR5OiB3aG9fbGluZVswXS50dHksXG4gICAgICAgICAgICBkYXRlOiB3aG9fbGluZVswXS5kYXRlLFxuICAgICAgICAgICAgdGltZTogd2hvX2xpbmVbMF0udGltZSxcbiAgICAgICAgICAgIGlwOiByZXN1bHRfdy5pcCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHJlc3VsdF93LmNvbW1hbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVzZXJzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgIC8vIGxpbnV4XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGV4ZWMoJ3dobyAtLWlwczsgZWNobyBcIi0tLVwiOyB3IHwgdGFpbCAtbiArMicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgLy8gbGluZXMgLyBzcGxpdFxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VVc2Vyc0xpbnV4KGxpbmVzLCAxKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ3dobzsgZWNobyBcIi0tLVwiOyB3IHwgdGFpbCAtbiArMicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gbGluZXMgLyBzcGxpdFxuICAgICAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZVVzZXJzTGludXgobGluZXMsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ3dobzsgZWNobyBcIi0tLVwiOyB3IC1paCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgLy8gbGluZXMgLyBzcGxpdFxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VVc2Vyc0RhcndpbihsaW5lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgZXhlYygnd2hvOyBlY2hvIFwiLS0tXCI7IHcgLWgnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGxpbmVzIC8gc3BsaXRcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVXNlcnNEYXJ3aW4obGluZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3dobzsgZWNobyBcIi0tLVwiOyB3IC1paCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgLy8gbGluZXMgLyBzcGxpdFxuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VVc2Vyc0RhcndpbihsaW5lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBjbWQgPSAnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0xvZ29uU2Vzc2lvbiB8IHNlbGVjdCBMb2dvbklkLEB7bj1cIlN0YXJ0VGltZVwiO2U9eyRfLlN0YXJ0VGltZS5Ub1N0cmluZyhcInl5eXktTU0tZGQgSEg6bW06c3NcIil9fSB8IGZsJyArICc7IGVjaG8gXFwnIy0jLSMtI1xcJzsnO1xuICAgICAgICAgIGNtZCArPSAnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0xvZ2dlZE9uVXNlciB8IHNlbGVjdCBhbnRlY2VkZW50LGRlcGVuZGVudCB8IGZsICcgKyAnOyBlY2hvIFxcJyMtIy0jLSNcXCc7JztcbiAgICAgICAgICBjbWQgKz0gJyRwcm9jZXNzID0gKEdldC1DaW1JbnN0YW5jZSBXaW4zMl9Qcm9jZXNzIC1GaWx0ZXIgXCJuYW1lID0gXFwnZXhwbG9yZXIuZXhlXFwnXCIpOyBJbnZva2UtQ2ltTWV0aG9kIC1JbnB1dE9iamVjdCAkcHJvY2Vzc1swXSAtTWV0aG9kTmFtZSBHZXRPd25lciB8IHNlbGVjdCB1c2VyLCBkb21haW4gfCBmbDsgZ2V0LXByb2Nlc3MgLW5hbWUgZXhwbG9yZXIgfCBzZWxlY3Qtb2JqZWN0IHNlc3Npb25pZCB8IGZsOyBlY2hvIFxcJyMtIy0jLSNcXCc7JztcbiAgICAgICAgICBjbWQgKz0gJ3F1ZXJ5IHVzZXInO1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbChjbWQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcjLSMtIy0jJyk7XG4gICAgICAgICAgICAgIGxldCBzZXNzaW9ucyA9IHBhcnNlV2luU2Vzc2lvbnMoKGRhdGFbMF0gfHwgJycpLnNwbGl0KC9cXG5cXHMqXFxuLykpO1xuICAgICAgICAgICAgICBsZXQgbG9nZ2Vkb25zID0gcGFyc2VXaW5Mb2dnZWRPbigoZGF0YVsxXSB8fCAnJykuc3BsaXQoL1xcblxccypcXG4vKSk7XG4gICAgICAgICAgICAgIGxldCBxdWVyeVVzZXIgPSBwYXJzZVdpblVzZXJzUXVlcnkoKGRhdGFbM10gfHwgJycpLnNwbGl0KCdcXHJcXG4nKSk7XG4gICAgICAgICAgICAgIGxldCB1c2VycyA9IHBhcnNlV2luVXNlcnMoKGRhdGFbMl0gfHwgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyksIHF1ZXJ5VXNlcik7XG4gICAgICAgICAgICAgIGZvciAobGV0IGlkIGluIGxvZ2dlZG9ucykge1xuICAgICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZ2dlZG9ucywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZWRvbnNbaWRdLmRhdGVUaW1lID0ge30uaGFzT3duUHJvcGVydHkuY2FsbChzZXNzaW9ucywgaWQpID8gc2Vzc2lvbnNbaWRdIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzZXJzLmZvckVhY2godXNlciA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGVUaW1lID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gbG9nZ2Vkb25zKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChsb2dnZWRvbnMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2Vkb25zW2lkXS51c2VyID09PSB1c2VyLnVzZXIgJiYgKCFkYXRlVGltZSB8fCBkYXRlVGltZSA8IGxvZ2dlZG9uc1tpZF0uZGF0ZVRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0ZVRpbWUgPSBsb2dnZWRvbnNbaWRdLmRhdGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdXNlcjogdXNlci51c2VyLFxuICAgICAgICAgICAgICAgICAgdHR5OiB1c2VyLnR0eSxcbiAgICAgICAgICAgICAgICAgIGRhdGU6IGAke2RhdGVUaW1lLnN1YnN0cmluZygwLCAxMCl9YCxcbiAgICAgICAgICAgICAgICAgIHRpbWU6IGAke2RhdGVUaW1lLnN1YnN0cmluZygxMSwgMTkpfWAsXG4gICAgICAgICAgICAgICAgICBpcDogJycsXG4gICAgICAgICAgICAgICAgICBjb21tYW5kOiAnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpblNlc3Npb25zKHNlc3Npb25QYXJ0cykge1xuICBjb25zdCBzZXNzaW9ucyA9IHt9O1xuICBzZXNzaW9uUGFydHMuZm9yRWFjaChzZXNzaW9uID0+IHtcbiAgICBjb25zdCBsaW5lcyA9IHNlc3Npb24uc3BsaXQoJ1xcclxcbicpO1xuICAgIGNvbnN0IGlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvZ29uSWQnKTtcbiAgICBjb25zdCBzdGFydHRpbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3RhcnR0aW1lJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBzZXNzaW9uc1tpZF0gPSBzdGFydHRpbWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlc3Npb25zO1xufVxuXG5mdW5jdGlvbiBmdXp6eU1hdGNoKG5hbWUxLCBuYW1lMikge1xuICBuYW1lMSA9IG5hbWUxLnRvTG93ZXJDYXNlKCk7XG4gIG5hbWUyID0gbmFtZTIudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGVxID0gMDtcbiAgbGV0IGxlbiA9IG5hbWUxLmxlbmd0aDtcbiAgaWYgKG5hbWUyLmxlbmd0aCA+IGxlbikgeyBsZW4gPSBuYW1lMi5sZW5ndGg7IH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYzEgPSBuYW1lMVtpXSB8fCAnJztcbiAgICBjb25zdCBjMiA9IG5hbWUyW2ldIHx8ICcnO1xuICAgIGlmIChjMSA9PT0gYzIpIHsgZXErKzsgfVxuICB9XG4gIHJldHVybiAobGVuID4gMTAgPyBlcSAvIGxlbiA+IDAuOSA6IChsZW4gPiAwID8gZXEgLyBsZW4gPiAwLjggOiBmYWxzZSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpblVzZXJzKHVzZXJQYXJ0cywgdXNlclF1ZXJ5KSB7XG4gIGNvbnN0IHVzZXJzID0gW107XG4gIHVzZXJQYXJ0cy5mb3JFYWNoKHVzZXIgPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gdXNlci5zcGxpdCgnXFxyXFxuJyk7XG5cbiAgICBjb25zdCBkb21haW4gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZG9tYWluJywgJzonLCB0cnVlKTtcbiAgICBjb25zdCB1c2VybmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd1c2VyJywgJzonLCB0cnVlKTtcbiAgICBjb25zdCBzZXNzaW9uaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2Vzc2lvbmlkJywgJzonLCB0cnVlKTtcblxuICAgIGlmICh1c2VybmFtZSkge1xuICAgICAgY29uc3QgcXVzZXIgPSB1c2VyUXVlcnkuZmlsdGVyKGl0ZW0gPT4gZnV6enlNYXRjaChpdGVtLnVzZXIsIHVzZXJuYW1lKSk7XG4gICAgICB1c2Vycy5wdXNoKHtcbiAgICAgICAgZG9tYWluLFxuICAgICAgICB1c2VyOiB1c2VybmFtZSxcbiAgICAgICAgdHR5OiBxdXNlciAmJiBxdXNlclswXSAmJiBxdXNlclswXS50dHkgPyBxdXNlclswXS50dHkgOiBzZXNzaW9uaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB1c2Vycztcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5Mb2dnZWRPbihsb2dnZWRvblBhcnRzKSB7XG4gIGNvbnN0IGxvZ2dlZG9ucyA9IHt9O1xuICBsb2dnZWRvblBhcnRzLmZvckVhY2gobG9nZ2Vkb24gPT4ge1xuICAgIGNvbnN0IGxpbmVzID0gbG9nZ2Vkb24uc3BsaXQoJ1xcclxcbicpO1xuXG4gICAgY29uc3QgYW50ZWNlbmRlbnQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYW50ZWNlZGVudCcsICc6JywgdHJ1ZSk7XG4gICAgbGV0IHBhcnRzID0gYW50ZWNlbmRlbnQuc3BsaXQoJz0nKTtcbiAgICBjb25zdCBuYW1lID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzFdLnNwbGl0KCcsJylbMF0ucmVwbGFjZSgvXCIvZywgJycpLnRyaW0oKSA6ICcnO1xuICAgIGNvbnN0IGRvbWFpbiA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXS5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgvXFwpL2csICcnKS50cmltKCkgOiAnJztcbiAgICBjb25zdCBkZXBlbmRlbnQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZGVwZW5kZW50JywgJzonLCB0cnVlKTtcbiAgICBwYXJ0cyA9IGRlcGVuZGVudC5zcGxpdCgnPScpO1xuICAgIGNvbnN0IGlkID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnJlcGxhY2UoL1wiL2csICcnKS5yZXBsYWNlKC9cXCkvZywgJycpLnRyaW0oKSA6ICcnO1xuICAgIGlmIChpZCkge1xuICAgICAgbG9nZ2Vkb25zW2lkXSA9IHtcbiAgICAgICAgZG9tYWluLFxuICAgICAgICB1c2VyOiBuYW1lXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsb2dnZWRvbnM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luVXNlcnNRdWVyeShsaW5lcykge1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcihpdGVtID0+IGl0ZW0pO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdO1xuICBjb25zdCBoZWFkZXJEZWxpbWl0ZXIgPSBbXTtcbiAgaWYgKGhlYWRlcikge1xuICAgIGNvbnN0IHN0YXJ0ID0gKGhlYWRlclswXSA9PT0gJyAnKSA/IDEgOiAwO1xuICAgIGhlYWRlckRlbGltaXRlci5wdXNoKHN0YXJ0IC0gMSk7XG4gICAgbGV0IG5leHRTcGFjZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0ICsgMTsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhlYWRlcltpXSA9PT0gJyAnICYmICgoaGVhZGVyW2kgLSAxXSA9PT0gJyAnKSB8fCAoaGVhZGVyW2kgLSAxXSA9PT0gJy4nKSkpIHtcbiAgICAgICAgbmV4dFNwYWNlID0gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXh0U3BhY2UpIHtcbiAgICAgICAgICBoZWFkZXJEZWxpbWl0ZXIucHVzaChuZXh0U3BhY2UpO1xuICAgICAgICAgIG5leHRTcGFjZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpbmVzW2ldLnRyaW0oKSkge1xuICAgICAgICBjb25zdCB1c2VyID0gbGluZXNbaV0uc3Vic3RyaW5nKGhlYWRlckRlbGltaXRlclswXSArIDEsIGhlYWRlckRlbGltaXRlclsxXSkudHJpbSgpIHx8ICcnO1xuICAgICAgICBjb25zdCB0dHkgPSBsaW5lc1tpXS5zdWJzdHJpbmcoaGVhZGVyRGVsaW1pdGVyWzFdICsgMSwgaGVhZGVyRGVsaW1pdGVyWzJdIC0gMikudHJpbSgpIHx8ICcnO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgICB0dHk6IHR0eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMudXNlcnMgPSB1c2VycztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gdXRpbHMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAwLiBoZWxwZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBzcGF3biA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5zcGF3bjtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcblxubGV0IF9jb3JlcyA9IDA7XG5sZXQgd21pY1BhdGggPSAnJztcbmxldCBjb2RlcGFnZSA9ICcnO1xubGV0IF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gbnVsbDtcblxuY29uc3QgV0lORElSID0gcHJvY2Vzcy5lbnYuV0lORElSIHx8ICdDOlxcXFxXaW5kb3dzJztcblxuLy8gcG93ZXJTaGVsbFxubGV0IF9wc0NoaWxkO1xubGV0IF9wc1Jlc3VsdCA9ICcnO1xubGV0IF9wc0NtZHMgPSBbXTtcbmxldCBfcHNQZXJzaXN0ZW50ID0gZmFsc2U7XG5jb25zdCBfcHNUb1VURjggPSAnJE91dHB1dEVuY29kaW5nID0gW1N5c3RlbS5Db25zb2xlXTo6T3V0cHV0RW5jb2RpbmcgPSBbU3lzdGVtLkNvbnNvbGVdOjpJbnB1dEVuY29kaW5nID0gW1N5c3RlbS5UZXh0LkVuY29kaW5nXTo6VVRGOCA7ICc7XG5jb25zdCBfcHNDbWRTdGFydCA9ICctLSMjI1NUQVJUIyMjLS0nO1xuY29uc3QgX3BzRXJyb3IgPSAnLS1FUlJPUi0tJztcbmNvbnN0IF9wc0NtZFNlcGVyYXRvciA9ICctLSMjI0VORENNRCMjIy0tJztcbmNvbnN0IF9wc0lkU2VwZXJhdG9yID0gJy0tIyNJRCMjLS0nO1xuXG5jb25zdCBleGVjT3B0c1dpbiA9IHtcbiAgd2luZG93c0hpZGU6IHRydWUsXG4gIG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwLFxuICBlbmNvZGluZzogJ1VURi04JyxcbiAgZW52OiB1dGlsLl9leHRlbmQoe30sIHByb2Nlc3MuZW52LCB7IExBTkc6ICdlbl9VUy5VVEYtOCcgfSlcbn07XG5cbmZ1bmN0aW9uIHRvSW50KHZhbHVlKSB7XG4gIGxldCByZXN1bHQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5jb25zdCBzdHJpbmdSZXBsYWNlID0gbmV3IFN0cmluZygpLnJlcGxhY2U7XG5jb25zdCBzdHJpbmdUb0xvd2VyID0gbmV3IFN0cmluZygpLnRvTG93ZXJDYXNlO1xuY29uc3Qgc3RyaW5nVG9TdHJpbmcgPSBuZXcgU3RyaW5nKCkudG9TdHJpbmc7XG5jb25zdCBzdHJpbmdTdWJzdHIgPSBuZXcgU3RyaW5nKCkuc3Vic3RyO1xuY29uc3Qgc3RyaW5nVHJpbSA9IG5ldyBTdHJpbmcoKS50cmltO1xuY29uc3Qgc3RyaW5nU3RhcnRXaXRoID0gbmV3IFN0cmluZygpLnN0YXJ0c1dpdGg7XG5jb25zdCBtYXRoTWluID0gTWF0aC5taW47XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIGxldCBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShvYmopIHtcbiAgbGV0IHVuaXF1ZXMgPSBbXTtcbiAgbGV0IHN0cmluZ2lmeSA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqW2ldKTtcbiAgICBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5c1tqXSk7XG4gICAgICBzdHIgKz0gSlNPTi5zdHJpbmdpZnkob2JqW2ldW2tleXNbal1dKTtcbiAgICB9XG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0cmluZ2lmeSwgc3RyKSkge1xuICAgICAgdW5pcXVlcy5wdXNoKG9ialtpXSk7XG4gICAgICBzdHJpbmdpZnlbc3RyXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmlxdWVzO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlLZXkoYXJyYXksIGtleXMpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBsZXQgeCA9ICcnO1xuICAgIGxldCB5ID0gJyc7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHggPSB4ICsgYVtrZXldOyB5ID0geSArIGJba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvcmVzKCkge1xuICBpZiAoX2NvcmVzID09PSAwKSB7XG4gICAgX2NvcmVzID0gb3MuY3B1cygpLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gX2NvcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZShsaW5lcywgcHJvcGVydHksIHNlcGFyYXRvciwgdHJpbW1lZCwgbGluZU1hdGNoKSB7XG4gIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnOic7XG4gIHByb3BlcnR5ID0gcHJvcGVydHkudG9Mb3dlckNhc2UoKTtcbiAgdHJpbW1lZCA9IHRyaW1tZWQgfHwgZmFsc2U7XG4gIGxpbmVNYXRjaCA9IGxpbmVNYXRjaCB8fCBmYWxzZTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgbGV0IGxpbmVMb3dlciA9IGxpbmUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHQvZywgJycpO1xuICAgIGlmICh0cmltbWVkKSB7XG4gICAgICBsaW5lTG93ZXIgPSBsaW5lTG93ZXIudHJpbSgpO1xuICAgIH1cbiAgICBpZiAobGluZUxvd2VyLnN0YXJ0c1dpdGgocHJvcGVydHkpICYmIChsaW5lTWF0Y2ggPyAobGluZUxvd2VyLm1hdGNoKHByb3BlcnR5ICsgc2VwYXJhdG9yKSkgfHwgKGxpbmVMb3dlci5tYXRjaChwcm9wZXJ0eSArICcgJyArIHNlcGFyYXRvcikpIDogdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdHJpbW1lZCA/IGxpbmUudHJpbSgpLnNwbGl0KHNlcGFyYXRvcikgOiBsaW5lLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0ID0gcGFydHMuam9pbihzZXBhcmF0b3IpLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFc2NhcGVTZXF1ZW5jZShzdHIsIGJhc2UpIHtcbiAgYmFzZSA9IGJhc2UgfHwgMTY7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXHgoWzAtOUEtRmEtZl17Mn0pL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChhcmd1bWVudHNbMV0sIGJhc2UpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRldGVjdFNwbGl0KHN0cikge1xuICBsZXQgc2VwZXJhdG9yID0gJyc7XG4gIGxldCBwYXJ0ID0gMDtcbiAgc3RyLnNwbGl0KCcnKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGlmIChlbGVtZW50ID49ICcwJyAmJiBlbGVtZW50IDw9ICc5Jykge1xuICAgICAgaWYgKHBhcnQgPT09IDEpIHsgcGFydCsrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJ0ID09PSAwKSB7IHBhcnQrKzsgfVxuICAgICAgaWYgKHBhcnQgPT09IDEpIHtcbiAgICAgICAgc2VwZXJhdG9yICs9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlcGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHQsIHBtRGVzaWduYXRvcikge1xuICBwbURlc2lnbmF0b3IgPSBwbURlc2lnbmF0b3IgfHwgJyc7XG4gIHQgPSB0LnRvVXBwZXJDYXNlKCk7XG4gIGxldCBob3VyID0gMDtcbiAgbGV0IG1pbiA9IDA7XG4gIGxldCBzcGxpdHRlciA9IGRldGVjdFNwbGl0KHQpO1xuICBsZXQgcGFydHMgPSB0LnNwbGl0KHNwbGl0dGVyKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHBhcnRzWzJdKSB7XG4gICAgICBwYXJ0c1sxXSArPSBwYXJ0c1syXTtcbiAgICB9XG4gICAgbGV0IGlzUE0gPSAocGFydHNbMV0gJiYgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncG0nKSA+IC0xKSB8fCAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwLm0uJykgPiAtMSkgfHwgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncC4gbS4nKSA+IC0xKSB8fCAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCduJykgPiAtMSkgfHwgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2gnKSA+IC0xKSB8fCAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCfDtnMnKSA+IC0xKSB8fCAocG1EZXNpZ25hdG9yICYmIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwbURlc2lnbmF0b3IpID4gLTEpKTtcbiAgICBob3VyID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICBtaW4gPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgIGhvdXIgPSBpc1BNICYmIGhvdXIgPCAxMiA/IGhvdXIgKyAxMiA6IGhvdXI7XG4gICAgcmV0dXJuICgnMCcgKyBob3VyKS5zdWJzdHIoLTIpICsgJzonICsgKCcwJyArIG1pbikuc3Vic3RyKC0yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZURhdGVUaW1lKGR0LCBjdWx0dXJlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBkYXRlOiAnJyxcbiAgICB0aW1lOiAnJ1xuICB9O1xuICBjdWx0dXJlID0gY3VsdHVyZSB8fCB7fTtcbiAgbGV0IGRhdGVGb3JtYXQgPSAoY3VsdHVyZS5kYXRlRm9ybWF0IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgcG1EZXNpZ25hdG9yID0gKGN1bHR1cmUucG1EZXNpZ25hdG9yIHx8ICcnKTtcblxuICBjb25zdCBwYXJ0cyA9IGR0LnNwbGl0KCcgJyk7XG4gIGlmIChwYXJ0c1swXSkge1xuICAgIGlmIChwYXJ0c1swXS5pbmRleE9mKCcvJykgPj0gMCkge1xuICAgICAgLy8gRGF0ZWZvcm1hdDogbW0vZGQveXl5eSBvciBkZC9tbS95eXl5IG9yIGRkL21tL3l5IG9yIHl5eXkvbW0vZGRcbiAgICAgIGNvbnN0IGR0cGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuICAgICAgaWYgKGR0cGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGlmIChkdHBhcnRzWzBdLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IHl5eXkvbW0vZGRcbiAgICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMF0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzJdKS5zdWJzdHIoLTIpO1xuICAgICAgICB9IGVsc2UgaWYgKGR0cGFydHNbMl0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgaWYgKChkYXRlRm9ybWF0LmluZGV4T2YoJy9kLycpID4gLTEgfHwgZGF0ZUZvcm1hdC5pbmRleE9mKCcvZGQvJykgPiAtMSkpIHtcbiAgICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IG1tL2RkL3l5XG4gICAgICAgICAgICByZXN1bHQuZGF0ZSA9ICcyMCcgKyBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGF0ZWZvcm1hdDogZGQvbW0veXlcbiAgICAgICAgICAgIHJlc3VsdC5kYXRlID0gJzIwJyArIGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBtbS9kZC95eXl5IG9yIGRkL21tL3l5eXlcbiAgICAgICAgICBjb25zdCBpc0VOID0gKChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3BtJykgPiAtMSkgfHwgKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncC5tLicpID4gLTEpIHx8IChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3AuIG0uJykgPiAtMSkgfHwgKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYW0nKSA+IC0xKSB8fCAoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhLm0uJykgPiAtMSkgfHwgKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYS4gbS4nKSA+IC0xKSk7XG4gICAgICAgICAgaWYgKChpc0VOIHx8IGRhdGVGb3JtYXQuaW5kZXhPZignL2QvJykgPiAtMSB8fCBkYXRlRm9ybWF0LmluZGV4T2YoJy9kZC8nKSA+IC0xKSAmJiBkYXRlRm9ybWF0LmluZGV4T2YoJ2RkLycpICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBtbS9kZC95eXl5XG4gICAgICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBkZC9tbS95eXl5XG4gICAgICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFydHNbMF0uaW5kZXhPZignLicpID49IDApIHtcbiAgICAgIGNvbnN0IGR0cGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLicpO1xuICAgICAgaWYgKGR0cGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGlmIChkYXRlRm9ybWF0LmluZGV4T2YoJy5kLicpID4gLTEgfHwgZGF0ZUZvcm1hdC5pbmRleE9mKCcuZGQuJykgPiAtMSkge1xuICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IG1tLmRkLnl5eXlcbiAgICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IGRkLm1tLnl5eXlcbiAgICAgICAgICByZXN1bHQuZGF0ZSA9IGR0cGFydHNbMl0gKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKSArICctJyArICgnMCcgKyBkdHBhcnRzWzBdKS5zdWJzdHIoLTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1swXS5pbmRleE9mKCctJykgPj0gMCkge1xuICAgICAgLy8gRGF0ZWZvcm1hdDogeXl5eS1tbS1kZFxuICAgICAgY29uc3QgZHRwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCctJyk7XG4gICAgICBpZiAoZHRwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzBdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1syXSkuc3Vic3RyKC0yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBhcnRzWzFdKSB7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICBsZXQgdGltZSA9IHBhcnRzLmpvaW4oJyAnKTtcbiAgICByZXN1bHQudGltZSA9IHBhcnNlVGltZSh0aW1lLCBwbURlc2lnbmF0b3IpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZChoZWFkLCByaWdodHMpIHtcbiAgbGV0IHNwYWNlID0gKHJpZ2h0cyA+IDApO1xuICBsZXQgY291bnQgPSAxO1xuICBsZXQgZnJvbSA9IDA7XG4gIGxldCB0byA9IDA7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvdW50IDw9IHJpZ2h0cykge1xuICAgICAgaWYgKC9cXHMvLnRlc3QoaGVhZFtpXSkgJiYgIXNwYWNlKSB7XG4gICAgICAgIHRvID0gaSAtIDE7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgIHRvOiB0byArIDEsXG4gICAgICAgICAgY2FwOiBoZWFkLnN1YnN0cmluZyhmcm9tLCB0byArIDEpXG4gICAgICAgIH0pO1xuICAgICAgICBmcm9tID0gdG8gKyAyO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgICAgc3BhY2UgPSBoZWFkW2ldID09PSAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghL1xccy8udGVzdChoZWFkW2ldKSAmJiBzcGFjZSkge1xuICAgICAgICB0byA9IGkgLSAxO1xuICAgICAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIGNhcDogaGVhZC5zdWJzdHJpbmcoZnJvbSwgdG8pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbSA9IHRvICsgMTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIHNwYWNlID0gaGVhZFtpXSA9PT0gJyAnO1xuICAgIH1cbiAgfVxuICB0byA9IDUwMDA7XG4gIHJlc3VsdC5wdXNoKHtcbiAgICBmcm9tOiBmcm9tLFxuICAgIHRvOiB0byxcbiAgICBjYXA6IGhlYWQuc3Vic3RyaW5nKGZyb20sIHRvKVxuICB9KTtcbiAgbGV0IGxlbiA9IHJlc3VsdC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocmVzdWx0W2ldLmNhcC5yZXBsYWNlKC9cXHMvZywgJycpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgIHJlc3VsdFtpXS50byA9IHJlc3VsdFtpICsgMV0udG87XG4gICAgICAgIHJlc3VsdFtpXS5jYXAgPSByZXN1bHRbaV0uY2FwICsgcmVzdWx0W2kgKyAxXS5jYXA7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICBsZW4gPSBsZW4gLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmaW5kT2JqZWN0QnlLZXkoYXJyYXksIGtleSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXVtrZXldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0V21pYygpIHtcbiAgaWYgKG9zLnR5cGUoKSA9PT0gJ1dpbmRvd3NfTlQnICYmICF3bWljUGF0aCkge1xuICAgIHdtaWNQYXRoID0gV0lORElSICsgJ1xcXFxzeXN0ZW0zMlxcXFx3YmVtXFxcXHdtaWMuZXhlJztcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMod21pY1BhdGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB3bWljUGF0aEFycmF5ID0gZXhlY1N5bmMoJ1dIRVJFIFdNSUMnLCBleGVjT3B0c1dpbikudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGlmICh3bWljUGF0aEFycmF5ICYmIHdtaWNQYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgd21pY1BhdGggPSB3bWljUGF0aEFycmF5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdtaWNQYXRoID0gJ3dtaWMnO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdtaWNQYXRoID0gJ3dtaWMnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gd21pY1BhdGg7XG59XG5cbmZ1bmN0aW9uIHdtaWMoY29tbWFuZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBvd2VyU2hlbGwoZ2V0V21pYygpICsgJyAnICsgY29tbWFuZCkudGhlbihzdGRvdXQgPT4ge1xuICAgICAgICAgIHJlc29sdmUoc3Rkb3V0LCAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXNvbHZlKCcnLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFZib3htYW5hZ2UoKSB7XG4gIHJldHVybiBfd2luZG93cyA/IGBcIiR7cHJvY2Vzcy5lbnYuVkJPWF9JTlNUQUxMX1BBVEggfHwgcHJvY2Vzcy5lbnYuVkJPWF9NU0lfSU5TVEFMTF9QQVRIfVxcXFxWQm94TWFuYWdlLmV4ZVwiYCA6ICd2Ym94bWFuYWdlJztcbn1cblxuZnVuY3Rpb24gcG93ZXJTaGVsbFByb2NlZWRSZXN1bHRzKGRhdGEpIHtcbiAgbGV0IGlkID0gJyc7XG4gIGxldCBwYXJ0cztcbiAgbGV0IHJlcyA9ICcnO1xuICAvLyBzdGFydElEXG4gIGlmIChkYXRhLmluZGV4T2YoX3BzQ21kU3RhcnQpID49IDApIHtcbiAgICBwYXJ0cyA9IGRhdGEuc3BsaXQoX3BzQ21kU3RhcnQpO1xuICAgIGNvbnN0IHBhcnRzMiA9IHBhcnRzWzFdLnNwbGl0KF9wc0lkU2VwZXJhdG9yKTtcbiAgICBpZCA9IHBhcnRzMlswXTtcbiAgICBpZiAocGFydHMyLmxlbmd0aCA+IDEpIHtcbiAgICAgIGRhdGEgPSBwYXJ0czIuc2xpY2UoMSkuam9pbihfcHNJZFNlcGVyYXRvcik7XG4gICAgfVxuICB9XG4gIC8vIHJlc3VsdDtcbiAgaWYgKGRhdGEuaW5kZXhPZihfcHNDbWRTZXBlcmF0b3IpID49IDApIHtcbiAgICBwYXJ0cyA9IGRhdGEuc3BsaXQoX3BzQ21kU2VwZXJhdG9yKTtcbiAgICByZXMgPSBwYXJ0c1swXTtcbiAgfVxuICBsZXQgcmVtb3ZlID0gLTE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX3BzQ21kcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChfcHNDbWRzW2ldLmlkID09PSBpZCkge1xuICAgICAgcmVtb3ZlID0gaTtcbiAgICAgIF9wc0NtZHNbaV0uY2FsbGJhY2socmVzKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZSA+PSAwKSB7XG4gICAgX3BzQ21kcy5zcGxpY2UocmVtb3ZlLCAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3dlclNoZWxsU3RhcnQoKSB7XG4gIGlmICghX3BzQ2hpbGQpIHtcbiAgICBfcHNDaGlsZCA9IHNwYXduKCdwb3dlcnNoZWxsLmV4ZScsIFsnLU5vTG9nbycsICctSW5wdXRGb3JtYXQnLCAnVGV4dCcsICctTm9FeGl0JywgJy1Db21tYW5kJywgJy0nXSwge1xuICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAsXG4gICAgICBlbmNvZGluZzogJ1VURi04JyxcbiAgICAgIGVudjogdXRpbC5fZXh0ZW5kKHt9LCBwcm9jZXNzLmVudiwgeyBMQU5HOiAnZW5fVVMuVVRGLTgnIH0pXG4gICAgfSk7XG4gICAgaWYgKF9wc0NoaWxkICYmIF9wc0NoaWxkLnBpZCkge1xuICAgICAgX3BzUGVyc2lzdGVudCA9IHRydWU7XG4gICAgICBfcHNDaGlsZC5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfcHNSZXN1bHQgPSBfcHNSZXN1bHQgKyBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgIGlmIChkYXRhLmluZGV4T2YoX3BzQ21kU2VwZXJhdG9yKSA+PSAwKSB7XG4gICAgICAgICAgcG93ZXJTaGVsbFByb2NlZWRSZXN1bHRzKF9wc1Jlc3VsdCk7XG4gICAgICAgICAgX3BzUmVzdWx0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX3BzQ2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3dlclNoZWxsUHJvY2VlZFJlc3VsdHMoX3BzUmVzdWx0ICsgX3BzRXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBfcHNDaGlsZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBvd2VyU2hlbGxQcm9jZWVkUmVzdWx0cyhfcHNSZXN1bHQgKyBfcHNFcnJvcik7XG4gICAgICB9KTtcbiAgICAgIF9wc0NoaWxkLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3BzQ2hpbGQua2lsbCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvd2VyU2hlbGxSZWxlYXNlKCkge1xuICB0cnkge1xuICAgIGlmIChfcHNDaGlsZCkge1xuICAgICAgX3BzQ2hpbGQuc3RkaW4ud3JpdGUoJ2V4aXQnICsgb3MuRU9MKTtcbiAgICAgIF9wc0NoaWxkLnN0ZGluLmVuZCgpO1xuICAgICAgX3BzUGVyc2lzdGVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChfcHNDaGlsZCkgeyBfcHNDaGlsZC5raWxsKCk7IH1cbiAgfVxuICBfcHNDaGlsZCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBvd2VyU2hlbGwoY21kKSB7XG5cbiAgaWYgKF9wc1BlcnNpc3RlbnQpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZGF0YSkge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgX3BzQ21kcy5wdXNoKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjbWQsXG4gICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9wc0NoaWxkICYmIF9wc0NoaWxkLnBpZCkge1xuICAgICAgICAgICAgX3BzQ2hpbGQuc3RkaW4ud3JpdGUoX3BzVG9VVEY4ICsgJ2VjaG8gJyArIF9wc0NtZFN0YXJ0ICsgaWQgKyBfcHNJZFNlcGVyYXRvciArICc7ICcgKyBvcy5FT0wgKyBjbWQgKyBvcy5FT0wgKyAnZWNobyAnICsgX3BzQ21kU2VwZXJhdG9yICsgb3MuRU9MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXNvbHZlKCcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oJ3Bvd2Vyc2hlbGwuZXhlJywgWyctTm9Mb2dvJywgJy1JbnB1dEZvcm1hdCcsICdUZXh0JywgJy1Ob0V4aXQnLCAnLUV4ZWN1dGlvblBvbGljeScsICdVbnJlc3RyaWN0ZWQnLCAnLUNvbW1hbmQnLCAnLSddLCB7XG4gICAgICAgICAgICBzdGRpbzogJ3BpcGUnLFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgICAgICBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCxcbiAgICAgICAgICAgIGVuY29kaW5nOiAnVVRGLTgnLFxuICAgICAgICAgICAgZW52OiB1dGlsLl9leHRlbmQoe30sIHByb2Nlc3MuZW52LCB7IExBTkc6ICdlbl9VUy5VVEYtOCcgfSlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjaGlsZCAmJiAhY2hpbGQucGlkKSB7XG4gICAgICAgICAgICBjaGlsZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQucGlkKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBkYXRhLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuXG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjaGlsZC5raWxsKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY2hpbGQuc3RkaW4ud3JpdGUoX3BzVG9VVEY4ICsgY21kICsgb3MuRU9MKTtcbiAgICAgICAgICAgICAgY2hpbGQuc3RkaW4ud3JpdGUoJ2V4aXQnICsgb3MuRU9MKTtcbiAgICAgICAgICAgICAgY2hpbGQuc3RkaW4uZW5kKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleGVjU2FmZShjbWQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oY21kLCBhcmdzLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoY2hpbGQgJiYgIWNoaWxkLnBpZCkge1xuICAgICAgICAgIGNoaWxkLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQucGlkKSB7XG4gICAgICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2hpbGQub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNoaWxkLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29kZXBhZ2UoKSB7XG4gIGlmIChfd2luZG93cykge1xuICAgIGlmICghY29kZXBhZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdjaGNwJywgZXhlY09wdHNXaW4pO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zcGxpdCgnOicpO1xuICAgICAgICBjb2RlcGFnZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS5yZXBsYWNlKCcuJywgJycpLnRyaW0oKSA6ICcnO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvZGVwYWdlID0gJzQzNyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlcGFnZTtcbiAgfVxuICBpZiAoX2xpbnV4IHx8IF9kYXJ3aW4gfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgIGlmICghY29kZXBhZ2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdlY2hvICRMQU5HJyk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvZGVwYWdlID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICBpZiAoIWNvZGVwYWdlKSB7XG4gICAgICAgICAgY29kZXBhZ2UgPSAnVVRGLTgnO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29kZXBhZ2UgPSAnVVRGLTgnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZXBhZ2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc21hcnRNb25Ub29sc0luc3RhbGxlZCgpIHtcbiAgaWYgKF9zbWFydE1vblRvb2xzSW5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkO1xuICB9XG4gIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gZmFsc2U7XG4gIGlmIChfd2luZG93cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXRoQXJyYXkgPSBleGVjU3luYygnV0hFUkUgc21hcnRjdGwgMj5udWwnLCBleGVjT3B0c1dpbikudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICBpZiAocGF0aEFycmF5ICYmIHBhdGhBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBwYXRoQXJyYXlbMF0uaW5kZXhPZignOlxcXFwnKSA+PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoX2xpbnV4IHx8IF9kYXJ3aW4gfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgIGNvbnN0IHBhdGhBcnJheSA9IGV4ZWNTeW5jKCd3aGljaCBzbWFydGN0bCAyPi9kZXYvbnVsbCcsIGV4ZWNPcHRzV2luKS50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IHBhdGhBcnJheS5sZW5ndGggPiAwO1xuICB9XG4gIHJldHVybiBfc21hcnRNb25Ub29sc0luc3RhbGxlZDtcbn1cblxuZnVuY3Rpb24gaXNSYXNwYmVycnkoKSB7XG4gIGNvbnN0IFBJX01PREVMX05PID0gW1xuICAgICdCQ00yNzA4JyxcbiAgICAnQkNNMjcwOScsXG4gICAgJ0JDTTI3MTAnLFxuICAgICdCQ00yNzExJyxcbiAgICAnQkNNMjgzNScsXG4gICAgJ0JDTTI4MzYnLFxuICAgICdCQ00yODM3JyxcbiAgICAnQkNNMjgzN0IwJ1xuICBdO1xuICBsZXQgY3B1aW5mbyA9IFtdO1xuICB0cnkge1xuICAgIGNwdWluZm8gPSBmcy5yZWFkRmlsZVN5bmMoJy9wcm9jL2NwdWluZm8nLCB7IGVuY29kaW5nOiAndXRmOCcgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaGFyZHdhcmUgPSBnZXRWYWx1ZShjcHVpbmZvLCAnaGFyZHdhcmUnKTtcbiAgcmV0dXJuIChoYXJkd2FyZSAmJiBQSV9NT0RFTF9OTy5pbmRleE9mKGhhcmR3YXJlKSA+IC0xKTtcbn1cblxuZnVuY3Rpb24gaXNSYXNwYmlhbigpIHtcbiAgbGV0IG9zcmVsZWFzZSA9IFtdO1xuICB0cnkge1xuICAgIG9zcmVsZWFzZSA9IGZzLnJlYWRGaWxlU3luYygnL2V0Yy9vcy1yZWxlYXNlJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlkID0gZ2V0VmFsdWUob3NyZWxlYXNlLCAnaWQnLCAnPScpO1xuICByZXR1cm4gKGlkICYmIGlkLmluZGV4T2YoJ3Jhc3BiaWFuJykgPiAtMSk7XG59XG5cbmZ1bmN0aW9uIGV4ZWNXaW4oY21kLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSBleGVjT3B0c1dpbjtcbiAgfVxuICBsZXQgbmV3Q21kID0gJ2NoY3AgNjUwMDEgPiBudWwgJiYgY21kIC9DICcgKyBjbWQgKyAnICYmIGNoY3AgJyArIGNvZGVwYWdlICsgJyA+IG51bCc7XG4gIGV4ZWMobmV3Q21kLCBvcHRzLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgIGNhbGxiYWNrKGVycm9yLCBzdGRvdXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGFyd2luWGNvZGVFeGlzdHMoKSB7XG4gIGNvbnN0IGNtZExpbmVUb29sc0V4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy9MaWJyYXJ5L0RldmVsb3Blci9Db21tYW5kTGluZVRvb2xzL3Vzci9iaW4vJyk7XG4gIGNvbnN0IHhjb2RlQXBwRXhpc3RzID0gZnMuZXhpc3RzU3luYygnL0FwcGxpY2F0aW9ucy9YY29kZS5hcHAvQ29udGVudHMvRGV2ZWxvcGVyL1Rvb2xzJyk7XG4gIGNvbnN0IHhjb2RlRXhpc3RzID0gZnMuZXhpc3RzU3luYygnL0xpYnJhcnkvRGV2ZWxvcGVyL1hjb2RlLycpO1xuICByZXR1cm4gKGNtZExpbmVUb29sc0V4aXN0cyB8fCB4Y29kZUV4aXN0cyB8fCB4Y29kZUFwcEV4aXN0cyk7XG59XG5cbmZ1bmN0aW9uIG5hbm9TZWNvbmRzKCkge1xuICBjb25zdCB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRpbWUpIHx8IHRpbWUubGVuZ3RoICE9PSAyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuICt0aW1lWzBdICogMWU5ICsgK3RpbWVbMV07XG59XG5cbmZ1bmN0aW9uIGNvdW50VW5pcXVlTGluZXMobGluZXMsIHN0YXJ0aW5nV2l0aCkge1xuICBzdGFydGluZ1dpdGggPSBzdGFydGluZ1dpdGggfHwgJyc7XG4gIGNvbnN0IHVuaXF1ZUxpbmVzID0gW107XG4gIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChzdGFydGluZ1dpdGgpKSB7XG4gICAgICBpZiAodW5pcXVlTGluZXMuaW5kZXhPZihsaW5lKSA9PT0gLTEpIHtcbiAgICAgICAgdW5pcXVlTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdW5pcXVlTGluZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBjb3VudExpbmVzKGxpbmVzLCBzdGFydGluZ1dpdGgpIHtcbiAgc3RhcnRpbmdXaXRoID0gc3RhcnRpbmdXaXRoIHx8ICcnO1xuICBjb25zdCB1bmlxdWVMaW5lcyA9IFtdO1xuICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoc3RhcnRpbmdXaXRoKSkge1xuICAgICAgdW5pcXVlTGluZXMucHVzaChsaW5lKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdW5pcXVlTGluZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVNoZWxsU3RyaW5nKHN0ciwgc3RyaWN0KSB7XG4gIGlmICh0eXBlb2Ygc3RyaWN0ID09PSAndW5kZWZpbmVkJykgeyBzdHJpY3QgPSBmYWxzZTsgfVxuICBjb25zdCBzID0gc3RyIHx8ICcnO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IG1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICBpZiAoIShzW2ldID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHNbaV0gPT09ICc+JyB8fFxuICAgICAgc1tpXSA9PT0gJzwnIHx8XG4gICAgICBzW2ldID09PSAnKicgfHxcbiAgICAgIHNbaV0gPT09ICc/JyB8fFxuICAgICAgc1tpXSA9PT0gJ1snIHx8XG4gICAgICBzW2ldID09PSAnXScgfHxcbiAgICAgIHNbaV0gPT09ICd8JyB8fFxuICAgICAgc1tpXSA9PT0gJ8uaJyB8fFxuICAgICAgc1tpXSA9PT0gJyQnIHx8XG4gICAgICBzW2ldID09PSAnOycgfHxcbiAgICAgIHNbaV0gPT09ICcmJyB8fFxuICAgICAgc1tpXSA9PT0gJygnIHx8XG4gICAgICBzW2ldID09PSAnKScgfHxcbiAgICAgIHNbaV0gPT09ICddJyB8fFxuICAgICAgc1tpXSA9PT0gJyMnIHx8XG4gICAgICBzW2ldID09PSAnXFxcXCcgfHxcbiAgICAgIHNbaV0gPT09ICdcXHQnIHx8XG4gICAgICBzW2ldID09PSAnXFxuJyB8fFxuICAgICAgc1tpXSA9PT0gJ1xcJycgfHxcbiAgICAgIHNbaV0gPT09ICdgJyB8fFxuICAgICAgc1tpXSA9PT0gJ1wiJyB8fFxuICAgICAgc1tpXS5sZW5ndGggPiAxIHx8XG4gICAgICAoc3RyaWN0ICYmIHNbaV0gPT09ICdAJykgfHxcbiAgICAgIChzdHJpY3QgJiYgc1tpXSA9PT0gJyAnKSB8fFxuICAgICAgKHN0cmljdCAmJiBzW2ldID09ICd7JykgfHxcbiAgICAgIChzdHJpY3QgJiYgc1tpXSA9PSAnKScpKSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZCgpIHtcbiAgY29uc3QgcyA9ICcxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWic7XG4gIGxldCBub3RQb2xsdXRlZCA9IHRydWU7XG4gIGxldCBzdCA9ICcnO1xuXG4gIHN0Ll9fcHJvdG9fXy5yZXBsYWNlID0gc3RyaW5nUmVwbGFjZTtcbiAgc3QuX19wcm90b19fLnRvTG93ZXJDYXNlID0gc3RyaW5nVG9Mb3dlcjtcbiAgc3QuX19wcm90b19fLnRvU3RyaW5nID0gc3RyaW5nVG9TdHJpbmc7XG4gIHN0Ll9fcHJvdG9fXy5zdWJzdHIgPSBzdHJpbmdTdWJzdHI7XG5cbiAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCB8fCAocy5sZW5ndGggIT09IDYyKTtcbiAgY29uc3QgbXMgPSBEYXRlLm5vdygpO1xuICBpZiAodHlwZW9mIG1zID09PSAnbnVtYmVyJyAmJiBtcyA+IDE2MDAwMDAwMDAwMDApIHtcbiAgICBjb25zdCBsID0gbXMgJSAxMDAgKyAxNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiA2MS45OTk5OTk5OSArIDE7XG4gICAgICBjb25zdCBycyA9IHBhcnNlSW50KE1hdGguZmxvb3IocikudG9TdHJpbmcoKSwgMTApO1xuICAgICAgY29uc3QgcnMyID0gcGFyc2VJbnQoci50b1N0cmluZygpLnNwbGl0KCcuJylbMF0sIDEwKTtcbiAgICAgIGNvbnN0IHEgPSBNYXRoLnJhbmRvbSgpICogNjEuOTk5OTk5OTkgKyAxO1xuICAgICAgY29uc3QgcXMgPSBwYXJzZUludChNYXRoLmZsb29yKHEpLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgIGNvbnN0IHFzMiA9IHBhcnNlSW50KHEudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdLCAxMCk7XG4gICAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIChyICE9PSBxKTtcbiAgICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgcnMgPT09IHJzMiAmJiBxcyA9PT0gcXMyO1xuICAgICAgc3QgKz0gc1tycyAtIDFdO1xuICAgIH1cbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHN0Lmxlbmd0aCA9PT0gbDtcbiAgICAvLyBzdHJpbmcgbWFuaXB1bGF0aW9uXG4gICAgbGV0IHAgPSBNYXRoLnJhbmRvbSgpICogbCAqIDAuOTk5OTk5OTk5OTtcbiAgICBsZXQgc3RtID0gc3Quc3Vic3RyKDAsIHApICsgJyAnICsgc3Quc3Vic3RyKHAsIDIwMDApO1xuICAgIHN0bS5fX3Byb3RvX18ucmVwbGFjZSA9IHN0cmluZ1JlcGxhY2U7XG4gICAgbGV0IHN0byA9IHN0bS5yZXBsYWNlKC8gL2csICcnKTtcbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHN0ID09PSBzdG87XG4gICAgcCA9IE1hdGgucmFuZG9tKCkgKiBsICogMC45OTk5OTk5OTk5O1xuICAgIHN0bSA9IHN0LnN1YnN0cigwLCBwKSArICd7JyArIHN0LnN1YnN0cihwLCAyMDAwKTtcbiAgICBzdG8gPSBzdG0ucmVwbGFjZSgvey9nLCAnJyk7XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzdCA9PT0gc3RvO1xuICAgIHAgPSBNYXRoLnJhbmRvbSgpICogbCAqIDAuOTk5OTk5OTk5OTtcbiAgICBzdG0gPSBzdC5zdWJzdHIoMCwgcCkgKyAnKicgKyBzdC5zdWJzdHIocCwgMjAwMCk7XG4gICAgc3RvID0gc3RtLnJlcGxhY2UoL1xcKi9nLCAnJyk7XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzdCA9PT0gc3RvO1xuICAgIHAgPSBNYXRoLnJhbmRvbSgpICogbCAqIDAuOTk5OTk5OTk5OTtcbiAgICBzdG0gPSBzdC5zdWJzdHIoMCwgcCkgKyAnJCcgKyBzdC5zdWJzdHIocCwgMjAwMCk7XG4gICAgc3RvID0gc3RtLnJlcGxhY2UoL1xcJC9nLCAnJyk7XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzdCA9PT0gc3RvO1xuXG4gICAgLy8gbG93ZXJcbiAgICBjb25zdCBzdGwgPSBzdC50b0xvd2VyQ2FzZSgpO1xuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgKHN0bC5sZW5ndGggPT09IGwpICYmIHN0bFtsIC0gMV0gJiYgIShzdGxbbF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBzMSA9IHN0W2ldO1xuICAgICAgczEuX19wcm90b19fLnRvTG93ZXJDYXNlID0gc3RyaW5nVG9Mb3dlcjtcbiAgICAgIGNvbnN0IHMyID0gc3RsID8gc3RsW2ldIDogJyc7XG4gICAgICBjb25zdCBzMWwgPSBzMS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzMWxbMF0gPT09IHMyICYmIHMxbFswXSAmJiAhKHMxbFsxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAhbm90UG9sbHV0ZWQ7XG59XG5cbmZ1bmN0aW9uIGhleDJiaW4oaGV4KSB7XG4gIHJldHVybiAoJzAwMDAwMDAwJyArIChwYXJzZUludChoZXgsIDE2KSkudG9TdHJpbmcoMikpLnN1YnN0cigtOCk7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVzSW5QYXRoKHNvdXJjZSkge1xuICBjb25zdCBsc3RhdFN5bmMgPSBmcy5sc3RhdFN5bmM7XG4gIGNvbnN0IHJlYWRkaXJTeW5jID0gZnMucmVhZGRpclN5bmM7XG4gIGNvbnN0IGpvaW4gPSBwYXRoLmpvaW47XG5cbiAgZnVuY3Rpb24gaXNEaXJlY3Rvcnkoc291cmNlKSB7XG4gICAgcmV0dXJuIGxzdGF0U3luYyhzb3VyY2UpLmlzRGlyZWN0b3J5KCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNGaWxlKHNvdXJjZSkgeyByZXR1cm4gbHN0YXRTeW5jKHNvdXJjZSkuaXNGaWxlKCk7IH1cblxuICBmdW5jdGlvbiBnZXREaXJlY3Rvcmllcyhzb3VyY2UpIHtcbiAgICByZXR1cm4gcmVhZGRpclN5bmMoc291cmNlKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGpvaW4oc291cmNlLCBuYW1lKTsgfSkuZmlsdGVyKGlzRGlyZWN0b3J5KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGaWxlcyhzb3VyY2UpIHtcbiAgICByZXR1cm4gcmVhZGRpclN5bmMoc291cmNlKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGpvaW4oc291cmNlLCBuYW1lKTsgfSkuZmlsdGVyKGlzRmlsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaWxlc1JlY3Vyc2l2ZWx5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZGlycyA9IGdldERpcmVjdG9yaWVzKHNvdXJjZSk7XG4gICAgICBsZXQgZmlsZXMgPSBkaXJzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZ2V0RmlsZXNSZWN1cnNpdmVseShkaXIpOyB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAgcmV0dXJuIGZpbGVzLmNvbmNhdChnZXRGaWxlcyhzb3VyY2UpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgaWYgKGZzLmV4aXN0c1N5bmMoc291cmNlKSkge1xuICAgIHJldHVybiBnZXRGaWxlc1JlY3Vyc2l2ZWx5KHNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZVBpQ3B1aW5mbyhsaW5lcykge1xuXG4gIC8vIGh0dHBzOi8vd3d3LnJhc3BiZXJyeXBpLm9yZy9kb2N1bWVudGF0aW9uL2hhcmR3YXJlL3Jhc3BiZXJyeXBpL3JldmlzaW9uLWNvZGVzL1JFQURNRS5tZFxuXG4gIGNvbnN0IG9sZFJldmlzaW9uQ29kZXMgPSB7XG4gICAgJzAwMDInOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzEuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDMnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzEuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDQnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA1Jzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdRaXNkYScsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDYnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDcnOiB7XG4gICAgICB0eXBlOiAnQScsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMDgnOiB7XG4gICAgICB0eXBlOiAnQScsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA5Jzoge1xuICAgICAgdHlwZTogJ0EnLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdRaXNkYScsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMGQnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0Vnb21hbicsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMGUnOiB7XG4gICAgICB0eXBlOiAnQicsXG4gICAgICByZXZpc2lvbjogJzIuMCcsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDBmJzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDEwJzoge1xuICAgICAgdHlwZTogJ0IrJyxcbiAgICAgIHJldmlzaW9uOiAnMS4yJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTEnOiB7XG4gICAgICB0eXBlOiAnQ00xJyxcbiAgICAgIHJldmlzaW9uOiAnMS4wJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTInOiB7XG4gICAgICB0eXBlOiAnQSsnLFxuICAgICAgcmV2aXNpb246ICcxLjEnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxMyc6IHtcbiAgICAgIHR5cGU6ICdCKycsXG4gICAgICByZXZpc2lvbjogJzEuMicsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0VtYmVzdCcsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTQnOiB7XG4gICAgICB0eXBlOiAnQ00xJyxcbiAgICAgIHJldmlzaW9uOiAnMS4wJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnRW1iZXN0JyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxNSc6IHtcbiAgICAgIHR5cGU6ICdBKycsXG4gICAgICByZXZpc2lvbjogJzEuMScsXG4gICAgICBtZW1vcnk6IDI1NixcbiAgICAgIG1hbnVmYWN0dXJlcjogJzUxMk1CXHRFbWJlc3QnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcHJvY2Vzc29yTGlzdCA9IFtcbiAgICAnQkNNMjgzNScsXG4gICAgJ0JDTTI4MzYnLFxuICAgICdCQ00yODM3JyxcbiAgICAnQkNNMjcxMScsXG4gIF07XG4gIGNvbnN0IG1hbnVmYWN0dXJlckxpc3QgPSBbXG4gICAgJ1NvbnkgVUsnLFxuICAgICdFZ29tYW4nLFxuICAgICdFbWJlc3QnLFxuICAgICdTb255IEphcGFuJyxcbiAgICAnRW1iZXN0JyxcbiAgICAnU3RhZGl1bSdcbiAgXTtcbiAgY29uc3QgdHlwZUxpc3QgPSB7XG4gICAgJzAwJzogJ0EnLFxuICAgICcwMSc6ICdCJyxcbiAgICAnMDInOiAnQSsnLFxuICAgICcwMyc6ICdCKycsXG4gICAgJzA0JzogJzJCJyxcbiAgICAnMDUnOiAnQWxwaGEgKGVhcmx5IHByb3RvdHlwZSknLFxuICAgICcwNic6ICdDTTEnLFxuICAgICcwOCc6ICczQicsXG4gICAgJzA5JzogJ1plcm8nLFxuICAgICcwYSc6ICdDTTMnLFxuICAgICcwYyc6ICdaZXJvIFcnLFxuICAgICcwZCc6ICczQisnLFxuICAgICcwZSc6ICczQSsnLFxuICAgICcwZic6ICdJbnRlcm5hbCB1c2Ugb25seScsXG4gICAgJzEwJzogJ0NNMysnLFxuICAgICcxMSc6ICc0QicsXG4gICAgJzEyJzogJ1plcm8gMiBXJyxcbiAgICAnMTMnOiAnNDAwJyxcbiAgICAnMTQnOiAnQ000J1xuICB9O1xuXG4gIGNvbnN0IHJldmlzaW9uQ29kZSA9IGdldFZhbHVlKGxpbmVzLCAncmV2aXNpb24nLCAnOicsIHRydWUpO1xuICBjb25zdCBtb2RlbCA9IGdldFZhbHVlKGxpbmVzLCAnbW9kZWw6JywgJzonLCB0cnVlKTtcbiAgY29uc3Qgc2VyaWFsID0gZ2V0VmFsdWUobGluZXMsICdzZXJpYWwnLCAnOicsIHRydWUpO1xuXG4gIGxldCByZXN1bHQgPSB7fTtcbiAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob2xkUmV2aXNpb25Db2RlcywgcmV2aXNpb25Db2RlKSkge1xuICAgIC8vIG9sZCByZXZpc2lvbiBjb2Rlc1xuICAgIHJlc3VsdCA9IHtcbiAgICAgIG1vZGVsLFxuICAgICAgc2VyaWFsLFxuICAgICAgcmV2aXNpb25Db2RlLFxuICAgICAgbWVtb3J5OiBvbGRSZXZpc2lvbkNvZGVzW3JldmlzaW9uQ29kZV0ubWVtb3J5LFxuICAgICAgbWFudWZhY3R1cmVyOiBvbGRSZXZpc2lvbkNvZGVzW3JldmlzaW9uQ29kZV0ubWFudWZhY3R1cmVyLFxuICAgICAgcHJvY2Vzc29yOiBvbGRSZXZpc2lvbkNvZGVzW3JldmlzaW9uQ29kZV0ucHJvY2Vzc29yLFxuICAgICAgdHlwZTogb2xkUmV2aXNpb25Db2Rlc1tyZXZpc2lvbkNvZGVdLnR5cGUsXG4gICAgICByZXZpc2lvbjogb2xkUmV2aXNpb25Db2Rlc1tyZXZpc2lvbkNvZGVdLnJldmlzaW9uLFxuICAgIH07XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBuZXcgcmV2aXNpb24gY29kZVxuICAgIGNvbnN0IHJldmlzaW9uID0gKCcwMDAwMDAwMCcgKyBnZXRWYWx1ZShsaW5lcywgJ3JldmlzaW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpKS5zdWJzdHIoLTgpO1xuICAgIGNvbnN0IG1lbVNpemVDb2RlID0gcGFyc2VJbnQoaGV4MmJpbihyZXZpc2lvbi5zdWJzdHIoMiwgMSkpLnN1YnN0cig1LCAzKSwgMikgfHwgMDtcbiAgICBjb25zdCBtYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXJMaXN0W3BhcnNlSW50KHJldmlzaW9uLnN1YnN0cigzLCAxKSwgMTApXTtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBwcm9jZXNzb3JMaXN0W3BhcnNlSW50KHJldmlzaW9uLnN1YnN0cig0LCAxKSwgMTApXTtcbiAgICBjb25zdCB0eXBlQ29kZSA9IHJldmlzaW9uLnN1YnN0cig1LCAyKTtcblxuXG4gICAgcmVzdWx0ID0ge1xuICAgICAgbW9kZWwsXG4gICAgICBzZXJpYWwsXG4gICAgICByZXZpc2lvbkNvZGUsXG4gICAgICBtZW1vcnk6IDI1NiAqIE1hdGgucG93KDIsIG1lbVNpemVDb2RlKSxcbiAgICAgIG1hbnVmYWN0dXJlcixcbiAgICAgIHByb2Nlc3NvcixcbiAgICAgIHR5cGU6IHt9Lmhhc093blByb3BlcnR5LmNhbGwodHlwZUxpc3QsIHR5cGVDb2RlKSA/IHR5cGVMaXN0W3R5cGVDb2RlXSA6ICcnLFxuICAgICAgcmV2aXNpb246ICcxLicgKyByZXZpc2lvbi5zdWJzdHIoNywgMSksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcm9taXNlQWxsKHByb21pc2VzKSB7XG4gIGNvbnN0IHJlc29sdmluZ1Byb21pc2VzID0gcHJvbWlzZXMubWFwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IG5ldyBBcnJheSgyKTtcbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHBheWxvYWRbMF0gPSByZXN1bHQ7XG4gICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcGF5bG9hZFsxXSA9IGVycm9yO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gVGhlIHdyYXBwZWQgUHJvbWlzZSByZXR1cm5zIGFuIGFycmF5OiAwID0gcmVzdWx0LCAxID0gZXJyb3IgLi4uIHdlIHJlc29sdmUgYWxsXG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gIC8vIEV4ZWN1dGUgYWxsIHdyYXBwZWQgUHJvbWlzZXNcbiAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmluZ1Byb21pc2VzKVxuICAgIC50aGVuKGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICBpZiAocGF5bG9hZFsxXSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKHBheWxvYWRbMV0pO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChudWxsKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocGF5bG9hZFswXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KG5vZGVTdHlsZUZ1bmN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5vZGVTdHlsZUZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnlTYXZlKG5vZGVTdHlsZUZ1bmN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBub2RlU3R5bGVGdW5jdGlvbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGludXhWZXJzaW9uKCkge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmIChfbGludXgpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZXhlY1N5bmMoJ3VuYW1lIC12JykudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGxpc3RQYXJzZXIoeG1sU3RyKSB7XG4gIGNvbnN0IHRhZ3MgPSBbJ2FycmF5JywgJ2RpY3QnLCAna2V5JywgJ3N0cmluZycsICdpbnRlZ2VyJywgJ2RhdGUnLCAncmVhbCcsICdkYXRhJywgJ2Jvb2xlYW4nLCAnYXJyYXlFbXB0eSddO1xuICBjb25zdCBzdGFydFN0ciA9ICc8cGxpc3QgdmVyc2lvbic7XG5cbiAgbGV0IHBvcyA9IHhtbFN0ci5pbmRleE9mKHN0YXJ0U3RyKTtcbiAgbGV0IGxlbiA9IHhtbFN0ci5sZW5ndGg7XG4gIHdoaWxlICh4bWxTdHJbcG9zXSAhPT0gJz4nICYmIHBvcyA8IGxlbikge1xuICAgIHBvcysrO1xuICB9XG5cbiAgbGV0IGRlcHRoID0gMDtcbiAgbGV0IGluVGFnU3RhcnQgPSBmYWxzZTtcbiAgbGV0IGluVGFnQ29udGVudCA9IGZhbHNlO1xuICBsZXQgaW5UYWdFbmQgPSBmYWxzZTtcbiAgbGV0IG1ldGFEYXRhID0gW3sgdGFnU3RhcnQ6ICcnLCB0YWdFbmQ6ICcnLCB0YWdDb250ZW50OiAnJywga2V5OiAnJywgZGF0YTogbnVsbCB9XTtcbiAgbGV0IGMgPSAnJztcbiAgbGV0IGNuID0geG1sU3RyW3Bvc107XG5cbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGMgPSBjbjtcbiAgICBpZiAocG9zICsgMSA8IGxlbikgeyBjbiA9IHhtbFN0cltwb3MgKyAxXTsgfVxuICAgIGlmIChjID09PSAnPCcpIHtcbiAgICAgIGluVGFnQ29udGVudCA9IGZhbHNlO1xuICAgICAgaWYgKGNuID09PSAnLycpIHsgaW5UYWdFbmQgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQpIHtcbiAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgPSAnJztcbiAgICAgICAgaWYgKCFtZXRhRGF0YVtkZXB0aF0uZGF0YSkgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ2FycmF5JyA/IFtdIDoge307IH1cbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgbWV0YURhdGEucHVzaCh7IHRhZ1N0YXJ0OiAnJywgdGFnRW5kOiAnJywgdGFnQ29udGVudDogJycsIGtleTogbnVsbCwgZGF0YTogbnVsbCB9KTtcbiAgICAgICAgaW5UYWdTdGFydCA9IHRydWU7XG4gICAgICAgIGluVGFnQ29udGVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWluVGFnU3RhcnQpIHsgaW5UYWdTdGFydCA9IHRydWU7IH1cbiAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ3RydWUvJykgeyBpblRhZ1N0YXJ0ID0gZmFsc2U7IGluVGFnRW5kID0gdHJ1ZTsgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID0gJyc7IG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnL2Jvb2xlYW4nOyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IHRydWU7IH1cbiAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICdmYWxzZS8nKSB7IGluVGFnU3RhcnQgPSBmYWxzZTsgaW5UYWdFbmQgPSB0cnVlOyBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPSAnJzsgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcvYm9vbGVhbic7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gZmFsc2U7IH1cbiAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICdhcnJheS8nKSB7IGluVGFnU3RhcnQgPSBmYWxzZTsgaW5UYWdFbmQgPSB0cnVlOyBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPSAnJzsgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcvYXJyYXlFbXB0eSc7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gW107IH1cbiAgICAgIGlmIChpblRhZ0NvbnRlbnQpIHsgaW5UYWdDb250ZW50ID0gZmFsc2U7IH1cbiAgICAgIGlmIChpblRhZ1N0YXJ0KSB7XG4gICAgICAgIGluVGFnU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaW5UYWdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9PT0gJ2RpY3QnKSB7XG4gICAgICAgICAgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluVGFnRW5kKSB7XG4gICAgICAgIGluVGFnRW5kID0gZmFsc2U7XG4gICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kICYmIHRhZ3MuaW5kZXhPZihtZXRhRGF0YVtkZXB0aF0udGFnRW5kLnN1YnN0cigxKSkgPj0gMCkge1xuICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2RpY3QnIHx8IG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvYXJyYXknKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAxICYmIG1ldGFEYXRhW2RlcHRoIC0gMl0udGFnU3RhcnQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgbWV0YURhdGFbZGVwdGggLSAyXS5kYXRhLnB1c2gobWV0YURhdGFbZGVwdGggLSAxXS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDEgJiYgbWV0YURhdGFbZGVwdGggLSAyXS50YWdTdGFydCA9PT0gJ2RpY3QnKSB7XG4gICAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoIC0gMl0uZGF0YVttZXRhRGF0YVtkZXB0aCAtIDFdLmtleV0gPSBtZXRhRGF0YVtkZXB0aCAtIDFdLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgbWV0YURhdGEucG9wKCk7XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID0gJyc7XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcva2V5JyAmJiBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkge1xuICAgICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0ua2V5ID0gbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9yZWFsJyAmJiBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IHBhcnNlRmxvYXQobWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHx8IDA7IH1cbiAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvaW50ZWdlcicgJiYgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBwYXJzZUludChtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkgfHwgMDsgfVxuICAgICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9zdHJpbmcnICYmIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgfHwgJyc7IH1cbiAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvYm9vbGVhbicpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCB8fCBmYWxzZTsgfVxuICAgICAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9hcnJheUVtcHR5JykgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50IHx8IFtdOyB9XG4gICAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgbWV0YURhdGFbZGVwdGggLSAxXS50YWdTdGFydCA9PT0gJ2FycmF5JykgeyBtZXRhRGF0YVtkZXB0aCAtIDFdLmRhdGEucHVzaChtZXRhRGF0YVtkZXB0aF0uZGF0YSk7IH1cbiAgICAgICAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBtZXRhRGF0YVtkZXB0aCAtIDFdLnRhZ1N0YXJ0ID09PSAnZGljdCcpIHsgbWV0YURhdGFbZGVwdGggLSAxXS5kYXRhW21ldGFEYXRhW2RlcHRoXS5rZXldID0gbWV0YURhdGFbZGVwdGhdLmRhdGE7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPSAnJztcbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcnO1xuICAgICAgICBpblRhZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGluVGFnQ29udGVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5UYWdTdGFydCkgeyBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgKz0gYzsgfVxuICAgICAgaWYgKGluVGFnRW5kKSB7IG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgKz0gYzsgfVxuICAgICAgaWYgKGluVGFnQ29udGVudCkgeyBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCArPSBjOyB9XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG4gIHJldHVybiBtZXRhRGF0YVswXS5kYXRhO1xufVxuXG5mdW5jdGlvbiBzdHJJc051bWVyaWMoc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiAhaXNOYU4oc3RyKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChzdHIpKTtcbn1cblxuZnVuY3Rpb24gcGxpc3RSZWFkZXIob3V0cHV0KSB7XG4gIGNvbnN0IGxpbmVzID0gb3V0cHV0LnNwbGl0KCdcXG4nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lc1tpXS5pbmRleE9mKCcgPSAnKSA+PSAwKSB7XG4gICAgICBjb25zdCBsaW5lUGFydHMgPSBsaW5lc1tpXS5zcGxpdCgnID0gJyk7XG4gICAgICBsaW5lUGFydHNbMF0gPSBsaW5lUGFydHNbMF0udHJpbSgpO1xuICAgICAgaWYgKCFsaW5lUGFydHNbMF0uc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgICBsaW5lUGFydHNbMF0gPSAnXCInICsgbGluZVBhcnRzWzBdICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGxpbmVQYXJ0c1sxXSA9IGxpbmVQYXJ0c1sxXS50cmltKCk7XG4gICAgICBpZiAobGluZVBhcnRzWzFdLmluZGV4T2YoJ1wiJykgPT09IC0xICYmIGxpbmVQYXJ0c1sxXS5lbmRzV2l0aCgnOycpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gbGluZVBhcnRzWzFdLnN1YnN0cmluZygwLCBsaW5lUGFydHNbMV0ubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICghc3RySXNOdW1lcmljKHZhbHVlU3RyaW5nKSkge1xuICAgICAgICAgIGxpbmVQYXJ0c1sxXSA9IGBcIiR7dmFsdWVTdHJpbmd9XCI7YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmVQYXJ0c1sxXS5pbmRleE9mKCdcIicpID49IDAgJiYgbGluZVBhcnRzWzFdLmVuZHNXaXRoKCc7JykpIHtcbiAgICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBsaW5lUGFydHNbMV0uc3Vic3RyaW5nKDAsIGxpbmVQYXJ0c1sxXS5sZW5ndGggLSAxKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgIGlmIChzdHJJc051bWVyaWModmFsdWVTdHJpbmcpKSB7XG4gICAgICAgICAgbGluZVBhcnRzWzFdID0gYCR7dmFsdWVTdHJpbmd9O2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpbmVzW2ldID0gbGluZVBhcnRzLmpvaW4oJyA6ICcpO1xuICAgIH1cbiAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UoL1xcKC9nLCAnWycpLnJlcGxhY2UoL1xcKS9nLCAnXScpLnJlcGxhY2UoLzsvZywgJywnKS50cmltKCk7XG4gICAgaWYgKGxpbmVzW2ldLnN0YXJ0c1dpdGgoJ30nKSAmJiBsaW5lc1tpIC0gMV0gJiYgbGluZXNbaSAtIDFdLmVuZHNXaXRoKCcsJykpIHtcbiAgICAgIGxpbmVzW2kgLSAxXSA9IGxpbmVzW2kgLSAxXS5zdWJzdHJpbmcoMCwgbGluZXNbaSAtIDFdLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgPSBsaW5lcy5qb2luKCcnKTtcbiAgbGV0IG9iaiA9IHt9O1xuICB0cnkge1xuICAgIG9iaiA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG5vb3AoKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBzZW12ZXJDb21wYXJlKHYxLCB2Mikge1xuICBsZXQgcmVzID0gMDtcbiAgY29uc3QgcGFydHMxID0gdjEuc3BsaXQoJy4nKTtcbiAgY29uc3QgcGFydHMyID0gdjIuc3BsaXQoJy4nKTtcbiAgaWYgKHBhcnRzMVswXSA8IHBhcnRzMlswXSkgeyByZXMgPSAxOyB9XG4gIGVsc2UgaWYgKHBhcnRzMVswXSA+IHBhcnRzMlswXSkgeyByZXMgPSAtMTsgfVxuICBlbHNlIGlmIChwYXJ0czFbMF0gPT09IHBhcnRzMlswXSAmJiBwYXJ0czEubGVuZ3RoID49IDIgJiYgcGFydHMyLmxlbmd0aCA+PSAyKSB7XG4gICAgaWYgKHBhcnRzMVsxXSA8IHBhcnRzMlsxXSkgeyByZXMgPSAxOyB9XG4gICAgZWxzZSBpZiAocGFydHMxWzFdID4gcGFydHMyWzFdKSB7IHJlcyA9IC0xOyB9XG4gICAgZWxzZSBpZiAocGFydHMxWzFdID09PSBwYXJ0czJbMV0pIHtcbiAgICAgIGlmIChwYXJ0czEubGVuZ3RoID49IDMgJiYgcGFydHMyLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIGlmIChwYXJ0czFbMl0gPCBwYXJ0czJbMl0pIHsgcmVzID0gMTsgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0czFbMl0gPiBwYXJ0czJbMl0pIHsgcmVzID0gLTE7IH1cbiAgICAgIH0gZWxzZSBpZiAocGFydHMyLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuZXhwb3J0cy50b0ludCA9IHRvSW50O1xuZXhwb3J0cy5leGVjT3B0c1dpbiA9IGV4ZWNPcHRzV2luO1xuZXhwb3J0cy5nZXRDb2RlcGFnZSA9IGdldENvZGVwYWdlO1xuZXhwb3J0cy5leGVjV2luID0gZXhlY1dpbjtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcbmV4cG9ydHMuc29ydEJ5S2V5ID0gc29ydEJ5S2V5O1xuZXhwb3J0cy5jb3JlcyA9IGNvcmVzO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZXhwb3J0cy5kZWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGRlY29kZUVzY2FwZVNlcXVlbmNlO1xuZXhwb3J0cy5wYXJzZURhdGVUaW1lID0gcGFyc2VEYXRlVGltZTtcbmV4cG9ydHMucGFyc2VIZWFkID0gcGFyc2VIZWFkO1xuZXhwb3J0cy5maW5kT2JqZWN0QnlLZXkgPSBmaW5kT2JqZWN0QnlLZXk7XG5leHBvcnRzLmdldFdtaWMgPSBnZXRXbWljO1xuZXhwb3J0cy53bWljID0gd21pYztcbmV4cG9ydHMuZGFyd2luWGNvZGVFeGlzdHMgPSBkYXJ3aW5YY29kZUV4aXN0cztcbmV4cG9ydHMuZ2V0VmJveG1hbmFnZSA9IGdldFZib3htYW5hZ2U7XG5leHBvcnRzLnBvd2VyU2hlbGwgPSBwb3dlclNoZWxsO1xuZXhwb3J0cy5wb3dlclNoZWxsU3RhcnQgPSBwb3dlclNoZWxsU3RhcnQ7XG5leHBvcnRzLnBvd2VyU2hlbGxSZWxlYXNlID0gcG93ZXJTaGVsbFJlbGVhc2U7XG5leHBvcnRzLmV4ZWNTYWZlID0gZXhlY1NhZmU7XG5leHBvcnRzLm5hbm9TZWNvbmRzID0gbmFub1NlY29uZHM7XG5leHBvcnRzLmNvdW50VW5pcXVlTGluZXMgPSBjb3VudFVuaXF1ZUxpbmVzO1xuZXhwb3J0cy5jb3VudExpbmVzID0gY291bnRMaW5lcztcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLmlzUmFzcGJlcnJ5ID0gaXNSYXNwYmVycnk7XG5leHBvcnRzLmlzUmFzcGJpYW4gPSBpc1Jhc3BiaWFuO1xuZXhwb3J0cy5zYW5pdGl6ZVNoZWxsU3RyaW5nID0gc2FuaXRpemVTaGVsbFN0cmluZztcbmV4cG9ydHMuaXNQcm90b3R5cGVQb2xsdXRlZCA9IGlzUHJvdG90eXBlUG9sbHV0ZWQ7XG5leHBvcnRzLmRlY29kZVBpQ3B1aW5mbyA9IGRlY29kZVBpQ3B1aW5mbztcbmV4cG9ydHMucHJvbWlzZUFsbCA9IHByb21pc2VBbGw7XG5leHBvcnRzLnByb21pc2lmeSA9IHByb21pc2lmeTtcbmV4cG9ydHMucHJvbWlzaWZ5U2F2ZSA9IHByb21pc2lmeVNhdmU7XG5leHBvcnRzLnNtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBzbWFydE1vblRvb2xzSW5zdGFsbGVkO1xuZXhwb3J0cy5saW51eFZlcnNpb24gPSBsaW51eFZlcnNpb247XG5leHBvcnRzLnBsaXN0UGFyc2VyID0gcGxpc3RQYXJzZXI7XG5leHBvcnRzLnBsaXN0UmVhZGVyID0gcGxpc3RSZWFkZXI7XG5leHBvcnRzLnN0cmluZ1JlcGxhY2UgPSBzdHJpbmdSZXBsYWNlO1xuZXhwb3J0cy5zdHJpbmdUb0xvd2VyID0gc3RyaW5nVG9Mb3dlcjtcbmV4cG9ydHMuc3RyaW5nVG9TdHJpbmcgPSBzdHJpbmdUb1N0cmluZztcbmV4cG9ydHMuc3RyaW5nU3Vic3RyID0gc3RyaW5nU3Vic3RyO1xuZXhwb3J0cy5zdHJpbmdUcmltID0gc3RyaW5nVHJpbTtcbmV4cG9ydHMuc3RyaW5nU3RhcnRXaXRoID0gc3RyaW5nU3RhcnRXaXRoO1xuZXhwb3J0cy5tYXRoTWluID0gbWF0aE1pbjtcbmV4cG9ydHMuV0lORElSID0gV0lORElSO1xuZXhwb3J0cy5nZXRGaWxlc0luUGF0aCA9IGdldEZpbGVzSW5QYXRoO1xuZXhwb3J0cy5zZW12ZXJDb21wYXJlID0gc2VtdmVyQ29tcGFyZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gdmlydHVhbGJveC5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDE0LiBEb2NrZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiB2Ym94SW5mbyhjYWxsYmFjaykge1xuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBsZXQgcmVzdWx0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXhlYyh1dGlsLmdldFZib3htYW5hZ2UoKSArICcgbGlzdCB2bXMgLS1sb25nJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgcGFydHMgPSAob3MuRU9MICsgc3Rkb3V0LnRvU3RyaW5nKCkpLnNwbGl0KG9zLkVPTCArICdOYW1lOicpO1xuICAgICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gKCdOYW1lOicgKyBwYXJ0KS5zcGxpdChvcy5FT0wpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhdGUnKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmcgPSBzdGF0ZS5zdGFydHNXaXRoKCdydW5uaW5nJyk7XG4gICAgICAgICAgICBjb25zdCBydW5uaW5nU2luY2VTdHJpbmcgPSBydW5uaW5nID8gc3RhdGUucmVwbGFjZSgncnVubmluZyAoc2luY2UgJywgJycpLnJlcGxhY2UoJyknLCAnJykudHJpbSgpIDogJyc7XG4gICAgICAgICAgICBsZXQgcnVubmluZ1NpbmNlID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luY2VEYXRlT2JqID0gbmV3IERhdGUocnVubmluZ1NpbmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzaW5jZURhdGVPYmouZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nU2luY2UgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gRGF0ZS5wYXJzZShzaW5jZURhdGVPYmopKSAvIDEwMDApICsgb2Zmc2V0ICogNjA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdG9wcGVkU2luY2VTdHJpbmcgPSAhcnVubmluZyA/IHN0YXRlLnJlcGxhY2UoJ3Bvd2VyZWQgb2ZmIChzaW5jZScsICcnKS5yZXBsYWNlKCcpJywgJycpLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgbGV0IHN0b3BwZWRTaW5jZSA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW5jZURhdGVPYmogPSBuZXcgRGF0ZShzdG9wcGVkU2luY2VTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHNpbmNlRGF0ZU9iai5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHN0b3BwZWRTaW5jZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBEYXRlLnBhcnNlKHNpbmNlRGF0ZU9iaikpIC8gMTAwMCkgKyBvZmZzZXQgKiA2MDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdVVUlEJyksXG4gICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOYW1lJyksXG4gICAgICAgICAgICAgIHJ1bm5pbmcsXG4gICAgICAgICAgICAgIHN0YXJ0ZWQ6IHJ1bm5pbmdTaW5jZVN0cmluZyxcbiAgICAgICAgICAgICAgcnVubmluZ1NpbmNlLFxuICAgICAgICAgICAgICBzdG9wcGVkOiBzdG9wcGVkU2luY2VTdHJpbmcsXG4gICAgICAgICAgICAgIHN0b3BwZWRTaW5jZSxcbiAgICAgICAgICAgICAgZ3Vlc3RPUzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0d1ZXN0IE9TJyksXG4gICAgICAgICAgICAgIGhhcmR3YXJlVVVJRDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0hhcmR3YXJlIFVVSUQnKSxcbiAgICAgICAgICAgICAgbWVtb3J5OiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWVtb3J5IHNpemUnLCAnICAgICAnKSwgMTApLFxuICAgICAgICAgICAgICB2cmFtOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVlJBTSBzaXplJyksIDEwKSxcbiAgICAgICAgICAgICAgY3B1czogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ051bWJlciBvZiBDUFVzJyksIDEwKSxcbiAgICAgICAgICAgICAgY3B1RXhlcENhcDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NQVSBleGVjIGNhcCcpLFxuICAgICAgICAgICAgICBjcHVQcm9maWxlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ1BVUHJvZmlsZScpLFxuICAgICAgICAgICAgICBjaGlwc2V0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2hpcHNldCcpLFxuICAgICAgICAgICAgICBmaXJtd2FyZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Zpcm13YXJlJyksXG4gICAgICAgICAgICAgIHBhZ2VGdXNpb246IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWdlIEZ1c2lvbicpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGNvbmZpZ0ZpbGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWcgZmlsZScpLFxuICAgICAgICAgICAgICBzbmFwc2hvdEZvbGRlcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NuYXBzaG90IGZvbGRlcicpLFxuICAgICAgICAgICAgICBsb2dGb2xkZXI6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb2cgZm9sZGVyJyksXG4gICAgICAgICAgICAgIGhwZXQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdIUEVUJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgcGFlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUEFFJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgbG9uZ01vZGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb25nIE1vZGUnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICB0cmlwbGVGYXVsdFJlc2V0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHJpcGxlIEZhdWx0IFJlc2V0JykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgYXBpYzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0FQSUMnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICB4MkFwaWM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdYMkFQSUMnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBhY3BpOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQUNQSScpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGlvQXBpYzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0lPQVBJQycpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGJpb3NBcGljTW9kZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JJT1MgQVBJQyBtb2RlJyksXG4gICAgICAgICAgICAgIGJvb3RNZW51TW9kZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Jvb3QgbWVudSBtb2RlJyksXG4gICAgICAgICAgICAgIGJvb3REZXZpY2UxOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQm9vdCBEZXZpY2UgMScpLFxuICAgICAgICAgICAgICBib290RGV2aWNlMjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Jvb3QgRGV2aWNlIDInKSxcbiAgICAgICAgICAgICAgYm9vdERldmljZTM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCb290IERldmljZSAzJyksXG4gICAgICAgICAgICAgIGJvb3REZXZpY2U0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQm9vdCBEZXZpY2UgNCcpLFxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVGltZSBvZmZzZXQnKSxcbiAgICAgICAgICAgICAgcnRjOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUlRDJyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy52Ym94SW5mbyA9IHZib3hJbmZvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyB3aWZpLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gOS4gd2lmaVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5cbmZ1bmN0aW9uIHdpZmlEQkZyb21RdWFsaXR5KHF1YWxpdHkpIHtcbiAgcmV0dXJuIChwYXJzZUZsb2F0KHF1YWxpdHkpIC8gMiAtIDEwMCk7XG59XG5cbmZ1bmN0aW9uIHdpZmlRdWFsaXR5RnJvbURCKGRiKSB7XG4gIGNvbnN0IHJlc3VsdCA9IDIgKiAocGFyc2VGbG9hdChkYikgKyAxMDApO1xuICByZXR1cm4gcmVzdWx0IDw9IDEwMCA/IHJlc3VsdCA6IDEwMDtcbn1cblxuY29uc3QgX3dpZmlfZnJlcXVlbmNpZXMgPSB7XG4gIDE6IDI0MTIsXG4gIDI6IDI0MTcsXG4gIDM6IDI0MjIsXG4gIDQ6IDI0MjcsXG4gIDU6IDI0MzIsXG4gIDY6IDI0MzcsXG4gIDc6IDI0NDIsXG4gIDg6IDI0NDcsXG4gIDk6IDI0NTIsXG4gIDEwOiAyNDU3LFxuICAxMTogMjQ2MixcbiAgMTI6IDI0NjcsXG4gIDEzOiAyNDcyLFxuICAxNDogMjQ4NCxcbiAgMzI6IDUxNjAsXG4gIDM0OiA1MTcwLFxuICAzNjogNTE4MCxcbiAgMzg6IDUxOTAsXG4gIDQwOiA1MjAwLFxuICA0MjogNTIxMCxcbiAgNDQ6IDUyMjAsXG4gIDQ2OiA1MjMwLFxuICA0ODogNTI0MCxcbiAgNTA6IDUyNTAsXG4gIDUyOiA1MjYwLFxuICA1NDogNTI3MCxcbiAgNTY6IDUyODAsXG4gIDU4OiA1MjkwLFxuICA2MDogNTMwMCxcbiAgNjI6IDUzMTAsXG4gIDY0OiA1MzIwLFxuICA2ODogNTM0MCxcbiAgOTY6IDU0ODAsXG4gIDEwMDogNTUwMCxcbiAgMTAyOiA1NTEwLFxuICAxMDQ6IDU1MjAsXG4gIDEwNjogNTUzMCxcbiAgMTA4OiA1NTQwLFxuICAxMTA6IDU1NTAsXG4gIDExMjogNTU2MCxcbiAgMTE0OiA1NTcwLFxuICAxMTY6IDU1ODAsXG4gIDExODogNTU5MCxcbiAgMTIwOiA1NjAwLFxuICAxMjI6IDU2MTAsXG4gIDEyNDogNTYyMCxcbiAgMTI2OiA1NjMwLFxuICAxMjg6IDU2NDAsXG4gIDEzMjogNTY2MCxcbiAgMTM0OiA1NjcwLFxuICAxMzY6IDU2ODAsXG4gIDEzODogNTY5MCxcbiAgMTQwOiA1NzAwLFxuICAxNDI6IDU3MTAsXG4gIDE0NDogNTcyMCxcbiAgMTQ5OiA1NzQ1LFxuICAxNTE6IDU3NTUsXG4gIDE1MzogNTc2NSxcbiAgMTU1OiA1Nzc1LFxuICAxNTc6IDU3ODUsXG4gIDE1OTogNTc5NSxcbiAgMTYxOiA1ODA1LFxuICAxNjU6IDU4MjUsXG4gIDE2OTogNTg0NSxcbiAgMTczOiA1ODY1LFxuICAxODM6IDQ5MTUsXG4gIDE4NDogNDkyMCxcbiAgMTg1OiA0OTI1LFxuICAxODc6IDQ5MzUsXG4gIDE4ODogNDk0MCxcbiAgMTg5OiA0OTQ1LFxuICAxOTI6IDQ5NjAsXG4gIDE5NjogNDk4MFxufTtcblxuZnVuY3Rpb24gd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKGNoYW5uZWwpIHtcbiAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwoX3dpZmlfZnJlcXVlbmNpZXMsIGNoYW5uZWwpID8gX3dpZmlfZnJlcXVlbmNpZXNbY2hhbm5lbF0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiB3aWZpQ2hhbm5lbEZyb21GcmVxdWVuY3MoZnJlcXVlbmN5KSB7XG4gIGxldCBjaGFubmVsID0gMDtcbiAgZm9yIChsZXQga2V5IGluIF93aWZpX2ZyZXF1ZW5jaWVzKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoX3dpZmlfZnJlcXVlbmNpZXMsIGtleSkpIHtcbiAgICAgIGlmIChfd2lmaV9mcmVxdWVuY2llc1trZXldID09PSBmcmVxdWVuY3kpIHsgY2hhbm5lbCA9IHV0aWwudG9JbnQoa2V5KTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbm5lbDtcbn1cblxuZnVuY3Rpb24gaWZhY2VMaXN0TGludXgoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjbWQgPSAnaXcgZGV2IDI+L2Rldi9udWxsJztcbiAgdHJ5IHtcbiAgICBjb25zdCBhbGwgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKS5qb2luKCdcXG4nKTtcbiAgICBjb25zdCBwYXJ0cyA9IGFsbC5zcGxpdCgnXFxuSW50ZXJmYWNlICcpO1xuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgcGFydHMuZm9yRWFjaChpZmFjZURldGFpbHMgPT4ge1xuICAgICAgY29uc3QgbGluZXMgPSBpZmFjZURldGFpbHMuc3BsaXQoJ1xcbicpO1xuICAgICAgY29uc3QgaWZhY2UgPSBsaW5lc1swXTtcbiAgICAgIGNvbnN0IGlkID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnaWZpbmRleCcsICcgJykpO1xuICAgICAgY29uc3QgbWFjID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2FkZHInLCAnICcpO1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYW5uZWwnLCAnICcpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGlmYWNlLFxuICAgICAgICBtYWMsXG4gICAgICAgIGNoYW5uZWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWxsID0gZXhlY1N5bmMoJ25tY2xpIC10IC1mIGdlbmVyYWwsd2lmaS1wcm9wZXJ0aWVzLHdpcmVkLXByb3BlcnRpZXMsaW50ZXJmYWNlLWZsYWdzLGNhcGFiaWxpdGllcyxuc3AgZGV2aWNlIHNob3cgMj4vZGV2L251bGwnKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcGFydHMgPSBhbGwuc3BsaXQoJ1xcbkdFTkVSQUwuREVWSUNFOicpO1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgcGFydHMuZm9yRWFjaChpZmFjZURldGFpbHMgPT4ge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGlmYWNlRGV0YWlscy5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGlmYWNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuREVWSUNFJyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5UWVBFJyk7XG4gICAgICAgIGNvbnN0IGlkID0gaSsrOyAvLyAvLyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5QQVRIJyk7XG4gICAgICAgIGNvbnN0IG1hYyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLkhXQUREUicpO1xuICAgICAgICBjb25zdCBjaGFubmVsID0gJyc7XG4gICAgICAgIGlmICh0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICd3aWZpJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICBtYWMsXG4gICAgICAgICAgICBjaGFubmVsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5taURldmljZUxpbnV4KGlmYWNlKSB7XG4gIGNvbnN0IGNtZCA9IGBubWNsaSAtdCAtZiBnZW5lcmFsLHdpZmktcHJvcGVydGllcyxjYXBhYmlsaXRpZXMsaXA0LGlwNiBkZXZpY2Ugc2hvdyAke2lmYWNlfSAyPi9kZXYvbnVsbGA7XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5DT05ORUNUSU9OJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlmYWNlLFxuICAgICAgdHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuVFlQRScpLFxuICAgICAgdmVuZG9yOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5WRU5ET1InKSxcbiAgICAgIHByb2R1Y3Q6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLlBST0RVQ1QnKSxcbiAgICAgIG1hYzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuSFdBRERSJykudG9Mb3dlckNhc2UoKSxcbiAgICAgIHNzaWQ6IHNzaWQgIT09ICctLScgPyBzc2lkIDogbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gbm1pQ29ubmVjdGlvbkxpbnV4KHNzaWQpIHtcbiAgY29uc3QgY21kID0gYG5tY2xpIC10IC0tc2hvdy1zZWNyZXRzIGNvbm5lY3Rpb24gc2hvdyAke3NzaWR9IDI+L2Rldi9udWxsYDtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgYnNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnODAyLTExLXdpcmVsZXNzLnNlZW4tYnNzaWRzJykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3NpZDogc3NpZCAhPT0gJy0tJyA/IHNzaWQgOiBudWxsLFxuICAgICAgdXVpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Nvbm5lY3Rpb24udXVpZCcpLFxuICAgICAgdHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Nvbm5lY3Rpb24udHlwZScpLFxuICAgICAgYXV0b2Nvbm5lY3Q6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjb25uZWN0aW9uLmF1dG9jb25uZWN0JykgPT09ICd5ZXMnLFxuICAgICAgc2VjdXJpdHk6IHV0aWwuZ2V0VmFsdWUobGluZXMsICc4MDItMTEtd2lyZWxlc3Mtc2VjdXJpdHkua2V5LW1nbXQnKSxcbiAgICAgIGJzc2lkOiBic3NpZCAhPT0gJy0tJyA/IGJzc2lkIDogbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gd3BhQ29ubmVjdGlvbkxpbnV4KGlmYWNlKSB7XG4gIGNvbnN0IGNtZCA9IGB3cGFfY2xpIC1pICR7aWZhY2V9IHN0YXR1cyAyPiYxYDtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgZnJlcSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZyZXEnLCAnPScpKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3NpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NzaWQnLCAnPScpLFxuICAgICAgdXVpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3V1aWQnLCAnPScpLFxuICAgICAgc2VjdXJpdHk6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXlfbWdtdCcsICc9JyksXG4gICAgICBmcmVxLFxuICAgICAgY2hhbm5lbDogd2lmaUNoYW5uZWxGcm9tRnJlcXVlbmNzKGZyZXEpLFxuICAgICAgYnNzaWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdic3NpZCcsICc9JykudG9Mb3dlckNhc2UoKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2lmaU5ldHdvcmtMaXN0Tm1pKCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY21kID0gJ25tY2xpIC10IC1tIG11bHRpbGluZSAtLWZpZWxkcyBhY3RpdmUsc3NpZCxic3NpZCxtb2RlLGNoYW4sZnJlcSxzaWduYWwsc2VjdXJpdHksd3BhLWZsYWdzLHJzbi1mbGFncyBkZXZpY2Ugd2lmaSBsaXN0IDI+L2Rldi9udWxsJztcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSk7XG4gICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnQUNUSVZFOicpO1xuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgIHBhcnQgPSAnQUNUSVZFOicgKyBwYXJ0O1xuICAgICAgY29uc3QgbGluZXMgPSBwYXJ0LnNwbGl0KG9zLkVPTCk7XG4gICAgICBjb25zdCBjaGFubmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NIQU4nKTtcbiAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGUkVRJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtaHonLCAnJykudHJpbSgpO1xuICAgICAgY29uc3Qgc2VjdXJpdHkgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU0VDVVJJVFknKS5yZXBsYWNlKCcoJywgJycpLnJlcGxhY2UoJyknLCAnJyk7XG4gICAgICBjb25zdCB3cGFGbGFncyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdXUEEtRkxBR1MnKS5yZXBsYWNlKCcoJywgJycpLnJlcGxhY2UoJyknLCAnJyk7XG4gICAgICBjb25zdCByc25GbGFncyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSU04tRkxBR1MnKS5yZXBsYWNlKCcoJywgJycpLnJlcGxhY2UoJyknLCAnJyk7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHNzaWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTU0lEJyksXG4gICAgICAgIGJzc2lkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNTSUQnKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBtb2RlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTU9ERScpLFxuICAgICAgICBjaGFubmVsOiBjaGFubmVsID8gcGFyc2VJbnQoY2hhbm5lbCwgMTApIDogbnVsbCxcbiAgICAgICAgZnJlcXVlbmN5OiBmcmVxdWVuY3kgPyBwYXJzZUludChmcmVxdWVuY3ksIDEwKSA6IG51bGwsXG4gICAgICAgIHNpZ25hbExldmVsOiB3aWZpREJGcm9tUXVhbGl0eSh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU0lHTkFMJykpLFxuICAgICAgICBxdWFsaXR5OiBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTSUdOQUwnKSksXG4gICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eSAmJiBzZWN1cml0eSAhPT0gJ25vbmUnID8gc2VjdXJpdHkuc3BsaXQoJyAnKSA6IFtdLFxuICAgICAgICB3cGFGbGFnczogd3BhRmxhZ3MgJiYgd3BhRmxhZ3MgIT09ICdub25lJyA/IHdwYUZsYWdzLnNwbGl0KCcgJykgOiBbXSxcbiAgICAgICAgcnNuRmxhZ3M6IHJzbkZsYWdzICYmIHJzbkZsYWdzICE9PSAnbm9uZScgPyByc25GbGFncy5zcGxpdCgnICcpIDogW11cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2lmaU5ldHdvcmtMaXN0SXcoaWZhY2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHRyeSB7XG4gICAgbGV0IGl3bGlzdFBhcnRzID0gZXhlY1N5bmMoYGV4cG9ydCBMQ19BTEw9QzsgaXdsaXN0ICR7aWZhY2V9IHNjYW4gMj4mMTsgdW5zZXQgTENfQUxMYCkudG9TdHJpbmcoKS5zcGxpdCgnICAgICAgICBDZWxsICcpO1xuICAgIGlmIChpd2xpc3RQYXJ0c1swXS5pbmRleE9mKCdyZXNvdXJjZSBidXN5JykgPj0gMCkgeyByZXR1cm4gLTE7IH1cbiAgICBpZiAoaXdsaXN0UGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgaXdsaXN0UGFydHMuc2hpZnQoKTtcbiAgICAgIGl3bGlzdFBhcnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZWxlbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhbm5lbCcsICc6JywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSAobGluZXMgJiYgbGluZXMubGVuZ3RoICYmIGxpbmVzWzBdLmluZGV4T2YoJ0FkZHJlc3M6JykgPj0gMCA/IGxpbmVzWzBdLnNwbGl0KCdBZGRyZXNzOicpWzFdLnRyaW0oKS50b0xvd2VyQ2FzZSgpIDogJycpO1xuICAgICAgICBjb25zdCBtb2RlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGUnLCAnOicsIHRydWUpO1xuICAgICAgICBjb25zdCBmcmVxdWVuY3kgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZnJlcXVlbmN5JywgJzonLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcXVhbGl0eVN0cmluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdRdWFsaXR5JywgJz0nLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZGJQYXJ0cyA9IHF1YWxpdHlTdHJpbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnc2lnbmFsIGxldmVsPScpO1xuICAgICAgICBjb25zdCBkYiA9IGRiUGFydHMubGVuZ3RoID4gMSA/IHV0aWwudG9JbnQoZGJQYXJ0c1sxXSkgOiAwO1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gZGIgPyB3aWZpUXVhbGl0eUZyb21EQihkYikgOiAwO1xuICAgICAgICBjb25zdCBzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Vzc2lkJywgJzonLCB0cnVlKTtcblxuICAgICAgICAvLyBzZWN1cml0eSBhbmQgd3BhLWZsYWdzXG4gICAgICAgIGNvbnN0IGlzV3BhID0gZWxlbWVudC5pbmRleE9mKCcgV1BBICcpID49IDA7XG4gICAgICAgIGNvbnN0IGlzV3BhMiA9IGVsZW1lbnQuaW5kZXhPZignV1BBMiAnKSA+PSAwO1xuICAgICAgICBjb25zdCBzZWN1cml0eSA9IFtdO1xuICAgICAgICBpZiAoaXNXcGEpIHsgc2VjdXJpdHkucHVzaCgnV1BBJyk7IH1cbiAgICAgICAgaWYgKGlzV3BhMikgeyBzZWN1cml0eS5wdXNoKCdXUEEyJyk7IH1cbiAgICAgICAgY29uc3Qgd3BhRmxhZ3MgPSBbXTtcbiAgICAgICAgbGV0IHdwYUZsYWcgPSAnJztcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgIGNvbnN0IGwgPSBsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsLmluZGV4T2YoJ2dyb3VwIGNpcGhlcicpID49IDApIHtcbiAgICAgICAgICAgIGlmICh3cGFGbGFnKSB7XG4gICAgICAgICAgICAgIHdwYUZsYWdzLnB1c2god3BhRmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGwuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHdwYUZsYWcgPSBwYXJ0c1sxXS50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGwuaW5kZXhPZigncGFpcndpc2UgY2lwaGVyJykgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBpZiAocGFydHNbMV0uaW5kZXhPZigndGtpcCcpKSB7IHdwYUZsYWcgPSAod3BhRmxhZyA/ICdUS0lQLycgKyB3cGFGbGFnIDogJ1RLSVAnKTsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1sxXS5pbmRleE9mKCdjY21wJykpIHsgd3BhRmxhZyA9ICh3cGFGbGFnID8gJ0NDTVAvJyArIHdwYUZsYWcgOiAnQ0NNUCcpOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzFdLmluZGV4T2YoJ3Byb3ByaWV0YXJ5JykpIHsgd3BhRmxhZyA9ICh3cGFGbGFnID8gJ1BST1AvJyArIHdwYUZsYWcgOiAnUFJPUCcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsLmluZGV4T2YoJ2F1dGhlbnRpY2F0aW9uIHN1aXRlcycpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdLmluZGV4T2YoJzgwMi4xeCcpKSB7IHdwYUZsYWcgPSAod3BhRmxhZyA/ICc4MDIuMXgvJyArIHdwYUZsYWcgOiAnODAyLjF4Jyk7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMV0uaW5kZXhPZigncHNrJykpIHsgd3BhRmxhZyA9ICh3cGFGbGFnID8gJ1BTSy8nICsgd3BhRmxhZyA6ICdQU0snKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3cGFGbGFnKSB7XG4gICAgICAgICAgd3BhRmxhZ3MucHVzaCh3cGFGbGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBzc2lkLFxuICAgICAgICAgIGJzc2lkOiBhZGRyZXNzLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCA/IHV0aWwudG9JbnQoY2hhbm5lbCkgOiBudWxsLFxuICAgICAgICAgIGZyZXF1ZW5jeTogZnJlcXVlbmN5ID8gdXRpbC50b0ludChmcmVxdWVuY3kucmVwbGFjZSgnLicsICcnKSkgOiBudWxsLFxuICAgICAgICAgIHNpZ25hbExldmVsOiBkYixcbiAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgIHNlY3VyaXR5LFxuICAgICAgICAgIHdwYUZsYWdzLFxuICAgICAgICAgIHJzbkZsYWdzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2lmaURhcndpbih3aWZpT2JqKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAod2lmaU9iaikge1xuICAgIHdpZmlPYmouZm9yRWFjaChmdW5jdGlvbiAod2lmaUl0ZW0pIHtcbiAgICAgIGNvbnN0IHNpZ25hbExldmVsID0gd2lmaUl0ZW0uUlNTSTtcbiAgICAgIGxldCBzZWN1cml0eSA9IFtdO1xuICAgICAgbGV0IHdwYUZsYWdzID0gW107XG4gICAgICBpZiAod2lmaUl0ZW0uV1BBX0lFKSB7XG4gICAgICAgIHNlY3VyaXR5LnB1c2goJ1dQQScpO1xuICAgICAgICBpZiAod2lmaUl0ZW0uV1BBX0lFLklFX0tFWV9XUEFfVUNJUEhFUlMpIHtcbiAgICAgICAgICB3aWZpSXRlbS5XUEFfSUUuSUVfS0VZX1dQQV9VQ0lQSEVSUy5mb3JFYWNoKGZ1bmN0aW9uIChjaXBoZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gMCAmJiB3cGFGbGFncy5pbmRleE9mKCd1bmtub3duL1RLSVAnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgndW5rbm93bi9US0lQJyk7IH1cbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSAyICYmIHdwYUZsYWdzLmluZGV4T2YoJ1BTSy9US0lQJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ1BTSy9US0lQJyk7IH1cbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSA0ICYmIHdwYUZsYWdzLmluZGV4T2YoJ1BTSy9BRVMnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgnUFNLL0FFUycpOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh3aWZpSXRlbS5SU05fSUUpIHtcbiAgICAgICAgc2VjdXJpdHkucHVzaCgnV1BBMicpO1xuICAgICAgICBpZiAod2lmaUl0ZW0uUlNOX0lFLklFX0tFWV9SU05fVUNJUEhFUlMpIHtcbiAgICAgICAgICB3aWZpSXRlbS5SU05fSUUuSUVfS0VZX1JTTl9VQ0lQSEVSUy5mb3JFYWNoKGZ1bmN0aW9uIChjaXBoZXJzKSB7XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gMCAmJiB3cGFGbGFncy5pbmRleE9mKCd1bmtub3duL1RLSVAnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgndW5rbm93bi9US0lQJyk7IH1cbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSAyICYmIHdwYUZsYWdzLmluZGV4T2YoJ1RLSVAvVEtJUCcpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCdUS0lQL1RLSVAnKTsgfVxuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDQgJiYgd3BhRmxhZ3MuaW5kZXhPZignUFNLL0FFUycpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCdQU0svQUVTJyk7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBzc2lkOiB3aWZpSXRlbS5TU0lEX1NUUixcbiAgICAgICAgYnNzaWQ6IHdpZmlJdGVtLkJTU0lELFxuICAgICAgICBtb2RlOiAnJyxcbiAgICAgICAgY2hhbm5lbDogd2lmaUl0ZW0uQ0hBTk5FTCxcbiAgICAgICAgZnJlcXVlbmN5OiB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwod2lmaUl0ZW0uQ0hBTk5FTCksXG4gICAgICAgIHNpZ25hbExldmVsOiBzaWduYWxMZXZlbCA/IHBhcnNlSW50KHNpZ25hbExldmVsLCAxMCkgOiBudWxsLFxuICAgICAgICBxdWFsaXR5OiB3aWZpUXVhbGl0eUZyb21EQihzaWduYWxMZXZlbCksXG4gICAgICAgIHNlY3VyaXR5LFxuICAgICAgICB3cGFGbGFncyxcbiAgICAgICAgcnNuRmxhZ3M6IFtdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lmaU5ldHdvcmtzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICByZXN1bHQgPSBnZXRXaWZpTmV0d29ya0xpc3RObWkoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXdjb25maWdQYXJ0cyA9IGV4ZWNTeW5jKCdleHBvcnQgTENfQUxMPUM7IGl3Y29uZmlnIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnKS50b1N0cmluZygpLnNwbGl0KCdcXG5cXG4nKTtcbiAgICAgICAgICAgIGxldCBpZmFjZSA9ICcnO1xuICAgICAgICAgICAgaXdjb25maWdQYXJ0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmRleE9mKCdubyB3aXJlbGVzcycpID09PSAtMSAmJiBlbGVtZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZmFjZSA9IGVsZW1lbnQuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaWZhY2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzID0gZ2V0V2lmaU5ldHdvcmtMaXN0SXcoaWZhY2UpO1xuICAgICAgICAgICAgICBpZiAocmVzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSBhZ2FpbiBhZnRlciA0IHNlY3NcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIChpZmFjZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gZ2V0V2lmaU5ldHdvcmtMaXN0SXcoaWZhY2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcyAhPSAtMSkgeyByZXN1bHQgPSByZXM7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIDQwMDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcztcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICcvU3lzdGVtL0xpYnJhcnkvUHJpdmF0ZUZyYW1ld29ya3MvQXBwbGU4MDIxMS5mcmFtZXdvcmsvVmVyc2lvbnMvQ3VycmVudC9SZXNvdXJjZXMvYWlycG9ydCAtcyAteCc7XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDQwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VXaWZpRGFyd2luKHV0aWwucGxpc3RQYXJzZXIob3V0cHV0KSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgY21kID0gJ25ldHNoIHdsYW4gc2hvdyBuZXR3b3JrcyBtb2RlPUJzc2lkJztcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKGNtZCkudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3NpZFBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCd1dGY4Jykuc3BsaXQob3MuRU9MICsgb3MuRU9MICsgJ1NTSUQgJyk7XG4gICAgICAgICAgc3NpZFBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICBzc2lkUGFydHMuZm9yRWFjaChzc2lkUGFydCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzc2lkTGluZXMgPSBzc2lkUGFydC5zcGxpdChvcy5FT0wpO1xuICAgICAgICAgICAgaWYgKHNzaWRMaW5lcyAmJiBzc2lkTGluZXMubGVuZ3RoID49IDggJiYgc3NpZExpbmVzWzBdLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGJzc2lkc1BhcnRzID0gc3NpZFBhcnQuc3BsaXQoJyBCU1NJRCcpO1xuICAgICAgICAgICAgICBic3NpZHNQYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgIGJzc2lkc1BhcnRzLmZvckVhY2goKGJzc2lkUGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJzc2lkTGluZXMgPSBic3NpZFBhcnQuc3BsaXQob3MuRU9MKTtcbiAgICAgICAgICAgICAgICBjb25zdCBic3NpZExpbmUgPSBic3NpZExpbmVzWzBdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgYnNzaWRMaW5lLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnNzaWQgPSBic3NpZExpbmUuam9pbignOicpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBic3NpZExpbmVzWzNdLnNwbGl0KCc6JykucG9wKCkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1YWxpdHkgPSBic3NpZExpbmVzWzFdLnNwbGl0KCc6JykucG9wKCkudHJpbSgpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgc3NpZDogc3NpZExpbmVzWzBdLnNwbGl0KCc6JykucG9wKCkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgYnNzaWQsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwgPyBwYXJzZUludChjaGFubmVsLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwoY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgICBzaWduYWxMZXZlbDogd2lmaURCRnJvbVF1YWxpdHkocXVhbGl0eSksXG4gICAgICAgICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5ID8gcGFyc2VJbnQocXVhbGl0eSwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBbc3NpZExpbmVzWzJdLnNwbGl0KCc6JykucG9wKCkudHJpbSgpXSxcbiAgICAgICAgICAgICAgICAgIHdwYUZsYWdzOiBbc3NpZExpbmVzWzNdLnNwbGl0KCc6JykucG9wKCkudHJpbSgpXSxcbiAgICAgICAgICAgICAgICAgIHJzbkZsYWdzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy53aWZpTmV0d29ya3MgPSB3aWZpTmV0d29ya3M7XG5cbmZ1bmN0aW9uIGdldFZlbmRvcihtb2RlbCkge1xuICBtb2RlbCA9IG1vZGVsLnRvTG93ZXJDYXNlKCk7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgaWYgKG1vZGVsLmluZGV4T2YoJ2ludGVsJykgPj0gMCkgeyByZXN1bHQgPSAnSW50ZWwnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ3JlYWx0ZWsnKSA+PSAwKSB7IHJlc3VsdCA9ICdSZWFsdGVrJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdxdWFsY29tJykgPj0gMCkgeyByZXN1bHQgPSAnUXVhbGNvbSc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignYnJvYWRjb20nKSA+PSAwKSB7IHJlc3VsdCA9ICdCcm9hZGNvbSc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignY2F2aXVtJykgPj0gMCkgeyByZXN1bHQgPSAnQ2F2aXVtJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdjaXNjbycpID49IDApIHsgcmVzdWx0ID0gJ0Npc2NvJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdtYXJ2ZWwnKSA+PSAwKSB7IHJlc3VsdCA9ICdNYXJ2ZWwnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ3p5eGVsJykgPj0gMCkgeyByZXN1bHQgPSAnWnl4ZWwnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ21lbGFub3gnKSA+PSAwKSB7IHJlc3VsdCA9ICdNZWxhbm94JzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdkLWxpbmsnKSA+PSAwKSB7IHJlc3VsdCA9ICdELUxpbmsnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ3RwLWxpbmsnKSA+PSAwKSB7IHJlc3VsdCA9ICdUUC1MaW5rJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdhc3VzJykgPj0gMCkgeyByZXN1bHQgPSAnQXN1cyc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignbGlua3N5cycpID49IDApIHsgcmVzdWx0ID0gJ0xpbmtzeXMnOyB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdpZmlDb25uZWN0aW9ucyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgY29uc3QgaWZhY2VzID0gaWZhY2VMaXN0TGludXgoKTtcbiAgICAgICAgY29uc3QgbmV0d29ya0xpc3QgPSBnZXRXaWZpTmV0d29ya0xpc3RObWkoKTtcbiAgICAgICAgaWZhY2VzLmZvckVhY2goaWZhY2VEZXRhaWwgPT4ge1xuICAgICAgICAgIGNvbnN0IG5taURldGFpbHMgPSBubWlEZXZpY2VMaW51eChpZmFjZURldGFpbC5pZmFjZSk7XG4gICAgICAgICAgY29uc3Qgd3BhRGV0YWlscyA9IHdwYUNvbm5lY3Rpb25MaW51eChpZmFjZURldGFpbC5pZmFjZSk7XG4gICAgICAgICAgY29uc3Qgc3NpZCA9IG5taURldGFpbHMuc3NpZCB8fCB3cGFEZXRhaWxzLnNzaWQ7XG4gICAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtMaXN0LmZpbHRlcihudyA9PiBudy5zc2lkID09PSBzc2lkKTtcbiAgICAgICAgICBjb25zdCBubWlDb25uZWN0aW9uID0gbm1pQ29ubmVjdGlvbkxpbnV4KHNzaWQpO1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXR3b3JrICYmIG5ldHdvcmsubGVuZ3RoICYmIG5ldHdvcmtbMF0uY2hhbm5lbCA/IG5ldHdvcmtbMF0uY2hhbm5lbCA6ICh3cGFEZXRhaWxzLmNoYW5uZWwgPyB3cGFEZXRhaWxzLmNoYW5uZWwgOiBudWxsKTtcbiAgICAgICAgICBjb25zdCBic3NpZCA9IG5ldHdvcmsgJiYgbmV0d29yay5sZW5ndGggJiYgbmV0d29ya1swXS5ic3NpZCA/IG5ldHdvcmtbMF0uYnNzaWQgOiAod3BhRGV0YWlscy5ic3NpZCA/IHdwYURldGFpbHMuYnNzaWQgOiBudWxsKTtcbiAgICAgICAgICBpZiAoc3NpZCAmJiBic3NpZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWZhY2VEZXRhaWwuaWQsXG4gICAgICAgICAgICAgIGlmYWNlOiBpZmFjZURldGFpbC5pZmFjZSxcbiAgICAgICAgICAgICAgbW9kZWw6IG5taURldGFpbHMucHJvZHVjdCxcbiAgICAgICAgICAgICAgc3NpZCxcbiAgICAgICAgICAgICAgYnNzaWQ6IG5ldHdvcmsgJiYgbmV0d29yay5sZW5ndGggJiYgbmV0d29ya1swXS5ic3NpZCA/IG5ldHdvcmtbMF0uYnNzaWQgOiAod3BhRGV0YWlscy5ic3NpZCA/IHdwYURldGFpbHMuYnNzaWQgOiBudWxsKSxcbiAgICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgICAgICAgZnJlcXVlbmN5OiBjaGFubmVsID8gd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKGNoYW5uZWwpIDogbnVsbCxcbiAgICAgICAgICAgICAgdHlwZTogbm1pQ29ubmVjdGlvbi50eXBlID8gbm1pQ29ubmVjdGlvbi50eXBlIDogJzgwMi4xMScsXG4gICAgICAgICAgICAgIHNlY3VyaXR5OiBubWlDb25uZWN0aW9uLnNlY3VyaXR5ID8gbm1pQ29ubmVjdGlvbi5zZWN1cml0eSA6ICh3cGFEZXRhaWxzLnNlY3VyaXR5ID8gd3BhRGV0YWlscy5zZWN1cml0eSA6IG51bGwpLFxuICAgICAgICAgICAgICBzaWduYWxMZXZlbDogbmV0d29yayAmJiBuZXR3b3JrLmxlbmd0aCAmJiBuZXR3b3JrWzBdLnNpZ25hbExldmVsID8gbmV0d29ya1swXS5zaWduYWxMZXZlbCA6IG51bGwsXG4gICAgICAgICAgICAgIHR4UmF0ZTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgU1BOZXR3b3JrRGF0YVR5cGUnO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0czEgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxuICAgIFdpLUZpOlxcblxcbicpO1xuICAgICAgICAgIGlmIChwYXJ0czEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0czFbMV0uc3BsaXQoJ1xcblxcbicpWzBdLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGlmYWNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTRCBEZXZpY2UgTmFtZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdoYXJkd2FyZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICBjbWQgPSAnL1N5c3RlbS9MaWJyYXJ5L1ByaXZhdGVGcmFtZXdvcmtzL0FwcGxlODAyMTEuZnJhbWV3b3JrL1ZlcnNpb25zL0N1cnJlbnQvUmVzb3VyY2VzL2FpcnBvcnQgLUknO1xuICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzMiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnc3NpZCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2Jzc2lkJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN1cml0eSA9IHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnbGluayBhdXRoJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFJhdGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2xhc3RUeFJhdGUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2NoYW5uZWwnLCAnOicsIHRydWUpLnNwbGl0KCcsJylbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9ICc4MDIuMTEnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJzc2kgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMyLCAnYWdyQ3RsUlNTSScsICc6JywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vaXNlID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2FnckN0bE5vaXNlJywgJzonLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsTGV2ZWwgPSByc3NpIC0gbm9pc2U7XG4gICAgICAgICAgICAgICAgaWYgKHNzaWQgfHwgYnNzaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdXaS1GaScsXG4gICAgICAgICAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgc3NpZCxcbiAgICAgICAgICAgICAgICAgICAgYnNzaWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHV0aWwudG9JbnQoY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogY2hhbm5lbCA/IHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbChjaGFubmVsKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWxMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgdHhSYXRlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgY21kID0gJ25ldHNoIHdsYW4gc2hvdyBpbnRlcmZhY2VzJztcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKGNtZCkudGhlbihmdW5jdGlvbiAoc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgYWxsTGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWxsTGluZXNbaV0gPSBhbGxMaW5lc1tpXS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhcnRzID0gYWxsTGluZXMuam9pbignXFxyXFxuJykuc3BsaXQoJzpcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlmYWNlID0gbGluZXNbMF0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1swXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGxpbmVzWzFdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMV0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBsaW5lc1syXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzJdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU1NJRCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGJzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTU0lEJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsTGV2ZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2lnbmFsJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSYWRpbyB0eXBlJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHlwZSBkZSByYWRpbycsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Z1bmt0eXAnLCAnOicsIHRydWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IHNlY3VyaXR5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2F1dGhlbnRpY2F0aW9uJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQXV0aGVudGlmaWNhdGlvbicsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0F1dGhlbnRpZml6aWVydW5nJywgJzonLCB0cnVlKSB8fCBudWxsO1xuICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NoYW5uZWwnLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYW5hbCcsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0thbmFsJywgJzonLCB0cnVlKSB8fCBudWxsO1xuICAgICAgICAgICAgICBjb25zdCB0eFJhdGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHJhbnNtaXQgcmF0ZSAobWJwcyknLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUcmFuc21pc3Npb24gKG1iaXQvcyknLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdFbXBmYW5nc3JhdGUgKE1CaXQvcyknLCAnOicsIHRydWUpIHx8IG51bGw7XG4gICAgICAgICAgICAgIGlmIChtb2RlbCAmJiBpZCAmJiBzc2lkICYmIGJzc2lkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgc3NpZCxcbiAgICAgICAgICAgICAgICAgIGJzc2lkLFxuICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdXRpbC50b0ludChjaGFubmVsKSxcbiAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogY2hhbm5lbCA/IHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbChjaGFubmVsKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgc2VjdXJpdHksXG4gICAgICAgICAgICAgICAgICBzaWduYWxMZXZlbCxcbiAgICAgICAgICAgICAgICAgIHR4UmF0ZTogdXRpbC50b0ludCh0eFJhdGUpIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy53aWZpQ29ubmVjdGlvbnMgPSB3aWZpQ29ubmVjdGlvbnM7XG5cbmZ1bmN0aW9uIHdpZmlJbnRlcmZhY2VzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBjb25zdCBpZmFjZXMgPSBpZmFjZUxpc3RMaW51eCgpO1xuICAgICAgICBpZmFjZXMuZm9yRWFjaChpZmFjZURldGFpbCA9PiB7XG4gICAgICAgICAgY29uc3Qgbm1pRGV0YWlscyA9IG5taURldmljZUxpbnV4KGlmYWNlRGV0YWlsLmlmYWNlKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBpZDogaWZhY2VEZXRhaWwuaWQsXG4gICAgICAgICAgICBpZmFjZTogaWZhY2VEZXRhaWwuaWZhY2UsXG4gICAgICAgICAgICBtb2RlbDogbm1pRGV0YWlscy5wcm9kdWN0ID8gbm1pRGV0YWlscy5wcm9kdWN0IDogbnVsbCxcbiAgICAgICAgICAgIHZlbmRvcjogbm1pRGV0YWlscy52ZW5kb3IgPyBubWlEZXRhaWxzLnZlbmRvciA6IG51bGwsXG4gICAgICAgICAgICBtYWM6IGlmYWNlRGV0YWlsLm1hYyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIFNQTmV0d29ya0RhdGFUeXBlJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgcGFydHMxID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxcbiAgICBXaS1GaTpcXG5cXG4nKTtcbiAgICAgICAgICBpZiAocGFydHMxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydHMxWzFdLnNwbGl0KCdcXG5cXG4nKVswXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBpZmFjZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU0QgRGV2aWNlIE5hbWUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgbWFjID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01BQyBBZGRyZXNzJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2hhcmR3YXJlJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6ICdXaS1GaScsXG4gICAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgbWFjXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgY21kID0gJ25ldHNoIHdsYW4gc2hvdyBpbnRlcmZhY2VzJztcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKGNtZCkudGhlbihmdW5jdGlvbiAoc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgYWxsTGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWxsTGluZXNbaV0gPSBhbGxMaW5lc1tpXS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBhcnRzID0gYWxsTGluZXMuam9pbignXFxyXFxuJykuc3BsaXQoJzpcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlmYWNlID0gbGluZXNbMF0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1swXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGxpbmVzWzFdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMV0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBsaW5lc1syXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzJdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IG1hY1BhcnRzID0gbGluZXNbM10uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1szXS5zcGxpdCgnOicpIDogW107XG4gICAgICAgICAgICAgIG1hY1BhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IG1hYyA9IG1hY1BhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IHZlbmRvciA9IGdldFZlbmRvcihtb2RlbCk7XG4gICAgICAgICAgICAgIGlmIChpZmFjZSAmJiBtb2RlbCAmJiBpZCAmJiBtYWMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICB2ZW5kb3IsXG4gICAgICAgICAgICAgICAgICBtYWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMud2lmaUludGVyZmFjZXMgPSB3aWZpSW50ZXJmYWNlcztcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwic3lzdGVtaW5mb3JtYXRpb25cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNS4xNy4xMlwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQWR2YW5jZWQsIGxpZ2h0d2VpZ2h0IHN5c3RlbSBhbmQgT1MgaW5mb3JtYXRpb24gbGlicmFyeVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJhdXRob3JcIjogXCJTZWJhc3RpYW4gSGlsZGVicmFuZHQgPGhpbGRlYnJhbmR0QHBsdXMtaW5ub3ZhdGlvbnMuY29tPiAoaHR0cHM6Ly9wbHVzLWlubm92YXRpb25zLmNvbSlcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vc3lzdGVtaW5mb3JtYXRpb24uaW9cIixcbiAgXCJtYWluXCI6IFwiLi9saWIvaW5kZXguanNcIixcbiAgXCJiaW5cIjoge1xuICAgIFwic3lzdGVtaW5mb3JtYXRpb25cIjogXCJsaWIvY2xpLmpzXCJcbiAgfSxcbiAgXCJ0eXBlc1wiOiBcIi4vbGliL2luZGV4LmQudHNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJub2RlIC4vdGVzdC90ZXN0LmpzXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJsaWIvXCJcbiAgXSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJzeXN0ZW0gaW5mb3JtYXRpb25cIixcbiAgICBcInN5c2luZm9cIixcbiAgICBcIm1vbml0b3JcIixcbiAgICBcIm1vbml0b3JpbmdcIixcbiAgICBcIm9zXCIsXG4gICAgXCJsaW51eFwiLFxuICAgIFwib3N4XCIsXG4gICAgXCJ3aW5kb3dzXCIsXG4gICAgXCJmcmVlYnNkXCIsXG4gICAgXCJvcGVuYnNkXCIsXG4gICAgXCJuZXRic2RcIixcbiAgICBcImNwdVwiLFxuICAgIFwiY3B1bG9hZFwiLFxuICAgIFwicGh5c2ljYWwgY29yZXNcIixcbiAgICBcImxvZ2ljYWwgY29yZXNcIixcbiAgICBcInByb2Nlc3NvclwiLFxuICAgIFwiY29yZXNcIixcbiAgICBcInRocmVhZHNcIixcbiAgICBcInNvY2tldCB0eXBlXCIsXG4gICAgXCJtZW1vcnlcIixcbiAgICBcImZpbGUgc3lzdGVtXCIsXG4gICAgXCJmc3N0YXRzXCIsXG4gICAgXCJkaXNraW9cIixcbiAgICBcImJsb2NrIGRldmljZXNcIixcbiAgICBcIm5ldHN0YXRzXCIsXG4gICAgXCJuZXR3b3JrXCIsXG4gICAgXCJuZXR3b3JrIGludGVyZmFjZXNcIixcbiAgICBcIm5ldHdvcmsgY29ubmVjdGlvbnNcIixcbiAgICBcIm5ldHdvcmsgc3RhdHNcIixcbiAgICBcImlmYWNlXCIsXG4gICAgXCJwcmludGVyXCIsXG4gICAgXCJwcm9jZXNzZXNcIixcbiAgICBcInVzZXJzXCIsXG4gICAgXCJpbnRlcm5ldFwiLFxuICAgIFwiYmF0dGVyeVwiLFxuICAgIFwiZG9ja2VyXCIsXG4gICAgXCJkb2NrZXIgc3RhdHNcIixcbiAgICBcImRvY2tlciBwcm9jZXNzZXNcIixcbiAgICBcImdyYXBoaWNzXCIsXG4gICAgXCJncmFwaGljIGNhcmRcIixcbiAgICBcImdyYXBoaWMgY29udHJvbGxlclwiLFxuICAgIFwiZ3B1XCIsXG4gICAgXCJkaXNwbGF5XCIsXG4gICAgXCJzbWFydFwiLFxuICAgIFwiZGlzayBsYXlvdXRcIixcbiAgICBcInVzYlwiLFxuICAgIFwiYXVkaW9cIixcbiAgICBcImJsdWV0b290aFwiLFxuICAgIFwid2lmaVwiLFxuICAgIFwid2lmaW5ldHdvcmtzXCIsXG4gICAgXCJ2aXJ0dWFsIGJveFwiLFxuICAgIFwidmlydHVhbGJveFwiLFxuICAgIFwidm1cIixcbiAgICBcImJhY2tlbmRcIixcbiAgICBcImhhcmR3YXJlXCIsXG4gICAgXCJCSU9TXCIsXG4gICAgXCJjaGFzc2lzXCJcbiAgXSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zZWJoaWxkZWJyYW5kdC9zeXN0ZW1pbmZvcm1hdGlvbi5naXRcIlxuICB9LFxuICBcImZ1bmRpbmdcIjoge1xuICAgIFwidHlwZVwiOiBcIkJ1eSBtZSBhIGNvZmZlZVwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly93d3cuYnV5bWVhY29mZmVlLmNvbS9zeXN0ZW1pbmZvXCJcbiAgfSxcbiAgXCJvc1wiOiBbXG4gICAgXCJkYXJ3aW5cIixcbiAgICBcImxpbnV4XCIsXG4gICAgXCJ3aW4zMlwiLFxuICAgIFwiZnJlZWJzZFwiLFxuICAgIFwib3BlbmJzZFwiLFxuICAgIFwibmV0YnNkXCIsXG4gICAgXCJzdW5vc1wiLFxuICAgIFwiYW5kcm9pZFwiXG4gIF0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj04LjAuMFwiXG4gIH1cbn1cbiJdfQ=="}