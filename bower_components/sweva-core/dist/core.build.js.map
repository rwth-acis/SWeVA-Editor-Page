{"version":3,"sources":["node_modules/browser-pack/_prelude.js","app/core/compilers/assemblyScriptCompiler.js","app/core/compilers/compiler.js","app/core/composables/composable.js","app/core/composables/composition.js","app/core/composables/module.js","app/core/core.js","app/core/errors/ExecutionError.js","app/core/errors/compileError.js","app/core/errors/definitionError.js","app/core/errors/errorManager.js","app/core/errors/swevaError.js","app/core/execution/composableLoader.js","app/core/execution/executionManager.js","app/core/execution/supportLibrary.js","app/core/network/dataProcessingDevice.js","app/core/network/potentialOffloadingTarget.js","app/core/offloading/availableOffloadingResources.js","app/core/offloading/offloadingDecision.js","app/core/offloading/offloadingTarget.js","app/core/runners/assemblyScriptRunner.js","app/core/runners/runner.js","app/core/swevaScript/swevaScript.js","node_modules/ajv/lib/ajv.js","node_modules/ajv/lib/cache.js","node_modules/ajv/lib/compile/_rules.js","node_modules/ajv/lib/compile/equal.js","node_modules/ajv/lib/compile/formats.js","node_modules/ajv/lib/compile/index.js","node_modules/ajv/lib/compile/resolve.js","node_modules/ajv/lib/compile/rules.js","node_modules/ajv/lib/compile/schema_obj.js","node_modules/ajv/lib/compile/util.js","node_modules/ajv/lib/dotjs/allOf.js","node_modules/ajv/lib/dotjs/anyOf.js","node_modules/ajv/lib/dotjs/dependencies.js","node_modules/ajv/lib/dotjs/enum.js","node_modules/ajv/lib/dotjs/format.js","node_modules/ajv/lib/dotjs/items.js","node_modules/ajv/lib/dotjs/maxItems.js","node_modules/ajv/lib/dotjs/maxLength.js","node_modules/ajv/lib/dotjs/maxProperties.js","node_modules/ajv/lib/dotjs/maximum.js","node_modules/ajv/lib/dotjs/minItems.js","node_modules/ajv/lib/dotjs/minLength.js","node_modules/ajv/lib/dotjs/minProperties.js","node_modules/ajv/lib/dotjs/minimum.js","node_modules/ajv/lib/dotjs/multipleOf.js","node_modules/ajv/lib/dotjs/not.js","node_modules/ajv/lib/dotjs/oneOf.js","node_modules/ajv/lib/dotjs/pattern.js","node_modules/ajv/lib/dotjs/properties.js","node_modules/ajv/lib/dotjs/ref.js","node_modules/ajv/lib/dotjs/required.js","node_modules/ajv/lib/dotjs/uniqueItems.js","node_modules/ajv/lib/dotjs/validate.js","node_modules/ajv/lib/refs/json-schema-draft-04.json","node_modules/as-bind/dist/as-bind.cjs.js","node_modules/async-mqtt/index.js","node_modules/available-typed-arrays/index.js","node_modules/base64-js/index.js","node_modules/bl/bl.js","node_modules/browser-resolve/empty.js","node_modules/buffer/index.js","node_modules/builtin-status-codes/browser.js","node_modules/call-bind/callBound.js","node_modules/call-bind/index.js","node_modules/clone/clone.js","node_modules/core-util-is/lib/util.js","node_modules/d/auto-bind.js","node_modules/d/index.js","node_modules/duplexify/index.js","node_modules/end-of-stream/index.js","node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js","node_modules/es5-ext/array/#/clear.js","node_modules/es5-ext/array/#/e-index-of.js","node_modules/es5-ext/array/from/index.js","node_modules/es5-ext/array/from/is-implemented.js","node_modules/es5-ext/array/from/shim.js","node_modules/es5-ext/function/is-arguments.js","node_modules/es5-ext/function/is-function.js","node_modules/es5-ext/function/noop.js","node_modules/es5-ext/math/sign/index.js","node_modules/es5-ext/math/sign/is-implemented.js","node_modules/es5-ext/math/sign/shim.js","node_modules/es5-ext/number/is-nan/index.js","node_modules/es5-ext/number/is-nan/is-implemented.js","node_modules/es5-ext/number/is-nan/shim.js","node_modules/es5-ext/number/to-integer.js","node_modules/es5-ext/number/to-pos-integer.js","node_modules/es5-ext/object/_iterate.js","node_modules/es5-ext/object/assign/index.js","node_modules/es5-ext/object/assign/is-implemented.js","node_modules/es5-ext/object/assign/shim.js","node_modules/es5-ext/object/copy.js","node_modules/es5-ext/object/create.js","node_modules/es5-ext/object/for-each.js","node_modules/es5-ext/object/is-object.js","node_modules/es5-ext/object/is-value.js","node_modules/es5-ext/object/keys/index.js","node_modules/es5-ext/object/keys/is-implemented.js","node_modules/es5-ext/object/keys/shim.js","node_modules/es5-ext/object/map.js","node_modules/es5-ext/object/normalize-options.js","node_modules/es5-ext/object/primitive-set.js","node_modules/es5-ext/object/set-prototype-of/index.js","node_modules/es5-ext/object/set-prototype-of/is-implemented.js","node_modules/es5-ext/object/set-prototype-of/shim.js","node_modules/es5-ext/object/valid-callable.js","node_modules/es5-ext/object/valid-value.js","node_modules/es5-ext/string/#/contains/index.js","node_modules/es5-ext/string/#/contains/is-implemented.js","node_modules/es5-ext/string/#/contains/shim.js","node_modules/es5-ext/string/is-string.js","node_modules/es6-iterator/array.js","node_modules/es6-iterator/for-of.js","node_modules/es6-iterator/get.js","node_modules/es6-iterator/index.js","node_modules/es6-iterator/is-iterable.js","node_modules/es6-iterator/string.js","node_modules/es6-iterator/valid-iterable.js","node_modules/es6-map/index.js","node_modules/es6-map/is-implemented.js","node_modules/es6-map/is-native-implemented.js","node_modules/es6-map/lib/iterator-kinds.js","node_modules/es6-map/lib/iterator.js","node_modules/es6-map/polyfill.js","node_modules/es6-symbol/index.js","node_modules/es6-symbol/is-implemented.js","node_modules/es6-symbol/is-symbol.js","node_modules/es6-symbol/lib/private/generate-name.js","node_modules/es6-symbol/lib/private/setup/standard-symbols.js","node_modules/es6-symbol/lib/private/setup/symbol-registry.js","node_modules/es6-symbol/polyfill.js","node_modules/es6-symbol/validate-symbol.js","node_modules/event-emitter/index.js","node_modules/events/events.js","node_modules/ext/global-this/implementation.js","node_modules/ext/global-this/index.js","node_modules/ext/global-this/is-implemented.js","node_modules/foreach/index.js","node_modules/function-bind/implementation.js","node_modules/function-bind/index.js","node_modules/get-intrinsic/index.js","node_modules/has-symbols/index.js","node_modules/has-symbols/shams.js","node_modules/has-tostringtag/shams.js","node_modules/has/src/index.js","node_modules/https-browserify/index.js","node_modules/ieee754/index.js","node_modules/in-array/index.js","node_modules/inherits/inherits_browser.js","node_modules/is-arguments/index.js","node_modules/is-generator-function/index.js","node_modules/is-typed-array/index.js","node_modules/isarray/index.js","node_modules/js-tokens/index.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/mqtt-packet/constants.js","node_modules/mqtt-packet/generate.js","node_modules/mqtt-packet/mqtt.js","node_modules/mqtt-packet/numbers.js","node_modules/mqtt-packet/packet.js","node_modules/mqtt-packet/parser.js","node_modules/mqtt-packet/writeToStream.js","node_modules/mqtt/lib/client.js","node_modules/mqtt/lib/connect/index.js","node_modules/mqtt/lib/connect/tcp.js","node_modules/mqtt/lib/connect/tls.js","node_modules/mqtt/lib/connect/ws.js","node_modules/mqtt/lib/connect/wx.js","node_modules/mqtt/lib/store.js","node_modules/mqtt/lib/validations.js","node_modules/once/once.js","node_modules/os-browserify/browser.js","node_modules/path-browserify/index.js","node_modules/process-nextick-args/index.js","node_modules/process/browser.js","node_modules/punycode/punycode.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/querystring-es3/index.js","node_modules/readable-stream/duplex-browser.js","node_modules/readable-stream/lib/_stream_duplex.js","node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/readable-stream/lib/_stream_readable.js","node_modules/readable-stream/lib/_stream_transform.js","node_modules/readable-stream/lib/_stream_writable.js","node_modules/readable-stream/lib/internal/streams/BufferList.js","node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/readable-stream/lib/internal/streams/stream-browser.js","node_modules/readable-stream/node_modules/safe-buffer/index.js","node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js","node_modules/readable-stream/readable-browser.js","node_modules/reinterval/index.js","node_modules/safe-buffer/index.js","node_modules/stream-http/index.js","node_modules/stream-http/lib/capability.js","node_modules/stream-http/lib/request.js","node_modules/stream-http/lib/response.js","node_modules/stream-http/node_modules/readable-stream/errors-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_passthrough.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_readable.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_transform.js","node_modules/stream-http/node_modules/readable-stream/lib/_stream_writable.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/buffer_list.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/from-browser.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/pipeline.js","node_modules/stream-http/node_modules/readable-stream/lib/internal/streams/state.js","node_modules/stream-http/node_modules/readable-stream/readable-browser.js","node_modules/stream-shift/index.js","node_modules/timers-browserify/main.js","node_modules/type/function/is.js","node_modules/type/lib/resolve-exception.js","node_modules/type/lib/safe-to-string.js","node_modules/type/lib/to-short-string.js","node_modules/type/object/is.js","node_modules/type/plain-function/ensure.js","node_modules/type/plain-function/is.js","node_modules/type/prototype/is.js","node_modules/type/string/coerce.js","node_modules/type/value/ensure.js","node_modules/type/value/is.js","node_modules/url/url.js","node_modules/url/util.js","node_modules/util-deprecate/browser.js","node_modules/util/support/isBufferBrowser.js","node_modules/util/support/types.js","node_modules/util/util.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_duplex.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_readable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/_stream_writable.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js","node_modules/websocket-stream/node_modules/readable-stream/lib/internal/streams/destroy.js","node_modules/websocket-stream/stream.js","node_modules/websocket-stream/ws-fallback.js","node_modules/which-typed-array/index.js","node_modules/wrappy/wrappy.js","node_modules/xtend/immutable.js","../../node_modules/systeminformation/lib/audio.js","../../node_modules/systeminformation/lib/battery.js","../../node_modules/systeminformation/lib/bluetooth.js","../../node_modules/systeminformation/lib/cpu.js","../../node_modules/systeminformation/lib/docker.js","../../node_modules/systeminformation/lib/dockerSocket.js","../../node_modules/systeminformation/lib/filesystem.js","../../node_modules/systeminformation/lib/graphics.js","../../node_modules/systeminformation/lib/index.js","../../node_modules/systeminformation/lib/internet.js","../../node_modules/systeminformation/lib/memory.js","../../node_modules/systeminformation/lib/network.js","../../node_modules/systeminformation/lib/osinfo.js","../../node_modules/systeminformation/lib/printer.js","../../node_modules/systeminformation/lib/processes.js","../../node_modules/systeminformation/lib/system.js","../../node_modules/systeminformation/lib/usb.js","../../node_modules/systeminformation/lib/users.js","../../node_modules/systeminformation/lib/util.js","../../node_modules/systeminformation/lib/virtualbox.js","../../node_modules/systeminformation/lib/wifi.js","../../node_modules/systeminformation/package.json"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACjhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACpTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1qDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC58CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC/kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACviBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"core.build.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","'use strict';\n\n//var {asc, assemblyscript} = require('../../../node_modules/assemblyscript/dist/sdk.js');\n//var AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\n//var AsBindTransform = require('../../../node_modules/as-bind/dist/transform.cjs');\nvar Runner = require('../../core/runners/runner.js');\nvar Compiler = require('../../core/compilers/compiler.js');\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\nvar Composable = require('../../core/composables/composable.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar CompileError = require('../../core/errors/compileError.js');\nconst DefinitionError = require(\"../../core/errors/ExecutionError.js\");\nconst offloadingDecision = require(\"../offloading/offloadingDecision\");\n\n//var AssemblyScriptGetterTransform = require('./assemblyScriptGetterTransform.js');\n\n/** include web-worker library for Nodejs **/\n\nif(typeof Worker === 'undefined') {\n    console.log(\"Loading Node worker module\");\n    var WorkerNodeJS = require('../../../node_modules/web-worker/cjs/node');\n}\n\n\n/**\n * The AssemblyScriptCompiler supports strict TypeScript\n *\n * @constructor\n * @extends Compiler\n *\n */\nfunction AssemblyScriptCompiler(supportLib) {\n    this.worker = null;\n    this.internalGetterPrefix = \"_internal_get_\";\n    this.supportLibraryDeclares = this.generateSupportLibraryDeclares(supportLib);\n    this.supportLibraryDocumentation = \"The lib namespace contains all function from the support library.\\n\" +\n        \"synchronous functions return their result immediately, while the callback for asynchronous functions is called after all currently running AssemblyScript code is finished.\\n\" +\n        \"Callback functions can have less parameters than the listed parameters, in which case only the first parameters are passed.\\n\" +\n        \"Functions:\\n\";\n    this.resolveCompile = null;\n}\n\n//inherit properties\nAssemblyScriptCompiler.prototype = Object.create(Compiler.prototype);\nAssemblyScriptCompiler.prototype.constructor = AssemblyScriptCompiler;\n\n/**\n * generates declare statements necessary, to access JavaScript functions from AssemblyScript\n * additionally the documentation is generated\n * @param supportLib\n */\nAssemblyScriptCompiler.prototype.generateSupportLibraryDeclares = function (supportLib) {\n    let docs = \"\";\n    let declares = \"namespace lib {\\n\";\n    for(let funcName in supportLib.functions) {\n        let returnSig = supportLib.functions[funcName].languageSpecific.typescript.returnSig || \"void\";\n        let paramSig = supportLib.functions[funcName].languageSpecific.typescript.parameterSig;\n        //callback function name is first parameter for asynchronous functions\n        if(supportLib.functions[funcName].async) {\n            paramSig = \"callback: string | null\" + (typeof paramSig !== undefined ? \", \"+paramSig : \"\");\n            returnSig = \"void\";\n        }\n        docs += funcName+\":\\n\"+\n            \"  Description: \"+supportLib.functions[funcName].description+\"\\n\"+\n            \"  Parameters: \\\"\"+paramSig+\"\\\"\\n\"+\n            \"  \"+(supportLib.functions[funcName].async?\n                \"Async function: callback with signature \\\"\"+supportLib.functions[funcName].languageSpecific.typescript.returnSig+\"\\\" required\":\n                \"Sync function: returns \\\"\"+returnSig+\"\\\"\")+\n            \"\\n\";\n        declares += \"export declare function \" + funcName + \"(\" + paramSig + \"):\" + returnSig + \";\\n\";\n    }\n    declares += \"}\";\n    this.supportLibraryDocumentation = docs;\n    console.log(\"Support functions:\");\n    console.log(this.supportLibraryDocumentation);\n    console.log(declares)\n    return declares;\n}\n\nAssemblyScriptCompiler.prototype.setup = async function () {\n    var self = this;\n\n    if(!this.setupCompleted) {\n        return new Promise((resolve) => {\n            console.log(\"Loading AssemblyScript compiler\");\n\n            this.initWorker();\n\n            this.worker.onmessage = function (e) {\n                console.log('msg to worker');\n                console.log(e.data);\n                switch (e.data.type) {\n                    case \"setupComplete\":\n                        console.log(\"setup complete\")\n                        self.setupCompleted = true;\n                        resolve();\n                        break;\n                    case \"compileError\":\n                    case \"compileResult\":\n                        if(self.resolveCompile != null) {\n                            self.resolveCompile(e.data);\n                        }\n                        break;\n                }\n            }\n        });\n    }\n}\n\nAssemblyScriptCompiler.prototype.initWorker = function() {\n    if(typeof this.worker != 'undefined' && this.worker != null) {\n        this.worker.terminate();\n    }\n\n    //different path for NodeJS\n    if(sweva.inBrowser) {\n        console.log(\"Load worker for webbrowser\");\n        this.worker = new Worker('/node_modules/sweva-core/app/core/compilers/assemblyScriptCompilerWorker.js');\n    } else {\n        console.log(\"Load worker for NodeJS\");\n        this.worker = new WorkerNodeJS('app/core/compilers/assemblyScriptCompilerWorker.js');\n    }\n}\n// MA\nAssemblyScriptCompiler.prototype.compile = async function (module) {\n\n    const self = this;\n    while (this.currentlyCompiling) {\n        new Promise(resolveWait => setTimeout(resolveWait, 1));\n    }\n    this.currentlyCompiling = true;\n\n    //load compiler\n    await this.setup();\n\n    let doneCompiling = false;\n    let offloading = false;\n    let intervalID;\n    let odList =sweva.ExecutionManager.getODList(); //todo: user input\n    console.log(\"odList in ASC compiler = \",odList);\n\n    let endCPU = 0;\n    let cpuMonitor=0;\n    // initial mem / battery check\n    offloading = await offloadingDecision(odList);\n    console.log('initial offloading decision = ',offloading);\n    if (offloading) {\n        // optimization: speed is key we do this after resolving promise\n        //clearInterval(intervalID);\n        //abort running compilation\n        return ('offloading');\n    }\n    let startCPU =performance.now();\n    return await Promise.race([\n        //monitoring the compilation process\n        new Promise( async (resolve) => {\n            console.log('Begin periodic monitoring execution...');\n            // interval check\n            intervalID = setInterval(async () => {\n                endCPU = performance.now();\n                cpuMonitor = ((endCPU - startCPU)/5000)*100;\n                //console.log('CPU TIME= ', cpuMonitor);\n                if (cpuMonitor > odList[0]) {\n                    console.log(\"offloadingOutput$ Monitoring = CPU limit exceeded\");\n                    resolve('offloading');\n                }\n                offloading = await offloadingDecision(odList);\n                console.log('periodic offloading decision = ', offloading);\n                if (offloading) {\n                    // optimization: speed is key we do this after resolving promise\n                    //clearInterval(intervalID);\n                    //abort running compilation\n                    resolve('offloading');\n                }\n            }, 500);\n        }),\n\n        // compiling the module\n        new Promise((resolve) => {\n\n            this.resolveCompile = resolve;\n            doneCompiling = true;\n            this.worker.postMessage({type: \"compile\", source: self.prepareSourceCode(module.source)});\n\n        })\n\n    ]).\n    then((wr) => {\n\n        let workerResult = wr;\n\n        clearInterval(intervalID); //clear monitoring interval if no offloading necessary\n        console.log('workerResult');\n        console.log(workerResult);\n        this.currentlyCompiling = false;\n\n        this.resolveCompile = null;\n\n        if (workerResult.type === \"compileResult\") {\n            console.log('offloadingOutput$ Offloading not needed. Proceed as normal');\n            return workerResult;\n        } else if (workerResult === 'offloading') {\n            //todo: offloading callback\n            this.initWorker();\n            console.log(\"offloadingOutput$ Offloading necessary. Callback triggered\");\n            return 'offloading'; //todo: is String a good DT for return ?\n        } else\n            throw new CompileError(workerResult.message, module.context);  // Compiler Error handling\n\n    });\n\n}\n\n\nAssemblyScriptCompiler.prototype.prepareSourceCode = function(source) {\n    let getters = this.generateGlobalGetters(source);\n    let sourceStr = source.join(\"\\n\");\n    return this.supportLibraryDeclares + sourceStr + getters;\n}\n\nAssemblyScriptCompiler.prototype.generateGlobalGetters = function(source) {\n    let getters = \"\";\n    for(let line in source) {\n        if(source.includes(this.internalGetterPrefix)) {\n            throw new CompileError(\"Do not use \"+this.internalGetterPrefix+\" for names in your source, as it is reserved for internal use.\", \"compileError\");\n        }\n        else if(source[line].indexOf(\"export var\") === 0) {\n            let tmp = source[line].split('=')[0].split(':');\n            let type = \"anyref\";\n            if(tmp.length >= 2)\n                type = tmp[1].split(/[\\s=]+/).filter(x => x !== \"\")[0];\n            else\n                throw new CompileError(\"Exported variables require an explicit type! \\n\\\"\"+source[line]+\"\\\" does not contain a type.\", \"compileError\");\n            tmp = tmp[0].split(/[\\s=]+/).filter(x => x !== \"\");\n            let name = tmp[tmp.length-1];\n            getters += \"export function \"+this.internalGetterPrefix+name+\"():\"+type+\" { return \"+name+\"; }\\n\";\n        }\n    }\n\n    return getters;\n}\n\nmodule.exports = AssemblyScriptCompiler;","'use strict';\n\n/**\n * The compiler loads the necessary resources for compilation of a language, compiles code and returns the resulting binary.\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\n * \n * The setup needs to be done only once, while the execution can be repeated on different data.\n * Additionally the setup should only be called, when the compiler is needed, because some dependencies for compiling can be very large\n * \n * This is a default implementation, returning the input source as the compiled code. It can be used for interpreted languages.\n *\n * @param {SupportLibrary} supportLibrary - source code to compile\n * @constructor\n */\nfunction Compiler(supportLibrary) {\n    /**\n     * Determines, if dependencies are loaded.\n     * @name Compiler#setupCompleted\n     * @type {boolean}\n     */\n    this.setupCompleted = false;\n\n    /**\n     * Documentation for functions in support library - should include specifics on language syntax\n     * Available after Compiler#setup() has been called.\n     * @name Compiler#setupCompleted\n     * @type {string}\n     */\n    this.supportLibraryDocumentation = \"\";\n}\n\n/**\n * Compile the provided source code\n * @param {module} source - source code to compile\n * @return {object} containing binaryData and optionally other properties of specific compilers\n */\nCompiler.prototype.compile = function (source) {\n    return source;\n}\n   \n/**\n * Loads dependencies\n */\nCompiler.prototype.setup = async function () {\n    if(!this.setupCompleted) {\n        this.setupCompleted = true;\n    }\n}\n\n\nmodule.exports = Compiler","'use strict';\n\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar Clone = require('../../../node_modules/clone/clone.js');\n\n/**\n * Composables process data. They can be linked into networks.\n * @abstract\n * @constructor\n */\nfunction Composable() {\n}\n/**\n * A definition of a JSON object.\n * @see {@link http://json-schema.org/documentation.html}\n * @typedef {Object} JSONSchema\n */\n\n/**\n * The initalization object with optional properties to initialize composables.\n * @typedef {Object} composableInitalizer\n * @property {string} [name=someComposable] - The name of the composable.\n * @property {string} [type=module] - The type of the composable: 'module' or 'composition'.\n * @property {JSONSchema} [dataInSchema=null] - The schema of the expected data object received from other composables.\n * @property {JSONSchema} [dataOutSchema=null] - The schema of the data object passed on to later composables.\n * @property {JSONSchema} [inputSchema=null] - The schema of the input object received at the beginning of exection.\n * @property {Array.<string>} [dataInNames=['data']] - The names of the expected properties of the received data object.\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\n * Multiple properties are needed, if you want to receive data from multiple other composables.\n *\n * @property {Array.<string>} [dataOutNames=['result']] - The names of the expected properties of the produced data object.\n * If there is only one element, the array is ignored and the whole data object is taken (no property names needed).\n * Multiple properties are needed, if you want to send data to multiple other composables.\n *\n * @property {Array.<string>} [inputNames=[]] - The names of the expected properties of the input object.\n * If there is only one element, the array is ignored and the whole input object is taken (no property names needed).\n */\n\n/** Initializes the object with a property object.\n  * Not defined Properties will get a default value.\n *  @protected\n *  @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n */\nComposable.prototype.initialize = function (initializationObject) {\n    this.initializeProperty(initializationObject, 'name', 'someComposable');\n    this.initializeProperty(initializationObject, 'type', 'module');\n    this.initializeProperty(initializationObject, 'dataInSchema', null);\n    this.initializeProperty(initializationObject, 'dataOutSchema', null);\n    this.initializeProperty(initializationObject, 'inputSchema', null);\n\n    this.initializeProperty(initializationObject, 'dataInNames', []);\n    this.initializeProperty(initializationObject, 'dataOutNames', []);\n    this.initializeProperty(initializationObject, 'inputNames', []);\n\n    /**\n     * Amount of expected properties for the received data object.\n     * @name Composable#dataIn\n     * @type {number}\n     */\n    this.dataIn = this.dataInNames.length;\n\n    /**\n    * Amount of expected properties for the produced data object.\n    * @name Composable#dataOut\n    * @type {number}\n    */\n    this.dataOut = this.dataOutNames.length;\n\n    /**\n    * Amount of expected properties for the received input object\n    * @name Composable#inputIn\n    * @type {number}\n    */\n    this.inputIn = this.inputNames.length;\n\n    /**\n    * The context of the composable used for error messages.\n    * @name Composable#context\n    * @type {number}\n    */\n    this.context = this.constructor.name + '[' + this.name + ']';\n}\n\n/**\n * Helper function to initialize internal variables. Sets also default values.\n * @protected\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\n * @param {string} defaultValue - A default value is set, if initializationObject does not contain such a property key.\n */\nComposable.prototype.initializeProperty = function (initializationObject,\n    property, defaultValue) {\n    if (initializationObject.hasOwnProperty(property)) {\n        var obj = initializationObject[property];\n        if (typeof obj === 'object') {\n            if (Array.isArray(obj)) {\n                if (obj.length == 0) {\n                    this[property] = defaultValue;\n                    return;\n                }\n            }\n            else if (Object.keys(obj).length == 0){\n                this[property] = defaultValue;\n                return;\n            }\n        }\n        this[property] = initializationObject[property];\n    } else {\n        this[property] = defaultValue;\n    }\n}\n\n/**\n * Helper function to initialize internal functions. Sets also default values.\n * @protected\n * @param {composableInitalizer} initializationObject - The object with optional properties for the composable.\n * @param {string} property - The property value to set. The name must be the same both for 'this' and initializationObject.\n * @param {number} expectedArgumentsCount - The amount of arguments the expected function needs to have. On mismatch an error is thrown.\n * @param {function} defaultValue - A default value is set, if initializationObject does not contain such a property key.\n */\nComposable.prototype.initializeFunction = function (initializationObject,\n    property, expectedArgumentsCount, defaultValue) {\n    if (initializationObject.hasOwnProperty(property)) {\n        //check if it is really a function\n        if (typeof initializationObject[property] === 'function') {\n            //the expected functions (which can be defined by the composable creators) have a fixed signature (arguments),\n            //so check here for validation.\n            if (initializationObject[property].length >= expectedArgumentsCount) {\n                this[property] = initializationObject[property];\n            }\n            else {\n                sweva.ErrorManager.error(\n                    new DefinitionError('function \"' + property + '\" requires at least ' +\n                    expectedArgumentsCount + ' arguments, but provides only ' +\n                    initializationObject[property].length,\n                    this.context, initializationObject[property]));\n            }\n        }\n        else if (initializationObject[property] == null) {\n            // for now ignore, as some functions are optional\n        }\n        else {\n            sweva.ErrorManager.error(\n                   new DefinitionError('\"' + property + '\" is reserved for functions, but not defined as one',\n                   this.context, initializationObject[property]));\n        }\n    }\n    else {\n        this[property] = defaultValue;\n    }\n}\n/**\n * Clones the current composable and overwrites/adds all the properties specified in an extender object.\n * This allows some sort of composable inheritance.\n * @this Composable\n * @param {Composable} extender - The partial composable from which to take the new values.\n * @returns {Composable} The cloned and extended composable object.\n */\nComposable.prototype.extendWith = function (extender) {\n    var cloned = Clone(this);\n    for (var key in extender) {\n        //we don't want to clone 'extends' as it is an indicator, that a composable wants to extend another. I.e. What we are doing here :)\n        if (extender.hasOwnProperty(key) && key != 'extends') {\n            cloned[key] = extender[key];\n        }\n    }\n    return cloned;\n}\n/**\n * Updates the context during the execution. It uses the parent's context and the alias, the parent has given this composable.\n * looks like: Composition[composition1].Module[module1]\n * @protected\n * @param {string} context - The context of the parent.\n * @param {string} alias - The alias (name) used in the parent for this composable.\n * @returns {string} Updated context.\n */\nComposable.prototype.getNewContext = function (context, alias) {\n    if (typeof context === 'string') {\n        //alias is optional, so check if it is defined\n        if (typeof alias !== 'string') {\n            alias = '';\n        }\n        else {\n            alias = ': ' + alias;\n        }\n        return context + '.' + this.constructor.name + '[' + this.name + alias + ']';\n    }\n    return this.context;\n}\n/**\n * Validates, if a given object has the expected structure (typecheck) compatible to this composable.\n * If available, it uses the provided JSON schema, otherwise (noch schmema available) it only checks, if the object has all required property keys. Defined by the *Names arrays (see {@link composableInitalizer}).\n * \n * @param {string} type - Type of object, needed to select the correct type definition. Use 'dataIn', 'dataOut' , 'input' respectively.\n * @param {Object} obj - Object, that should be validated.\n * @returns {boolean} - True, if the object is compatible to this composable regarding the given type.\n */\nComposable.prototype.validateTypes = function (type, obj) {\n    var typeNames = this[type + 'Names'];\n    var typeSchema = this[type + 'Schema'];\n    \n    //if properties are all present and a schema is provided, we can perform a more detailed check\n    if (typeSchema !== null) {\n        //use the validator library on the object\n        try {\n            var valid = sweva.Ajv.validate(typeSchema, obj);\n            if (!valid) {\n                sweva.ErrorManager.error(new ExecutionError('Object does not match the given ' + type + 'Schema: ' + sweva.Ajv.errorsText(sweva.Ajv.errors),\n                    this.context, obj));\n                return false;\n            }\n        } catch(err) {\n            /*\n            ignore, because an invalid schema like generated by AssemblyScript is generated from the source and\n            already matches the input/output data. Consider adding the custom types to the validator, if this is not the\n            case for future added languages.\n             */\n        }\n    }\n\n    return true;\n}\n/**\n * Function to start the data processing. Here only a dummy is defined.\n * @param {Object} data - Tha data object received.\n * @param {Object} input - The input object received.\n * @return {Promise<number>} - The processed data.\n */\nComposable.prototype.execute = function (data, input) {\n    return new Promise(function (resolve, reject) {\n        resolve(0);\n    });\n}\nmodule.exports = Composable;","'use strict';\n\nvar Composable = require('../../core/composables/composable.js');\nvar Module = require('../../core/composables/module.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\n\n/**\n * Represents how a composable is linked to another\n * @typedef {Object} linkType\n * @property {string} to - The alias/name of the target composable (i.e. under which key it is defined in the composables dictionary of the composition)\n * @property {string|Object.<string,string>} mapping - How dataOut and dataIn of two composables are mapped to each other.\n * If no mapping is specified, the whole dataOut object is taken as the dataIn object.\n * If a string is specified as a value, it is mapped to the appropriate dataIn property.\n * If a dictionary is specified, the key represents the dataOut property and thevalue the dataIn property it is mapped to.\n * All string values must be using the given values of the dataInNames and dataOutNames arrays defined in the composable.\n */\n\n/**\n * A user defineable function to map the input object of the composition to the input object of individual composables.\n * Basically the function is called for each composable and the return value is then used as its input object.\n * For example you can use an input object, where you specify in detail for every composable the value, then you could simply\n * return input[composableName];\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapInputFunction\n * @param {Object} input - The input object given to the composition.\n * @param {string} composableName - The name of the composable requesting an input object.\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\n * @param {Object} libs - A library object provides access to libs from within the function.\n * @returns {Object} A value to use for the requesting composable as the input object.\n */\n\n/**\n * A user defineable function to map the data object of the composition to the data object of individual composables.\n * Basically the function is called for each composable and the return value is then used as its data object.\n * For example you can use a data object, where you specify in detail for every composable the value, then you could simply\n * return data[composableName];\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapDataInFunction\n * @param {Object} data - The data object given to the composition.\n * @param {string} composableName - The name of the composable requesting a data object.\n * @param {Object.<string,string>} composables - A dictionary of the composables used by the composition.\n * @param {Object} libs - A library object provides access to libs from within the function.\n * @returns {Object} A value to use for the requesting composable as the data object.\n */\n\n/**\n * A user defineable function to transform the resulting data object of the data processing pipeline.\n * You could for example add additional properties or remove some, convert values etc.\n * \n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n * \n * @callback Composition~mapDataOutFunction\n * @param {Object} output - The data object produced by the composables without outgoing links (end of data processing).\n * @returns {Object} A value the composition returns as the dataprocessing result.\n */\n\n\n/**\n * The initalization object with optional properties to initialize composables.\n * @typedef {composableInitalizer} compositionInitalizer\n * @property {Object.<string,string>} [composables={}] - A dictionary of all composables used by the composition. \n * The key represents the internal alias, the value represents \n * the composable name, which is used to load the composable information.\n * \n * @property {Object.<string, Array.<linkType>>} [links={}] - A dictionary describing an edge list of how the composables are linked.\n * The key describes the origin composable, the value describes an array of target composables with mapping information of the data properties.\n * @property {Composition~mapInputFunction} [mapInput] - A function to map the input object of the composition to the input object of individual composables.\n * The default requires an input object, where each property corresponds to a composable alias/name and maps the value of the property to this composable input.\n * @property {Composition~mapDataInFunction} [mapDataIn] - A function to map the data object of the composition to the data object of individual composables.\n * The default requires a data object, where each property corresponds to a composable alias/name and maps the value of the property to this composable data.\n * @property {Composition~mapDataOutFunction} [mapDataOut] - A function to transform the resulting data object of the composition, before making it available.\n * The default does not change the output object.\n */\n\n/**\n * A composition can consist of multiple other compositions or composables.\n * It orchistrates the execution of the composables.\n * @constructor\n * @extends Composable\n * @param {compositionInitalizer} initializationObject - The object with optional properties for the composition.\n * \n */\nfunction Composition(initializationObject, manager) {\n    this.manager = manager;\n\n    this.initializeProperty(initializationObject, 'composables', {});\n    this.initializeProperty(initializationObject, 'links', {});\n\n    this.initializeFunction(initializationObject, 'mapInput', 4, function (input, composableName, composables, libs) {\n        if (input.hasOwnProperty(composableName)) {\n            return input[composableName];\n        }\n        return null;\n    });\n\n    this.initializeFunction(initializationObject, 'mapDataIn', 4, function (data, composableName, composables, libs) {\n        if (data.hasOwnProperty(composableName)) {\n            return data[composableName];\n        }\n        return null;\n    });\n\n    this.initializeFunction(initializationObject, 'mapDataOut', 2, function (output, libs) {\n        return output;\n    });\n    //call to the parent class initalization function\n    this.initialize(initializationObject);\n\n    /**\n    * Indicates, if the composition is ready to use. This is important, as required composables might need to be loaded first.\n    * @protected\n    * @name Composition#isReady\n    * @type {boolean}\n    */\n    this.isReady = false;\n}\n//inherit properties\nComposition.prototype = Object.create(Composable.prototype);\n\n/**\n * This function starts to recursively load composables required by this composition.\n * See {@link ComposableLoader} for more details on he loading process.\n * When finished all required composables are in memory and can be used.\n * As loading is async it returns a promise. \n * @returns {Promise<void>} An empty promise, signaling that everything was loaded.\n */\nComposition.prototype.loadComposables = function () {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        //collects an array of loading promises, which is then filled\n        var promises = [];\n        for (var key in self.composables) {\n            if (self.composables.hasOwnProperty(key)) {\n                //for each required composable the composable is loaded using the specified name of it\n                //the name itself acts as a part of a URL\n                //a reference to the composables dictionary of the composition is passed, so the\n                //string values (names) of the required compositions are later replaced with the comosition objects,\n                //which can then be used\n                if (typeof self.composables[key] === 'string') {\n                    promises.push(sweva.ComposableLoader.load(self.composables[key], self.composables, key));\n                }\n                else { //otherwise create from given object directly\n                    var type = self.composables[key].type;\n                    if(type=='module'){\n                        self.composables[key] = new Module(self.composables[key], self.manager);\n                    }\n                    else {\n                        self.composables[key] = new Composition(self.composables[key], self.manager);\n                    }\n                    \n                }\n                \n            }\n        }\n        //invoke all promises and wait for them to finish\n        Promise.all(promises).then(function () {\n            //when all promises are finished, all components are loaded, so the composition is ready to be used\n            self.isReady = true;\n\n            //important: as we are dealing here with async operations, one might try to execute the composition, before\n            //it is ready to be used. In this case the execution is delayed and indicated (wantsToExecute=true)\n            //now if the loading is finished, it can directly start the execution directly itself, using the provided callback\n            //no polling needed :)\n            if (self.wantsToExecute) {\n                self.wantsToExecute = false;\n                self.executeStarterCallback();\n            }\n            \n           \n            //ok all loaded, now we can analyze graph and check for compatibility\n            self.analyzeLinkGraph();\n           \n            //indicate to the outside, that we are done with everything and the composition can be used\n            resolve();\n        })\n        .catch(function (error) {\n            sweva.ErrorManager.error(\n                       new ExecutionError('Could not load all composables: ' + error,\n                       self.context, self.composables));\n            \n        });\n    });\n}\n/**\n * Checks, if all the data a composable requires is already available.\n * As composables are executed in a graph, some composables depend on the calculations of others and have to wait for the data.\n * \n * For this purpose, the {@link Composable#dataIn} property is used as a count, that has to be reached\n * by the amount of properties stored for this composable in {@links Composition#parameters}.\n * @protected\n * @param {string} composableName - The alias of the composable object, for which the check should be performed.\n * @returns {boolean} true, if all data required for the composable is available.\n */\nComposition.prototype.hasParameters = function (composableName) {\n    //how many parameters does the composable need?\n    \n    var parametersNeeded = [];\n    if(typeof this.composables[composableName].dataInConnected !== 'undefined') {\n        parametersNeeded = Object.keys(this.composables[composableName].dataInConnected);\n    }\n    \n    \n    //if it does not need any, we are good here\n    if (parametersNeeded.length === 0) {\n        return true;\n    }\n    \n    //if we are still here, it needs at least one\n    if (this.parameters.hasOwnProperty(composableName)) {\n       \n        \n        //not enough\n        for (var i = 0; i < parametersNeeded.length; i++) {\n            var parameter = parametersNeeded[i];\n            \n            if (typeof this.parameters[composableName][parameter] === 'undefined') {\n                return false;\n            }\n        }\n        return true;\n        \n    }\n    return false;\n}\n\n/**\n * Adds new data to the available pool other composables use.\n * This allows dependant composables to fetch the data and start execution.\n * It saves the data as a subkey of a subkey of {@links Composition#parameters}:\n * this.parameters[composable][property] = value\n * @protected\n * @param {string} composableName - The alias of the composable object for which the data is intended.\n * @param {string} property - The property name to save the data as, the value must correspond to a value defined\n * in {@links Composable#dataInNames} (we need correct mapping).\n * @param {Object|boolean|string|number} value - The value of the data to add.\n */\nComposition.prototype.addParameter = function (composableName, property, value) {\n    //if no key for composable present, create one\n    if (!this.parameters.hasOwnProperty(composableName)) {\n        this.parameters[composableName] = {};\n    }\n\n    this.parameters[composableName][property] = value;\n}\n\n/**\n * Resets the composition, so it can be executed again.\n * @protected\n */\nComposition.prototype.reset = function () {\n    this.parameters = {};    \n    this.output = {};\n    this.unlcearedComposables = [];\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            this.unlcearedComposables.push({\n                composable: key,\n                cleared: false\n            });\n        }\n    }\n    \n}\n\n/**\n * Checks, if the composable graph of the composition contains cycles (end therefore is not a DAG).\n * @protected\n * @param {Array.<string>} startingNodeArray - An array with the aliases of all composables, that do not have an incoming edge/link.\n * They are considered as the first nodes, that get executed.\n * @returns {boolean} True, if the graph contains cycles.\n */\nComposition.prototype.hasCycles = function (startingNodeArray) {\n    var nodes = {};\n    var edges = {};\n\n    //first create a copy of the composables in the composition (nodes)\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            nodes[key] = {}\n        }\n    }\n    //create a copy of the links without mapping information (edges)\n    for (var fromNode in this.links) {\n        if (this.links.hasOwnProperty(fromNode)) {\n            edges[fromNode] = [];\n\n            for (var fromEndpoint in this.links[fromNode]) {\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\n                    \n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\n\n                            edges[fromNode].push(toNode);\n\n                        }\n                    }\n\n                }\n            }\n            /*for (var i = 0; i < this.links[key].length; i++) {\n                edges[key].push(this.links[key][i].to);\n            }*/\n        }\n    }\n\n    \n    //Kahn's algorithm\n    //https://en.wikipedia.org/wiki/Topological_sorting\n    var L = [];\n    var S = startingNodeArray.slice();\n    var uniqueL = true;\n    while (S.length > 0) {\n        var n = S.pop();\n\n        //sorting only works, if all elements are unique!\n        if (L.indexOf(n) >= 0) {\n            uniqueL = false;\n            break;\n        }\n        L.push(n);\n        if (edges.hasOwnProperty(n)) {\n            for (var i = 0; i < edges[n].length; i++) {\n                var m = edges[n][i];\n                edges[n].splice(i, 1);\n\n                i--;\n\n                var hasIncoming = false;\n                for (var key in edges) {\n                    if (edges.hasOwnProperty(key)) {\n                        for (var k = 0; k < edges[key].length; k++) {\n                            if (edges[key][k] === m) {\n                                hasIncoming = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (hasIncoming) {\n                        break;\n                    }\n                }\n                if (!hasIncoming) {\n                    S.push(m);\n                }\n                if (edges[n].length === 0) {\n                    delete edges[n];\n                    break;\n                }\n            }\n        }\n    }\n\n    //if edges exist, or L has non unique elements: there is a cycle\n    if (Object.keys(edges).length > 0 || !uniqueL) {\n        return true;\n    }\n    return false;\n}\n/**\n * Checks, if the schemas of two objects are compatible.\n * Two objects are compatible, if one of them has no schema definition, or if the first schema is identical to the second one in a recursive comparison.\n * @protected\n * @param {string} obj1Name - The name of the first object (from). Only used for error output.\n * @param {string} obj2Name - The name of the second object (to). Only used for error output.\n * @param {JSONSchema} obj1Schema - The schema ofthe first object.\n * @param {JSONSchema} obj2Schema - The schema ofthe second object.\n * @param {string} [mappingFrom] - The relevant property name of the first object (source/from).\n * @param {string} [mappingTo] - The relevant property name of the second object (target/to).\n * @returns {boolean} True, if the object with obj1Schema can be used, where obj2Schema is required. \n */\nComposition.prototype.checkSchemaCompatibility = function (obj1Name, obj2Name, obj1Schema, obj2Schema, mappingFrom, mappingTo) {\n    //schemas are optional (null), so give the benefit of the doubt\n    if (obj1Schema == null || obj2Schema == null) { \n        return true;\n    }\n    //use to store error messages\n    var error = null;\n\n    //function for recursion, deals with the meta information level (type, properties, required, etc) of the JSONSchema\n    //level indicates the poperty chain and is used for error messages\n    function metaLevel(level, from, to) {\n        //iterate over the target keys (obj2Schema)\n        for (var key in to) {\n            //the source (obj1Schema) must have all keys the target has\n            if (key !== 'items' && key !== 'required' && !from.hasOwnProperty(key)) {\n                error = {\n                    level: level,\n                    message: 'missing property \"' + key + '\"'\n                }\n                return false;\n            }\n            //if we are dealing with an array, proceed to the meta-level\n            if (key === 'items' && from.hasOwnProperty(key)) {\n                if (!metaLevel(level + '.' + key, from[key], to[key])) {\n                    return false;\n                }\n            }\n            //if properties are defined, proceed with the recursion using the propertyLevel\n            else if (key === 'properties' && from.hasOwnProperty(key)) {\n                if (!propertyLevel(level + '.' + key, from[key], to[key])) {\n                    return false;\n                }\n            }\n            //if we get to the required array...\n            else if (key === 'required' && from.hasOwnProperty(key)) {\n                //special: required array order should be ignored\n                from[key].sort();\n                to[key].sort();\n\n                //first check if the length is the same\n                if (from[key].length !== to[key].length) {\n                    error = {\n                        level: level,\n                        message: 'array length different for \"' + key + '\" ' + from[key].toString() + ' != ' + to[key].toString()\n                    }\n                    return false;\n                }\n                //otherwise we need to compare each element\n                for (var i = 0; i < from[key].length; i++) {\n                    if (from[key][i] !== to[key][i]) {\n                        error = {\n                            level: level,\n                            message: 'array element difference for \"' + key + '\" ( ' + from[key][i] + ' != ' + to[key][i]\n                                + ' ) ' + from[key].toString() + ' != ' + to[key].toString()\n                        }\n\n                        return false;\n                    }\n                }\n            }\n            //if we get something else, we compare the values\n            //this should be all primitive types, but I'm not sure if I didn't miss any possible non-primitive\n            //in the above if-else\n            else if (from.hasOwnProperty(key)){\n                if (from[key] !== to[key]) {\n                    error = {\n                        level: level,\n                        message: 'inequal property value \"' + key + '\" ( ' + from[key] + ' != ' + to[key] + ' )'\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    //function for recursion, dealing with the enumeration of property keys of a schema\n    function propertyLevel(level, from, to) {\n        for (var key in to) {\n            //from must have at least all keys to has\n            if (!from.hasOwnProperty(key)) {\n                error = {\n                    level: level,\n                    message: 'missing property \"' + key + '\"'\n                }\n                return false;\n            }\n            //continue, by checking the meta-level of each property\n            if (!metaLevel(level + '.' + key, from[key], to[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var result = true;\n    //helper function, that helps to narrow the scope, if a mappingTo/mappingFrom is given\n    //it basically traverses the schema to the desired mapping property and returns it as the new schema\n    function scopeOnMapping(schema, mapping) {\n        var hasSchema = true;\n\n        if (schema.hasOwnProperty('properties')) {\n            if (schema.properties.hasOwnProperty(mapping)) {\n                return schema.properties[mapping];\n            }\n            else {\n                return null;\n            }\n        }\n\n        return schema;\n    }\n\n    //copy the original schemas for error output (we might modify our reference later to narrow the scope, but \n    //we still want to show the full schema for the error message\n    var OriginalObj1Schema = obj1Schema; \n    var OriginalObj2Schema = obj2Schema;\n\n    //mappings are optional, so scheck if they are defined and narrow the scopes\n    if (typeof mappingTo === 'string') {\n        var temp = scopeOnMapping(obj2Schema, mappingTo);\n        if (temp) {\n            obj2Schema = temp;\n        }\n        else {\n            error = {\n                level: '',\n                message: 'Composable \"' + obj2Name + '\" has no schema for property \"' + mappingTo + '\" provided by composable \"' + obj1Name + '\"'\n            }\n        }\n    }\n\n    if (typeof mappingFrom === 'string') {\n        var temp = scopeOnMapping(obj1Schema, mappingFrom);\n        if (temp) {\n            obj1Schema = temp;\n        }\n        else {\n            error = {\n                level: '',\n                message: 'Composable \"' + obj1Name + '\" has no schema for property \"' + mappingFrom + '\" required by composable \"' + obj2Name + '\"'\n            }\n        }\n    }\n\n    //if we didn't have an error yet, we can start the recursion\n    \n    if (!error) {\n        result = metaLevel('', obj1Schema, obj2Schema);\n    }\n\n    //output an error message\n    if (error) {\n        var relevantMapping = '';\n        if (typeof mappingFrom === 'string' && typeof mappingTo === 'string') {\n            relevantMapping = ' for the mapping \"' + mappingFrom + '\" -> \"' + mappingTo + '\"';\n        } else if (typeof mappingTo === 'string') {\n            relevantMapping = ' for the mapping \"' + mappingTo + '\"';\n        }\n\n        var faultyObject = {};\n        faultyObject[obj1Name] = OriginalObj1Schema;\n        faultyObject[obj2Name] = OriginalObj2Schema;\n        \n\n        sweva.ErrorManager.error(\n                      new DefinitionError('Schemas of \"' + obj1Name + '\" and \"' + obj2Name + '\" incompatible' + relevantMapping + ': '\n            + error.level + ': ' + error.message,\n                      this.context, faultyObject));\n    }\n    return result;\n}\n/**\n * Statically analyzes the graph before execution.\n * Checks for compatability of composables, absence of cycles in the linkage definition etc.\n * @protected\n */\nComposition.prototype.analyzeLinkGraph = function () {\n    /**\n     * False, if no errors in the link graph definition were detected.\n     * @protected\n     * @name Composition#invalidLinkGraph\n     * @type {boolean}\n     */\n    this.invalidLinkGraph = false;\n    /**\n     * Array of all the aliases of the composables, that have no ingoing link, i.e. the 'start'\n     * @protected\n     * @name Composition#startingComposables\n     * @type {Array.<string>}\n     */\n    this.startingComposables = Object.keys(this.composables);\n    /**\n    * Dictionary of all the aliases of the composables, that have no outgoing link, i.e. the 'end'\n    * Dictionary, because there will be some lookups of the key values later on.\n    * @protected\n    * @name Composition#startingComposables\n    * @type {Object.<string,string>}\n    */\n    this.endingComposables = {};\n    for (var key in this.composables) {\n        if (this.composables.hasOwnProperty(key)) {\n            this.endingComposables[key] = true;\n        }\n    }\n\n    //find startingComposables that have no ingoing edges\n    //find endingComposables that have no outgoing edges\n   \n\n    for (var fromNode in this.links) {\n        if (this.links.hasOwnProperty(fromNode)) {\n           \n\n            for (var fromEndpoint in this.links[fromNode]) {\n                if (this.links[fromNode].hasOwnProperty(fromEndpoint)) {\n\n                    for (var toNode in this.links[fromNode][fromEndpoint]) {\n                        if (this.links[fromNode][fromEndpoint].hasOwnProperty(toNode)) {\n                            var toEndpoint = this.links[fromNode][fromEndpoint][toNode];\n                            //check if linking to existing composable!\n                            if (!this.composables.hasOwnProperty(toNode)) {\n                                sweva.ErrorManager.error(\n                                  new DefinitionError('Composable \"' + fromNode + '\" links to undefined composable \"' + toNode + '\"!',\n                                  this.context, Object.keys(this.composables)));\n                                this.invalidLinkGraph = true;\n                            }\n                            else {    \n                                //composable has no such dataOut, it tries to map to another composable\n                                if (this.composables[fromNode].dataOutNames.indexOf(fromEndpoint) < 0) {\n                                    sweva.ErrorManager.error(\n                                         new DefinitionError('Composable \"' + fromNode + '\" maps undefined dataOut \"' + fromEndpoint + '\" to composable \"' + toNode + '\"!',\n                                         this.context, this.composables[fromNode].dataOutNames));\n                                    this.invalidLinkGraph = true;\n                                    break;\n                                }\n\n                                //composable has no such dataIn\n                                if (this.composables[toNode].dataInNames.indexOf(toEndpoint) < 0) {\n                                    sweva.ErrorManager.error(\n                                         new DefinitionError('Composable \"' + fromNode + '\" links to undefined dataIn \"' + toEndpoint + '\" of composable \"' + toNode + '\"!',\n                                         this.context, this.composables[toNode].dataInNames));\n                                    this.invalidLinkGraph = true;\n                                    break;\n                                }\n                                //additionally check for schema compatibility (optional)\n                                if (this.composables[fromNode].dataOutSchema && this.composables[toNode].dataInSchema != null) {//schemas are optional, so only check if available\n                                    var compatibleSchemas = this.checkSchemaCompatibility(fromNode, toNode, this.composables[fromNode].dataOutSchema, this.composables[toNode].dataInSchema,fromEndpoint, toEndpoint);\n                                    if (!compatibleSchemas) {\n                                        this.invalidLinkGraph = true;\n                                        break;\n                                    }\n                                }\n                                if (typeof this.composables[toNode].dataInConnected === 'undefined') {\n                                    this.composables[toNode].dataInConnected = {};\n                                }\n                                this.composables[toNode].dataInConnected[toEndpoint] = true;\n\n                            }\n                            //if one composable A points to composable B, then B cannot be startingComposable\n                            var propIndex = this.startingComposables.indexOf(toNode);\n                            if (propIndex >= 0) {\n                                this.startingComposables.splice(propIndex, 1);\n                            }\n                            //if one composable A points to composable B, then A cannot be endingComposable\n                            \n                            if (this.endingComposables.hasOwnProperty(fromNode)) {\n                                delete this.endingComposables[fromNode]\n                            }\n\n                        }\n                    }\n                }\n            }           \n        }\n    }\n\n\n    \n\n    //check for cycles\n    var hasCycles = this.hasCycles(this.startingComposables);\n    if (hasCycles) {\n        sweva.ErrorManager.error(\n                       new DefinitionError('There are cycles in the linkage of composables!',\n                       this.context, this.links));\n        this.invalidLinkGraph = true;\n    }\n\n    //extract implicit information\n    this.dataIn = this.startingComposables.length;\n    this.dataOut = Object.keys(this.endingComposables).length;\n\n    this.dataInNames = [];\n    this.dataOutNames = [];\n\n    for (var i = 0; i < this.startingComposables.length; i++) {\n       \n        if (this.composables[this.startingComposables[i]].dataInNames.length>0) {\n            this.dataInNames.push(this.startingComposables[i]);\n        }        \n    }\n    for (var key in this.endingComposables) {\n        if (this.endingComposables.hasOwnProperty(key)) {\n            this.dataOutNames.push(key);\n        }\n    }\n    \n}\n/**\n * Recursive function that executes all composables, as soon as they can be executed (have all required data available)\n * @param {string} context - Information about the execution context, see {@link Composable#context}\n * @protected\n */\nComposition.prototype.composableQueueExecution = function (context) {\n    \n    //keep an array of all composables\n    //executed composables get marked\n    /*\n    console.log(\"CQE : context =\");\n    console.log(context);\n    console.log(\"CQE : this =\");\n    console.log(this);\n    console.log(\"CQE : unclearedComposables =\");\n    console.log(this.unlcearedComposables);\n    */\n\n    for (var i = 0; i < this.unlcearedComposables.length; i++) {\n\n        //skip already executed composables\n        if (this.unlcearedComposables[i].cleared) {\n            continue;\n        }\n        \n        var composableName = this.unlcearedComposables[i].composable;\n\n        \n       \n        var data = null;\n        var input = null;\n        \n        //check if composable has all data it depends on available\n        \n        if (this.hasParameters(composableName)) {\n            \n            //fill data and input for next composable call\n            data = this.parameters[composableName];\n           \n            input = this.mapInput(this.input, composableName, this.composables, sweva.libs);\n          \n        }\n        else {\n            continue;\n        }\n\n        //not continued = composableName can be executed (has data vailable)\n        var self = this;\n        //closure function, to get the current composable for each function\n        var func = function (composableName) {\n            return function (output) {\n                //check if composable does not provide data to other composables (end of execution chain)\n                if (self.endingComposables.hasOwnProperty(composableName)) {\n                    \n                    var allCleared = true;\n                    //if we have only one output composable, we do not need a named property,\n                    //otherwise create a property using the ending-composable alias\n                    if (Object.keys(self.endingComposables).length > 1) {\n                        self.output[composableName] = output;\n                    }\n                    else {\n                        self.output = output;\n                    }\n\n                    //check if this was the last composable (all have been executed)\n                    for (var k = 0; k < self.unlcearedComposables.length; k++) {\n                        if (!self.unlcearedComposables[k].cleared) {\n                            allCleared = false;\n                        }\n                    }\n                    //if this was the last endingComposable, finish\n                    if (allCleared) {\n                        self.executeFinishedCallback();\n                    }                    \n                }\n                //if composable provides data to other composables \n                else {\n                    if (self.links[composableName]) {\n\n                        for (var fromEndpoint in self.links[composableName]) {\n                            if (self.links[composableName].hasOwnProperty(fromEndpoint)) {\n\n                                for (var toNode in self.links[composableName][fromEndpoint]) {\n                                    if (self.links[composableName][fromEndpoint].hasOwnProperty(toNode)) {\n                                        var toEndpoint = self.links[composableName][fromEndpoint][toNode];\n                                            self.addParameter(toNode, toEndpoint, output[fromEndpoint]);                                            \n                                    }\n                                }\n                            }\n                        }                            \n                    }\n                }\n                //recursive execution of the next composables, as this one just finished and probably resolved some data dependencies\n                //console.log(self.parameters)\n\n                self.manager.addReexecutionListener(function(result) {\n                    self.needsReloadingVisualization = true;\n                    self.progress = result.mqtt_sweva_parameters.data.progress;\n                    self.context = result.mqtt_sweva_parameters.context;\n                    self.parameters = result.mqtt_sweva_parameters.data.parameters;\n                    self.output = result.mqtt_sweva_parameters.data.output;\n                    self.mqtt_client = result.mqtt_sweva_parameters.data.client;\n                    // if(result.lastReturnedData){\n                    //     for (var key in self.composables) {\n                    //       if(self.composables[key].name == result.name){\n                    //           var output =  self.composables[key].dataOutNames[0];\n                    //           for (var i in self.composables[key].dataInNames){\n                    //             self.parameters[key][self.composables[key].dataInNames[i]] = result.lastReturnedData[output];\n                    //           }\n                    //       }\n                    //     }\n                    // }\n                    self.unlcearedComposables = JSON.parse(JSON.stringify(result.mqtt_sweva_parameters.data.unclearedComposablesClone));\n                    self.composableQueueExecution.apply(self, [self.context]);\n                    console.log('recomputing demo result');\n                }, self.mqtt_module_name);\n                self.composableQueueExecution.apply(self, [context]);\n\n\n            }\n\n        };\n        //mark composable as cleared\n        if (!this.unlcearedComposables[i].cleared) {\n\n            //Retrieve Data needed for the ASYNC calls of the MQTT nodes\n            //Check if the current node about to be cleared is an MQTT node\n          var mqtt_sweva_parameters = false;\n          if (typeof this.composables[this.unlcearedComposables[i].composable].subscribe === 'function'){\n            self.mqtt_module_name = this.composables[this.unlcearedComposables[i].composable].name;\n            mqtt_sweva_parameters = {\n              module_name: this.composables[this.unlcearedComposables[i].composable].name,\n              context: context,\n              data: {\n                parameters: this.parameters,\n                output: this.output,\n                unclearedComposablesClone: JSON.parse(JSON.stringify(this.unlcearedComposables)),\n                process: this.progress,\n                client: this.mqtt_client\n              }\n            };\n          } else {\n            self.mqtt_module_name = false;\n          }\n\n\n            this.unlcearedComposables[i].cleared = true;\n           \n            //execute composable\n            this.composables[composableName].execute(data, input, context, composableName, mqtt_sweva_parameters, this.progress)\n                .then(\n                    //a => console.log(a))\n                    func(composableName))\n                .catch(function (error) {\n                    //error is logged earlier, but how to handle?\n                });\n        }\n\n       \n    }\n}\n/**\n * Starts execution of the composable, initializes required data. Use this function if you want to execute a composable!\n * @param {Object} data - The data relevant to the processing.\n * @param {Object} input - Input information on how to process the data.\n * @param {string} context - Execution context. See {@link Composable#context}.\n * @param {string} [alias] - Name, under which the composable is known to its parent.\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\n */\nComposition.prototype.execute = function (data, input, context, alias, progress) {\n    \n    var self = this;\n    this.data = data;\n    this.input = input;\n    context = this.getNewContext(context, alias);\n    this.reset();\n    \n    this.progress = progress;\n    \n    //return a promise, since execution is async\n    return new Promise(function (resolve, reject) {\n        //do not bother executing, if link graph definition is invalid, or the provided data or input object do not match the provided schema definitions\n        if (!self.invalidLinkGraph && self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\n            //each starting composable has an own data part\n            //use user-definable {@link Composition~mapDataInFunction} to map the data to the starting composables\n            for (var i = 0; i < self.startingComposables.length; i++) {\n                var composableName = self.startingComposables[i];               \n                self.parameters[composableName] = self.mapDataIn(self.data, composableName, self.composables, sweva.libs);\n            }\n            \n            //define callback for when execution is finished\n            self.executeFinishedCallback = function (error) {\n                if (error) {\n                    sweva.ErrorManager.error(\n                       new ExecutionError('Something unexpected happened: ' + error,\n                       context, error));\n                    reject(sweva.ErrorManager.getLastError());\n                }\n                //if there is no error\n                else {\n                    //use user-definable {@link Composition~mapDataOutFunction} to create the final output object\n                    var result = self.mapDataOut(self.output, sweva.libs);\n                    //validate output using provided schema\n                    if (self.validateTypes('dataOut', result)) {\n                        if(self.needsReloadingVisualization === true) {\n                            self.manager.sendDataToVisualization(result);\n                        }\n                        resolve(result);\n                    }\n                    else {\n                        reject(sweva.ErrorManager.getLastError());\n                    }\n                }\n            }\n            //all composables are loaded, so execution can start directly\n            if (self.isReady) {\n                self.composableQueueExecution.apply(self, [context]);\n            }\n                //delay execution to {@link Composition#loadComposables}\n            else {\n                //we want to execute, but cannot: tell so the initialization/loading part\n                self.wantsToExecute = true;\n                //execute via callback, as soon as loading finished\n                self.executeStarterCallback = function () { \n                    self.composableQueueExecution.apply(self, [context]);\n                }\n            }\n        }\n        else {\n            reject(sweva.ErrorManager.getLastError());\n        }\n    });\n}\n\nmodule.exports = Composition;","'use strict';\n\nvar Composable = require('../../core/composables/composable.js');\n//var Composition = require('../../core/composables/composition.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\n\n/**\n * A user defineable function to create a HTTP request as a promise. It is used to call a remote service using its API.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestFunction\n * @param {Object} data - The data object given to the module.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n/**\n * A user defineable function to handle errors from failed service calls.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestErrorFunction\n * @param {Object} response - The response object from the service call.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n\n/**\n * A user defineable function to transform the response of the service.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~requestErrorFunction\n * @param {Object} response - The response object from the service call.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n/**\n * A user defineable function to do all computation locally, no service is called.\n *\n * Attention! The user definable functions use a limited subset ob JavaScript. You cannot use dangereous operations, like accessing this, eval, etc.\n * Moreover, the [] accessor is forbidden, as it cannot be filtered before execution!\n * A replacement function is accessible from inside the function under libs.get, which takes the object and desired property key as a string and\n * acts as [].\n * See {@link SwevaScript} for more details.\n *\n * @callback Module~computeFunction\n * @param {Object} data - The data object given to the module.\n * @param {Object} input - The input object given to the module.\n * @param {Object} libs - An object allowing access to libraries inside the function.\n */\n\n\n/**\n * The initalization object with optional properties to initialize modules.\n * @typedef {composableInitalizer} moduleInitalizer\n * @property {Module~requestFunction} [request] - Creates a HTTP request to call the appropriate service.\n * @property {Module~requestErrorFunction} [request] - If this function is provided, it is used to handle errors, if the service call was unsuccessful.\n * @property {Module~responseFunction} [request] - Function to transform the the service response to be used later on.\n * @property {Module~computeFunction} [request] - If provided, no service is called, but all computation is performed locally in this function.\n *\n */\n\n/**\n * A module is the smallest unit of execution.\n * It serves as an envelope to a service call and can optionally do all computations locally wihtout a remote service.\n * @constructor\n * @extends Composable\n * @param {moduleInitalizer} initializationObject - The object with optional properties for the composition.\n *\n */\nfunction Module(initializationObject, manager) {\n    this.manager = manager;\n\n    this.initialize(initializationObject);\n\n    // general node type\n\n    this.initializeFunction(initializationObject, 'run', 3, null);\n    this.initializeProperty(initializationObject, 'language', 'typescript');\n\n    this.initializeProperty(initializationObject, 'source', null);\n    this.initializeProperty(initializationObject, 'binary', null);\n    this.initializeProperty(initializationObject, 'binaryHash', null);\n\n    /*this.initializeFunction(initializationObject, 'requestError', 3, null);\n\n    this.initializeFunction(initializationObject, 'response', 3,\n      function (response, input, libs) {\n        var obj = {};\n        obj[this.dataOutNames[0]] = response.data;\n        return obj;\n      });*/\n\n    // now the asynchronous node type\n\n    this.initializeFunction(initializationObject, 'subscribe', 3, null);\n    this.initializeFunction(initializationObject, 'onConnect', 3, null);\n    this.initializeFunction(initializationObject, 'onSubscription', 3, null);\n    this.initializeFunction(initializationObject, 'onMessageReceived', 4, null);\n}\n\n//inherit properties\nModule.prototype = Object.create(Composable.prototype);\nModule.prototype.constructor = Module;\n\nModule.prototype.lastReturnedData = null;\n\n/**\n * Calls the service using the created HTTP request received from {@link Module~requestFunction}.\n *\n * @protected\n * @param {Promise} request - The async service call.\n * @param {Object} input - The data input object given to the module.\n * @returns {Promise} - A promise with the response object.\n */\nModule.prototype.callService = function (request, input) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        request\n            .then(function (response) {\n                resolve(self.response(response, input, sweva.libs));\n            })\n            .catch(function (response) {\n                //if we have a function to deal with errors from service directly...\n                if (typeof self.requestError === 'function') {\n                    resolve(self.requestError(response, input, sweva.libs));\n                } else {\n                    reject(response);\n                }\n            });\n    });\n};\n\n/**\n * This one subscribes to a topic on a message queue.\n *\n * @param subscribe\n * @param input\n */\nModule.prototype.callSubscription = function (subscribe, data, mqtt_sweva_parameters, input) {\n    var self = this;\n\n    return new Promise(function (resolve, reject) {\n        if (subscribe !== false) {\n            var client = subscribe;\n            mqtt_sweva_parameters.data.client = client;\n            client.on('connect', function () {\n                self.onConnect(client, input, sweva.libs);\n            });\n            if (self.lastReturnedData === null) {\n                self.lastReturnedData = data;\n            }\n            client.on('message', function (topic, message) {\n                if (mqtt_sweva_parameters != false) {\n                    self.mqtt_sweva_parameters = mqtt_sweva_parameters;\n                } else {\n                    reject(error);\n                }\n                self.lastReturnedData = self.onMessageReceived(self.lastReturnedData, topic, message, sweva.libs);\n                // now notify the execution manager\n                self.manager.onModuleUpdate(self);\n            });\n        }\n\n\n        resolve(self.onSubscription(data, input, sweva.libs)).catch(function (error) {\n            // if we have a function to deal with errors from service directly...\n            if (typeof self.requestError === 'function') {\n                resolve(self.requestError(response, input, sweva.libs));\n            } else {\n                reject(error);\n            }\n        });\n    });\n};\n\n/**\n * Executes the module, i.e. performs the computation either by calling a service or locally.\n * @param {Object} data - The data relevant to the processing.\n * @param {Object} input - Input information on how to process the data.\n * @param {string} context - Execution context. See {@link Composable#context}.\n * @param {string} [alias] - Name, under which the composable is known to its parent.\n * @param {function} [progress] - Callback for progress tracking, gets called every time a module finishes execution.\n */\nModule.prototype.execute = function (data, input, context, alias, mqtt_sweva_parameters, progress) {\n    var self = this;\n    console.log(\"context ===\");\n    console.log(context);\n    console.log(\"Module to be executed =\");\n    console.log(self);\n    context = this.getNewContext(context, alias);\n\n    if (input == null) {\n        input = {};\n    }\n\n\n    // Promise to abort if offloading is necessary\n    return new Promise(function (resolve, reject) {\n        //begin promise\n        //only execute, if data and input objects are valid according to the optional schamas\n        if (self.validateTypes('dataIn', data) && self.validateTypes('input', input)) {\n\n            console.log(\"Input data for \" + alias + \": \");\n            console.log(data);\n\n            if (self.source != null) { //TODO: typeof self.run === 'function')\n                // if a computation function is defined, then skip service calls and compute locally\n                console.log(\"EXECUTE \" + self.name + \"[\" + alias + \"] USING: \" + sweva.runners[self.language].name);\n                //const result = await sweva.runners[self.language].exec(self, data, input, {signal});\n\n                //=== OFFLOADING === MODULE EXECUTION BEGINS HERE\n                sweva.runners[self.language].exec(self, data, input).then((result) => {\n\n                    console.log(\"Result data for \" + alias + \": \");\n                    console.log(result);\n\n                    if (result ==='offloading'){\n                     resolve('offloading') //todo: resolve or reject here ?\n                    }\n                    //TODO: MAP correctly\n                    //var result = self.run(data, input, sweva.libs);\n                    if (self.validateTypes('dataOut', result)) {\n                        //report progress, if callback is defined\n                        if (typeof progress !== 'undefined') {\n                            progress(alias, self.name, context,result);\n                        }\n                        // resolve module execution promise\n                        resolve(result);\n                    } else {\n                        // offloading callback here\n                        reject(sweva.ErrorManager.getLastError());\n                    }\n                });\n            }\n\n        } else if (typeof self.subscribe === 'function') {\n            // this is subscribing to an asynchronous message queue\n            var client;\n            if (typeof mqtt_sweva_parameters.data.client === 'undefined') {\n                client = self.subscribe(data, input, sweva.libs);\n            } else {\n                client = false;\n            }\n            self.callSubscription(client, data, mqtt_sweva_parameters, input).then(function (output) {\n                //validate output\n                if (self.validateTypes('dataOut', output)) {\n                    //report progress, if callback is defined\n                    if (typeof progress !== 'undefined') {\n\n                        progress(alias, self.name, context);\n                    }\n\n                    self.lastReturnedData = output;\n                    resolve(output);\n                } else {\n                    reject(sweva.ErrorManager.getLastError());\n                }\n            }).catch(function (error) {\n                sweva.ErrorManager.error(\n                    new ExecutionError('Something unexpected happened: ' + error,\n                        context, error));\n                reject(sweva.ErrorManager.getLastError());\n            });\n        } else if (typeof self.request === 'function') {\n            // this is an HTTP request node, call service using an HTTP request\n\n            self.callService(self.request(data, input, sweva.libs), input).then(function (output) {\n                // the output is already the HTTP response\n\n                //validate output\n                if (self.validateTypes('dataOut', output)) {\n                    //report progress, if callback is defined\n                    if (typeof progress !== 'undefined') {\n\n                        progress(alias, self.name, context);\n                    }\n\n                    resolve(output);\n                } else {\n                    reject(sweva.ErrorManager.getLastError());\n                }\n            }).catch(function (error) {\n                sweva.ErrorManager.error(\n                    new ExecutionError('Something unexpected happened: ' + error,\n                        context, error));\n                reject(sweva.ErrorManager.getLastError());\n            });\n\n        } else {\n            reject(sweva.ErrorManager.getLastError());\n        }\n\n    });\n}\n\nmodule.exports = Module;","//global object initialization\nvar globalObject;\n\nvar inBrowser = false;\n\ntry {\n    if (window) {\n        globalObject = window;\n        inBrowser = true;\n    }\n}\ncatch (e) {\n    globalObject = global;\n}\n\n//prevent loading everything twice on editor-page\nif(!globalObject.sweva) {\n    globalObject.sweva = {};\n\n    globalObject.sweva.inBrowser = inBrowser;\n\n    globalObject.sweva.asyncmqtt = require('../../node_modules/async-mqtt');\n\n    var Ajv = require('../../node_modules/ajv/lib/ajv.js');\n    globalObject.sweva.Ajv = new Ajv();\n\n    var ComposableLoader = require('../../app/core/execution/composableLoader.js');\n    globalObject.sweva.ComposableLoader = new ComposableLoader('');\n\n    globalObject.sweva.ExecutionManager = require('../../app/core/execution/executionManager.js');\n\n    var ErrorManager = require('../../app/core/errors/errorManager.js');\n    globalObject.sweva.ErrorManager = new ErrorManager();\n\n    var SwevaScript = require('../../app/core/swevaScript/swevaScript.js');\n    globalObject.sweva.SwevaScript = new SwevaScript();\n\n    var AssemblyScriptRunner = require('../../app/core/runners/assemblyScriptRunner.js');\n\n    /*\n    globalObject.sweva.axios = require('../../node_modules/axios/dist/axios.min.js');\n    globalObject.sweva.libs = {\n        axios: globalObject.sweva.axios,\n        mqtt: globalObject.sweva.asyncmqtt,\n        get: globalObject.sweva.SwevaScript.get,\n        set: globalObject.sweva.SwevaScript.set,\n        //mqttclient: globalObject.sweva.SwevaScript.client,\n        //mqttsubscribe: globalObject.sweva.SwevaScript.subscribe,\n        adddata: globalObject.sweva.SwevaScript.adddata\n    }*/\n\n    globalObject.sweva.runners = {};\n\n    var typescript = new AssemblyScriptRunner();\n    globalObject.sweva.runners[typescript.id] = typescript;\n}\n\nmodule.exports = globalObject.sweva;","'use strict';\n\nvar SwevaError = require('../../core/errors/swevaError.js');\n/**\n * An execution error should be used, if the error occured during execution.\n * @constructor\n * @extends SwevaError\n */\nfunction ExecutionError(message, context, faultyObject) {\n    SwevaError.call(this, message, context, faultyObject);\n    this.name = 'ExecutionError';\n}\nExecutionError.prototype = Object.create(SwevaError.prototype);\n\nmodule.exports = ExecutionError","'use strict';\n\nvar DefinitionError = require('../../core/errors/definitionError.js');\n/**\n * A compile error should be used, if  the error was thrown by the compiler, before actual execution and validation.\n * @constructor\n * @extends DefinitionError\n */\nfunction CompileError(message, context, faultyObject) {\n    DefinitionError.call(this, message, context, faultyObject);\n    this.name = 'CompileError';\n}\nCompileError.prototype = Object.create(DefinitionError.prototype);\n\nmodule.exports = CompileError;","'use strict';\n\nvar SwevaError = require('../../core/errors/swevaError.js');\n/**\n * A definition error should be used, if  the error occured because of incompatible definitions of composables, i.e. before actual execution.\n * @constructor\n * @extends SwevaError\n */\nfunction DefinitionError(message, context, faultyObject) {\n    SwevaError.call(this, message, context, faultyObject);\n    this.name = 'DefinitionError';\n}\nDefinitionError.prototype = Object.create(SwevaError.prototype);\n\nmodule.exports = DefinitionError;","'use strict';\n/**\n * Aggregates {@link SwevaError} messages.\n * @constructor\n */\nfunction ErrorManager() {\n    /**\n    * An array storing the error messages.\n    * @name ErrorManager#queue\n    * @type {Array.<Error>}\n    */\n    this.queue = [];\n}\n/**\n * Resets the ErrorManager.\n */\nErrorManager.prototype.clear = function () {\n    this.queue = [];\n}\n/**\n * Appends errors to the internal queue, logs them and returns the error object\n * @param {Error} error - The error object.\n * @returns {Error} - The error object.\n */\nErrorManager.prototype.error = function (error) {\n    this.queue.push(error);\n    console.log(error.toString());\n    console.log(error);\n    return error;\n}\n/**\n * Gets a string representation of all stored errors.\n * @returns {string} - All stored errors separated by a linebreak.\n */\nErrorManager.prototype.getLog = function () {\n    var result = '';\n    for (var i = 0; i < this.queue.length; i++) {\n        result += this.queue[i].toString() + '\\n';\n    }\n    return result;\n}\n/**\n * @returns {Error} - The last error that was recorded.\n */\nErrorManager.prototype.getLastError = function () {\n    if (this.queue.length > 0) {\n        return this.queue[this.queue.length - 1];\n    }\n    return null;\n}\n\nmodule.exports = ErrorManager;","'use strict';\n\n/**\n * An error object with some additional information.\n * @constructor\n * @extends Error\n * @param {string} message - The error message: What went wrong?\n * @param {string} context - The execution context, in what composable did the error occur?\n * @param {Object} [faultyObject] - Additional information about the error cause.\n */\nfunction SwevaError(message, context, faultyObject) {\n    /**\n    * The name of the error object.\n    * @name SwevaError#name\n    * @type {string}\n    */\n    this.name = 'SwevaError';\n\n    /**\n    * The error message.\n    * @name SwevaError#message\n    * @type {string}\n    */\n    this.message = message || 'Default Message';\n\n    /**\n    * The callstack of the error.\n    * @name SwevaError#stack\n    * @type {Object}\n    */\n    this.stack = (new Error()).stack;\n\n    /**\n    * The execution context of the error (in which composable it occured).\n    * @name SwevaError#context\n    * @type {string}\n    */\n    this.context = context;\n\n   \n    if (faultyObject !== 'undefined') {\n        //shallow copy: should provide enough information and save RAM\n        //copy is needed, as we need the object exactly at the time the error occurred\n        this.faultyObject = faultyObject;\n\n        if (typeof faultyObject === 'function') {\n            //make functions to strings            \n            this.faultyObject = faultyObject.toString();\n        }\n        else if (typeof faultyObject === 'object') {\n            for (var key in faultyObject) {\n                if (faultyObject.hasOwnProperty(key)) {\n                    this.faultyObject[key] = faultyObject[key];\n                }\n            }\n        }\n    }\n    else {\n        this.faultyObject = null;\n    }\n    /**\n    * The timestamp of the error.\n    * @name SwevaError#time\n    * @type {number}\n    */\n    this.time = Date.now();\n\n    console.error(\"Error in \"+context+\" created! Stacktrace:\");\n    console.trace();\n}\n//inherit properties\nSwevaError.prototype = Object.create(Error.prototype, {\n    constructor: {\n        value: this.constructor,\n        writable: true,\n        configurable: true\n    }\n});\n/**\n * @returns {string} - A string representation of the error timestamp.\n */\nSwevaError.prototype.getTime = function () {\n    return new Date(this.time).toLocaleTimeString();\n}\n\n/**\n * Converts error object to string including relevant information (timestamp, name, context, message, additional information).\n * @returns {string} - String representation of the error.\n */\nSwevaError.prototype.toString = function () {\n    var faultyObject = '';\n    if (typeof this.faultyObject === 'object') {\n        //transform object to pretty printed string (with identation).\n        faultyObject = JSON.stringify(this.faultyObject, null, 4);\n    }\n    else {\n        faultyObject = this.faultyObject.toString();\n    }\n    //construct string\n    return '[' + this.getTime() + '] SwevaError ' + this.name + ' in ' + this.context + ': ' + this.message + '\\n'\n        + faultyObject;\n}\nmodule.exports = SwevaError;","'use strict';\n\nvar Module = require('../../core/composables/module.js');\nvar Composition = require('../../core/composables/composition.js');\nvar DefinitionError = require('../../core/errors/definitionError.js');\n\n/**\n * Responsible for dynamically loading composables from a web address.\n * Loaded composables are stored in an internal dictionary, so they only need to be downloaded once.\n * @constructor\n * @param {string} [basePath=''] - The base address from which to download the composable. Gets prepended to the composable name.\n * @param {string} [suffix=.json] - The suffix that gets appended to the composable name.\n */\nfunction ComposableLoader(basePath, suffix) {\n    /**\n    * The base address from which to download the composable. Gets prepended to the composable name.\n    * @name ComposableLoader#basePath\n    * @type {string}\n    */\n    this.basePath = basePath || '';\n    /**\n    * The suffix that gets appended to the composable name.\n    * @name ComposableLoader#suffix\n    * @type {string}\n    */\n    this.suffix = suffix || '';\n    /**\n    * Dictionary of the composable names and the corresponding composable objects.\n    * @name ComposableLoader#composables\n    * @type {Object.<string, Composable>}\n    */\n    this.composables = {};\n    /**\n    * Dictionary of a waiting list, where loaded composables can be assigned to external objects\n    * @name ComposableLoader#waitingList\n    * @type {Object.<string, Object>}\n    */\n    this.waitingList = {};\n}\n\n/**\n * @returns {number} - The number of stored composables.\n */\nComposableLoader.prototype.size = function () {\n    return Object.keys(this.composables).length;\n}\n/**\n * @param {string} name - The name of the composable to return.\n * @returns {Composable} - The composable object.\n */\nComposableLoader.prototype.get = function (name) {\n    return this.composables[name];\n}\n/**\n * Composable objects can be directly added, without having to download them.\n * This can be used e.g. for rapid prototyping.\n * @param {string} name - The name of the composable to add.\n * @paranm {Composable} composable - The composable to add.\n */\nComposableLoader.prototype.add = function (name, composable) {\n    this.composables[name] = composable;\n}\n/**\n * Converts a JSON representation of a composable into a full composable object.\n * Since composables can have custom functions defined, and JSON does not support functions, we cannot use JSON.parse.\n * Instead functions are encoded as string arrays in JSON and then assembled.\n * {@link SwevaScript} is used to sanitize the functions.\n *\n * @protected\n * @param {Object} json - The JSON object of the composable.\n * @param {string} context - The context of execution (for error messages).\n * @returns {composableInitalizer} - Composable initalization object.\n */\nComposableLoader.prototype.convertToObject = function (json, context) {\n    var result = json;\n    var self = this;\n    for (var key in json) {\n        if (json.hasOwnProperty(key)) {\n           //decode base64 encoded binaries\n            if(key === 'binary' && !(json[key] instanceof Uint8Array)) {\n                /*console.log(json)\n                console.log(context)\n                console.log(json[key]);\n                console.log(typeof json[key])*/\n                let binaryList = atob(json[key]);\n               json[key] = new Uint8Array(binaryList.split(\"\").map(function(c) {\n                   return c.charCodeAt(0);\n               }));\n            }\n\n            //TODO: consider removing mapping functions\n            if (key !== 'source' && (json[key] !== null && typeof json[key][0] === 'string')) {\n                var str = String(json[key][0]);\n                //check if string array starts with 'function' -> assemble function into object\n                if (str.trim().indexOf('function') === 0) {\n                    //first sanitize the script to prevent malicious code execution\n\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\n                        function (error) {\n                            sweva.ErrorManager.error(\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\n                                    context, self.convertJsonToCode(json)));\n                        });\n                }\n            }\n\n            /*//TODO: consider removing mapping functions\n            if (key !== 'source' && typeof json[key][0] === 'string') {\n                var str = String(json[key][0]);\n                //check if string array starts with 'function' -> assemble function into object\n                if (str.trim().indexOf('function') === 0) {\n                    //first sanitize the script to prevent malicious code execution\n\n                    json[key] = sweva.SwevaScript.sanitize(json[key].join('\\n'),\n                        function (error) {\n                            sweva.ErrorManager.error(\n                                new DefinitionError('Could not sanitize function \"' + key + '\" when loading \"' + context + '\": ' + error,\n                                    context, self.convertJsonToCode(json)));\n                        });\n                }\n            }*/\n\n            if (typeof json[key] === 'object') {\n                json[key] = this.convertToObject(json[key], context);\n            }\n        }\n    }\n\n    return result;\n}\n//TODO: replace default modules\nComposableLoader.prototype.getDefaultModule = function () {\n    return \"{\\n\" +\n        \"      \\\"type\\\": \\\"module\\\",\\n\" +\n        \"      \\\"name\\\": \\\"Module\\\",\\n\" +\n        \"      \\\"description\\\": \\\"New Module template\\\",\\n\" +\n        \"      \\\"dataInNames\\\": [\\n\" +\n        \"        \\\"num\\\"\\n\" +\n        \"      ],\\n\" +\n        \"      \\\"dataInSchema\\\": {},\\n\" +\n        \"      \\\"dataOutNames\\\": [\\n\" +\n        \"        \\\"out\\\"\\n\" +\n        \"      ],\\n\" +\n        \"      \\\"dataOutSchema\\\": {},\\n\" +\n        \"      \\\"inputNames\\\": [],\\n\" +\n        \"      \\\"inputSchema\\\": {},\\n\" +\n        \"      \\\"source\\\": [\\n\" +\n        \"      \\\"export var a:i32 = 42;\\\",\\n\" +\n        \"      \\\"export function run(num: i32): i32 {\\\",\\n\" +\n        \"      \\\"if (a > num){\\\",\\n\" +\n        \"      \\\"return b}\\\",\\n\" +\n        \"      \\\"return num\\\",\\n\" +\n        \"      \\\"}\\\"\\n\" +\n        \"      ]\\n\" +\n        \"}\";\n}\nComposableLoader.prototype.getDefaultComposition = function () {\n    return \"{\\n    type: \\'composition\\',\\n    name: \\'composition1\\',\\n    dataInNames: [],\\n    dataInSchema: {},\\n    dataOutNames:[\\'result\\'],\\n    dataOutSchema: {},\\n    inputNames: [],\\n    inputSchema: {},\\n    mapDataIn: function (data, composableName, composables, libs) {\\n        if (data.hasOwnProperty(composableName)) {\\n            return libs.get(data, composableName);\\n        }\\n        return null;\\n    },\\n    mapDataOut: function (output, libs) {\\n        return output;\\n    },\\n    mapInput: function (input, moduleName, modules, libs) {\\n        if (input.hasOwnProperty(moduleName)) {\\n            return libs.get(input, moduleName);\\n        }\\n        return null;\\n    }\\n}\";\n}\n\nComposableLoader.prototype.convertCodeToJson = function (string) {\n    \n    var result = ''\n    var lines = string.split(/\\r?\\n/);\n   \n    var regexFunction = new RegExp(/^\\s*(\\w)+\\s*:\\s*function/);\n    var regexProperty = new RegExp(/^\\s*(\\w)+\\s*/);\n\n    var funcLines = false;\n    var funcLinesFirst = false;\n    var braceCount = 0;\n    var funcLinesJustFinished= false;\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i].trim();        \n        if (!funcLines) {\n            if (funcLinesJustFinished && line.indexOf(':') >= 0) {\n                funcLinesJustFinished = false;\n                result += ',\\n';\n            }\n            if (regexFunction.test(line)) {\n                funcLines = true;\n\n                var index = line.indexOf('function');\n\n                var linePart = line.slice(0, index);\n                var match = regexProperty.exec(linePart);\n                if (match != null) {\n                    linePart = linePart.slice(0, match.index) + '\"' + linePart.slice(match.index, match.index + match[0].length) + '\"' + linePart.slice(match.index + match[0].length);\n                }\n                linePart = linePart.replace(/'/g, '\"');\n\n                result += linePart;\n\n                result += '[\"' + line.slice(index) + '\",\\n';\n                funcLinesFirst = true;\n            }\n            else {\n                var match = regexProperty.exec(line);\n                if (match != null) {\n                    line = line.slice(0, match.index) + '\"' + line.slice(match.index, match.index + match[0].length) + '\"' + line.slice(match.index + match[0].length);\n                }\n                line = line.replace(/'/g, '\"');                \n                result += line + '\\n';\n            }\n        }\n        if (funcLines) {\n            var inQuotes = false;\n            var inSingleQuotes = false;\n            for (var k = 0; k < line.length; k++) {\n                var c = line[k];\n\n                if (c == '\"' && !inSingleQuotes) {\n                    inQuotes = !inQuotes;\n                    line = line.slice(0, k) + '\\\\' + line.slice(k);\n                    k++;\n                }\n                else if (c == '\\'' && !inQuotes) {\n                    inQuotes = !inSingleQuotes;\n                }\n                else if (c == '{' && !inQuotes && !inSingleQuotes) {\n                    braceCount++;\n                }\n                else if (c == '}' && !inQuotes && !inSingleQuotes) {\n                    braceCount--;\n                }\n            }\n            if (funcLinesFirst) {\n                funcLinesFirst = false;\n            }\n            else {\n                line = line.replace('\\\\n', '\\\\\\\\n');\n                if (braceCount == 0) {\n                    if (line.length > 0 && line.indexOf(',') >= line.length - 1) {\n                        line = line.slice(0, line.length - 1);\n                    }\n                    result += '\"' + line + '\"' + '\\n';\n                }\n                else {\n                    result += '\"' + line + '\"' + ',' + '\\n';\n                }\n            }\n\n            if (braceCount == 0) {\n                funcLines = false;\n                funcLinesFirst = false;\n                result += ']\\n';\n                funcLinesJustFinished=true;\n               \n            }\n        }\n    }\n\n    if (result.indexOf('{') !== 0) {\n        return '{' + result + '}';\n    }\n\n    return result;\n}\nComposableLoader.prototype.convertJsonToCode = function (obj) {\n    function getSpaces(spaces) {\n        var result = '';\n        for (var i = 0; i < spaces; i++) {\n            result += ' ';\n        }\n        return result;\n    }\n    function stringify(object, level, spaces) {\n        var result = '';\n\n        var ident = getSpaces(level * spaces);\n\n        var keys = Object.keys(object);\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var keyString = (key.indexOf(' ') >= 0) ? ('\\'' + key + '\\'') : key;\n            result += ident + keyString + ': ';\n            if (typeof object[key] === 'string') {\n                result += '\\'' + object[key] + '\\'';\n            }\n            else if (typeof object[key] === 'object') {\n                if (Array.isArray(object[key])) {\n                    var arrayContent = '';\n\n                    if (object[key].length > 0 && typeof object[key][0] === 'string' && object[key][0].trim().indexOf('function') == 0) {\n                        //decode function\n                        var internalLevel = 0;\n                        for (var k = 0; k < object[key].length; k++) {\n                            var line = object[key][k].trim();\n                            if (line.indexOf('}') == 0) {\n                                internalLevel--;\n                                if (internalLevel < 0) {\n                                    internalLevel = 0;\n                                }\n                            }\n                            arrayContent += (k == 0 ? '' : ident) + getSpaces(spaces * internalLevel) + line + (k >= object[key].length - 1 ? '' : '\\n');\n                            if (line.length > 0 && line.indexOf('{') == line.length - 1) {\n                                internalLevel++;\n                            }\n                        }\n                        result += arrayContent + ident;\n                    }\n                    else {\n                        for (var k = 0; k < object[key].length; k++) {\n                            var element = object[key][k];\n                            arrayContent += ident + getSpaces(spaces);\n                            if (typeof element === 'string') {\n                                arrayContent += '\\'' + element + '\\'';\n                            }\n                            else if (typeof element === 'object') {\n                                arrayContent += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\n                            }\n                            else {\n                                arrayContent += element;\n                            }\n                            if (k < object[key].length - 1) {\n                                arrayContent += ',';\n                            }\n                            arrayContent += '\\n';\n                        }\n                        result += '[\\n' + arrayContent + ident + ']';\n                    }\n                }\n                else {\n                    result += '{\\n' + stringify(object[key], level + 1, spaces) + ident + '}';\n                }\n            }\n\n            else {\n                result += '\\'' + object[key] + '\\'';\n            }\n\n            if (i < keys.length - 1) {\n                result += ',';\n            }\n            result += '\\n';\n        }\n        return result;\n    }\n    return '{\\n'+stringify(obj, 1, 4)+'}';\n}\n\n/**\n * Helper function, that assigns the composables to the internal dictionary and optionally to external objects with a specified property.\n * This can be used to directly fill another external dictionary of composables, like the {@link Composition} composable dictionary.\n * @protected\n * @param {string} name - The name of the composable.\n * @param {Composable} composable - The composable object.\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\n */\nComposableLoader.prototype.assignLoadedComposables = function (name, composable, assignToObject, property) {\n    this.composables[name] = composable;\n\n    //check if the optional assignToObject is given\n    if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\n        assignToObject[property] = composable;\n    }\n\n    //deal with waitinglist: as the caller has to wait for 'then' we, can set the required values now with some delay\n    if (this.waitingList.hasOwnProperty(name)) {\n        //for each object, that waits for the composable to be assigned to\n        for (var i = 0; i < this.waitingList[name].length; i++) {\n            var assignTo = this.waitingList[name][i].assignTo;\n            var prop = this.waitingList[name][i].prop;\n\n            assignTo[prop] = composable;\n        }\n        //remove element from the waitingList\n        delete this.waitingList[name];\n    }\n}\n/**\n * Loads a composable by the given name from a web resource.\n * If no basePath was given in the constructor, use the full web address as the name.\n * @param {string} name - The name of the composable.\n * @param {Object} [assignToObject] - The external object to wich the composable should be assigned to.\n * @param {string} [property] - The porperty of the external object to wich the composable should be assigned to.\n * @returns {Promise<Composable>} - The loaded composable object.\n */\nComposableLoader.prototype.load = function (name, assignToObject, property) {\n    var self = this;\n\n    //return a promise, since loading is ansynchronuous\n    return new Promise(function (resolve, reject) {\n        //check if the name was already loaded or is currently being loaded\n        if (self.composables.hasOwnProperty(name)) {\n            //we have only our placeholder, no real value yet\n            //this means the composable is currently requested, but not loaded\n            if (self.composables[name] === true) {\n                //put in waitinglist, which is checked after each load\n                //but only, if it needs to be assigned externally\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null && typeof property === 'string') {\n                    if (!self.waitingList.hasOwnProperty(name)) {\n                        self.waitingList[name] = [];\n                    }\n                    self.waitingList[name].push({\n                        assignTo: assignToObject,\n                        prop: property\n                    });\n                }\n                //load from dictionary\n                resolve(self.composables[name]);\n            }\n            else {\n                if (typeof assignToObject !== 'undefined' && assignToObject !== null) {\n                    assignToObject[property] = self.composables[name];\n                }\n                resolve(self.composables[name]);\n            }\n        }\n            //not already in dictionary, needs to be loaded\n        else {\n            //set key and prevent unnecessary loads, while loading is already in progress\n            self.composables[name] = true;\n            //construct url\n            var url = self.basePath + name + self.suffix;\n\n            sweva.axios.get(url)\n            .then(function (response) {\n                //convert the response JSON to an actual composable\n                var composable = self.convertToObject(response.data, url);\n                //closue function, dummy\n                var func = function (comp) {\n                    return function (res, rej) {\n                        res(comp);\n                    }\n                }\n                var internalPromise = new Promise(func(composable));\n\n                //check if composable just extends existing one\n                if (composable.hasOwnProperty('extends')) {\n                    var baseComposableName = composable.extends;\n                    //create a closure to load the base composable\n                    var func2 = function (baseComposableName, composable) {\n                        return function (res, rej) {\n                            self.load(baseComposableName).then(function (comp) {\n                                //extend loaded composable with extension\n                                res(comp.extendWith(composable));\n                            });\n                        }\n                    };\n                    //adjust internal promise to load the base composable first, before extending it.\n                    internalPromise = new Promise(func2(baseComposableName, composable));\n                }\n\n                internalPromise.then(function (composable) {\n                    //log as loaded\n                    console.log('loaded ' + composable.name);\n                    //if the loaded composable is a module\n                    if (composable.type == 'module') {\n                        //construct Module\n                        composable = new Module(composable);\n\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\n\n                        resolve(composable);\n                    }\n                        //if the loaded composable is a composition\n                    else {\n                        //construct Composition\n                        composable = new Composition(composable);\n\n                        self.assignLoadedComposables(name, composable, assignToObject, property);\n                        //load composables required for the composition\n                        composable.loadComposables().then(function () {\n                            resolve(composable);\n                        });\n                    }\n                });\n            })\n            .catch(function (response) {\n                reject(self.basePath + name + self.suffix); //could not load\n            });\n        }\n    });\n}\n/**\n * Clears the internal dictionaries.\n */\nComposableLoader.prototype.clear = function () {\n    this.composables = {};\n    this.waitingList = {};\n}\nmodule.exports = ComposableLoader;","'use strict';\n\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar Module = require('../../core/composables/module.js');\nvar Composition = require('../../core/composables/composition.js');\n\n//MA\nlet potentialOffloadingTarget = require(\"../network/potentialOffloadingTarget.js\");\nlet dataProcessingDevice = require(\"../network/dataProcessingDevice.js\");\n\n// **** P2P network ****\nlet peer = new Peer('',{\n    host:\"milki-psy.dbis.rwth-aachen.de\",\n    port:443,\n    path:\"/discoveryNetwork\"\n});\nconsole.log('offloadingOutput$ Connection to the SWeVA P2P network successful!')\n//Event-based script\n//+++++++++ DEVICE is POT +++++++++\npeer.on('connection', (connection) => {\n    connection.on('data', (data) => {\n        if (data === 'peer'){\n            let msg = 'offloadingOutput$ Potential Offloading Target from device = ' + connection.peer;\n            console.log(msg);\n            potentialOffloadingTarget();\n        }\n    }); });\n//+++++++++ DEVICE is DPD +++++++++\n\nfunction broadcastToDiscoveryNetwork(intermediatePipelineAndResults) {\n    console.log('offloadingOutput$ broadcasting to discovery network....');\n    dataProcessingDevice(intermediatePipelineAndResults);\n    peer.listAllPeers((peerIds) => {\n        peerIds\n            .filter((peerId) => peerId !== peer.id) // Filter out device ID\n            .forEach((peerId) => {\n                const conn = peer.connect(peerId);\n                conn.on('open', () => {\n                    //console.log('offloadingOutput$ Discovered Peer = ' + peerId);\n                    conn.send('peer');\n                });\n                conn.on('error', (err) => {\n                    console.error('Error discovering Peer : ' + peerId);\n                    console.error(err);\n                })\n            });\n    });\n}\n\n// **** END P2P network ****\n\n// ************* Getters and Setters ****************\n\n//default values\nlet odList = [0,0,0];\nlet orList = [0,0,false];\nlet intermediatePipeline = {};\nlet intermediatePipelineResults ={};\nExecutionManager.setODList = function (odListInput) {\n    odList=odListInput;\n}\nExecutionManager.getODList = function () {\n    return odList;\n}\n\nExecutionManager.setORList = function (orListInput) {\n    orList=orListInput;\n}\nExecutionManager.getORList = function () {\n    return orList;\n}\n\nExecutionManager.setInitialIntermediatePipeline = function (intermediatePipelineInput) {\n    //prepare the intermediate pipeline for compatibility reasons\n    for (let key in intermediatePipelineInput.composables) {\n        if (intermediatePipelineInput.composables.hasOwnProperty(key)) {\n            delete intermediatePipelineInput.composables[key].manager;\n        }\n    }\n    intermediatePipeline = intermediatePipelineInput;\n\n    console.log('Initializing intermediate pipeline =',intermediatePipeline);\n\n}\n\nExecutionManager.getListOfPeers = function listOfPeers() {\n    return new Promise((resolve) => {\n        peer.listAllPeers((peerIds) => {\n            const list = peerIds\n                .filter((peerId) => peerId !== peer.id)\n                .map((peerId) => peerId.toString());\n\n            resolve(list);\n        });\n    });\n};\n\n//****** end Web GETTERS and SETTERS ***********\n\n/**\n * An ExecutionManager is responsible for managing the execution process of compositions and modules.\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an execution phase,\n * that executes the composables by providing data and input objects to them.\n *\n * The setup needs to be done only once, while the execution can be repeated on different data.\n * @constructor\n * @param {string} [name] - Name of the execution manager.\n */\nfunction ExecutionManager(name) {\n    if (typeof name === 'string') {\n        this.name = name;\n    } else {\n        this.name = 'ExecutionManager';\n    }\n    /**\n     * Amount of how many modules are used currently.\n     * @name ExecutionManager#modulesTotal\n     * @type {number}\n     */\n    this.modulesTotal = 1;\n    /**\n     * Amount of how many modules have finished execution.\n     * @name ExecutionManager#modulesDone\n     * @type {number}\n     */\n    this.modulesDone = 0;\n    /**\n     * Callback to track progress, gets called everytime a module finishes.\n     * @name ExecutionManager#progressCallback\n     * @type {function}\n     */\n    this.progressCallback = null;\n    this.updateVisualizationNotifier = null;\n\n    this.reexecutionListeners = [];\n}\n\n/**\n * Registers the callback function to track progress.\n * @param callback\n */\nExecutionManager.prototype.onProgress = function (callback) {\n    this.progressCallback = callback;\n};\n\n/**\n * Registers the callback function to update visualization on MQTT data received after reexecuting the sweva-graph.\n * @param {function} - Callback function for updating the visualization.\n */\nExecutionManager.prototype.onMQTTDataRecieved = function (callback) {\n    this.updateVisualizationNotifier = callback;\n};\n\nExecutionManager.prototype.sendDataToVisualization = function (result) {\n    if (this.updateVisualizationNotifier !== null) {\n        this.updateVisualizationNotifier(result);\n    }\n}\n\n\n/**\n * Registers a callback function that gets called whenever any asynchronous node re-executes parts of the composition.\n *\n * @param callback\n */\nExecutionManager.prototype.addReexecutionListener = function (callback, module_name) {\n    if (this.reexecutionListeners.length !== 0) {\n        for (var key in this.reexecutionListeners) {\n            if (this.reexecutionListeners[key].module_name === module_name) {\n                this.reexecutionListeners.splice(key, 1);\n            }\n        }\n        this.reexecutionListeners.push({\n            callback: callback,\n            module_name: module_name\n        });\n\n    } else if (module_name !== false) {\n        this.reexecutionListeners.push({\n            callback: callback,\n            module_name: module_name\n        });\n    }\n\n};\n\nExecutionManager.prototype.onModuleUpdate = function (module) {\n    for (var i in this.reexecutionListeners) {\n        if (this.reexecutionListeners[i].module_name === module.mqtt_sweva_parameters.module_name) this.reexecutionListeners[i].callback(module);\n    }\n};\n\n/**\n * Initializes all required composables, loads dependencies, validates.\n *\n * (IF) PARSE pipeline to JS object self gloabl to the executionManager !\n *\n * @param {Array.<string|Composable>} executionArray - Array of composables that will be executed.\n * @param {boolean} [isPureObject=false] - Set this to true, if passing pure JavaScript Objects and not just JSON.\n */\n//Global variable names\n\n\n\nExecutionManager.prototype.setup = function (executionArray, isPureObject) {\n\n    //internal recursive function to count how many modules are currently used\n    function countModules(composable) {\n        if (typeof composable.composables === 'undefined') {\n            return 1;\n        } else {\n            var count = 0;\n\n            for (var key in composable.composables) {\n                if (composable.composables.hasOwnProperty(key)) {\n                    //console.log(key, composable.composables[key]);\n                    count += countModules(composable.composables[key]);\n                }\n            }\n            //console.log('UPDATED Composable =', composable);\n            //console.log(\"Number of set up nodes in Composable: \" + count);\n            return count;\n        }\n    }\n\n    var needsLoading = [];\n    this.composables = {};\n    this.isReady = false;\n\n    this.wantsToExecute = false;\n    //if it is not an array, make it one\n    if (!Array.isArray(executionArray)) {\n        executionArray = [executionArray];\n    }\n    var names = [];\n    //for each composable, that will be executed\n    for (var i = 0; i < executionArray.length; i++) {\n        var composable = executionArray[i];\n        //if composable is provided as string, i.e. name it needs to be loaded\n        if (typeof composable === 'string') {\n            names.push(composable);\n            needsLoading.push(sweva.ComposableLoader.load(composable, this.composables, composable));\n        }\n        //otherwise a composable object is given\n        else {\n            if (typeof isPureObject === 'undefined' || !isPureObject) {\n                composable = sweva.ComposableLoader.convertToObject(composable, 'JSON');\n            }\n\n            if (composable.type === 'module') {\n                this.composables[composable.name] = new Module(composable, this);\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\n            } else {\n                this.composables[composable.name] = new Composition(composable, this);\n                sweva.ComposableLoader.add(composable.name, this.composables[composable.name]);\n                //composables of a composition need also to be loaded\n                needsLoading.push(this.composables[composable.name].loadComposables());\n            }\n            names.push(composable.name);\n        }\n    }\n    var self = this;\n\n    //now wait for everything to load\n    Promise.all(needsLoading).then(function () {\n        //console.log('RAW Pipline / User Input=', composable);\n        //let's check, how many modules are used in total to have a rough estimate for progress tracking\n        var moduleCount = 0;\n        for (var i = 0; i < executionArray.length; i++) {\n            moduleCount += countModules(sweva.ComposableLoader.get(names[i]));\n\n        }\n        self.modulesTotal = moduleCount;\n        self.modulesDone = 0;\n\n        //composables should now contain everything\n        self.isReady = true;\n        console.log('all loaded');\n        //if we want to execute, before setup is ready, it is delayed and continued from here\n        if (self.wantsToExecute) {\n            self.wantsToExecute = false;\n            self.executeCallback();\n        }\n    })\n        .catch(function (error) {\n            sweva.ErrorManager.error(\n                new ExecutionError('Could not load all modules: ' + error,\n                    self.name, error));\n        });\n}\n\n/**\n * Calculates the current progress state and calls the optionally registered progressCallback.\n * It counts the percentage of the modules that have finished execution.\n *\n * @param {string} alias - The alias of the module, under which it is known to the parent composition.\n * @param {string} name - The name of the module.\n * @param {string} context - The context under which the module is executed (its parents).\n */\nExecutionManager.prototype.progressUpdate = function (alias, name, context,result) {\n    console.log('offloadingOutput$ Finished executing ',alias);\n    if (result==='offloading')\n        {\n            console.log('OFFLOADING flag catched in Exec manager !');\n\n            //prepare pipeline to be compatible for offloading\n            for (let key in intermediatePipeline.composables) {\n                if (intermediatePipeline.composables.hasOwnProperty(key)) {\n                    delete intermediatePipeline.composables[key].manager;\n                }\n                const composablesNode = intermediatePipeline.composables[key];\n                for (let prop in composablesNode) {\n                    if (composablesNode[prop] === null) {\n                        delete composablesNode[prop];\n                    }\n                }\n            }\n\n            intermediatePipeline =JSON.stringify(intermediatePipeline);\n\n            intermediatePipelineResults= JSON.stringify(intermediatePipelineResults);\n            let mergedPip ={intermediatePipeline:intermediatePipeline,intermediatePipelineResults:intermediatePipelineResults};\n\n            //console.log('offloading the merged Pipeline...');\n            //console.log(mergedPip);\n\n            broadcastToDiscoveryNetwork(mergedPip); //Offload merged Pipeline to best POT\n\n\n    }\n\n    //detects an offloaded pipeline :)\n    if (Object.keys(intermediatePipeline).length !== 0)\n    {\n        //consider result as linked nodes input\n        let nodeLinks = intermediatePipeline.links;\n        let moduleResult = result.out;\n\n        if (nodeLinks.hasOwnProperty(alias)){\n            console.log('Cheesecake !')\n            let linksArray =Object.entries(nodeLinks[alias].out)[0];\n            console.log(linksArray);\n\n            intermediatePipelineResults[linksArray[0]]={\n                \"num\":moduleResult\n            };\n            console.log(intermediatePipelineResults);\n            delete intermediatePipeline.composables[alias];\n        }else {\n\n            //consider result as node output\n            console.log('croissant !')\n            intermediatePipelineResults[alias]={\n                \"out\":moduleResult\n            };\n            delete intermediatePipeline.composables[alias];\n        }\n\n\n    if (this.progressCallback !== null) {\n        this.modulesDone++;\n\n        var progress = this.modulesDone / +this.modulesTotal;\n\n        //make a value 0-100 and cut off decimal places\n        this.progressCallback((progress * 100).toFixed(0));\n        //TODO send this to frontend\n    }}\n}\n\n\n\n/**\n * Executes the composables that were initalized during {@link ExecutionManager#setup}.\n * @param {Object} data - The data to use for the execution. If multiple composables will be executed,\n * the data property names must correspond to the composable names for a correct mapping of the data.\n * @param {Object} input - The input object for the execution. If multiple composables will be executed,\n * the input property names must correspond to the composable names for a correct mapping of the input.\n */\n\n\nExecutionManager.prototype.execute = function (data, input) {\n    /**\n     * An Array of executions, which are representing Modules (nodes).\n     * @type {Array}\n     */\n    var executions = [];\n    var self = this;\n\n    /*\n    console.log(\"///////////// Exec Manager inputs //////////////\");\n    console.log(\"data\");\n    console.log(data);\n    console.log(\"input\");\n    console.log(input);\n    console.log('self');\n    console.log(self);\n    console.log('intermediate Pipeline');\n    console.log(intermediatePipeline);\n    console.log(\"///////////////////////////\");\n    */\n    console.log('begin the execution');\n    return new Promise(function (resolve, reject) {\n        //closure function\n        //composables is the pipeline\n        //executions is the list of promises Module to be executed\n        var func = function (composables, executions, resolve, reject) {\n            /*\n            console.log(\"///////////// func inputs //////////////\");\n            console.log('Composables= ');\n            console.log(composables);\n            console.log('Executions= ');\n            console.log(executions);\n            console.log(\"///////////////////////////\");\n            */\n            return function () {\n\n                var onlyOneComposable = false;\n                // check if only one composable will be executed, because then you don't go into the loop.\n                if (Object.keys(composables).length === 1) {\n                    onlyOneComposable = true;\n                }\n\n                for (var key in composables) {\n                    if (composables.hasOwnProperty(key)) {\n                        /*\n                        console.log(\"///////////// if condition //////////////\");\n                        console.log('composables[key]= ');\n                        console.log(composables[key]);\n                        console.log('input[key] ');\n                        console.log(input[key]);\n                        console.log('key= ');\n                        console.log(key);\n                        console.log('self.progressUpdate.bind(self)= ');\n                        console.log(self.progressUpdate.bind(self));\n                        console.log(\"///////////////////////////\");\n                        */\n                        if (onlyOneComposable) {\n                            //execute function is defined in module.js\n                            executions.push(composables[key].execute(data, input, '', key, self.progressUpdate.bind(self)));\n                            //console.log(\" ====== Only One Composable ==== \");\n                        } else {\n                            //=== OFFLOADING === MODULE EXECUTION IS INITIALIZED !\n                            executions.push(composables[key].execute(data[key], input[key] || {}, '', key, self.progressUpdate.bind(self)));\n                            //console.log(\" ====== More than 1 composable ==== \");\n                        }\n\n                    }\n                }\n\n                // while loop to monitor the execution of the pipeline and update the offloading pipeline\n\n                //todo: implement a loop that updates a copy of the original pipeline each time a module is executed\n                // ( promise is fullfilled) and stops and returns the updated pipeline if one promise is rejected\n                //monitorPromises(executions);\n\n                // ELSE NO OFFLOADING ...\n                // when all the execution Promises have resolved...\n                Promise.all(executions).then(function (results) {\n                    console.log('all promises resolved');\n                    if (onlyOneComposable) {\n                        return resolve(results[0]);\n                    }\n                    resolve(results);\n                }).catch(function (results) {\n                    if (onlyOneComposable) {\n                        return resolve(results);\n                    }\n                    sweva.ErrorManager.error(\n                        new ExecutionError('Something unexpected happened: ' + results,\n                            this.name, results));\n                    reject(results);\n                });\n            }\n\n        };\n\n        if (self.isReady) {\n            func(self.composables, executions, resolve, reject)();\n        } else {\n            self.wantsToExecute = true;\n            self.executeCallback = func(self.composables, executions, resolve, reject);\n        }\n    });\n}\n//alias\nExecutionManager.prototype.run = ExecutionManager.prototype.execute;\nmodule.exports = ExecutionManager\n\n\n/*\n\n//////////////  EXPERT MODE  //////////////\n\n// inputs are extracted from device\nExecutionManager.prototype.deviceMonitoringIndex = async function () {\n    async function deviceMonitoringIndex() {\n        return new Promise((resolve, reject) => {\n            //this.window = window;\n            let metrics = [];\n\n            //Hardware metrics in Linux environments:\n            let cpu = await currentCPUusage()\n            let mem = await currentMemoryusage()\n            let storage = await availableStorage()\n            let battery = await availableBattery()\n            let charging = await isCharging()\n\n            console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\n            resolve(metrics.push(cpu, mem, storage,battery,charging));\n\n\n            //for windows testing purposes\n            let cpu = 60; //avg free cpu value for 3 measurements in %\n            let mem = 100000; // avilable free mem value in bytes\n            let storage = 2000000; // avilable free storage value in bytes\n            let battery = 80;\n            let charging = true;\n            //console.log(\"cpu\",cpu,\"\\n mem\", mem, \"\\n storage\", storage, \"\\n battery\", battery, \"\\n charging\", charging);\n            metrics.push(cpu, mem, storage, battery, charging)\n            resolve(metrics);\n\n        })\n    }\n\n    return await deviceMonitoringIndex();\n\n}\n*/\n\n/*\n//inputs are extracted from frontend -> user input in backend\nExecutionManager.prototype.offloadingDecision = async function (od_CPU, od_mem, od_battery) {\n    async function offloadingDecission(wpn, od_CPU, od_mem, od_battery) {\n        return new Promise(async (resolve, reject) => {\n            const dmi = await ExecutionManager.prototype.deviceMonitoringIndex();\n            let decision = false;\n            //[0]:cpu\n            //[1]: memory\n            //[2]: storage\n            //dmi[3]: battery\n            //dmi[4]: is charging\n            if (od_CPU === 0 || od_mem === 0 || od_battery === 0) {\n                decision = true;\n            } else if (wpn[0] > (dmi[0] * od_CPU) || wpn[1] > (dmi[1] * od_mem) || dmi[3] < od_battery) {\n                decision = true;\n            }\n            resolve(decision);\n        });\n    }\n\n    return await offloadingDecission([sweva.ComposableLoader['totalCPUReq'], sweva.ComposableLoader['totalMemReq']], od_CPU, od_mem, od_battery);\n\n}\n*/\n\n//////////////  END  EXPERT MODE  //////////////\n","/**\n * Creates instance of support library\n *\n * Allow loading functionality separately, depending on what is needed for a specific runner\n *\n * @constructor\n */\n\nfunction SupportLibrary() {\n    this.functions = {};\n}\n\nSupportLibrary.prototype.loadTestSync = function() {\n    this.functions.test = {\n        async: false,\n        languageSpecific: {\n            typescript: {\n                parameterSig: \"url: string\",\n                returnSig: \"string\"\n            }\n        },\n        func: function (url) {\n            return url + url;\n        }\n    };\n}\n\nSupportLibrary.prototype.loadLogger = function() {\n    this.functions.log = {\n        description: \"Log the text to the browser console\",\n        async: false,\n        languageSpecific: {\n            typescript: {\n                parameterSig: \"text: string\",\n                returnSig: \"void\"\n            }},\n        func: function (text) {\n            console.log(text);\n        }};\n}\nSupportLibrary.prototype.loadHTTP = function() {\n    this.functions.httpRequest = {\n        description: \"Send a HTTP(S) request using the fetch api. Returns status=-1 on timeout!\",\n        async: true,\n        languageSpecific:{\n            typescript: {\n                parameterSig: \"url: string, headers:string = null | null, method:string = 'GET' | null, body:string = null | null, cache:string = 'no-store' | null, timeout:i32 = 5000\",\n                returnSig: \"text: string, status: int\"\n        }},\n        func: async function (url, headers, method, body, cache, timeout) {\n            let init = {};\n\n            if(headers != null)\n                init.headers = headers;\n            if(method != null)\n                init.method = method;\n            if(body != null)\n                init.body = body;\n            if(cache != null)\n                init.cache = cache;\n            else\n                init.cache = \"no-store\";\n\n            let controller = new AbortController();\n            let timeoutTimer = setTimeout(() => controller.abort(), timeout);\n            init.signal = controller.signal;\n\n            try{\n                let response = await fetch(url, init);\n                clearTimeout(timeoutTimer);\n                console.log(\"RESPONSE:\")\n                console.log(response);\n                let text = await response.text();\n                return [text, response.status];\n            } catch (e) {\n                return [\"TIMEOUT\", -1];\n            }\n        }};\n}\n\nmodule.exports = SupportLibrary;","let offloadingTarget = require(\"../offloading/offloadingTarget.js\");\n\nfunction createPeer(id, callback = () => {\n}) {\n    let peer = new Peer(id, {\n        host: \"milki-psy.dbis.rwth-aachen.de\", //localhost\n        port: 443, //9001\n        path: \"/offloadingNetwork\",\n    });\n    peer.on('open', function (ID) {\n        console.log('offloadingOutput$ My peer ID is = ' + ID);\n        callback();\n    });\n    peer.on(\"error\", function (err) {\n        console.log(\"Error: \" + err);\n    });\n    peer.on('disconnected', function (ID) {\n        console.log('peer ID ' + ID+' disconnected');\n        callback();\n    });\n\n    return peer;\n}\n\nfunction dataProcessingDevice(pipeline) {\n    let idAndDMIpairs = {};\n    let connections = {};\n    let allReceived = false;\n    let peer = createPeer('source', () => {\n\n        peer.on('connection', (connection) => {\n            //to check which peer sent a msg and which didn't YET!\n            connections[connection.peer]=false;\n            console.log('offloadingOutput$ connected to peer = '+connection.peer);\n            console.log(connections);\n            connection.on('data', (data) => {\n\n                if (Array.isArray(data) &&\n                    data.length > 0 &&\n                    data[data.length-1]==='dmi')\n                {\n                    console.log('received DMI from: ',connection.peer);\n                    console.log(data);\n                    //delete the flag\n                    connections[connection.peer]=true;\n                    console.log(connections);\n                    idAndDMIpairs[connection.peer]= data;\n\n                    allReceived= Object.values(connections).every(value => value === true);\n                    console.log(allReceived);\n\n                    //todo: have a timeout for robustness\n                    if (allReceived){\n\n                        return processMsgs();\n                    }\n\n\n                }else{\n                    console.log( \"Error encountered while receiving the dmi\");\n                    //TODO: error handling\n                }\n\n\n            });\n        });\n        function processMsgs () {\n\n            console.log('entered processMsgs functions');\n            let potId = offloadingTarget(idAndDMIpairs); //TODO: change processList to chooseBestPOT\n            if (potId === null ){\n                console.log( 'offloadingOutput$ There is no suitable offloading peer available ! Offload to the cloud...');\n            }else{\n            console.log('offloadingOutput$ chosen potID for offloading = ' + potId);\n\n            let conn = peer.connect(potId);\n            conn.on('open', () => {\n                console.log('offloadingOutput$ connection opened with chosen POT !');\n                console.log('SENT PIPELINE = ',pipeline);\n                console.log('Type of PIPELINE = ', typeof pipeline);\n                conn.send(pipeline); //send pipeline here\n            });\n\n            conn.on('data', (data) => {\n\n                console.log('Pipeline result: ');\n                console.log(data); //receive pipeline results here\n\n                console.log('offloadingOutput$ Offloaded Result =');\n                let msg = JSON.stringify(data);\n                msg = 'offloadingOutput$ '+msg;\n                console.log(msg);\n                peer.disconnect();\n\n            });\n\n\n        }\n\n        }\n    });\n\n}\nmodule.exports =dataProcessingDevice","\nlet availableOffloadingResources = require(\"../offloading/availableOffloadingResources\");\n\nfunction createPeer(id, callback = () => {\n}) {\n    let peer = new Peer(id, {\n        host: \"milki-psy.dbis.rwth-aachen.de\", //localhost\n        port: 443, //9001\n        path: \"/offloadingNetwork\",\n    });\n    peer.on('open', function (ID) {\n        console.log('offloadingOutput$ My peer ID is = ' + ID);\n        callback();\n    });\n    peer.on(\"error\", function (err) {\n        console.log(\"Error: \" + err);\n    });\n    peer.on('disconnected', function (ID) {\n        console.log('peer ID ' + ID+' disconnected');\n        callback();\n    });\n\n    return peer;\n}\n\nfunction potentialOffloadingTarget() {\n    let peer = createPeer('', () => {\n        peer.on('connection', (co)=>{\n            console.log('offloadingOutput$ I am chosen by Source Peer !');\n            co.on('data', (data)=>{\n                // Process Pipeline and send result\n                console.log('Data received from Source = ',data);\n                //TODO: is there a way to check if received date is really a pipeline ? yes\n                //TODO: user input ?\n                console.log('offloadingOutput$ Processing offloaded pipeline ...');\n                // setup and process the pipeline\n                processPipeline(data).then((result)=>{\n                    //send pipeline result\n                    console.log('OFFLOADING RESULT = ');\n                    console.log(result);\n                    console.log('offloadingOutput$ Finished processing the offloaded pipeline')\n                    co.send(result);\n                    console.log('offloadingOutput$ Result sent to offloading source peer')\n\n                }).catch(error => {\n                    console.error(error);\n                });\n            });\n        });\n\n        const connection = peer.connect('source');\n        connection.on('open', () => {\n            console.log('offloadingOutput$ connected to peer = '+connection.peer);\n\n            //TODO: get input from execution manager GET frontend.\n            //input offloading resources limits MUST be global value from user input (frontend)\n            let orList= sweva.ExecutionManager.getORList();\n            console.log('orList GET in potentialOffloadingTarget = ',orList);\n            availableOffloadingResources(orList).then(result => {\n\n                console.log('result is =',result);\n\n                    //push string 'dmi' as last entry in the array\n                    result.push('dmi');\n                    console.log(result);\n                    //send dmi as array\n                    connection.send(result);\n\n            }).catch(error => {\n                console.error(error);\n            });\n        });\n    });\n}\nfunction formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    const size = parseFloat((bytes / Math.pow(k, i)).toFixed(dm));\n\n    return `${size} ${sizes[i]}`;\n}\nfunction formatTime(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000) % 60;\n    const minutes = Math.floor(milliseconds / (1000 * 60)) % 60;\n\n    const formattedTime = [];\n\n    if (minutes > 0) {\n        formattedTime.push(minutes + (minutes === 1 ? ' minute' : ' minutes'));\n    }\n    if (seconds >0){\n        formattedTime.push(seconds + (seconds === 1 ? ' second' : ' seconds'));\n    }\n\n    return formattedTime.join(', ');\n}\n\n//TODO: process pipeline in exe\nasync function processPipeline(receivedPipeline){\n    //TODO: extract intermediate result from pipeline with a new key in the object\n\n    console.log('entered processPipeline is POT ...');\n    console.log(receivedPipeline);\n\n    let {intermediatePipeline:ob1, intermediatePipelineResults:ob2} = receivedPipeline;\n    console.log('pipeline = ',ob1);\n    console.log('pipeline inputs = ',ob2);\n    let pipeline = JSON.parse(ob1);\n    let pipelineInputs = JSON.parse(ob2);\n    console.log('pipeline = ', pipeline);\n    console.log('pipeline inputs = ', pipelineInputs);\n\n\n    try {\n            let manager = new sweva.ExecutionManager();\n            manager.setup(pipeline);\n\n            let startMemExecute = performance.memory.usedJSHeapSize;\n            let startTimeExecute = Date.now();\n            let offloadedResult = await manager.execute(pipelineInputs, {});\n            let endTimeExecute = Date.now();\n            let endMemExecute = performance.memory.usedJSHeapSize;\n            console.log('OUTPUT offloaded msg = ',offloadedResult);\n            console.log('offloadingOutput$ Offloaded task Execution time: ',formatTime(endTimeExecute-startTimeExecute));\n            console.log('offloadingOutput$ Offloaded task Execution Memory: ',formatBytes(endMemExecute-startMemExecute));\n            return offloadedResult;\n            }\n        catch (e){\n            console.log('Error encountered while executing the offloaded pipeline = ',e,'\\nPlease try again');\n            return 'Error encountered while executing the offloaded pipeline. Please try again';\n    }\n\n}\n\nmodule.exports = potentialOffloadingTarget","//USER input orList:\n\n// for Web environment:\n// orList = [mem%, battery%, isCharging (binary)]\n\n//for Node.JS environment:\n// orList = [cpu%, mem%, battery%, isCharging (binary)]\n\nasync function availableOffloadingResources(orList) {\n    if (orList[0] === 0 || orList[1] === 0) {\n        return [0,0,0,false];\n    }\n\n    let cpuLoad = 0;\n    let memUsage = 0;\n    let batteryPercent = 0;\n    let batteryIsCharging = false;\n\n    let listOfMetrics =[];\n    if (typeof window !== 'undefined') {\n\n        //Browser environment\n        memUsage = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100;\n        let battery = await navigator.getBattery();\n        batteryPercent = battery.level * 100;\n        batteryIsCharging = battery.charging;\n        console.log('memUsage = ',memUsage,'battery = ',batteryPercent, 'isCharging = ',batteryIsCharging);\n\n    }else{\n        //NodeJS environment\n        let si = require('systeminformation');\n\n        await Promise.all ([\n            si.currentLoad(),\n            si.mem(),\n            si.battery()\n        ]).then(([cpu, mem, battery]) => {\n            let memRSS = process.memoryUsage();\n            memUsage =  (memRSS.rss / mem.available) * 100;\n            cpuLoad = cpu.avgLoad;\n            batteryPercent = battery.percent;\n            batteryIsCharging = battery.acConnected;\n            //current cpu load higher than user limit (only for Node.js environment)\n            if (cpuLoad > orList[0]){\n                return [0,0,0,false]\n            }\n            //console.log('cpu = ',cpuLoad, 'memUsage = ',memUsage,'battery = ',batteryPercent, 'isCharging = ',batteryIsCharging);\n        }).catch((err) => {\n            console.log('Error occurred extracting metrics in the NodeJS environment. ERROR = ' + err);\n        });\n    }\n\n    if (\n        memUsage > orList[0] || // mem usage is higher than limit\n        batteryPercent < orList[1] || // battery is lower than minimum set by user\n        batteryIsCharging !== orList[2]\n    )\n    {\n        console.log('offloadingOutput$ Peer not strong enough for the offloaded task')\n        return [0,0,0,false]\n    }\n    else{\n    //Output metrics in percent %\n        listOfMetrics.push(cpuLoad,(100-memUsage),batteryPercent,batteryIsCharging);\n        console.log('offloadingOutput$ Peer is strong enough to process the offloaded task')\n        return listOfMetrics;\n\n    }\n\n}\nmodule.exports = availableOffloadingResources\n\n/*\n// TEST function for Node.js environment\nsetInterval(() =>{\nconst startTime = process.hrtime();\navailableOffloadingResources([0,10,10,true]).then((result) => {\n    const endTime = process.hrtime(startTime);\n    console.log(result);\n    console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\n\n});},3000);\n*/\n\n","/*\n*\nUse this function to monitor any SWeVA execution and determine necessity of offloading\nbased on CPU , Memory and Battery metrics. This function can be used in both\nWeb and NodeJS environments !\n* USER Input odList = [Limit_cpu %, Limit_mem %, Limit_battery %]\n*/\n\nasync function offloadingDecision(odList) {\n    if (odList[0] === 0 || odList[1] === 0 || odList[2] === 0) {\n        return true;\n    }\n    let cpuLoad = 0;\n    let memUsage = 0;\n    let batteryPercent = 0;\n    let offloading = false;\n    if (typeof window !== 'undefined') {\n\n        //Browser environment\n        memUsage = (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100;\n        let battery = await navigator.getBattery();\n        batteryPercent = battery.level * 100;\n        //console.log('Measured mem = ',memUsage,'battery = ',batteryPercent);\n\n    } else {\n\n        //NodeJS environment\n        let si = require('systeminformation');\n\n        await Promise.all ([\n            si.currentLoad(),\n            si.mem(),\n            si.battery()\n        ]).then(([cpu, mem, battery]) => {\n            let memRSS = process.memoryUsage();\n            memUsage = (memRSS.rss / mem.available) * 100;\n            cpuLoad = cpu.avgLoad;\n            batteryPercent = battery.percent;\n            console.log('cpu = ',cpuLoad, 'mem = ',memUsage,'battery = ',batteryPercent);\n        }).catch((err) => {\n            console.log('Error occurred extracting metrics in the NodeJS environment. ERROR = ' + err);\n        });\n    }\n            if (cpuLoad > odList[0]) {\n                console.log('offloadingOutput$ Monitoring = CPU limit exceeded');\n                offloading = true;\n            } else if (memUsage > odList[1]) {\n                console.log('offloadingOutput$ Monitoring = Memory limit exceeded');\n                offloading = true;\n            } else if (batteryPercent < odList[2]) {\n                console.log('offloadingOutput$ Monitoring = Battery limit exceeded');\n                offloading = true;\n            }\n\n    return offloading;\n}\nmodule.exports = offloadingDecision\n\n\n\n\n/*\n// TEST function for Node.js environment\n\n//let time =0;\nlet i=0;\nlet odList =[10,10,90];\nlet startTime = null;\nlet endTime =null;\nlet avgList=[] ;\n\n\nsetInterval(()=>{\n       startTime = process.hrtime();\n       offloadingDecision(odList).then ((result)=>{\n       endTime = process.hrtime(startTime);\n\n       console.log('Monitoring Round #'+i);\n       i++;\n       console.log(result);\n       console.log('Elapsed time: '+(endTime[0] * 1000 + endTime[1] / 1000000).toFixed(2)+ ' ms');\n   });\n\n\n},3000);\n*/\n\n\n","\n// orList = [cpu%, mem%, battery%, isCharging (binary)]\n\nfunction decisionValueOfPOT(offloadingResourcesList){\n    let advantageCPU = 1-offloadingResourcesList[0]; //Node.js env. only\n\n    let advantageMem = offloadingResourcesList[1]; // free memory in %\n\n    //battery is charging= MAX advantage !\n    let advantageBattery = 0;\n    //battery is not charging\n    if (!offloadingResourcesList[3]){\n        advantageBattery = 100-offloadingResourcesList[2];\n    }\n    //return advantageCPU + advantageMem - advantageBattery;\n    return advantageCPU + advantageMem - advantageBattery;\n}\n\n\n//We qualify by \"best\" the peer with highest current computation and battery\n\n//input iDandORpairs= { id : [ or list ] }\nfunction offloadingTarget (iDandORpairs){\n    let bestPOTId=null;\n    let temp = 0;\n    for ( let key in iDandORpairs ){\n\n        let dpot = decisionValueOfPOT(iDandORpairs[key]);\n        console.log('PEER = '+key+' DPOD = '+dpot);\n        if ( dpot>temp){\n            temp=dpot;\n            bestPOTId=key;\n        }\n    }\n    console.log('offloadingOutput$ best POT is = ',bestPOTId);\n    return bestPOTId;\n}\nmodule.exports = offloadingTarget\n\n/*\n//for testing purposes (Node.js env.)\nlet pairs = {\n    'id1' : [10,20,60,false],\n    'id2' : [50,30,100,false],\n    'id3' : [99,40,10,true],\n    'id4' : [ 0.00, 73.20, 80, false ]\n}\noffloadingTarget(pairs);\n*/\n","'use strict';\n\nvar AsBind = require('../../../node_modules/as-bind/dist/as-bind.cjs.js');\nvar Runner = require('../../core/runners/runner.js');\nvar Compiler = require('../../core/compilers/assemblyScriptCompiler.js');\nvar Composable = require('../../core/composables/composable.js');\nvar ExecutionError = require('../../core/errors/ExecutionError.js');\nvar DefinitionError = require('../../core/errors/ExecutionError.js');\nvar SupportLibrary = require('../../core/execution/supportLibrary.js');\n\n\n/**\n * Parameters in the AssemblyScript run function starting with this string are used for the user inputs.\n */\nconst userInputSeparator = \"input_\";\n\n/**\n * The AssemblyScript runner supports strict TypeScript\n *\n * @constructor\n * @extends Runner\n *\n */\nfunction AssemblyScriptRunner() {\n    this.supportLib = new SupportLibrary();\n    this.supportLib.loadHTTP();\n    this.supportLib.loadLogger();\n    this.supportLib.loadTestSync();\n    this.compiler = new Compiler(this.supportLib);\n}\n\nAssemblyScriptRunner.prototype.getHTMLDescription = function () {\n    let description = \"Find the official AssemblyScript documentation on <a href='https://www.assemblyscript.org/introduction.html' target='_blank'>assemblyscript.org</a>.\\n\" +\n        \"The exported <b>run</b> function will be called with the parameters as data inputs and returned data as an output called <b>out</b>. User inputs have to be prefixed with <b>input_</b> and be the first parameters.\\n\" +\n        \"Additional outputs are generated for exported global variables. This allows returning values resulting from asynchronous callbacks.\\n\" +\n        \"If the <b>run</b> function has the return type \\\"void\\\" no default output is generated.\\n\";\n    description += \"\\n\" + this.compiler.supportLibraryDocumentation;\n\n    //HTML new lines\n    description.replaceAll(\"\\n\", \"<br>\");\n    return description;\n};\n\n//inherit properties\nAssemblyScriptRunner.prototype = Object.create(Runner.prototype);\nAssemblyScriptRunner.prototype.constructor = AssemblyScriptRunner;\n\nAssemblyScriptRunner.prototype.name = \"TypeScript (using AssemblyScript)\";\nAssemblyScriptRunner.prototype.id = \"typescript\";\n\n//=== OFFLOADING === Module => ASC code to WASM binary\nAssemblyScriptRunner.prototype.prepare = async function (module, callbackList = []) {\n    let definitionData = null;\n\n    if (!module.binary || module.binary.length === 0 || module.binaryHash !== this.calculateBinaryHash(module.binary)) {\n        module.binaryHash = null;\n        // monitored compilation in ASCcompiler.js\n        let compilerResult = await this.compiler.compile(module);\n            console.log('compilerResult');\n            console.log(compilerResult);\n            if (compilerResult === 'offloading') {\n                //todo: Offloading needed\n                console.log(\"offloading intercepted in ASCRunner.prepare()\")\n                return 'offloading';\n            } else {\n                module.binary = compilerResult.binaryData;\n                module.binaryHash = this.calculateBinaryHash(module.binary);\n                definitionData = compilerResult.definitionData;\n            }\n        }\n\n    const moduleInstance = await AsBind.instantiate(module.binary, {\n        module: this.generateFunctionDescription(callbackList)\n    });\n\n    if (definitionData != null)\n        this.createDataSchema(module, moduleInstance, definitionData);\n\n    return moduleInstance;\n}\n\n\n/**\n *  wrapper for\n */\nAssemblyScriptRunner.prototype.generateFunctionDescription = function (callbackList) {\n    let functions = {};\n\n    for (let funcName in this.supportLib.functions) {\n        let funcDesc = this.supportLib.functions[funcName];\n        let functionReference;\n\n        if (funcDesc.async) {\n            //params has callback name as first argument followed by regular parameters\n            functionReference = function (...params) {\n                let callbackName = params[0];\n                params.shift();\n\n                callbackList.push({\n                    promise: funcDesc.func(...params),\n                    params: params,\n                    funcName: funcName,\n                    callbackName: callbackName\n                });\n            }\n        } else {\n            functionReference = funcDesc.func;\n        }\n\n        functions[\"lib.\" + funcName] = functionReference;\n    }\n    return functions;\n}\n\nAssemblyScriptRunner.prototype.exec = async function (module, data, input) {\n\n    let callbackList = [];\n    /*\n    console.log(\"///////////// ASC runner inputs //////////////\");\n    console.log(\"module\");\n    console.log(module);\n    console.log(\"data\");\n    console.log(data);\n    console.log(\"input\");\n    console.log(input);\n    console.log(\"///////////////////////////\");\n     */\n    //compile and update schema\n    let instance = await this.prepare(module, callbackList);\n    console.log('instance');\n    console.log(instance);\n    if (instance === 'offloading') {\n        console.log('offloading intercepted in ASCRunner.exec()');\n        return 'offloading';\n\n    }\n    console.log('module prepared= ');\n    console.log(module);\n\n    let preparedParams = [];\n    if (module.inputNames.length > 0)\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.inputNames, input, module.context));\n    if (module.dataInNames.length > 0)\n        preparedParams = preparedParams.concat(this.findParamAssignment(module.dataInNames, data, module.context));\n\n    //Module input\n    console.log('Module source code input');\n    console.log(preparedParams);\n\n    // returnValue returns the result from the binary execution of the WASM module\n    //todo execute this after checking DMI ! if() else ...\n    // TODO Promise.Race here!!!!!!!!\n    let returnValue = instance.exports.run(...preparedParams);\n    console.log('returnValue = ');\n    console.log(returnValue);\n\n    //finish executing all asynchronous functions ( if callback functions are needed by the module )\n    while (callbackList.length > 0) {\n        console.log(\"Remaining Callback: \");\n        console.log(callbackList[0]);\n        let result = null;\n        try {\n            //todo: monitor this?\n            result = await callbackList[0].promise;\n\n        } catch (err) {\n            throw new ExecutionError(\"Error in support function \" + callbackList[0].funcName + \" with parameters \" + callbackList[0].params + \"!\", module.context);\n        }\n\n        if (result !== null) {\n\n            let callbackDescriptor = instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName];\n            if (!callbackDescriptor)\n                throw new DefinitionError(\"Callback function with name \" + callbackList[0].callbackName + \" not found!\", module.context);\n\n            try {\n                if (callbackList[0].callbackName != null && callbackList[0].callbackName !== \"\") {\n                    //match number of parameters of callback\n                    let callbackParamCount = callbackDescriptor.parameters.length;\n                    let preparedResult = result.slice(0, callbackParamCount);\n                    console.log(instance.typeDescriptor.exportedFunctions[callbackList[0].callbackName]);\n\n                    //Todo: do something with callback returns?\n                    let returnValue = instance.exports[callbackList[0].callbackName](...preparedResult);\n\n                    if (returnValue)\n                        console.log(\"Callback return: \" + returnValue);\n                }\n            } catch (err) {\n                throw new ExecutionError(\"Error while calling callback function \" + callbackList[0].callbackName + \" with parameters '\" + result + \"'!\", module.context);\n            }\n        }\n        callbackList.shift();\n    }\n    return this.collectOutputData(instance, returnValue);\n}\n\nAssemblyScriptRunner.prototype.collectOutputData = function (moduleInstance, returnValue) {\n    let result = {};\n\n    if (returnValue !== undefined) {\n        result.out = returnValue;\n    }\n    console.log('AsBind');\n    console.log(AsBind);\n    console.log('moduleInstance');\n    console.log(moduleInstance);\n\n\n    for (let exportedObj in moduleInstance.exports) {\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\n            result[exportedObj] = moduleInstance.exports[this.compiler.internalGetterPrefix + exportedObj]();\n        }\n    }\n    console.log('result');\n    console.log(result);\n    return result;\n}\n\nAssemblyScriptRunner.prototype.findParamAssignment = function (names, values, context) {\n    let preparedParams = [];\n    for (let i in names) {\n        let matchFound = false;\n        if (values !== undefined && values != null) {\n            for (let inputName in values) {\n                if (names[i] === inputName) {\n                    preparedParams.push(values[inputName]);\n                    matchFound = true;\n                }\n            }\n        }\n        if (!matchFound)\n            throw new DefinitionError(\"Mismatch between received and expected parameters!\\nExpected \\\"\" + names[i] + \"\\\", but not contained in received parameters: \" + JSON.stringify(values), context);\n    }\n    return preparedParams;\n}\n\n\nAssemblyScriptRunner.prototype.parseAssemblyScriptVariableNames = function (definitionData) {\n    let paramNames = Array();\n    let lines = definitionData.split(\"\\n\");\n    for (let line in lines) {\n        if (lines[line].indexOf(\"export function run\") === 0) {\n            let params = lines[line].substring(lines[line].indexOf('(') + 1, lines[line].indexOf(')')).split(', ');\n            for (let i in params) {\n                let paramName = params[i].substring(0, params[i].indexOf(\":\"));\n                if (paramName.length > 0)\n                    paramNames.push(paramName);\n            }\n        }\n    }\n    return paramNames;\n}\n\nAssemblyScriptRunner.prototype.createDataSchema = function (module, moduleInstance, definitionData) {\n    let run = moduleInstance.typeDescriptor.exportedFunctions.run;\n\n    //verify entrypoint exists\n    if (run === undefined)\n        throw new DefinitionError(\"Missing entrypoint: exported function named run is required, as an entrypoint.\", module.context);\n\n    //inputs\n    //parse parameter names of run function - replace, if AssemblyScript API, to access parameter names becomes available\n    let paramNames = this.parseAssemblyScriptVariableNames(definitionData);\n\n    if (run.parameters.length !== paramNames.length)\n        throw new DefinitionError(\"Parameter length mismatch! Parameters could not be parsed fully!\", module.context);\n\n    module.dataInNames = [];\n    module.inputNames = [];\n    module.dataInSchema = {type: \"object\", properties: {}};\n    module.inputSchema = {type: \"object\", properties: {}};\n\n    for (let i in run.parameters) {\n        if (paramNames[i].startsWith(userInputSeparator)) {\n            module.inputNames.push(paramNames[i]);\n\n            module.inputSchema.properties[paramNames[i]] = {type: run.parameters[i]};\n        } else {\n            module.dataInNames.push(paramNames[i]);\n\n            module.dataInSchema.properties[paramNames[i]] = {type: run.parameters[i]};\n        }\n    }\n\n    //outputs\n    module.dataOutNames = [];\n    module.dataOutSchema = {type: \"object\", properties: {}};\n    for (let exportedObj in moduleInstance.exports) {\n        if (moduleInstance.exports[exportedObj] instanceof WebAssembly.Global && !exportedObj.startsWith(\"__\")) {\n            module.dataOutNames.push(exportedObj);\n            module.dataOutSchema.properties[exportedObj] = {type: moduleInstance.typeDescriptor.exportedFunctions[this.compiler.internalGetterPrefix + exportedObj]}\n        }\n    }\n    if (run.returnType !== 'void') {\n        if (!module.dataOutNames.includes('out')) {\n            module.dataOutNames.push('out');\n            module.dataOutSchema.properties['out'] = {type: run.returnType}\n        } else {\n            throw new DefinitionError(\"Duplicate parameter called 'out'! Do not use 'out' as a name for exported variables!\", module.context);\n        }\n    }\n}\n\n\nmodule.exports = AssemblyScriptRunner;","'use strict';\n\n\n/**\n * The runner executes the compiled code made available by the compiler and contains a reference to the matching compiler\n * It has two phases: A setup phase, were all dependencies are loaded and initialized and an operational phase, which is used to compile code\n * The setup needs to be done only once, while the execution can be repeated on different data.\n * \n * This is a default implementation, which should be subclassed for each supported language\n * \n * @constructor\n * @abstract\n */\nfunction Runner() {\n    /**\n    * Determines, if dependencies are loaded.\n    * @name ExecutionManager#modulesTotal\n    * @type {boolean}\n    */\n    this.setupCompleted = false;\n}\n\n/**\n * Run the provided binary or source code\n * @param {module} module - module containing source code/binary to run\n * @param {Object} data - data passed to the processing node\n * @param {Object} input - inputs passed to the processing node\n * @abstract\n */\nRunner.prototype.exec = function (module, data, input) {\n}\n\n/**\n * Prepare the provided module for execution:\n * - compile, if not already compiled\n * - update references to binary/hash\n * - update data schemes\n * This is also used to validate new source code while editing\n *\n * @param {module} module - module containing source code/binary to run\n * @return {Object} instance ready to execute\n * @throws CompileError\n *\n * @abstract\n */\nRunner.prototype.prepare = function (module) {}\n\n/**\n * End user friendly Name\n */\nRunner.prototype.name = \"Abstract Runner\"\n\n/**\n * ID used internally, to identify runners\n */\nRunner.prototype.id = \"abstract_runner\"\n\n/**\n * @return Description of the runner including a link to the official documentation and support library explanation as html.\n * @abstract\n */\nRunner.prototype.getHTMLDescription = function () {}\n\n\n/**\n * Calculates Hash used to compare binaries\n *\n * @param {Uint8Array} binary - binary to hash\n * @return hash\n *\n */\nRunner.prototype.calculateBinaryHash = function (binary) {\n    let hash = 0;\n    for(let i in binary) {\n        hash = ((hash << 8)-hash)+binary[i];\n    }\n    return hash;\n}\n\n/**\n * Determine data schema based on source/binary and write results to the module\n * The properties dataInSchema, dataOutSchema, inputSchema, dataInNames, dataOutNames, inputNames of the module can be written\n * Called automatically, when new source is compiled, but can be used to manually regenerate data schema\n *\n * @param {module} module - module containing source code/binary\n *\n * @abstract\n */\nRunner.prototype.createDataSchema = function (module) {\n}\n\nmodule.exports = Runner","'use strict';\nvar JsTokens = require('../../../node_modules/js-tokens/index.js');\n/**\n * Responsible to verify if a string complies to a safe  JavaScript subset.\n * A blacklist used to ensure no harmful operation can be performed by user defined scripts.\n * Currently the following tokens are forbidden:\n * arguments, callee, caller, constructor, eval, prototype, stack, unwatch, valueOf, watch, __proto__, __parent__, 'this', window, document, '[', ']', Function, 'with', uneval, toSource, setTimeout, setInterval\n * Use {@link SwevaScript#get} as a replacement for [].\n * \n * Additionally global variables are masked.\n * @constructor \n */\nfunction SwevaScript() {\n    /**\n    * List of forbidden tokens, that are not allowed in this JavaScript subset.\n    * @name SwevaScript#forbiddenList\n    * @type {Object.<string, boolean>}\n    */\n    this.forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    /**\n    * List of allowed global variables, that should not be masked.\n    * This is currently: Math, console \n    * @name SwevaScript#allowedGlobals\n    * @type {Object.<string, boolean>}\n    */\n    this.allowedGlobals = {\n        Math: true,\n        console: true,\n        'true': true,\n        'false': true\n    }\n}\n\n/**\n * Verifies if a JavaScript code complies to the safer JavaScript subset.\n * Does not rewrite or change the code, therefor you should DENY anything, that is considered harmful by this function.\n * \n * @param {string} code - The JavaScript code to verify for safety.\n * @returns {boolean} True, if the code does not contain forbidden tokens.\n */\nSwevaScript.prototype.verify = function (code) {\n    try {\n        //get an array of tokens using the tokenizer (external library)\n        var tokens = code.match(JsTokens);\n    } catch (e) {\n        return {\n            valid: false,\n            error: e.message\n        }\n    }\n   \n    //check for each token\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i].trim();\n        if (token.length > 0) {\n            //if token non empty: is it in the blacklist?\n            if (this.forbiddenList.hasOwnProperty(token)) {\n                return {\n                    valid: false,\n                    error: 'Invalid usage of ' + token\n                };\n            }\n        }\n\n        \n    }\n\n    //if no return reached before, we can assume there was no forbidden token present\n    return {\n        valid: true,\n        error: ''\n    }\n};\n\n/**\n * Replaces the forbidden [] accessor, by checking the property name during runtime.\n * If a forbidden property (see {@link SwevaScript}) is used, the property is not accessed.\n * \n * @param {Object} object - The object from which the property value is required.\n * @param {string|number} property - The name of the property to retrieve the value from.\n * returns {Object|boolean|string|number} - The value of the property, if an illegal property name is used null.\n */\nSwevaScript.prototype.get = function (object, property) {\n    var forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    //if a string is provided, check for being in the blacklist\n    if (typeof property === 'string') {\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\n            return object[property];\n        }\n    }\n    //numbers are not checked for being in the blacklist\n    else if (typeof property === 'number') {\n        return object[property];\n    }\n\n    console.error('Illegal property name: ' + property);\n    return null;\n}\n\nSwevaScript.prototype.set = function (object, property, value) {\n    var forbiddenList = {\n        arguments: true,\n        callee: true,\n        caller: true,\n        constructor: true,\n        eval: true,\n        prototype: true,\n        stack: true,\n        unwatch: true,\n        valueOf: true,\n        watch: true,\n\n        __proto__: true,\n        __parent__: true,\n        'this': true,\n        window: true,\n        document: true,\n        '[': true,\n        ']': true,\n        Function: true,\n        'with': true,\n        uneval: true,\n        toSource: true,\n        setTimeout: true,\n        setInterval: true\n    }\n    //if a string is provided, check for being in the blacklist\n    if (typeof property === 'string') {\n        if (!object.window && !forbiddenList.hasOwnProperty(property)) {\n            object[property] = value;\n        }\n        else {\n            console.error('Illegal property name: ' + property);\n        }\n    }\n    //numbers are not checked for being in the blacklist\n    else if (typeof property === 'number') {\n        object[property] = value;\n    }\n};\n\n/**\n * Sanitizes given Javascript code by verifying if it is a safer subset of JavaScript and masking global variables.\n * {@link SwevaScript#verify} is performed internally, so you do not need to verify explicitly beforehand.\n * @param {string} code - The JavaScript function to sanitize.\n * @param {function} errorCallback - A callback called, when an error occurs, has a string as a parameter with the error message.\n * @returns{function} - A function, that can be executed\n */\nSwevaScript.prototype.sanitize = function (code, errorCallback) {\n    //all in one line\n    //code = code.replace(/(\\r\\n|\\n|\\r)/gm, \"\"); \n   \n    var error = '';\n    //first make sure it is valid SwevaScript\n    var validation = this.verify(code);    \n    if (validation.valid) {        \n        var allowedGlobals = this.allowedGlobals;\n        //get all global variables except the exceptions we defined in {@link SwevaScript#allowedGlobals}\n        var globals = Object.keys(window).filter(function (obj) {\n            return !allowedGlobals.hasOwnProperty(obj)\n        }).join(',');\n        //we want to shadow all global variables except the ones we allow, by declaring them as local variables\n        //https://stackoverflow.com/posts/26917938/revisions\n        //var funcReg = /function *\\(([^()]*)\\)[ \\n\\t]*{(.*)}/gmi;\n        var funcReg = /function\\s*\\(([^()]*)\\)\\s\\{((.|\\n)*)\\}/gmi;\n        var match = funcReg.exec(code);\n       \n        //we extract funtion header (decrlaration with parameters) and body\n        if (match) {\n            \n            //enforce strict behavior, shadow globals, append verified code\n            var fn_text = '\"use strict\"; var ' + globals + ';' + match[2] + ';';\n            \n            var fn = new Function(match[1].split(','), fn_text);//generate sanitized function\n\n            return fn;\n        }\n        else {\n            error = 'Not a valid JS function';\n        }\n    }\n    else {\n        error = validation.error;\n    }\n    if (typeof errorCallback === 'function') {\n        errorCallback(error);\n    }\n    \n    return null;\n}\n\nmodule.exports = SwevaScript;","'use strict';\n\nvar compileSchema = require('./compile')\n    , resolve = require('./compile/resolve')\n    , Cache = require('./cache')\n    , SchemaObject = require('./compile/schema_obj')\n    , stableStringify = require('json-stable-stringify')\n    , formats = require('./compile/formats');\n\nmodule.exports = Ajv;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';\nvar SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i;\nfunction SCHEMA_URI_FORMAT_FUNC(str) {\n    return SCHEMA_URI_FORMAT.test(str);\n}\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n    if (!(this instanceof Ajv)) return new Ajv(opts);\n    var self = this;\n\n    this.opts = opts || {};\n    this._schemas = {};\n    this._refs = {};\n    this._formats = formats(this.opts.format);\n    this._cache = this.opts.cache || new Cache;\n    this._loadingSchemas = {};\n\n    // this is done on purpose, so that methods are bound to the instance\n    // (without using bind) so that they can be used without the instance\n    this.validate = validate;\n    this.compile = compile;\n    this.compileAsync = compileAsync;\n    this.addSchema = addSchema;\n    this.addMetaSchema = addMetaSchema;\n    this.validateSchema = validateSchema;\n    this.getSchema = getSchema;\n    this.removeSchema = removeSchema;\n    this.addFormat = addFormat;\n    this.errorsText = errorsText;\n\n    this._compile = _compile;\n\n    addInitialSchemas();\n    if (this.opts.formats) addInitialFormats();\n\n\n    /**\n     * Validate data using schema\n     * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     * @param  {Any} data to be validated\n     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n     */\n    function validate(schemaKeyRef, data) {\n        var v;\n        if (typeof schemaKeyRef == 'string') {\n            v = getSchema(schemaKeyRef);\n            if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n        } else {\n            var schemaObj = _addSchema(schemaKeyRef);\n            v = schemaObj.validate || _compile(schemaObj);\n        }\n\n        var valid = v(data);\n        self.errors = v.errors;\n        return valid;\n    }\n\n\n    /**\n     * Create validating function for passed schema.\n     * @param  {String|Object} schema\n     * @return {Function} validating function\n     */\n    function compile(schema) {\n        var schemaObj = _addSchema(schema);\n        return schemaObj.validate || _compile(schemaObj);\n    }\n\n\n    /**\n     * Create validating function for passed schema with asynchronous loading of missing schemas.\n     * `loadSchema` option should be a function that accepts schema uri and node-style callback.\n     * @param  {String|Object} schema\n     * @param  {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.\n     */\n    function compileAsync(schema, callback) {\n        var schemaObj;\n        try {\n            schemaObj = _addSchema(schema);\n        } catch(e) {\n            setTimeout(function() { callback(e); });\n            return;\n        }\n        if (schemaObj.validate)\n            setTimeout(function() { callback(null, schemaObj.validate); });\n        else {\n            if (typeof self.opts.loadSchema != 'function')\n                throw new Error('options.loadSchema should be a function');\n            _compileAsync(schema, callback, true);\n        }\n    }\n\n\n    function _compileAsync(schema, callback, firstCall) {\n        var validate;\n        try { validate = compile(schema); }\n        catch(e) {\n            if (e.missingSchema) loadMissingSchema(e);\n            else deferCallback(e);\n            return;\n        }\n        deferCallback(null, validate);\n\n        function loadMissingSchema(e) {\n            var ref = e.missingSchema;\n            if (self._refs[ref] || self._schemas[ref])\n                return callback(new Error('Schema ' + ref + ' is loaded but' + e.missingRef + 'cannot be resolved'));\n            var _callbacks = self._loadingSchemas[ref];\n            if (_callbacks) {\n                if (typeof _callbacks == 'function')\n                    self._loadingSchemas[ref] = [_callbacks, schemaLoaded];\n                else\n                    _callbacks[_callbacks.length] = schemaLoaded;\n            } else {\n                self._loadingSchemas[ref] = schemaLoaded;\n                self.opts.loadSchema(ref, function (err, sch) {\n                    var _callbacks = self._loadingSchemas[ref];\n                    delete self._loadingSchemas[ref];\n                    if (typeof _callbacks == 'function')\n                        _callbacks(err, sch);\n                    else\n                        for (var i=0; i<_callbacks.length; i++)\n                            _callbacks[i](err, sch);\n                });\n            }\n\n            function schemaLoaded(err, sch) {\n                if (err) callback(err);\n                else {\n                    if (!(self._refs[ref] || self._schemas[ref])) {\n                        try {\n                            addSchema(sch, ref);\n                        } catch(e) {\n                            callback(e);\n                            return;\n                        }\n                    }\n                    _compileAsync(schema, callback);\n                }\n            }\n        }\n\n        function deferCallback(err, validate) {\n            if (firstCall) setTimeout(function() { callback(err, validate); });\n            else callback(err, validate);\n        }\n    }\n\n\n    /**\n     * Adds schema to the instance.\n     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` will be ignored.\n     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n     */\n    function addSchema(schema, key, _skipValidation, _meta) {\n        if (Array.isArray(schema)){\n            for (var i=0; i<schema.length; i++) addSchema(schema[i]);\n            return;\n        }\n        // can key/id have # inside?\n        key = resolve.normalizeId(key || schema.id);\n        checkUnique(key);\n        var schemaObj = self._schemas[key] = _addSchema(schema, _skipValidation);\n        schemaObj.meta = _meta;\n    }\n\n\n    /**\n     * Add schema that will be used to validate other schemas\n     * removeAdditional option is alway set to false\n     * @param {Object} schema\n     * @param {String} key optional schema key\n     */\n    function addMetaSchema(schema, key, _skipValidation) {\n        addSchema(schema, key, _skipValidation, true);\n    }\n\n\n    /**\n     * Validate schema\n     * @param  {Object} schema schema to validate\n     * @return {Boolean}\n     */\n    function validateSchema(schema) {\n        var $schema = schema.$schema || META_SCHEMA_ID;\n        var currentUriFormat = self._formats.uri;\n        self._formats.uri = typeof currentUriFormat == 'function'\n                            ? SCHEMA_URI_FORMAT_FUNC\n                            : SCHEMA_URI_FORMAT;\n        var valid = validate($schema, schema);\n        self._formats.uri = currentUriFormat;\n        return valid;\n    }\n\n\n    /**\n     * Get compiled schema from the instance by `key` or `ref`.\n     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n     * @return {Function} schema validating function (with property `schema`).\n     */\n    function getSchema(keyRef) {\n        var schemaObj = _getSchemaObj(keyRef);\n        switch (typeof schemaObj) {\n            case 'object': return schemaObj.validate || _compile(schemaObj);\n            case 'string': return getSchema(schemaObj);\n        }\n    }\n\n\n    function _getSchemaObj(keyRef) {\n        keyRef = resolve.normalizeId(keyRef);\n        return self._schemas[keyRef] || self._refs[keyRef];\n    }\n\n\n    /**\n     * Remove cached schema\n     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references\n     * @param  {String|Object} schemaKeyRef key, ref or schema object\n     */\n    function removeSchema(schemaKeyRef) {\n        switch (typeof schemaKeyRef) {\n            case 'string':\n                var schemaObj = _getSchemaObj(schemaKeyRef);\n                self._cache.del(schemaObj.jsonStr);\n                delete self._schemas[schemaKeyRef];\n                delete self._refs[schemaKeyRef];\n                break;\n            case 'object':\n                var jsonStr = stableStringify(schemaKeyRef);\n                self._cache.del(jsonStr);\n                var id = schemaKeyRef.id;\n                if (id) {\n                    id = resolve.normalizeId(id);\n                    delete self._refs[id];\n                }\n        }\n    }\n\n\n    function _addSchema(schema, skipValidation) {\n        if (typeof schema != 'object') throw new Error('schema should be object');\n        var jsonStr = stableStringify(schema);\n        var cached = self._cache.get(jsonStr);\n        if (cached) return cached;\n\n        var id = resolve.normalizeId(schema.id);\n        if (id) checkUnique(id);\n\n        var ok = skipValidation || self.opts.validateSchema === false\n                 || validateSchema(schema);\n        if (!ok) {\n            var message = 'schema is invalid:' + errorsText();\n            if (self.opts.validateSchema == 'log') console.error(message);\n            else throw new Error(message);\n        }\n\n        var localRefs = resolve.ids.call(self, schema);\n\n        var schemaObj = new SchemaObject({\n            id: id,\n            schema: schema,\n            localRefs: localRefs,\n            jsonStr: jsonStr,\n        });\n\n        if (id[0] != '#') self._refs[id] = schemaObj;\n        self._cache.put(jsonStr, schemaObj);\n\n        return schemaObj;\n    }\n\n\n    function _compile(schemaObj, root) {\n        if (schemaObj.compiling) {\n            schemaObj.validate = callValidate;\n            callValidate.schema = schemaObj.schema;\n            callValidate.errors = null;\n            callValidate.root = root ? root : callValidate;\n            return callValidate;\n        }\n        schemaObj.compiling = true;\n\n        var currentRA = self.opts.removeAdditional;\n        if (currentRA && schemaObj.meta) self.opts.removeAdditional = false;\n        var v;\n        try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }\n        finally {\n            schemaObj.compiling = false;\n            if (currentRA) self.opts.removeAdditional = currentRA;\n        }\n\n        schemaObj.validate = v;\n        schemaObj.refs = v.refs;\n        schemaObj.refVal = v.refVal;\n        schemaObj.root = v.root;\n        return v;\n\n\n        function callValidate() {\n            var v = schemaObj.validate;\n            var result = v.apply(null, arguments);\n            callValidate.errors = v.errors;\n            return result;\n        }\n    }\n\n\n    function errorsText(errors, opts) {\n        errors = errors || self.errors;\n        if (!errors) return 'No errors';\n        opts = opts || {};\n        var separator = opts.separator || ', ';\n        var dataVar = opts.dataVar || 'data';\n\n        var text = errors.reduce(function(txt, e) {\n            return e ? txt + dataVar + e.dataPath + ' ' + e.message + separator : txt;\n        }, '');\n        return text.slice(0, -separator.length);\n    }\n\n\n    function addFormat(name, format) {\n        if (typeof format == 'string') format = new RegExp(format);\n        self._formats[name] = format;\n    }\n\n\n    function addInitialSchemas() {\n        if (self.opts.meta !== false) {\n            var metaSchema = require('./refs/json-schema-draft-04.json');\n            addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n            self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n        }\n\n        var optsSchemas = self.opts.schemas;\n        if (!optsSchemas) return;\n        if (Array.isArray(optsSchemas)) addSchema(optsSchemas);\n        else for (var key in optsSchemas) addSchema(optsSchemas[key], key);\n    }\n\n\n    function addInitialFormats() {\n        for (var name in self.opts.formats) {\n            var format = self.opts.formats[name];\n            addFormat(name, format);\n        }\n    }\n\n\n    function checkUnique(id) {\n        if (self._schemas[id] || self._refs[id])\n            throw new Error('schema with key or id \"' + id + '\" already exists');\n    }\n}\n","'use strict';\n\n\nvar Cache = module.exports = function Cache() {\n    this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n    this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n    return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n    delete this._cache[key];\n};\n","'use strict';\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': require('../dotjs/ref'),\n  anyOf: require('../dotjs/anyOf'),\n  format: require('../dotjs/format'),\n  maxLength: require('../dotjs/maxLength'),\n  minItems: require('../dotjs/minItems'),\n  minimum: require('../dotjs/minimum'),\n  oneOf: require('../dotjs/oneOf'),\n  required: require('../dotjs/required'),\n  dependencies: require('../dotjs/dependencies'),\n  items: require('../dotjs/items'),\n  maxProperties: require('../dotjs/maxProperties'),\n  minLength: require('../dotjs/minLength'),\n  multipleOf: require('../dotjs/multipleOf'),\n  pattern: require('../dotjs/pattern'),\n  uniqueItems: require('../dotjs/uniqueItems'),\n  allOf: require('../dotjs/allOf'),\n  enum: require('../dotjs/enum'),\n  maxItems: require('../dotjs/maxItems'),\n  maximum: require('../dotjs/maximum'),\n  minProperties: require('../dotjs/minProperties'),\n  not: require('../dotjs/not'),\n  properties: require('../dotjs/properties'),\n  validate: require('../dotjs/validate')\n};\n","'use strict';\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  var arrA = Array.isArray(a)\n    , arrB = Array.isArray(b)\n    , i;\n\n  if (arrA && arrB) {\n    if (a.length != b.length) return false;\n    for (i = 0; i < a.length; i++)\n      if (!equal(a[i], b[i])) return false;\n    return true;\n  }\n\n  if (arrA != arrB) return false;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    var keys = Object.keys(a);\n\n    if (keys.length !== Object.keys(b).length) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if (b[keys[i]] === undefined) return false;\n\n    for (i = 0; i < keys.length; i++)\n      if(!equal(a[keys[i]], b[keys[i]])) return false;\n\n    return true;\n  }\n\n  return false;\n};\n","'use strict';\n\nvar util = require('./util');\n\nvar DATE = /^\\d\\d\\d\\d-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/;\nvar HOSTNAME = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?(?:\\#(?:[a-z0-9\\-._~!$&'()*+,;=:@\\/?]|%[0-9a-f]{2})*)?$/i;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t ][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nformats.full = {\n  date: date,\n  'date-time': date_time,\n  uri: uri,\n  email: /^[a-z0-9!#$%&'*+\\/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&''*+\\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: hostname,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex\n};\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var month = +matches[1];\n  var day = +matches[2];\n  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];\n}\n\n\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.toLowerCase().split('t');\n  if (!date(dateTime[0])) return false;\n\n  var matches = dateTime[1].match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  return hour <= 23 && minute <= 59 && second <= 59;\n}\n\n\nfunction hostname(str) {\n  // http://tools.ietf.org/html/rfc1034#section-3.5\n  return str.length <= 255 && HOSTNAME.test(str);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|\\:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nfunction regex(str) {\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n","'use strict';\n\nvar resolve = require('./resolve')\n  , util = require('./util')\n  , equal = require('./equal');\n\ntry { var beautify = require('' + 'js-beautify').js_beautify; } catch(e) {}\n\nvar RULES = require('./rules')\n  , validateGenerator = require('../dotjs/validate');\n\nmodule.exports = compile;\n\n\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  var self = this\n    , refVal = [ undefined ] \n    , refs = {}\n    , patterns = []\n    , patternsHash = {};\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var formats = this._formats;\n\n  return localCompile(schema, root, localRefs, baseId);\n\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var validateCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errorPath: '\"\"',\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      opts: self.opts,\n      formats: formats\n    });\n\n    validateCode = refsCode(refVal) + patternsCode(patterns) + validateCode;\n\n    if (self.opts.beautify) {\n      var opts = self.opts.beautify === true ? { indent_size: 2 } : self.opts.beautify;\n      if (beautify) validateCode = beautify(validateCode, opts);\n      else console.error('\"npm install js-beautify\" to use beautify option');\n    }\n    // console.log('\\n\\n\\n *** \\n', validateCode);\n    var validate;\n    // try {\n      eval(validateCode);\n      refVal[0] = validate;\n    // } catch(e) {\n    //   console.log('Error compiling schema, function code:', validateCode);\n    //   throw e;\n    // }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (!v) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, self.opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v) {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(schema, code) {\n    return typeof schema == 'object'\n            ? { schema: schema, code: code }\n            : code;\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n}\n\n\nfunction patternsCode(patterns) {\n  return _arrCode(patterns, patternCode);\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction refsCode(refVal) {\n  return _arrCode(refVal, refCode);\n}\n\n\nfunction refCode(i, refVal) {\n  return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';\n}\n\n\nfunction _arrCode(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\n","'use strict';\n\nvar url = require('url')\n  , equal = require('./equal')\n  , util = require('./util')\n  , SchemaObject = require('./schema_obj');\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\n\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n  \n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject)\n    return inlineRef(refVal.schema, this.opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n\n  var res = _resolve.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject)\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  else if (schema)\n    v = inlineRef(schema, this.opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n\n  return v;\n}\n\n\nfunction _resolve(root, ref) {\n  /* jshint validthis: true */\n  var p = url.parse(ref, false, true)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(root.schema.id);\n  if (refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(root.schema.id);\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = _resolve.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    if (schema.id) baseId = resolveUrl(baseId, schema.id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum']);\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.hash = parsedRef.hash || '';\n  if (parsedRef.hash.slice(0,2) != '#/') return;\n  var parts = parsedRef.hash.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = unescapeFragment(part);\n      schema = schema[part];\n      if (!schema) break;\n      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);\n      if (schema.$ref) {\n        var $ref = resolveUrl(baseId, schema.$ref);\n        var res = _resolve.call(this, root, $ref);\n        if (res) {\n          schema = res.schema;\n          root = res.root;\n        }\n      }\n    }\n  }\n  if (schema && schema != root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum' \n]);\nfunction inlineRef(schema, limit) {\n  if (limit === undefined) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      else {\n        item = schema[key];\n        if (typeof item == 'object' && !checkNoRef(item)) return false;\n      }\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) count++;\n      else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction unescapeFragment(str) {\n  return decodeURIComponent(str)\n          .replace(/~1/g, '/')\n          .replace(/~0/g, '~');\n}\n\n\nfunction escapeFragment(str) {\n  str = str.replace(/~/g, '~0').replace(/\\//g, '~1');\n  return encodeURIComponent(str);\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = url.parse(id, false, true);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return (p.protocol||'') + (p.protocol?'//':'') + (p.host||'') + (p.path||'')  + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return url.resolve(baseId, id);\n}\n\n\nfunction resolveIds(schema) {\n  /* jshint validthis: true */\n  var id = normalizeId(schema.id);\n  var localRefs = {};\n  _resolveIds.call(this, schema, getFullPath(id, false), id);\n  return localRefs;\n\n  function _resolveIds(schema, fullPath, baseId) {\n    /* jshint validthis: true */\n    if (Array.isArray(schema))\n      for (var i=0; i<schema.length; i++)\n        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);\n    else if (schema && typeof schema == 'object') {\n      if (typeof schema.id == 'string') {\n        var id = baseId = baseId\n                          ? url.resolve(baseId, schema.id)\n                          : normalizeId(schema.id);\n\n        var refVal = this._refs[id];\n        if (typeof refVal == 'string') refVal = this._refs[refVal];\n        if (refVal && refVal.schema) {\n          if (!equal(schema, refVal.schema))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n        } else if (id != normalizeId(fullPath)) {\n          if (id[0] == '#') {\n            if (localRefs[id] && !equal(schema, localRefs[id]))\n              throw new Error('id \"' + id + '\" resolves to more than one schema');\n            localRefs[id] = schema;\n          } else\n            this._refs[id] = fullPath;\n        }\n      }\n      for (var key in schema)\n        _resolveIds.call(this, schema[key], fullPath+'/'+escapeFragment(key), baseId);\n    }\n  }\n}\n","'use strict';\n\nvar ruleModules = require('./_rules')\n  , util = require('./util');\n\nvar RULES = module.exports = [\n  { type: 'number',\n    rules: [ 'maximum', 'minimum', 'multipleOf'] },\n  { type: 'string',\n    rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n  { type: 'array',\n    rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },\n  { type: 'object',\n    rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },\n  { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }\n];\n\nRULES.all = [ 'type', 'additionalProperties', 'patternProperties' ];\n\n\nRULES.forEach(function (group) {\n  group.rules = group.rules.map(function (keyword) {\n    RULES.all.push(keyword);\n    return {\n      keyword: keyword,\n      code: ruleModules[keyword]\n    };\n  });\n});\n\nRULES.all = util.toHash(RULES.all);\n","'use strict';\n\nvar util = require('./util');\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n    util.copy(obj, this);\n}\n","'use strict';\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  ucs2length: ucs2length,\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  cleanUpCode: cleanUpCode,\n  cleanUpVarErrors: cleanUpVarErrors,\n  schemaHasRules: schemaHasRules,\n  stableStringify: require('json-stable-stringify'),\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1))';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);\n\n      return code;\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return IDENTIFIER.test(key)\n          ? '.' + key\n          : \"['\" + key.replace(SINGLE_QUOTE, '\\\\$&') + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&');\n}\n\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nvar EMPTY_ELSE = /else\\s*{\\s*}/g\n  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g\n  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;\nfunction cleanUpCode(out) {\n  return out.replace(EMPTY_ELSE, '')\n            .replace(EMPTY_IF_NO_ELSE, '')\n            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');\n}\n\n\nvar ERRORS_REGEXP = /[^v\\.]errors/g\n  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g\n  , RETURN_VALID = 'return errors === 0;'\n  , RETURN_TRUE = 'validate.errors = null; return true;';\n\nfunction cleanUpVarErrors(out) {\n  var matches = out.match(ERRORS_REGEXP);\n  if (matches && matches.length === 2)\n    return out.replace(REMOVE_ERRORS, '')\n              .replace(RETURN_VALID, RETURN_TRUE);\n  else\n    return out;\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction toQuotedString (str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr (currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath (currentPath, prop, jsonPointers) {\n  var path = jsonPointers\n              ? toQuotedString('/' + prop.replace(/~/g, '~0').replace(/\\//g, '~1'))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/' \\+ '/g, '');\n}\n","'use strict';\nmodule.exports = function generate_allOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['allOf'],\n    $schemaPath = it.schemaPath + '.' + 'allOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces.slice(0, -1));\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_anyOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['anyOf'],\n    $schemaPath = it.schemaPath + '.' + 'anyOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return it.util.schemaHasRules($sch, it.RULES.all);\n  });\n  if ($noEmptySchema) {\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ' + ($valid) + ' = ' + ($valid) + ' || valid' + ($it.level) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   { keyword: \\'' + ('anyOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match some schema in anyOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n    out = it.util.cleanUpCode(out);\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_dependencies(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['dependencies'],\n    $schemaPath = it.schemaPath + '.' + 'dependencies',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $schemaDeps = {},\n    $propertyDeps = {};\n  for ($property in $schema) {\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  for (var $property in $propertyDeps) {\n    out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined) { ';\n    $deps = $propertyDeps[$property];\n    out += ' if ( ';\n    var arr1 = $deps;\n    if (arr1) {\n      var $dep, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $dep = arr1[$i += 1];\n        if ($i) {\n          out += ' || ';\n        }\n        out += ' ' + ($data) + (it.util.getProperty($dep)) + ' === undefined ';\n      }\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('dependencies') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should have ';\n        if ($deps.length == 1) {\n          out += 'property ' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { n: ' + ($deps.length) + ', deps: \\'';\n        if ($deps.length == 1) {\n          out += '' + (it.util.escapeQuotes($deps[0]));\n        } else {\n          out += '' + (it.util.escapeQuotes($deps.join(\", \")));\n        }\n        out += '\\', property: \\'' + (it.util.escapeQuotes($property)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      $closingBraces += '}';\n      out += ' else { ';\n    }\n    out += ' }';\n  }\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if (it.util.schemaHasRules($sch, it.RULES.all)) {\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '[\\'' + ($property) + '\\'] !== undefined) { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      out += ' ' + (it.validate($it)) + ' }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_enum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['enum'],\n    $schemaPath = it.schemaPath + '.' + 'enum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $i = 'i' + $lvl;\n  out += 'var enumSchema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ' , ' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<enumSchema' + ($lvl) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', enumSchema' + ($lvl) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; } if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('enum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of values\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_format(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['format'],\n    $schemaPath = it.schemaPath + '.' + 'format',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $format = it.formats[$schema];\n  if (it.opts.format !== false && $format) {\n    out += ' if (!   ';\n    if (typeof $format == 'function') {\n      out += ' formats' + (it.util.getProperty($schema)) + ' (' + ($data) + ') ';\n    } else {\n      out += ' formats' + (it.util.getProperty($schema)) + ' .test(' + ($data) + ') ';\n    }\n    out += ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('format') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match format ' + (it.util.escapeQuotes($schema)) + '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_items(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['items'],\n    $schemaPath = it.schemaPath + '.' + 'items',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + ';  if (!' + ($valid) + ') {  ';\n      if (!it.compositeRule && $breakOnError) {\n        out += ' validate.errors = [ { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }]; return false; ';\n      } else {\n        out += '  var err =   { keyword: \\'' + ('additionalItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: false ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' }  ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          var $passData = $data + '[' + $i + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (valid' + ($it.level) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var i' + ($lvl) + ' = ' + ($schema.length) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n      var $passData = $data + '[i' + $lvl + ']';\n      var $code = it.validate($it);\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!valid' + ($it.level) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += '  for (var i' + ($lvl) + ' = ' + (0) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);\n    var $passData = $data + '[i' + $lvl + ']';\n    var $code = it.validate($it);\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!valid' + ($it.level) + ') break; ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxItems'],\n    $schemaPath = it.schemaPath + '.' + 'maxItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxLength'],\n    $schemaPath = it.schemaPath + '.' + 'maxLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be longer than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maxProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maxProperties'],\n    $schemaPath = it.schemaPath + '.' + 'maxProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length > ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maxProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have more than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_maximum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['maximum'],\n    $schemaPath = it.schemaPath + '.' + 'maximum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMaximum === true,\n    $op = $exclusive ? '<' : '<=',\n    $notOp = $exclusive ? '>=' : '>';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('maximum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minItems'],\n    $schemaPath = it.schemaPath + '.' + 'minItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (' + ($data) + '.length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' items\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minLength(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minLength'],\n    $schemaPath = it.schemaPath + '.' + 'minLength',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if ( ';\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minLength') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be shorter than ' + ($schema) + ' characters\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minProperties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minProperties'],\n    $schemaPath = it.schemaPath + '.' + 'minProperties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'if (Object.keys(' + ($data) + ').length < ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have less than ' + ($schema) + ' properties\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_minimum(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['minimum'],\n    $schemaPath = it.schemaPath + '.' + 'minimum',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $exclusive = it.schema.exclusiveMinimum === true,\n    $op = $exclusive ? '>' : '>=',\n    $notOp = $exclusive ? '<=' : '<';\n  out += 'if (' + ($data) + ' ' + ($notOp) + ' ' + ($schema) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('minimum') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($op) + ' ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { condition: \\'' + ($op) + ' ' + ($schema) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_multipleOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['multipleOf'],\n    $schemaPath = it.schemaPath + '.' + 'multipleOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  out += 'var division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schema) + ';if (' + ($data) + ' / ' + ($schema) + ' !== parseInt(division' + ($lvl) + ')) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('multipleOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ' + ($schema) + '\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + ($schema) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_not(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['not'],\n    $schemaPath = it.schemaPath + '.' + 'not',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  if (it.util.schemaHasRules($schema, it.RULES.all)) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += ' ' + (it.validate($it)) + '  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (valid' + ($it.level) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   { keyword: \\'' + ('not') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be valid\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_oneOf(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['oneOf'],\n    $schemaPath = it.schemaPath + '.' + 'oneOf',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        out += ' ' + (it.validate($it)) + ' ';\n      } else {\n        out += ' var valid' + ($it.level) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (valid' + ($it.level) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (valid' + ($it.level) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('oneOf') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} else { errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_pattern(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['pattern'],\n    $schemaPath = it.schemaPath + '.' + 'pattern',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  new RegExp($schema);\n  out += 'if (! ' + (it.usePattern($schema)) + '.test(' + ($data) + ') ) {  ';\n  if (!it.compositeRule && $breakOnError) {\n    out += ' validate.errors = [ { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }]; return false; ';\n  } else {\n    out += '  var err =   { keyword: \\'' + ('pattern') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"' + (it.util.escapeQuotes($schema)) + '\"\\' ';\n    }\n    if (it.opts.verbose || it.opts.i18n) {\n      out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , data: ' + ($data) + ' ';\n    }\n    if (it.opts.i18n) {\n      out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n    }\n    out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_properties(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['properties'],\n    $schemaPath = it.schemaPath + '.' + 'properties',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  var $it = it.util.copy(it),\n    $closingBraces = '';\n  $it.level++;\n  var $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt;\n  var $schemaKeys = Object.keys($schema || {}),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $requiredProperties = it.util.toHash(it.schema.required || []);\n  out += 'var ' + ($errs) + ' = errors;var valid' + ($it.level) + ' = true;';\n  if ($checkAdditional) {\n    out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { ';\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 5) {\n          out += ' || validate.schema' + ($schemaPath) + '[key' + ($lvl) + '] ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || key' + ($lvl) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';\n        } else {\n          out += ' valid' + ($it.level) + ' = false;  ';\n          if (!it.compositeRule && $breakOnError) {\n            out += ' validate.errors = [ { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }]; return false; ';\n          } else {\n            out += '  var err =   { keyword: \\'' + ('additionalProperties') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'should NOT have additional properties\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: false ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            out += '  }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!valid' + ($it.level) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[key' + ($lvl) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errorPath = it.errorPath;\n          var $passData = $data + '[key' + $lvl + ']';\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!valid' + ($it.level) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (valid' + ($it.level) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if (it.util.schemaHasRules($sch, it.RULES.all)) {\n          $it.schema = $sch;\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          var $code = it.validate($it);\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($requiredProperties[$propertyKey]) {\n            out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = false; ';\n            var $currentErrorPath = it.errorPath,\n              $missingProperty = it.util.escapeQuotes($propertyKey);\n            it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'is a required property\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            it.errorPath = $currentErrorPath;\n            out += ' } else { ';\n          } else {\n            if ($breakOnError) {\n              out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = true; } else { ';\n            } else {\n              out += ' if (' + ($useData) + ' !== undefined) { ';\n            }\n          }\n          out += ' ' + ($code) + ' } ';\n        }\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  var arr4 = $pPropertyKeys;\n  if (arr4) {\n    var $pProperty, i4 = -1,\n      l4 = arr4.length - 1;\n    while (i4 < l4) {\n      $pProperty = arr4[i4 += 1];\n      var $sch = $pProperties[$pProperty];\n      if (it.util.schemaHasRules($sch, it.RULES.all)) {\n        $it.schema = $sch;\n        $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n        out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { if (' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ')) { ';\n        $it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);\n        var $passData = $data + '[key' + $lvl + ']';\n        var $code = it.validate($it);\n        if (it.util.varOccurences($code, $nextData) < 2) {\n          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n        } else {\n          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n        }\n        if ($breakOnError) {\n          out += ' if (!valid' + ($it.level) + ') break; ';\n        }\n        out += ' } ';\n        if ($breakOnError) {\n          out += ' else valid' + ($it.level) + ' = true; ';\n        }\n        out += ' }  ';\n        if ($breakOnError) {\n          out += ' if (valid' + ($it.level) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_ref(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['$ref'],\n    $schemaPath = it.schemaPath + '.' + '$ref',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      out += '  if (! ' + ('validate') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('validate') + '.errors; else vErrors = vErrors.concat(' + ('validate') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      out += '  if (! ' + ('root.refVal[0]') + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ('root.refVal[0]') + '.errors; else vErrors = vErrors.concat(' + ('root.refVal[0]') + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = 'can\\'t resolve reference ' + $schema + ' from id ' + it.baseId;\n      if (it.opts.missingRefs == 'fail') {\n        console.log($message);\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('$ref') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { escaped: \\'' + (it.util.escapeQuotes($schema)) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        console.log($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        var $error = new Error($message);\n        $error.missingRef = it.resolve.url(it.baseId, $schema);\n        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));\n        throw $error;\n      }\n    } else if (typeof $refVal == 'string') {\n      out += '  if (! ' + ($refVal) + '(' + ($data) + ', (dataPath || \\'\\')';\n      if (it.errorPath != '\"\"') {\n        out += ' + ' + (it.errorPath);\n      }\n      out += ') ) { if (vErrors === null) vErrors = ' + ($refVal) + '.errors; else vErrors = vErrors.concat(' + ($refVal) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    } else {\n      var $it = it.util.copy(it),\n        $closingBraces = '';\n      $it.level++;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      var $code = it.validate($it);\n      if (/validate\\.schema/.test($code)) {\n        out += ' var rootSchema' + ($it.level) + ' = validate.schema; validate.schema = ' + ($refVal.code) + '; ' + ($code) + ' validate.schema = rootSchema' + ($it.level) + '; ';\n      } else {\n        out += ' ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (valid' + ($it.level) + ') { ';\n      }\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_required(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['required'],\n    $schemaPath = it.schemaPath + '.' + 'required',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if (it.schema.properties && Object.keys(it.schema.properties).length) {\n    var $required = [];\n    var arr1 = $schema;\n    if (arr1) {\n      var $property, i1 = -1,\n        l1 = arr1.length - 1;\n      while (i1 < l1) {\n        $property = arr1[i1 += 1];\n        var $propertySch = it.schema.properties[$property];\n        if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {\n          $required[$required.length] = $property;\n        }\n      }\n    }\n  } else {\n    var $required = $schema;\n  }\n  if ($required.length) {\n    var $currentErrorPath = it.errorPath;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($required.length <= 20) {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $property, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $property = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($property);\n            out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $property : $prop)) + ') ) ';\n          }\n        }\n        out += ') { ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { var ' + ($valid) + ' = ' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; }  if (!' + ($valid) + ') {  ';\n        if (!it.compositeRule && $breakOnError) {\n          out += ' validate.errors = [ { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }]; return false; ';\n        } else {\n          out += '  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'is a required property\\' ';\n          }\n          if (it.opts.verbose || it.opts.i18n) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , data: ' + ($data) + ' ';\n          }\n          if (it.opts.i18n) {\n            out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n          }\n          out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($required.length <= 20) {\n        var arr3 = $required;\n        if (arr3) {\n          var $property, $i = -1,\n            l3 = arr3.length - 1;\n          while ($i < l3) {\n            $property = arr3[$i += 1];\n            var $prop = it.util.getProperty($property),\n              $missingProperty = it.util.escapeQuotes($prop);\n            it.errorPath = it.util.getPath($currentErrorPath, $property, it.opts.jsonPointers);\n            out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'is a required property\\' ';\n            }\n            if (it.opts.verbose || it.opts.i18n) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , data: ' + ($data) + ' ';\n            }\n            if (it.opts.i18n) {\n              out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n            }\n            out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      } else {\n        out += '  var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + \"\\'\" + ' + $propertyPath + ' + \"\\'\" + \\'';\n        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { if (' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] === undefined) {  var err =   { keyword: \\'' + ('required') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'is a required property\\' ';\n        }\n        if (it.opts.verbose || it.opts.i18n) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , data: ' + ($data) + ' ';\n        }\n        if (it.opts.i18n) {\n          out += ', params: { missingProperty: \\'' + ($missingProperty) + '\\' }';\n        }\n        out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_uniqueItems(it) {\n  var out = ' ';\n  var $lvl = it.level,\n    $dataLvl = it.dataLevel,\n    $schema = it.schema['uniqueItems'],\n    $schemaPath = it.schemaPath + '.' + 'uniqueItems',\n    $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || ''),\n    $valid = 'valid' + $lvl,\n    $errs = 'errs' + $lvl;\n  if ($schema && it.opts.uniqueItems !== false) {\n    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } if (!' + ($valid) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('uniqueItems') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ' + ($schema) + ' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { i: i, j: j }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n","'use strict';\nmodule.exports = function generate_validate(it) {\n  var out = '';\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.root.schema.id);\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    out += ' validate = function (data, dataPath) { \\'use strict\\'; var vErrors = null; ';\n    out += ' var errors = 0;     ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $typeSchema = it.schema.type;\n  var arr1 = it.RULES;\n  if (arr1) {\n    var $rulesGroup, i1 = -1,\n      l1 = arr1.length - 1;\n    while (i1 < l1) {\n      $rulesGroup = arr1[i1 += 1];\n      if ($shouldUseGroup($rulesGroup)) {\n        if ($rulesGroup.type) {\n          out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';\n        }\n        var arr2 = $rulesGroup.rules;\n        if (arr2) {\n          var $rule, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $rule = arr2[i2 += 1];\n            if ($shouldUseRule($rule)) {\n              out += ' ' + ($rule.code(it)) + ' ';\n              if ($breakOnError) {\n                $closingBraces1 += '}';\n              }\n            }\n          }\n        }\n        if ($breakOnError) {\n          out += ' ' + ($closingBraces1) + ' ';\n          $closingBraces1 = '';\n        }\n        if ($rulesGroup.type) {\n          out += ' } ';\n          if ($typeSchema && $typeSchema === $rulesGroup.type) {\n            var $typeChecked = true;\n            out += ' else {  ';\n            if (!it.compositeRule && $breakOnError) {\n              out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }]; return false; ';\n            } else {\n              out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should be ';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose || it.opts.i18n) {\n                out += ' , schema: ';\n                if ($isArray) {\n                  out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n                } else {\n                  out += '\\'' + ($typeSchema) + '\\'';\n                }\n              }\n              if (it.opts.verbose) {\n                out += ' , data: ' + ($data) + ' ';\n              }\n              if (it.opts.i18n) {\n                out += ', params: { type: \\'';\n                if ($isArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' }';\n              }\n              out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n            }\n            out += ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (errors === ';\n          if ($top) {\n            out += '0';\n          } else {\n            out += 'errs_' + ($lvl);\n          }\n          out += ') { ';\n          $closingBraces2 += '}';\n        }\n      }\n    }\n  }\n  if ($typeSchema && !$typeChecked) {\n    var $schemaPath = it.schemaPath + '.type',\n      $isArray = Array.isArray($typeSchema),\n      $method = $isArray ? 'checkDataTypes' : 'checkDataType';\n    out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';\n    if (!it.compositeRule && $breakOnError) {\n      out += ' validate.errors = [ { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }]; return false; ';\n    } else {\n      out += '  var err =   { keyword: \\'' + ('type') + '\\', dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should be ';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' ';\n      }\n      if (it.opts.verbose || it.opts.i18n) {\n        out += ' , schema: ';\n        if ($isArray) {\n          out += '[\\'' + ($typeSchema.join(\"','\")) + '\\']';\n        } else {\n          out += '\\'' + ($typeSchema) + '\\'';\n        }\n      }\n      if (it.opts.verbose) {\n        out += ' , data: ' + ($data) + ' ';\n      }\n      if (it.opts.i18n) {\n        out += ', params: { type: \\'';\n        if ($isArray) {\n          out += '' + ($typeSchema.join(\",\"));\n        } else {\n          out += '' + ($typeSchema);\n        }\n        out += '\\' }';\n      }\n      out += ' }; if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    out += ' validate.errors = vErrors; ';\n    out += ' return errors === 0;       ';\n    out += ' }';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n  out = it.util.cleanUpCode(out);\n  if ($top && $breakOnError) {\n    out = it.util.cleanUpVarErrors(out);\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    for (var i = 0; i < $rulesGroup.rules.length; i++)\n      if ($shouldUseRule($rulesGroup.rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length)));\n  }\n  return out;\n}\n","module.exports={\n    \"id\": \"http://json-schema.org/draft-04/schema#\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"description\": \"Core schema meta-schema\",\n    \"definitions\": {\n        \"schemaArray\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"items\": { \"$ref\": \"#\" }\n        },\n        \"positiveInteger\": {\n            \"type\": \"integer\",\n            \"minimum\": 0\n        },\n        \"positiveIntegerDefault0\": {\n            \"allOf\": [ { \"$ref\": \"#/definitions/positiveInteger\" }, { \"default\": 0 } ]\n        },\n        \"simpleTypes\": {\n            \"enum\": [ \"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\" ]\n        },\n        \"stringArray\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" },\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        }\n    },\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"$schema\": {\n            \"type\": \"string\",\n            \"format\": \"uri\"\n        },\n        \"title\": {\n            \"type\": \"string\"\n        },\n        \"description\": {\n            \"type\": \"string\"\n        },\n        \"default\": {},\n        \"multipleOf\": {\n            \"type\": \"number\",\n            \"minimum\": 0,\n            \"exclusiveMinimum\": true\n        },\n        \"maximum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMaximum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"minimum\": {\n            \"type\": \"number\"\n        },\n        \"exclusiveMinimum\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxLength\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minLength\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"pattern\": {\n            \"type\": \"string\",\n            \"format\": \"regex\"\n        },\n        \"additionalItems\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"items\": {\n            \"anyOf\": [\n                { \"$ref\": \"#\" },\n                { \"$ref\": \"#/definitions/schemaArray\" }\n            ],\n            \"default\": {}\n        },\n        \"maxItems\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minItems\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"uniqueItems\": {\n            \"type\": \"boolean\",\n            \"default\": false\n        },\n        \"maxProperties\": { \"$ref\": \"#/definitions/positiveInteger\" },\n        \"minProperties\": { \"$ref\": \"#/definitions/positiveIntegerDefault0\" },\n        \"required\": { \"$ref\": \"#/definitions/stringArray\" },\n        \"additionalProperties\": {\n            \"anyOf\": [\n                { \"type\": \"boolean\" },\n                { \"$ref\": \"#\" }\n            ],\n            \"default\": {}\n        },\n        \"definitions\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"properties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"patternProperties\": {\n            \"type\": \"object\",\n            \"additionalProperties\": { \"$ref\": \"#\" },\n            \"default\": {}\n        },\n        \"dependencies\": {\n            \"type\": \"object\",\n            \"additionalProperties\": {\n                \"anyOf\": [\n                    { \"$ref\": \"#\" },\n                    { \"$ref\": \"#/definitions/stringArray\" }\n                ]\n            }\n        },\n        \"enum\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"uniqueItems\": true\n        },\n        \"type\": {\n            \"anyOf\": [\n                { \"$ref\": \"#/definitions/simpleTypes\" },\n                {\n                    \"type\": \"array\",\n                    \"items\": { \"$ref\": \"#/definitions/simpleTypes\" },\n                    \"minItems\": 1,\n                    \"uniqueItems\": true\n                }\n            ]\n        },\n        \"allOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"anyOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"oneOf\": { \"$ref\": \"#/definitions/schemaArray\" },\n        \"not\": { \"$ref\": \"#\" }\n    },\n    \"dependencies\": {\n        \"exclusiveMaximum\": [ \"maximum\" ],\n        \"exclusiveMinimum\": [ \"minimum\" ]\n    },\n    \"default\": {}\n}\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});const t=\"undefined\"!=typeof BigUint64Array,e=Symbol(),r=new TextDecoder(\"utf-16le\",{fatal:!0});function n(t,e){let n=new Uint32Array(t)[e+-4>>>2]>>>1;const s=new Uint16Array(t,e,n);if(n<=192)return String.fromCharCode(...s);try{return r.decode(s)}catch{let t=\"\",e=0;for(;n-e>1024;)t+=String.fromCharCode(...s.subarray(e,e+=1024));return t+String.fromCharCode(...s.subarray(e))}}function s(t){const e={};function r(t,e){return t?n(t.buffer,e):\"<yet unknown>\"}const s=t.env=t.env||{};return s.abort=s.abort||function(t,n,o,i){const a=e.memory||s.memory;throw Error(`abort: ${r(a,t)} at ${r(a,n)}:${o}:${i}`)},s.trace=s.trace||function(t,n,...o){const i=e.memory||s.memory;console.log(`trace: ${r(i,t)}${n?\" \":\"\"}${o.slice(0,n).join(\", \")}`)},s.seed=s.seed||Date.now,t.Math=t.Math||Math,t.Date=t.Date||Date,e}const o=function(){throw Error(\"Operation requires compiling with --exportRuntime\")};function i(e,r){const s=r.exports,i=s.memory,a=s.table,c=s.__new||o,u=s.__pin||o,y=s.__unpin||o,l=s.__collect||o,p=s.__rtti_base,d=p?function(t){return t[p>>>2]}:o;function b(t){const e=function(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t]}(t);if(!(7&e))throw Error(`not an array: ${t}, flags=${e}`);return e}function h(t){const e=new Uint32Array(i.buffer);if((t>>>=0)>=d(e))throw Error(`invalid id: ${t}`);return e[(p+4>>>2)+2*t+1]}function m(t){return 31-Math.clz32(t>>>6&31)}function g(t,e,r){const n=i.buffer;if(r)switch(t){case 2:return new Float32Array(n);case 3:return new Float64Array(n)}else switch(t){case 0:return new(e?Int8Array:Uint8Array)(n);case 1:return new(e?Int16Array:Uint16Array)(n);case 2:return new(e?Int32Array:Uint32Array)(n);case 3:return new(e?BigInt64Array:BigUint64Array)(n)}throw Error(`unsupported align: ${t}`)}function A(t){const e=new Uint32Array(i.buffer),r=b(e[t+-8>>>2]),n=m(r);let s=4&r?t:e[t+4>>>2];const o=2&r?e[t+12>>>2]:e[s+-4>>>2]>>>n;return g(n,2048&r,4096&r).subarray(s>>>=n,s+o)}function w(t,e,r){return new t(_(t,e,r))}function _(t,e,r){const n=i.buffer,s=new Uint32Array(n),o=s[r+4>>>2];return new t(n,o,s[o+-4>>>2]>>>e)}function T(t,r,n){e[`__get${r}`]=w.bind(null,t,n),e[`__get${r}View`]=_.bind(null,t,n)}return e.__new=c,e.__pin=u,e.__unpin=y,e.__collect=l,e.__newString=function(t){if(null==t)return 0;const e=t.length,r=c(e<<1,1),n=new Uint16Array(i.buffer);for(var s=0,o=r>>>1;s<e;++s)n[o+s]=t.charCodeAt(s);return r},e.__newArrayBuffer=function(t){if(null==t)return 0;const e=new Uint8Array(t),r=c(e.length,0);return new Uint8Array(i.buffer).set(e,r),r},e.__getString=function(t){if(!t)return null;const e=i.buffer;if(1!==new Uint32Array(e)[t+-8>>>2])throw Error(`not a string: ${t}`);return n(e,t)},e.__newArray=function(t,e){const r=b(t),n=m(r),s=e.length,o=c(s<<n,4&r?t:0);let a;if(4&r)a=o;else{u(o);const e=c(2&r?16:12,t);y(o);const f=new Uint32Array(i.buffer);f[e+0>>>2]=o,f[e+4>>>2]=o,f[e+8>>>2]=s<<n,2&r&&(f[e+12>>>2]=s),a=e}const f=g(n,2048&r,4096&r);if(16384&r)for(let t=0;t<s;++t){const r=e[t];f[(o>>>n)+t]=r}else f.set(e,o>>>n);return a},e.__getArrayView=A,e.__getArray=function(t){const e=A(t),r=e.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=e[t];return n},e.__getArrayBuffer=function(t){const e=i.buffer,r=new Uint32Array(e)[t+-4>>>2];return e.slice(t,t+r)},[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array].forEach((t=>{T(t,t.name,31-Math.clz32(t.BYTES_PER_ELEMENT))})),t&&[BigUint64Array,BigInt64Array].forEach((t=>{T(t,t.name.slice(3),3)})),e.__instanceof=function(t,e){const r=new Uint32Array(i.buffer);let n=r[t+-8>>>2];if(n<=d(r))do{if(n==e)return!0;n=h(n)}while(n);return!1},e.memory=e.memory||i,e.table=e.table||a,f(s,e)}function a(t){return\"undefined\"!=typeof Response&&t instanceof Response}function c(t){return t instanceof WebAssembly.Module}async function u(t,e={}){if(a(t=await t))return y(t,e);const r=c(t)?t:await WebAssembly.compile(t),n=s(e),o=await WebAssembly.instantiate(r,e);return{module:r,instance:o,exports:i(n,o)}}async function y(t,e={}){if(!WebAssembly.instantiateStreaming)return u(a(t=await t)?t.arrayBuffer():t,e);const r=s(e),n=await WebAssembly.instantiateStreaming(t,e),o=i(r,n.instance);return{...n,exports:o}}function f(t,r={}){const n=t.__argumentsLength?e=>{t.__argumentsLength.value=e}:t.__setArgumentsLength||t.__setargc||(()=>{});for(let s in t){if(!Object.prototype.hasOwnProperty.call(t,s))continue;const o=t[s];let i=s.split(\".\"),a=r;for(;i.length>1;){let t=i.shift();Object.prototype.hasOwnProperty.call(a,t)||(a[t]={}),a=a[t]}let c=i[0],u=c.indexOf(\"#\");if(u>=0){const r=c.substring(0,u),i=a[r];if(void 0===i||!i.prototype){const t=function(...e){return t.wrap(t.prototype.constructor(0,...e))};t.prototype={valueOf(){return this[e]}},t.wrap=function(r){return Object.create(t.prototype,{[e]:{value:r,writable:!1}})},i&&Object.getOwnPropertyNames(i).forEach((e=>Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e)))),a[r]=t}if(c=c.substring(u+1),a=a[r].prototype,/^(get|set):/.test(c)){if(!Object.prototype.hasOwnProperty.call(a,c=c.substring(4))){let r=t[s.replace(\"set:\",\"get:\")],n=t[s.replace(\"get:\",\"set:\")];Object.defineProperty(a,c,{get(){return r(this[e])},set(t){n(this[e],t)},enumerable:!0})}}else\"constructor\"===c?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:(a[c]=function(...t){return n(t.length),o(this[e],...t)}).original=o}else/^(get|set):/.test(c)?Object.prototype.hasOwnProperty.call(a,c=c.substring(4))||Object.defineProperty(a,c,{get:t[s.replace(\"set:\",\"get:\")],set:t[s.replace(\"get:\",\"set:\")],enumerable:!0}):\"function\"==typeof o&&o!==n?(a[c]=(...t)=>(n(t.length),o(...t))).original=o:a[c]=o}return r}var l={instantiate:u,instantiateSync:function(t,e={}){const r=c(t)?t:new WebAssembly.Module(t),n=s(e),o=new WebAssembly.Instance(r,e);return{module:r,instance:o,exports:i(n,o)}},instantiateStreaming:y,demangle:f};function p(t,e,r){return e}function d(t,e,r){return t.exports[`__get${function(t){return t.startsWith(\"~lib/typedarray/\")?((t=t.slice(\"~lib/typedarray/\".length)).startsWith(\"Big\")&&(t=t.slice(3)),t):t}(r)}View`](e)}function b(t,e,r){return t.exports.__newArray(t.getTypeId(r),e)}function h(t){if(!t.startsWith(\"~lib/array/Array\"))throw Error(`${JSON.stringify(t)} is not an array type`);return t.slice(\"~lib/array/Array<\".length,-1)}const m=new Map([[\"void\",{ascToJs:p,jsToAsc:p}],[/^(i|u|f)(8|16|32|64)|[ui]size|bool|externref$/,{ascToJs:p,jsToAsc:p}],[\"~lib/string/String\",{ascToJs:function(t,e,r){return t.exports.__getString(e)},jsToAsc:function(t,e,r){return t.exports.__newString(e)}}],[\"~lib/typedarray/Int8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint16Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Int64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Uint8ClampedArray\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float32Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/typedarray/Float64Array\",{ascToJs:d,jsToAsc:b}],[\"~lib/arraybuffer/ArrayBuffer\",{ascToJs:function(t,e,r){return t.exports.__getArrayBuffer(e)},jsToAsc:function(t,e,r){const n=t.exports.__new(e.byteLength,t.getTypeId(r));return new Uint8Array(t.exports.memory.buffer,n,e.byteLength).set(new Uint8Array(e)),n}}],[/^~lib\\/array\\/Array<.+>$/,{ascToJs:function(t,e,r){const n=h(r),s=A(n);return t.exports.__getArray(e).map((e=>s.ascToJs(t,e,n)))},jsToAsc:function(t,e,r){const n=h(r),s=A(n),o=e.map((e=>s.jsToAsc(t,e,n)));return t.exports.__newArray(t.getTypeId(r),o)}}]]),g=new Set;function A(t){for(const[e,r]of m)if(\"string\"!=typeof e){if(e.test(t))return r}else if(e===t)return r;return g.has(t)||(console.warn(`No converter for ${JSON.stringify(t)}, using pass-through`),g.add(t)),{ascToJs:p,jsToAsc:p}}function w(t){var e;return null===(e=A(t))||void 0===e?void 0:e.ascToJs}function _(t){var e;return null===(e=A(t))||void 0===e?void 0:e.jsToAsc}function T(t,e,r){const n=r.parameters.map(w),s=_(r.returnType);return function(...o){if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=o.map(((e,s)=>n[s](t,e,r.parameters[s]))),a=e(...i);return s(t,a,r.returnType)}}function j(t,e,r){const n=r.parameters.map(_),s=w(r.returnType);return(...o)=>{if(o.length!=n.length)throw Error(`Expected ${n.length} arguments, got ${o.length}`);const i=[],a=o.map(((e,s)=>{const o=n[s](t,e,r.parameters[s]);return o!==e&&(t.exports.__pin(o),i.push(o)),o})),c=e(...a);return i.forEach((e=>t.exports.__unpin(e))),s(t,c,r.returnType)}}function x(t,{depth:e=Number.POSITIVE_INFINITY}={}){return e<=0||!t||\"object\"!=typeof t?t:Object.fromEntries(Object.entries(t).map((([t,r])=>[t,x(r,{depth:e-1})])))}function O(t){const e=WebAssembly.Module.customSections(t,\"as-bind_bindings\"),r=new TextDecoder(\"utf8\").decode(new Uint8Array(e[0]));try{return JSON.parse(r)}catch(t){throw Error(`Couldn’t decode type descriptor: ${t.message}`)}}class U{constructor(){this.unboundExports={},this.exports={},this.importObject={}}getTypeId(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].id;throw Error(`Unknown type ${JSON.stringify(t)}`)}getTypeSize(t){if(t in this.typeDescriptor.typeIds)return this.typeDescriptor.typeIds[t].byteSize;throw Error(`Unknown type ${JSON.stringify(t)}`)}_validate(){if(!WebAssembly.Module.exports(this.module).find((t=>\"__new\"===t.name)))throw Error(\"The AssemblyScript wasm module was not built with --exportRuntime, which is required.\");if(1!==WebAssembly.Module.customSections(this.module,\"as-bind_bindings\").length)throw new Error(\"The AssemblyScript wasm module was not built with the as-bind transform.\")}async _instantiate(t,e){this.module=await async function(t){if(t=await Promise.resolve(t),\"undefined\"!=typeof Response&&t instanceof Response){if(WebAssembly.compileStreaming)return WebAssembly.compileStreaming(t);t=await t.arrayBuffer()}return WebAssembly.compile(t)}(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=await async function(t,e){return l.instantiate(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateSync(t,e){this.module=new WebAssembly.Module(t),this._validate(),this.typeDescriptor=O(this.module),this._instantiateBindImportFunctions(e),this.loadedModule=function(t,e){return l.instantiateSync(t,e)}(this.module,this.importObject),this._instantiateBindUnboundExports()}_instantiateBindImportFunctions(t){this.importObject=x(t,{depth:2});for(const[e,r]of Object.entries(this.typeDescriptor.importedFunctions))for(const[n,s]of Object.entries(r))this.importObject[e][`__asbind_unbound_${n}`]=t[e][n],this.importObject[e][n]=T(this,t[e][n],s)}_instantiateBindUnboundExports(){const t=this.loadedModule.exports;this.exports=x(t,{depth:1});for(const[e,r]of Object.entries(this.typeDescriptor.exportedFunctions))this.exports[e]=j(this,t[e],r)}}exports.converters=m,exports.instantiate=async function(t,e){let r=new U;return await r._instantiate(t,e),r},exports.instantiateSync=function(t,e){let r=new U;return r._instantiateSync(t,e),r},exports.version=\"0.8.1\";\n","\"use strict\";\nvar mqtt = require(\"mqtt\");\nvar inArray = require(\"in-array\");\n\nvar RegularClientPrototype = mqtt.MqttClient.prototype;\n\nvar ASYNC_METHODS = [\"publish\",\n\t\"subscribe\",\n\t\"unsubscribe\",\n\t\"unsubscribe\",\n\t\"end\"\n];\n\nvar SYNC_METHODS = [\n\t\"emit\",\n\t\"addListener\",\n\t\"on\",\n\t\"once\",\n\t\"removeListener\",\n\t\"removeAllListeners\",\n\t\"setMaxListeners\",\n\t\"getMaxListeners\",\n\t\"listeners\",\n\t\"listenerCount\"\n];\n\nmodule.exports = {\n\tconnect: connect,\n\tAsyncClient: AsyncClient\n};\n\nfunction connect(brokerURL, opts) {\n\tvar client = mqtt.connect(brokerURL, opts);\n\n\tvar asyncClient = new AsyncClient(client);\n\n\treturn asyncClient;\n}\n\nfunction AsyncClient(client) {\n\tthis._client = client;\n}\n\nAsyncClient.prototype = {\n\tset handleMessage(newHandler) {\n\t\tthis._client.handleMessage = newHandler;\n\t},\n\tget handleMessage() {\n\t\treturn this._client.handleMessage;\n\t}\n};\n\nASYNC_METHODS.forEach(defineAsync);\nSYNC_METHODS.forEach(definePassthrough);\n\nfunction definePassthrough(name) {\n\tAsyncClient.prototype[name] = function() {\n\t\tvar client = this._client;\n\t\treturn client[name].apply(client, arguments);\n\t};\n}\n\nfunction defineAsync(name) {\n\tAsyncClient.prototype[name] = function asyncMethod() {\n\t\tvar client = this._client;\n\t\tvar args = [];\n\t\tvar length = arguments.length;\n\t\tvar i = 0;\n\t\tfor (i; i < length; i++)\n\t\t\targs.push(arguments[i]);\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\targs.push(makeCallback(resolve, reject));\n\t\t\tclient[name].apply(client, args);\n\t\t});\n\t};\n}\n\nfunction makeCallback(resolve, reject) {\n\treturn function(err, data) {\n\t\tif (err)\n\t\t\treject(err);\n\t\telse resolve(data);\n\t};\n}\n","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n  , Buffer       = require('safe-buffer').Buffer\n\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n  } else {\n    this.append(callback)\n  }\n\n  DuplexStream.call(this)\n}\n\n\nutil.inherits(BufferList, DuplexStream)\n\n\nBufferList.prototype._offset = function _offset (offset) {\n  var tot = 0, i = 0, _t\n  if (offset === 0) return [ 0, 0 ]\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t || i == this._bufs.length - 1)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\n\nBufferList.prototype.append = function append (buf) {\n  var i = 0\n\n  if (Buffer.isBuffer(buf)) {\n    this._appendBuffer(buf);\n  } else if (Array.isArray(buf)) {\n    for (; i < buf.length; i++)\n      this.append(buf[i])\n  } else if (buf instanceof BufferList) {\n    // unwrap argument into individual BufferLists\n    for (; i < buf._bufs.length; i++)\n      this.append(buf._bufs[i])\n  } else if (buf != null) {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf == 'number')\n      buf = buf.toString()\n\n    this._appendBuffer(Buffer.from(buf));\n  }\n\n  return this\n}\n\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\n\nBufferList.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback == 'function')\n    callback()\n}\n\n\nBufferList.prototype._read = function _read (size) {\n  if (!this.length)\n    return this.push(null)\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\n\nBufferList.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\n\nBufferList.prototype.get = function get (index) {\n  return this.slice(index, index + 1)[0]\n}\n\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start == 'number' && start < 0)\n    start += this.length\n  if (typeof end == 'number' && end < 0)\n    end += this.length\n  return this.copy(null, 0, start, end)\n}\n\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || Buffer.alloc(0)\n  if (srcEnd <= 0)\n    return dst || Buffer.alloc(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) { // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = end || this.length\n\n  if (start < 0)\n    start += this.length\n  if (end < 0)\n    end += this.length\n\n  var startOffset = this._offset(start)\n    , endOffset = this._offset(end)\n    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] == 0)\n    buffers.pop()\n  else\n    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])\n\n  if (startOffset[1] != 0)\n    buffers[0] = buffers[0].slice(startOffset[1])\n\n  return new BufferList(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\n\nBufferList.prototype.duplicate = function duplicate () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\n\nBufferList.prototype.destroy = function destroy () {\n  this._bufs.length = 0\n  this.length = 0\n  this.push(null)\n}\n\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\n\nmodule.exports = BufferList\n","","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('buffer').Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","\"use strict\";\n\nvar isValue             = require(\"type/value/is\")\n  , ensureValue         = require(\"type/value/ensure\")\n  , ensurePlainFunction = require(\"type/plain-function/ensure\")\n  , copy                = require(\"es5-ext/object/copy\")\n  , normalizeOptions    = require(\"es5-ext/object/normalize-options\")\n  , map                 = require(\"es5-ext/object/map\");\n\nvar bind = Function.prototype.bind\n  , defineProperty = Object.defineProperty\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , define;\n\ndefine = function (name, desc, options) {\n\tvar value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;\n\tdgs = copy(desc);\n\tdelete dgs.writable;\n\tdelete dgs.value;\n\tdgs.get = function () {\n\t\tif (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n\t\tdesc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n\t\tdefineProperty(this, name, desc);\n\t\treturn this[name];\n\t};\n\treturn dgs;\n};\n\nmodule.exports = function (props/*, options*/) {\n\tvar options = normalizeOptions(arguments[1]);\n\tif (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);\n\treturn map(props, function (desc, name) { return define(name, desc, options); });\n};\n","\"use strict\";\n\nvar isValue         = require(\"type/value/is\")\n  , isPlainFunction = require(\"type/plain-function/is\")\n  , assign          = require(\"es5-ext/object/assign\")\n  , normalizeOpts   = require(\"es5-ext/object/normalize-options\")\n  , contains        = require(\"es5-ext/string/#/contains\");\n\nvar d = (module.exports = function (dscr, value/*, options*/) {\n\tvar c, e, w, options, desc;\n\tif (arguments.length < 2 || typeof dscr !== \"string\") {\n\t\toptions = value;\n\t\tvalue = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[2];\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t\tw = contains.call(dscr, \"w\");\n\t} else {\n\t\tc = w = true;\n\t\te = false;\n\t}\n\n\tdesc = { value: value, configurable: c, enumerable: e, writable: w };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n});\n\nd.gs = function (dscr, get, set/*, options*/) {\n\tvar c, e, options, desc;\n\tif (typeof dscr !== \"string\") {\n\t\toptions = set;\n\t\tset = get;\n\t\tget = dscr;\n\t\tdscr = null;\n\t} else {\n\t\toptions = arguments[3];\n\t}\n\tif (!isValue(get)) {\n\t\tget = undefined;\n\t} else if (!isPlainFunction(get)) {\n\t\toptions = get;\n\t\tget = set = undefined;\n\t} else if (!isValue(set)) {\n\t\tset = undefined;\n\t} else if (!isPlainFunction(set)) {\n\t\toptions = set;\n\t\tset = undefined;\n\t}\n\tif (isValue(dscr)) {\n\t\tc = contains.call(dscr, \"c\");\n\t\te = contains.call(dscr, \"e\");\n\t} else {\n\t\tc = true;\n\t\te = false;\n\t}\n\n\tdesc = { get: get, set: set, configurable: c, enumerable: e };\n\treturn !options ? desc : assign(normalizeOpts(options), desc);\n};\n","var stream = require('readable-stream')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar shift = require('stream-shift')\n\nvar SIGNAL_FLUSH = (Buffer.from && Buffer.from !== Uint8Array.from)\n  ? Buffer.from([0])\n  : new Buffer([0])\n\nvar onuncork = function(self, fn) {\n  if (self._corked) self.once('uncork', fn)\n  else fn()\n}\n\nvar autoDestroy = function (self, err) {\n  if (self._autoDestroy) self.destroy(err)\n}\n\nvar destroyer = function(self, end) {\n  return function(err) {\n    if (err) autoDestroy(self, err.message === 'premature close' ? null : err)\n    else if (end && !self._ended) self.end()\n  }\n}\n\nvar end = function(ws, fn) {\n  if (!ws) return fn()\n  if (ws._writableState && ws._writableState.finished) return fn()\n  if (ws._writableState) return ws.end(fn)\n  ws.end()\n  fn()\n}\n\nvar toStreams2 = function(rs) {\n  return new (stream.Readable)({objectMode:true, highWaterMark:16}).wrap(rs)\n}\n\nvar Duplexify = function(writable, readable, opts) {\n  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)\n  stream.Duplex.call(this, opts)\n\n  this._writable = null\n  this._readable = null\n  this._readable2 = null\n\n  this._autoDestroy = !opts || opts.autoDestroy !== false\n  this._forwardDestroy = !opts || opts.destroy !== false\n  this._forwardEnd = !opts || opts.end !== false\n  this._corked = 1 // start corked\n  this._ondrain = null\n  this._drained = false\n  this._forwarding = false\n  this._unwrite = null\n  this._unread = null\n  this._ended = false\n\n  this.destroyed = false\n\n  if (writable) this.setWritable(writable)\n  if (readable) this.setReadable(readable)\n}\n\ninherits(Duplexify, stream.Duplex)\n\nDuplexify.obj = function(writable, readable, opts) {\n  if (!opts) opts = {}\n  opts.objectMode = true\n  opts.highWaterMark = 16\n  return new Duplexify(writable, readable, opts)\n}\n\nDuplexify.prototype.cork = function() {\n  if (++this._corked === 1) this.emit('cork')\n}\n\nDuplexify.prototype.uncork = function() {\n  if (this._corked && --this._corked === 0) this.emit('uncork')\n}\n\nDuplexify.prototype.setWritable = function(writable) {\n  if (this._unwrite) this._unwrite()\n\n  if (this.destroyed) {\n    if (writable && writable.destroy) writable.destroy()\n    return\n  }\n\n  if (writable === null || writable === false) {\n    this.end()\n    return\n  }\n\n  var self = this\n  var unend = eos(writable, {writable:true, readable:false}, destroyer(this, this._forwardEnd))\n\n  var ondrain = function() {\n    var ondrain = self._ondrain\n    self._ondrain = null\n    if (ondrain) ondrain()\n  }\n\n  var clear = function() {\n    self._writable.removeListener('drain', ondrain)\n    unend()\n  }\n\n  if (this._unwrite) process.nextTick(ondrain) // force a drain on stream reset to avoid livelocks\n\n  this._writable = writable\n  this._writable.on('drain', ondrain)\n  this._unwrite = clear\n\n  this.uncork() // always uncork setWritable\n}\n\nDuplexify.prototype.setReadable = function(readable) {\n  if (this._unread) this._unread()\n\n  if (this.destroyed) {\n    if (readable && readable.destroy) readable.destroy()\n    return\n  }\n\n  if (readable === null || readable === false) {\n    this.push(null)\n    this.resume()\n    return\n  }\n\n  var self = this\n  var unend = eos(readable, {writable:false, readable:true}, destroyer(this))\n\n  var onreadable = function() {\n    self._forward()\n  }\n\n  var onend = function() {\n    self.push(null)\n  }\n\n  var clear = function() {\n    self._readable2.removeListener('readable', onreadable)\n    self._readable2.removeListener('end', onend)\n    unend()\n  }\n\n  this._drained = true\n  this._readable = readable\n  this._readable2 = readable._readableState ? readable : toStreams2(readable)\n  this._readable2.on('readable', onreadable)\n  this._readable2.on('end', onend)\n  this._unread = clear\n\n  this._forward()\n}\n\nDuplexify.prototype._read = function() {\n  this._drained = true\n  this._forward()\n}\n\nDuplexify.prototype._forward = function() {\n  if (this._forwarding || !this._readable2 || !this._drained) return\n  this._forwarding = true\n\n  var data\n\n  while (this._drained && (data = shift(this._readable2)) !== null) {\n    if (this.destroyed) continue\n    this._drained = this.push(data)\n  }\n\n  this._forwarding = false\n}\n\nDuplexify.prototype.destroy = function(err) {\n  if (this.destroyed) return\n  this.destroyed = true\n\n  var self = this\n  process.nextTick(function() {\n    self._destroy(err)\n  })\n}\n\nDuplexify.prototype._destroy = function(err) {\n  if (err) {\n    var ondrain = this._ondrain\n    this._ondrain = null\n    if (ondrain) ondrain(err)\n    else this.emit('error', err)\n  }\n\n  if (this._forwardDestroy) {\n    if (this._readable && this._readable.destroy) this._readable.destroy()\n    if (this._writable && this._writable.destroy) this._writable.destroy()\n  }\n\n  this.emit('close')\n}\n\nDuplexify.prototype._write = function(data, enc, cb) {\n  if (this.destroyed) return cb()\n  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))\n  if (data === SIGNAL_FLUSH) return this._finish(cb)\n  if (!this._writable) return cb()\n\n  if (this._writable.write(data) === false) this._ondrain = cb\n  else cb()\n}\n\nDuplexify.prototype._finish = function(cb) {\n  var self = this\n  this.emit('preend')\n  onuncork(this, function() {\n    end(self._forwardEnd && self._writable, function() {\n      // haxx to not emit prefinish twice\n      if (self._writableState.prefinished === false) self._writableState.prefinished = true\n      self.emit('prefinish')\n      onuncork(self, cb)\n    })\n  })\n}\n\nDuplexify.prototype.end = function(data, enc, cb) {\n  if (typeof data === 'function') return this.end(null, null, data)\n  if (typeof enc === 'function') return this.end(data, null, enc)\n  this._ended = true\n  if (data) this.write(data)\n  if (!this._writableState.ending) this.write(SIGNAL_FLUSH)\n  return stream.Writable.prototype.end.call(this, cb)\n}\n\nmodule.exports = Duplexify\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","// Inspired by Google Closure:\n// http://closure-library.googlecode.com/svn/docs/\n// closure_goog_array_array.js.html#goog.array.clear\n\n\"use strict\";\n\nvar value = require(\"../../object/valid-value\");\n\nmodule.exports = function () {\n\tvalue(this).length = 0;\n\treturn this;\n};\n","\"use strict\";\n\nvar numberIsNaN       = require(\"../../number/is-nan\")\n  , toPosInt          = require(\"../../number/to-pos-integer\")\n  , value             = require(\"../../object/valid-value\")\n  , indexOf           = Array.prototype.indexOf\n  , objHasOwnProperty = Object.prototype.hasOwnProperty\n  , abs               = Math.abs\n  , floor             = Math.floor;\n\nmodule.exports = function (searchElement/*, fromIndex*/) {\n\tvar i, length, fromIndex, val;\n\tif (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n\n\tlength = toPosInt(value(this).length);\n\tfromIndex = arguments[1];\n\tif (isNaN(fromIndex)) fromIndex = 0;\n\telse if (fromIndex >= 0) fromIndex = floor(fromIndex);\n\telse fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n\n\tfor (i = fromIndex; i < length; ++i) {\n\t\tif (objHasOwnProperty.call(this, i)) {\n\t\t\tval = this[i];\n\t\t\tif (numberIsNaN(val)) return i; // Jslint: ignore\n\t\t}\n\t}\n\treturn -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Array.from : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar from = Array.from, arr, result;\n\tif (typeof from !== \"function\") return false;\n\tarr = [\"raz\", \"dwa\"];\n\tresult = from(arr);\n\treturn Boolean(result && result !== arr && result[1] === \"dwa\");\n};\n","\"use strict\";\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArguments    = require(\"../../function/is-arguments\")\n  , isFunction     = require(\"../../function/is-function\")\n  , toPosInt       = require(\"../../number/to-pos-integer\")\n  , callable       = require(\"../../object/valid-callable\")\n  , validValue     = require(\"../../object/valid-value\")\n  , isValue        = require(\"../../object/is-value\")\n  , isString       = require(\"../../string/is-string\")\n  , isArray        = Array.isArray\n  , call           = Function.prototype.call\n  , desc           = { configurable: true, enumerable: true, writable: true, value: null }\n  , defineProperty = Object.defineProperty;\n\n// eslint-disable-next-line complexity, max-lines-per-function\nmodule.exports = function (arrayLike/*, mapFn, thisArg*/) {\n\tvar mapFn = arguments[1]\n\t  , thisArg = arguments[2]\n\t  , Context\n\t  , i\n\t  , j\n\t  , arr\n\t  , length\n\t  , code\n\t  , iterator\n\t  , result\n\t  , getIterator\n\t  , value;\n\n\tarrayLike = Object(validValue(arrayLike));\n\n\tif (isValue(mapFn)) callable(mapFn);\n\tif (!this || this === Array || !isFunction(this)) {\n\t\t// Result: Plain array\n\t\tif (!mapFn) {\n\t\t\tif (isArguments(arrayLike)) {\n\t\t\t\t// Source: Arguments\n\t\t\t\tlength = arrayLike.length;\n\t\t\t\tif (length !== 1) return Array.apply(null, arrayLike);\n\t\t\t\tarr = new Array(1);\n\t\t\t\tarr[0] = arrayLike[0];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t\tif (isArray(arrayLike)) {\n\t\t\t\t// Source: Array\n\t\t\t\tarr = new Array((length = arrayLike.length));\n\t\t\t\tfor (i = 0; i < length; ++i) arr[i] = arrayLike[i];\n\t\t\t\treturn arr;\n\t\t\t}\n\t\t}\n\t\tarr = [];\n\t} else {\n\t\t// Result: Non plain array\n\t\tContext = this;\n\t}\n\n\tif (!isArray(arrayLike)) {\n\t\tif ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n\t\t\t// Source: Iterator\n\t\t\titerator = callable(getIterator).call(arrayLike);\n\t\t\tif (Context) arr = new Context();\n\t\t\tresult = iterator.next();\n\t\t\ti = 0;\n\t\t\twhile (!result.done) {\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[i] = value;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tlength = i;\n\t\t} else if (isString(arrayLike)) {\n\t\t\t// Source: String\n\t\t\tlength = arrayLike.length;\n\t\t\tif (Context) arr = new Context();\n\t\t\tfor (i = 0, j = 0; i < length; ++i) {\n\t\t\t\tvalue = arrayLike[i];\n\t\t\t\tif (i + 1 < length) {\n\t\t\t\t\tcode = value.charCodeAt(0);\n\t\t\t\t\t// eslint-disable-next-line max-depth\n\t\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n\t\t\t\t}\n\t\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n\t\t\t\tif (Context) {\n\t\t\t\t\tdesc.value = value;\n\t\t\t\t\tdefineProperty(arr, j, desc);\n\t\t\t\t} else {\n\t\t\t\t\tarr[j] = value;\n\t\t\t\t}\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tlength = j;\n\t\t}\n\t}\n\tif (length === undefined) {\n\t\t// Source: array or array-like\n\t\tlength = toPosInt(arrayLike.length);\n\t\tif (Context) arr = new Context(length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tvalue = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n\t\t\tif (Context) {\n\t\t\t\tdesc.value = value;\n\t\t\t\tdefineProperty(arr, i, desc);\n\t\t\t} else {\n\t\t\t\tarr[i] = value;\n\t\t\t}\n\t\t}\n\t}\n\tif (Context) {\n\t\tdesc.value = null;\n\t\tarr.length = length;\n\t}\n\treturn arr;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , id = objToString.call((function () { return arguments; })());\n\nmodule.exports = function (value) { return objToString.call(value) === id; };\n","\"use strict\";\n\nvar objToString = Object.prototype.toString\n  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);\n\nmodule.exports = function (value) {\n\treturn typeof value === \"function\" && isFunctionStringTag(objToString.call(value));\n};\n","\"use strict\";\n\n// eslint-disable-next-line no-empty-function\nmodule.exports = function () {};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Math.sign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar sign = Math.sign;\n\tif (typeof sign !== \"function\") return false;\n\treturn sign(10) === 1 && sign(-20) === -1;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tvalue = Number(value);\n\tif (isNaN(value) || value === 0) return value;\n\treturn value > 0 ? 1 : -1;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Number.isNaN : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar numberIsNaN = Number.isNaN;\n\tif (typeof numberIsNaN !== \"function\") return false;\n\treturn !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\t// eslint-disable-next-line no-self-compare\n\treturn value !== value;\n};\n","\"use strict\";\n\nvar sign  = require(\"../math/sign\")\n  , abs   = Math.abs\n  , floor = Math.floor;\n\nmodule.exports = function (value) {\n\tif (isNaN(value)) return 0;\n\tvalue = Number(value);\n\tif (value === 0 || !isFinite(value)) return value;\n\treturn sign(value) * floor(abs(value));\n};\n","\"use strict\";\n\nvar toInteger = require(\"./to-integer\")\n  , max       = Math.max;\n\nmodule.exports = function (value) { return max(0, toInteger(value)); };\n","// Internal method, used by iteration functions.\n// Calls a function for each key-value pair found in object\n// Optionally takes compareFn to iterate object in specific order\n\n\"use strict\";\n\nvar callable                = require(\"./valid-callable\")\n  , value                   = require(\"./valid-value\")\n  , bind                    = Function.prototype.bind\n  , call                    = Function.prototype.call\n  , keys                    = Object.keys\n  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nmodule.exports = function (method, defVal) {\n\treturn function (obj, cb/*, thisArg, compareFn*/) {\n\t\tvar list, thisArg = arguments[2], compareFn = arguments[3];\n\t\tobj = Object(value(obj));\n\t\tcallable(cb);\n\n\t\tlist = keys(obj);\n\t\tif (compareFn) {\n\t\t\tlist.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n\t\t}\n\t\tif (typeof method !== \"function\") method = list[method];\n\t\treturn call.call(method, list, function (key, index) {\n\t\t\tif (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n\t\t\treturn call.call(cb, thisArg, obj[key], key, obj, index);\n\t\t});\n\t};\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tvar assign = Object.assign, obj;\n\tif (typeof assign !== \"function\") return false;\n\tobj = { foo: \"raz\" };\n\tassign(obj, { bar: \"dwa\" }, { trzy: \"trzy\" });\n\treturn obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n};\n","\"use strict\";\n\nvar keys  = require(\"../keys\")\n  , value = require(\"../valid-value\")\n  , max   = Math.max;\n\nmodule.exports = function (dest, src/*, …srcn*/) {\n\tvar error, i, length = max(arguments.length, 2), assign;\n\tdest = Object(value(dest));\n\tassign = function (key) {\n\t\ttry {\n\t\t\tdest[key] = src[key];\n\t\t} catch (e) {\n\t\t\tif (!error) error = e;\n\t\t}\n\t};\n\tfor (i = 1; i < length; ++i) {\n\t\tsrc = arguments[i];\n\t\tkeys(src).forEach(assign);\n\t}\n\tif (error !== undefined) throw error;\n\treturn dest;\n};\n","\"use strict\";\n\nvar aFrom  = require(\"../array/from\")\n  , assign = require(\"./assign\")\n  , value  = require(\"./valid-value\");\n\nmodule.exports = function (obj/*, propertyNames, options*/) {\n\tvar copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);\n\tif (copy !== obj && !propertyNames) return copy;\n\tvar result = {};\n\tif (propertyNames) {\n\t\taFrom(propertyNames, function (propertyName) {\n\t\t\tif (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n\t\t});\n\t} else {\n\t\tassign(result, obj);\n\t}\n\treturn result;\n};\n","// Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n\"use strict\";\n\nvar create = Object.create, shim;\n\nif (!require(\"./set-prototype-of/is-implemented\")()) {\n\tshim = require(\"./set-prototype-of/shim\");\n}\n\nmodule.exports = (function () {\n\tvar nullObject, polyProps, desc;\n\tif (!shim) return create;\n\tif (shim.level !== 1) return create;\n\n\tnullObject = {};\n\tpolyProps = {};\n\tdesc = { configurable: false, enumerable: false, writable: true, value: undefined };\n\tObject.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n\t\tif (name === \"__proto__\") {\n\t\t\tpolyProps[name] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: undefined\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tpolyProps[name] = desc;\n\t});\n\tObject.defineProperties(nullObject, polyProps);\n\n\tObject.defineProperty(shim, \"nullPolyfill\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: nullObject\n\t});\n\n\treturn function (prototype, props) {\n\t\treturn create(prototype === null ? nullObject : prototype, props);\n\t};\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./_iterate\")(\"forEach\");\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar map = { function: true, object: true };\n\nmodule.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };\n","\"use strict\";\n\nvar _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\nmodule.exports = function (val) { return val !== _undefined && val !== null; };\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n","\"use strict\";\n\nmodule.exports = function () {\n\ttry {\n\t\tObject.keys(\"primitive\");\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue = require(\"../is-value\");\n\nvar keys = Object.keys;\n\nmodule.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };\n","\"use strict\";\n\nvar callable = require(\"./valid-callable\")\n  , forEach  = require(\"./for-each\")\n  , call     = Function.prototype.call;\n\nmodule.exports = function (obj, cb/*, thisArg*/) {\n\tvar result = {}, thisArg = arguments[2];\n\tcallable(cb);\n\tforEach(obj, function (value, key, targetObj, index) {\n\t\tresult[key] = call.call(cb, thisArg, value, key, targetObj, index);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\nvar process = function (src, obj) {\n\tvar key;\n\tfor (key in src) obj[key] = src[key];\n};\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (opts1/*, …options*/) {\n\tvar result = create(null);\n\tforEach.call(arguments, function (options) {\n\t\tif (!isValue(options)) return;\n\t\tprocess(Object(options), result);\n\t});\n\treturn result;\n};\n","\"use strict\";\n\nvar forEach = Array.prototype.forEach, create = Object.create;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function (arg/*, …args*/) {\n\tvar set = create(null);\n\tforEach.call(arguments, function (name) { set[name] = true; });\n\treturn set;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? Object.setPrototypeOf : require(\"./shim\");\n","\"use strict\";\n\nvar create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};\n\nmodule.exports = function (/* CustomCreate*/) {\n\tvar setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;\n\tif (typeof setPrototypeOf !== \"function\") return false;\n\treturn getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n};\n","/* eslint no-proto: \"off\" */\n\n// Big thanks to @WebReflection for sorting this out\n// https://gist.github.com/WebReflection/5593554\n\n\"use strict\";\n\nvar isObject         = require(\"../is-object\")\n  , value            = require(\"../valid-value\")\n  , objIsPrototypeOf = Object.prototype.isPrototypeOf\n  , defineProperty   = Object.defineProperty\n  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }\n  , validate;\n\nvalidate = function (obj, prototype) {\n\tvalue(obj);\n\tif (prototype === null || isObject(prototype)) return obj;\n\tthrow new TypeError(\"Prototype must be null or an object\");\n};\n\nmodule.exports = (function (status) {\n\tvar fn, set;\n\tif (!status) return null;\n\tif (status.level === 2) {\n\t\tif (status.set) {\n\t\t\tset = status.set;\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tset.call(validate(obj, prototype), prototype);\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t} else {\n\t\t\tfn = function (obj, prototype) {\n\t\t\t\tvalidate(obj, prototype).__proto__ = prototype;\n\t\t\t\treturn obj;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tfn = function self(obj, prototype) {\n\t\t\tvar isNullBase;\n\t\t\tvalidate(obj, prototype);\n\t\t\tisNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n\t\t\tif (isNullBase) delete self.nullPolyfill.__proto__;\n\t\t\tif (prototype === null) prototype = self.nullPolyfill;\n\t\t\tobj.__proto__ = prototype;\n\t\t\tif (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n\t\t\treturn obj;\n\t\t};\n\t}\n\treturn Object.defineProperty(fn, \"level\", {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\twritable: false,\n\t\tvalue: status.level\n\t});\n})(\n\t(function () {\n\t\tvar tmpObj1 = Object.create(null)\n\t\t  , tmpObj2 = {}\n\t\t  , set\n\t\t  , desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n\n\t\tif (desc) {\n\t\t\ttry {\n\t\t\t\tset = desc.set; // Opera crashes at this point\n\t\t\t\tset.call(tmpObj1, tmpObj2);\n\t\t\t} catch (ignore) {}\n\t\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };\n\t\t}\n\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };\n\n\t\ttmpObj1 = {};\n\t\ttmpObj1.__proto__ = tmpObj2;\n\t\tif (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };\n\n\t\treturn false;\n\t})()\n);\n\nrequire(\"../create\");\n","\"use strict\";\n\nmodule.exports = function (fn) {\n\tif (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n\treturn fn;\n};\n","\"use strict\";\n\nvar isValue = require(\"./is-value\");\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n\treturn value;\n};\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n","\"use strict\";\n\nvar str = \"razdwatrzy\";\n\nmodule.exports = function () {\n\tif (typeof str.contains !== \"function\") return false;\n\treturn str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n};\n","\"use strict\";\n\nvar indexOf = String.prototype.indexOf;\n\nmodule.exports = function (searchString/*, position*/) {\n\treturn indexOf.call(this, searchString, arguments[1]) > -1;\n};\n","\"use strict\";\n\nvar objToString = Object.prototype.toString, id = objToString.call(\"\");\n\nmodule.exports = function (value) {\n\treturn (\n\t\ttypeof value === \"string\" ||\n\t\t(value &&\n\t\t\ttypeof value === \"object\" &&\n\t\t\t(value instanceof String || objToString.call(value) === id)) ||\n\t\tfalse\n\t);\n};\n","\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , contains       = require(\"es5-ext/string/#/contains\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, ArrayIterator;\n\nArrayIterator = module.exports = function (arr, kind) {\n\tif (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tIterator.call(this, arr);\n\tif (!kind) kind = \"value\";\n\telse if (contains.call(kind, \"key+value\")) kind = \"key+value\";\n\telse if (contains.call(kind, \"key\")) kind = \"key\";\n\telse kind = \"value\";\n\tdefineProperty(this, \"__kind__\", d(\"\", kind));\n};\nif (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete ArrayIterator.prototype.constructor;\n\nArrayIterator.prototype = Object.create(Iterator.prototype, {\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === \"value\") return this.__list__[i];\n\t\tif (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n\t\treturn i;\n\t})\n});\ndefineProperty(ArrayIterator.prototype, Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , callable    = require(\"es5-ext/object/valid-callable\")\n  , isString    = require(\"es5-ext/string/is-string\")\n  , get         = require(\"./get\");\n\nvar isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;\n\nmodule.exports = function (iterable, cb /*, thisArg*/) {\n\tvar mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;\n\tif (isArray(iterable) || isArguments(iterable)) mode = \"array\";\n\telse if (isString(iterable)) mode = \"string\";\n\telse iterable = get(iterable);\n\n\tcallable(cb);\n\tdoBreak = function () {\n\t\tbroken = true;\n\t};\n\tif (mode === \"array\") {\n\t\tsome.call(iterable, function (value) {\n\t\t\tcall.call(cb, thisArg, value, doBreak);\n\t\t\treturn broken;\n\t\t});\n\t\treturn;\n\t}\n\tif (mode === \"string\") {\n\t\tlength = iterable.length;\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tchar = iterable[i];\n\t\t\tif (i + 1 < length) {\n\t\t\t\tcode = char.charCodeAt(0);\n\t\t\t\tif (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];\n\t\t\t}\n\t\t\tcall.call(cb, thisArg, char, doBreak);\n\t\t\tif (broken) break;\n\t\t}\n\t\treturn;\n\t}\n\tresult = iterable.next();\n\n\twhile (!result.done) {\n\t\tcall.call(cb, thisArg, result.value, doBreak);\n\t\tif (broken) return;\n\t\tresult = iterable.next();\n\t}\n};\n","\"use strict\";\n\nvar isArguments    = require(\"es5-ext/function/is-arguments\")\n  , isString       = require(\"es5-ext/string/is-string\")\n  , ArrayIterator  = require(\"./array\")\n  , StringIterator = require(\"./string\")\n  , iterable       = require(\"./valid-iterable\")\n  , iteratorSymbol = require(\"es6-symbol\").iterator;\n\nmodule.exports = function (obj) {\n\tif (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n\tif (isArguments(obj)) return new ArrayIterator(obj);\n\tif (isString(obj)) return new StringIterator(obj);\n\treturn new ArrayIterator(obj);\n};\n","\"use strict\";\n\nvar clear    = require(\"es5-ext/array/#/clear\")\n  , assign   = require(\"es5-ext/object/assign\")\n  , callable = require(\"es5-ext/object/valid-callable\")\n  , value    = require(\"es5-ext/object/valid-value\")\n  , d        = require(\"d\")\n  , autoBind = require(\"d/auto-bind\")\n  , Symbol   = require(\"es6-symbol\");\n\nvar defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;\n\nmodule.exports = Iterator = function (list, context) {\n\tif (!(this instanceof Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tdefineProperties(this, {\n\t\t__list__: d(\"w\", value(list)),\n\t\t__context__: d(\"w\", context),\n\t\t__nextIndex__: d(\"w\", 0)\n\t});\n\tif (!context) return;\n\tcallable(context.on);\n\tcontext.on(\"_add\", this._onAdd);\n\tcontext.on(\"_delete\", this._onDelete);\n\tcontext.on(\"_clear\", this._onClear);\n};\n\n// Internal %IteratorPrototype% doesn't expose its constructor\ndelete Iterator.prototype.constructor;\n\ndefineProperties(\n\tIterator.prototype,\n\tassign(\n\t\t{\n\t\t\t_next: d(function () {\n\t\t\t\tvar i;\n\t\t\t\tif (!this.__list__) return undefined;\n\t\t\t\tif (this.__redo__) {\n\t\t\t\t\ti = this.__redo__.shift();\n\t\t\t\t\tif (i !== undefined) return i;\n\t\t\t\t}\n\t\t\t\tif (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n\t\t\t\tthis._unBind();\n\t\t\t\treturn undefined;\n\t\t\t}),\n\t\t\tnext: d(function () {\n\t\t\t\treturn this._createResult(this._next());\n\t\t\t}),\n\t\t\t_createResult: d(function (i) {\n\t\t\t\tif (i === undefined) return { done: true, value: undefined };\n\t\t\t\treturn { done: false, value: this._resolve(i) };\n\t\t\t}),\n\t\t\t_resolve: d(function (i) {\n\t\t\t\treturn this.__list__[i];\n\t\t\t}),\n\t\t\t_unBind: d(function () {\n\t\t\t\tthis.__list__ = null;\n\t\t\t\tdelete this.__redo__;\n\t\t\t\tif (!this.__context__) return;\n\t\t\t\tthis.__context__.off(\"_add\", this._onAdd);\n\t\t\t\tthis.__context__.off(\"_delete\", this._onDelete);\n\t\t\t\tthis.__context__.off(\"_clear\", this._onClear);\n\t\t\t\tthis.__context__ = null;\n\t\t\t}),\n\t\t\ttoString: d(function () {\n\t\t\t\treturn \"[object \" + (this[Symbol.toStringTag] || \"Object\") + \"]\";\n\t\t\t})\n\t\t},\n\t\tautoBind({\n\t\t\t_onAdd: d(function (index) {\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t++this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) {\n\t\t\t\t\tdefineProperty(this, \"__redo__\", d(\"c\", [index]));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.__redo__.forEach(function (redo, i) {\n\t\t\t\t\tif (redo >= index) this.__redo__[i] = ++redo;\n\t\t\t\t}, this);\n\t\t\t\tthis.__redo__.push(index);\n\t\t\t}),\n\t\t\t_onDelete: d(function (index) {\n\t\t\t\tvar i;\n\t\t\t\tif (index >= this.__nextIndex__) return;\n\t\t\t\t--this.__nextIndex__;\n\t\t\t\tif (!this.__redo__) return;\n\t\t\t\ti = this.__redo__.indexOf(index);\n\t\t\t\tif (i !== -1) this.__redo__.splice(i, 1);\n\t\t\t\tthis.__redo__.forEach(function (redo, j) {\n\t\t\t\t\tif (redo > index) this.__redo__[j] = --redo;\n\t\t\t\t}, this);\n\t\t\t}),\n\t\t\t_onClear: d(function () {\n\t\t\t\tif (this.__redo__) clear.call(this.__redo__);\n\t\t\t\tthis.__nextIndex__ = 0;\n\t\t\t})\n\t\t})\n\t)\n);\n\ndefineProperty(\n\tIterator.prototype,\n\tSymbol.iterator,\n\td(function () {\n\t\treturn this;\n\t})\n);\n","\"use strict\";\n\nvar isArguments = require(\"es5-ext/function/is-arguments\")\n  , isValue     = require(\"es5-ext/object/is-value\")\n  , isString    = require(\"es5-ext/string/is-string\");\n\nvar iteratorSymbol = require(\"es6-symbol\").iterator\n  , isArray        = Array.isArray;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\tif (isArray(value)) return true;\n\tif (isString(value)) return true;\n\tif (isArguments(value)) return true;\n\treturn typeof value[iteratorSymbol] === \"function\";\n};\n","// Thanks @mathiasbynens\n// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n\"use strict\";\n\nvar setPrototypeOf = require(\"es5-ext/object/set-prototype-of\")\n  , d              = require(\"d\")\n  , Symbol         = require(\"es6-symbol\")\n  , Iterator       = require(\"./\");\n\nvar defineProperty = Object.defineProperty, StringIterator;\n\nStringIterator = module.exports = function (str) {\n\tif (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n\tstr = String(str);\n\tIterator.call(this, str);\n\tdefineProperty(this, \"__length__\", d(\"\", str.length));\n};\nif (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n// Internal %ArrayIteratorPrototype% doesn't expose its constructor\ndelete StringIterator.prototype.constructor;\n\nStringIterator.prototype = Object.create(Iterator.prototype, {\n\t_next: d(function () {\n\t\tif (!this.__list__) return undefined;\n\t\tif (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n\t\tthis._unBind();\n\t\treturn undefined;\n\t}),\n\t_resolve: d(function (i) {\n\t\tvar char = this.__list__[i], code;\n\t\tif (this.__nextIndex__ === this.__length__) return char;\n\t\tcode = char.charCodeAt(0);\n\t\tif (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];\n\t\treturn char;\n\t})\n});\ndefineProperty(StringIterator.prototype, Symbol.toStringTag, d(\"c\", \"String Iterator\"));\n","\"use strict\";\n\nvar isIterable = require(\"./is-iterable\");\n\nmodule.exports = function (value) {\n\tif (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n\treturn value;\n};\n","'use strict';\n\nmodule.exports = require('./is-implemented')() ? Map : require('./polyfill');\n","'use strict';\n\nmodule.exports = function () {\n\tvar map, iterator, result;\n\tif (typeof Map !== 'function') return false;\n\ttry {\n\t\t// WebKit doesn't support arguments and crashes\n\t\tmap = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n\t} catch (e) {\n\t\treturn false;\n\t}\n\tif (String(map) !== '[object Map]') return false;\n\tif (map.size !== 3) return false;\n\tif (typeof map.clear !== 'function') return false;\n\tif (typeof map.delete !== 'function') return false;\n\tif (typeof map.entries !== 'function') return false;\n\tif (typeof map.forEach !== 'function') return false;\n\tif (typeof map.get !== 'function') return false;\n\tif (typeof map.has !== 'function') return false;\n\tif (typeof map.keys !== 'function') return false;\n\tif (typeof map.set !== 'function') return false;\n\tif (typeof map.values !== 'function') return false;\n\n\titerator = map.entries();\n\tresult = iterator.next();\n\tif (result.done !== false) return false;\n\tif (!result.value) return false;\n\tif (result.value[0] !== 'raz') return false;\n\tif (result.value[1] !== 'one') return false;\n\n\treturn true;\n};\n","// Exports true if environment provides native `Map` implementation,\n// whatever that is.\n\n'use strict';\n\nmodule.exports = (function () {\n\tif (typeof Map === 'undefined') return false;\n\treturn (Object.prototype.toString.call(new Map()) === '[object Map]');\n}());\n","'use strict';\n\nmodule.exports = require('es5-ext/object/primitive-set')('key',\n\t'value', 'key+value');\n","'use strict';\n\nvar setPrototypeOf    = require('es5-ext/object/set-prototype-of')\n  , d                 = require('d')\n  , Iterator          = require('es6-iterator')\n  , toStringTagSymbol = require('es6-symbol').toStringTag\n  , kinds             = require('./iterator-kinds')\n\n  , defineProperties = Object.defineProperties\n  , unBind = Iterator.prototype._unBind\n  , MapIterator;\n\nMapIterator = module.exports = function (map, kind) {\n\tif (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n\tIterator.call(this, map.__mapKeysData__, map);\n\tif (!kind || !kinds[kind]) kind = 'key+value';\n\tdefineProperties(this, {\n\t\t__kind__: d('', kind),\n\t\t__values__: d('w', map.__mapValuesData__)\n\t});\n};\nif (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n\nMapIterator.prototype = Object.create(Iterator.prototype, {\n\tconstructor: d(MapIterator),\n\t_resolve: d(function (i) {\n\t\tif (this.__kind__ === 'value') return this.__values__[i];\n\t\tif (this.__kind__ === 'key') return this.__list__[i];\n\t\treturn [this.__list__[i], this.__values__[i]];\n\t}),\n\t_unBind: d(function () {\n\t\tthis.__values__ = null;\n\t\tunBind.call(this);\n\t}),\n\ttoString: d(function () { return '[object Map Iterator]'; })\n});\nObject.defineProperty(MapIterator.prototype, toStringTagSymbol,\n\td('c', 'Map Iterator'));\n","'use strict';\n\nvar clear          = require('es5-ext/array/#/clear')\n  , eIndexOf       = require('es5-ext/array/#/e-index-of')\n  , setPrototypeOf = require('es5-ext/object/set-prototype-of')\n  , callable       = require('es5-ext/object/valid-callable')\n  , validValue     = require('es5-ext/object/valid-value')\n  , d              = require('d')\n  , ee             = require('event-emitter')\n  , Symbol         = require('es6-symbol')\n  , iterator       = require('es6-iterator/valid-iterable')\n  , forOf          = require('es6-iterator/for-of')\n  , Iterator       = require('./lib/iterator')\n  , isNative       = require('./is-native-implemented')\n\n  , call = Function.prototype.call\n  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf\n  , MapPoly;\n\nmodule.exports = MapPoly = function (/*iterable*/) {\n\tvar iterable = arguments[0], keys, values, self;\n\tif (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n\tif (isNative && setPrototypeOf && (Map !== MapPoly)) {\n\t\tself = setPrototypeOf(new Map(), getPrototypeOf(this));\n\t} else {\n\t\tself = this;\n\t}\n\tif (iterable != null) iterator(iterable);\n\tdefineProperties(self, {\n\t\t__mapKeysData__: d('c', keys = []),\n\t\t__mapValuesData__: d('c', values = [])\n\t});\n\tif (!iterable) return self;\n\tforOf(iterable, function (value) {\n\t\tvar key = validValue(value)[0];\n\t\tvalue = value[1];\n\t\tif (eIndexOf.call(keys, key) !== -1) return;\n\t\tkeys.push(key);\n\t\tvalues.push(value);\n\t}, self);\n\treturn self;\n};\n\nif (isNative) {\n\tif (setPrototypeOf) setPrototypeOf(MapPoly, Map);\n\tMapPoly.prototype = Object.create(Map.prototype, {\n\t\tconstructor: d(MapPoly)\n\t});\n}\n\nee(defineProperties(MapPoly.prototype, {\n\tclear: d(function () {\n\t\tif (!this.__mapKeysData__.length) return;\n\t\tclear.call(this.__mapKeysData__);\n\t\tclear.call(this.__mapValuesData__);\n\t\tthis.emit('_clear');\n\t}),\n\tdelete: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return false;\n\t\tthis.__mapKeysData__.splice(index, 1);\n\t\tthis.__mapValuesData__.splice(index, 1);\n\t\tthis.emit('_delete', index, key);\n\t\treturn true;\n\t}),\n\tentries: d(function () { return new Iterator(this, 'key+value'); }),\n\tforEach: d(function (cb/*, thisArg*/) {\n\t\tvar thisArg = arguments[1], iterator, result;\n\t\tcallable(cb);\n\t\titerator = this.entries();\n\t\tresult = iterator._next();\n\t\twhile (result !== undefined) {\n\t\t\tcall.call(cb, thisArg, this.__mapValuesData__[result],\n\t\t\t\tthis.__mapKeysData__[result], this);\n\t\t\tresult = iterator._next();\n\t\t}\n\t}),\n\tget: d(function (key) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key);\n\t\tif (index === -1) return;\n\t\treturn this.__mapValuesData__[index];\n\t}),\n\thas: d(function (key) {\n\t\treturn (eIndexOf.call(this.__mapKeysData__, key) !== -1);\n\t}),\n\tkeys: d(function () { return new Iterator(this, 'key'); }),\n\tset: d(function (key, value) {\n\t\tvar index = eIndexOf.call(this.__mapKeysData__, key), emit;\n\t\tif (index === -1) {\n\t\t\tindex = this.__mapKeysData__.push(key) - 1;\n\t\t\temit = true;\n\t\t}\n\t\tthis.__mapValuesData__[index] = value;\n\t\tif (emit) this.emit('_add', index, key);\n\t\treturn this;\n\t}),\n\tsize: d.gs(function () { return this.__mapKeysData__.length; }),\n\tvalues: d(function () { return new Iterator(this, 'value'); }),\n\ttoString: d(function () { return '[object Map]'; })\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {\n\treturn this.entries();\n}));\nObject.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")()\n\t? require(\"ext/global-this\").Symbol\n\t: require(\"./polyfill\");\n","\"use strict\";\n\nvar global     = require(\"ext/global-this\")\n  , validTypes = { object: true, symbol: true };\n\nmodule.exports = function () {\n\tvar Symbol = global.Symbol;\n\tvar symbol;\n\tif (typeof Symbol !== \"function\") return false;\n\tsymbol = Symbol(\"test symbol\");\n\ttry { String(symbol); }\n\tcatch (e) { return false; }\n\n\t// Return 'true' also for polyfills\n\tif (!validTypes[typeof Symbol.iterator]) return false;\n\tif (!validTypes[typeof Symbol.toPrimitive]) return false;\n\tif (!validTypes[typeof Symbol.toStringTag]) return false;\n\n\treturn true;\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\tif (!value) return false;\n\tif (typeof value === \"symbol\") return true;\n\tif (!value.constructor) return false;\n\tif (value.constructor.name !== \"Symbol\") return false;\n\treturn value[value.constructor.toStringTag] === \"Symbol\";\n};\n","\"use strict\";\n\nvar d = require(\"d\");\n\nvar create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;\n\nvar created = create(null);\nmodule.exports = function (desc) {\n\tvar postfix = 0, name, ie11BugWorkaround;\n\twhile (created[desc + (postfix || \"\")]) ++postfix;\n\tdesc += postfix || \"\";\n\tcreated[desc] = true;\n\tname = \"@@\" + desc;\n\tdefineProperty(\n\t\tobjPrototype,\n\t\tname,\n\t\td.gs(null, function (value) {\n\t\t\t// For IE11 issue see:\n\t\t\t// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n\t\t\t//    ie11-broken-getters-on-dom-objects\n\t\t\t// https://github.com/medikoo/es6-symbol/issues/12\n\t\t\tif (ie11BugWorkaround) return;\n\t\t\tie11BugWorkaround = true;\n\t\t\tdefineProperty(this, name, d(value));\n\t\t\tie11BugWorkaround = false;\n\t\t})\n\t);\n\treturn name;\n};\n","\"use strict\";\n\nvar d            = require(\"d\")\n  , NativeSymbol = require(\"ext/global-this\").Symbol;\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\t// To ensure proper interoperability with other native functions (e.g. Array.from)\n\t\t// fallback to eventual native implementation of given symbol\n\t\thasInstance: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill(\"hasInstance\")\n\t\t),\n\t\tisConcatSpreadable: d(\n\t\t\t\"\",\n\t\t\t(NativeSymbol && NativeSymbol.isConcatSpreadable) ||\n\t\t\t\tSymbolPolyfill(\"isConcatSpreadable\")\n\t\t),\n\t\titerator: d(\"\", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill(\"iterator\")),\n\t\tmatch: d(\"\", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill(\"match\")),\n\t\treplace: d(\"\", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill(\"replace\")),\n\t\tsearch: d(\"\", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill(\"search\")),\n\t\tspecies: d(\"\", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill(\"species\")),\n\t\tsplit: d(\"\", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill(\"split\")),\n\t\ttoPrimitive: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill(\"toPrimitive\")\n\t\t),\n\t\ttoStringTag: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill(\"toStringTag\")\n\t\t),\n\t\tunscopables: d(\n\t\t\t\"\", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill(\"unscopables\")\n\t\t)\n\t});\n};\n","\"use strict\";\n\nvar d              = require(\"d\")\n  , validateSymbol = require(\"../../../validate-symbol\");\n\nvar registry = Object.create(null);\n\nmodule.exports = function (SymbolPolyfill) {\n\treturn Object.defineProperties(SymbolPolyfill, {\n\t\tfor: d(function (key) {\n\t\t\tif (registry[key]) return registry[key];\n\t\t\treturn (registry[key] = SymbolPolyfill(String(key)));\n\t\t}),\n\t\tkeyFor: d(function (symbol) {\n\t\t\tvar key;\n\t\t\tvalidateSymbol(symbol);\n\t\t\tfor (key in registry) {\n\t\t\t\tif (registry[key] === symbol) return key;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t})\n\t});\n};\n","// ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n\"use strict\";\n\nvar d                    = require(\"d\")\n  , validateSymbol       = require(\"./validate-symbol\")\n  , NativeSymbol         = require(\"ext/global-this\").Symbol\n  , generateName         = require(\"./lib/private/generate-name\")\n  , setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\")\n  , setupSymbolRegistry  = require(\"./lib/private/setup/symbol-registry\");\n\nvar create = Object.create\n  , defineProperties = Object.defineProperties\n  , defineProperty = Object.defineProperty;\n\nvar SymbolPolyfill, HiddenSymbol, isNativeSafe;\n\nif (typeof NativeSymbol === \"function\") {\n\ttry {\n\t\tString(NativeSymbol());\n\t\tisNativeSafe = true;\n\t} catch (ignore) {}\n} else {\n\tNativeSymbol = null;\n}\n\n// Internal constructor (not one exposed) for creating Symbol instances.\n// This one is used to ensure that `someSymbol instanceof Symbol` always return false\nHiddenSymbol = function Symbol(description) {\n\tif (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n\treturn SymbolPolyfill(description);\n};\n\n// Exposed `Symbol` constructor\n// (returns instances of HiddenSymbol)\nmodule.exports = SymbolPolyfill = function Symbol(description) {\n\tvar symbol;\n\tif (this instanceof Symbol) throw new TypeError(\"Symbol is not a constructor\");\n\tif (isNativeSafe) return NativeSymbol(description);\n\tsymbol = create(HiddenSymbol.prototype);\n\tdescription = description === undefined ? \"\" : String(description);\n\treturn defineProperties(symbol, {\n\t\t__description__: d(\"\", description),\n\t\t__name__: d(\"\", generateName(description))\n\t});\n};\n\nsetupStandardSymbols(SymbolPolyfill);\nsetupSymbolRegistry(SymbolPolyfill);\n\n// Internal tweaks for real symbol producer\ndefineProperties(HiddenSymbol.prototype, {\n\tconstructor: d(SymbolPolyfill),\n\ttoString: d(\"\", function () { return this.__name__; })\n});\n\n// Proper implementation of methods exposed on Symbol.prototype\n// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\ndefineProperties(SymbolPolyfill.prototype, {\n\ttoString: d(function () { return \"Symbol (\" + validateSymbol(this).__description__ + \")\"; }),\n\tvalueOf: d(function () { return validateSymbol(this); })\n});\ndefineProperty(\n\tSymbolPolyfill.prototype,\n\tSymbolPolyfill.toPrimitive,\n\td(\"\", function () {\n\t\tvar symbol = validateSymbol(this);\n\t\tif (typeof symbol === \"symbol\") return symbol;\n\t\treturn symbol.toString();\n\t})\n);\ndefineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n// Proper implementaton of toPrimitive and toStringTag for returned symbol instances\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toStringTag,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])\n);\n\n// Note: It's important to define `toPrimitive` as last one, as some implementations\n// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n// And that may invoke error in definition flow:\n// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\ndefineProperty(\n\tHiddenSymbol.prototype, SymbolPolyfill.toPrimitive,\n\td(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])\n);\n","\"use strict\";\n\nvar isSymbol = require(\"./is-symbol\");\n\nmodule.exports = function (value) {\n\tif (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n\treturn value;\n};\n","'use strict';\n\nvar d        = require('d')\n  , callable = require('es5-ext/object/valid-callable')\n\n  , apply = Function.prototype.apply, call = Function.prototype.call\n  , create = Object.create, defineProperty = Object.defineProperty\n  , defineProperties = Object.defineProperties\n  , hasOwnProperty = Object.prototype.hasOwnProperty\n  , descriptor = { configurable: true, enumerable: false, writable: true }\n\n  , on, once, off, emit, methods, descriptors, base;\n\non = function (type, listener) {\n\tvar data;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) {\n\t\tdata = descriptor.value = create(null);\n\t\tdefineProperty(this, '__ee__', descriptor);\n\t\tdescriptor.value = null;\n\t} else {\n\t\tdata = this.__ee__;\n\t}\n\tif (!data[type]) data[type] = listener;\n\telse if (typeof data[type] === 'object') data[type].push(listener);\n\telse data[type] = [data[type], listener];\n\n\treturn this;\n};\n\nonce = function (type, listener) {\n\tvar once, self;\n\n\tcallable(listener);\n\tself = this;\n\ton.call(this, type, once = function () {\n\t\toff.call(self, type, once);\n\t\tapply.call(listener, this, arguments);\n\t});\n\n\tonce.__eeOnceListener__ = listener;\n\treturn this;\n};\n\noff = function (type, listener) {\n\tvar data, listeners, candidate, i;\n\n\tcallable(listener);\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return this;\n\tdata = this.__ee__;\n\tif (!data[type]) return this;\n\tlisteners = data[type];\n\n\tif (typeof listeners === 'object') {\n\t\tfor (i = 0; (candidate = listeners[i]); ++i) {\n\t\t\tif ((candidate === listener) ||\n\t\t\t\t\t(candidate.__eeOnceListener__ === listener)) {\n\t\t\t\tif (listeners.length === 2) data[type] = listeners[i ? 0 : 1];\n\t\t\t\telse listeners.splice(i, 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((listeners === listener) ||\n\t\t\t\t(listeners.__eeOnceListener__ === listener)) {\n\t\t\tdelete data[type];\n\t\t}\n\t}\n\n\treturn this;\n};\n\nemit = function (type) {\n\tvar i, l, listener, listeners, args;\n\n\tif (!hasOwnProperty.call(this, '__ee__')) return;\n\tlisteners = this.__ee__[type];\n\tif (!listeners) return;\n\n\tif (typeof listeners === 'object') {\n\t\tl = arguments.length;\n\t\targs = new Array(l - 1);\n\t\tfor (i = 1; i < l; ++i) args[i - 1] = arguments[i];\n\n\t\tlisteners = listeners.slice();\n\t\tfor (i = 0; (listener = listeners[i]); ++i) {\n\t\t\tapply.call(listener, this, args);\n\t\t}\n\t} else {\n\t\tswitch (arguments.length) {\n\t\tcase 1:\n\t\t\tcall.call(listeners, this);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcall.call(listeners, this, arguments[1]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcall.call(listeners, this, arguments[1], arguments[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl = arguments.length;\n\t\t\targs = new Array(l - 1);\n\t\t\tfor (i = 1; i < l; ++i) {\n\t\t\t\targs[i - 1] = arguments[i];\n\t\t\t}\n\t\t\tapply.call(listeners, this, args);\n\t\t}\n\t}\n};\n\nmethods = {\n\ton: on,\n\tonce: once,\n\toff: off,\n\temit: emit\n};\n\ndescriptors = {\n\ton: d(on),\n\tonce: d(once),\n\toff: d(off),\n\temit: d(emit)\n};\n\nbase = defineProperties({}, descriptors);\n\nmodule.exports = exports = function (o) {\n\treturn (o == null) ? create(base) : defineProperties(Object(o), descriptors);\n};\nexports.methods = methods;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ is resolved with global context, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\n\nmodule.exports = require(\"./is-implemented\")() ? globalThis : require(\"./implementation\");\n","\"use strict\";\n\nmodule.exports = function () {\n\tif (typeof globalThis !== \"object\") return false;\n\tif (!globalThis) return false;\n\treturn globalThis.Array === Array;\n};\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * in-array <https://github.com/jonschlinkert/in-array>\n *\n * Copyright (c) 2014 Jon Schlinkert, contributors.\n * Licensed under the MIT License\n */\n\n'use strict';\n\nmodule.exports = function inArray (arr, val) {\n  arr = arr || [];\n  var len = arr.length;\n  var i;\n\n  for (i = 0; i < len; i++) {\n    if (arr[i] === val) {\n      return true;\n    }\n  }\n  return false;\n};\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// Copyright 2014, 2015 Simon Lydell\n// X11 (“MIT”) Licensed. (See LICENSE.)\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nmodule.exports = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyu]{1,5}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|((?:0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?))|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]{1,6}\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-*\\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nmodule.exports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0]}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\n\n/* Protocol - protocol constants */\nvar protocol = module.exports\n\n/* Command code => mnemonic */\nprotocol.types = {\n  0: 'reserved',\n  1: 'connect',\n  2: 'connack',\n  3: 'publish',\n  4: 'puback',\n  5: 'pubrec',\n  6: 'pubrel',\n  7: 'pubcomp',\n  8: 'subscribe',\n  9: 'suback',\n  10: 'unsubscribe',\n  11: 'unsuback',\n  12: 'pingreq',\n  13: 'pingresp',\n  14: 'disconnect',\n  15: 'reserved'\n}\n\n/* Mnemonic => Command code */\nprotocol.codes = {}\nfor (var k in protocol.types) {\n  var v = protocol.types[k]\n  protocol.codes[v] = k\n}\n\n/* Header */\nprotocol.CMD_SHIFT = 4\nprotocol.CMD_MASK = 0xF0\nprotocol.DUP_MASK = 0x08\nprotocol.QOS_MASK = 0x03\nprotocol.QOS_SHIFT = 1\nprotocol.RETAIN_MASK = 0x01\n\n/* Length */\nprotocol.LENGTH_MASK = 0x7F\nprotocol.LENGTH_FIN_MASK = 0x80\n\n/* Connack */\nprotocol.SESSIONPRESENT_MASK = 0x01\nprotocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK])\nprotocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT])\n\n/* Connect */\nprotocol.USERNAME_MASK = 0x80\nprotocol.PASSWORD_MASK = 0x40\nprotocol.WILL_RETAIN_MASK = 0x20\nprotocol.WILL_QOS_MASK = 0x18\nprotocol.WILL_QOS_SHIFT = 3\nprotocol.WILL_FLAG_MASK = 0x04\nprotocol.CLEAN_SESSION_MASK = 0x02\nprotocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT])\n\nfunction genHeader (type) {\n  return [0, 1, 2].map(function (qos) {\n    return [0, 1].map(function (dup) {\n      return [0, 1].map(function (retain) {\n        var buf = new Buffer(1)\n        buf.writeUInt8(\n          protocol.codes[type] << protocol.CMD_SHIFT |\n          (dup ? protocol.DUP_MASK : 0) |\n          qos << protocol.QOS_SHIFT | retain, 0, true)\n        return buf\n      })\n    })\n  })\n}\n\n/* Publish */\nprotocol.PUBLISH_HEADER = genHeader('publish')\n\n/* Subscribe */\nprotocol.SUBSCRIBE_HEADER = genHeader('subscribe')\n\n/* Unsubscribe */\nprotocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe')\n\n/* Confirmations */\nprotocol.ACKS = {\n  unsuback: genHeader('unsuback'),\n  puback: genHeader('puback'),\n  pubcomp: genHeader('pubcomp'),\n  pubrel: genHeader('pubrel'),\n  pubrec: genHeader('pubrec')\n}\n\nprotocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT])\n\n/* Protocol versions */\nprotocol.VERSION3 = Buffer.from([3])\nprotocol.VERSION4 = Buffer.from([4])\n\n/* QoS */\nprotocol.QOS = [0, 1, 2].map(function (qos) {\n  return Buffer.from([qos])\n})\n\n/* Empty packets */\nprotocol.EMPTY = {\n  pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n  pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n  disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0])\n}\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar writeToStream = require('./writeToStream')\nvar EE = require('events').EventEmitter\nvar inherits = require('inherits')\n\nfunction generate (packet) {\n  var stream = new Accumulator()\n  writeToStream(packet, stream)\n  return stream.concat()\n}\n\nfunction Accumulator () {\n  this._array = new Array(20)\n  this._i = 0\n}\n\ninherits(Accumulator, EE)\n\nAccumulator.prototype.write = function (chunk) {\n  this._array[this._i++] = chunk\n  return true\n}\n\nAccumulator.prototype.concat = function () {\n  var length = 0\n  var lengths = new Array(this._array.length)\n  var list = this._array\n  var pos = 0\n  var i\n  var result\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') lengths[i] = list[i].length\n    else lengths[i] = Buffer.byteLength(list[i])\n\n    length += lengths[i]\n  }\n\n  result = Buffer.allocUnsafe(length)\n\n  for (i = 0; i < list.length && list[i] !== undefined; i++) {\n    if (typeof list[i] !== 'string') {\n      list[i].copy(result, pos)\n      pos += lengths[i]\n    } else {\n      result.write(list[i], pos)\n      pos += lengths[i]\n    }\n  }\n\n  return result\n}\n\nmodule.exports = generate\n","'use strict'\n\nexports.parser = require('./parser')\nexports.generate = require('./generate')\nexports.writeToStream = require('./writeToStream')\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar max = 65536\nvar cache = {}\n\nfunction generateBuffer (i) {\n  var buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer\n}\n","\nfunction Packet () {\n  this.cmd = null\n  this.retain = false\n  this.qos = 0\n  this.dup = false\n  this.length = -1\n  this.topic = null\n  this.payload = null\n}\n\nmodule.exports = Packet\n","'use strict'\n\nvar bl = require('bl')\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar Packet = require('./packet')\nvar constants = require('./constants')\n\nfunction Parser () {\n  if (!(this instanceof Parser)) return new Parser()\n\n  this._states = [\n    '_parseHeader',\n    '_parseLength',\n    '_parsePayload',\n    '_newPacket'\n  ]\n\n  this._resetState()\n}\n\ninherits(Parser, EE)\n\nParser.prototype._resetState = function () {\n  this.packet = new Packet()\n  this.error = null\n  this._list = bl()\n  this._stateCounter = 0\n}\n\nParser.prototype.parse = function (buf) {\n  if (this.error) this._resetState()\n\n  this._list.append(buf)\n\n  while ((this.packet.length !== -1 || this._list.length > 0) &&\n         this[this._states[this._stateCounter]]() &&\n         !this.error) {\n    this._stateCounter++\n\n    if (this._stateCounter >= this._states.length) this._stateCounter = 0\n  }\n\n  return this._list.length\n}\n\nParser.prototype._parseHeader = function () {\n  // There is at least one byte in the buffer\n  var zero = this._list.readUInt8(0)\n  this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT]\n  this.packet.retain = (zero & constants.RETAIN_MASK) !== 0\n  this.packet.qos = (zero >> constants.QOS_SHIFT) & constants.QOS_MASK\n  this.packet.dup = (zero & constants.DUP_MASK) !== 0\n\n  this._list.consume(1)\n\n  return true\n}\n\nParser.prototype._parseLength = function () {\n  // There is at least one byte in the list\n  var bytes = 0\n  var mul = 1\n  var length = 0\n  var result = true\n  var current\n\n  while (bytes < 5) {\n    current = this._list.readUInt8(bytes++)\n    length += mul * (current & constants.LENGTH_MASK)\n    mul *= 0x80\n\n    if ((current & constants.LENGTH_FIN_MASK) === 0) break\n    if (this._list.length <= bytes) {\n      result = false\n      break\n    }\n  }\n\n  if (result) {\n    this.packet.length = length\n    this._list.consume(bytes)\n  }\n\n  return result\n}\n\nParser.prototype._parsePayload = function () {\n  var result = false\n\n  // Do we have a payload? Do we have enough data to complete the payload?\n  // PINGs have no payload\n  if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n    this._pos = 0\n\n    switch (this.packet.cmd) {\n      case 'connect':\n        this._parseConnect()\n        break\n      case 'connack':\n        this._parseConnack()\n        break\n      case 'publish':\n        this._parsePublish()\n        break\n      case 'puback':\n      case 'pubrec':\n      case 'pubrel':\n      case 'pubcomp':\n        this._parseMessageId()\n        break\n      case 'subscribe':\n        this._parseSubscribe()\n        break\n      case 'suback':\n        this._parseSuback()\n        break\n      case 'unsubscribe':\n        this._parseUnsubscribe()\n        break\n      case 'unsuback':\n        this._parseUnsuback()\n        break\n      case 'pingreq':\n      case 'pingresp':\n      case 'disconnect':\n        // These are empty, nothing to do\n        break\n      default:\n        this._emitError(new Error('Not supported'))\n    }\n\n    result = true\n  }\n\n  return result\n}\n\nParser.prototype._parseConnect = function () {\n  var protocolId // Protocol ID\n  var clientId // Client ID\n  var topic // Will topic\n  var payload // Will payload\n  var password // Password\n  var username // Username\n  var flags = {}\n  var packet = this.packet\n\n  // Parse protocolId\n  protocolId = this._parseString()\n\n  if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'))\n  if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n    return this._emitError(new Error('Invalid protocolId'))\n  }\n\n  packet.protocolId = protocolId\n\n  // Parse constants version number\n  if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'))\n\n  packet.protocolVersion = this._list.readUInt8(this._pos)\n\n  if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4) {\n    return this._emitError(new Error('Invalid protocol version'))\n  }\n\n  this._pos++\n\n  if (this._pos >= this._list.length) {\n    return this._emitError(new Error('Packet too short'))\n  }\n\n  // Parse connect flags\n  flags.username = (this._list.readUInt8(this._pos) & constants.USERNAME_MASK)\n  flags.password = (this._list.readUInt8(this._pos) & constants.PASSWORD_MASK)\n  flags.will = (this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK)\n\n  if (flags.will) {\n    packet.will = {}\n    packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0\n    packet.will.qos = (this._list.readUInt8(this._pos) &\n                          constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT\n  }\n\n  packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0\n  this._pos++\n\n  // Parse keepalive\n  packet.keepalive = this._parseNum()\n  if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'))\n\n  // Parse clientId\n  clientId = this._parseString()\n  if (clientId === null) return this._emitError(new Error('Packet too short'))\n  packet.clientId = clientId\n\n  if (flags.will) {\n    // Parse will topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse will topic'))\n    packet.will.topic = topic\n\n    // Parse will payload\n    payload = this._parseBuffer()\n    if (payload === null) return this._emitError(new Error('Cannot parse will payload'))\n    packet.will.payload = payload\n  }\n\n  // Parse username\n  if (flags.username) {\n    username = this._parseString()\n    if (username === null) return this._emitError(new Error('Cannot parse username'))\n    packet.username = username\n  }\n\n  // Parse password\n  if (flags.password) {\n    password = this._parseBuffer()\n    if (password === null) return this._emitError(new Error('Cannot parse password'))\n    packet.password = password\n  }\n\n  return packet\n}\n\nParser.prototype._parseConnack = function () {\n  var packet = this.packet\n\n  if (this._list.length < 2) return null\n\n  packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK)\n  packet.returnCode = this._list.readUInt8(this._pos)\n\n  if (packet.returnCode === -1) return this._emitError(new Error('Cannot parse return code'))\n}\n\nParser.prototype._parsePublish = function () {\n  var packet = this.packet\n  packet.topic = this._parseString()\n\n  if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n  // Parse messageId\n  if (packet.qos > 0) if (!this._parseMessageId()) { return }\n\n  packet.payload = this._list.slice(this._pos, packet.length)\n}\n\nParser.prototype._parseSubscribe = function () {\n  var packet = this.packet\n  var topic\n  var qos\n\n  if (packet.qos !== 1) {\n    return this._emitError(new Error('Wrong subscribe header'))\n  }\n\n  packet.subscriptions = []\n\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'))\n    qos = this._list.readUInt8(this._pos++)\n\n    // Push pair to subscriptions\n    packet.subscriptions.push({ topic: topic, qos: qos })\n  }\n}\n\nParser.prototype._parseSuback = function () {\n  this.packet.granted = []\n\n  if (!this._parseMessageId()) { return }\n\n  // Parse granted QoSes\n  while (this._pos < this.packet.length) {\n    this.packet.granted.push(this._list.readUInt8(this._pos++))\n  }\n}\n\nParser.prototype._parseUnsubscribe = function () {\n  var packet = this.packet\n\n  packet.unsubscriptions = []\n\n  // Parse messageId\n  if (!this._parseMessageId()) { return }\n\n  while (this._pos < packet.length) {\n    var topic\n\n    // Parse topic\n    topic = this._parseString()\n    if (topic === null) return this._emitError(new Error('Cannot parse topic'))\n\n    // Push topic to unsubscriptions\n    packet.unsubscriptions.push(topic)\n  }\n}\n\nParser.prototype._parseUnsuback = function () {\n  if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'))\n}\n\nParser.prototype._parseMessageId = function () {\n  var packet = this.packet\n\n  packet.messageId = this._parseNum()\n\n  if (packet.messageId === null) {\n    this._emitError(new Error('Cannot parse messageId'))\n    return false\n  }\n\n  return true\n}\n\nParser.prototype._parseString = function (maybeBuffer) {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.toString('utf8', this._pos, end)\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseBuffer = function () {\n  var length = this._parseNum()\n  var result\n  var end = length + this._pos\n\n  if (length === -1 || end > this._list.length || end > this.packet.length) return null\n\n  result = this._list.slice(this._pos, end)\n\n  this._pos += length\n\n  return result\n}\n\nParser.prototype._parseNum = function () {\n  if (this._list.length - this._pos < 2) return -1\n\n  var result = this._list.readUInt16BE(this._pos)\n  this._pos += 2\n\n  return result\n}\n\nParser.prototype._newPacket = function () {\n  if (this.packet) {\n    this._list.consume(this.packet.length)\n    this.emit('packet', this.packet)\n  }\n\n  this.packet = new Packet()\n\n  return true\n}\n\nParser.prototype._emitError = function (err) {\n  this.error = err\n  this.emit('error', err)\n}\n\nmodule.exports = Parser\n","'use strict'\n\nvar protocol = require('./constants')\nvar Buffer = require('safe-buffer').Buffer\nvar empty = Buffer.allocUnsafe(0)\nvar zeroBuf = Buffer.from([0])\nvar numbers = require('./numbers')\nvar nextTick = require('process-nextick-args').nextTick\n\nvar numCache = numbers.cache\nvar generateNumber = numbers.generateNumber\nvar generateCache = numbers.generateCache\nvar writeNumber = writeNumberCached\nvar toGenerate = true\n\nfunction generate (packet, stream) {\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream)\n    case 'connack':\n      return connack(packet, stream)\n    case 'publish':\n      return publish(packet, stream)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n    case 'unsuback':\n      return confirmation(packet, stream)\n    case 'subscribe':\n      return subscribe(packet, stream)\n    case 'suback':\n      return suback(packet, stream)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream)\n    case 'pingreq':\n    case 'pingresp':\n    case 'disconnect':\n      return emptyPacket(packet, stream)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get: function () {\n    return writeNumber === writeNumberCached\n  },\n  set: function (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (opts, stream) {\n  var settings = opts || {}\n  var protocolId = settings.protocolId || 'MQTT'\n  var protocolVersion = settings.protocolVersion || 4\n  var will = settings.will\n  var clean = settings.clean\n  var keepalive = settings.keepalive || 0\n  var clientId = settings.clientId || ''\n  var username = settings.username\n  var password = settings.password\n\n  if (clean === undefined) clean = true\n\n  var length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4\n  if (protocolVersion !== 3 && protocolVersion !== 4) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion === 4) && (clientId || clean)) {\n    length += clientId.length + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    if (will.payload && will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload) + 2\n        } else {\n          length += will.payload.length + 2\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    } else {\n      length += 2\n    }\n  }\n\n  // Username\n  var providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n  stream.write(\n    protocolVersion === 4 ? protocol.VERSION4 : protocol.VERSION3\n  )\n\n  // Connect flags\n  var flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (opts, stream) {\n  var settings = opts || {}\n  var rc = settings.returnCode\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  writeLength(stream, 2)\n  stream.write(opts.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  return stream.write(Buffer.from([rc]))\n}\n\nfunction publish (opts, stream) {\n  var settings = opts || {}\n  var qos = settings.qos || 0\n  var retain = settings.retain ? protocol.RETAIN_MASK : 0\n  var topic = settings.topic\n  var payload = settings.payload || empty\n  var id = settings.messageId\n\n  var length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][opts.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeLength(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Payload\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (opts, stream) {\n  var settings = opts || {}\n  var type = settings.cmd || 'puback'\n  var id = settings.messageId\n  var dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  var qos = 0\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeLength(stream, 2)\n\n  // Message ID\n  return writeNumber(stream, id)\n}\n\nfunction subscribe (opts, stream) {\n  var settings = opts || {}\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var id = settings.messageId\n  var subs = settings.subscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (var i = 0; i < subs.length; i += 1) {\n      var itopic = subs[i].topic\n      var iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeLength(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  var result = true\n\n  // Generate subs\n  for (var j = 0; j < subs.length; j++) {\n    var sub = subs[j]\n    var jtopic = sub.topic\n    var jqos = sub.qos\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // Write qos\n    result = stream.write(protocol.QOS[jqos])\n  }\n\n  return result\n}\n\nfunction suback (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var granted = settings.granted\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (var i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (opts, stream) {\n  var settings = opts || {}\n  var id = settings.messageId\n  var dup = settings.dup ? protocol.DUP_MASK : 0\n  var unsubs = settings.unsubscriptions\n\n  var length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (var i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeLength(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // Unsubs\n  var result = true\n  for (var j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction emptyPacket (opts, stream) {\n  return stream.write(protocol.EMPTY[opts.cmd])\n}\n\n/**\n * calcLengthLength - calculate the length of the remaining\n * length field\n *\n * @api private\n */\nfunction calcLengthLength (length) {\n  if (length >= 0 && length < 128) return 1\n  else if (length >= 128 && length < 16384) return 2\n  else if (length >= 16384 && length < 2097152) return 3\n  else if (length >= 2097152 && length < 268435456) return 4\n  else return 0\n}\n\nfunction genBufLength (length) {\n  var digit = 0\n  var pos = 0\n  var buffer = Buffer.allocUnsafe(calcLengthLength(length))\n\n  do {\n    digit = length % 128 | 0\n    length = length / 128 | 0\n    if (length > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (length > 0)\n\n  return buffer\n}\n\n/**\n * writeLength - write an MQTT style length field to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nvar lengthCache = {}\nfunction writeLength (stream, length) {\n  var buffer = lengthCache[length]\n\n  if (!buffer) {\n    buffer = genBufLength(length)\n    if (length < 16384) lengthCache[length] = buffer\n  }\n\n  stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  var strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  stream.write(string, 'utf8')\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  return stream.write(generateNumber(number))\n}\n\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n","'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar eos = require('end-of-stream')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId] === 'function') {\n        queue[messageId](new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof this.options.clientId === 'string') ? this.options.clientId : defaultId()\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = this.options.outgoingStore || new Store()\n  this.incomingStore = this.options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = this.options.queueQoSZero === undefined ? true : this.options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // Mark connected on connect\n  this.on('connect', function () {\n    if (this.disconnected) {\n      return\n    }\n\n    this.connected = true\n    var outStore = this.outgoingStore.createStream()\n\n    this.once('close', remove)\n    outStore.on('end', function () {\n      that.removeListener('close', remove)\n    })\n    outStore.on('error', function (err) {\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n\n      var packet = outStore.read(1)\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId]\n        that.outgoing[packet.messageId] = function (err, status) {\n          // Ensure that the original callback passed in to publish gets invoked\n          if (cb) {\n            cb(err, status)\n          }\n\n          storeDeliver()\n        }\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    // start flowing\n    storeDeliver()\n  })\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Setup ping timer\n  this.on('connect', this._setupPingTimer)\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  var firstConnection = true\n  // resubscribe\n  this.on('connect', function () {\n    if (!firstConnection &&\n        this.options.clean &&\n        Object.keys(this._resubscribeTopics).length > 0) {\n      if (this.options.resubscribe) {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      } else {\n        this._resubscribeTopics = {}\n      }\n    }\n\n    firstConnection = false\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    process.nextTick(work)\n  }\n\n  function work () {\n    var packet = packets.shift()\n    var done = completeParse\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      completeParse = null\n      done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    work()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  eos(this.stream, this.emit.bind(this, 'close'))\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n\n      // Add to callbacks\n      this.outgoing[packet.messageId] = callback || nop\n      this._sendPacket(packet)\n      break\n    default:\n      this._sendPacket(packet, callback)\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = Array.prototype.slice.call(arguments)\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = { qos: 0 }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (that._resubscribeTopics[topic] < opts.qos ||\n          !that._resubscribeTopics.hasOwnProperty(topic) ||\n          resubscribe) {\n        subs.push({\n          topic: topic,\n          qos: opts.qos\n        })\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (that._resubscribeTopics[k] < obj[k] ||\n            !that._resubscribeTopics.hasOwnProperty(k) ||\n            resubscribe) {\n          subs.push({\n            topic: k,\n            qos: obj[k]\n          })\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        that._resubscribeTopics[sub.topic] = sub.qos\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = function (err, packet) {\n    if (!err) {\n      var granted = packet.granted\n      for (var i = 0; i < granted.length; i += 1) {\n        subs[i].qos = granted[i]\n      }\n    }\n\n    callback(err, subs)\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function (topic, callback) {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n\n  callback = callback || nop\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  this.outgoing[packet.messageId] = callback\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, cb) {\n  var that = this\n\n  if (typeof force === 'function') {\n    cb = force\n    force = false\n  }\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments)\n        }\n        that.emit('end')\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores))\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid]\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    this.stream.destroy()\n  } else {\n    this._sendPacket(\n      { cmd: 'disconnect' },\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb) {\n  if (!this.connected) {\n    if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n      this.queue.push({ packet: packet, cb: cb })\n    } else if (packet.qos > 0) {\n      cb = this.outgoing[packet.messageId]\n      this.outgoingStore.put(packet, function (err) {\n        if (err) {\n          return cb && cb(err)\n        }\n      })\n    } else if (cb) {\n      cb(new Error('No connection to broker'))\n    }\n\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var rc = packet.returnCode\n  var errors = [\n    '',\n    'Unacceptable protocol version',\n    'Identifier rejected',\n    'Server unavailable',\n    'Bad username or password',\n    'Not authorized'\n  ]\n\n  clearTimeout(this.connackTimer)\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this.emit('connect', packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n\n  switch (qos) {\n    case 2:\n      this.incomingStore.put(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n      })\n      break\n    case 1:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, function (err) {\n        if (err) {\n          return done(err)\n        }\n        // send 'puback' if the above 'handleMessage' method executed\n        // successfully.\n        that._sendPacket({cmd: 'puback', messageId: mid}, done)\n      })\n      break\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid]\n  var that = this\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      // Callback - we're done\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n\n      this._sendPacket(response)\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      if (packet.granted.length === 1 && (packet.granted[0] & 0x80) !== 0) {\n        // suback with Failure status\n        var topics = this.messageIdToTopic[mid]\n        if (topics) {\n          topics.forEach(function (topic) {\n            delete that._resubscribeTopics[topic]\n          })\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err && pub.cmd !== 'pubrel') {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.incomingStore.put(packet, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.handleMessage(pub, function (err) {\n          if (err) {\n            return callback(err)\n          }\n          that._sendPacket(comp, callback)\n        })\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\nmodule.exports = MqttClient\n","'use strict'\n\nvar MqttClient = require('../client')\nvar Store = require('../store')\nvar url = require('url')\nvar xtend = require('xtend')\nvar protocols = {}\n\nif (process.title !== 'browser') {\n  protocols.mqtt = require('./tcp')\n  protocols.tcp = require('./tcp')\n  protocols.ssl = require('./tls')\n  protocols.tls = require('./tls')\n  protocols.mqtts = require('./tls')\n} else {\n  protocols.wx = require('./wx')\n  protocols.wxs = require('./wx')\n}\n\nprotocols.ws = require('./ws')\nprotocols.wss = require('./ws')\n\n/**\n * Parse the auth attribute and merge username and password in the options object.\n *\n * @param {Object} [opts] option object\n */\nfunction parseAuthOptions (opts) {\n  var matches\n  if (opts.auth) {\n    matches = opts.auth.match(/^(.+):(.+)$/)\n    if (matches) {\n      opts.username = matches[1]\n      opts.password = matches[2]\n    } else {\n      opts.username = opts.auth\n    }\n  }\n}\n\n/**\n * connect - connect to an MQTT broker.\n *\n * @param {String} [brokerUrl] - url of the broker, optional\n * @param {Object} opts - see MqttClient#constructor\n */\nfunction connect (brokerUrl, opts) {\n  if ((typeof brokerUrl === 'object') && !opts) {\n    opts = brokerUrl\n    brokerUrl = null\n  }\n\n  opts = opts || {}\n\n  if (brokerUrl) {\n    var parsed = url.parse(brokerUrl, true)\n    if (parsed.port != null) {\n      parsed.port = Number(parsed.port)\n    }\n\n    opts = xtend(parsed, opts)\n\n    if (opts.protocol === null) {\n      throw new Error('Missing protocol')\n    }\n    opts.protocol = opts.protocol.replace(/:$/, '')\n  }\n\n  // merge in the auth options if supplied\n  parseAuthOptions(opts)\n\n  // support clientId passed in the query string of the url\n  if (opts.query && typeof opts.query.clientId === 'string') {\n    opts.clientId = opts.query.clientId\n  }\n\n  if (opts.cert && opts.key) {\n    if (opts.protocol) {\n      if (['mqtts', 'wss', 'wxs'].indexOf(opts.protocol) === -1) {\n        switch (opts.protocol) {\n          case 'mqtt':\n            opts.protocol = 'mqtts'\n            break\n          case 'ws':\n            opts.protocol = 'wss'\n            break\n          case 'wx':\n            opts.protocol = 'wxs'\n            break\n          default:\n            throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!')\n        }\n      }\n    } else {\n      // don't know what protocol he want to use, mqtts or wss\n      throw new Error('Missing secure protocol key')\n    }\n  }\n\n  if (!protocols[opts.protocol]) {\n    var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1\n    opts.protocol = [\n      'mqtt',\n      'mqtts',\n      'ws',\n      'wss',\n      'wx',\n      'wxs'\n    ].filter(function (key, index) {\n      if (isSecure && index % 2 === 0) {\n        // Skip insecure protocols when requesting a secure one.\n        return false\n      }\n      return (typeof protocols[key] === 'function')\n    })[0]\n  }\n\n  if (opts.clean === false && !opts.clientId) {\n    throw new Error('Missing clientId for unclean clients')\n  }\n\n  if (opts.protocol) {\n    opts.defaultProtocol = opts.protocol\n  }\n\n  function wrapper (client) {\n    if (opts.servers) {\n      if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n        client._reconnectCount = 0\n      }\n\n      opts.host = opts.servers[client._reconnectCount].host\n      opts.port = opts.servers[client._reconnectCount].port\n      opts.protocol = (!opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol)\n      opts.hostname = opts.host\n\n      client._reconnectCount++\n    }\n\n    return protocols[opts.protocol](client, opts)\n  }\n\n  return new MqttClient(wrapper, opts)\n}\n\nmodule.exports = connect\nmodule.exports.connect = connect\nmodule.exports.MqttClient = MqttClient\nmodule.exports.Store = Store\n","'use strict'\nvar net = require('net')\n\n/*\n  variables port and host can be removed since\n  you have all required information in opts object\n*/\nfunction buildBuilder (client, opts) {\n  var port, host\n  opts.port = opts.port || 1883\n  opts.hostname = opts.hostname || opts.host || 'localhost'\n\n  port = opts.port\n  host = opts.hostname\n\n  return net.createConnection(port, host)\n}\n\nmodule.exports = buildBuilder\n","'use strict'\nvar tls = require('tls')\n\nfunction buildBuilder (mqttClient, opts) {\n  var connection\n  opts.port = opts.port || 8883\n  opts.host = opts.hostname || opts.host || 'localhost'\n\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\n\n  delete opts.path\n\n  connection = tls.connect(opts)\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'))\n    } else {\n      connection.removeListener('error', handleTLSerrors)\n    }\n  })\n\n  function handleTLSerrors (err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err)\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end()\n  }\n\n  connection.on('error', handleTLSerrors)\n  return connection\n}\n\nmodule.exports = buildBuilder\n","'use strict'\n\nvar websocket = require('websocket-stream')\nvar urlModule = require('url')\nvar WSS_OPTIONS = [\n  'rejectUnauthorized',\n  'ca',\n  'cert',\n  'key',\n  'pfx',\n  'passphrase'\n]\nvar IS_BROWSER = process.title === 'browser'\n\nfunction buildUrl (opts, client) {\n  var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.port) {\n    if (opts.protocol === 'wss') {\n      opts.port = 443\n    } else {\n      opts.port = 80\n    }\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n  if (!IS_BROWSER && opts.protocol === 'wss') {\n    // Add cert/key/ca etc options\n    WSS_OPTIONS.forEach(function (prop) {\n      if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n        opts.wsOptions[prop] = opts[prop]\n      }\n    })\n  }\n}\n\nfunction createWebSocket (client, opts) {\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n  var url = buildUrl(opts, client)\n  return websocket(url, [websocketSubProtocol], opts.wsOptions)\n}\n\nfunction buildBuilder (client, opts) {\n  return createWebSocket(client, opts)\n}\n\nfunction buildBuilderBrowser (client, opts) {\n  if (!opts.hostname) {\n    opts.hostname = opts.host\n  }\n\n  if (!opts.hostname) {\n    // Throwing an error in a Web Worker if no `hostname` is given, because we\n    // can not determine the `hostname` automatically.  If connecting to\n    // localhost, please supply the `hostname` as an argument.\n    if (typeof (document) === 'undefined') {\n      throw new Error('Could not determine host. Specify host manually.')\n    }\n    var parsed = urlModule.parse(document.URL)\n    opts.hostname = parsed.hostname\n\n    if (!opts.port) {\n      opts.port = parsed.port\n    }\n  }\n  return createWebSocket(client, opts)\n}\n\nif (IS_BROWSER) {\n  module.exports = buildBuilderBrowser\n} else {\n  module.exports = buildBuilder\n}\n","'use strict'\n\n/* global wx */\nvar socketOpen = false\nvar socketMsgQueue = []\n\nfunction sendSocketMessage (msg) {\n  if (socketOpen) {\n    wx.sendSocketMessage({\n      data: msg.buffer || msg\n    })\n  } else {\n    socketMsgQueue.push(msg)\n  }\n}\n\nfunction WebSocket (url, protocols) {\n  var ws = {\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3,\n    readyState: socketOpen ? 1 : 0,\n    send: sendSocketMessage,\n    close: wx.closeSocket,\n    onopen: null,\n    onmessage: null,\n    onclose: null,\n    onerror: null\n  }\n\n  wx.connectSocket({\n    url: url,\n    protocols: protocols\n  })\n  wx.onSocketOpen(function (res) {\n    ws.readyState = ws.OPEN\n    socketOpen = true\n    for (var i = 0; i < socketMsgQueue.length; i++) {\n      sendSocketMessage(socketMsgQueue[i])\n    }\n    socketMsgQueue = []\n\n    ws.onopen && ws.onopen.apply(ws, arguments)\n  })\n  wx.onSocketMessage(function (res) {\n    ws.onmessage && ws.onmessage.apply(ws, arguments)\n  })\n  wx.onSocketClose(function () {\n    ws.onclose && ws.onclose.apply(ws, arguments)\n    ws.readyState = ws.CLOSED\n    socketOpen = false\n  })\n  wx.onSocketError(function () {\n    ws.onerror && ws.onerror.apply(ws, arguments)\n    ws.readyState = ws.CLOSED\n    socketOpen = false\n  })\n\n  return ws\n}\n\nvar websocket = require('websocket-stream')\n\nfunction buildUrl (opts, client) {\n  var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws'\n  var url = protocol + '://' + opts.hostname + opts.path\n  if (opts.port && opts.port !== 80 && opts.port !== 443) {\n    url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path\n  }\n  if (typeof (opts.transformWsUrl) === 'function') {\n    url = opts.transformWsUrl(url, opts, client)\n  }\n  return url\n}\n\nfunction setDefaultOpts (opts) {\n  if (!opts.hostname) {\n    opts.hostname = 'localhost'\n  }\n  if (!opts.path) {\n    opts.path = '/'\n  }\n\n  if (!opts.wsOptions) {\n    opts.wsOptions = {}\n  }\n}\n\nfunction createWebSocket (client, opts) {\n  var websocketSubProtocol =\n    (opts.protocolId === 'MQIsdp') && (opts.protocolVersion === 3)\n      ? 'mqttv3.1'\n      : 'mqtt'\n\n  setDefaultOpts(opts)\n  var url = buildUrl(opts, client)\n  return websocket(WebSocket(url, [websocketSubProtocol]))\n}\n\nfunction buildBuilder (client, opts) {\n  opts.hostname = opts.hostname || opts.host\n\n  if (!opts.hostname) {\n    throw new Error('Could not determine host. Specify host manually.')\n  }\n\n  return createWebSocket(client, opts)\n}\n\nmodule.exports = buildBuilder\n","'use strict'\n\n/**\n * Module dependencies\n */\nvar xtend = require('xtend')\n\nvar Readable = require('readable-stream').Readable\nvar streamsOpts = { objectMode: true }\nvar defaultStoreOptions = {\n  clean: true\n}\n\n/**\n * es6-map can preserve insertion order even if ES version is older.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\n * It should be noted that a Map which is a map of an object, especially\n * a dictionary of dictionaries, will only map to the object's insertion\n * order. In ES2015 this is ordered for objects but for older versions of\n * ES, this may be random and not ordered.\n *\n */\nvar Map = require('es6-map')\n\n/**\n * In-memory implementation of the message store\n * This can actually be saved into files.\n *\n * @param {Object} [options] - store options\n */\nfunction Store (options) {\n  if (!(this instanceof Store)) {\n    return new Store(options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  this.options = xtend(defaultStoreOptions, options)\n\n  this._inflights = new Map()\n}\n\n/**\n * Adds a packet to the store, a packet is\n * anything that has a messageId property.\n *\n */\nStore.prototype.put = function (packet, cb) {\n  this._inflights.set(packet.messageId, packet)\n\n  if (cb) {\n    cb()\n  }\n\n  return this\n}\n\n/**\n * Creates a stream with all the packets in the store\n *\n */\nStore.prototype.createStream = function () {\n  var stream = new Readable(streamsOpts)\n  var destroyed = false\n  var values = []\n  var i = 0\n\n  this._inflights.forEach(function (value, key) {\n    values.push(value)\n  })\n\n  stream._read = function () {\n    if (!destroyed && i < values.length) {\n      this.push(values[i++])\n    } else {\n      this.push(null)\n    }\n  }\n\n  stream.destroy = function () {\n    if (destroyed) {\n      return\n    }\n\n    var self = this\n\n    destroyed = true\n\n    process.nextTick(function () {\n      self.emit('close')\n    })\n  }\n\n  return stream\n}\n\n/**\n * deletes a packet from the store.\n */\nStore.prototype.del = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    this._inflights.delete(packet.messageId)\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * get a packet from the store.\n */\nStore.prototype.get = function (packet, cb) {\n  packet = this._inflights.get(packet.messageId)\n  if (packet) {\n    cb(null, packet)\n  } else if (cb) {\n    cb(new Error('missing packet'))\n  }\n\n  return this\n}\n\n/**\n * Close the store\n */\nStore.prototype.close = function (cb) {\n  if (this.options.clean) {\n    this._inflights = null\n  }\n  if (cb) {\n    cb()\n  }\n}\n\nmodule.exports = Store\n","'use strict'\n\n/**\n * Validate a topic to see if it's valid or not.\n * A topic is valid if it follow below rules:\n * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n * - Rule #2: Part `#` must be located at the end of the mailbox\n *\n * @param {String} topic - A topic\n * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n */\nfunction validateTopic (topic) {\n  var parts = topic.split('/')\n\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i] === '+') {\n      continue\n    }\n\n    if (parts[i] === '#') {\n      // for Rule #2\n      return i === parts.length - 1\n    }\n\n    if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Validate an array of topics to see if any of them is valid or not\n  * @param {Array} topics - Array of topics\n * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n */\nfunction validateTopics (topics) {\n  if (topics.length === 0) {\n    return 'empty_topic_list'\n  }\n  for (var i = 0; i < topics.length; i++) {\n    if (!validateTopic(topics[i])) {\n      return topics[i]\n    }\n  }\n  return null\n}\n\nmodule.exports = {\n  validateTopics: validateTopics\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(require('core-util-is'));\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","'use strict'\n\nfunction ReInterval (callback, interval, args) {\n  var self = this;\n\n  this._callback = callback;\n  this._args = args;\n\n  this._interval = setInterval(callback, interval, this._args);\n\n  this.reschedule = function (interval) {\n    // if no interval entered, use the interval passed in on creation\n    if (!interval)\n      interval = self._interval;\n\n    if (self._interval)\n      clearInterval(self._interval);\n    self._interval = setInterval(self._callback, interval, self._args);\n  };\n\n  this.clear = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n      self._interval = undefined;\n    }\n  };\n  \n  this.destroy = function () {\n    if (self._interval) {\n      clearInterval(self._interval);\n    }\n    self._callback = undefined;\n    self._interval = undefined;\n    self._args = undefined;\n  };\n}\n\nfunction reInterval () {\n  if (typeof arguments[0] !== 'function')\n    throw new Error('callback needed');\n  if (typeof arguments[1] !== 'number')\n    throw new Error('interval needed');\n\n  var args;\n\n  if (arguments.length > 0) {\n    args = new Array(arguments.length - 2);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i + 2];\n    }\n  }\n\n  return new ReInterval(arguments[0], arguments[1], args);\n}\n\nmodule.exports = reInterval;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\tself._socketTimeout = null\n\tself._socketTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tif ('timeout' in opts && opts.timeout !== 0) {\n\t\tself.setTimeout(opts.timeout)\n\t}\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n        body = new Blob(self._body, {\n            type: (headersObj['content-type'] || {}).value || ''\n        });\n    }\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._resetTimers(false)\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself._resetTimers(true)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself._resetTimers(true)\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tself._resetTimers(false)\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress(self._resetTimers.bind(self))\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype._resetTimers = function (done) {\n\tvar self = this\n\n\tglobal.clearTimeout(self._socketTimer)\n\tself._socketTimer = null\n\n\tif (done) {\n\t\tglobal.clearTimeout(self._fetchTimer)\n\t\tself._fetchTimer = null\n\t} else if (self._socketTimeout) {\n\t\tself._socketTimer = global.setTimeout(function () {\n\t\t\tself.emit('timeout')\n\t\t}, self._socketTimeout)\n\t}\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {\n\tvar self = this\n\tself._destroyed = true\n\tself._resetTimers(true)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n\n\tif (err)\n\t\tself.emit('error', err)\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.setTimeout = function (timeout, cb) {\n\tvar self = this\n\n\tif (cb)\n\t\tself.once('timeout', cb)\n\n\tself._socketTimeout = timeout\n\tself._resetTimers(false)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\tresetTimers(false)\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(Buffer.from(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tresetTimers(true)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tresetTimers(result.done)\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(Buffer.from(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tresetTimers(true)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function (resetTimers) {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text':\n\t\t\tresponse = xhr.responseText\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = Buffer.alloc(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(Buffer.from(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tresetTimers(true)\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tresetTimers(true)\n\t\tself.push(null)\n\t}\n}\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","module.exports = shift\n\nfunction shift (stream) {\n  var rs = stream._readableState\n  if (!rs) return null\n  return (rs.objectMode || typeof stream._duplexState === 'number') ? stream.read() : stream.read(getStateLength(rs))\n}\n\nfunction getStateLength (state) {\n  if (state.buffer.length) {\n    // Since node 6.3.0 state.buffer is a BufferList not an array\n    if (state.buffer.head) {\n      return state.buffer.head.data.length\n    }\n\n    return state.buffer[0].length\n  }\n\n  return state.length\n}\n","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};","\"use strict\";\n\nvar isPrototype = require(\"../prototype/is\");\n\nmodule.exports = function (value) {\n\tif (typeof value !== \"function\") return false;\n\n\tif (!hasOwnProperty.call(value, \"length\")) return false;\n\n\ttry {\n\t\tif (typeof value.length !== \"number\") return false;\n\t\tif (typeof value.call !== \"function\") return false;\n\t\tif (typeof value.apply !== \"function\") return false;\n\t} catch (error) {\n\t\treturn false;\n\t}\n\n\treturn !isPrototype(value);\n};\n","\"use strict\";\n\nvar isValue       = require(\"../value/is\")\n  , isObject      = require(\"../object/is\")\n  , stringCoerce  = require(\"../string/coerce\")\n  , toShortString = require(\"./to-short-string\");\n\nvar resolveMessage = function (message, value) {\n\treturn message.replace(\"%v\", toShortString(value));\n};\n\nmodule.exports = function (value, defaultMessage, inputOptions) {\n\tif (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));\n\tif (!isValue(value)) {\n\t\tif (\"default\" in inputOptions) return inputOptions[\"default\"];\n\t\tif (inputOptions.isOptional) return null;\n\t}\n\tvar errorMessage = stringCoerce(inputOptions.errorMessage);\n\tif (!isValue(errorMessage)) errorMessage = defaultMessage;\n\tthrow new TypeError(resolveMessage(errorMessage, value));\n};\n","\"use strict\";\n\nmodule.exports = function (value) {\n\ttry {\n\t\treturn value.toString();\n\t} catch (error) {\n\t\ttry { return String(value); }\n\t\tcatch (error2) { return null; }\n\t}\n};\n","\"use strict\";\n\nvar safeToString = require(\"./safe-to-string\");\n\nvar reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n\nmodule.exports = function (value) {\n\tvar string = safeToString(value);\n\tif (string === null) return \"<Non-coercible to string value>\";\n\t// Trim if too long\n\tif (string.length > 100) string = string.slice(0, 99) + \"…\";\n\t// Replace eventual new lines\n\tstring = string.replace(reNewLine, function (char) {\n\t\tswitch (char) {\n\t\t\tcase \"\\n\":\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase \"\\r\":\n\t\t\t\treturn \"\\\\r\";\n\t\t\tcase \"\\u2028\":\n\t\t\t\treturn \"\\\\u2028\";\n\t\t\tcase \"\\u2029\":\n\t\t\t\treturn \"\\\\u2029\";\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unexpected character\");\n\t\t}\n\t});\n\treturn string;\n};\n","\"use strict\";\n\nvar isValue = require(\"../value/is\");\n\n// prettier-ignore\nvar possibleTypes = { \"object\": true, \"function\": true, \"undefined\": true /* document.all */ };\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return false;\n\treturn hasOwnProperty.call(possibleTypes, typeof value);\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"%v is not a plain function\", arguments[1]);\n};\n","\"use strict\";\n\nvar isFunction = require(\"../function/is\");\n\nvar classRe = /^\\s*class[\\s{/}]/, functionToString = Function.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isFunction(value)) return false;\n\tif (classRe.test(functionToString.call(value))) return false;\n\treturn true;\n};\n","\"use strict\";\n\nvar isObject = require(\"../object/is\");\n\nmodule.exports = function (value) {\n\tif (!isObject(value)) return false;\n\ttry {\n\t\tif (!value.constructor) return false;\n\t\treturn value.constructor.prototype === value;\n\t} catch (error) {\n\t\treturn false;\n\t}\n};\n","\"use strict\";\n\nvar isValue  = require(\"../value/is\")\n  , isObject = require(\"../object/is\");\n\nvar objectToString = Object.prototype.toString;\n\nmodule.exports = function (value) {\n\tif (!isValue(value)) return null;\n\tif (isObject(value)) {\n\t\t// Reject Object.prototype.toString coercion\n\t\tvar valueToString = value.toString;\n\t\tif (typeof valueToString !== \"function\") return null;\n\t\tif (valueToString === objectToString) return null;\n\t\t// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant\n\t\t// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case\n\t}\n\ttry {\n\t\treturn \"\" + value; // Ensure implicit coercion\n\t} catch (error) {\n\t\treturn null;\n\t}\n};\n","\"use strict\";\n\nvar resolveException = require(\"../lib/resolve-exception\")\n  , is               = require(\"./is\");\n\nmodule.exports = function (value/*, options*/) {\n\tif (is(value)) return value;\n\treturn resolveException(value, \"Cannot use %v\", arguments[1]);\n};\n","\"use strict\";\n\n// ES3 safe\nvar _undefined = void 0;\n\nmodule.exports = function (value) { return value !== _undefined && value !== null; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\nvar WS = require('ws')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = WebSocketStream\n\nfunction buildProxy (options, socketWrite, socketEnd) {\n  var proxy = new Transform({\n    objectMode: options.objectMode\n  })\n\n  proxy._write = socketWrite\n  proxy._flush = socketEnd\n\n  return proxy\n}\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket\n\n  var isBrowser = process.title === 'browser'\n  var isNative = !!global.WebSocket\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols\n    protocols = null\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {}\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  var proxy = buildProxy(options, socketWrite, socketEnd)\n\n  if (!options.objectMode) {\n    proxy._writev = writev\n  }\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target\n  // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols)\n    } else {\n      socket = new WS(target, protocols, options)\n    }\n\n    socket.binaryType = 'arraybuffer'\n  }\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else if (isBrowser) {\n    stream = proxy\n    stream.cork()\n    socket.onopen = onopenBrowser\n  } else {\n    stream = duplexify.obj()\n    socket.onopen = onopen\n  }\n\n  stream.socket = socket\n\n  socket.onclose = onclose\n  socket.onerror = onerror\n  socket.onmessage = onmessage\n\n  proxy.on('close', destroy)\n\n  var coerceToBuffer = !options.objectMode\n\n  function socketWriteNode(chunk, enc, next) {\n    // avoid errors, this never happens unless\n    // destroy() is called\n    if (socket.readyState !== socket.OPEN) {\n      next()\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n    socket.send(chunk, next)\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch(err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEnd(done) {\n    socket.close()\n    done()\n  }\n\n  function onopen() {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onopenBrowser () {\n    stream.uncork()\n    stream.emit('connect')\n  }\n\n  function onclose() {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror(err) {\n    stream.destroy(err)\n  }\n\n  function onmessage(event) {\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  function destroy() {\n    socket.close()\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    var buffers = new Array(chunks.length)\n    for (var i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  return stream\n}\n","\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n}\n\nmodule.exports = ws\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. audio\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseAudioType(str, input, output) {\n  str = str.toLowerCase();\n  let result = '';\n\n  if (str.indexOf('input') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('display audio') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('speak') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('laut') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('loud') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('head') >= 0) { result = 'Headset'; }\n  if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('mikr') >= 0) { result = 'Microphone'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('controll') >= 0) { result = 'Controller'; }\n  if (str.indexOf('line o') >= 0) { result = 'Line Out'; }\n  if (str.indexOf('digital o') >= 0) { result = 'Digital Out'; }\n  if (str.indexOf('smart sound technology') >= 0) { result = 'Digital Signal Processor'; }\n  if (str.indexOf('high definition audio') >= 0) { result = 'Sound Driver'; }\n\n  if (!result && output) {\n    result = 'Speaker';\n  } else if (!result && input) {\n    result = 'Microphone';\n  }\n  return result;\n}\n\n\nfunction getLinuxAudioPci() {\n  let cmd = 'lspci -v 2>/dev/null';\n  let result = [];\n  try {\n    const parts = execSync(cmd).toString().split('\\n\\n');\n    parts.forEach(element => {\n      const lines = element.split('\\n');\n      if (lines && lines.length && lines[0].toLowerCase().indexOf('audio') >= 0) {\n        const audio = {};\n        audio.slotId = lines[0].split(' ')[0];\n        audio.driver = util.getValue(lines, 'Kernel driver in use', ':', true) || util.getValue(lines, 'Kernel modules', ':', true);\n        result.push(audio);\n      }\n    });\n    return result;\n  } catch (e) {\n    return result;\n  }\n}\n\nfunction parseLinuxAudioPciMM(lines, audioPCI) {\n  const result = {};\n  const slotId = util.getValue(lines, 'Slot');\n\n  const pciMatch = audioPCI.filter(function (item) { return item.slotId === slotId; });\n\n  result.id = slotId;\n  result.name = util.getValue(lines, 'SDevice');\n  result.manufacturer = util.getValue(lines, 'SVendor');\n  result.revision = util.getValue(lines, 'Rev');\n  result.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : '';\n  result.default = null;\n  result.channel = 'PCIe';\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseDarwinChannel(str) {\n  let result = '';\n\n  if (str.indexOf('builtin') >= 0) { result = 'Built-In'; }\n  if (str.indexOf('extern') >= 0) { result = 'Audio-Jack'; }\n  if (str.indexOf('hdmi') >= 0) { result = 'HDMI'; }\n  if (str.indexOf('displayport') >= 0) { result = 'Display-Port'; }\n  if (str.indexOf('usb') >= 0) { result = 'USB'; }\n  if (str.indexOf('pci') >= 0) { result = 'PCIe'; }\n\n  return result;\n}\n\nfunction parseDarwinAudio(audioObject, id) {\n  const result = {};\n  const channelStr = ((audioObject.coreaudio_device_transport || '') + ' ' + (audioObject._name || '')).toLowerCase();\n\n  result.id = id;\n  result.name = audioObject._name;\n  result.manufacturer = audioObject.coreaudio_device_manufacturer;\n  result.revision = null;\n  result.driver = null;\n  result.default = !!(audioObject.coreaudio_default_audio_input_device || '') || !!(audioObject.coreaudio_default_audio_output_device || '');\n  result.channel = parseDarwinChannel(channelStr);\n  result.type = parseAudioType(result.name, !!(audioObject.coreaudio_device_input || ''), !!(audioObject.coreaudio_device_output || ''));\n  result.in = !!(audioObject.coreaudio_device_input || '');\n  result.out = !!(audioObject.coreaudio_device_output || '');\n  result.status = 'online';\n\n  return result;\n}\n\nfunction parseWindowsAudio(lines) {\n  const result = {};\n  const status = util.getValue(lines, 'StatusInfo', ':');\n\n  result.id = util.getValue(lines, 'DeviceID', ':'); // PNPDeviceID??\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.revision = null;\n  result.driver = null;\n  result.default = null;\n  result.channel = null;\n  result.type = parseAudioType(result.name, null, null);\n  result.in = null;\n  result.out = null;\n  result.status = status;\n\n  return result;\n}\n\nfunction audio(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'lspci -vmm 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // PCI\n          if (!error) {\n            const audioPCI = getLinuxAudioPci();\n            const parts = stdout.toString().split('\\n\\n');\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'class', ':', true).toLowerCase().indexOf('audio') >= 0) {\n                const audio = parseLinuxAudioPciMM(lines, audioPCI);\n                result.push(audio);\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPAudioDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]['_items'] && outObj.SPAudioDataType[0]['_items'].length) {\n                for (let i = 0; i < outObj.SPAudioDataType[0]['_items'].length; i++) {\n                  const audio = parseDarwinAudio(outObj.SPAudioDataType[0]['_items'][i], i);\n                  result.push(audio);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach(element => {\n              const lines = element.split('\\n');\n              if (util.getValue(lines, 'name', ':')) {\n                result.push(parseWindowsAudio(lines));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.audio = audio;\n","'use strict';\n// @ts-check;\n// ==================================================================================\n// battery.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 6. Battery\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {\n  const result = {};\n  let status = util.getValue(lines, 'BatteryStatus', ':').trim();\n  // 1 = \"Discharging\"\n  // 2 = \"On A/C\"\n  // 3 = \"Fully Charged\"\n  // 4 = \"Low\"\n  // 5 = \"Critical\"\n  // 6 = \"Charging\"\n  // 7 = \"Charging High\"\n  // 8 = \"Charging Low\"\n  // 9 = \"Charging Critical\"\n  // 10 = \"Undefined\"\n  // 11 = \"Partially Charged\"\n  if (status >= 0) {\n    const statusValue = status ? parseInt(status) : 0;\n    result.status = statusValue;\n    result.hasBattery = true;\n    result.maxCapacity = fullChargeCapacity || parseInt(util.getValue(lines, 'DesignCapacity', ':') || 0);\n    result.designedCapacity = parseInt(util.getValue(lines, 'DesignCapacity', ':') || designedCapacity);\n    result.voltage = parseInt(util.getValue(lines, 'DesignVoltage', ':') || 0) / 1000.0;\n    result.capacityUnit = 'mWh';\n    result.percent = parseInt(util.getValue(lines, 'EstimatedChargeRemaining', ':') || 0);\n    result.currentCapacity = parseInt(result.maxCapacity * result.percent / 100);\n    result.isCharging = (statusValue >= 6 && statusValue <= 9) || statusValue === 11 || ((statusValue !== 3) && (statusValue !== 1) && result.percent < 100);\n    result.acConnected = result.isCharging || statusValue === 2;\n    result.model = util.getValue(lines, 'DeviceID', ':');\n  } else {\n    result.status = -1;\n  }\n\n  return result;\n}\n\nmodule.exports = function (callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        hasBattery: false,\n        cycleCount: 0,\n        isCharging: false,\n        designedCapacity: 0,\n        maxCapacity: 0,\n        currentCapacity: 0,\n        voltage: 0,\n        capacityUnit: '',\n        percent: 0,\n        timeRemaining: null,\n        acConnected: true,\n        type: '',\n        model: '',\n        manufacturer: '',\n        serial: ''\n      };\n\n      if (_linux) {\n        let battery_path = '';\n        if (fs.existsSync('/sys/class/power_supply/BAT1/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT1/';\n        } else if (fs.existsSync('/sys/class/power_supply/BAT0/uevent')) {\n          battery_path = '/sys/class/power_supply/BAT0/';\n        }\n\n        let acConnected = false;\n        let acPath = '';\n        if (fs.existsSync('/sys/class/power_supply/AC/online')) {\n          acPath = '/sys/class/power_supply/AC/online';\n        } else if (fs.existsSync('/sys/class/power_supply/AC0/online')) {\n          acPath = '/sys/class/power_supply/AC0/online';\n        }\n\n        if (acPath) {\n          const file = fs.readFileSync(acPath);\n          acConnected = file.toString().trim() === '1';\n        }\n\n        if (battery_path) {\n          fs.readFile(battery_path + 'uevent', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n\n              result.isCharging = (util.getValue(lines, 'POWER_SUPPLY_STATUS', '=').toLowerCase() === 'charging');\n              result.acConnected = acConnected || result.isCharging;\n              result.voltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_NOW', '='), 10) / 1000000.0;\n              result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n              result.cycleCount = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CYCLE_COUNT', '='), 10);\n              result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL', '=', true, true), 10) / 1000.0 * (result.voltage || 1));\n              const desingedMinVoltage = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_VOLTAGE_MIN_DESIGN', '='), 10) / 1000000.0;\n              result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_FULL_DESIGN', '=', true, true), 10) / 1000.0 * (desingedMinVoltage || result.voltage || 1));\n              result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CHARGE_NOW', '='), 10) / 1000.0 * (result.voltage || 1));\n              if (!result.maxCapacity) {\n                result.maxCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL', '=', true, true), 10) / 1000.0;\n                result.designedCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_FULL_DESIGN', '=', true, true), 10) / 1000.0 | result.maxCapacity;\n                result.currentCapacity = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10) / 1000.0;\n              }\n              const percent = util.getValue(lines, 'POWER_SUPPLY_CAPACITY', '=');\n              const energy = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_ENERGY_NOW', '='), 10);\n              const power = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_POWER_NOW', '='), 10);\n              const current = parseInt('0' + util.getValue(lines, 'POWER_SUPPLY_CURRENT_NOW', '='), 10);\n\n              result.percent = parseInt('0' + percent, 10);\n              if (result.maxCapacity && result.currentCapacity) {\n                result.hasBattery = true;\n                if (!percent) {\n                  result.percent = 100.0 * result.currentCapacity / result.maxCapacity;\n                }\n              }\n              if (result.isCharging) {\n                result.hasBattery = true;\n              }\n              if (energy && power) {\n                result.timeRemaining = Math.floor(energy / power * 60);\n              } else if (current && result.currentCapacity) {\n                result.timeRemaining = Math.floor(result.currentCapacity / current * 60);\n              }\n              result.type = util.getValue(lines, 'POWER_SUPPLY_TECHNOLOGY', '=');\n              result.model = util.getValue(lines, 'POWER_SUPPLY_MODEL_NAME', '=');\n              result.manufacturer = util.getValue(lines, 'POWER_SUPPLY_MANUFACTURER', '=');\n              result.serial = util.getValue(lines, 'POWER_SUPPLY_SERIAL_NUMBER', '=');\n              if (callback) { callback(result); }\n              resolve(result);\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i hw.acpi.battery hw.acpi.acline', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const batteries = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.units'), 10);\n          const percent = parseInt('0' + util.getValue(lines, 'hw.acpi.battery.life'), 10);\n          result.hasBattery = (batteries > 0);\n          result.cycleCount = null;\n          result.isCharging = util.getValue(lines, 'hw.acpi.acline') !== '1';\n          result.acConnected = result.isCharging;\n          result.maxCapacity = null;\n          result.currentCapacity = null;\n          result.capacityUnit = 'unknown';\n          result.percent = batteries ? percent : null;\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('ioreg -n AppleSmartBattery -r | egrep \"CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|BatterySerialNumber|TimeRemaining|Voltage\"; pmset -g batt | grep %', function (error, stdout) {\n          if (stdout) {\n            let lines = stdout.toString().replace(/ +/g, '').replace(/\"+/g, '').replace(/-/g, '').split('\\n');\n            result.cycleCount = parseInt('0' + util.getValue(lines, 'cyclecount', '='), 10);\n            result.voltage = parseInt('0' + util.getValue(lines, 'voltage', '='), 10) / 1000.0;\n            result.capacityUnit = result.voltage ? 'mWh' : 'mAh';\n            result.maxCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawmaxcapacity', '='), 10) * (result.voltage || 1));\n            result.currentCapacity = Math.round(parseInt('0' + util.getValue(lines, 'applerawcurrentcapacity', '='), 10) * (result.voltage || 1));\n            result.designedCapacity = Math.round(parseInt('0' + util.getValue(lines, 'DesignCapacity', '='), 10) * (result.voltage || 1));\n            result.manufacturer = 'Apple';\n            result.serial = util.getValue(lines, 'BatterySerialNumber', '=');\n            let percent = null;\n            const line = util.getValue(lines, 'internal', 'Battery');\n            let parts = line.split(';');\n            if (parts && parts[0]) {\n              let parts2 = parts[0].split('\\t');\n              if (parts2 && parts2[1]) {\n                percent = parseFloat(parts2[1].trim().replace(/%/g, ''));\n              }\n            }\n            if (parts && parts[1]) {\n              result.isCharging = (parts[1].trim() === 'charging');\n              result.acConnected = (parts[1].trim() !== 'discharging');\n            } else {\n              result.isCharging = util.getValue(lines, 'ischarging', '=').toLowerCase() === 'yes';\n              result.acConnected = result.isCharging;\n            }\n            if (result.maxCapacity && result.currentCapacity) {\n              result.hasBattery = true;\n              result.type = 'Li-ion';\n              result.percent = percent !== null ? percent : Math.round(100.0 * result.currentCapacity / result.maxCapacity);\n              if (!result.isCharging) {\n                result.timeRemaining = parseInt('0' + util.getValue(lines, 'TimeRemaining', '='), 10);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity'));\n          workload.push(util.powerShell('(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            if (data) {\n              let parts = data.results[0].split(/\\n\\s*\\n/);\n              let batteries = [];\n              const hasValue = value => /\\S/.test(value);\n              for (let i = 0; i < parts.length; i++) {\n                if (hasValue(parts[i]) && (!batteries.length || !hasValue(parts[i - 1]))) {\n                  batteries.push([]);\n                }\n                if (hasValue(parts[i])) {\n                  batteries[batteries.length - 1].push(parts[i]);\n                }\n              }\n              let designCapacities = data.results[1].split('\\r\\n').filter(e => e);\n              let fullChargeCapacities = data.results[2].split('\\r\\n').filter(e => e);\n              if (batteries.length) {\n                let first = false;\n                let additionalBatteries = [];\n                for (let i = 0; i < batteries.length; i++) {\n                  let lines = batteries[i][0].split('\\r\\n');\n                  const designedCapacity = designCapacities && designCapacities.length >= (i + 1) && designCapacities[i] ? util.toInt(designCapacities[i]) : 0;\n                  const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= (i + 1) && fullChargeCapacities[i] ? util.toInt(fullChargeCapacities[i]) : 0;\n                  const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);\n                  if (!first && parsed.status > 0 && parsed.status !== 10) {\n                    result.hasBattery = parsed.hasBattery;\n                    result.maxCapacity = parsed.maxCapacity;\n                    result.designedCapacity = parsed.designedCapacity;\n                    result.voltage = parsed.voltage;\n                    result.capacityUnit = parsed.capacityUnit;\n                    result.percent = parsed.percent;\n                    result.currentCapacity = parsed.currentCapacity;\n                    result.isCharging = parsed.isCharging;\n                    result.acConnected = parsed.acConnected;\n                    result.model = parsed.model;\n                    first = true;\n                  } else if (parsed.status !== -1) {\n                    additionalBatteries.push(\n                      {\n                        hasBattery: parsed.hasBattery,\n                        maxCapacity: parsed.maxCapacity,\n                        designedCapacity: parsed.designedCapacity,\n                        voltage: parsed.voltage,\n                        capacityUnit: parsed.capacityUnit,\n                        percent: parsed.percent,\n                        currentCapacity: parsed.currentCapacity,\n                        isCharging: parsed.isCharging,\n                        timeRemaining: null,\n                        acConnected: parsed.acConnected,\n                        model: parsed.model,\n                        type: '',\n                        manufacturer: '',\n                        serial: ''\n                      }\n                    );\n                  }\n                }\n                if (!first && additionalBatteries.length) {\n                  result = additionalBatteries[0];\n                  additionalBatteries.shift();\n                }\n                if (additionalBatteries.length) {\n                  result.additionalBatteries = additionalBatteries;\n                }\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n};\n","'use strict';\n// @ts-check\n// ==================================================================================\n// audio.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 17. bluetooth\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst path = require('path');\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseBluetoothType(str) {\n  let result = '';\n\n  if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  if (str.indexOf('speaker') >= 0) { result = 'Speaker'; }\n  if (str.indexOf('headset') >= 0) { result = 'Headset'; }\n  if (str.indexOf('phone') >= 0) { result = 'Phone'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Computer'; }\n  if (str.indexOf('imac') >= 0) { result = 'Computer'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Tablet'; }\n  if (str.indexOf('watch') >= 0) { result = 'Watch'; }\n  if (str.indexOf('headphone') >= 0) { result = 'Headset'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseBluetoothManufacturer(str) {\n  let result = str.split(' ')[0];\n  str = str.toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n  if (str.indexOf('ipad') >= 0) { result = 'Apple'; }\n  if (str.indexOf('imac') >= 0) { result = 'Apple'; }\n  if (str.indexOf('iphone') >= 0) { result = 'Apple'; }\n  if (str.indexOf('magic mouse') >= 0) { result = 'Apple'; }\n  if (str.indexOf('macbook') >= 0) { result = 'Apple'; }\n  // to be continued ...\n\n  return result;\n}\n\nfunction parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', '=');\n  result.manufacturer = null;\n  result.macDevice = macAddr1;\n  result.macHost = macAddr2;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = false;\n\n  return result;\n}\n\nfunction parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {\n  const result = {};\n  const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || '') + (bluetoothObject.device_name || '')).toLowerCase();\n\n  result.device = bluetoothObject.device_services || '';\n  result.name = bluetoothObject.device_name || '';\n  result.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothManufacturer(bluetoothObject.device_name || '') || '';\n  result.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || '').toLowerCase().replace(/-/g, ':');\n  result.macHost = macAddr2;\n  result.batteryPercent = bluetoothObject.device_batteryPercent || null;\n  result.type = parseBluetoothType(typeStr);\n  result.connected = bluetoothObject.device_isconnected === 'attrib_Yes' || false;\n\n  return result;\n}\n\nfunction parseWindowsBluetooth(lines) {\n  const result = {};\n\n  result.device = null;\n  result.name = util.getValue(lines, 'name', ':');\n  result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n  result.macDevice = null;\n  result.macHost = null;\n  result.batteryPercent = null;\n  result.type = parseBluetoothType(result.name.toLowerCase());\n  result.connected = null;\n\n  return result;\n}\n\nfunction bluetoothDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        // get files in /var/lib/bluetooth/ recursive\n        const btFiles = util.getFilesInPath('/var/lib/bluetooth/');\n        btFiles.forEach((element) => {\n          const filename = path.basename(element);\n          const pathParts = element.split('/');\n          const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;\n          const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;\n          if (filename === 'info') {\n            const infoFile = fs.readFileSync(element, { encoding: 'utf8' }).split('\\n');\n            result.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));\n          }\n        });\n        // determine \"connected\" with hcitool con\n        try {\n          const hdicon = execSync('hcitool con').toString().toLowerCase();\n          for (let i = 0; i < result.length; i++) {\n            if (result[i].macDevice && result[i].macDevice.length > 10 && hdicon.indexOf(result[i].macDevice.toLowerCase()) >= 0) {\n              result[i].connected = true;\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPBluetoothDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_title'] && outObj.SPBluetoothDataType[0]['device_title'].length) {\n                // missing: host BT Adapter macAddr ()\n                let macAddr2 = null;\n                if (outObj.SPBluetoothDataType[0]['local_device_title'] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {\n                  macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ':');\n                }\n                outObj.SPBluetoothDataType[0]['device_title'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_connected'] && outObj.SPBluetoothDataType[0]['device_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_Yes';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n              if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]['device_not_connected'] && outObj.SPBluetoothDataType[0]['device_not_connected'].length) {\n                const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ':') : null;\n                outObj.SPBluetoothDataType[0]['device_not_connected'].forEach((element) => {\n                  const obj = element;\n                  const objKey = Object.keys(obj);\n                  if (objKey && objKey.length === 1) {\n                    const innerObject = obj[objKey[0]];\n                    innerObject.device_name = objKey[0];\n                    innerObject.device_isconnected = 'attrib_No';\n                    const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);\n                    result.push(bluetoothDevice);\n                  }\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            parts.forEach((part) => {\n              if (util.getValue(part.split('\\n'), 'PNPClass', ':') === 'Bluetooth') {\n                result.push(parseWindowsBluetooth(part.split('\\n')));\n              }\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _netbsd || _openbsd || _sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.bluetoothDevices = bluetoothDevices;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// cpu.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 4. CPU\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _cpu_speed = 0;\nlet _current_cpu = {\n  user: 0,\n  nice: 0,\n  system: 0,\n  idle: 0,\n  irq: 0,\n  load: 0,\n  tick: 0,\n  ms: 0,\n  currentLoad: 0,\n  currentLoadUser: 0,\n  currentLoadSystem: 0,\n  currentLoadNice: 0,\n  currentLoadIdle: 0,\n  currentLoadIrq: 0,\n  rawCurrentLoad: 0,\n  rawCurrentLoadUser: 0,\n  rawCurrentLoadSystem: 0,\n  rawCurrentLoadNice: 0,\n  rawCurrentLoadIdle: 0,\n  rawCurrentLoadIrq: 0\n};\nlet _cpus = [];\nlet _corecount = 0;\n\nconst AMDBaseFrequencies = {\n  '8346': '1.8',\n  '8347': '1.9',\n  '8350': '2.0',\n  '8354': '2.2',\n  '8356|SE': '2.4',\n  '8356': '2.3',\n  '8360': '2.5',\n  '2372': '2.1',\n  '2373': '2.1',\n  '2374': '2.2',\n  '2376': '2.3',\n  '2377': '2.3',\n  '2378': '2.4',\n  '2379': '2.4',\n  '2380': '2.5',\n  '2381': '2.5',\n  '2382': '2.6',\n  '2384': '2.7',\n  '2386': '2.8',\n  '2387': '2.8',\n  '2389': '2.9',\n  '2393': '3.1',\n  '8374': '2.2',\n  '8376': '2.3',\n  '8378': '2.4',\n  '8379': '2.4',\n  '8380': '2.5',\n  '8381': '2.5',\n  '8382': '2.6',\n  '8384': '2.7',\n  '8386': '2.8',\n  '8387': '2.8',\n  '8389': '2.9',\n  '8393': '3.1',\n  '2419EE': '1.8',\n  '2423HE': '2.0',\n  '2425HE': '2.1',\n  '2427': '2.2',\n  '2431': '2.4',\n  '2435': '2.6',\n  '2439SE': '2.8',\n  '8425HE': '2.1',\n  '8431': '2.4',\n  '8435': '2.6',\n  '8439SE': '2.8',\n  '4122': '2.2',\n  '4130': '2.6',\n  '4162EE': '1.7',\n  '4164EE': '1.8',\n  '4170HE': '2.1',\n  '4174HE': '2.3',\n  '4176HE': '2.4',\n  '4180': '2.6',\n  '4184': '2.8',\n  '6124HE': '1.8',\n  '6128HE': '2.0',\n  '6132HE': '2.2',\n  '6128': '2.0',\n  '6134': '2.3',\n  '6136': '2.4',\n  '6140': '2.6',\n  '6164HE': '1.7',\n  '6166HE': '1.8',\n  '6168': '1.9',\n  '6172': '2.1',\n  '6174': '2.2',\n  '6176': '2.3',\n  '6176SE': '2.3',\n  '6180SE': '2.5',\n  '3250': '2.5',\n  '3260': '2.7',\n  '3280': '2.4',\n  '4226': '2.7',\n  '4228': '2.8',\n  '4230': '2.9',\n  '4234': '3.1',\n  '4238': '3.3',\n  '4240': '3.4',\n  '4256': '1.6',\n  '4274': '2.5',\n  '4276': '2.6',\n  '4280': '2.8',\n  '4284': '3.0',\n  '6204': '3.3',\n  '6212': '2.6',\n  '6220': '3.0',\n  '6234': '2.4',\n  '6238': '2.6',\n  '6262HE': '1.6',\n  '6272': '2.1',\n  '6274': '2.2',\n  '6276': '2.3',\n  '6278': '2.4',\n  '6282SE': '2.6',\n  '6284SE': '2.7',\n  '6308': '3.5',\n  '6320': '2.8',\n  '6328': '3.2',\n  '6338P': '2.3',\n  '6344': '2.6',\n  '6348': '2.8',\n  '6366': '1.8',\n  '6370P': '2.0',\n  '6376': '2.3',\n  '6378': '2.4',\n  '6380': '2.5',\n  '6386': '2.8',\n  'FX|4100': '3.6',\n  'FX|4120': '3.9',\n  'FX|4130': '3.8',\n  'FX|4150': '3.8',\n  'FX|4170': '4.2',\n  'FX|6100': '3.3',\n  'FX|6120': '3.6',\n  'FX|6130': '3.6',\n  'FX|6200': '3.8',\n  'FX|8100': '2.8',\n  'FX|8120': '3.1',\n  'FX|8140': '3.2',\n  'FX|8150': '3.6',\n  'FX|8170': '3.9',\n  'FX|4300': '3.8',\n  'FX|4320': '4.0',\n  'FX|4350': '4.2',\n  'FX|6300': '3.5',\n  'FX|6350': '3.9',\n  'FX|8300': '3.3',\n  'FX|8310': '3.4',\n  'FX|8320': '3.5',\n  'FX|8350': '4.0',\n  'FX|8370': '4.0',\n  'FX|9370': '4.4',\n  'FX|9590': '4.7',\n  'FX|8320E': '3.2',\n  'FX|8370E': '3.3',\n\n  // ZEN Desktop CPUs\n  '1200': '3.1',\n  'Pro 1200': '3.1',\n  '1300X': '3.5',\n  'Pro 1300': '3.5',\n  '1400': '3.2',\n  '1500X': '3.5',\n  'Pro 1500': '3.5',\n  '1600': '3.2',\n  '1600X': '3.6',\n  'Pro 1600': '3.2',\n  '1700': '3.0',\n  'Pro 1700': '3.0',\n  '1700X': '3.4',\n  'Pro 1700X': '3.4',\n  '1800X': '3.6',\n  '1900X': '3.8',\n  '1920': '3.2',\n  '1920X': '3.5',\n  '1950X': '3.4',\n\n  // ZEN Desktop APUs\n  '200GE': '3.2',\n  'Pro 200GE': '3.2',\n  '220GE': '3.4',\n  '240GE': '3.5',\n  '3000G': '3.5',\n  '300GE': '3.4',\n  '3050GE': '3.4',\n  '2200G': '3.5',\n  'Pro 2200G': '3.5',\n  '2200GE': '3.2',\n  'Pro 2200GE': '3.2',\n  '2400G': '3.6',\n  'Pro 2400G': '3.6',\n  '2400GE': '3.2',\n  'Pro 2400GE': '3.2',\n\n  // ZEN Mobile APUs\n  'Pro 200U': '2.3',\n  '300U': '2.4',\n  '2200U': '2.5',\n  '3200U': '2.6',\n  '2300U': '2.0',\n  'Pro 2300U': '2.0',\n  '2500U': '2.0',\n  'Pro 2500U': '2.2',\n  '2600H': '3.2',\n  '2700U': '2.0',\n  'Pro 2700U': '2.2',\n  '2800H': '3.3',\n\n  // ZEN Server Processors\n  '7351': '2.4',\n  '7351P': '2.4',\n  '7401': '2.0',\n  '7401P': '2.0',\n  '7551P': '2.0',\n  '7551': '2.0',\n  '7251': '2.1',\n  '7261': '2.5',\n  '7281': '2.1',\n  '7301': '2.2',\n  '7371': '3.1',\n  '7451': '2.3',\n  '7501': '2.0',\n  '7571': '2.2',\n  '7601': '2.2',\n\n  // ZEN Embedded Processors\n  'V1500B': '2.2',\n  'V1780B': '3.35',\n  'V1202B': '2.3',\n  'V1404I': '2.0',\n  'V1605B': '2.0',\n  'V1756B': '3.25',\n  'V1807B': '3.35',\n\n  '3101': '2.1',\n  '3151': '2.7',\n  '3201': '1.5',\n  '3251': '2.5',\n  '3255': '2.5',\n  '3301': '2.0',\n  '3351': '1.9',\n  '3401': '1.85',\n  '3451': '2.15',\n\n  // ZEN+ Desktop\n  '1200|AF': '3.1',\n  '2300X': '3.5',\n  '2500X': '3.6',\n  '2600': '3.4',\n  '2600E': '3.1',\n  '1600|AF': '3.2',\n  '2600X': '3.6',\n  '2700': '3.2',\n  '2700E': '2.8',\n  'Pro 2700': '3.2',\n  '2700X': '3.7',\n  'Pro 2700X': '3.6',\n  '2920X': '3.5',\n  '2950X': '3.5',\n  '2970WX': '3.0',\n  '2990WX': '3.0',\n\n  // ZEN+ Desktop APU\n  'Pro 300GE': '3.4',\n  'Pro 3125GE': '3.4',\n  '3150G': '3.5',\n  'Pro 3150G': '3.5',\n  '3150GE': '3.3',\n  'Pro 3150GE': '3.3',\n  '3200G': '3.6',\n  'Pro 3200G': '3.6',\n  '3200GE': '3.3',\n  'Pro 3200GE': '3.3',\n  '3350G': '3.6',\n  'Pro 3350G': '3.6',\n  '3350GE': '3.3',\n  'Pro 3350GE': '3.3',\n  '3400G': '3.7',\n  'Pro 3400G': '3.7',\n  '3400GE': '3.3',\n  'Pro 3400GE': '3.3',\n\n  // ZEN+ Mobile\n  '3300U': '2.1',\n  'PRO 3300U': '2.1',\n  '3450U': '2.1',\n  '3500U': '2.1',\n  'PRO 3500U': '2.1',\n  '3500C': '2.1',\n  '3550H': '2.1',\n  '3580U': '2.1',\n  '3700U': '2.3',\n  'PRO 3700U': '2.3',\n  '3700C': '2.3',\n  '3750H': '2.3',\n  '3780U': '2.3',\n\n  // ZEN2 Desktop CPUS\n  '3100': '3.6',\n  '3300X': '3.8',\n  '3500': '3.6',\n  '3500X': '3.6',\n  '3600': '3.6',\n  'Pro 3600': '3.6',\n  '3600X': '3.8',\n  '3600XT': '3.8',\n  'Pro 3700': '3.6',\n  '3700X': '3.6',\n  '3800X': '3.9',\n  '3800XT': '3.9',\n  '3900': '3.1',\n  'Pro 3900': '3.1',\n  '3900X': '3.8',\n  '3900XT': '3.8',\n  '3950X': '3.5',\n  '3960X': '3.8',\n  '3970X': '3.7',\n  '3990X': '2.9',\n  '3945WX': '4.0',\n  '3955WX': '3.9',\n  '3975WX': '3.5',\n  '3995WX': '2.7',\n\n  // ZEN2 Desktop APUs\n  '4300GE': '3.5',\n  'Pro 4300GE': '3.5',\n  '4300G': '3.8',\n  'Pro 4300G': '3.8',\n  '4600GE': '3.3',\n  'Pro 4650GE': '3.3',\n  '4600G': '3.7',\n  'Pro 4650G': '3.7',\n  '4700GE': '3.1',\n  'Pro 4750GE': '3.1',\n  '4700G': '3.6',\n  'Pro 4750G': '3.6',\n  '4300U': '2.7',\n  '4450U': '2.5',\n  'Pro 4450U': '2.5',\n  '4500U': '2.3',\n  '4600U': '2.1',\n  'PRO 4650U': '2.1',\n  '4680U': '2.1',\n  '4600HS': '3.0',\n  '4600H': '3.0',\n  '4700U': '2.0',\n  'PRO 4750U': '1.7',\n  '4800U': '1.8',\n  '4800HS': '2.9',\n  '4800H': '2.9',\n  '4900HS': '3.0',\n  '4900H': '3.3',\n  '5300U': '2.6',\n  '5500U': '2.1',\n  '5700U': '1.8',\n\n  // ZEN2 - EPYC\n  '7232P': '3.1',\n  '7302P': '3.0',\n  '7402P': '2.8',\n  '7502P': '2.5',\n  '7702P': '2.0',\n  '7252': '3.1',\n  '7262': '3.2',\n  '7272': '2.9',\n  '7282': '2.8',\n  '7302': '3.0',\n  '7352': '2.3',\n  '7402': '2.8',\n  '7452': '2.35',\n  '7502': '2.5',\n  '7532': '2.4',\n  '7542': '2.9',\n  '7552': '2.2',\n  '7642': '2.3',\n  '7662': '2.0',\n  '7702': '2.0',\n  '7742': '2.25',\n  '7H12': '2.6',\n  '7F32': '3.7',\n  '7F52': '3.5',\n  '7F72': '3.2',\n\n  // Epyc (Milan)\n\n  '7763': '2.45',\n  '7713': '2.0',\n  '7713P': '2.0',\n  '7663': '2.0',\n  '7643': '2.3',\n  '75F3': '2.95',\n  '7543': '2.8',\n  '7543P': '2.8',\n  '7513': '2.6',\n  '7453': '2.75',\n  '74F3': '3.2',\n  '7443': '2.85',\n  '7443P': '2.85',\n  '7413': '2.65',\n  '73F3': '3.5',\n  '7343': '3.2',\n  '7313': '3.0',\n  '7313P': '3.0',\n  '72F3': '3.7',\n\n  // ZEN3\n  '5600X': '3.7',\n  '5800X': '3.8',\n  '5900X': '3.7',\n  '5950X': '3.4'\n};\n\n\nconst socketTypes = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Daughter Board',\n  4: 'ZIF Socket',\n  5: 'Replacement/Piggy Back',\n  6: 'None',\n  7: 'LIF Socket',\n  8: 'Slot 1',\n  9: 'Slot 2',\n  10: '370 Pin Socket',\n  11: 'Slot A',\n  12: 'Slot M',\n  13: '423',\n  14: 'A (Socket 462)',\n  15: '478',\n  16: '754',\n  17: '940',\n  18: '939',\n  19: 'mPGA604',\n  20: 'LGA771',\n  21: 'LGA775',\n  22: 'S1',\n  23: 'AM2',\n  24: 'F (1207)',\n  25: 'LGA1366',\n  26: 'G34',\n  27: 'AM3',\n  28: 'C32',\n  29: 'LGA1156',\n  30: 'LGA1567',\n  31: 'PGA988A',\n  32: 'BGA1288',\n  33: 'rPGA988B',\n  34: 'BGA1023',\n  35: 'BGA1224',\n  36: 'LGA1155',\n  37: 'LGA1356',\n  38: 'LGA2011',\n  39: 'FS1',\n  40: 'FS2',\n  41: 'FM1',\n  42: 'FM2',\n  43: 'LGA2011-3',\n  44: 'LGA1356-3',\n  45: 'LGA1150',\n  46: 'BGA1168',\n  47: 'BGA1234',\n  48: 'BGA1364',\n  49: 'AM4',\n  50: 'LGA1151',\n  51: 'BGA1356',\n  52: 'BGA1440',\n  53: 'BGA1515',\n  54: 'LGA3647-1',\n  55: 'SP3',\n  56: 'SP3r2',\n  57: 'LGA2066',\n  58: 'BGA1392',\n  59: 'BGA1510',\n  60: 'BGA1528',\n  61: 'LGA4189',\n  62: 'LGA1200',\n  63: 'LGA4677',\n};\n\nconst socketTypesByName = {\n  'LGA1150': 'i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430',\n  'LGA1151': 'i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400',\n  '1155': 'G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290'\n};\n\nfunction getSocketTypesByName(str) {\n  let result = '';\n  for (const key in socketTypesByName) {\n    const names = socketTypesByName[key].split(' ');\n    names.forEach(element => {\n      if (str.indexOf(element) >= 0) {\n        result = key;\n      }\n    });\n  }\n  return result;\n}\n\nfunction cpuManufacturer(str) {\n  let result = str;\n  str = str.toLowerCase();\n\n  if (str.indexOf('intel') >= 0) { result = 'Intel'; }\n  if (str.indexOf('amd') >= 0) { result = 'AMD'; }\n  if (str.indexOf('qemu') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('hygon') >= 0) { result = 'Hygon'; }\n  if (str.indexOf('centaur') >= 0) { result = 'WinChip/Via'; }\n  if (str.indexOf('vmware') >= 0) { result = 'VMware'; }\n  if (str.indexOf('Xen') >= 0) { result = 'Xen Hypervisor'; }\n  if (str.indexOf('tcg') >= 0) { result = 'QEMU'; }\n  if (str.indexOf('apple') >= 0) { result = 'Apple'; }\n\n  return result;\n}\n\nfunction cpuBrandManufacturer(res) {\n  res.brand = res.brand.replace(/\\(R\\)+/g, '®').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(TM\\)+/g, '™').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/\\(C\\)+/g, '©').replace(/\\s+/g, ' ').trim();\n  res.brand = res.brand.replace(/CPU+/g, '').replace(/\\s+/g, ' ').trim();\n  res.manufacturer = cpuManufacturer(res.brand);\n\n  let parts = res.brand.split(' ');\n  parts.shift();\n  res.brand = parts.join(' ');\n  return res;\n}\n\nfunction getAMDSpeed(brand) {\n  let result = '0';\n  for (let key in AMDBaseFrequencies) {\n    if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {\n      let parts = key.split('|');\n      let found = 0;\n      parts.forEach(item => {\n        if (brand.indexOf(item) > -1) {\n          found++;\n        }\n      });\n      if (found === parts.length) {\n        result = AMDBaseFrequencies[key];\n      }\n    }\n  }\n  return parseFloat(result);\n}\n\n// --------------------------\n// CPU - brand, speed\n\nfunction getCpu() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const UNKNOWN = 'unknown';\n      let result = {\n        manufacturer: UNKNOWN,\n        brand: UNKNOWN,\n        vendor: '',\n        family: '',\n        model: '',\n        stepping: '',\n        revision: '',\n        voltage: '',\n        speed: 0,\n        speedMin: 0,\n        speedMax: 0,\n        governor: '',\n        cores: util.cores(),\n        physicalCores: util.cores(),\n        performanceCores: util.cores(),\n        efficiencyCores: 0,\n        processors: 1,\n        socket: '',\n        flags: '',\n        virtualization: false,\n        cache: {}\n      };\n      cpuFlags().then(flags => {\n        result.flags = flags;\n        result.virtualization = flags.indexOf('vmx') > -1 || flags.indexOf('svm') > -1;\n        if (_darwin) {\n          exec('sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily', function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            const modelline = util.getValue(lines, 'machdep.cpu.brand_string');\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            const speed = modellineParts[1] ? modellineParts[1].trim() : '0';\n            result.speed = parseFloat(speed.replace(/GHz+/g, ''));\n            let tbFrequency = util.getValue(lines, 'hw.tbfrequency') / 1000000000.0;\n            tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;\n            result.speed = result.speed === 0 ? tbFrequency : result.speed;\n\n            _cpu_speed = result.speed;\n            result = cpuBrandManufacturer(result);\n            result.speedMin = util.getValue(lines, 'hw.cpufrequency_min') ? (util.getValue(lines, 'hw.cpufrequency_min') / 1000000000.0) : result.speed;\n            result.speedMax = util.getValue(lines, 'hw.cpufrequency_max') ? (util.getValue(lines, 'hw.cpufrequency_max') / 1000000000.0) : result.speed;\n            result.vendor = util.getValue(lines, 'machdep.cpu.vendor') || 'Apple';\n            result.family = util.getValue(lines, 'machdep.cpu.family') || util.getValue(lines, 'hw.cpufamily');\n            result.model = util.getValue(lines, 'machdep.cpu.model');\n            result.stepping = util.getValue(lines, 'machdep.cpu.stepping') || util.getValue(lines, 'hw.cpusubfamily');\n            result.virtualization = true;\n            const countProcessors = util.getValue(lines, 'hw.packages');\n            const countCores = util.getValue(lines, 'hw.physicalcpu_max');\n            const countThreads = util.getValue(lines, 'hw.ncpu');\n            if (os.arch() === 'arm64') {\n              const clusters = execSync('ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type').toString().split('\\n');\n              const efficiencyCores = clusters.filter(line => line.indexOf('\"E\"') >= 0).length;\n              const performanceCores = clusters.filter(line => line.indexOf('\"P\"') >= 0).length;\n              result.socket = 'SOC';\n              result.efficiencyCores = efficiencyCores;\n              result.performanceCores = performanceCores;\n            }\n            if (countProcessors) {\n              result.processors = parseInt(countProcessors) || 1;\n            }\n            if (countCores && countThreads) {\n              result.cores = parseInt(countThreads) || util.cores();\n              result.physicalCores = parseInt(countCores) || util.cores();\n            }\n            cpuCache().then((res) => {\n              result.cache = res;\n              resolve(result);\n            });\n          });\n        }\n        if (_linux) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; lscpu; echo -n \"Governor: \"; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n            }\n            modelline = util.getValue(lines, 'model name') || modelline;\n            const modellineParts = modelline.split('@');\n            result.brand = modellineParts[0].trim();\n            result.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = Math.round(parseFloat(util.getValue(lines, 'cpu min mhz').replace(/,/g, '.')) / 10.0) / 100;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'cpu max mhz').replace(/,/g, '.')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'vendor id'));\n\n            result.family = util.getValue(lines, 'cpu family');\n            result.model = util.getValue(lines, 'model:');\n            result.stepping = util.getValue(lines, 'stepping');\n            result.revision = util.getValue(lines, 'cpu revision');\n            result.cache.l1d = util.getValue(lines, 'l1d cache');\n            if (result.cache.l1d) { result.cache.l1d = parseInt(result.cache.l1d) * (result.cache.l1d.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1d.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l1i = util.getValue(lines, 'l1i cache');\n            if (result.cache.l1i) { result.cache.l1i = parseInt(result.cache.l1i) * (result.cache.l1i.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l1i.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l2 = util.getValue(lines, 'l2 cache');\n            if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2) * (result.cache.l2.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l2.indexOf('K') !== -1 ? 1024 : 1)); }\n            result.cache.l3 = util.getValue(lines, 'l3 cache');\n            if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3) * (result.cache.l3.indexOf('M') !== -1 ? 1024 * 1024 : (result.cache.l3.indexOf('K') !== -1 ? 1024 : 1)); }\n\n            const threadsPerCore = util.getValue(lines, 'thread(s) per core') || '1';\n            const processors = util.getValue(lines, 'socket(s)') || '1';\n            let threadsPerCoreInt = parseInt(threadsPerCore, 10); // threads per code (normally only for performance cores)\n            let processorsInt = parseInt(processors, 10) || 1;  // number of sockets /  processor units in machine (normally 1)\n            const coresPerSocket = parseInt(util.getValue(lines, 'core(s) per socket'), 10); // number of cores (e.g. 16 on i12900)\n            result.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result.cores / threadsPerCoreInt;\n            result.performanceCores = threadsPerCoreInt > 1 ? result.cores - result.physicalCores : result.cores;\n            result.efficiencyCores = threadsPerCoreInt > 1 ? result.cores - (threadsPerCoreInt * result.performanceCores) : 0;\n            result.processors = processorsInt;\n            result.governor = util.getValue(lines, 'governor') || '';\n\n            // Test Raspberry\n            if (result.vendor === 'ARM') {\n              const linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n              const rPIRevision = util.decodePiCpuinfo(linesRpi);\n              if (rPIRevision.model.toLowerCase().indexOf('raspberry') >= 0) {\n                result.family = result.manufacturer;\n                result.manufacturer = rPIRevision.manufacturer;\n                result.brand = rPIRevision.processor;\n                result.revision = rPIRevision.revisionCode;\n                result.socket = 'SOC';\n              }\n            }\n\n            // socket type\n            let lines2 = [];\n            exec('export LC_ALL=C; dmidecode –t 4 2>/dev/null | grep \"Upgrade: Socket\"; unset LC_ALL', function (error2, stdout2) {\n              lines2 = stdout2.toString().split('\\n');\n              if (lines2 && lines2.length) {\n                result.socket = util.getValue(lines2, 'Upgrade').replace('Socket', '').trim() || result.socket;\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          let modelline = '';\n          let lines = [];\n          if (os.cpus()[0] && os.cpus()[0].model) { modelline = os.cpus()[0].model; }\n          exec('export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL', function (error, stdout) {\n            let cache = [];\n            if (!error) {\n              const data = stdout.toString().split('# dmidecode');\n              const processor = data.length > 1 ? data[1] : '';\n              cache = data.length > 2 ? data[2].split('Cache Information') : [];\n\n              lines = processor.split('\\n');\n            }\n            result.brand = modelline.split('@')[0].trim();\n            result.speed = modelline.split('@')[1] ? parseFloat(modelline.split('@')[1].trim()) : 0;\n            if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n              result.speed = getAMDSpeed(result.brand);\n            }\n            if (result.speed === 0) {\n              const current = getCpuCurrentSpeedSync();\n              if (current.avg !== 0) { result.speed = current.avg; }\n            }\n            _cpu_speed = result.speed;\n            result.speedMin = result.speed;\n            result.speedMax = Math.round(parseFloat(util.getValue(lines, 'max speed').replace(/Mhz/g, '')) / 10.0) / 100;\n\n            result = cpuBrandManufacturer(result);\n            result.vendor = cpuManufacturer(util.getValue(lines, 'manufacturer'));\n            let sig = util.getValue(lines, 'signature');\n            sig = sig.split(',');\n            for (let i = 0; i < sig.length; i++) {\n              sig[i] = sig[i].trim();\n            }\n            result.family = util.getValue(sig, 'Family', ' ', true);\n            result.model = util.getValue(sig, 'Model', ' ', true);\n            result.stepping = util.getValue(sig, 'Stepping', ' ', true);\n            result.revision = '';\n            const voltage = parseFloat(util.getValue(lines, 'voltage'));\n            result.voltage = isNaN(voltage) ? '' : voltage.toFixed(2);\n            for (let i = 0; i < cache.length; i++) {\n              lines = cache[i].split('\\n');\n              let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n              cacheType = cacheType.length ? cacheType[0] : '';\n              const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n              let size = parseInt(sizeParts[0], 10);\n              const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n              size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n              if (cacheType) {\n                if (cacheType === 'l1') {\n                  result.cache[cacheType + 'd'] = size / 2;\n                  result.cache[cacheType + 'i'] = size / 2;\n                } else {\n                  result.cache[cacheType] = size;\n                }\n              }\n            }\n            // socket type\n            result.socket = util.getValue(lines, 'Upgrade').replace('Socket', '').trim();\n            // # threads / # cores\n            const threadCount = util.getValue(lines, 'thread count').trim();\n            const coreCount = util.getValue(lines, 'core count').trim();\n            if (coreCount && threadCount) {\n              result.cores = parseInt(threadCount, 10);\n              result.physicalCores = parseInt(coreCount, 10);\n            }\n            resolve(result);\n          });\n        }\n        if (_sunos) {\n          resolve(result);\n        }\n        if (_windows) {\n          try {\n            const workload = [];\n            workload.push(util.powerShell('Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl'));\n            workload.push(util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl'));\n            workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n\n            Promise.all(\n              workload\n            ).then((data) => {\n              let lines = data[0].split('\\r\\n');\n              let name = util.getValue(lines, 'name', ':') || '';\n              if (name.indexOf('@') >= 0) {\n                result.brand = name.split('@')[0].trim();\n                result.speed = name.split('@')[1] ? parseFloat(name.split('@')[1].trim()) : 0;\n                _cpu_speed = result.speed;\n              } else {\n                result.brand = name.trim();\n                result.speed = 0;\n              }\n              result = cpuBrandManufacturer(result);\n              result.revision = util.getValue(lines, 'revision', ':');\n              result.cache.l1d = 0;\n              result.cache.l1i = 0;\n              result.cache.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.cache.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.cache.l2) { result.cache.l2 = parseInt(result.cache.l2, 10) * 1024; }\n              if (result.cache.l3) { result.cache.l3 = parseInt(result.cache.l3, 10) * 1024; }\n              result.vendor = util.getValue(lines, 'manufacturer', ':');\n              result.speedMax = Math.round(parseFloat(util.getValue(lines, 'maxclockspeed', ':').replace(/,/g, '.')) / 10.0) / 100;\n              if (result.speed === 0 && (result.brand.indexOf('AMD') > -1 || result.brand.toLowerCase().indexOf('ryzen') > -1)) {\n                result.speed = getAMDSpeed(result.brand);\n              }\n              if (result.speed === 0) {\n                result.speed = result.speedMax;\n              }\n              result.speedMin = result.speed;\n\n              let description = util.getValue(lines, 'description', ':').split(' ');\n              for (let i = 0; i < description.length; i++) {\n                if (description[i].toLowerCase().startsWith('family') && (i + 1) < description.length && description[i + 1]) {\n                  result.family = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('model') && (i + 1) < description.length && description[i + 1]) {\n                  result.model = description[i + 1];\n                }\n                if (description[i].toLowerCase().startsWith('stepping') && (i + 1) < description.length && description[i + 1]) {\n                  result.stepping = description[i + 1];\n                }\n              }\n              // socket type\n              const socketId = util.getValue(lines, 'UpgradeMethod', ':');\n              if (socketTypes[socketId]) {\n                result.socket = socketTypes[socketId];\n              }\n              const socketByName = getSocketTypesByName(name);\n              if (socketByName) {\n                result.socket = socketByName;\n              }\n              // # threads / # cores\n              const countProcessors = util.countLines(lines, 'Caption');\n              const countThreads = util.getValue(lines, 'NumberOfLogicalProcessors', ':');\n              const countCores = util.getValue(lines, 'NumberOfCores', ':');\n              if (countProcessors) {\n                result.processors = parseInt(countProcessors) || 1;\n              }\n              if (countCores && countThreads) {\n                result.cores = parseInt(countThreads) || util.cores();\n                result.physicalCores = parseInt(countCores) || util.cores();\n              }\n              if (countProcessors > 1) {\n                result.cores = result.cores * countProcessors;\n                result.physicalCores = result.physicalCores * countProcessors;\n              }\n              const parts = data[1].split(/\\n\\s*\\n/);\n              parts.forEach(function (part) {\n                lines = part.split('\\r\\n');\n                const cacheType = util.getValue(lines, 'CacheType');\n                const level = util.getValue(lines, 'Level');\n                const installedSize = util.getValue(lines, 'InstalledSize');\n                // L1 Instructions\n                if (level === '3' && cacheType === '3') {\n                  result.cache.l1i = parseInt(installedSize, 10);\n                }\n                // L1 Data\n                if (level === '3' && cacheType === '4') {\n                  result.cache.l1d = parseInt(installedSize, 10);\n                }\n                // L1 all\n                if (level === '3' && cacheType === '5' && !result.cache.l1i && !result.cache.l1d) {\n                  result.cache.l1i = parseInt(installedSize, 10) / 2;\n                  result.cache.l1d = parseInt(installedSize, 10) / 2;\n                }\n              });\n              const hyperv = data[2] ? data[2].toString().toLowerCase() : '';\n              result.virtualization = hyperv.indexOf('true') !== -1;\n\n              resolve(result);\n            });\n          } catch (e) {\n            resolve(result);\n          }\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// CPU - Processor Data\n\nfunction cpu(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getCpu().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.cpu = cpu;\n\n// --------------------------\n// CPU - current speed - in GHz\n\nfunction getCpuCurrentSpeedSync() {\n\n  let cpus = os.cpus();\n  let minFreq = 999999999;\n  let maxFreq = 0;\n  let avgFreq = 0;\n  let cores = [];\n\n  if (cpus && cpus.length) {\n    for (let i in cpus) {\n      if ({}.hasOwnProperty.call(cpus, i)) {\n        let freq = cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1000 : cpus[i].speed / 10;\n        avgFreq = avgFreq + freq;\n        if (freq > maxFreq) { maxFreq = freq; }\n        if (freq < minFreq) { minFreq = freq; }\n        cores.push(parseFloat(freq.toFixed(2)));\n      }\n    }\n    avgFreq = avgFreq / cpus.length;\n    return {\n      min: parseFloat(minFreq.toFixed(2)),\n      max: parseFloat(maxFreq.toFixed(2)),\n      avg: parseFloat((avgFreq).toFixed(2)),\n      cores: cores\n    };\n  } else {\n    return {\n      min: 0,\n      max: 0,\n      avg: 0,\n      cores: cores\n    };\n  }\n}\n\nfunction cpuCurrentSpeed(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getCpuCurrentSpeedSync();\n      if (result.avg === 0 && _cpu_speed !== 0) {\n        const currCpuSpeed = parseFloat(_cpu_speed);\n        result = {\n          min: currCpuSpeed,\n          max: currCpuSpeed,\n          avg: currCpuSpeed,\n          cores: []\n        };\n      }\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.cpuCurrentSpeed = cpuCurrentSpeed;\n\n// --------------------------\n// CPU - temperature\n// if sensors are installed\n\nfunction cpuTemperature(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        main: null,\n        cores: [],\n        max: null,\n        socket: [],\n        chipset: null\n      };\n      if (_linux) {\n        // CPU Chipset, Socket\n        try {\n          const cmd = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo \"-----\"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';\n          const parts = execSync(cmd).toString().split('-----\\n');\n          if (parts.length === 2) {\n            const lines = parts[0].split('\\n');\n            const lines2 = parts[1].split('\\n');\n            for (let i = 0; i < lines.length; i++) {\n              const line = lines[i].trim();\n              if (line.startsWith('acpi') && lines2[i]) {\n                result.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);\n              }\n              if (line.startsWith('pch') && lines2[i]) {\n                result.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;\n              }\n            }\n          }\n        } catch (e) {\n          util.noop();\n        }\n\n        const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in \"$mon\"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat \"$label\")___$(cat \"$value\"); fi; done; done;';\n        try {\n          exec(cmd, function (error, stdout) {\n            stdout = stdout.toString();\n            const tdiePos = stdout.toLowerCase().indexOf('tdie');\n            if (tdiePos !== -1) {\n              stdout = stdout.substring(tdiePos);\n            }\n            let lines = stdout.split('\\n');\n            lines.forEach(line => {\n              const parts = line.split('___');\n              const label = parts[0];\n              const value = parts.length > 1 && parts[1] ? parts[1] : '0';\n              if (value && (label === undefined || (label && label.toLowerCase().startsWith('core')))) {\n                result.cores.push(Math.round(parseInt(value, 10) / 100) / 10);\n              } else if (value && label && result.main === null && (label.toLowerCase().indexOf('package') >= 0 || label.toLowerCase().indexOf('physical') >= 0)) {\n                result.main = Math.round(parseInt(value, 10) / 100) / 10;\n              }\n            });\n\n            if (result.cores.length > 0) {\n              if (result.main === null) {\n                result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n              }\n              let maxtmp = Math.max.apply(Math, result.cores);\n              result.max = (maxtmp > result.main) ? maxtmp : result.main;\n            }\n            if (result.main !== null) {\n              if (result.max === null) {\n                result.max = result.main;\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n              return;\n            }\n            exec('sensors', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                let tdieTemp = null;\n                let newSectionStarts = true;\n                let section = '';\n                lines.forEach(function (line) {\n                  // determine section\n                  if (line.trim() === '') {\n                    newSectionStarts = true;\n                  } else if (newSectionStarts) {\n                    if (line.trim().toLowerCase().startsWith('acpi')) { section = 'acpi'; }\n                    if (line.trim().toLowerCase().startsWith('pch')) { section = 'pch'; }\n                    if (line.trim().toLowerCase().startsWith('core')) { section = 'core'; }\n                    newSectionStarts = false;\n                  }\n                  let regex = /[+-]([^°]*)/g;\n                  let temps = line.match(regex);\n                  let firstPart = line.split(':')[0].toUpperCase();\n                  if (section === 'acpi') {\n                    // socket temp\n                    if (firstPart.indexOf('TEMP') !== -1) {\n                      result.socket.push(parseFloat(temps));\n                    }\n                  } else if (section === 'pch') {\n                    // chipset temp\n                    if (firstPart.indexOf('TEMP') !== -1 && !result.chipset) {\n                      result.chipset = parseFloat(temps);\n                    }\n                  }\n                  // cpu temp\n                  if (firstPart.indexOf('PHYSICAL') !== -1 || firstPart.indexOf('PACKAGE') !== -1) {\n                    result.main = parseFloat(temps);\n                  }\n                  if (firstPart.indexOf('CORE ') !== -1) {\n                    result.cores.push(parseFloat(temps));\n                  }\n                  if (firstPart.indexOf('TDIE') !== -1 && tdieTemp === null) {\n                    tdieTemp = parseFloat(temps);\n                  }\n                });\n                if (result.cores.length > 0) {\n                  result.main = Math.round(result.cores.reduce((a, b) => a + b, 0) / result.cores.length);\n                  let maxtmp = Math.max.apply(Math, result.cores);\n                  result.max = (maxtmp > result.main) ? maxtmp : result.main;\n                } else {\n                  if (result.main === null && tdieTemp !== null) {\n                    result.main = tdieTemp;\n                    result.max = tdieTemp;\n                  }\n                }\n                if (result.main !== null || result.max !== null) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                  return;\n                }\n              }\n              fs.stat('/sys/class/thermal/thermal_zone0/temp', function (err) {\n                if (err === null) {\n                  fs.readFile('/sys/class/thermal/thermal_zone0/temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0) {\n                        result.main = parseFloat(lines[0]) / 1000.0;\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  exec('/opt/vc/bin/vcgencmd measure_temp', function (error, stdout) {\n                    if (!error) {\n                      let lines = stdout.toString().split('\\n');\n                      if (lines.length > 0 && lines[0].indexOf('=')) {\n                        result.main = parseFloat(lines[0].split('=')[1]);\n                        result.max = result.main;\n                      }\n                    }\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              });\n            });\n          });\n        } catch (er) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl dev.cpu | grep temp', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            let sum = 0;\n            lines.forEach(function (line) {\n              const parts = line.split(':');\n              if (parts.length > 1) {\n                const temp = parseFloat(parts[1].replace(',', '.'));\n                if (temp > result.max) { result.max = temp; }\n                sum = sum + temp;\n                result.cores.push(temp);\n              }\n            });\n            if (result.cores.length) {\n              result.main = Math.round(sum / result.cores.length * 100) / 100;\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        /*\n        let osxTemp = null;\n        try {\n          //osxTemp = require('osx-temperature-sensor');\n        } catch (er) {\n          osxTemp = null;\n        }\n        if (osxTemp) {\n          //result = osxTemp.cpuTemperature();\n          // round to 2 digits\n          if (result.main) {\n            result.main = Math.round(result.main * 100) / 100;\n          }\n          if (result.max) {\n            result.max = Math.round(result.max * 100) / 100;\n          }\n          if (result.cores && result.cores.length) {\n            for (let i = 0; i < result.cores.length; i++) {\n              result.cores[i] = Math.round(result.cores[i] * 100) / 100;\n            }\n          }\n        }\n\n        if (callback) { callback(result); }\n        resolve(result);\n        */\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace \"root/wmi\" | Select CurrentTemperature').then((stdout, error) => {\n            if (!error) {\n              let sum = 0;\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                let value = (parseInt(line, 10) - 2732) / 10;\n                if (!isNaN(value)) {\n                  sum = sum + value;\n                  if (value > result.max) { result.max = value; }\n                  result.cores.push(value);\n                }\n              });\n              if (result.cores.length) {\n                result.main = sum / result.cores.length;\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuTemperature = cpuTemperature;\n\n// --------------------------\n// CPU Flags\n\nfunction cpuFlags(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_windows) {\n        try {\n          exec('reg query \"HKEY_LOCAL_MACHINE\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0\" /v FeatureSet', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let flag_hex = stdout.split('0x').pop().trim();\n              let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);\n              let flag_bin = '0'.repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;\n              // empty flags are the reserved fields in the CPUID feature bit list\n              // as found on wikipedia:\n              // https://en.wikipedia.org/wiki/CPUID\n              let all_flags = [\n                'fpu', 'vme', 'de', 'pse', 'tsc', 'msr', 'pae', 'mce', 'cx8', 'apic',\n                '', 'sep', 'mtrr', 'pge', 'mca', 'cmov', 'pat', 'pse-36', 'psn', 'clfsh',\n                '', 'ds', 'acpi', 'mmx', 'fxsr', 'sse', 'sse2', 'ss', 'htt', 'tm', 'ia64', 'pbe'\n              ];\n              for (let f = 0; f < all_flags.length; f++) {\n                if (flag_bin[f] === '1' && all_flags[f] !== '') {\n                  result += ' ' + all_flags[f];\n                }\n              }\n              result = result.trim().toLowerCase();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        try {\n\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                if (line.split(':')[0].toUpperCase().indexOf('FLAGS') !== -1) {\n                  result = line.split(':')[1].trim().toLowerCase();\n                }\n              });\n            }\n            if (!result) {\n              fs.readFile('/proc/cpuinfo', function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  result = util.getValue(lines, 'features', ':', true).toLowerCase();\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let flags = [];\n          if (!error) {\n            let parts = stdout.toString().split('\\tFlags:');\n            const lines = parts.length > 1 ? parts[1].split('\\tVersion:')[0].split('\\n') : [];\n            lines.forEach(function (line) {\n              let flag = (line.indexOf('(') ? line.split('(')[0].toLowerCase() : '').trim().replace(/\\t/g, '');\n              if (flag) {\n                flags.push(flag);\n              }\n            });\n          }\n          result = flags.join(' ').trim().toLowerCase();\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl machdep.cpu.features', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0 && lines[0].indexOf('machdep.cpu.features:') !== -1) {\n              result = lines[0].split(':')[1].trim().toLowerCase();\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.cpuFlags = cpuFlags;\n\n// --------------------------\n// CPU Cache\n\nfunction cpuCache(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        l1d: null,\n        l1i: null,\n        l2: null,\n        l3: null,\n      };\n      if (_linux) {\n        try {\n          exec('export LC_ALL=C; lscpu; unset LC_ALL', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                let parts = line.split(':');\n                if (parts[0].toUpperCase().indexOf('L1D CACHE') !== -1) {\n                  result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L1I CACHE') !== -1) {\n                  result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L2 CACHE') !== -1) {\n                  result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n                if (parts[0].toUpperCase().indexOf('L3 CACHE') !== -1) {\n                  result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('M') !== -1 ? 1024 * 1024 : (parts[1].indexOf('K') !== -1 ? 1024 : 1));\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let cache = [];\n          if (!error) {\n            const data = stdout.toString();\n            cache = data.split('Cache Information');\n            cache.shift();\n          }\n          for (let i = 0; i < cache.length; i++) {\n            const lines = cache[i].split('\\n');\n            let cacheType = util.getValue(lines, 'Socket Designation').toLowerCase().replace(' ', '-').split('-');\n            cacheType = cacheType.length ? cacheType[0] : '';\n            const sizeParts = util.getValue(lines, 'Installed Size').split(' ');\n            let size = parseInt(sizeParts[0], 10);\n            const unit = sizeParts.length > 1 ? sizeParts[1] : 'kb';\n            size = size * (unit === 'kb' ? 1024 : (unit === 'mb' ? 1024 * 1024 : (unit === 'gb' ? 1024 * 1024 * 1024 : 1)));\n            if (cacheType) {\n              if (cacheType === 'l1') {\n                result.cache[cacheType + 'd'] = size / 2;\n                result.cache[cacheType + 'i'] = size / 2;\n              } else {\n                result.cache[cacheType] = size;\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            lines.forEach(function (line) {\n              let parts = line.split(':');\n              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') !== -1) {\n                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') !== -1) {\n                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') !== -1) {\n                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') !== -1) {\n                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') !== -1 ? 1024 : 1);\n              }\n            });\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.l1d = 0;\n              result.l1i = 0;\n              result.l2 = util.getValue(lines, 'l2cachesize', ':');\n              result.l3 = util.getValue(lines, 'l3cachesize', ':');\n              if (result.l2) { result.l2 = parseInt(result.l2, 10) * 1024; }\n              if (result.l3) { result.l3 = parseInt(result.l3, 10) * 1024; }\n            }\n            util.powerShell('Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl').then((stdout, error) => {\n              if (!error) {\n                const parts = stdout.split(/\\n\\s*\\n/);\n                parts.forEach(function (part) {\n                  const lines = part.split('\\r\\n');\n                  const cacheType = util.getValue(lines, 'CacheType');\n                  const level = util.getValue(lines, 'Level');\n                  const installedSize = util.getValue(lines, 'InstalledSize');\n                  // L1 Instructions\n                  if (level === '3' && cacheType === '3') {\n                    result.l1i = parseInt(installedSize, 10);\n                  }\n                  // L1 Data\n                  if (level === '3' && cacheType === '4') {\n                    result.l1d = parseInt(installedSize, 10);\n                  }\n                  // L1 all\n                  if (level === '3' && cacheType === '5' && !result.l1i && !result.l1d) {\n                    result.l1i = parseInt(installedSize, 10) / 2;\n                    result.l1d = parseInt(installedSize, 10) / 2;\n                  }\n                });\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.cpuCache = cpuCache;\n\n// --------------------------\n// CPU - current load - in %\n\nfunction getLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let loads = os.loadavg().map(function (x) { return x / util.cores(); });\n      let avgLoad = parseFloat((Math.max.apply(Math, loads)).toFixed(2));\n      let result = {};\n\n      let now = Date.now() - _current_cpu.ms;\n      if (now >= 200) {\n        _current_cpu.ms = Date.now();\n        const cpus = os.cpus();\n        let totalUser = 0;\n        let totalSystem = 0;\n        let totalNice = 0;\n        let totalIrq = 0;\n        let totalIdle = 0;\n        let cores = [];\n        _corecount = (cpus && cpus.length) ? cpus.length : 0;\n\n        for (let i = 0; i < _corecount; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIdle += cpu.idle;\n          totalIrq += cpu.irq;\n          let tmpTick = (_cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0);\n          let tmpLoad = (_cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0);\n          let tmpUser = (_cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0);\n          let tmpSystem = (_cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0);\n          let tmpNice = (_cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0);\n          let tmpIdle = (_cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0);\n          let tmpIrq = (_cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0);\n          _cpus[i] = cpu;\n          _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].idle;\n          _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq;\n          _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;\n          _cpus[i].load = (_cpus[i].totalLoad - tmpLoad);\n          _cpus[i].loadUser = (_cpus[i].user - tmpUser);\n          _cpus[i].loadSystem = (_cpus[i].sys - tmpSystem);\n          _cpus[i].loadNice = (_cpus[i].nice - tmpNice);\n          _cpus[i].loadIdle = (_cpus[i].idle - tmpIdle);\n          _cpus[i].loadIrq = (_cpus[i].irq - tmpIrq);\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalIdle;\n        let totalLoad = totalUser + totalSystem + totalNice + totalIrq;\n        let currentTick = totalTick - _current_cpu.tick;\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,\n          currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,\n          currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,\n          currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,\n          currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,\n          currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,\n          rawCurrentLoad: (totalLoad - _current_cpu.load),\n          rawCurrentLoadUser: (totalUser - _current_cpu.user),\n          rawCurrentLoadSystem: (totalSystem - _current_cpu.system),\n          rawCurrentLoadNice: (totalNice - _current_cpu.nice),\n          rawCurrentLoadIdle: (totalIdle - _current_cpu.idle),\n          rawCurrentLoadIrq: (totalIrq - _current_cpu.irq),\n          cpus: cores\n        };\n        _current_cpu = {\n          user: totalUser,\n          nice: totalNice,\n          system: totalSystem,\n          idle: totalIdle,\n          irq: totalIrq,\n          tick: totalTick,\n          load: totalLoad,\n          ms: _current_cpu.ms,\n          currentLoad: result.currentLoad,\n          currentLoadUser: result.currentLoadUser,\n          currentLoadSystem: result.currentLoadSystem,\n          currentLoadNice: result.currentLoadNice,\n          currentLoadIdle: result.currentLoadIdle,\n          currentLoadIrq: result.currentLoadIrq,\n          rawCurrentLoad: result.rawCurrentLoad,\n          rawCurrentLoadUser: result.rawCurrentLoadUser,\n          rawCurrentLoadSystem: result.rawCurrentLoadSystem,\n          rawCurrentLoadNice: result.rawCurrentLoadNice,\n          rawCurrentLoadIdle: result.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: result.rawCurrentLoadIrq,\n        };\n      } else {\n        let cores = [];\n        for (let i = 0; i < _corecount; i++) {\n          cores[i] = {};\n          cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;\n          cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;\n          cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;\n          cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;\n          cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;\n          cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;\n          cores[i].rawLoad = _cpus[i].load;\n          cores[i].rawLoadUser = _cpus[i].loadUser;\n          cores[i].rawLoadSystem = _cpus[i].loadSystem;\n          cores[i].rawLoadNice = _cpus[i].loadNice;\n          cores[i].rawLoadIdle = _cpus[i].loadIdle;\n          cores[i].rawLoadIrq = _cpus[i].loadIrq;\n        }\n        result = {\n          avgLoad: avgLoad,\n          currentLoad: _current_cpu.currentLoad,\n          currentLoadUser: _current_cpu.currentLoadUser,\n          currentLoadSystem: _current_cpu.currentLoadSystem,\n          currentLoadNice: _current_cpu.currentLoadNice,\n          currentLoadIdle: _current_cpu.currentLoadIdle,\n          currentLoadIrq: _current_cpu.currentLoadIrq,\n          rawCurrentLoad: _current_cpu.rawCurrentLoad,\n          rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,\n          rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,\n          rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,\n          rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,\n          rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,\n          cpus: cores\n        };\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction currentLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.currentLoad = currentLoad;\n\n// --------------------------\n// PS - full load\n// since bootup\n\nfunction getFullLoad() {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const cpus = os.cpus();\n      let totalUser = 0;\n      let totalSystem = 0;\n      let totalNice = 0;\n      let totalIrq = 0;\n      let totalIdle = 0;\n\n      let result = 0;\n\n      if (cpus && cpus.length) {\n        for (let i = 0, len = cpus.length; i < len; i++) {\n          const cpu = cpus[i].times;\n          totalUser += cpu.user;\n          totalSystem += cpu.sys;\n          totalNice += cpu.nice;\n          totalIrq += cpu.irq;\n          totalIdle += cpu.idle;\n        }\n        let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;\n        result = (totalTicks - totalIdle) / totalTicks * 100.0;\n\n      }\n      resolve(result);\n    });\n  });\n}\n\nfunction fullLoad(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      getFullLoad().then(result => {\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.fullLoad = fullLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// docker.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. Docker\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst DockerSocket = require('./dockerSocket');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\n\nlet _docker_container_stats = {};\nlet _docker_socket;\nlet _docker_last_read = 0;\n\n\n// --------------------------\n// get containers (parameter all: get also inactive/exited containers)\n\nfunction dockerInfo(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const result = {};\n\n      _docker_socket.getInfo((data) => {\n        result.id = data.ID;\n        result.containers = data.Containers;\n        result.containersRunning = data.ContainersRunning;\n        result.containersPaused = data.ContainersPaused;\n        result.containersStopped = data.ContainersStopped;\n        result.images = data.Images;\n        result.driver = data.Driver;\n        result.memoryLimit = data.MemoryLimit;\n        result.swapLimit = data.SwapLimit;\n        result.kernelMemory = data.KernelMemory;\n        result.cpuCfsPeriod = data.CpuCfsPeriod;\n        result.cpuCfsQuota = data.CpuCfsQuota;\n        result.cpuShares = data.CPUShares;\n        result.cpuSet = data.CPUSet;\n        result.ipv4Forwarding = data.IPv4Forwarding;\n        result.bridgeNfIptables = data.BridgeNfIptables;\n        result.bridgeNfIp6tables = data.BridgeNfIp6tables;\n        result.debug = data.Debug;\n        result.nfd = data.NFd;\n        result.oomKillDisable = data.OomKillDisable;\n        result.ngoroutines = data.NGoroutines;\n        result.systemTime = data.SystemTime;\n        result.loggingDriver = data.LoggingDriver;\n        result.cgroupDriver = data.CgroupDriver;\n        result.nEventsListener = data.NEventsListener;\n        result.kernelVersion = data.KernelVersion;\n        result.operatingSystem = data.OperatingSystem;\n        result.osType = data.OSType;\n        result.architecture = data.Architecture;\n        result.ncpu = data.NCPU;\n        result.memTotal = data.MemTotal;\n        result.dockerRootDir = data.DockerRootDir;\n        result.httpProxy = data.HttpProxy;\n        result.httpsProxy = data.HttpsProxy;\n        result.noProxy = data.NoProxy;\n        result.name = data.Name;\n        result.labels = data.Labels;\n        result.experimentalBuild = data.ExperimentalBuild;\n        result.serverVersion = data.ServerVersion;\n        result.clusterStore = data.ClusterStore;\n        result.clusterAdvertise = data.ClusterAdvertise;\n        result.defaultRuntime = data.DefaultRuntime;\n        result.liveRestoreEnabled = data.LiveRestoreEnabled;\n        result.isolation = data.Isolation;\n        result.initBinary = data.InitBinary;\n        result.productLicense = data.ProductLicense;\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nexports.dockerInfo = dockerInfo;\n\nfunction dockerImages(all, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listImages(all, data => {\n        let dockerImages = {};\n        try {\n          dockerImages = data;\n          if (dockerImages && Object.prototype.toString.call(dockerImages) === '[object Array]' && dockerImages.length > 0) {\n\n            dockerImages.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerImagesInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerImagesInspect(imageID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      imageID = imageID || '';\n      if (typeof imageID !== 'string') {\n        return resolve();\n      }\n      const imageIDSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(imageID, true)).trim();\n      if (imageIDSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.inspectImage(imageIDSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              container: data.Container,\n              comment: data.Comment,\n              os: data.Os,\n              architecture: data.Architecture,\n              parent: data.Parent,\n              dockerVersion: data.DockerVersion,\n              size: data.Size,\n              sharedSize: payload.SharedSize,\n              virtualSize: data.VirtualSize,\n              author: data.Author,\n              created: data.Created ? Math.round(new Date(data.Created).getTime() / 1000) : 0,\n              containerConfig: data.ContainerConfig ? data.ContainerConfig : {},\n              graphDriver: data.GraphDriver ? data.GraphDriver : {},\n              repoDigests: data.RepoDigests ? data.RepoDigests : {},\n              repoTags: data.RepoTags ? data.RepoTags : {},\n              config: data.Config ? data.Config : {},\n              rootFS: data.RootFS ? data.RootFS : {},\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerImages = dockerImages;\n\nfunction dockerContainers(all, callback) {\n\n  function inContainers(containers, id) {\n    let filtered = containers.filter(obj => {\n      /**\n       * @namespace\n       * @property {string}  Id\n       */\n      return (obj.Id && (obj.Id === id));\n    });\n    return (filtered.length > 0);\n  }\n\n  // fallback - if only callback is given\n  if (util.isFunction(all) && !callback) {\n    callback = all;\n    all = false;\n  }\n  if (typeof all === 'string' && all === 'true') {\n    all = true;\n  }\n  if (typeof all !== 'boolean' && all !== undefined) {\n    all = false;\n  }\n\n  all = all || false;\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      const workload = [];\n\n      _docker_socket.listContainers(all, data => {\n        let docker_containers = {};\n        try {\n          docker_containers = data;\n          if (docker_containers && Object.prototype.toString.call(docker_containers) === '[object Array]' && docker_containers.length > 0) {\n            // GC in _docker_container_stats\n            for (let key in _docker_container_stats) {\n              if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n                if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n              }\n            }\n\n            docker_containers.forEach(function (element) {\n\n              if (element.Names && Object.prototype.toString.call(element.Names) === '[object Array]' && element.Names.length > 0) {\n                element.Name = element.Names[0].replace(/^\\/|\\/$/g, '');\n              }\n              workload.push(dockerContainerInspect(element.Id.trim(), element));\n            });\n            if (workload.length) {\n              Promise.all(\n                workload\n              ).then((data) => {\n                if (callback) { callback(data); }\n                resolve(data);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          // GC in _docker_container_stats\n          for (let key in _docker_container_stats) {\n            if ({}.hasOwnProperty.call(_docker_container_stats, key)) {\n              if (!inContainers(docker_containers, key)) { delete _docker_container_stats[key]; }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\n// --------------------------\n// container inspect (for one container)\n\nfunction dockerContainerInspect(containerID, payload) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve();\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerIdSanitized.trim(), data => {\n          try {\n            resolve({\n              id: payload.Id,\n              name: payload.Name,\n              image: payload.Image,\n              imageID: payload.ImageID,\n              command: payload.Command,\n              created: payload.Created,\n              started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1000) : 0,\n              finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? Math.round(new Date(data.State.FinishedAt).getTime() / 1000) : 0,\n              createdAt: data.Created ? data.Created : '',\n              startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : '',\n              finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith('0001-01-01') ? data.State.FinishedAt : '',\n              state: payload.State,\n              restartCount: data.RestartCount || 0,\n              platform: data.Platform || '',\n              driver: data.Driver || '',\n              ports: payload.Ports,\n              mounts: payload.Mounts,\n              // hostconfig: payload.HostConfig,\n              // network: payload.NetworkSettings\n            });\n          } catch (err) {\n            resolve();\n          }\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexports.dockerContainers = dockerContainers;\n\n// --------------------------\n// helper functions for calculation of docker stats\n\nfunction docker_calcCPUPercent(cpu_stats, precpu_stats) {\n  /**\n   * @namespace\n   * @property {object}  cpu_usage\n   * @property {number}  cpu_usage.total_usage\n   * @property {number}  system_cpu_usage\n   * @property {object}  cpu_usage\n   * @property {Array}  cpu_usage.percpu_usage\n   */\n\n  if (!_windows) {\n    let cpuPercent = 0.0;\n    // calculate the change for the cpu usage of the container in between readings\n    let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n    // calculate the change for the entire system between readings\n    let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;\n\n    if (systemDelta > 0.0 && cpuDelta > 0.0) {\n      // calculate the change for the cpu usage of the container in between readings\n      if (precpu_stats.online_cpus) {\n        cpuPercent = (cpuDelta / systemDelta) * precpu_stats.online_cpus * 100.0;\n      }\n      else {\n        cpuPercent = (cpuDelta / systemDelta) * cpu_stats.cpu_usage.percpu_usage.length * 100.0;\n      }\n    }\n\n    return cpuPercent;\n  } else {\n    let nanoSecNow = util.nanoSeconds();\n    let cpuPercent = 0.0;\n    if (_docker_last_read > 0) {\n      let possIntervals = (nanoSecNow - _docker_last_read); //  / 100 * os.cpus().length;\n      let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;\n      if (possIntervals > 0) {\n        cpuPercent = 100.0 * intervalsUsed / possIntervals;\n      }\n    }\n    _docker_last_read = nanoSecNow;\n    return cpuPercent;\n  }\n}\n\nfunction docker_calcNetworkIO(networks) {\n  let rx;\n  let wx;\n  for (let key in networks) {\n    // skip loop if the property is from prototype\n    if (!{}.hasOwnProperty.call(networks, key)) { continue; }\n\n    /**\n     * @namespace\n     * @property {number}  rx_bytes\n     * @property {number}  tx_bytes\n     */\n    let obj = networks[key];\n    rx = +obj.rx_bytes;\n    wx = +obj.tx_bytes;\n  }\n  return {\n    rx,\n    wx\n  };\n}\n\nfunction docker_calcBlockIO(blkio_stats) {\n  let result = {\n    r: 0,\n    w: 0\n  };\n\n  /**\n   * @namespace\n   * @property {Array}  io_service_bytes_recursive\n   */\n  if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === '[object Array]' && blkio_stats.io_service_bytes_recursive.length > 0) {\n    blkio_stats.io_service_bytes_recursive.forEach(function (element) {\n      /**\n       * @namespace\n       * @property {string}  op\n       * @property {number}  value\n       */\n\n      if (element.op && element.op.toLowerCase() === 'read' && element.value) {\n        result.r += element.value;\n      }\n      if (element.op && element.op.toLowerCase() === 'write' && element.value) {\n        result.w += element.value;\n      }\n    });\n  }\n  return result;\n}\n\nfunction dockerContainerStats(containerIDs, callback) {\n\n  let containerArray = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(containerIDs) && !callback) {\n        callback = containerIDs;\n        containerArray = ['*'];\n      } else {\n        containerIDs = containerIDs || '*';\n        if (typeof containerIDs !== 'string') {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        let containerIDsSanitized = '';\n        containerIDsSanitized.__proto__.toLowerCase = util.stringToLower;\n        containerIDsSanitized.__proto__.replace = util.stringReplace;\n        containerIDsSanitized.__proto__.trim = util.stringTrim;\n\n        containerIDsSanitized = containerIDs;\n        containerIDsSanitized = containerIDsSanitized.trim();\n        if (containerIDsSanitized !== '*') {\n          containerIDsSanitized = '';\n          const s = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerIDs, true)).trim();\n          for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n            if (s[i] !== undefined) {\n              s[i].__proto__.toLowerCase = util.stringToLower;\n              const sl = s[i].toLowerCase();\n              if (sl && sl[0] && !sl[1]) {\n                containerIDsSanitized = containerIDsSanitized + sl[0];\n              }\n            }\n          }\n        }\n\n        containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, '|');\n        containerArray = containerIDsSanitized.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (containerArray.length && containerArray[0].trim() === '*') {\n        containerArray = [];\n        dockerContainers().then(allContainers => {\n          for (let container of allContainers) {\n            containerArray.push(container.id);\n          }\n          if (containerArray.length) {\n            dockerContainerStats(containerArray.join(',')).then(result => {\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      } else {\n        for (let containerID of containerArray) {\n          workload.push(dockerContainerStatsSingle(containerID.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\n// --------------------------\n// container stats (for one container)\n\nfunction dockerContainerStatsSingle(containerID) {\n  containerID = containerID || '';\n  let result = {\n    id: containerID,\n    memUsage: 0,\n    memLimit: 0,\n    memPercent: 0,\n    cpuPercent: 0,\n    pids: 0,\n    netIO: {\n      rx: 0,\n      wx: 0\n    },\n    blockIO: {\n      r: 0,\n      w: 0\n    },\n    restartCount: 0,\n    cpuStats: {},\n    precpuStats: {},\n    memoryStats: {},\n    networks: {},\n  };\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (containerID) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getInspect(containerID, dataInspect => {\n          try {\n            _docker_socket.getStats(containerID, data => {\n              try {\n                let stats = data;\n\n                if (!stats.message) {\n                  result.memUsage = (stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0);\n                  result.memLimit = (stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0);\n                  result.memPercent = (stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100.0 : 0);\n                  result.cpuPercent = (stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0);\n                  result.pids = (stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0);\n                  result.restartCount = (dataInspect.RestartCount ? dataInspect.RestartCount : 0);\n                  if (stats.networks) { result.netIO = docker_calcNetworkIO(stats.networks); }\n                  if (stats.blkio_stats) { result.blockIO = docker_calcBlockIO(stats.blkio_stats); }\n                  result.cpuStats = (stats.cpu_stats ? stats.cpu_stats : {});\n                  result.precpuStats = (stats.precpu_stats ? stats.precpu_stats : {});\n                  result.memoryStats = (stats.memory_stats ? stats.memory_stats : {});\n                  result.networks = (stats.networks ? stats.networks : {});\n                }\n              } catch (err) {\n                util.noop();\n              }\n              // }\n              resolve(result);\n            });\n          } catch (err) {\n            util.noop();\n          }\n        });\n      } else {\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerStats = dockerContainerStats;\n\n// --------------------------\n// container processes (for one container)\n\nfunction dockerContainerProcesses(containerID, callback) {\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      containerID = containerID || '';\n      if (typeof containerID !== 'string') {\n        return resolve(result);\n      }\n      const containerIdSanitized = (util.isPrototypePolluted() ? '' : util.sanitizeShellString(containerID, true)).trim();\n\n      if (containerIdSanitized) {\n\n        if (!_docker_socket) {\n          _docker_socket = new DockerSocket();\n        }\n\n        _docker_socket.getProcesses(containerIdSanitized, data => {\n          /**\n           * @namespace\n           * @property {Array}  Titles\n           * @property {Array}  Processes\n           **/\n          try {\n            if (data && data.Titles && data.Processes) {\n              let titles = data.Titles.map(function (value) {\n                return value.toUpperCase();\n              });\n              let pos_pid = titles.indexOf('PID');\n              let pos_ppid = titles.indexOf('PPID');\n              let pos_pgid = titles.indexOf('PGID');\n              let pos_vsz = titles.indexOf('VSZ');\n              let pos_time = titles.indexOf('TIME');\n              let pos_elapsed = titles.indexOf('ELAPSED');\n              let pos_ni = titles.indexOf('NI');\n              let pos_ruser = titles.indexOf('RUSER');\n              let pos_user = titles.indexOf('USER');\n              let pos_rgroup = titles.indexOf('RGROUP');\n              let pos_group = titles.indexOf('GROUP');\n              let pos_stat = titles.indexOf('STAT');\n              let pos_rss = titles.indexOf('RSS');\n              let pos_command = titles.indexOf('COMMAND');\n\n              data.Processes.forEach(process => {\n                result.push({\n                  pidHost: (pos_pid >= 0 ? process[pos_pid] : ''),\n                  ppid: (pos_ppid >= 0 ? process[pos_ppid] : ''),\n                  pgid: (pos_pgid >= 0 ? process[pos_pgid] : ''),\n                  user: (pos_user >= 0 ? process[pos_user] : ''),\n                  ruser: (pos_ruser >= 0 ? process[pos_ruser] : ''),\n                  group: (pos_group >= 0 ? process[pos_group] : ''),\n                  rgroup: (pos_rgroup >= 0 ? process[pos_rgroup] : ''),\n                  stat: (pos_stat >= 0 ? process[pos_stat] : ''),\n                  time: (pos_time >= 0 ? process[pos_time] : ''),\n                  elapsed: (pos_elapsed >= 0 ? process[pos_elapsed] : ''),\n                  nice: (pos_ni >= 0 ? process[pos_ni] : ''),\n                  rss: (pos_rss >= 0 ? process[pos_rss] : ''),\n                  vsz: (pos_vsz >= 0 ? process[pos_vsz] : ''),\n                  command: (pos_command >= 0 ? process[pos_command] : '')\n                });\n              });\n            }\n          } catch (err) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } else {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.dockerContainerProcesses = dockerContainerProcesses;\n\nfunction dockerVolumes(callback) {\n\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (!_docker_socket) {\n        _docker_socket = new DockerSocket();\n      }\n      _docker_socket.listVolumes((data) => {\n        let dockerVolumes = {};\n        try {\n          dockerVolumes = data;\n          if (dockerVolumes && dockerVolumes.Volumes && Object.prototype.toString.call(dockerVolumes.Volumes) === '[object Array]' && dockerVolumes.Volumes.length > 0) {\n\n            dockerVolumes.Volumes.forEach(function (element) {\n\n              result.push({\n                name: element.Name,\n                driver: element.Driver,\n                labels: element.Labels,\n                mountpoint: element.Mountpoint,\n                options: element.Options,\n                scope: element.Scope,\n                created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1000) : 0,\n              });\n            });\n            if (callback) { callback(result); }\n            resolve(result);\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } catch (err) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerVolumes = dockerVolumes;\n\nfunction dockerAll(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      dockerContainers(true).then(result => {\n        if (result && Object.prototype.toString.call(result) === '[object Array]' && result.length > 0) {\n          let l = result.length;\n          result.forEach(function (element) {\n            dockerContainerStats(element.id).then((res) => {\n              // include stats in array\n              element.memUsage = res[0].memUsage;\n              element.memLimit = res[0].memLimit;\n              element.memPercent = res[0].memPercent;\n              element.cpuPercent = res[0].cpuPercent;\n              element.pids = res[0].pids;\n              element.netIO = res[0].netIO;\n              element.blockIO = res[0].blockIO;\n              element.cpuStats = res[0].cpuStats;\n              element.precpuStats = res[0].precpuStats;\n              element.memoryStats = res[0].memoryStats;\n              element.networks = res[0].networks;\n\n              dockerContainerProcesses(element.id).then(processes => {\n                element.processes = processes;\n\n                l -= 1;\n                if (l === 0) {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n              // all done??\n            });\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      });\n    });\n  });\n}\n\nexports.dockerAll = dockerAll;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// dockerSockets.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 13. DockerSockets\n// ----------------------------------------------------------------------------------\n\nconst net = require('net');\nconst isWin = require('os').type() === 'Windows_NT';\nconst socketPath = isWin ? '//./pipe/docker_engine' : '/var/run/docker.sock';\n\nclass DockerSocket {\n\n  getInfo(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/info HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  listImages(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/images/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  inspectImage(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/images/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listContainers(all, callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/containers/json' + (all ? '?all=1' : '') + ' HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n\n  getStats(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getInspect(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/json?stream=0 HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  getProcesses(id, callback) {\n    id = id || '';\n    if (id) {\n      try {\n        let socket = net.createConnection({ path: socketPath });\n        let alldata = '';\n        let data;\n\n        socket.on('connect', () => {\n          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\\r\\n\\r\\n');\n        });\n\n        socket.on('data', data => {\n          alldata = alldata + data.toString();\n        });\n\n        socket.on('error', () => {\n          socket = false;\n          callback({});\n        });\n\n        socket.on('end', () => {\n          let startbody = alldata.indexOf('\\r\\n\\r\\n');\n          alldata = alldata.substring(startbody + 4);\n          socket = false;\n          try {\n            data = JSON.parse(alldata);\n            callback(data);\n          } catch (err) {\n            callback({});\n          }\n        });\n      } catch (err) {\n        callback({});\n      }\n    } else {\n      callback({});\n    }\n  }\n\n  listVolumes(callback) {\n    try {\n\n      let socket = net.createConnection({ path: socketPath });\n      let alldata = '';\n      let data;\n\n      socket.on('connect', () => {\n        socket.write('GET http:/volumes HTTP/1.0\\r\\n\\r\\n');\n      });\n\n      socket.on('data', data => {\n        alldata = alldata + data.toString();\n      });\n\n      socket.on('error', () => {\n        socket = false;\n        callback({});\n      });\n\n      socket.on('end', () => {\n        let startbody = alldata.indexOf('\\r\\n\\r\\n');\n        alldata = alldata.substring(startbody + 4);\n        socket = false;\n        try {\n          data = JSON.parse(alldata);\n          callback(data);\n        } catch (err) {\n          callback({});\n        }\n      });\n    } catch (err) {\n      callback({});\n    }\n  }\n}\n\nmodule.exports = DockerSocket;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// filesystem.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 8. File System\n// ----------------------------------------------------------------------------------\n\nconst util = require('./util');\nconst fs = require('fs');\n\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromiseSave = util.promisifySave(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _fs_speed = {};\nlet _disk_io = {};\n\n// --------------------------\n// FS - mounted file systems\n\nfunction fsSize(callback) {\n\n  let macOsDisks = [];\n  let osMounts = [];\n\n  function getmacOsFsType(fs) {\n    if (!fs.startsWith('/')) { return 'NFS'; }\n    const parts = fs.split('/');\n    const fsShort = parts[parts.length - 1];\n    const macOsDisksSingle = macOsDisks.filter(item => item.indexOf(fsShort) >= 0);\n    if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf('APFS') >= 0) { return 'APFS'; }\n    return 'HFS';\n  }\n\n  function isLinuxTmpFs(fs) {\n    const linuxTmpFileSystems = ['rootfs', 'unionfs', 'squashfs', 'cramfs', 'initrd', 'initramfs', 'devtmpfs', 'tmpfs', 'udev', 'devfs', 'specfs', 'type', 'appimaged'];\n    let result = false;\n    linuxTmpFileSystems.forEach(linuxFs => {\n      if (fs.toLowerCase().indexOf(linuxFs) >= 0) { result = true; }\n    });\n    return result;\n  }\n\n  function filterLines(stdout) {\n    let lines = stdout.toString().split('\\n');\n    if (stdout.toString().toLowerCase().indexOf('filesystem')) {\n      let removeLines = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i].toLowerCase().startsWith('filesystem')) {\n          removeLines = i;\n        }\n      }\n      for (let i = 0; i < removeLines; i++) {\n        lines.shift();\n      }\n    }\n    return lines;\n  }\n\n  function parseDf(lines) {\n    let data = [];\n    lines.forEach(function (line) {\n      if (line !== '') {\n        line = line.replace(/ +/g, ' ').split(' ');\n        if (line && ((line[0].startsWith('/')) || (line[6] && line[6] === '/') || (line[0].indexOf('/') > 0) || (line[0].indexOf(':') === 1) || !_darwin && !isLinuxTmpFs(line[1]))) {\n          const fs = line[0];\n          const fsType = ((_linux || _freebsd || _openbsd || _netbsd) ? line[1] : getmacOsFsType(line[0]));\n          const size = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[2] : line[1])) * 1024;\n          const used = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[3] : line[2])) * 1024;\n          const available = parseInt(((_linux || _freebsd || _openbsd || _netbsd) ? line[4] : line[3])) * 1024;\n          const use = parseFloat((100.0 * (used / (used + available))).toFixed(2));\n          let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs] || false : null;\n          line.splice(0, (_linux || _freebsd || _openbsd || _netbsd) ? 6 : 5);\n          const mount = line.join(' ');\n          if (!data.find(el => (el.fs === fs && el.type === fsType))) {\n            data.push({\n              fs,\n              type: fsType,\n              size,\n              used,\n              available,\n              use,\n              mount,\n              rw\n            });\n          }\n        }\n      }\n    });\n    return data;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = '';\n        macOsDisks = [];\n        osMounts = {};\n        if (_darwin) {\n          cmd = 'df -kP';\n          try {\n            macOsDisks = execSync('diskutil list').toString().split('\\n').filter(line => {\n              return !line.startsWith('/') && line.indexOf(':') > 0;\n            });\n            execSync('mount').toString().split('\\n').filter(line => {\n              return line.startsWith('/');\n            }).forEach((line) => {\n              osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n            });\n          } catch (e) {\n            util.noop();\n          }\n        }\n        if (_linux) {\n          cmd = 'df -lkPTx squashfs';\n          execSync('cat /proc/mounts 2>/dev/null').toString().split('\\n').filter(line => {\n            return line.startsWith('/');\n          }).forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('rw') >= 0;\n          });\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'df -lkPT';\n          execSync('mount').toString().split('\\n').forEach((line) => {\n            osMounts[line.split(' ')[0]] = line.toLowerCase().indexOf('read-only') === -1;\n          });\n        }\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          let lines = filterLines(stdout);\n          data = parseDf(lines);\n          if (!error || data.length) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('df -kPT', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = filterLines(stdout);\n                data = parseDf(lines);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        try {\n          // util.wmic('logicaldisk get Caption,FileSystem,FreeSpace,Size').then((stdout) => {\n          util.powerShell('Get-CimInstance Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const size = util.toInt(util.getValue(lines, 'size', ':'));\n                const free = util.toInt(util.getValue(lines, 'freespace', ':'));\n                const caption = util.getValue(lines, 'caption', ':');\n                const rwValue = util.getValue(lines, 'access', ':');\n                const rw = rwValue ? (util.toInt(rwValue) !== 1) : null;\n                if (size) {\n                  data.push({\n                    fs: caption,\n                    type: util.getValue(lines, 'filesystem', ':'),\n                    size,\n                    used: size - free,\n                    available: free,\n                    use: parseFloat(((100.0 * (size - free)) / size).toFixed(2)),\n                    mount: caption,\n                    rw\n                  });\n                }\n              });\n            }\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n    });\n  });\n}\n\nexports.fsSize = fsSize;\n\n// --------------------------\n// FS - open files count\n\nfunction fsOpenFiles(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = {\n        max: null,\n        allocated: null,\n        available: null\n      };\n      if (_freebsd || _openbsd || _netbsd || _darwin) {\n        let cmd = 'sysctl -i kern.maxfiles kern.num_files kern.open_files';\n        exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            result.max = parseInt(util.getValue(lines, 'kern.maxfiles', ':'), 10);\n            result.allocated = parseInt(util.getValue(lines, 'kern.num_files', ':'), 10) || parseInt(util.getValue(lines, 'kern.open_files', ':'), 10);\n            result.available = result.max - result.allocated;\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        fs.readFile('/proc/sys/fs/file-nr', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            if (lines[0]) {\n              const parts = lines[0].replace(/\\s+/g, ' ').split(' ');\n              if (parts.length === 3) {\n                result.allocated = parseInt(parts[0], 10);\n                result.available = parseInt(parts[1], 10);\n                result.max = parseInt(parts[2], 10);\n                if (!result.available) { result.available = result.max - result.allocated; }\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            fs.readFile('/proc/sys/fs/file-max', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                if (lines[0]) {\n                  result.max = parseInt(lines[0], 10);\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.fsOpenFiles = fsOpenFiles;\n\n// --------------------------\n// disks\n\nfunction parseBytes(s) {\n  return parseInt(s.substr(s.indexOf(' (') + 2, s.indexOf(' Bytes)') - 10));\n}\n\nfunction parseDevices(lines) {\n  let devices = [];\n  let i = 0;\n  lines.forEach(line => {\n    if (line.length > 0) {\n      if (line[0] === '*') {\n        i++;\n      } else {\n        let parts = line.split(':');\n        if (parts.length > 1) {\n          if (!devices[i]) {\n            devices[i] = {\n              name: '',\n              identifier: '',\n              type: 'disk',\n              fsType: '',\n              mount: '',\n              size: 0,\n              physical: 'HDD',\n              uuid: '',\n              label: '',\n              model: '',\n              serial: '',\n              removable: false,\n              protocol: '',\n              group: '',\n              device: ''\n            };\n          }\n          parts[0] = parts[0].trim().toUpperCase().replace(/ +/g, '');\n          parts[1] = parts[1].trim();\n          if ('DEVICEIDENTIFIER' === parts[0]) { devices[i].identifier = parts[1]; }\n          if ('DEVICENODE' === parts[0]) { devices[i].name = parts[1]; }\n          if ('VOLUMENAME' === parts[0]) {\n            if (parts[1].indexOf('Not applicable') === -1) { devices[i].label = parts[1]; }\n          }\n          if ('PROTOCOL' === parts[0]) { devices[i].protocol = parts[1]; }\n          if ('DISKSIZE' === parts[0]) { devices[i].size = parseBytes(parts[1]); }\n          if ('FILESYSTEMPERSONALITY' === parts[0]) { devices[i].fsType = parts[1]; }\n          if ('MOUNTPOINT' === parts[0]) { devices[i].mount = parts[1]; }\n          if ('VOLUMEUUID' === parts[0]) { devices[i].uuid = parts[1]; }\n          if ('READ-ONLYMEDIA' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'CD/DVD'; }\n          if ('SOLIDSTATE' === parts[0] && parts[1] === 'Yes') { devices[i].physical = 'SSD'; }\n          if ('VIRTUAL' === parts[0]) { devices[i].type = 'virtual'; }\n          if ('REMOVABLEMEDIA' === parts[0]) { devices[i].removable = (parts[1] === 'Removable'); }\n          if ('PARTITIONTYPE' === parts[0]) { devices[i].type = 'part'; }\n          if ('DEVICE/MEDIANAME' === parts[0]) { devices[i].model = parts[1]; }\n        }\n      }\n    }\n  });\n  return devices;\n}\n\nfunction parseBlk(lines) {\n  let data = [];\n\n  lines.filter(line => line !== '').forEach((line) => {\n    try {\n      line = decodeURIComponent(line.replace(/\\\\x/g, '%'));\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n      let disk = JSON.parse(line);\n      data.push({\n        'name': disk.name,\n        'type': disk.type,\n        'fsType': disk.fsType,\n        'mount': disk.mountpoint,\n        'size': parseInt(disk.size),\n        'physical': (disk.type === 'disk' ? (disk.rota === '0' ? 'SSD' : 'HDD') : (disk.type === 'rom' ? 'CD/DVD' : '')),\n        'uuid': disk.uuid,\n        'label': disk.label,\n        'model': (disk.model || '').trim(),\n        'serial': disk.serial,\n        'removable': disk.rm === '1',\n        'protocol': disk.tran,\n        'group': disk.group || '',\n      });\n    } catch (e) {\n      util.noop();\n    }\n  });\n  data = util.unique(data);\n  data = util.sortByKey(data, ['type', 'name']);\n  return data;\n}\n\nfunction decodeMdabmData(lines) {\n  const raid = util.getValue(lines, 'md_level', '=');\n  const label = util.getValue(lines, 'md_name', '='); // <- get label info\n  const uuid = util.getValue(lines, 'md_uuid', '='); // <- get uuid info\n  const members = [];\n  lines.forEach(line => {\n    if (line.toLowerCase().startsWith('md_device_dev') && line.toLowerCase().indexOf('/dev/') > 0) {\n      members.push(line.split('/dev/')[1]);\n    }\n  });\n  return {\n    raid,\n    label,\n    uuid,\n    members\n  };\n}\n\nfunction raidMatchLinux(data) {\n  // for all block devices of type \"raid%\"\n  let result = data;\n  try {\n    data.forEach(element => {\n      if (element.type.startsWith('raid')) {\n        const lines = execSync(`mdadm --export --detail /dev/${element.name}`).toString().split('\\n');\n        const mdData = decodeMdabmData(lines);\n\n        element.label = mdData.label; // <- assign label info\n        element.uuid = mdData.uuid; // <- assign uuid info\n\n        if (mdData.members && mdData.members.length && mdData.raid === element.type) {\n          result = result.map(blockdevice => {\n            if (blockdevice.fsType === 'linux_raid_member' && mdData.members.indexOf(blockdevice.name) >= 0) {\n              blockdevice.group = element.name;\n            }\n            return blockdevice;\n          });\n        }\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesLinux(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push(element.name);\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesLinux(data) {\n  let result = data;\n  try {\n    const devices = getDevicesLinux(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element)) {\n            blockdevice.device = '/dev/' + element;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesMac(data) {\n  const result = [];\n  data.forEach(element => {\n    if (element.type.startsWith('disk')) {\n      result.push({ name: element.name, model: element.model, device: element.name });\n    }\n    if (element.type.startsWith('virtual')) {\n      let device = '';\n      result.forEach(e => {\n        if (e.model === element.model) {\n          device = e.device;\n        }\n      });\n      if (device) {\n        result.push({ name: element.name, model: element.model, device });\n      }\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesMac(data) {\n  let result = data;\n  try {\n    const devices = getDevicesMac(data);\n    result = result.map(blockdevice => {\n      if (blockdevice.type.startsWith('part') || blockdevice.type.startsWith('disk') || blockdevice.type.startsWith('virtual')) {\n        devices.forEach(element => {\n          if (blockdevice.name.startsWith(element.name)) {\n            blockdevice.device = element.device;\n          }\n        });\n      }\n      return blockdevice;\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getDevicesWin(diskDrives) {\n  const result = [];\n  diskDrives.forEach(element => {\n    const lines = element.split('\\r\\n');\n    const device = util.getValue(lines, 'DeviceID', ':');\n    let partitions = element.split('@{DeviceID=');\n    if (partitions.length > 1) {\n      partitions = partitions.slice(1);\n      partitions.forEach(partition => {\n        result.push({ name: partition.split(';')[0].toUpperCase(), device });\n      });\n    }\n  });\n  return result;\n}\n\nfunction matchDevicesWin(data, diskDrives) {\n  const devices = getDevicesWin(diskDrives);\n  data.map(element => {\n    const filteresDevices = devices.filter((e) => { return e.name === element.name.toUpperCase(); });\n    if (filteresDevices.length > 0) {\n      element.device = filteresDevices[0].device;\n    }\n    return element;\n  });\n  return data;\n}\n\nfunction blkStdoutToObject(stdout) {\n  return stdout.toString()\n    .replace(/NAME=/g, '{\"name\":')\n    .replace(/FSTYPE=/g, ',\"fsType\":')\n    .replace(/TYPE=/g, ',\"type\":')\n    .replace(/SIZE=/g, ',\"size\":')\n    .replace(/MOUNTPOINT=/g, ',\"mountpoint\":')\n    .replace(/UUID=/g, ',\"uuid\":')\n    .replace(/ROTA=/g, ',\"rota\":')\n    .replace(/RO=/g, ',\"ro\":')\n    .replace(/RM=/g, ',\"rm\":')\n    .replace(/TRAN=/g, ',\"tran\":')\n    .replace(/SERIAL=/g, ',\"serial\":')\n    .replace(/LABEL=/g, ',\"label\":')\n    .replace(/MODEL=/g, ',\"model\":')\n    .replace(/OWNER=/g, ',\"owner\":')\n    .replace(/GROUP=/g, ',\"group\":')\n    .replace(/\\n/g, '}\\n');\n}\n\nfunction blockDevices(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = [];\n      if (_linux) {\n        // see https://wiki.ubuntuusers.de/lsblk/\n        // exec(\"lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME\", function (error, stdout) {\n        exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = blkStdoutToObject(stdout).split('\\n');\n            data = parseBlk(lines);\n            data = raidMatchLinux(data);\n            data = matchDevicesLinux(data);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          } else {\n            exec('lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              if (!error) {\n                let lines = blkStdoutToObject(stdout).split('\\n');\n                data = parseBlk(lines);\n                data = raidMatchLinux(data);\n              }\n              if (callback) {\n                callback(data);\n              }\n              resolve(data);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        exec('diskutil info -all', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            // parse lines into temp array of devices\n            data = parseDevices(lines);\n            data = matchDevicesMac(data);\n          }\n          if (callback) {\n            callback(data);\n          }\n          resolve(data);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(data); }\n        resolve(data);\n      }\n      if (_windows) {\n        let drivetypes = ['Unknown', 'NoRoot', 'Removable', 'Local', 'Network', 'CD/DVD', 'RAM'];\n        try {\n          // util.wmic('logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber /value').then((stdout, error) => {\n          // util.powerShell('Get-CimInstance Win32_logicaldisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl').then((stdout, error) => {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl'));\n          workload.push(util.powerShell('Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L=\\'Partitions\\'; E={$_.GetRelated(\\'Win32_DiskPartition\\').GetRelated(\\'Win32_LogicalDisk\\') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl'));\n          util.promiseAll(\n            workload\n          ).then((res) => {\n            let logicalDisks = res.results[0].toString().split(/\\n\\s*\\n/);\n            let diskDrives = res.results[1].toString().split(/\\n\\s*\\n/);\n            logicalDisks.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              let drivetype = util.getValue(lines, 'drivetype', ':');\n              if (drivetype) {\n                data.push({\n                  name: util.getValue(lines, 'name', ':'),\n                  identifier: util.getValue(lines, 'caption', ':'),\n                  type: 'disk',\n                  fsType: util.getValue(lines, 'filesystem', ':').toLowerCase(),\n                  mount: util.getValue(lines, 'caption', ':'),\n                  size: util.getValue(lines, 'size', ':'),\n                  physical: (drivetype >= 0 && drivetype <= 6) ? drivetypes[drivetype] : drivetypes[0],\n                  uuid: util.getValue(lines, 'volumeserialnumber', ':'),\n                  label: util.getValue(lines, 'volumename', ':'),\n                  model: '',\n                  serial: util.getValue(lines, 'volumeserialnumber', ':'),\n                  removable: drivetype === '2',\n                  protocol: '',\n                  group: '',\n                  device: ''\n                });\n              }\n            });\n            // match devices\n            data = matchDevicesWin(data, diskDrives);\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          });\n        } catch (e) {\n          if (callback) { callback(data); }\n          resolve(data);\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        // will follow\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n\n    });\n  });\n}\n\nexports.blockDevices = blockDevices;\n\n// --------------------------\n// FS - speed\n\nfunction calcFsSpeed(rx, wx) {\n  let result = {\n    rx: 0,\n    wx: 0,\n    tx: 0,\n    rx_sec: null,\n    wx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_fs_speed && _fs_speed.ms) {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    result.ms = Date.now() - _fs_speed.ms;\n    result.rx_sec = (result.rx - _fs_speed.bytes_read) / (result.ms / 1000);\n    result.wx_sec = (result.wx - _fs_speed.bytes_write) / (result.ms / 1000);\n    result.tx_sec = result.rx_sec + result.wx_sec;\n    _fs_speed.rx_sec = result.rx_sec;\n    _fs_speed.wx_sec = result.wx_sec;\n    _fs_speed.tx_sec = result.tx_sec;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = result.ms;\n  } else {\n    result.rx = rx;\n    result.wx = wx;\n    result.tx = result.rx + result.wx;\n    _fs_speed.rx_sec = null;\n    _fs_speed.wx_sec = null;\n    _fs_speed.tx_sec = null;\n    _fs_speed.bytes_read = result.rx;\n    _fs_speed.bytes_write = result.wx;\n    _fs_speed.bytes_overall = result.rx + result.wx;\n    _fs_speed.ms = Date.now();\n    _fs_speed.last_ms = 0;\n  }\n  return result;\n}\n\nfunction fsStats(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rx: 0,\n        wx: 0,\n        tx: 0,\n        rx_sec: null,\n        wx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let rx = 0;\n      let wx = 0;\n      if ((_fs_speed && !_fs_speed.ms) || (_fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500)) {\n        if (_linux) {\n          // exec(\"df -k | grep /dev/\", function(error, stdout) {\n          exec('lsblk -r 2>/dev/null | grep /', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              let fs_filter = [];\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(' ');\n                  if (fs_filter.indexOf(line[0]) === -1) { fs_filter.push(line[0]); }\n                }\n              });\n\n              let output = fs_filter.join('|');\n              exec('cat /proc/diskstats | egrep \"' + output + '\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.forEach(function (line) {\n                    line = line.trim();\n                    if (line !== '') {\n                      line = line.replace(/ +/g, ' ').split(' ');\n\n                      rx += parseInt(line[5]) * 512;\n                      wx += parseInt(line[9]) * 512;\n                    }\n                  });\n                  result = calcFsSpeed(rx, wx);\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rx += parseInt(line[2]);\n                  wx += parseInt(line[9]);\n                }\n              });\n              result = calcFsSpeed(rx, wx);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.ms = _fs_speed.last_ms;\n        result.rx = _fs_speed.bytes_read;\n        result.wx = _fs_speed.bytes_write;\n        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;\n        result.rx_sec = _fs_speed.rx_sec;\n        result.wx_sec = _fs_speed.wx_sec;\n        result.tx_sec = _fs_speed.tx_sec;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.fsStats = fsStats;\n\nfunction calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {\n  let result = {\n    rIO: 0,\n    wIO: 0,\n    tIO: 0,\n    rIO_sec: null,\n    wIO_sec: null,\n    tIO_sec: null,\n    rWaitTime: 0,\n    wWaitTime: 0,\n    tWaitTime: 0,\n    rWaitPercent: null,\n    wWaitPercent: null,\n    tWaitPercent: null,\n    ms: 0\n  };\n  if (_disk_io && _disk_io.ms) {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.ms = Date.now() - _disk_io.ms;\n    result.rIO_sec = (result.rIO - _disk_io.rIO) / (result.ms / 1000);\n    result.wIO_sec = (result.wIO - _disk_io.wIO) / (result.ms / 1000);\n    result.tIO_sec = result.rIO_sec + result.wIO_sec;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    result.rWaitPercent = (result.rWaitTime - _disk_io.rWaitTime) * 100 / (result.ms);\n    result.wWaitPercent = (result.wWaitTime - _disk_io.wWaitTime) * 100 / (result.ms);\n    result.tWaitPercent = (result.tWaitTime - _disk_io.tWaitTime) * 100 / (result.ms);\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = result.rIO_sec;\n    _disk_io.wIO_sec = result.wIO_sec;\n    _disk_io.tIO_sec = result.tIO_sec;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = result.rWaitPercent;\n    _disk_io.wWaitPercent = result.wWaitPercent;\n    _disk_io.tWaitPercent = result.tWaitPercent;\n    _disk_io.last_ms = result.ms;\n    _disk_io.ms = Date.now();\n  } else {\n    result.rIO = rIO;\n    result.wIO = wIO;\n    result.tIO = rIO + wIO;\n    result.rWaitTime = rWaitTime;\n    result.wWaitTime = wWaitTime;\n    result.tWaitTime = tWaitTime;\n    _disk_io.rIO = rIO;\n    _disk_io.wIO = wIO;\n    _disk_io.rIO_sec = null;\n    _disk_io.wIO_sec = null;\n    _disk_io.tIO_sec = null;\n    _disk_io.rWaitTime = rWaitTime;\n    _disk_io.wWaitTime = wWaitTime;\n    _disk_io.tWaitTime = tWaitTime;\n    _disk_io.rWaitPercent = null;\n    _disk_io.wWaitPercent = null;\n    _disk_io.tWaitPercent = null;\n    _disk_io.last_ms = 0;\n    _disk_io.ms = Date.now();\n  }\n  return result;\n}\n\nfunction disksIO(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        return resolve(null);\n      }\n      if (_sunos) {\n        return resolve(null);\n      }\n\n      let result = {\n        rIO: 0,\n        wIO: 0,\n        tIO: 0,\n        rIO_sec: null,\n        wIO_sec: null,\n        tIO_sec: null,\n        rWaitTime: 0,\n        wWaitTime: 0,\n        tWaitTime: 0,\n        rWaitPercent: null,\n        wWaitPercent: null,\n        tWaitPercent: null,\n        ms: 0\n      };\n      let rIO = 0;\n      let wIO = 0;\n      let rWaitTime = 0;\n      let wWaitTime = 0;\n      let tWaitTime = 0;\n\n      if ((_disk_io && !_disk_io.ms) || (_disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500)) {\n        if (_linux || _freebsd || _openbsd || _netbsd) {\n          // prints Block layer statistics for all mounted volumes\n          // var cmd = \"for mount in `lsblk | grep / | sed -r 's/│ └─//' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          // var cmd = \"for mount in `lsblk | grep / | sed 's/[│└─├]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done\";\n          let cmd = 'for mount in `lsblk 2>/dev/null | grep \" disk \" | sed \"s/[│└─├]//g\" | awk \\'{$1=$1};1\\' | cut -d \" \" -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r \"s/ +/;/g\" | sed -r \"s/^;//\"; done';\n\n          exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.split('\\n');\n              lines.forEach(function (line) {\n                // ignore empty lines\n                if (!line) { return; }\n\n                // sum r/wIO of all disks to compute all disks IO\n                let stats = line.split(';');\n                rIO += parseInt(stats[0]);\n                wIO += parseInt(stats[4]);\n                rWaitTime += parseInt(stats[3]);\n                wWaitTime += parseInt(stats[7]);\n                tWaitTime += parseInt(stats[10]);\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        }\n        if (_darwin) {\n          exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n \"/IOBlockStorageDriver/,/Statistics/p\" | grep \"Statistics\" | tr -cd \"01234567890,\\n\"', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              lines.forEach(function (line) {\n                line = line.trim();\n                if (line !== '') {\n                  line = line.split(',');\n\n                  rIO += parseInt(line[10]);\n                  wIO += parseInt(line[0]);\n                }\n              });\n              result = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        }\n      } else {\n        result.rIO = _disk_io.rIO;\n        result.wIO = _disk_io.wIO;\n        result.tIO = _disk_io.rIO + _disk_io.wIO;\n        result.ms = _disk_io.last_ms;\n        result.rIO_sec = _disk_io.rIO_sec;\n        result.wIO_sec = _disk_io.wIO_sec;\n        result.tIO_sec = _disk_io.tIO_sec;\n        result.rWaitTime = _disk_io.rWaitTime;\n        result.wWaitTime = _disk_io.wWaitTime;\n        result.tWaitTime = _disk_io.tWaitTime;\n        result.rWaitPercent = _disk_io.rWaitPercent;\n        result.wWaitPercent = _disk_io.wWaitPercent;\n        result.tWaitPercent = _disk_io.tWaitPercent;\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.disksIO = disksIO;\n\nfunction diskLayout(callback) {\n\n  function getVendorFromModel(model) {\n    const diskManufacturers = [\n      { pattern: 'WESTERN.*', manufacturer: 'Western Digital' },\n      { pattern: '^WDC.*', manufacturer: 'Western Digital' },\n      { pattern: 'WD.*', manufacturer: 'Western Digital' },\n      { pattern: 'TOSHIBA.*', manufacturer: 'Toshiba' },\n      { pattern: 'HITACHI.*', manufacturer: 'Hitachi' },\n      { pattern: '^IC.*', manufacturer: 'Hitachi' },\n      { pattern: '^HTS.*', manufacturer: 'Hitachi' },\n      { pattern: 'SANDISK.*', manufacturer: 'SanDisk' },\n      { pattern: 'KINGSTON.*', manufacturer: 'Kingston Technology' },\n      { pattern: '^SONY.*', manufacturer: 'Sony' },\n      { pattern: 'TRANSCEND.*', manufacturer: 'Transcend' },\n      { pattern: 'SAMSUNG.*', manufacturer: 'Samsung' },\n      { pattern: '^ST(?!I\\\\ ).*', manufacturer: 'Seagate' },\n      { pattern: '^STI\\\\ .*', manufacturer: 'SimpleTech' },\n      { pattern: '^D...-.*', manufacturer: 'IBM' },\n      { pattern: '^IBM.*', manufacturer: 'IBM' },\n      { pattern: '^FUJITSU.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MP.*', manufacturer: 'Fujitsu' },\n      { pattern: '^MK.*', manufacturer: 'Toshiba' },\n      { pattern: 'MAXTO.*', manufacturer: 'Maxtor' },\n      { pattern: 'PIONEER.*', manufacturer: 'Pioneer' },\n      { pattern: 'PHILIPS.*', manufacturer: 'Philips' },\n      { pattern: 'QUANTUM.*', manufacturer: 'Quantum Technology' },\n      { pattern: 'FIREBALL.*', manufacturer: 'Quantum Technology' },\n      { pattern: '^VBOX.*', manufacturer: 'VirtualBox' },\n      { pattern: 'CORSAIR.*', manufacturer: 'Corsair Components' },\n      { pattern: 'CRUCIAL.*', manufacturer: 'Crucial' },\n      { pattern: 'ECM.*', manufacturer: 'ECM' },\n      { pattern: 'INTEL.*', manufacturer: 'INTEL' },\n      { pattern: 'EVO.*', manufacturer: 'Samsung' },\n      { pattern: 'APPLE.*', manufacturer: 'Apple' },\n    ];\n\n    let result = '';\n    if (model) {\n      model = model.toUpperCase();\n      diskManufacturers.forEach((manufacturer) => {\n        const re = RegExp(manufacturer.pattern);\n        if (re.test(model)) { result = manufacturer.manufacturer; }\n      });\n    }\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const commitResult = res => {\n        for (let i = 0; i < res.length; i++) {\n          delete res[i].BSDName;\n        }\n        if (callback) {\n          callback(res);\n        }\n        resolve(res);\n      };\n\n      let result = [];\n      let cmd = '';\n\n      if (_linux) {\n        let cmdFullSmart = '';\n\n        exec('export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            try {\n              const out = stdout.toString().trim();\n              let devices = [];\n              try {\n                const outJSON = JSON.parse(out);\n                if (outJSON && {}.hasOwnProperty.call(outJSON, 'blockdevices')) {\n                  devices = outJSON.blockdevices.filter(item => { return (item.type === 'disk') && item.size > 0 && (item.model !== null || (item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf('/ram') !== 0 && item.path.indexOf('/loop') !== 0 && item['disc-max'] && item['disc-max'] !== 0)); });\n                }\n              } catch (e) {\n                // fallback to older version of lsblk\n                const out2 = execSync('export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL').toString();\n                let lines = blkStdoutToObject(out2).split('\\n');\n                const data = parseBlk(lines);\n                devices = data.filter(item => { return (item.type === 'disk') && item.size > 0 && ((item.model !== null && item.model !== '') || (item.mount === '' && item.label === '' && item.fsType === '')); });\n              }\n              devices.forEach((device) => {\n                let mediumType = '';\n                const BSDName = '/dev/' + device.name;\n                const logical = device.name;\n                try {\n                  mediumType = execSync('cat /sys/block/' + logical + '/queue/rotational 2>/dev/null').toString().split('\\n')[0];\n                } catch (e) {\n                  util.noop();\n                }\n                let interfaceType = device.tran ? device.tran.toUpperCase().trim() : '';\n                if (interfaceType === 'NVME') {\n                  mediumType = '2';\n                  interfaceType = 'PCIe';\n                }\n                result.push({\n                  device: BSDName,\n                  type: (mediumType === '0' ? 'SSD' : (mediumType === '1' ? 'HD' : (mediumType === '2' ? 'NVMe' : (device.model && device.model.indexOf('SSD') > -1 ? 'SSD' : (device.model && device.model.indexOf('NVM') > -1 ? 'NVMe' : 'HD'))))),\n                  name: device.model || '',\n                  vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ''),\n                  size: device.size || 0,\n                  bytesPerSector: null,\n                  totalCylinders: null,\n                  totalHeads: null,\n                  totalSectors: null,\n                  totalTracks: null,\n                  tracksPerCylinder: null,\n                  sectorsPerTrack: null,\n                  firmwareRevision: device.rev ? device.rev.trim() : '',\n                  serialNum: device.serial ? device.serial.trim() : '',\n                  interfaceType: interfaceType,\n                  smartStatus: 'unknown',\n                  temperature: null,\n                  BSDName: BSDName\n                });\n                cmd += `printf \"\\n${BSDName}|\"; smartctl -H ${BSDName} | grep overall;`;\n                cmdFullSmart += `${cmdFullSmart ? 'printf \",\";' : ''}smartctl -a -j ${BSDName};`;\n              });\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // check S.M.A.R.T. status\n          if (cmdFullSmart) {\n            exec(cmdFullSmart, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n              try {\n                const data = JSON.parse(`[${stdout}]`);\n                data.forEach(disk => {\n                  const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];\n\n                  for (let i = 0; i < result.length; i++) {\n                    if (result[i].BSDName === diskBSDName) {\n                      result[i].smartStatus = (disk.smart_status.passed ? 'Ok' : (disk.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (disk.temperature && disk.temperature.current) {\n                        result[i].temperature = disk.temperature.current;\n                      }\n                      result[i].smartData = disk;\n                    }\n                  }\n                });\n                commitResult(result);\n              } catch (e) {\n                if (cmd) {\n                  cmd = cmd + 'printf \"\\n\"';\n                  exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                    let lines = stdout.toString().split('\\n');\n                    lines.forEach(line => {\n                      if (line) {\n                        let parts = line.split('|');\n                        if (parts.length === 2) {\n                          let BSDName = parts[0];\n                          parts[1] = parts[1].trim();\n                          let parts2 = parts[1].split(':');\n                          if (parts2.length === 2) {\n                            parts2[1] = parts2[1].trim();\n                            let status = parts2[1].toLowerCase();\n                            for (let i = 0; i < result.length; i++) {\n                              if (result[i].BSDName === BSDName) {\n                                result[i].smartStatus = (status === 'passed' ? 'Ok' : (status === 'failed!' ? 'Predicted Failure' : 'unknown'));\n                              }\n                            }\n                          }\n                        }\n                      }\n                    });\n                    commitResult(result);\n                  });\n                } else {\n                  commitResult(result);\n                }\n              }\n            });\n          } else {\n            commitResult(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        exec('system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType', { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n          if (!error) {\n            // split by type:\n            let lines = stdout.toString().split('\\n');\n            let linesSATA = [];\n            let linesNVMe = [];\n            let linesUSB = [];\n            let dataType = 'SATA';\n            lines.forEach(line => {\n              if (line === 'NVMExpress:') { dataType = 'NVMe'; }\n              else if (line === 'USB:') { dataType = 'USB'; }\n              else if (line === 'SATA/SATA Express:') { dataType = 'SATA'; }\n              else if (dataType === 'SATA') { linesSATA.push(line); }\n              else if (dataType === 'NVMe') { linesNVMe.push(line); }\n              else if (dataType === 'USB') { linesUSB.push(line); }\n            });\n            try {\n              // Serial ATA Drives\n              let devices = linesSATA.join('\\n').split(' Physical Interconnect: ');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = 'InterfaceType: ' + device;\n                let lines = device.split('\\n');\n                const mediumType = util.getValue(lines, 'Medium Type', ':', true).trim();\n                const sizeStr = util.getValue(lines, 'capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: mediumType.startsWith('Solid') ? 'SSD' : 'HD',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()) || util.getValue(lines, 'Manufacturer', ':', true),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: util.getValue(lines, 'InterfaceType', ':', true).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n\n            // NVME Drives\n            try {\n              let devices = linesNVMe.join('\\n').split('\\n\\n          Capacity:');\n              devices.shift();\n              devices.forEach(function (device) {\n                device = '!Capacity: ' + device;\n                let lines = device.split('\\n');\n                const linkWidth = util.getValue(lines, 'link width', ':', true).trim();\n                const sizeStr = util.getValue(lines, '!capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'NVMe',\n                      name: util.getValue(lines, 'Model', ':', true).trim(),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: ('PCIe ' + linkWidth).trim(),\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            // USB Drives\n            try {\n              let devices = linesUSB.join('\\n').replaceAll('Media:\\n ', 'Model:').split('\\n\\n          Product ID:');\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\n');\n                const sizeStr = util.getValue(lines, 'Capacity', ':', true).trim();\n                const BSDName = util.getValue(lines, 'BSD Name', ':', true).trim();\n                if (sizeStr) {\n                  let sizeValue = 0;\n                  if (sizeStr.indexOf('(') >= 0) {\n                    sizeValue = parseInt(sizeStr.match(/\\(([^)]+)\\)/)[1].replace(/\\./g, '').replace(/,/g, '').replace(/\\s/g, ''));\n                  }\n                  if (!sizeValue) {\n                    sizeValue = parseInt(sizeStr);\n                  }\n                  if (sizeValue) {\n                    const smartStatusString = util.getValue(lines, 'S.M.A.R.T. status', ':', true).trim().toLowerCase();\n                    result.push({\n                      device: BSDName,\n                      type: 'USB',\n                      name: util.getValue(lines, 'Model', ':', true).trim().replaceAll(':', ''),\n                      vendor: getVendorFromModel(util.getValue(lines, 'Model', ':', true).trim()),\n                      size: sizeValue,\n                      bytesPerSector: null,\n                      totalCylinders: null,\n                      totalHeads: null,\n                      totalSectors: null,\n                      totalTracks: null,\n                      tracksPerCylinder: null,\n                      sectorsPerTrack: null,\n                      firmwareRevision: util.getValue(lines, 'Revision', ':', true).trim(),\n                      serialNum: util.getValue(lines, 'Serial Number', ':', true).trim(),\n                      interfaceType: 'USB',\n                      smartStatus: smartStatusString === 'verified' ? 'OK' : smartStatusString || 'unknown',\n                      temperature: null,\n                      BSDName: BSDName\n                    });\n                    cmd = cmd + 'printf \"\\n' + BSDName + '|\"; diskutil info /dev/' + BSDName + ' | grep SMART;';\n                  }\n                }\n              });\n            } catch (e) {\n              util.noop();\n            }\n            if (cmd) {\n              cmd = cmd + 'printf \"\\n\"';\n              exec(cmd, { maxBuffer: 1024 * 1024 }, function (error, stdout) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(line => {\n                  if (line) {\n                    let parts = line.split('|');\n                    if (parts.length === 2) {\n                      let BSDName = parts[0];\n                      parts[1] = parts[1].trim();\n                      let parts2 = parts[1].split(':');\n                      if (parts2.length === 2) {\n                        parts2[1] = parts2[1].trim();\n                        let status = parts2[1].toLowerCase();\n                        for (let i = 0; i < result.length; i++) {\n                          if (result[i].BSDName === BSDName) {\n                            result[i].smartStatus = (status === 'not supported' ? 'not supported' : (status === 'verified' ? 'Ok' : (status === 'failing' ? 'Predicted Failure' : 'unknown')));\n                          }\n                        }\n                      }\n                    }\n                  }\n                });\n                for (let i = 0; i < result.length; i++) {\n                  delete result[i].BSDName;\n                }\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              for (let i = 0; i < result.length; i++) {\n                delete result[i].BSDName;\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          }\n        });\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl'));\n          workload.push(util.powerShell('Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl'));\n          if (util.smartMonToolsInstalled()) {\n            try {\n              const smartDev = JSON.parse(execSync('smartctl --scan -j'));\n              if (smartDev && smartDev.devices && smartDev.devices.length > 0) {\n                smartDev.devices.forEach((dev) => {\n                  workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util.execOptsWin));\n                });\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let devices = data.results[0].toString().split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const status = util.getValue(lines, 'Status', ':').trim().toLowerCase();\n              if (size) {\n                result.push({\n                  device: util.getValue(lines, 'DeviceId', ':'),  // changed from PNPDeviceId to DeviceID (be be able to match devices)\n                  type: device.indexOf('SSD') > -1 ? 'SSD' : 'HD',  // just a starting point ... better: MSFT_PhysicalDisk - Media Type ... see below\n                  name: util.getValue(lines, 'Caption', ':'),\n                  vendor: getVendorFromModel(util.getValue(lines, 'Caption', ':', true).trim()),\n                  size: parseInt(size),\n                  bytesPerSector: parseInt(util.getValue(lines, 'BytesPerSector', ':')),\n                  totalCylinders: parseInt(util.getValue(lines, 'TotalCylinders', ':')),\n                  totalHeads: parseInt(util.getValue(lines, 'TotalHeads', ':')),\n                  totalSectors: parseInt(util.getValue(lines, 'TotalSectors', ':')),\n                  totalTracks: parseInt(util.getValue(lines, 'TotalTracks', ':')),\n                  tracksPerCylinder: parseInt(util.getValue(lines, 'TracksPerCylinder', ':')),\n                  sectorsPerTrack: parseInt(util.getValue(lines, 'SectorsPerTrack', ':')),\n                  firmwareRevision: util.getValue(lines, 'FirmwareRevision', ':').trim(),\n                  serialNum: util.getValue(lines, 'SerialNumber', ':').trim(),\n                  interfaceType: util.getValue(lines, 'InterfaceType', ':').trim(),\n                  smartStatus: (status === 'ok' ? 'Ok' : (status === 'degraded' ? 'Degraded' : (status === 'pred fail' ? 'Predicted Failure' : 'Unknown'))),\n                  temperature: null,\n                });\n              }\n            });\n            devices = data.results[1].split(/\\n\\s*\\n/);\n            devices.forEach(function (device) {\n              let lines = device.split('\\r\\n');\n              const serialNum = util.getValue(lines, 'SerialNumber', ':').trim();\n              const name = util.getValue(lines, 'FriendlyName', ':').trim().replace('Msft ', 'Microsoft');\n              const size = util.getValue(lines, 'Size', ':').trim();\n              const model = util.getValue(lines, 'Model', ':').trim();\n              const interfaceType = util.getValue(lines, 'BusType', ':').trim();\n              let mediaType = util.getValue(lines, 'MediaType', ':').trim();\n              if (mediaType === '3' || mediaType === 'HDD') { mediaType = 'HD'; }\n              if (mediaType === '4') { mediaType = 'SSD'; }\n              if (mediaType === '5') { mediaType = 'SCM'; }\n              if (mediaType === 'Unspecified' && (model.toLowerCase().indexOf('virtual') > -1 || model.toLowerCase().indexOf('vbox') > -1)) { mediaType = 'Virtual'; }\n              if (size) {\n                let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                if (i === -1 || serialNum === '') {\n                  i = util.findObjectByKey(result, 'name', name);\n                }\n                if (i != -1) {\n                  result[i].type = mediaType;\n                  result[i].interfaceType = interfaceType;\n                }\n              }\n            });\n            // S.M.A.R.T\n            data.results.shift();\n            data.results.shift();\n            if (data.results.length) {\n              data.results.forEach((smartStr) => {\n                try {\n                  const smartData = JSON.parse(smartStr);\n                  if (smartData.serial_number) {\n                    const serialNum = smartData.serial_number;\n                    let i = util.findObjectByKey(result, 'serialNum', serialNum);\n                    if (i != -1) {\n                      result[i].smartStatus = (smartData.smart_status && smartData.smart_status.passed ? 'Ok' : (smartData.smart_status && smartData.smart_status.passed === false ? 'Predicted Failure' : 'unknown'));\n                      if (smartData.temperature && smartData.temperature.current) {\n                        result[i].temperature = smartData.temperature.current;\n                      }\n                      result[i].smartData = smartData;\n                    }\n                  }\n                } catch (e) {\n                  util.noop();\n                }\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.diskLayout = diskLayout;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// graphics.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 7. Graphics (controller, display)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\nlet _nvidiaSmiPath = '';\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _resolutionX = 0;\nlet _resolutionY = 0;\nlet _pixelDepth = 0;\nlet _refreshRate = 0;\n\nconst videoTypes = {\n  '-2': 'UNINITIALIZED',\n  '-1': 'OTHER',\n  '0': 'HD15',\n  '1': 'SVIDEO',\n  '2': 'Composite video',\n  '3': 'Component video',\n  '4': 'DVI',\n  '5': 'HDMI',\n  '6': 'LVDS',\n  '8': 'D_JPN',\n  '9': 'SDI',\n  '10': 'DP',\n  '11': 'DP embedded',\n  '12': 'UDI',\n  '13': 'UDI embedded',\n  '14': 'SDTVDONGLE',\n  '15': 'MIRACAST',\n  '2147483648': 'INTERNAL'\n};\n\nfunction getVendorFromModel(model) {\n  const manufacturers = [\n    { pattern: '^LG.+', manufacturer: 'LG' },\n    { pattern: '^BENQ.+', manufacturer: 'BenQ' },\n    { pattern: '^ASUS.+', manufacturer: 'Asus' },\n    { pattern: '^DELL.+', manufacturer: 'Dell' },\n    { pattern: '^SAMSUNG.+', manufacturer: 'Samsung' },\n    { pattern: '^VIEWSON.+', manufacturer: 'ViewSonic' },\n    { pattern: '^SONY.+', manufacturer: 'Sony' },\n    { pattern: '^ACER.+', manufacturer: 'Acer' },\n    { pattern: '^AOC.+', manufacturer: 'AOC Monitors' },\n    { pattern: '^HP.+', manufacturer: 'HP' },\n    { pattern: '^EIZO.?', manufacturer: 'Eizo' },\n    { pattern: '^PHILIPS.?', manufacturer: 'Philips' },\n    { pattern: '^IIYAMA.?', manufacturer: 'Iiyama' },\n    { pattern: '^SHARP.?', manufacturer: 'Sharp' },\n    { pattern: '^NEC.?', manufacturer: 'NEC' },\n    { pattern: '^LENOVO.?', manufacturer: 'Lenovo' },\n    { pattern: 'COMPAQ.?', manufacturer: 'Compaq' },\n    { pattern: 'APPLE.?', manufacturer: 'Apple' },\n    { pattern: 'INTEL.?', manufacturer: 'Intel' },\n    { pattern: 'AMD.?', manufacturer: 'AMD' },\n    { pattern: 'NVIDIA.?', manufacturer: 'NVDIA' },\n  ];\n\n  let result = '';\n  if (model) {\n    model = model.toUpperCase();\n    manufacturers.forEach((manufacturer) => {\n      const re = RegExp(manufacturer.pattern);\n      if (re.test(model)) { result = manufacturer.manufacturer; }\n    });\n  }\n  return result;\n}\n\nfunction getVendorFromId(id) {\n  const vendors = {\n    '610': 'Apple',\n    '1e6d': 'LG',\n    '10ac': 'DELL',\n    '4dd9': 'Sony',\n    '38a3': 'NEC',\n  };\n  return vendors[id] || '';\n}\n\nfunction vendorToId(str) {\n  let result = '';\n  str = (str || '').toLowerCase();\n  if (str.indexOf('apple') >= 0) { result = '0x05ac'; }\n  else if (str.indexOf('nvidia') >= 0) { result = '0x10de'; }\n  else if (str.indexOf('intel') >= 0) { result = '0x8086'; }\n  else if (str.indexOf('ati') >= 0 || str.indexOf('amd') >= 0) { result = '0x1002'; }\n\n  return result;\n}\n\nfunction getMetalVersion(id) {\n  const families = {\n    'spdisplays_mtlgpufamilymac1': 'mac1',\n    'spdisplays_mtlgpufamilymac2': 'mac2',\n    'spdisplays_mtlgpufamilyapple1': 'apple1',\n    'spdisplays_mtlgpufamilyapple2': 'apple2',\n    'spdisplays_mtlgpufamilyapple3': 'apple3',\n    'spdisplays_mtlgpufamilyapple4': 'apple4',\n    'spdisplays_mtlgpufamilyapple5': 'apple5',\n    'spdisplays_mtlgpufamilyapple6': 'apple6',\n    'spdisplays_mtlgpufamilyapple7': 'apple7',\n    'spdisplays_metalfeaturesetfamily11': 'family1_v1',\n    'spdisplays_metalfeaturesetfamily12': 'family1_v2',\n    'spdisplays_metalfeaturesetfamily13': 'family1_v3',\n    'spdisplays_metalfeaturesetfamily14': 'family1_v4',\n    'spdisplays_metalfeaturesetfamily21': 'family2_v1'\n  };\n  return families[id] || '';\n}\n\nfunction graphics(callback) {\n\n  function parseLinesDarwin(graphicsArr) {\n    const res = {\n      controllers: [],\n      displays: []\n    };\n    try {\n      graphicsArr.forEach(function (item) {\n        // controllers\n        const bus = ((item.sppci_bus || '').indexOf('builtin') > -1 ? 'Built-In' : ((item.sppci_bus || '').indexOf('pcie') > -1 ? 'PCIe' : ''));\n        const vram = (parseInt((item.spdisplays_vram || ''), 10) || 0) * (((item.spdisplays_vram || '').indexOf('GB') > -1) ? 1024 : 1);\n        const vramDyn = (parseInt((item.spdisplays_vram_shared || ''), 10) || 0) * (((item.spdisplays_vram_shared || '').indexOf('GB') > -1) ? 1024 : 1);\n        let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || '');\n        res.controllers.push({\n          vendor: getVendorFromModel(item.spdisplays_vendor || '') || item.spdisplays_vendor || '',\n          model: item.sppci_model || '',\n          bus,\n          vramDynamic: bus === 'Built-In',\n          vram: vram || vramDyn || null,\n          deviceId: item['spdisplays_device-id'] || '',\n          vendorId: item['spdisplays_vendor-id'] || vendorToId((item['spdisplays_vendor'] || '') + (item.sppci_model || '')),\n          external: (item.sppci_device_type === 'spdisplays_egpu'),\n          cores: item['sppci_cores'] || null,\n          metalVersion\n        });\n\n        // displays\n        if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {\n          item.spdisplays_ndrvs.forEach(function (displayItem) {\n            const connectionType = displayItem['spdisplays_connection_type'] || '';\n            const currentResolutionParts = (displayItem['_spdisplays_resolution'] || '').split('@');\n            const currentResolution = currentResolutionParts[0].split('x');\n            const pixelParts = (displayItem['_spdisplays_pixels'] || '').split('x');\n            const pixelDepthString = displayItem['spdisplays_depth'] || '';\n            const serial = displayItem['_spdisplays_display-serial-number'] || displayItem['_spdisplays_display-serial-number2'] || null;\n            res.displays.push({\n              vendor: getVendorFromId(displayItem['_spdisplays_display-vendor-id'] || '') || getVendorFromModel(displayItem['_name'] || ''),\n              vendorId: displayItem['_spdisplays_display-vendor-id'] || '',\n              model: displayItem['_name'] || '',\n              productionYear: displayItem['_spdisplays_display-year'] || null,\n              serial: serial !== '0' ? serial : null,\n              displayId: displayItem['_spdisplays_displayID'] || null,\n              main: displayItem['spdisplays_main'] ? displayItem['spdisplays_main'] === 'spdisplays_yes' : false,\n              builtin: (displayItem['spdisplays_display_type'] || '').indexOf('built-in') > -1,\n              connection: ((connectionType.indexOf('_internal') > -1) ? 'Internal' : ((connectionType.indexOf('_displayport') > -1) ? 'Display Port' : ((connectionType.indexOf('_hdmi') > -1) ? 'HDMI' : null))),\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: (pixelDepthString === 'CGSThirtyBitColor' ? 30 : (pixelDepthString === 'CGSThirtytwoBitColor' ? 32 : (pixelDepthString === 'CGSTwentyfourBitColor' ? 24 : null))),\n              resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,\n              resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,\n              currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,\n              currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null,\n\n            });\n          });\n        }\n      });\n      return res;\n    } catch (e) {\n      return res;\n    }\n  }\n\n  function parseLinesLinuxControllers(lines) {\n    let controllers = [];\n    let currentController = {\n      vendor: '',\n      model: '',\n      bus: '',\n      busAddress: '',\n      vram: null,\n      vramDynamic: false,\n      pciID: ''\n    };\n    let isGraphicsController = false;\n    // PCI bus IDs\n    let pciIDs = [];\n    try {\n      pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep \"Bus Address: \"').toString().split('\\n');\n      for (let i = 0; i < pciIDs.length; i++) {\n        pciIDs[i] = pciIDs[i].replace('Bus Address:', '').replace('0000:', '').trim();\n      }\n      pciIDs = pciIDs.filter(function (el) {\n        return el != null && el;\n      });\n    } catch (e) {\n      util.noop();\n    }\n    lines.forEach((line) => {\n      if ('' !== line.trim()) {\n        if (' ' !== line[0] && '\\t' !== line[0]) {        // first line of new entry\n          let isExternal = (pciIDs.indexOf(line.split(' ')[0]) >= 0);\n          let vgapos = line.toLowerCase().indexOf(' vga ');\n          let _3dcontrollerpos = line.toLowerCase().indexOf('3d controller');\n          if (vgapos !== -1 || _3dcontrollerpos !== -1) {         // VGA\n            if (_3dcontrollerpos !== -1 && vgapos === -1) {\n              vgapos = _3dcontrollerpos;\n            }\n            if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n              controllers.push(currentController);\n              currentController = {\n                vendor: '',\n                model: '',\n                bus: '',\n                busAddress: '',\n                vram: null,\n                vramDynamic: false,\n              };\n            }\n\n            const pciIDCandidate = line.split(' ')[0];\n            if (/[\\da-fA-F]{2}:[\\da-fA-F]{2}\\.[\\da-fA-F]/.test(pciIDCandidate)) {\n              currentController.busAddress = pciIDCandidate;\n            }\n            isGraphicsController = true;\n            let endpos = line.search(/\\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);\n            let parts = line.substr(vgapos, endpos - vgapos).split(':');\n            currentController.busAddress = line.substr(0, vgapos).trim();\n            if (parts.length > 1) {\n              parts[1] = parts[1].trim();\n              if (parts[1].toLowerCase().indexOf('corporation') >= 0) {\n                currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf('corporation') + 11).trim();\n                currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf('corporation') + 11, 200).trim().split('(')[0];\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' inc.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' inc.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' inc.') + 5, 200).trim().split('(')[0].trim();\n                }\n                currentController.bus = (pciIDs.length > 0 && isExternal) ? 'PCIe' : 'Onboard';\n                currentController.vram = null;\n                currentController.vramDynamic = false;\n              } else if (parts[1].toLowerCase().indexOf(' ltd.') >= 0) {\n                if ((parts[1].match(/]/g) || []).length > 1) {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(']') + 1).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(']') + 1, 200).trim().split('(')[0].trim();\n                } else {\n                  currentController.vendor = parts[1].substr(0, parts[1].toLowerCase().indexOf(' ltd.') + 5).trim();\n                  currentController.model = parts[1].substr(parts[1].toLowerCase().indexOf(' ltd.') + 5, 200).trim().split('(')[0].trim();\n                }\n              }\n            }\n\n          } else {\n            isGraphicsController = false;\n          }\n        }\n        if (isGraphicsController) { // within VGA details\n          let parts = line.split(':');\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('devicename') !== -1 && parts[1].toLowerCase().indexOf('onboard') !== -1) { currentController.bus = 'Onboard'; }\n          if (parts.length > 1 && parts[0].replace(/ +/g, '').toLowerCase().indexOf('region') !== -1 && parts[1].toLowerCase().indexOf('memory') !== -1) {\n            let memparts = parts[1].split('=');\n            if (memparts.length > 1) {\n              currentController.vram = parseInt(memparts[1]);\n            }\n          }\n        }\n      }\n    });\n\n    if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) { // already a controller found\n      controllers.push(currentController);\n    }\n    return (controllers);\n  }\n\n  function parseLinesLinuxClinfo(controllers, lines) {\n    const fieldPattern = /\\[([^\\]]+)\\]\\s+(\\w+)\\s+(.*)/;\n    const devices = lines.reduce((devices, line) => {\n      const field = fieldPattern.exec(line.trim());\n      if (field) {\n        if (!devices[field[1]]) {\n          devices[field[1]] = {};\n        }\n        devices[field[1]][field[2]] = field[3];\n      }\n      return devices;\n    }, {});\n    for (let deviceId in devices) {\n      const device = devices[deviceId];\n      if (device['CL_DEVICE_TYPE'] === 'CL_DEVICE_TYPE_GPU') {\n        let busAddress;\n        if (device['CL_DEVICE_TOPOLOGY_AMD']) {\n          const bdf = device['CL_DEVICE_TOPOLOGY_AMD'].match(/[a-zA-Z0-9]+:\\d+\\.\\d+/);\n          if (bdf) {\n            busAddress = bdf[0];\n          }\n        } else if (device['CL_DEVICE_PCI_BUS_ID_NV'] && device['CL_DEVICE_PCI_SLOT_ID_NV']) {\n          const bus = parseInt(device['CL_DEVICE_PCI_BUS_ID_NV']);\n          const slot = parseInt(device['CL_DEVICE_PCI_SLOT_ID_NV']);\n          if (!isNaN(bus) && !isNaN(slot)) {\n            const b = bus & 0xff;\n            const d = (slot >> 3) & 0xff;\n            const f = slot & 0x07;\n            busAddress = `${b.toString().padStart(2, '0')}:${d.toString().padStart(2, '0')}.${f}`;\n          }\n        }\n        if (busAddress) {\n          let controller = controllers.find(controller => controller.busAddress === busAddress);\n          if (!controller) {\n            controller = {\n              vendor: '',\n              model: '',\n              bus: '',\n              busAddress,\n              vram: null,\n              vramDynamic: false\n            };\n            controllers.push(controller);\n          }\n          controller.vendor = device['CL_DEVICE_VENDOR'];\n          if (device['CL_DEVICE_BOARD_NAME_AMD']) {\n            controller.model = device['CL_DEVICE_BOARD_NAME_AMD'];\n          } else {\n            controller.model = device['CL_DEVICE_NAME'];\n          }\n          const memory = parseInt(device['CL_DEVICE_GLOBAL_MEM_SIZE']);\n          if (!isNaN(memory)) {\n            controller.vram = Math.round(memory / 1024 / 1024);\n          }\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function getNvidiaSmi() {\n    if (_nvidiaSmiPath) {\n      return _nvidiaSmiPath;\n    }\n\n    if (_windows) {\n      try {\n        const basePath = util.WINDIR + '\\\\System32\\\\DriverStore\\\\FileRepository';\n        // find all directories that have an nvidia-smi.exe file\n        const candidateDirs = fs.readdirSync(basePath).filter(dir => {\n          return fs.readdirSync([basePath, dir].join('/')).includes('nvidia-smi.exe');\n        });\n        // use the directory with the most recently created nvidia-smi.exe file\n        const targetDir = candidateDirs.reduce((prevDir, currentDir) => {\n          const previousNvidiaSmi = fs.statSync([basePath, prevDir, 'nvidia-smi.exe'].join('/'));\n          const currentNvidiaSmi = fs.statSync([basePath, currentDir, 'nvidia-smi.exe'].join('/'));\n          return (previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs) ? prevDir : currentDir;\n        });\n\n        if (targetDir) {\n          _nvidiaSmiPath = [basePath, targetDir, 'nvidia-smi.exe'].join('/');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else if (_linux) {\n      _nvidiaSmiPath = 'nvidia-smi';\n    }\n    return _nvidiaSmiPath;\n  }\n\n  function nvidiaSmi(options) {\n    const nvidiaSmiExe = getNvidiaSmi();\n    options = options || util.execOptsWin;\n    if (nvidiaSmiExe) {\n      const nvidiaSmiOpts = '--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits';\n      const cmd = nvidiaSmiExe + ' ' + nvidiaSmiOpts + (_linux ? '  2>/dev/null' : '');\n      try {\n        const res = execSync(cmd, options).toString();\n        return res;\n      } catch (e) {\n        util.noop();\n      }\n    }\n    return '';\n  }\n\n  function nvidiaDevices() {\n\n    function safeParseNumber(value) {\n      if ([null, undefined].includes(value)) {\n        return value;\n      }\n      return parseFloat(value);\n    }\n\n    const stdout = nvidiaSmi();\n    if (!stdout) {\n      return [];\n    }\n\n    const gpus = stdout.split('\\n').filter(Boolean);\n    let results = gpus.map(gpu => {\n      const splittedData = gpu.split(', ').map(value => value.includes('N/A') ? undefined : value);\n      if (splittedData.length === 16) {\n        return {\n          driverVersion: splittedData[0],\n          subDeviceId: splittedData[1],\n          name: splittedData[2],\n          pciBus: splittedData[3],\n          fanSpeed: safeParseNumber(splittedData[4]),\n          memoryTotal: safeParseNumber(splittedData[5]),\n          memoryUsed: safeParseNumber(splittedData[6]),\n          memoryFree: safeParseNumber(splittedData[7]),\n          utilizationGpu: safeParseNumber(splittedData[8]),\n          utilizationMemory: safeParseNumber(splittedData[9]),\n          temperatureGpu: safeParseNumber(splittedData[10]),\n          temperatureMemory: safeParseNumber(splittedData[11]),\n          powerDraw: safeParseNumber(splittedData[12]),\n          powerLimit: safeParseNumber(splittedData[13]),\n          clockCore: safeParseNumber(splittedData[14]),\n          clockMemory: safeParseNumber(splittedData[15]),\n        };\n      } else {\n        return {};\n      }\n    });\n    results = results.filter((item) => {\n      return ('pciBus' in item);\n    });\n    return results;\n  }\n\n  function mergeControllerNvidia(controller, nvidia) {\n    if (nvidia.driverVersion) { controller.driverVersion = nvidia.driverVersion; }\n    if (nvidia.subDeviceId) { controller.subDeviceId = nvidia.subDeviceId; }\n    if (nvidia.name) { controller.name = nvidia.name; }\n    if (nvidia.pciBus) { controller.pciBus = nvidia.pciBus; }\n    if (nvidia.fanSpeed) { controller.fanSpeed = nvidia.fanSpeed; }\n    if (nvidia.memoryTotal) {\n      controller.memoryTotal = nvidia.memoryTotal;\n      controller.vram = nvidia.memoryTotal;\n      controller.vramDynamic = false;\n    }\n    if (nvidia.memoryUsed) { controller.memoryUsed = nvidia.memoryUsed; }\n    if (nvidia.memoryFree) { controller.memoryFree = nvidia.memoryFree; }\n    if (nvidia.utilizationGpu) { controller.utilizationGpu = nvidia.utilizationGpu; }\n    if (nvidia.utilizationMemory) { controller.utilizationMemory = nvidia.utilizationMemory; }\n    if (nvidia.temperatureGpu) { controller.temperatureGpu = nvidia.temperatureGpu; }\n    if (nvidia.temperatureMemory) { controller.temperatureMemory = nvidia.temperatureMemory; }\n    if (nvidia.powerDraw) { controller.powerDraw = nvidia.powerDraw; }\n    if (nvidia.powerLimit) { controller.powerLimit = nvidia.powerLimit; }\n    if (nvidia.clockCore) { controller.clockCore = nvidia.clockCore; }\n    if (nvidia.clockMemory) { controller.clockMemory = nvidia.clockMemory; }\n    return controller;\n  }\n\n  function parseLinesLinuxEdid(edid) {\n    // parsen EDID\n    // --> model\n    // --> resolutionx\n    // --> resolutiony\n    // --> builtin = false\n    // --> pixeldepth (?)\n    // --> sizex\n    // --> sizey\n    let result = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    // find first \"Detailed Timing Description\"\n    let start = 108;\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    if (edid.substr(start, 6) === '000000') {\n      start += 36;\n    }\n    result.resolutionX = parseInt('0x0' + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));\n    result.resolutionY = parseInt('0x0' + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));\n    result.sizeX = parseInt('0x0' + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));\n    result.sizeY = parseInt('0x0' + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));\n    // monitor name\n    start = edid.indexOf('000000fc00'); // find first \"Monitor Description Data\"\n    if (start >= 0) {\n      let model_raw = edid.substr(start + 10, 26);\n      if (model_raw.indexOf('0a') !== -1) {\n        model_raw = model_raw.substr(0, model_raw.indexOf('0a'));\n      }\n      try {\n        if (model_raw.length > 2) {\n          result.model = model_raw.match(/.{1,2}/g).map(function (v) {\n            return String.fromCharCode(parseInt(v, 16));\n          }).join('');\n        }\n      } catch (e) {\n        util.noop();\n      }\n    } else {\n      result.model = '';\n    }\n    return result;\n  }\n\n  function parseLinesLinuxDisplays(lines, depth) {\n    let displays = [];\n    let currentDisplay = {\n      vendor: '',\n      model: '',\n      deviceName: '',\n      main: false,\n      builtin: false,\n      connection: '',\n      sizeX: null,\n      sizeY: null,\n      pixelDepth: null,\n      resolutionX: null,\n      resolutionY: null,\n      currentResX: null,\n      currentResY: null,\n      positionX: 0,\n      positionY: 0,\n      currentRefreshRate: null\n    };\n    let is_edid = false;\n    let is_current = false;\n    let edid_raw = '';\n    let start = 0;\n    for (let i = 1; i < lines.length; i++) {        // start with second line\n      if ('' !== lines[i].trim()) {\n        if (' ' !== lines[i][0] && '\\t' !== lines[i][0] && lines[i].toLowerCase().indexOf(' connected ') !== -1) {        // first line of new entry\n          if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {         // push last display to array\n            displays.push(currentDisplay);\n            currentDisplay = {\n              vendor: '',\n              model: '',\n              main: false,\n              builtin: false,\n              connection: '',\n              sizeX: null,\n              sizeY: null,\n              pixelDepth: null,\n              resolutionX: null,\n              resolutionY: null,\n              currentResX: null,\n              currentResY: null,\n              positionX: 0,\n              positionY: 0,\n              currentRefreshRate: null\n            };\n          }\n          let parts = lines[i].split(' ');\n          currentDisplay.connection = parts[0];\n          currentDisplay.main = lines[i].toLowerCase().indexOf(' primary ') >= 0;\n          currentDisplay.builtin = (parts[0].toLowerCase().indexOf('edp') >= 0);\n        }\n\n        // try to read EDID information\n        if (is_edid) {\n          if (lines[i].search(/\\S|$/) > start) {\n            edid_raw += lines[i].toLowerCase().trim();\n          } else {\n            // parsen EDID\n            let edid_decoded = parseLinesLinuxEdid(edid_raw);\n            currentDisplay.vendor = edid_decoded.vendor;\n            currentDisplay.model = edid_decoded.model;\n            currentDisplay.resolutionX = edid_decoded.resolutionX;\n            currentDisplay.resolutionY = edid_decoded.resolutionY;\n            currentDisplay.sizeX = edid_decoded.sizeX;\n            currentDisplay.sizeY = edid_decoded.sizeY;\n            currentDisplay.pixelDepth = depth;\n            is_edid = false;\n          }\n        }\n        if (lines[i].toLowerCase().indexOf('edid:') >= 0) {\n          is_edid = true;\n          start = lines[i].search(/\\S|$/);\n        }\n        if (lines[i].toLowerCase().indexOf('*current') >= 0) {\n          const parts1 = lines[i].split('(');\n          if (parts1 && parts1.length > 1 && parts1[0].indexOf('x') >= 0) {\n            const resParts = parts1[0].trim().split('x');\n            currentDisplay.currentResX = util.toInt(resParts[0]);\n            currentDisplay.currentResY = util.toInt(resParts[1]);\n          }\n          is_current = true;\n        }\n        if (is_current && lines[i].toLowerCase().indexOf('clock') >= 0 && lines[i].toLowerCase().indexOf('hz') >= 0 && lines[i].toLowerCase().indexOf('v: height') >= 0) {\n          const parts1 = lines[i].split('clock');\n          if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf('hz') >= 0) {\n            currentDisplay.currentRefreshRate = util.toInt(parts1[1]);\n          }\n          is_current = false;\n        }\n      }\n    }\n\n    // pushen displays\n    if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {  // still information there\n      displays.push(currentDisplay);\n    }\n    return displays;\n  }\n\n  // function starts here\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        controllers: [],\n        displays: []\n      };\n      if (_darwin) {\n        let cmd = 'system_profiler -xml -detailLevel full SPDisplaysDataType';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const output = stdout.toString();\n              result = parseLinesDarwin(util.plistParser(output)[0]._items);\n            } catch (e) {\n              util.noop();\n            }\n            stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo \"\"');\n            const output = (stdout || '').toString();\n            const obj = util.plistReader(output);\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets']['Configs'] && obj['DisplayAnyUserSets']['Configs'][0] && obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig']) {\n              const current = obj['DisplayAnyUserSets']['Configs'][0]['DisplayConfig'];\n              let i = 0;\n              current.forEach((o) => {\n                if (o['CurrentInfo'] && 'OriginX' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['CurrentInfo']['OriginX'];\n                }\n                if (o['CurrentInfo'] && 'OriginY' in o['CurrentInfo'] && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['CurrentInfo']['OriginY'];\n                }\n                i++;\n              });\n            }\n            if (obj['DisplayAnyUserSets'] && obj['DisplayAnyUserSets'].length > 0 && obj['DisplayAnyUserSets'][0].length > 0 && obj['DisplayAnyUserSets'][0][0]['DisplayID']) {\n              const current = obj['DisplayAnyUserSets'][0];\n              let i = 0;\n              current.forEach((o) => {\n                if ('OriginX' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionX = o['OriginX'];\n                }\n                if ('OriginY' in o && result.displays && result.displays[i]) {\n                  result.displays[i].positionY = o['OriginY'];\n                }\n                if (o['Mode'] && 'BitsPerPixel' in o['Mode'] && result.displays && result.displays[i]) {\n                  result.displays[i].pixelDepth = o['Mode']['BitsPerPixel'];\n                }\n                i++;\n              });\n            }\n\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        // Raspberry: https://elinux.org/RPI_vcgencmd_usage\n        if (util.isRaspberry() && util.isRaspbian()) {\n          let cmd = 'fbset -s | grep \\'mode \"\\'; vcgencmd get_mem gpu; tvservice -s; tvservice -n;';\n          exec(cmd, function (error, stdout) {\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 3 && lines[0].indexOf('mode \"') >= -1 && lines[2].indexOf('0x12000a') > -1) {\n              const parts = lines[0].replace('mode', '').replace(/\"/g, '').trim().split('x');\n              if (parts.length === 2) {\n                result.displays.push({\n                  vendor: '',\n                  model: util.getValue(lines, 'device_name', '='),\n                  main: true,\n                  builtin: false,\n                  connection: 'HDMI',\n                  sizeX: null,\n                  sizeY: null,\n                  pixelDepth: null,\n                  resolutionX: parseInt(parts[0], 10),\n                  resolutionY: parseInt(parts[1], 10),\n                  currentResX: null,\n                  currentResY: null,\n                  positionX: 0,\n                  positionY: 0,\n                  currentRefreshRate: null\n                });\n              }\n            }\n            if (lines.length > 1 && stdout.toString().indexOf('gpu=') >= -1) {\n              result.controllers.push({\n                vendor: 'Broadcom',\n                model: 'VideoCore IV',\n                bus: '',\n                vram: util.getValue(lines, 'gpu', '=').replace('M', ''),\n                vramDynamic: true\n              });\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        } else {\n          let cmd = 'lspci -vvv  2>/dev/null';\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              result.controllers = parseLinesLinuxControllers(lines);\n              const nvidiaData = nvidiaDevices();\n              // needs to be rewritten ... using no spread operators\n              result.controllers = result.controllers.map((controller) => { // match by busAddress\n                return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});\n              });\n            }\n            let cmd = 'clinfo --raw';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.controllers = parseLinesLinuxClinfo(result.controllers, lines);\n              }\n              let cmd = 'xdpyinfo 2>/dev/null | grep \\'depth of root window\\' | awk \\'{ print $5 }\\'';\n              exec(cmd, function (error, stdout) {\n                let depth = 0;\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  depth = parseInt(lines[0]) || 0;\n                }\n                let cmd = 'xrandr --verbose 2>/dev/null';\n                exec(cmd, function (error, stdout) {\n                  if (!error) {\n                    let lines = stdout.toString().split('\\n');\n                    result.displays = parseLinesLinuxDisplays(lines, depth);\n                  }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                });\n              });\n            });\n          });\n        }\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_sunos) {\n        if (callback) { callback(null); }\n        resolve(null);\n      }\n      if (_windows) {\n\n        // https://blogs.technet.microsoft.com/heyscriptingguy/2013/10/03/use-powershell-to-discover-multi-monitor-information/\n        // https://devblogs.microsoft.com/scripting/use-powershell-to-discover-multi-monitor-information/\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance win32_VideoController | fl *'));\n          workload.push(util.powerShell('gp \"HKLM:\\\\SYSTEM\\\\ControlSet001\\\\Control\\\\Class\\\\{4d36e968-e325-11ce-bfc1-08002be10318}\\\\*\" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));\n          workload.push(util.powerShell('Get-CimInstance win32_desktopmonitor | fl *'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorBasicDisplayParams | fl'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens'));\n          workload.push(util.powerShell('Get-CimInstance -Namespace root\\\\wmi -ClassName WmiMonitorConnectionParams | fl'));\n          workload.push(util.powerShell('gwmi WmiMonitorID -Namespace root\\\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join \"\") + \"|\" + $_.InstanceName}'));\n\n          const nvidiaData = nvidiaDevices();\n\n          Promise.all(\n            workload\n          ).then((data) => {\n            // controller + vram\n            let csections = data[0].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            let vsections = data[1].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            result.controllers = parseLinesWindowsControllers(csections, vsections);\n            result.controllers = result.controllers.map((controller) => { // match by subDeviceId\n              if (controller.vendor.toLowerCase() === 'nvidia') {\n                return mergeControllerNvidia(controller, nvidiaData.find(device => {\n                  let windowsSubDeviceId = (controller.subDeviceId || '').toLowerCase();\n                  const nvidiaSubDeviceIdParts = device.subDeviceId.split('x');\n                  let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();\n                  const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);\n                  if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      nvidiaSubDeviceId = '0' + nvidiaSubDeviceId;\n                    }\n                  } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {\n                    for (let i = 0; i < lengthDifference; i++) {\n                      windowsSubDeviceId = '0' + windowsSubDeviceId;\n                    }\n                  }\n                  return windowsSubDeviceId === nvidiaSubDeviceId;\n                }) || {});\n              } else {\n                return controller;\n              }\n            });\n\n            // displays\n            let dsections = data[2].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            // result.displays = parseLinesWindowsDisplays(dsections);\n            if (dsections[0].trim() === '') { dsections.shift(); }\n            if (dsections.length && dsections[dsections.length - 1].trim() === '') { dsections.pop(); }\n\n            // monitor (powershell)\n            let msections = data[3].replace(/\\r/g, '').split('Active ');\n            msections.shift();\n\n            // forms.screens (powershell)\n            let ssections = data[4].replace(/\\r/g, '').split('BitsPerPixel ');\n            ssections.shift();\n\n            // connection params (powershell) - video type\n            let tsections = data[5].replace(/\\r/g, '').split(/\\n\\s*\\n/);\n            tsections.shift();\n\n            // monitor ID (powershell) - model / vendor\n            const res = data[6].replace(/\\r/g, '').split(/\\n/);\n            let isections = [];\n            res.forEach(element => {\n              const parts = element.split('|');\n              if (parts.length === 5) {\n                isections.push({\n                  vendor: parts[0],\n                  code: parts[1],\n                  model: parts[2],\n                  serial: parts[3],\n                  instanceId: parts[4]\n                });\n              }\n            });\n\n            result.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);\n\n            if (result.displays.length === 1) {\n              if (_resolutionX) {\n                result.displays[0].resolutionX = _resolutionX;\n                if (!result.displays[0].currentResX) {\n                  result.displays[0].currentResX = _resolutionX;\n                }\n              }\n              if (_resolutionY) {\n                result.displays[0].resolutionY = _resolutionY;\n                if (result.displays[0].currentResY === 0) {\n                  result.displays[0].currentResY = _resolutionY;\n                }\n              }\n              if (_pixelDepth) {\n                result.displays[0].pixelDepth = _pixelDepth;\n              }\n            }\n            result.displays = result.displays.map(element => {\n              if (_refreshRate && !element.currentRefreshRate) {\n                element.currentRefreshRate = _refreshRate;\n              }\n              return element;\n            });\n\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          })\n            .catch(() => {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n\n  function parseLinesWindowsControllers(sections, vections) {\n    const memorySizes = {};\n    for (const i in vections) {\n      if ({}.hasOwnProperty.call(vections, i)) {\n        if (vections[i].trim() !== '') {\n          const lines = vections[i].trim().split('\\n');\n          const matchingDeviceId = util.getValue(lines, 'MatchingDeviceId').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          if (matchingDeviceId) {\n            const quadWordmemorySize = parseInt(util.getValue(lines, 'HardwareInformation.qwMemorySize'));\n            if (!isNaN(quadWordmemorySize)) {\n              let deviceId = matchingDeviceId[1].toUpperCase() + '&' + matchingDeviceId[2].toUpperCase();\n              if (matchingDeviceId[3]) {\n                deviceId += '&' + matchingDeviceId[3].toUpperCase();\n              }\n              if (matchingDeviceId[4]) {\n                deviceId += '&' + matchingDeviceId[4].toUpperCase();\n              }\n              memorySizes[deviceId] = quadWordmemorySize;\n            }\n          }\n        }\n      }\n    }\n\n    let controllers = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\n');\n          let pnpDeviceId = util.getValue(lines, 'PNPDeviceID', ':').match(/PCI\\\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);\n          let subDeviceId = null;\n          let memorySize = null;\n          if (pnpDeviceId) {\n            subDeviceId = pnpDeviceId[3] || '';\n            if (subDeviceId) {\n              subDeviceId = subDeviceId.split('_')[1];\n            }\n\n            // Match PCI device identifier (there's an order of increasing generality):\n            // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/identifiers-for-pci-devices\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&SUBSYS_s(4)n(4)\n            if (memorySize == null && pnpDeviceId[3]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[3].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)&REV_r(2)\n            if (memorySize == null && pnpDeviceId[4]) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase() + '&' + pnpDeviceId[4].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n\n            // PCI\\VEN_v(4)&DEV_d(4)\n            if (memorySize == null) {\n              const deviceId = pnpDeviceId[1].toUpperCase() + '&' + pnpDeviceId[2].toUpperCase();\n              if ({}.hasOwnProperty.call(memorySizes, deviceId)) {\n                memorySize = memorySizes[deviceId];\n              }\n            }\n          }\n\n          controllers.push({\n            vendor: util.getValue(lines, 'AdapterCompatibility', ':'),\n            model: util.getValue(lines, 'name', ':'),\n            bus: util.getValue(lines, 'PNPDeviceID', ':').startsWith('PCI') ? 'PCI' : '',\n            vram: (memorySize == null ? util.toInt(util.getValue(lines, 'AdapterRAM', ':')) : memorySize) / 1024 / 1024,\n            vramDynamic: (util.getValue(lines, 'VideoMemoryType', ':') === '2'),\n            subDeviceId\n          });\n          _resolutionX = util.toInt(util.getValue(lines, 'CurrentHorizontalResolution', ':')) || _resolutionX;\n          _resolutionY = util.toInt(util.getValue(lines, 'CurrentVerticalResolution', ':')) || _resolutionY;\n          _refreshRate = util.toInt(util.getValue(lines, 'CurrentRefreshRate', ':')) || _refreshRate;\n          _pixelDepth = util.toInt(util.getValue(lines, 'CurrentBitsPerPixel', ':')) || _pixelDepth;\n        }\n      }\n    }\n    return controllers;\n  }\n\n  function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {\n    let displays = [];\n    let vendor = '';\n    let model = '';\n    let deviceID = '';\n    let resolutionX = 0;\n    let resolutionY = 0;\n    if (dsections && dsections.length) {\n      let linesDisplay = dsections[0].split('\\n');\n      vendor = util.getValue(linesDisplay, 'MonitorManufacturer', ':');\n      model = util.getValue(linesDisplay, 'Name', ':');\n      deviceID = util.getValue(linesDisplay, 'PNPDeviceID', ':').replace(/&amp;/g, '&').toLowerCase();\n      resolutionX = util.toInt(util.getValue(linesDisplay, 'ScreenWidth', ':'));\n      resolutionY = util.toInt(util.getValue(linesDisplay, 'ScreenHeight', ':'));\n    }\n    for (let i = 0; i < ssections.length; i++) {\n      if (ssections[i].trim() !== '') {\n        ssections[i] = 'BitsPerPixel ' + ssections[i];\n        msections[i] = 'Active ' + msections[i];\n        // tsections can be empty OR undefined on earlier versions of powershell (<=2.0)\n        // Tag connection type as UNKNOWN by default if this information is missing\n        if (tsections.length === 0 || tsections[i] === undefined) {\n          tsections[i] = 'Unknown';\n        }\n        let linesScreen = ssections[i].split('\\n');\n        let linesMonitor = msections[i].split('\\n');\n\n        let linesConnection = tsections[i].split('\\n');\n        const bitsPerPixel = util.getValue(linesScreen, 'BitsPerPixel');\n        const bounds = util.getValue(linesScreen, 'Bounds').replace('{', '').replace('}', '').replace(/=/g, ':').split(',');\n        const primary = util.getValue(linesScreen, 'Primary');\n        const sizeX = util.getValue(linesMonitor, 'MaxHorizontalImageSize');\n        const sizeY = util.getValue(linesMonitor, 'MaxVerticalImageSize');\n        const instanceName = util.getValue(linesMonitor, 'InstanceName').toLowerCase();\n        const videoOutputTechnology = util.getValue(linesConnection, 'VideoOutputTechnology');\n        const deviceName = util.getValue(linesScreen, 'DeviceName');\n        let displayVendor = '';\n        let displayModel = '';\n        isections.forEach(element => {\n          if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith('(') && model.startsWith('PnP')) {\n            displayVendor = element.vendor;\n            displayModel = element.model;\n          }\n        });\n        displays.push({\n          vendor: instanceName.startsWith(deviceID) && displayVendor === '' ? vendor : displayVendor,\n          model: instanceName.startsWith(deviceID) && displayModel === '' ? model : displayModel,\n          deviceName,\n          main: primary.toLowerCase() === 'true',\n          builtin: videoOutputTechnology === '2147483648',\n          connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : '',\n          resolutionX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          resolutionY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          sizeX: sizeX ? parseInt(sizeX, 10) : null,\n          sizeY: sizeY ? parseInt(sizeY, 10) : null,\n          pixelDepth: bitsPerPixel,\n          currentResX: util.toInt(util.getValue(bounds, 'Width', ':')),\n          currentResY: util.toInt(util.getValue(bounds, 'Height', ':')),\n          positionX: util.toInt(util.getValue(bounds, 'X', ':')),\n          positionY: util.toInt(util.getValue(bounds, 'Y', ':')),\n        });\n      }\n    }\n    if (ssections.length === 0) {\n      displays.push({\n        vendor,\n        model,\n        main: true,\n        sizeX: null,\n        sizeY: null,\n        resolutionX,\n        resolutionY,\n        pixelDepth: null,\n        currentResX: resolutionX,\n        currentResY: resolutionY,\n        positionX: 0,\n        positionY: 0\n      });\n    }\n    return displays;\n  }\n}\n\nexports.graphics = graphics;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// index.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// Contributors:  Guillaume Legrain (https://github.com/glegrain)\n//                Riccardo Novaglia (https://github.com/richy24)\n//                Quentin Busuttil (https://github.com/Buzut)\n//                Lapsio (https://github.com/lapsio)\n//                csy (https://github.com/csy1983)\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n\n// ----------------------------------------------------------------------------------\n// Dependencies\n// ----------------------------------------------------------------------------------\n\nconst lib_version = require('../package.json').version;\nconst util = require('./util');\nconst system = require('./system');\nconst osInfo = require('./osinfo');\nconst cpu = require('./cpu');\nconst memory = require('./memory');\nconst battery = require('./battery');\nconst graphics = require('./graphics');\nconst filesystem = require('./filesystem');\nconst network = require('./network');\nconst wifi = require('./wifi');\nconst processes = require('./processes');\nconst users = require('./users');\nconst internet = require('./internet');\nconst docker = require('./docker');\nconst vbox = require('./virtualbox');\nconst printer = require('./printer');\nconst usb = require('./usb');\nconst audio = require('./audio');\nconst bluetooth = require('./bluetooth');\n\nlet _platform = process.platform;\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// ----------------------------------------------------------------------------------\n// init\n// ----------------------------------------------------------------------------------\n\nif (_windows) {\n  util.getCodepage();\n}\n\n// ----------------------------------------------------------------------------------\n// General\n// ----------------------------------------------------------------------------------\n\nfunction version() {\n  return lib_version;\n}\n\n// ----------------------------------------------------------------------------------\n// Get static and dynamic data (all)\n// ----------------------------------------------------------------------------------\n\n// --------------------------\n// get static data - they should not change until restarted\n\nfunction getStaticData(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let data = {};\n\n      data.version = version();\n\n      Promise.all([\n        system.system(),\n        system.bios(),\n        system.baseboard(),\n        system.chassis(),\n        osInfo.osInfo(),\n        osInfo.uuid(),\n        osInfo.versions(),\n        cpu.cpu(),\n        cpu.cpuFlags(),\n        graphics.graphics(),\n        network.networkInterfaces(),\n        memory.memLayout(),\n        filesystem.diskLayout()\n      ]).then((res) => {\n        data.system = res[0];\n        data.bios = res[1];\n        data.baseboard = res[2];\n        data.chassis = res[3];\n        data.os = res[4];\n        data.uuid = res[5];\n        data.versions = res[6];\n        data.cpu = res[7];\n        data.cpu.flags = res[8];\n        data.graphics = res[9];\n        data.net = res[10];\n        data.memLayout = res[11];\n        data.diskLayout = res[12];\n        if (callback) { callback(data); }\n        resolve(data);\n      });\n    });\n  });\n}\n\n\n// --------------------------\n// get all dynamic data - e.g. for monitoring agents\n// may take some seconds to get all data\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getDynamicData(srv, iface, callback) {\n\n  if (util.isFunction(iface)) {\n    callback = iface;\n    iface = '';\n  }\n  if (util.isFunction(srv)) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      iface = iface || network.getDefaultNetworkInterface();\n      srv = srv || '';\n\n      // use closure to track ƒ completion\n      let functionProcessed = (function () {\n        let totalFunctions = 15;\n        if (_windows) { totalFunctions = 13; }\n        if (_freebsd || _openbsd || _netbsd) { totalFunctions = 11; }\n        if (_sunos) { totalFunctions = 6; }\n\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(data);\n            }\n            resolve(data);\n          }\n        };\n      })();\n\n      let data = {};\n\n      // get time\n      data.time = osInfo.time();\n\n      /**\n       * @namespace\n       * @property {Object}  versions\n       * @property {string}  versions.node\n       * @property {string}  versions.v8\n       */\n      data.node = process.versions.node;\n      data.v8 = process.versions.v8;\n\n      cpu.cpuCurrentSpeed().then((res) => {\n        data.cpuCurrentSpeed = res;\n        functionProcessed();\n      });\n\n      users.users().then((res) => {\n        data.users = res;\n        functionProcessed();\n      });\n\n      processes.processes().then((res) => {\n        data.processes = res;\n        functionProcessed();\n      });\n\n      cpu.currentLoad().then((res) => {\n        data.currentLoad = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        cpu.cpuTemperature().then((res) => {\n          data.temp = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        network.networkStats(iface).then((res) => {\n          data.networkStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        network.networkConnections().then((res) => {\n          data.networkConnections = res;\n          functionProcessed();\n        });\n      }\n\n      memory.mem().then((res) => {\n        data.mem = res;\n        functionProcessed();\n      });\n\n      if (!_sunos) {\n        battery().then((res) => {\n          data.battery = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        processes.services(srv).then((res) => {\n          data.services = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_sunos) {\n        filesystem.fsSize().then((res) => {\n          data.fsSize = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.fsStats().then((res) => {\n          data.fsStats = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        filesystem.disksIO().then((res) => {\n          data.disksIO = res;\n          functionProcessed();\n        });\n      }\n\n      if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {\n        wifi.wifiNetworks().then((res) => {\n          data.wifiNetworks = res;\n          functionProcessed();\n        });\n      }\n\n      internet.inetLatency().then((res) => {\n        data.inetLatency = res;\n        functionProcessed();\n      });\n    });\n  });\n}\n\n// --------------------------\n// get all data at once\n// --------------------------\n// 2 additional parameters needed\n// - srv: \t\tcomma separated list of services to monitor e.g. \"mysql, apache, postgresql\"\n// - iface:\tdefine network interface for which you like to monitor network speed e.g. \"eth0\"\n\nfunction getAllData(srv, iface, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let data = {};\n\n      if (iface && util.isFunction(iface) && !callback) {\n        callback = iface;\n        iface = '';\n      }\n\n      if (srv && util.isFunction(srv) && !iface && !callback) {\n        callback = srv;\n        srv = '';\n        iface = '';\n      }\n\n      getStaticData().then((res) => {\n        data = res;\n        getDynamicData(srv, iface).then((res) => {\n          for (let key in res) {\n            if ({}.hasOwnProperty.call(res, key)) {\n              data[key] = res[key];\n            }\n          }\n          if (callback) { callback(data); }\n          resolve(data);\n        });\n      });\n    });\n  });\n}\n\nfunction get(valueObject, callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const allPromises = Object.keys(valueObject)\n        .filter(func => ({}.hasOwnProperty.call(exports, func)))\n        .map(func => {\n          const params = valueObject[func].substring(valueObject[func].lastIndexOf('(') + 1, valueObject[func].lastIndexOf(')'));\n          let funcWithoutParams = func.indexOf(')') >= 0 ? func.split(')')[1].trim() : func;\n          funcWithoutParams = func.indexOf('|') >= 0 ? func.split('|')[0].trim() : funcWithoutParams;\n          if (params) {\n            return exports[funcWithoutParams](params);\n          } else {\n            return exports[funcWithoutParams]('');\n          }\n        });\n\n      Promise.all(allPromises).then((data) => {\n        const result = {};\n        let i = 0;\n        for (let key in valueObject) {\n          if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports, key) && data.length > i) {\n            if (valueObject[key] === '*' || valueObject[key] === 'all') {\n              result[key] = data[i];\n            } else {\n              let keys = valueObject[key];\n              let filter = '';\n              let filterParts = [];\n              // remove params\n              if (keys.indexOf(')') >= 0) {\n                keys = keys.split(')')[1].trim();\n              }\n              // extract filter and remove it from keys\n              if (keys.indexOf('|') >= 0) {\n                filter = keys.split('|')[1].trim();\n                filterParts = filter.split(':');\n\n                keys = keys.split('|')[0].trim();\n              }\n              keys = keys.replace(/,/g, ' ').replace(/ +/g, ' ').split(' ');\n              if (data[i]) {\n                if (Array.isArray(data[i])) {\n                  // result is in an array, go through all elements of array and pick only the right ones\n                  const partialArray = [];\n                  data[i].forEach(element => {\n                    let partialRes = {};\n                    if (keys.length === 1 && (keys[0] === '*' || keys[0] === 'all')) {\n                      partialRes = element;\n                    } else {\n                      keys.forEach(k => {\n                        if ({}.hasOwnProperty.call(element, k)) {\n                          partialRes[k] = element[k];\n                        }\n                      });\n                    }\n                    // if there is a filter, then just take those elements\n                    if (filter && filterParts.length === 2) {\n                      if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {\n                        const val = partialRes[filterParts[0].trim()];\n                        if (typeof val == 'number') {\n                          if (val === parseFloat(filterParts[1].trim())) {\n                            partialArray.push(partialRes);\n                          }\n                        } else if (typeof val == 'string') {\n                          if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {\n                            partialArray.push(partialRes);\n                          }\n                        }\n                      }\n                    } else {\n                      partialArray.push(partialRes);\n                    }\n\n                  });\n                  result[key] = partialArray;\n                } else {\n                  const partialRes = {};\n                  keys.forEach(k => {\n                    if ({}.hasOwnProperty.call(data[i], k)) {\n                      partialRes[k] = data[i][k];\n                    }\n                  });\n                  result[key] = partialRes;\n                }\n              } else {\n                result[key] = {};\n              }\n            }\n            i++;\n          }\n        }\n        if (callback) { callback(result); }\n        resolve(result);\n      });\n    });\n  });\n}\n\nfunction observe(valueObject, interval, callback) {\n  let _data = null;\n\n  const result = setInterval(() => {\n    get(valueObject).then((data) => {\n      if (JSON.stringify(_data) !== JSON.stringify(data)) {\n        _data = Object.assign({}, data);\n        callback(data);\n      }\n    });\n  }, interval);\n  return result;\n}\n\n// ----------------------------------------------------------------------------------\n// export all libs\n// ----------------------------------------------------------------------------------\n\nexports.version = version;\nexports.system = system.system;\nexports.bios = system.bios;\nexports.baseboard = system.baseboard;\nexports.chassis = system.chassis;\n\nexports.time = osInfo.time;\nexports.osInfo = osInfo.osInfo;\nexports.versions = osInfo.versions;\nexports.shell = osInfo.shell;\nexports.uuid = osInfo.uuid;\n\nexports.cpu = cpu.cpu;\nexports.cpuFlags = cpu.cpuFlags;\nexports.cpuCache = cpu.cpuCache;\nexports.cpuCurrentSpeed = cpu.cpuCurrentSpeed;\nexports.cpuTemperature = cpu.cpuTemperature;\nexports.currentLoad = cpu.currentLoad;\nexports.fullLoad = cpu.fullLoad;\n\nexports.mem = memory.mem;\nexports.memLayout = memory.memLayout;\n\nexports.battery = battery;\n\nexports.graphics = graphics.graphics;\n\nexports.fsSize = filesystem.fsSize;\nexports.fsOpenFiles = filesystem.fsOpenFiles;\nexports.blockDevices = filesystem.blockDevices;\nexports.fsStats = filesystem.fsStats;\nexports.disksIO = filesystem.disksIO;\nexports.diskLayout = filesystem.diskLayout;\n\nexports.networkInterfaceDefault = network.networkInterfaceDefault;\nexports.networkGatewayDefault = network.networkGatewayDefault;\nexports.networkInterfaces = network.networkInterfaces;\nexports.networkStats = network.networkStats;\nexports.networkConnections = network.networkConnections;\n\nexports.wifiNetworks = wifi.wifiNetworks;\nexports.wifiInterfaces = wifi.wifiInterfaces;\nexports.wifiConnections = wifi.wifiConnections;\n\nexports.services = processes.services;\nexports.processes = processes.processes;\nexports.processLoad = processes.processLoad;\n\nexports.users = users.users;\n\nexports.inetChecksite = internet.inetChecksite;\nexports.inetLatency = internet.inetLatency;\n\nexports.dockerInfo = docker.dockerInfo;\nexports.dockerImages = docker.dockerImages;\nexports.dockerContainers = docker.dockerContainers;\nexports.dockerContainerStats = docker.dockerContainerStats;\nexports.dockerContainerProcesses = docker.dockerContainerProcesses;\nexports.dockerVolumes = docker.dockerVolumes;\nexports.dockerAll = docker.dockerAll;\n\nexports.vboxInfo = vbox.vboxInfo;\n\nexports.printer = printer.printer;\n\nexports.usb = usb.usb;\n\nexports.audio = audio.audio;\nexports.bluetoothDevices = bluetooth.bluetoothDevices;\n\nexports.getStaticData = getStaticData;\nexports.getDynamicData = getDynamicData;\nexports.getAllData = getAllData;\nexports.get = get;\nexports.observe = observe;\n\nexports.powerShellStart = util.powerShellStart;\nexports.powerShellRelease = util.powerShellRelease;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\n// const exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: null\n      };\n      if (typeof url !== 'string') {\n        if (callback) { callback(result); }\n        return resolve(result);\n      }\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url, true);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      result.url = urlSanitized;\n      try {\n        if (urlSanitized && !util.isPrototypePolluted()) {\n          urlSanitized.__proto__.startsWith = util.stringStartWith;\n          if (urlSanitized.startsWith('file:') || urlSanitized.startsWith('gopher:') || urlSanitized.startsWith('telnet:') || urlSanitized.startsWith('mailto:') || urlSanitized.startsWith('news:') || urlSanitized.startsWith('nntp:')) {\n            if (callback) { callback(result); }\n            return resolve(result);\n          }\n          let t = Date.now();\n          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n            let args = ['-I', '--connect-timeout', '5', '-m', '5'];\n            args.push(urlSanitized);\n            let cmd = 'curl';\n            util.execSafe(cmd, args).then((stdout) => {\n              const lines = stdout.split('\\n');\n              let statusCode = lines[0] && lines[0].indexOf(' ') >= 0 ? parseInt(lines[0].split(' ')[1], 10) : 404;\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n              result.ms = (result.ok ? Date.now() - t : null);\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          }\n          if (_windows) {   // if this is stable, this can be used for all OS types\n            const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n            try {\n              http.get(urlSanitized, (res) => {\n                const statusCode = res.statusCode;\n\n                result.status = statusCode || 404;\n                result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n                if (statusCode !== 200) {\n                  res.resume();\n                  result.ms = (result.ok ? Date.now() - t : null);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  res.on('data', () => { });\n                  res.on('end', () => {\n                    result.ms = (result.ok ? Date.now() - t : null);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              }).on('error', () => {\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } catch (err) {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } catch (err) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof host !== 'string') {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let hostSanitized = '';\n      const s = (util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host, true)).trim();\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1]) {\n            hostSanitized = hostSanitized + sl[0];\n          }\n        }\n      }\n      hostSanitized.__proto__.startsWith = util.stringStartWith;\n      if (hostSanitized.startsWith('file:') || hostSanitized.startsWith('gopher:') || hostSanitized.startsWith('telnet:') || hostSanitized.startsWith('mailto:') || hostSanitized.startsWith('news:') || hostSanitized.startsWith('nntp:')) {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let params;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          params = ['-c', '2', '-w', '3', hostSanitized];\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          params = ['-c', '2', '-t', '3', hostSanitized];\n        }\n        if (_darwin) {\n          params = ['-c2', '-t3', hostSanitized];\n        }\n        util.execSafe('ping', params).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter((line) => (line.indexOf('rtt') >= 0 || line.indexOf('round-trip') >= 0 || line.indexOf('avg') >= 0)).join('\\n');\n\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        const params = ['-s', '-a', hostSanitized, '56', '2'];\n        const filt = 'avg';\n        util.execSafe('ping', params, { timeout: 3000 }).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = null;\n        try {\n          const params = [hostSanitized, '-n', '1'];\n          util.execSafe('ping', params, util.execOptsWin).then((stdout) => {\n            if (stdout) {\n              let lines = stdout.split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// memory.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 5. Memory\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\nconst fs = require('fs');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst OSX_RAM_manufacturers = {\n  '0x014F': 'Transcend Information',\n  '0x2C00': 'Micron Technology Inc.',\n  '0x802C': 'Micron Technology Inc.',\n  '0x80AD': 'Hynix Semiconductor Inc.',\n  '0x80CE': 'Samsung Electronics Inc.',\n  '0xAD00': 'Hynix Semiconductor Inc.',\n  '0xCE00': 'Samsung Electronics Inc.',\n  '0x02FE': 'Elpida',\n  '0x5105': 'Qimonda AG i. In.',\n  '0x8551': 'Qimonda AG i. In.',\n  '0x859B': 'Crucial',\n  '0x04CD': 'G-Skill'\n};\n\nconst LINUX_RAM_manufacturers = {\n  '017A': 'Apacer',\n  '0198': 'HyperX',\n  '029E': 'Corsair',\n  '04CB': 'A-DATA',\n  '04CD': 'G-Skill',\n  '059B': 'Crucial',\n  '00CE': 'Samsung',\n  '1315': 'Crutial',\n  '014F': 'Transcend Information',\n  '2C00': 'Micron Technology Inc.',\n  '802C': 'Micron Technology Inc.',\n  '80AD': 'Hynix Semiconductor Inc.',\n  '80CE': 'Samsung Electronics Inc.',\n  'AD00': 'Hynix Semiconductor Inc.',\n  'CE00': 'Samsung Electronics Inc.',\n  '02FE': 'Elpida',\n  '5105': 'Qimonda AG i. In.',\n  '8551': 'Qimonda AG i. In.',\n  '859B': 'Crucial'\n};\n\n// _______________________________________________________________________________________\n// |                         R A M                              |          H D           |\n// |______________________|_________________________|           |                        |\n// |        active             buffers/cache        |           |                        |\n// |________________________________________________|___________|_________|______________|\n// |                     used                            free   |   used       free      |\n// |____________________________________________________________|________________________|\n// |                        total                               |          swap          |\n// |____________________________________________________________|________________________|\n\n// free (older versions)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers     cached\n// Mem:         16038 (1)   15653 (2)   384 (3)  0 (4)     236 (5)     14788 (6)\n// -/+ buffers/cache:       628 (7)     15409 (8)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// | active (2-(5+6) = 7) |  available (3+5+6 = 8)              |\n// |______________________|_________________________|___________|\n// |        active        |  buffers/cache (5+6)    |           |\n// |________________________________________________|___________|\n// |                   used (2)                     | free (3)  |\n// |____________________________________________________________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n\n//\n// free (since free von procps-ng 3.3.10)\n// ----------------------------------\n// # free\n//              total       used        free     shared    buffers/cache   available\n// Mem:         16038 (1)   628 (2)     386 (3)  0 (4)     15024 (5)     14788 (6)\n// Swap:        16371         83      16288\n//\n// |------------------------------------------------------------|\n// |                           R A M                            |\n// |______________________|_____________________________________|\n// |                      |      available (6) estimated        |\n// |______________________|_________________________|___________|\n// |     active (2)       |   buffers/cache (5)     | free (3)  |\n// |________________________________________________|___________|\n// |                          total (1)                         |\n// |____________________________________________________________|\n//\n// Reference: http://www.software-architect.net/blog/article/date/2015/06/12/-826c6e5052.html\n\n// /procs/meminfo - sample (all in kB)\n//\n// MemTotal: 32806380 kB\n// MemFree: 17977744 kB\n// MemAvailable: 19768972 kB\n// Buffers: 517028 kB\n// Cached: 2161876 kB\n// SwapCached: 456 kB\n// Active: 12081176 kB\n// Inactive: 2164616 kB\n// Active(anon): 10832884 kB\n// Inactive(anon): 1477272 kB\n// Active(file): 1248292 kB\n// Inactive(file): 687344 kB\n// Unevictable: 0 kB\n// Mlocked: 0 kB\n// SwapTotal: 16768892 kB\n// SwapFree: 16768304 kB\n// Dirty: 268 kB\n// Writeback: 0 kB\n// AnonPages: 11568832 kB\n// Mapped: 719992 kB\n// Shmem: 743272 kB\n// Slab: 335716 kB\n// SReclaimable: 256364 kB\n// SUnreclaim: 79352 kB\n\nfunction mem(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        total: os.totalmem(),\n        free: os.freemem(),\n        used: os.totalmem() - os.freemem(),\n\n        active: os.totalmem() - os.freemem(),     // temporarily (fallback)\n        available: os.freemem(),                  // temporarily (fallback)\n        buffers: 0,\n        cached: 0,\n        slab: 0,\n        buffcache: 0,\n\n        swaptotal: 0,\n        swapused: 0,\n        swapfree: 0\n      };\n\n      if (_linux) {\n        fs.readFile('/proc/meminfo', function (error, stdout) {\n          if (!error) {\n            const lines = stdout.toString().split('\\n');\n            result.total = parseInt(util.getValue(lines, 'memtotal'), 10);\n            result.total = result.total ? result.total * 1024 : os.totalmem();\n            result.free = parseInt(util.getValue(lines, 'memfree'), 10);\n            result.free = result.free ? result.free * 1024 : os.freemem();\n            result.used = result.total - result.free;\n\n            result.buffers = parseInt(util.getValue(lines, 'buffers'), 10);\n            result.buffers = result.buffers ? result.buffers * 1024 : 0;\n            result.cached = parseInt(util.getValue(lines, 'cached'), 10);\n            result.cached = result.cached ? result.cached * 1024 : 0;\n            result.slab = parseInt(util.getValue(lines, 'slab'), 10);\n            result.slab = result.slab ? result.slab * 1024 : 0;\n            result.buffcache = result.buffers + result.cached + result.slab;\n\n            let available = parseInt(util.getValue(lines, 'memavailable'), 10);\n            result.available = available ? available * 1024 : result.free + result.buffcache;\n            result.active = result.total - result.available;\n\n            result.swaptotal = parseInt(util.getValue(lines, 'swaptotal'), 10);\n            result.swaptotal = result.swaptotal ? result.swaptotal * 1024 : 0;\n            result.swapfree = parseInt(util.getValue(lines, 'swapfree'), 10);\n            result.swapfree = result.swapfree ? result.swapfree * 1024 : 0;\n            result.swapused = result.swaptotal - result.swapfree;\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n            const pagesize = parseInt(util.getValue(lines, 'vm.stats.vm.v_page_size'), 10);\n            const inactive = parseInt(util.getValue(lines, 'vm.stats.vm.v_inactive_count'), 10) * pagesize;\n            const cache = parseInt(util.getValue(lines, 'vm.stats.vm.v_cache_count'), 10) * pagesize;\n\n            result.total = parseInt(util.getValue(lines, 'hw.realmem'), 10);\n            if (isNaN(result.total)) { result.total = parseInt(util.getValue(lines, 'hw.physmem'), 10); }\n            result.free = parseInt(util.getValue(lines, 'vm.stats.vm.v_free_count'), 10) * pagesize;\n            result.buffcache = inactive + cache;\n            result.available = result.buffcache + result.free;\n            result.active = result.total - result.free - result.buffcache;\n\n            result.swaptotal = 0;\n            result.swapfree = 0;\n            result.swapused = 0;\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_darwin) {\n        let pageSize = 4096;\n        try {\n          let sysPpageSize = util.toInt(execSync('sysctl -n vm.pagesize').toString());\n          pageSize = sysPpageSize || pageSize;\n        } catch (e) {\n          util.noop();\n        }\n        exec('vm_stat 2>/dev/null | grep \"Pages active\"', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().split('\\n');\n\n            result.active = parseInt(lines[0].split(':')[1], 10) * pageSize;\n            result.buffcache = result.used - result.active;\n            result.available = result.free + result.buffcache;\n          }\n          exec('sysctl -n vm.swapusage 2>/dev/null', function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              if (lines.length > 0) {\n                let firstline = lines[0].replace(/,/g, '.').replace(/M/g, '');\n                let lineArray = firstline.trim().split('  ');\n                lineArray.forEach(line => {\n                  if (line.toLowerCase().indexOf('total') !== -1) { result.swaptotal = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('used') !== -1) { result.swapused = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                  if (line.toLowerCase().indexOf('free') !== -1) { result.swapfree = parseFloat(line.split('=')[1].trim()) * 1024 * 1024; }\n                });\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      }\n      if (_windows) {\n        let swaptotal = 0;\n        let swapused = 0;\n        try {\n          util.powerShell('Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n').filter(line => line.trim() !== '').filter((line, idx) => idx > 0);\n              lines.forEach(function (line) {\n                if (line !== '') {\n                  line = line.trim().split(/\\s\\s+/);\n                  swaptotal = swaptotal + (parseInt(line[0], 10) || 0);\n                  swapused = swapused + (parseInt(line[1], 10) || 0);\n                }\n              });\n            }\n            result.swaptotal = swaptotal * 1024 * 1024;\n            result.swapused = swapused * 1024 * 1024;\n            result.swapfree = result.swaptotal - result.swapused;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.mem = mem;\n\nfunction memLayout(callback) {\n\n  function getManufacturerDarwin(manId) {\n    if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {\n      return (OSX_RAM_manufacturers[manId]);\n    }\n    return manId;\n  }\n\n  function getManufacturerLinux(manId) {\n    const manIdSearch = manId.replace('0x', '').toUpperCase();\n    if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {\n      return (LINUX_RAM_manufacturers[manIdSearch]);\n    }\n    return manId;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = [];\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE \"Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number\"; unset LC_ALL', function (error, stdout) {\n          if (!error) {\n            let devices = stdout.toString().split('Memory Device');\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const sizeString = util.getValue(lines, 'Size');\n              const size = sizeString.indexOf('GB') >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;\n              let bank = util.getValue(lines, 'Bank Locator');\n              if (bank.toLowerCase().indexOf('bad') >= 0) {\n                bank = '';\n              }\n              if (parseInt(util.getValue(lines, 'Size'), 10) > 0) {\n                const totalWidth = util.toInt(util.getValue(lines, 'Total Width'));\n                const dataWidth = util.toInt(util.getValue(lines, 'Data Width'));\n                result.push({\n                  size,\n                  bank,\n                  type: util.getValue(lines, 'Type:'),\n                  ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                  clockSpeed: (util.getValue(lines, 'Configured Clock Speed:') ? parseInt(util.getValue(lines, 'Configured Clock Speed:'), 10) : (util.getValue(lines, 'Speed:') ? parseInt(util.getValue(lines, 'Speed:'), 10) : null)),\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  manufacturer: getManufacturerLinux(util.getValue(lines, 'Manufacturer:')),\n                  partNum: util.getValue(lines, 'Part Number:'),\n                  serialNum: util.getValue(lines, 'Serial Number:'),\n                  voltageConfigured: parseFloat(util.getValue(lines, 'Configured Voltage:')) || null,\n                  voltageMin: parseFloat(util.getValue(lines, 'Minimum Voltage:')) || null,\n                  voltageMax: parseFloat(util.getValue(lines, 'Maximum Voltage:')) || null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: util.getValue(lines, 'Form Factor:'),\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            result.push({\n              size: os.totalmem(),\n              bank: '',\n              type: '',\n              ecc: null,\n              clockSpeed: 0,\n              formFactor: '',\n              partNum: '',\n              serialNum: '',\n              voltageConfigured: null,\n              voltageMin: null,\n              voltageMax: null,\n            });\n\n            // Try Raspberry PI\n            try {\n              let stdout = execSync('cat /proc/cpuinfo 2>/dev/null');\n              let lines = stdout.toString().split('\\n');\n              let model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n              let version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n\n              if (model === 'BCM2835' || model === 'BCM2708' || model === 'BCM2709' || model === 'BCM2835' || model === 'BCM2837') {\n\n                const clockSpeed = {\n                  '0': 400,\n                  '1': 450,\n                  '2': 450,\n                  '3': 3200\n                };\n                result[0].type = 'LPDDR2';\n                result[0].type = version && version[2] && version[2] === '3' ? 'LPDDR4' : result[0].type;\n                result[0].ecc = false;\n                result[0].clockSpeed = version && version[2] && clockSpeed[version[2]] || 400;\n                result[0].clockSpeed = version && version[4] && version[4] === 'd' ? 500 : result[0].clockSpeed;\n                result[0].formFactor = 'SoC';\n\n                stdout = execSync('vcgencmd get_config sdram_freq 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let freq = parseInt(util.getValue(lines, 'sdram_freq', '=', true), 10) || 0;\n                if (freq) {\n                  result[0].clockSpeed = freq;\n                }\n\n                stdout = execSync('vcgencmd measure_volts sdram_p 2>/dev/null');\n                lines = stdout.toString().split('\\n');\n                let voltage = parseFloat(util.getValue(lines, 'volt', '=', true)) || 0;\n                if (voltage) {\n                  result[0].voltageConfigured = voltage;\n                  result[0].voltageMin = voltage;\n                  result[0].voltageMax = voltage;\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('system_profiler SPMemoryDataType', function (error, stdout) {\n          if (!error) {\n            const allLines = stdout.toString().split('\\n');\n            const eccStatus = util.getValue(allLines, 'ecc', ':', true).toLowerCase();\n            let devices = stdout.toString().split('        BANK ');\n            let hasBank = true;\n            if (devices.length === 1) {\n              devices = stdout.toString().split('        DIMM');\n              hasBank = false;\n            }\n            devices.shift();\n            devices.forEach(function (device) {\n              let lines = device.split('\\n');\n              const bank = (hasBank ? 'BANK ' : 'DIMM') + lines[0].trim().split('/')[0];\n              const size = parseInt(util.getValue(lines, '          Size'));\n              if (size) {\n                result.push({\n                  size: size * 1024 * 1024 * 1024,\n                  bank: bank,\n                  type: util.getValue(lines, '          Type:'),\n                  ecc: eccStatus ? eccStatus === 'enabled' : null,\n                  clockSpeed: parseInt(util.getValue(lines, '          Speed:'), 10),\n                  formFactor: '',\n                  manufacturer: getManufacturerDarwin(util.getValue(lines, '          Manufacturer:')),\n                  partNum: util.getValue(lines, '          Part Number:'),\n                  serialNum: util.getValue(lines, '          Serial Number:'),\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              } else {\n                result.push({\n                  size: 0,\n                  bank: bank,\n                  type: 'Empty',\n                  ecc: null,\n                  clockSpeed: 0,\n                  formFactor: '',\n                  manufacturer: '',\n                  partNum: '',\n                  serialNum: '',\n                  voltageConfigured: null,\n                  voltageMin: null,\n                  voltageMax: null,\n                });\n              }\n            });\n          }\n          if (!result.length) {\n            const lines = stdout.toString().split('\\n');\n            const size = parseInt(util.getValue(lines, '      Memory:'));\n            const type = util.getValue(lines, '      Type:');\n            if (size && type) {\n              result.push({\n                size: size * 1024 * 1024 * 1024,\n                bank: '0',\n                type,\n                ecc: false,\n                clockSpeed: 0,\n                formFactor: '',\n                manufacturer: 'Apple',\n                partNum: '',\n                serialNum: '',\n                voltageConfigured: null,\n                voltageMin: null,\n                voltageMax: null,\n              });\n\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        const memoryTypes = 'Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4'.split('|');\n        const FormFactors = 'Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA'.split('|');\n\n        try {\n          util.powerShell('Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage | fl').then((stdout, error) => {\n            if (!error) {\n              let devices = stdout.toString().split(/\\n\\s*\\n/);\n              devices.shift();\n              devices.forEach(function (device) {\n                let lines = device.split('\\r\\n');\n                const dataWidth = util.toInt(util.getValue(lines, 'DataWidth', ':'));\n                const totalWidth = util.toInt(util.getValue(lines, 'TotalWidth', ':'));\n                const size = parseInt(util.getValue(lines, 'Capacity', ':'), 10) || 0;\n                if (size) {\n                  result.push({\n                    size,\n                    bank: util.getValue(lines, 'BankLabel', ':'), // BankLabel\n                    type: memoryTypes[parseInt(util.getValue(lines, 'MemoryType', ':'), 10) || parseInt(util.getValue(lines, 'SMBIOSMemoryType', ':'), 10)],\n                    ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,\n                    clockSpeed: parseInt(util.getValue(lines, 'ConfiguredClockSpeed', ':'), 10) || parseInt(util.getValue(lines, 'Speed', ':'), 10) || 0,\n                    formFactor: FormFactors[parseInt(util.getValue(lines, 'FormFactor', ':'), 10) || 0],\n                    manufacturer: util.getValue(lines, 'Manufacturer', ':'),\n                    partNum: util.getValue(lines, 'PartNumber', ':'),\n                    serialNum: util.getValue(lines, 'SerialNumber', ':'),\n                    voltageConfigured: (parseInt(util.getValue(lines, 'ConfiguredVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMin: (parseInt(util.getValue(lines, 'MinVoltage', ':'), 10) || 0) / 1000.0,\n                    voltageMax: (parseInt(util.getValue(lines, 'MaxVoltage', ':'), 10) || 0) / 1000.0,\n                  });\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.memLayout = memLayout;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _network = {};\nlet _default_iface = '';\nlet _ifaces = {};\nlet _dhcpNics = [];\nlet _networkInterfaces = [];\nlet _mac = {};\nlet pathToIp;\n\nfunction getDefaultNetworkInterface() {\n\n  let ifacename = '';\n  let ifacenameFirst = '';\n  try {\n    let ifaces = os.networkInterfaces();\n\n    let scopeid = 9999;\n\n    // fallback - \"first\" external interface (sorted by scopeid)\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.internal === false) {\n            ifacenameFirst = ifacenameFirst || dev; // fallback if no scopeid\n            if (details.scopeid && details.scopeid < scopeid) {\n              ifacename = dev;\n              scopeid = details.scopeid;\n            }\n          }\n        });\n      }\n    }\n    ifacename = ifacename || ifacenameFirst || '';\n\n    if (_windows) {\n      // https://www.inetdaemon.com/tutorials/internet/ip/routing/default_route.shtml\n      let defaultIp = '';\n      const cmd = 'netstat -r';\n      const result = execSync(cmd, util.execOptsWin);\n      const lines = result.toString().split(os.EOL);\n      lines.forEach(line => {\n        line = line.replace(/\\s+/g, ' ').trim();\n        if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n          const parts = line.split(' ');\n          if (parts.length >= 5) {\n            defaultIp = parts[parts.length - 2];\n          }\n        }\n      });\n      if (defaultIp) {\n        for (let dev in ifaces) {\n          if ({}.hasOwnProperty.call(ifaces, dev)) {\n            ifaces[dev].forEach(function (details) {\n              if (details && details.address && details.address === defaultIp) {\n                ifacename = dev;\n              }\n            });\n          }\n        }\n      }\n    }\n    if (_linux) {\n      let cmd = 'ip route 2> /dev/null | grep default';\n      let result = execSync(cmd);\n      let parts = result.toString().split('\\n')[0].split(/\\s+/);\n      if (parts[0] === 'none' && parts[5]) {\n        ifacename = parts[5];\n      } else if (parts[4]) {\n        ifacename = parts[4];\n      }\n\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n    if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {\n      let cmd = '';\n      if (_linux) { cmd = 'ip route 2> /dev/null | grep default | awk \\'{print $5}\\''; }\n      if (_darwin) { cmd = 'route -n get default 2>/dev/null | grep interface: | awk \\'{print $2}\\''; }\n      if (_freebsd || _openbsd || _netbsd || _sunos) { cmd = 'route get 0.0.0.0 | grep interface:'; }\n      let result = execSync(cmd);\n      ifacename = result.toString().split('\\n')[0];\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n  } catch (e) {\n    util.noop();\n  }\n  if (ifacename) { _default_iface = ifacename; }\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  let iface = '';\n  let mac = '';\n  let result = {};\n  if (_linux || _freebsd || _openbsd || _netbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        const lines = execSync('which ip').toString().split('\\n');\n        if (lines.length && lines[0].indexOf(':') === -1 && lines[0].indexOf('/') === 0) {\n          pathToIp = lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n    try {\n      const cmd = 'export LC_ALL=C; ' + ((pathToIp) ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== ' ') {\n          if (pathToIp) {\n            let nextline = lines[i + 1].trim().split(' ');\n            if (nextline[0] === 'link/ether') {\n              iface = lines[i].split(' ')[1];\n              iface = iface.slice(0, iface.length - 1);\n              mac = nextline[1];\n            }\n          } else {\n            iface = lines[i].split(' ')[0];\n            mac = lines[i].split('HWaddr ')[1];\n          }\n\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_darwin) {\n    try {\n      const cmd = '/sbin/ifconfig';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== '\\t' && lines[i].indexOf(':') > 0) {\n          iface = lines[i].split(':')[0];\n        } else if (lines[i].indexOf('\\tether ') === 0) {\n          mac = lines[i].split('\\tether ')[1];\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction parseLinesWindowsNics(sections, nconfigsections) {\n  let nics = [];\n  for (let i in sections) {\n    if ({}.hasOwnProperty.call(sections, i)) {\n\n      if (sections[i].trim() !== '') {\n\n        let lines = sections[i].trim().split('\\r\\n');\n        let linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split('\\r\\n') : [];\n        let netEnabled = util.getValue(lines, 'NetEnabled', ':');\n        let adapterType = util.getValue(lines, 'AdapterTypeID', ':') === '9' ? 'wireless' : 'wired';\n        let ifacename = util.getValue(lines, 'Name', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        let iface = util.getValue(lines, 'NetConnectionID', ':').replace(/\\]/g, ')').replace(/\\[/g, '(');\n        if (ifacename.toLowerCase().indexOf('wi-fi') >= 0 || ifacename.toLowerCase().indexOf('wireless') >= 0) {\n          adapterType = 'wireless';\n        }\n        if (netEnabled !== '') {\n          const speed = parseInt(util.getValue(lines, 'speed', ':').trim(), 10) / 1000000;\n          nics.push({\n            mac: util.getValue(lines, 'MACAddress', ':').toLowerCase(),\n            dhcp: util.getValue(linesNicConfig, 'dhcpEnabled', ':').toLowerCase() === 'true',\n            name: ifacename,\n            iface,\n            netEnabled: netEnabled === 'TRUE',\n            speed: isNaN(speed) ? null : speed,\n            operstate: util.getValue(lines, 'NetConnectionStatus', ':') === '2' ? 'up' : 'down',\n            type: adapterType\n          });\n        }\n      }\n    }\n  }\n  return nics;\n}\n\nfunction getWindowsNics() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let cmd = 'Get-CimInstance Win32_NetworkAdapter | fl *' + '; echo \\'#-#-#-#\\';';\n      cmd += 'Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled' + '';\n      try {\n        util.powerShell(cmd).then((data) => {\n          data = data.split('#-#-#-#');\n          const nsections = (data[0] || '').split(/\\n\\s*\\n/);\n          const nconfigsections = (data[1] || '').split(/\\n\\s*\\n/);\n          resolve(parseLinesWindowsNics(nsections, nconfigsections));\n        });\n      } catch (e) {\n        resolve([]);\n      }\n    });\n  });\n}\n\nfunction getWindowsDNSsuffixes() {\n\n  let iface = {};\n\n  let dnsSuffixes = {\n    primaryDNS: '',\n    exitCode: 0,\n    ifaces: [],\n  };\n\n  try {\n    const ipconfig = execSync('ipconfig /all', util.execOptsWin);\n    const ipconfigArray = ipconfig.split('\\r\\n\\r\\n');\n\n    ipconfigArray.forEach((element, index) => {\n\n      if (index == 1) {\n        const longPrimaryDNS = element.split('\\r\\n').filter((element) => {\n          return element.toUpperCase().includes('DNS');\n        });\n        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(':') + 1);\n        dnsSuffixes.primaryDNS = primaryDNS.trim();\n        if (!dnsSuffixes.primaryDNS) { dnsSuffixes.primaryDNS = 'Not defined'; }\n      }\n      if (index > 1) {\n        if (index % 2 == 0) {\n          const name = element.substring(element.lastIndexOf(' ') + 1).replace(':', '');\n          iface.name = name;\n        } else {\n          const connectionSpecificDNS = element.split('\\r\\n').filter((element) => {\n            return element.toUpperCase().includes('DNS');\n          });\n          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(':') + 1);\n          iface.dnsSuffix = dnsSuffix.trim();\n          dnsSuffixes.ifaces.push(iface);\n          iface = {};\n        }\n      }\n    });\n\n    return dnsSuffixes;\n  } catch (error) {\n    return {\n      primaryDNS: '',\n      exitCode: 0,\n      ifaces: [],\n    };\n  }\n}\n\nfunction getWindowsIfaceDNSsuffix(ifaces, ifacename) {\n  let dnsSuffix = '';\n  // Adding (.) to ensure ifacename compatibility when duplicated iface-names\n  const interfaceName = ifacename + '.';\n  try {\n    const connectionDnsSuffix = ifaces.filter((iface) => {\n      return interfaceName.includes(iface.name + '.');\n    }).map((iface) => iface.dnsSuffix);\n    if (connectionDnsSuffix[0]) {\n      dnsSuffix = connectionDnsSuffix[0];\n    }\n    if (!dnsSuffix) { dnsSuffix = ''; }\n    return dnsSuffix;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\n\nfunction getWindowsWiredProfilesInformation() {\n  try {\n    const result = execSync('netsh lan show profiles', util.execOptsWin);\n    const profileList = result.split('\\r\\nProfile on interface');\n    return profileList;\n  } catch (error) {\n    if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n      return 'Disabled';\n    }\n    return [];\n  }\n}\n\nfunction getWindowsWirelessIfaceSSID(interfaceName) {\n  try {\n    const result = execSync(`netsh wlan show  interface name=\"${interfaceName}\" | findstr \"SSID\"`, util.execOptsWin);\n    const SSID = result.split('\\r\\n').shift();\n    const parseSSID = SSID.split(':').pop();\n    return parseSSID;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\nfunction getWindowsIEEE8021x(connectionType, iface, ifaces) {\n  let i8021x = {\n    state: 'Unknown',\n    protocol: 'Unknown',\n  };\n\n  if (ifaces === 'Disabled') {\n    i8021x.state = 'Disabled';\n    i8021x.protocol = 'Not defined';\n    return i8021x;\n  }\n\n  if (connectionType == 'wired' && ifaces.length > 0) {\n    try {\n      // Get 802.1x information by interface name\n      const iface8021xInfo = ifaces.find((element) => {\n        return element.includes(iface + '\\r\\n');\n      });\n      const arrayIface8021xInfo = iface8021xInfo.split('\\r\\n');\n      const state8021x = arrayIface8021xInfo.find((element) => {\n        return element.includes('802.1x');\n      });\n\n      if (state8021x.includes('Disabled')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      } else if (state8021x.includes('Enabled')) {\n        const protocol8021x = arrayIface8021xInfo.find((element) => {\n          return element.includes('EAP');\n        });\n        i8021x.protocol = protocol8021x.split(':').pop();\n        i8021x.state = 'Enabled';\n      }\n    } catch (error) {\n      return i8021x;\n    }\n  } else if (connectionType == 'wireless') {\n\n    let i8021xState = '';\n    let i8021xProtocol = '';\n\n\n\n    try {\n      const SSID = getWindowsWirelessIfaceSSID(iface);\n      if (SSID !== 'Unknown') {\n        i8021xState = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"802.1X\"`, util.execOptsWin);\n        i8021xProtocol = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"EAP\"`, util.execOptsWin);\n      }\n\n      if (i8021xState.includes(':') && i8021xProtocol.includes(':')) {\n        i8021x.state = i8021xState.split(':').pop();\n        i8021x.protocol = i8021xProtocol.split(':').pop();\n      }\n    } catch (error) {\n      if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      }\n      return i8021x;\n    }\n  }\n\n  return i8021x;\n}\n\nfunction splitSectionsNics(lines) {\n  const result = [];\n  let section = [];\n  lines.forEach(function (line) {\n    if (!line.startsWith('\\t') && !line.startsWith(' ')) {\n      if (section.length) {\n        result.push(section);\n        section = [];\n      }\n    }\n    section.push(line);\n  });\n  if (section.length) {\n    result.push(section);\n  }\n  return result;\n}\n\nfunction parseLinesDarwinNics(sections) {\n  let nics = [];\n  sections.forEach(section => {\n    let nic = {\n      iface: '',\n      mtu: null,\n      mac: '',\n      ip6: '',\n      ip4: '',\n      speed: null,\n      type: '',\n      operstate: '',\n      duplex: '',\n      internal: false\n    };\n    const first = section[0];\n    nic.iface = first.split(':')[0].trim();\n    let parts = first.split('> mtu');\n    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : null;\n    if (isNaN(nic.mtu)) {\n      nic.mtu = null;\n    }\n    nic.internal = parts[0].toLowerCase().indexOf('loopback') > -1;\n    section.forEach(line => {\n      if (line.trim().startsWith('ether ')) {\n        nic.mac = line.split('ether ')[1].toLowerCase().trim();\n      }\n      if (line.trim().startsWith('inet6 ') && !nic.ip6) {\n        nic.ip6 = line.split('inet6 ')[1].toLowerCase().split('%')[0].split(' ')[0];\n      }\n      if (line.trim().startsWith('inet ') && !nic.ip4) {\n        nic.ip4 = line.split('inet ')[1].toLowerCase().split(' ')[0];\n      }\n    });\n    let speed = util.getValue(section, 'link rate');\n    nic.speed = speed ? parseFloat(speed) : null;\n    if (nic.speed === null) {\n      speed = util.getValue(section, 'uplink rate');\n      nic.speed = speed ? parseFloat(speed) : null;\n      if (nic.speed !== null && speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    } else {\n      if (speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    }\n    nic.type = util.getValue(section, 'type').toLowerCase().indexOf('wi-fi') > -1 ? 'wireless' : 'wired';\n    const operstate = util.getValue(section, 'status').toLowerCase();\n    nic.operstate = (operstate === 'active' ? 'up' : (operstate === 'inactive' ? 'down' : 'unknown'));\n    nic.duplex = util.getValue(section, 'media').toLowerCase().indexOf('half-duplex') > -1 ? 'half' : 'full';\n    if (nic.ip6 || nic.ip4 || nic.mac) {\n      nics.push(nic);\n    }\n  });\n  return nics;\n}\n\nfunction getDarwinNics() {\n  const cmd = '/sbin/ifconfig -v';\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    return (parseLinesDarwinNics(nsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getLinuxIfaceConnectionName(interfaceName) {\n  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;\n\n  try {\n    const result = execSync(cmd).toString();\n    const resultFormat = result.replace(/\\s+/g, ' ').trim();\n    const connectionNameLines = resultFormat.split(' ').slice(3);\n    const connectionName = connectionNameLines.join(' ');\n    return connectionName != '--' ? connectionName : '';\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction checkLinuxDCHPInterfaces(file) {\n  let result = [];\n  try {\n    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\\\|source'`;\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n\n    lines.forEach(line => {\n      const parts = line.replace(/\\s+/g, ' ').trim().split(' ');\n      if (parts.length >= 4) {\n        if (line.toLowerCase().indexOf(' inet ') >= 0 && line.toLowerCase().indexOf('dhcp') >= 0) {\n          result.push(parts[1]);\n        }\n      }\n      if (line.toLowerCase().includes('source')) {\n        let file = line.split(' ')[1];\n        result = result.concat(checkLinuxDCHPInterfaces(file));\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxDHCPNics() {\n  // alternate methods getting interfaces using DHCP\n  let cmd = 'ip a 2> /dev/null';\n  let result = [];\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    result = (parseLinuxDHCPNics(nsections));\n  } catch (e) {\n    util.noop();\n  }\n  try {\n    result = checkLinuxDCHPInterfaces('/etc/network/interfaces');\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction parseLinuxDHCPNics(sections) {\n  const result = [];\n  if (sections && sections.length) {\n    sections.forEach(lines => {\n      if (lines && lines.length) {\n        const parts = lines[0].split(':');\n        if (parts.length > 2) {\n          for (let line of lines) {\n            if (line.indexOf(' inet ') >= 0 && line.indexOf(' dynamic ') >= 0) {\n              const parts2 = line.split(' ');\n              const nic = parts2[parts2.length - 1].trim();\n              result.push(nic);\n              break;\n            }\n          }\n        }\n      }\n    });\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {\n  let result = false;\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.method;`;\n    try {\n      const lines = execSync(cmd).toString();\n      const resultFormat = lines.replace(/\\s+/g, ' ').trim();\n\n      let dhcStatus = resultFormat.split(' ').slice(1).toString();\n      switch (dhcStatus) {\n        case 'auto':\n          result = true;\n          break;\n\n        default:\n          result = false;\n          break;\n      }\n      return result;\n    } catch (e) {\n      return (DHCPNics.indexOf(iface) >= 0);\n    }\n  } else {\n    return (DHCPNics.indexOf(iface) >= 0);\n  }\n}\n\nfunction getDarwinIfaceDHCPstatus(iface) {\n  let result = false;\n  const cmd = `ipconfig getpacket \"${iface}\" 2>/dev/null | grep lease_time;`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    if (lines.length && lines[0].startsWith('lease_time')) {\n      result = true;\n    }\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDNSsuffix(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep ipv4.dns-search;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const dnsSuffix = resultFormat.split(' ').slice(1).toString();\n      return dnsSuffix == '--' ? 'Not defined' : dnsSuffix;\n    } catch (e) {\n      return 'Unknown';\n    }\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xAuth(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null | grep 802-1x.eap;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const authenticationProtocol = resultFormat.split(' ').slice(1).toString();\n\n\n      return authenticationProtocol == '--' ? '' : authenticationProtocol;\n    } catch (e) {\n      return 'Not defined';\n    }\n  } else {\n    return 'Not defined';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xState(authenticationProtocol) {\n  if (authenticationProtocol) {\n    if (authenticationProtocol == 'Not defined') {\n      return 'Disabled';\n    }\n    return 'Enabled';\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction testVirtualNic(iface, ifaceName, mac) {\n  const virtualMacs = ['00:00:00:00:00:00', '00:03:FF', '00:05:69', '00:0C:29', '00:0F:4B', '00:0F:4B', '00:13:07', '00:13:BE', '00:15:5d', '00:16:3E', '00:1C:42', '00:21:F6', '00:21:F6', '00:24:0B', '00:24:0B', '00:50:56', '00:A0:B1', '00:E0:C8', '08:00:27', '0A:00:27', '18:92:2C', '16:DF:49', '3C:F3:92', '54:52:00', 'FC:15:97'];\n  if (mac) {\n    return virtualMacs.filter(item => { return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length)); }).length > 0 ||\n      iface.toLowerCase().indexOf(' virtual ') > -1 ||\n      ifaceName.toLowerCase().indexOf(' virtual ') > -1 ||\n      iface.toLowerCase().indexOf('vethernet ') > -1 ||\n      ifaceName.toLowerCase().indexOf('vethernet ') > -1 ||\n      iface.toLowerCase().startsWith('veth') ||\n      ifaceName.toLowerCase().startsWith('veth') ||\n      iface.toLowerCase().startsWith('vboxnet') ||\n      ifaceName.toLowerCase().startsWith('vboxnet');\n  } else { return false; }\n}\n\nfunction networkInterfaces(callback, rescan, defaultString) {\n\n  if (typeof callback === 'string') {\n    defaultString = callback;\n    rescan = true;\n    callback = null;\n  }\n\n  if (typeof callback === 'boolean') {\n    rescan = callback;\n    callback = null;\n    defaultString = '';\n  }\n  if (typeof rescan === 'undefined') {\n    rescan = true;\n  }\n  defaultString = defaultString || '';\n  defaultString = '' + defaultString;\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let ifaces = os.networkInterfaces();\n\n      let result = [];\n      let nics = [];\n      let dnsSuffixes = [];\n      let nics8021xInfo = [];\n      // seperate handling in OSX\n      if (_darwin || _freebsd || _openbsd || _netbsd) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          const defaultInterface = getDefaultNetworkInterface();\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n\n          nics = getDarwinNics();\n\n\n          nics.forEach(nic => {\n\n            if ({}.hasOwnProperty.call(ifaces, nic.iface)) {\n              ifaces[nic.iface].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  nic.ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  nic.ip6subnet = details.netmask;\n                }\n              });\n            }\n\n            let ifaceSanitized = '';\n            const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(nic.iface);\n            for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n              if (s[i] !== undefined) {\n                ifaceSanitized = ifaceSanitized + s[i];\n              }\n            }\n\n            result.push({\n              iface: nic.iface,\n              ifaceName: nic.iface,\n              default: nic.iface === defaultInterface,\n              ip4: nic.ip4,\n              ip4subnet: nic.ip4subnet || '',\n              ip6: nic.ip6,\n              ip6subnet: nic.ip6subnet || '',\n              mac: nic.mac,\n              internal: nic.internal,\n              virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),\n              operstate: nic.operstate,\n              type: nic.type,\n              duplex: nic.duplex,\n              mtu: nic.mtu,\n              speed: nic.speed,\n              dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),\n              dnsSuffix: '',\n              ieee8021xAuth: '',\n              ieee8021xState: '',\n              carrierChanges: 0\n            });\n          });\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_linux) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          _dhcpNics = getLinuxDHCPNics();\n          const defaultInterface = getDefaultNetworkInterface();\n          for (let dev in ifaces) {\n            let ip4 = '';\n            let ip4subnet = '';\n            let ip6 = '';\n            let ip6subnet = '';\n            let mac = '';\n            let duplex = '';\n            let mtu = '';\n            let speed = null;\n            let carrierChanges = 0;\n            let dhcp = false;\n            let dnsSuffix = '';\n            let ieee8021xAuth = '';\n            let ieee8021xState = '';\n            let type = '';\n\n            if ({}.hasOwnProperty.call(ifaces, dev)) {\n              let ifaceName = dev;\n              ifaces[dev].forEach(function (details) {\n                if (details.family === 'IPv4' || details.family === 4) {\n                  ip4 = details.address;\n                  ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6' || details.family === 6) {\n                  if (!ip6 || ip6.match(/^fe80::/i)) {\n                    ip6 = details.address;\n                    ip6subnet = details.netmask;\n                  }\n                }\n                mac = details.mac;\n                // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                  if (Object.keys(_mac).length === 0) {\n                    _mac = getMacAddresses();\n                  }\n                  mac = _mac[dev] || '';\n                }\n              });\n              let iface = dev.split(':')[0].trim().toLowerCase();\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n              const cmd = `echo -n \"addr_assign_type: \"; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;\n            echo -n \"address: \"; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;\n            echo -n \"addr_len: \"; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;\n            echo -n \"broadcast: \"; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;\n            echo -n \"carrier: \"; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;\n            echo -n \"carrier_changes: \"; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;\n            echo -n \"dev_id: \"; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;\n            echo -n \"dev_port: \"; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;\n            echo -n \"dormant: \"; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;\n            echo -n \"duplex: \"; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;\n            echo -n \"flags: \"; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;\n            echo -n \"gro_flush_timeout: \"; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;\n            echo -n \"ifalias: \"; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;\n            echo -n \"ifindex: \"; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;\n            echo -n \"iflink: \"; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;\n            echo -n \"link_mode: \"; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;\n            echo -n \"mtu: \"; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;\n            echo -n \"netdev_group: \"; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;\n            echo -n \"operstate: \"; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;\n            echo -n \"proto_down: \"; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;\n            echo -n \"speed: \"; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;\n            echo -n \"tx_queue_len: \"; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;\n            echo -n \"type: \"; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;\n            echo -n \"wireless: \"; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;\n            echo -n \"wirelessspeed: \"; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;\n\n              let lines = [];\n              try {\n                lines = execSync(cmd).toString().split('\\n');\n                const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);\n                dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);\n                dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);\n                ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);\n                ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);\n              } catch (e) {\n                util.noop();\n              }\n              duplex = util.getValue(lines, 'duplex');\n              duplex = duplex.startsWith('cat') ? '' : duplex;\n              mtu = parseInt(util.getValue(lines, 'mtu'), 10);\n              let myspeed = parseInt(util.getValue(lines, 'speed'), 10);\n              speed = isNaN(myspeed) ? null : myspeed;\n              let wirelessspeed = util.getValue(lines, 'wirelessspeed').split('tx bitrate: ');\n              if (speed === null && wirelessspeed.length === 2) {\n                myspeed = parseFloat(wirelessspeed[1]);\n                speed = isNaN(myspeed) ? null : myspeed;\n              }\n              carrierChanges = parseInt(util.getValue(lines, 'carrier_changes'), 10);\n              const operstate = util.getValue(lines, 'operstate');\n              type = operstate === 'up' ? (util.getValue(lines, 'wireless').trim() ? 'wireless' : 'wired') : 'unknown';\n              if (ifaceSanitized === 'lo' || ifaceSanitized.startsWith('bond')) { type = 'virtual'; }\n\n              let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n              if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                internal = true;\n              }\n              const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n              result.push({\n                iface: ifaceSanitized,\n                ifaceName,\n                default: iface === defaultInterface,\n                ip4,\n                ip4subnet,\n                ip6,\n                ip6subnet,\n                mac,\n                internal,\n                virtual,\n                operstate,\n                type,\n                duplex,\n                mtu,\n                speed,\n                dhcp,\n                dnsSuffix,\n                ieee8021xAuth,\n                ieee8021xState,\n                carrierChanges,\n              });\n            }\n          }\n          _networkInterfaces = result;\n          if (defaultString.toLowerCase().indexOf('default') >= 0) {\n            result = result.filter(item => item.default);\n            if (result.length > 0) {\n              result = result[0];\n            } else {\n              result = [];\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = JSON.parse(JSON.stringify(ifaces));\n          const defaultInterface = getDefaultNetworkInterface();\n\n          getWindowsNics().then(function (nics) {\n            nics.forEach(nic => {\n              let found = false;\n              Object.keys(ifaces).forEach(key => {\n                if (!found) {\n                  ifaces[key].forEach(value => {\n                    if (Object.keys(value).indexOf('mac') >= 0) {\n                      found = value['mac'] === nic.mac;\n                    }\n                  });\n                }\n              });\n\n              if (!found) {\n                ifaces[nic.name] = [{ mac: nic.mac }];\n              }\n            });\n            nics8021xInfo = getWindowsWiredProfilesInformation();\n            dnsSuffixes = getWindowsDNSsuffixes();\n            for (let dev in ifaces) {\n\n              let ifaceSanitized = '';\n              const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(dev);\n              for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n                if (s[i] !== undefined) {\n                  ifaceSanitized = ifaceSanitized + s[i];\n                }\n              }\n\n              let iface = dev;\n              let ip4 = '';\n              let ip4subnet = '';\n              let ip6 = '';\n              let ip6subnet = '';\n              let mac = '';\n              let duplex = '';\n              let mtu = '';\n              let speed = null;\n              let carrierChanges = 0;\n              let operstate = 'down';\n              let dhcp = false;\n              let dnsSuffix = '';\n              let ieee8021xAuth = '';\n              let ieee8021xState = '';\n              let type = '';\n\n              if ({}.hasOwnProperty.call(ifaces, dev)) {\n                let ifaceName = dev;\n                ifaces[dev].forEach(function (details) {\n                  if (details.family === 'IPv4' || details.family === 4) {\n                    ip4 = details.address;\n                    ip4subnet = details.netmask;\n                  }\n                  if (details.family === 'IPv6' || details.family === 6) {\n                    if (!ip6 || ip6.match(/^fe80::/i)) {\n                      ip6 = details.address;\n                      ip6subnet = details.netmask;\n                    }\n                  }\n                  mac = details.mac;\n                  // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                  const nodeMainVersion = parseInt(process.versions.node.split('.'), 10);\n                  if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && (!details.internal) && nodeMainVersion >= 8 && nodeMainVersion <= 11) {\n                    if (Object.keys(_mac).length === 0) {\n                      _mac = getMacAddresses();\n                    }\n                    mac = _mac[dev] || '';\n                  }\n                });\n\n\n\n                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);\n                let foundFirst = false;\n                nics.forEach(detail => {\n                  if (detail.mac === mac && !foundFirst) {\n                    iface = detail.iface || iface;\n                    ifaceName = detail.name;\n                    dhcp = detail.dhcp;\n                    operstate = detail.operstate;\n                    speed = detail.speed;\n                    type = detail.type;\n                    foundFirst = true;\n                  }\n                });\n\n                if (dev.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('802.11n') >= 0 || ifaceName.toLowerCase().indexOf('wireless') >= 0 || ifaceName.toLowerCase().indexOf('wi-fi') >= 0 || ifaceName.toLowerCase().indexOf('wifi') >= 0) {\n                  type = 'wireless';\n                }\n\n                const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);\n                ieee8021xAuth = IEEE8021x.protocol;\n                ieee8021xState = IEEE8021x.state;\n                let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n                if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                  internal = true;\n                }\n                const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n                result.push({\n                  iface,\n                  ifaceName,\n                  default: iface === defaultInterface,\n                  ip4,\n                  ip4subnet,\n                  ip6,\n                  ip6subnet,\n                  mac,\n                  internal,\n                  virtual,\n                  operstate,\n                  type,\n                  duplex,\n                  mtu,\n                  speed,\n                  dhcp,\n                  dnsSuffix,\n                  ieee8021xAuth,\n                  ieee8021xState,\n                  carrierChanges,\n                });\n              }\n            }\n            _networkInterfaces = result;\n            if (defaultString.toLowerCase().indexOf('default') >= 0) {\n              result = result.filter(item => item.default);\n              if (result.length > 0) {\n                result = result[0];\n              } else {\n                result = [];\n              }\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {\n  let result = {\n    iface,\n    operstate,\n    rx_bytes,\n    rx_dropped,\n    rx_errors,\n    tx_bytes,\n    tx_dropped,\n    tx_errors,\n    rx_sec: null,\n    tx_sec: null,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx_bytes - _network[iface].rx_bytes) >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;\n    result.tx_sec = (tx_bytes - _network[iface].tx_bytes) >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) { _network[iface] = {}; }\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = null;\n    _network[iface].tx_sec = null;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n  return result;\n}\n\nfunction networkStats(ifaces, callback) {\n\n  let ifacesArray = [];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      // fallback - if only callback is given\n      if (util.isFunction(ifaces) && !callback) {\n        callback = ifaces;\n        ifacesArray = [getDefaultNetworkInterface()];\n      } else {\n        if (typeof ifaces !== 'string' && ifaces !== undefined) {\n          if (callback) { callback([]); }\n          return resolve([]);\n        }\n        ifaces = ifaces || getDefaultNetworkInterface();\n\n        ifaces.__proto__.toLowerCase = util.stringToLower;\n        ifaces.__proto__.replace = util.stringReplace;\n        ifaces.__proto__.trim = util.stringTrim;\n\n        ifaces = ifaces.trim().toLowerCase().replace(/,+/g, '|');\n        ifacesArray = ifaces.split('|');\n      }\n\n      const result = [];\n\n      const workload = [];\n      if (ifacesArray.length && ifacesArray[0].trim() === '*') {\n        ifacesArray = [];\n        networkInterfaces(false).then(allIFaces => {\n          for (let iface of allIFaces) {\n            ifacesArray.push(iface.iface);\n          }\n          networkStats(ifacesArray.join(',')).then(result => {\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      } else {\n        for (let iface of ifacesArray) {\n          workload.push(networkStatsSingle(iface.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then((data) => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction networkStatsSingle(iface) {\n\n  function parseLinesWindowsPerfData(sections) {\n    let perfData = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', ':').replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase(),\n            rx_bytes: parseInt(util.getValue(lines, 'BytesReceivedPersec', ':'), 10),\n            rx_errors: parseInt(util.getValue(lines, 'PacketsReceivedErrors', ':'), 10),\n            rx_dropped: parseInt(util.getValue(lines, 'PacketsReceivedDiscarded', ':'), 10),\n            tx_bytes: parseInt(util.getValue(lines, 'BytesSentPersec', ':'), 10),\n            tx_errors: parseInt(util.getValue(lines, 'PacketsOutboundErrors', ':'), 10),\n            tx_dropped: parseInt(util.getValue(lines, 'PacketsOutboundDiscarded', ':'), 10)\n          });\n        }\n      }\n    }\n    return perfData;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaceSanitized = '';\n      const s = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          ifaceSanitized = ifaceSanitized + s[i];\n        }\n      }\n\n      let result = {\n        iface: ifaceSanitized,\n        operstate: 'unknown',\n        rx_bytes: 0,\n        rx_dropped: 0,\n        rx_errors: 0,\n        tx_bytes: 0,\n        tx_dropped: 0,\n        tx_errors: 0,\n        rx_sec: null,\n        tx_sec: null,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx_bytes = 0;\n      let tx_bytes = 0;\n      let rx_dropped = 0;\n      let rx_errors = 0;\n      let tx_dropped = 0;\n      let tx_errors = 0;\n\n      let cmd, lines, stats;\n      if (!_network[ifaceSanitized] || (_network[ifaceSanitized] && !_network[ifaceSanitized].ms) || (_network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + ifaceSanitized)) {\n            cmd =\n              'cat /sys/class/net/' + ifaceSanitized + '/operstate; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_errors; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_errors; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx_bytes = parseInt(lines[1], 10);\n                tx_bytes = parseInt(lines[2], 10);\n                rx_dropped = parseInt(lines[3], 10);\n                rx_errors = parseInt(lines[4], 10);\n                tx_dropped = parseInt(lines[5], 10);\n                tx_errors = parseInt(lines[6], 10);\n\n                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n\n              }\n              resolve(result);\n            });\n          } else {\n            resolve(result);\n          }\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'netstat -ibndI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n              for (let i = 1; i < lines.length; i++) {\n                const line = lines[i].replace(/ +/g, ' ').split(' ');\n                if (line && line[0] && line[7] && line[10]) {\n                  rx_bytes = rx_bytes + parseInt(line[7]);\n                  if (line[6].trim() !== '-') { rx_dropped = rx_dropped + parseInt(line[6]); }\n                  if (line[5].trim() !== '-') { rx_errors = rx_errors + parseInt(line[5]); }\n                  tx_bytes = tx_bytes + parseInt(line[10]);\n                  if (line[12].trim() !== '-') { tx_dropped = tx_dropped + parseInt(line[12]); }\n                  if (line[9].trim() !== '-') { tx_errors = tx_errors + parseInt(line[9]); }\n                  operstate = 'up';\n                }\n              }\n              result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n            }\n            resolve(result);\n          });\n        }\n        if (_darwin) {\n          cmd = 'ifconfig ' + ifaceSanitized + ' | grep \"status\"';    // lgtm [js/shell-command-constructed-from-input]\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = 'netstat -bdI ' + ifaceSanitized;   // lgtm [js/shell-command-constructed-from-input]\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  const offset = stats.length > 11 ? 1 : 0;\n                  rx_bytes = parseInt(stats[offset + 5]);\n                  rx_dropped = parseInt(stats[offset + 10]);\n                  rx_errors = parseInt(stats[offset + 4]);\n                  tx_bytes = parseInt(stats[offset + 8]);\n                  tx_dropped = parseInt(stats[offset + 10]);\n                  tx_errors = parseInt(stats[offset + 7]);\n                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n                }\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_windows) {\n          let perfData = [];\n          let ifaceName = ifaceSanitized;\n\n          // Performance Data\n          util.powerShell('Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl').then((stdout, error) => {\n            if (!error) {\n              const psections = stdout.toString().split(/\\n\\s*\\n/);\n              perfData = parseLinesWindowsPerfData(psections);\n            }\n\n            // Network Interfaces\n            networkInterfaces(false).then(interfaces => {\n              // get bytes sent, received from perfData by name\n              rx_bytes = 0;\n              tx_bytes = 0;\n              perfData.forEach(detail => {\n                interfaces.forEach(det => {\n                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.mac.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === ifaceSanitized.replace(/[()[\\] ]+/g, '').replace('#', '_').toLowerCase()) &&\n                    (det.ifaceName.replace(/[()[\\] ]+/g, '').replace(/#|\\//g, '_').toLowerCase() === detail.name)) {\n                    ifaceName = det.iface;\n                    rx_bytes = detail.rx_bytes;\n                    rx_dropped = detail.rx_dropped;\n                    rx_errors = detail.rx_errors;\n                    tx_bytes = detail.tx_bytes;\n                    tx_dropped = detail.tx_dropped;\n                    tx_errors = detail.tx_errors;\n                    operstate = det.operstate;\n                  }\n                });\n              });\n              if (rx_bytes && tx_bytes) {\n                result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n              }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx_bytes = _network[ifaceSanitized].rx_bytes;\n        result.tx_bytes = _network[ifaceSanitized].tx_bytes;\n        result.rx_sec = _network[ifaceSanitized].rx_sec;\n        result.tx_sec = _network[ifaceSanitized].tx_sec;\n        result.ms = _network[ifaceSanitized].last_ms;\n        result.operstate = _network[ifaceSanitized].operstate;\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction getProcessName(processes, pid) {\n  let cmd = '';\n  processes.forEach(line => {\n    const parts = line.split(' ');\n    const id = parseInt(parts[0], 10) || -1;\n    if (id === pid) {\n      parts.shift();\n      cmd = parts.join(' ').split(':')[0];\n    }\n  });\n  cmd = cmd.split(' -')[0];\n  // return cmd;\n  const cmdParts = cmd.split('/');\n  return cmdParts[cmdParts.length - 1];\n}\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'export LC_ALL=C; netstat -tunap | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL'; }\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          if (!error && (lines.length > 1 || lines[0] != '')) {\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 7) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                let proc = line[6].split('/');\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localAddress: localip,\n                    localPort: localport,\n                    peerAddress: peerip,\n                    peerPort: peerport,\n                    state: connstate,\n                    pid: proc[0] && proc[0] !== '-' ? parseInt(proc[0], 10) : null,\n                    process: proc[1] ? proc[1].split(' ')[0].split(':')[0] : ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            cmd = 'ss -tunap | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') { connstate = 'ESTABLISHED'; }\n                    if (connstate === 'TIME-WAIT') { connstate = 'TIME_WAIT'; }\n                    let pid = null;\n                    let process = '';\n                    if (line.length >= 7 && line[6].indexOf('users:') > -1) {\n                      let proc = line[6].replace('users:((\"', '').replace(/\"/g, '').split(',');\n                      if (proc.length > 2) {\n                        process = proc[0].split(' ')[0].split(':')[0];\n                        pid = parseInt(proc[1], 10);\n                      }\n                    }\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localAddress: localip,\n                        localPort: localport,\n                        peerAddress: peerip,\n                        peerPort: peerport,\n                        state: connstate,\n                        pid,\n                        process\n                      });\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        // let cmd = 'netstat -natv | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        let cmd = 'netstat -natv | grep \"tcp4\\\\|tcp6\\\\|udp4\\\\|udp6\"';\n        const states = 'ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          if (!error) {\n            exec('ps -axo pid,command', { maxBuffer: 1024 * 20000 }, function (err2, stdout2) {\n              let processes = stdout2.toString().split('\\n');\n              processes = processes.map((line => { return line.trim().replace(/ +/g, ' '); }));\n              let lines = stdout.toString().split('\\n');\n\n              lines.forEach(function (line) {\n                line = line.replace(/ +/g, ' ').split(' ');\n                if (line.length >= 8) {\n                  let localip = line[3];\n                  let localport = '';\n                  let localaddress = line[3].split('.');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join('.');\n                  }\n                  let peerip = line[4];\n                  let peerport = '';\n                  let peeraddress = line[4].split('.');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join('.');\n                  }\n                  const hasState = states.indexOf(line[5]) >= 0;\n                  let connstate = hasState ? line[5] : 'UNKNOWN';\n                  let pid = parseInt(line[8 + (hasState ? 0 : -1)], 10);\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0],\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid: pid,\n                      process: getProcessName(processes, pid)\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n\n          }\n        });\n      }\n      if (_windows) {\n        let cmd = 'netstat -nao';\n        try {\n          exec(cmd, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n\n              let lines = stdout.toString().split('\\r\\n');\n\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n                if (line.length >= 4) {\n                  let localip = line[1];\n                  let localport = '';\n                  let localaddress = line[1].split(':');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n                  localip = localip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let peerip = line[2];\n                  let peerport = '';\n                  let peeraddress = line[2].split(':');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n                  peerip = peerip.replace(/\\[/g, '').replace(/\\]/g, '');\n                  let pid = util.toInt(line[4]);\n                  let connstate = line[3];\n                  if (connstate === 'HERGESTELLT') { connstate = 'ESTABLISHED'; }\n                  if (connstate.startsWith('ABH')) { connstate = 'LISTEN'; }\n                  if (connstate === 'SCHLIESSEN_WARTEN') { connstate = 'CLOSE_WAIT'; }\n                  if (connstate === 'WARTEND') { connstate = 'TIME_WAIT'; }\n                  if (connstate === 'SYN_GESENDET') { connstate = 'SYN_SENT'; }\n\n                  if (connstate === 'LISTENING') { connstate = 'LISTEN'; }\n                  if (connstate === 'SYN_RECEIVED') { connstate = 'SYN_RECV'; }\n                  if (connstate === 'FIN_WAIT_1') { connstate = 'FIN_WAIT1'; }\n                  if (connstate === 'FIN_WAIT_2') { connstate = 'FIN_WAIT2'; }\n                  if (line[0].toLowerCase() !== 'udp' && connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: connstate,\n                      pid,\n                      process: ''\n                    });\n                  } else if (line[0].toLowerCase() === 'udp') {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localAddress: localip,\n                      localPort: localport,\n                      peerAddress: peerip,\n                      peerPort: peerport,\n                      state: '',\n                      pid: parseInt(line[3], 10),\n                      process: ''\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n\nfunction networkGatewayDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'ip route get 1';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              const line = lines && lines[0] ? lines[0] : '';\n              let parts = line.split(' via ');\n              if (parts && parts[1]) {\n                parts = parts[1].split(' ');\n                result = parts[0];\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        let cmd = 'route -n get default';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n').map(line => line.trim());\n              result = util.getValue(lines, 'gateway');\n            }\n            if (!result) {\n              cmd = 'netstat -rn | awk \\'/default/ {print $2}\\'';\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                const lines = stdout.toString().split('\\n').map(line => line.trim());\n                result = lines.find(line => (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line)));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        try {\n          exec('netstat -r', util.execOptsWin, function (error, stdout) {\n            const lines = stdout.toString().split(os.EOL);\n            lines.forEach(line => {\n              line = line.replace(/\\s+/g, ' ').trim();\n              if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n                const parts = line.split(' ');\n                if (parts.length >= 5 && (parts[parts.length - 3]).indexOf('.') > -1) {\n                  result = parts[parts.length - 3];\n                }\n              }\n            });\n            if (!result) {\n              util.powerShell('Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \\'0.0.0.0\\' -and $_.Mask -eq \\'0.0.0.0\\' }')\n                .then((data) => {\n                  let lines = data.toString().split('\\r\\n');\n                  if (lines.length > 1 && !result) {\n                    result = util.getValue(lines, 'NextHop');\n                    if (callback) {\n                      callback(result);\n                    }\n                    resolve(result);\n                    // } else {\n                    //   exec('ipconfig', util.execOptsWin, function (error, stdout) {\n                    //     let lines = stdout.toString().split('\\r\\n');\n                    //     lines.forEach(function (line) {\n                    //       line = line.trim().replace(/\\. /g, '');\n                    //       line = line.trim().replace(/ +/g, '');\n                    //       const parts = line.split(':');\n                    //       if ((parts[0].toLowerCase().startsWith('standardgate') || parts[0].toLowerCase().indexOf('gateway') > -1 || parts[0].toLowerCase().indexOf('enlace') > -1) && parts[1]) {\n                    //         result = parts[1];\n                    //       }\n                    //     });\n                    //     if (callback) { callback(result); }\n                    //     resolve(result);\n                    //   });\n                  }\n                });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkGatewayDefault = networkGatewayDefault;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// osinfo.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 3. Operating System\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// Get current time and OS uptime\n\nfunction time() {\n  let t = new Date().toString().split(' ');\n  return {\n    current: Date.now(),\n    uptime: os.uptime(),\n    timezone: (t.length >= 7) ? t[5] : '',\n    timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : (t.length >= 7) ? t.slice(6).join(' ').replace(/\\(/g, '').replace(/\\)/g, '') : ''\n  };\n}\n\nexports.time = time;\n\n// --------------------------\n// Get logo filename of OS distribution\n\nfunction getLogoFile(distro) {\n  distro = distro || '';\n  distro = distro.toLowerCase();\n  let result = _platform;\n  if (_windows) {\n    result = 'windows';\n  }\n  else if (distro.indexOf('mac os') !== -1) {\n    result = 'apple';\n  }\n  else if (distro.indexOf('arch') !== -1) {\n    result = 'arch';\n  }\n  else if (distro.indexOf('centos') !== -1) {\n    result = 'centos';\n  }\n  else if (distro.indexOf('coreos') !== -1) {\n    result = 'coreos';\n  }\n  else if (distro.indexOf('debian') !== -1) {\n    result = 'debian';\n  }\n  else if (distro.indexOf('deepin') !== -1) {\n    result = 'deepin';\n  }\n  else if (distro.indexOf('elementary') !== -1) {\n    result = 'elementary';\n  }\n  else if (distro.indexOf('fedora') !== -1) {\n    result = 'fedora';\n  }\n  else if (distro.indexOf('gentoo') !== -1) {\n    result = 'gentoo';\n  }\n  else if (distro.indexOf('mageia') !== -1) {\n    result = 'mageia';\n  }\n  else if (distro.indexOf('mandriva') !== -1) {\n    result = 'mandriva';\n  }\n  else if (distro.indexOf('manjaro') !== -1) {\n    result = 'manjaro';\n  }\n  else if (distro.indexOf('mint') !== -1) {\n    result = 'mint';\n  }\n  else if (distro.indexOf('mx') !== -1) {\n    result = 'mx';\n  }\n  else if (distro.indexOf('openbsd') !== -1) {\n    result = 'openbsd';\n  }\n  else if (distro.indexOf('freebsd') !== -1) {\n    result = 'freebsd';\n  }\n  else if (distro.indexOf('opensuse') !== -1) {\n    result = 'opensuse';\n  }\n  else if (distro.indexOf('pclinuxos') !== -1) {\n    result = 'pclinuxos';\n  }\n  else if (distro.indexOf('puppy') !== -1) {\n    result = 'puppy';\n  }\n  else if (distro.indexOf('raspbian') !== -1) {\n    result = 'raspbian';\n  }\n  else if (distro.indexOf('reactos') !== -1) {\n    result = 'reactos';\n  }\n  else if (distro.indexOf('redhat') !== -1) {\n    result = 'redhat';\n  }\n  else if (distro.indexOf('slackware') !== -1) {\n    result = 'slackware';\n  }\n  else if (distro.indexOf('sugar') !== -1) {\n    result = 'sugar';\n  }\n  else if (distro.indexOf('steam') !== -1) {\n    result = 'steam';\n  }\n  else if (distro.indexOf('suse') !== -1) {\n    result = 'suse';\n  }\n  else if (distro.indexOf('mate') !== -1) {\n    result = 'ubuntu-mate';\n  }\n  else if (distro.indexOf('lubuntu') !== -1) {\n    result = 'lubuntu';\n  }\n  else if (distro.indexOf('xubuntu') !== -1) {\n    result = 'xubuntu';\n  }\n  else if (distro.indexOf('ubuntu') !== -1) {\n    result = 'ubuntu';\n  }\n  else if (distro.indexOf('solaris') !== -1) {\n    result = 'solaris';\n  }\n  else if (distro.indexOf('tails') !== -1) {\n    result = 'tails';\n  }\n  else if (distro.indexOf('feren') !== -1) {\n    result = 'ferenos';\n  }\n  else if (distro.indexOf('robolinux') !== -1) {\n    result = 'robolinux';\n  } else if (_linux && distro) {\n    result = distro.toLowerCase().trim().replace(/\\s+/g, '-');\n  }\n  return result;\n}\n\n// --------------------------\n// FQDN\n\nfunction getFQDN() {\n  let fqdn = os.hostname;\n  if (_linux || _darwin) {\n    try {\n      const stdout = execSync('hostname -f');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_freebsd || _openbsd || _netbsd) {\n    try {\n      const stdout = execSync('hostname');\n      fqdn = stdout.toString().split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_windows) {\n    try {\n      const stdout = execSync('echo %COMPUTERNAME%.%USERDNSDOMAIN%', util.execOptsWin);\n      fqdn = stdout.toString().replace('.%USERDNSDOMAIN%', '').split(os.EOL)[0];\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return fqdn;\n}\n\n// --------------------------\n// OS Information\n\nfunction osInfo(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n\n        platform: (_platform === 'win32' ? 'Windows' : _platform),\n        distro: 'unknown',\n        release: 'unknown',\n        codename: '',\n        kernel: os.release(),\n        arch: os.arch(),\n        hostname: os.hostname(),\n        fqdn: getFQDN(),\n        codepage: '',\n        logofile: '',\n        serial: '',\n        build: '',\n        servicepack: '',\n        uefi: false\n      };\n\n      if (_linux) {\n\n        exec('cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release', function (error, stdout) {\n          /**\n           * @namespace\n           * @property {string}  DISTRIB_ID\n           * @property {string}  NAME\n           * @property {string}  DISTRIB_RELEASE\n           * @property {string}  VERSION_ID\n           * @property {string}  DISTRIB_CODENAME\n           */\n          let release = {};\n          let lines = stdout.toString().split('\\n');\n          lines.forEach(function (line) {\n            if (line.indexOf('=') !== -1) {\n              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();\n            }\n          });\n          let releaseVersion = (release.VERSION || '').replace(/\"/g, '');\n          let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || '').replace(/\"/g, '');\n          if (releaseVersion.indexOf('(') >= 0) {\n            codename = releaseVersion.split('(')[1].replace(/[()]/g, '').trim();\n            releaseVersion = releaseVersion.split('(')[0].trim();\n          }\n          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/\"/g, '');\n          result.logofile = getLogoFile(result.distro);\n          result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/\"/g, '');\n          result.codename = codename;\n          result.codepage = util.getCodepage();\n          result.build = (release.BUILD_ID || '').replace(/\"/g, '').trim();\n          isUefiLinux().then(uefi => {\n            result.uefi = uefi;\n            uuid().then((data) => {\n              result.serial = data.os;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n\n        exec('sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          const distro = util.getValue(lines, 'kern.ostype');\n          const logofile = util.getValue(lines, 'kern.ostype');\n          const release = util.getValue(lines, 'kern.osrelease').split('-')[0];\n          const serial = util.getValue(lines, 'kern.uuid');\n          const bootmethod = util.getValue(lines, 'machdep.bootmethod');\n          const uefiConf = stdout.toString().indexOf('<type>efi</type>') >= 0;\n          const uefi = bootmethod ? bootmethod.toLowerCase().indexOf('uefi') >= 0 : (uefiConf ? uefiConf : null);\n          result.distro = distro || result.distro;\n          result.logofile = logofile || result.logofile;\n          result.release = release || result.release;\n          result.serial = serial || result.serial;\n          result.codename = '';\n          result.codepage = util.getCodepage();\n          result.uefi = uefi || null;\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.serial = util.getValue(lines, 'kern.uuid');\n          result.distro = util.getValue(lines, 'ProductName');\n          result.release = util.getValue(lines, 'ProductVersion');\n          result.build = util.getValue(lines, 'BuildVersion');\n          result.logofile = getLogoFile(result.distro);\n          result.codename = 'macOS';\n          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);\n          result.codename = (result.release.indexOf('10.5') > -1 ? 'Mac OS X Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.6') > -1 ? 'Mac OS X Snow Leopard' : result.codename);\n          result.codename = (result.release.indexOf('10.7') > -1 ? 'Mac OS X Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.8') > -1 ? 'OS X Mountain Lion' : result.codename);\n          result.codename = (result.release.indexOf('10.9') > -1 ? 'OS X Mavericks' : result.codename);\n          result.codename = (result.release.indexOf('10.10') > -1 ? 'OS X Yosemite' : result.codename);\n          result.codename = (result.release.indexOf('10.11') > -1 ? 'OS X El Capitan' : result.codename);\n          result.codename = (result.release.indexOf('10.12') > -1 ? 'macOS Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.13') > -1 ? 'macOS High Sierra' : result.codename);\n          result.codename = (result.release.indexOf('10.14') > -1 ? 'macOS Mojave' : result.codename);\n          result.codename = (result.release.indexOf('10.15') > -1 ? 'macOS Catalina' : result.codename);\n          result.codename = (result.release.startsWith('11.') ? 'macOS Big Sur' : result.codename);\n          result.codename = (result.release.startsWith('12.') ? 'macOS Monterey' : result.codename);\n          result.codename = (result.release.startsWith('13.') ? 'macOS Ventura' : result.codename);\n          result.uefi = true;\n          result.codepage = util.getCodepage();\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        result.release = result.kernel;\n        exec('uname -o', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.distro = lines[0];\n          result.logofile = getLogoFile(result.distro);\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        result.logofile = getLogoFile();\n        result.release = result.kernel;\n        try {\n          const workload = [];\n          workload.push(util.powerShell('Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl'));\n          workload.push(util.powerShell('(Get-CimInstance Win32_ComputerSystem).HypervisorPresent'));\n          workload.push(util.powerShell('Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession'));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n            result.distro = util.getValue(lines, 'Caption', ':').trim();\n            result.serial = util.getValue(lines, 'SerialNumber', ':').trim();\n            result.build = util.getValue(lines, 'BuildNumber', ':').trim();\n            result.servicepack = util.getValue(lines, 'ServicePackMajorVersion', ':').trim() + '.' + util.getValue(lines, 'ServicePackMinorVersion', ':').trim();\n            result.codepage = util.getCodepage();\n            const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : '';\n            result.hypervisor = hyperv.indexOf('true') !== -1;\n            const term = data.results[2] ? data.results[2].toString() : '';\n            result.remoteSession = (term.toString().toLowerCase().indexOf('true') >= 0);\n            isUefiWindows().then(uefi => {\n              result.uefi = uefi;\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.osInfo = osInfo;\n\nfunction isUefiLinux() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      fs.stat('/sys/firmware/efi', function (err) {\n        if (!err) {\n          return resolve(true);\n        } else {\n          exec('dmesg | grep -E \"EFI v\"', function (error, stdout) {\n            if (!error) {\n              const lines = stdout.toString().split('\\n');\n              return resolve(lines.length > 0);\n            }\n            return resolve(false);\n          });\n        }\n      });\n    });\n  });\n}\n\nfunction isUefiWindows() {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec('findstr /C:\"Detected boot environment\" \"%windir%\\\\Panther\\\\setupact.log\"', util.execOptsWin, function (error, stdout) {\n          if (!error) {\n            const line = stdout.toString().split('\\n\\r')[0];\n            return resolve(line.toLowerCase().indexOf('efi') >= 0);\n          } else {\n            exec('echo %firmware_type%', util.execOptsWin, function (error, stdout) {\n              if (!error) {\n                const line = stdout.toString() || '';\n                return resolve(line.toLowerCase().indexOf('efi') >= 0);\n              } else {\n                return resolve(false);\n              }\n            });\n          }\n        });\n      } catch (e) {\n        return resolve(false);\n      }\n    });\n  });\n}\n\nfunction versions(apps, callback) {\n  let versionObject = {\n    kernel: os.release(),\n    openssl: '',\n    systemOpenssl: '',\n    systemOpensslLib: '',\n    node: process.versions.node,\n    v8: process.versions.v8,\n    npm: '',\n    yarn: '',\n    pm2: '',\n    gulp: '',\n    grunt: '',\n    git: '',\n    tsc: '',\n    mysql: '',\n    redis: '',\n    mongodb: '',\n    apache: '',\n    nginx: '',\n    php: '',\n    docker: '',\n    postfix: '',\n    postgresql: '',\n    perl: '',\n    python: '',\n    python3: '',\n    pip: '',\n    pip3: '',\n    java: '',\n    gcc: '',\n    virtualbox: '',\n    bash: '',\n    zsh: '',\n    fish: '',\n    powershell: '',\n    dotnet: ''\n  };\n\n  function checkVersionParam(apps) {\n    if (apps === '*') {\n      return {\n        versions: versionObject,\n        counter: 30\n      };\n    }\n    if (!Array.isArray(apps)) {\n      apps = apps.trim().toLowerCase().replace(/,+/g, '|').replace(/ /g, '|');\n      apps = apps.split('|');\n      const result = {\n        versions: {},\n        counter: 0\n      };\n      apps.forEach(el => {\n        if (el) {\n          for (let key in versionObject) {\n            if ({}.hasOwnProperty.call(versionObject, key)) {\n              if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result.versions, key)) {\n                result.versions[key] = versionObject[key];\n                if (key === 'openssl') {\n                  result.versions.systemOpenssl = '';\n                  result.versions.systemOpensslLib = '';\n                }\n\n                if (!result.versions[key]) { result.counter++; }\n              }\n            }\n          }\n        }\n      });\n      return result;\n    }\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (util.isFunction(apps) && !callback) {\n        callback = apps;\n        apps = '*';\n      } else {\n        apps = apps || '*';\n        if (typeof apps !== 'string') {\n          if (callback) { callback({}); }\n          return resolve({});\n        }\n      }\n      const appsObj = checkVersionParam(apps);\n      let totalFunctions = appsObj.counter;\n\n      let functionProcessed = (function () {\n        return function () {\n          if (--totalFunctions === 0) {\n            if (callback) {\n              callback(appsObj.versions);\n            }\n            resolve(appsObj.versions);\n          }\n        };\n      })();\n\n      let cmd = '';\n      try {\n        if ({}.hasOwnProperty.call(appsObj.versions, 'openssl')) {\n          appsObj.versions.openssl = process.versions.openssl;\n          exec('openssl version', function (error, stdout) {\n            if (!error) {\n              let openssl_string = stdout.toString().split('\\n')[0].trim();\n              let openssl = openssl_string.split(' ');\n              appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];\n              appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : 'openssl';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'npm')) {\n          exec('npm -v', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.npm = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pm2')) {\n          cmd = 'pm2';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} -v`, function (error, stdout) {\n            if (!error) {\n              let pm2 = stdout.toString().split('\\n')[0].trim();\n              if (!pm2.startsWith('[PM2]')) {\n                appsObj.versions.pm2 = pm2;\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'yarn')) {\n          exec('yarn --version', function (error, stdout) {\n            if (!error) {\n              appsObj.versions.yarn = stdout.toString().split('\\n')[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gulp')) {\n          cmd = 'gulp';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const gulp = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.gulp = (gulp.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'tsc')) {\n          cmd = 'tsc';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const tsc = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.tsc = (tsc.toLowerCase().split('version')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'grunt')) {\n          cmd = 'grunt';\n          if (_windows) {\n            cmd += '.cmd';\n          }\n          exec(`${cmd} --version`, function (error, stdout) {\n            if (!error) {\n              const grunt = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.grunt = (grunt.toLowerCase().split('cli v')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'git')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/git') || fs.existsSync('/opt/homebrew/bin/git');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('git --version', function (error, stdout) {\n                if (!error) {\n                  let git = stdout.toString().split('\\n')[0] || '';\n                  git = (git.toLowerCase().split('version')[1] || '').trim();\n                  appsObj.versions.git = (git.split(' ')[0] || '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('git --version', function (error, stdout) {\n              if (!error) {\n                let git = stdout.toString().split('\\n')[0] || '';\n                git = (git.toLowerCase().split('version')[1] || '').trim();\n                appsObj.versions.git = (git.split(' ')[0] || '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'apache')) {\n          exec('apachectl -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const apache = (stdout.toString().split('\\n')[0] || '').split(':');\n              appsObj.versions.apache = (apache.length > 1 ? apache[1].replace('Apache', '').replace('/', '').split('(')[0].trim() : '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'nginx')) {\n          exec('nginx -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const nginx = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.nginx = (nginx.toLowerCase().split('/')[1] || '').trim();\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mysql')) {\n          exec('mysql -V', function (error, stdout) {\n            if (!error) {\n              let mysql = stdout.toString().split('\\n')[0] || '';\n              mysql = mysql.toLowerCase();\n              if (mysql.indexOf(',') > -1) {\n                mysql = (mysql.split(',')[0] || '').trim();\n                const parts = mysql.split(' ');\n                appsObj.versions.mysql = (parts[parts.length - 1] || '').trim();\n              } else {\n                if (mysql.indexOf(' ver ') > -1) {\n                  mysql = mysql.split(' ver ')[1];\n                  appsObj.versions.mysql = mysql.split(' ')[0];\n                }\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'php')) {\n          exec('php -v', function (error, stdout) {\n            if (!error) {\n              const php = stdout.toString().split('\\n')[0] || '';\n              let parts = php.split('(');\n              if (parts[0].indexOf('-')) {\n                parts = parts[0].split('-');\n              }\n              appsObj.versions.php = parts[0].replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'redis')) {\n          exec('redis-server --version', function (error, stdout) {\n            if (!error) {\n              const redis = stdout.toString().split('\\n')[0] || '';\n              const parts = redis.split(' ');\n              appsObj.versions.redis = util.getValue(parts, 'v', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'docker')) {\n          exec('docker --version', function (error, stdout) {\n            if (!error) {\n              const docker = stdout.toString().split('\\n')[0] || '';\n              const parts = docker.split(' ');\n              appsObj.versions.docker = parts.length > 2 && parts[2].endsWith(',') ? parts[2].slice(0, -1) : '';\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postfix')) {\n          exec('postconf -d | grep mail_version', function (error, stdout) {\n            if (!error) {\n              const postfix = stdout.toString().split('\\n') || [];\n              appsObj.versions.postfix = util.getValue(postfix, 'mail_version', '=', true);\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'mongodb')) {\n          exec('mongod --version', function (error, stdout) {\n            if (!error) {\n              const mongodb = stdout.toString().split('\\n')[0] || '';\n              appsObj.versions.mongodb = (mongodb.toLowerCase().split(',')[0] || '').replace(/[^0-9.]/g, '');\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'postgresql')) {\n          if (_linux) {\n            exec('locate bin/postgres', function (error, stdout) {\n              if (!error) {\n                const postgresqlBin = stdout.toString().split('\\n').sort();\n                if (postgresqlBin.length) {\n                  exec(postgresqlBin[postgresqlBin.length - 1] + ' -V', function (error, stdout) {\n                    if (!error) {\n                      const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    }\n                    functionProcessed();\n                  });\n                } else {\n                  functionProcessed();\n                }\n              } else {\n                exec('psql -V', function (error, stdout) {\n                  if (!error) {\n                    const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                    appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                    appsObj.versions.postgresql = appsObj.versions.postgresql.split('-')[0];\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            if (_windows) {\n              util.powerShell('Get-CimInstance Win32_Service | select caption | fl').then((stdout) => {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((item) => {\n                  if (item.trim() !== '') {\n                    let lines = item.trim().split('\\r\\n');\n                    let srvCaption = util.getValue(lines, 'caption', ':', true).toLowerCase();\n                    if (srvCaption.indexOf('postgresql') > -1) {\n                      const parts = srvCaption.split(' server ');\n                      if (parts.length > 1) {\n                        appsObj.versions.postgresql = parts[1];\n                      }\n                    }\n                  }\n                });\n                functionProcessed();\n              });\n            } else {\n              exec('postgres -V', function (error, stdout) {\n                if (!error) {\n                  const postgresql = stdout.toString().split('\\n')[0].split(' ') || [];\n                  appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : '';\n                }\n                functionProcessed();\n              });\n            }\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'perl')) {\n          exec('perl -v', function (error, stdout) {\n            if (!error) {\n              const perl = stdout.toString().split('\\n') || '';\n              while (perl.length > 0 && perl[0].trim() === '') {\n                perl.shift();\n              }\n              if (perl.length > 0) {\n                appsObj.versions.perl = perl[0].split('(').pop().split(')')[0].replace('v', '');\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python')) {\n          if (_darwin) {\n            const stdout = execSync('sw_vers');\n            const lines = stdout.toString().split('\\n');\n            const osVersion = util.getValue(lines, 'ProductVersion', ':');\n            const gitHomebrewExists1 = fs.existsSync('/usr/local/Cellar/python');\n            const gitHomebrewExists2 = fs.existsSync('/opt/homebrew/bin/python');\n            if ((util.darwinXcodeExists() && util.semverCompare('12.0.1', osVersion) < 0) || gitHomebrewExists1 || gitHomebrewExists2) {\n              const cmd = gitHomebrewExists1 ? '/usr/local/Cellar/python -V 2>&1' : (gitHomebrewExists2 ? '/opt/homebrew/bin/python -V 2>&1' : 'python -V 2>&1');\n              exec(cmd, function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'python3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/python3') || fs.existsSync('/opt/homebrew/bin/python3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('python3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const python = stdout.toString().split('\\n')[0] || '';\n                  appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('python3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const python = stdout.toString().split('\\n')[0] || '';\n                appsObj.versions.python3 = python.toLowerCase().replace('python', '').trim();\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip') || fs.existsSync('/opt/homebrew/bin/pip');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'pip3')) {\n          if (_darwin) {\n            const gitHomebrewExists = fs.existsSync('/usr/local/Cellar/pip3') || fs.existsSync('/opt/homebrew/bin/pip3');\n            if (util.darwinXcodeExists() || gitHomebrewExists) {\n              exec('pip3 -V 2>&1', function (error, stdout) {\n                if (!error) {\n                  const pip = stdout.toString().split('\\n')[0] || '';\n                  const parts = pip.split(' ');\n                  appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n                }\n                functionProcessed();\n              });\n            } else {\n              functionProcessed();\n            }\n          } else {\n            exec('pip3 -V 2>&1', function (error, stdout) {\n              if (!error) {\n                const pip = stdout.toString().split('\\n')[0] || '';\n                const parts = pip.split(' ');\n                appsObj.versions.pip3 = parts.length >= 2 ? parts[1] : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'java')) {\n          if (_darwin) {\n            // check if any JVM is installed but avoid dialog box that Java needs to be installed\n            exec('/usr/libexec/java_home -V 2>&1', function (error, stdout) {\n              if (!error && stdout.toString().toLowerCase().indexOf('no java runtime') === -1) {\n                // now this can be done savely\n                exec('java -version 2>&1', function (error, stdout) {\n                  if (!error) {\n                    const java = stdout.toString().split('\\n')[0] || '';\n                    const parts = java.split('\"');\n                    appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n                  }\n                  functionProcessed();\n                });\n              } else {\n                functionProcessed();\n              }\n            });\n          } else {\n            exec('java -version 2>&1', function (error, stdout) {\n              if (!error) {\n                const java = stdout.toString().split('\\n')[0] || '';\n                const parts = java.split('\"');\n                appsObj.versions.java = parts.length === 3 ? parts[1].trim() : '';\n              }\n              functionProcessed();\n            });\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'gcc')) {\n          if ((_darwin && util.darwinXcodeExists()) || !_darwin) {\n            exec('gcc -dumpversion', function (error, stdout) {\n              if (!error) {\n                appsObj.versions.gcc = stdout.toString().split('\\n')[0].trim() || '';\n              }\n              if (appsObj.versions.gcc.indexOf('.') > -1) {\n                functionProcessed();\n              } else {\n                exec('gcc --version', function (error, stdout) {\n                  if (!error) {\n                    const gcc = stdout.toString().split('\\n')[0].trim();\n                    if (gcc.indexOf('gcc') > -1 && gcc.indexOf(')') > -1) {\n                      const parts = gcc.split(')');\n                      appsObj.versions.gcc = parts[1].trim() || appsObj.versions.gcc;\n                    }\n                  }\n                  functionProcessed();\n                });\n              }\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'virtualbox')) {\n          exec(util.getVboxmanage() + ' -v 2>&1', function (error, stdout) {\n            if (!error) {\n              const vbox = stdout.toString().split('\\n')[0] || '';\n              const parts = vbox.split('r');\n              appsObj.versions.virtualbox = parts[0];\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'bash')) {\n          exec('bash --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.bash = parts[1].split(' ')[0].split('(')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'zsh')) {\n          exec('zsh --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split('zsh ');\n              if (parts.length > 1) {\n                appsObj.versions.zsh = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'fish')) {\n          exec('fish --version', function (error, stdout) {\n            if (!error) {\n              const line = stdout.toString().split('\\n')[0];\n              const parts = line.split(' version ');\n              if (parts.length > 1) {\n                appsObj.versions.fish = parts[1].split(' ')[0];\n              }\n            }\n            functionProcessed();\n          });\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'powershell')) {\n          if (_windows) {\n            util.powerShell('$PSVersionTable').then(stdout => {\n              const lines = stdout.toString().split('\\n').map(line => line.replace(/ +/g, ' ').replace(/ +/g, ':'));\n              appsObj.versions.powershell = util.getValue(lines, 'psversion');\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n        if ({}.hasOwnProperty.call(appsObj.versions, 'dotnet')) {\n          if (_windows) {\n            util.powerShell('gci \"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\NET Framework Setup\\\\NDP\" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match \"^(?!S)\\\\p{L}\"} | select PSChildName, Version, Release').then(stdout => {\n              const lines = stdout.toString().split('\\r\\n');\n              let dotnet = '';\n              lines.forEach(line => {\n                line = line.replace(/ +/g, ' ');\n                const parts = line.split(' ');\n                dotnet = dotnet || (parts[0].toLowerCase().startsWith('client') && parts.length > 2 ? parts[1].trim() : (parts[0].toLowerCase().startsWith('full') && parts.length > 2 ? parts[1].trim() : ''));\n              });\n              appsObj.versions.dotnet = dotnet.trim();\n              functionProcessed();\n            });\n          } else {\n            functionProcessed();\n          }\n        }\n      } catch (e) {\n        if (callback) { callback(appsObj.versions); }\n        resolve(appsObj.versions);\n      }\n    });\n  });\n}\n\nexports.versions = versions;\n\nfunction shell(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (_windows) {\n        resolve('cmd');\n      } else {\n        let result = '';\n        exec('echo $SHELL', function (error, stdout) {\n          if (!error) {\n            result = stdout.toString().split('\\n')[0];\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n    });\n  });\n}\n\nexports.shell = shell;\n\nfunction getUniqueMacAdresses() {\n  let macs = [];\n  try {\n    const ifaces = os.networkInterfaces();\n    for (let dev in ifaces) {\n      if ({}.hasOwnProperty.call(ifaces, dev)) {\n        ifaces[dev].forEach(function (details) {\n          if (details && details.mac && details.mac !== '00:00:00:00:00:00') {\n            const mac = details.mac.toLowerCase();\n            if (macs.indexOf(mac) === -1) {\n              macs.push(mac);\n            }\n          }\n        });\n      }\n    }\n    macs = macs.sort(function (a, b) {\n      if (a < b) { return -1; }\n      if (a > b) { return 1; }\n      return 0;\n    });\n  } catch (e) {\n    macs.push('00:00:00:00:00:00');\n  }\n  return macs;\n}\n\nfunction uuid(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        os: '',\n        hardware: '',\n        macs: getUniqueMacAdresses()\n      };\n      let parts;\n\n      if (_darwin) {\n        exec('system_profiler SPHardwareDataType -json', function (error, stdout) {\n          if (!error) {\n            try {\n              const jsonObj = JSON.parse(stdout.toString());\n              if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {\n                const spHardware = jsonObj.SPHardwareDataType[0];\n                result.os = spHardware.platform_UUID.toLowerCase();\n                result.hardware = spHardware.serial_number;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_linux) {\n        const cmd = `echo -n \"os: \"; cat /var/lib/dbus/machine-id 2> /dev/null; echo;\necho -n \"os: \"; cat /etc/machine-id 2> /dev/null; echo;\necho -n \"hardware: \"; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'os').toLowerCase();\n          result.hardware = util.getValue(lines, 'hardware').toLowerCase();\n          if (!result.hardware) {\n            const lines = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n            const serial = util.getValue(lines, 'serial');\n            result.hardware = serial || '';\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('sysctl -i kern.hostid kern.hostuuid', function (error, stdout) {\n          const lines = stdout.toString().split('\\n');\n          result.os = util.getValue(lines, 'kern.hostid', ':').toLowerCase();\n          result.hardware = util.getValue(lines, 'kern.hostuuid', ':').toLowerCase();\n          if (result.os.indexOf('unknown') >= 0) { result.os = ''; }\n          if (result.hardware.indexOf('unknown') >= 0) { result.hardware = ''; }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let sysdir = '%windir%\\\\System32';\n        if (process.arch === 'ia32' && Object.prototype.hasOwnProperty.call(process.env, 'PROCESSOR_ARCHITEW6432')) {\n          sysdir = '%windir%\\\\sysnative\\\\cmd.exe /c %windir%\\\\System32';\n        }\n        util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl').then((stdout) => {\n          let lines = stdout.split('\\r\\n');\n          result.hardware = util.getValue(lines, 'uuid', ':').toLowerCase();\n          exec(`${sysdir}\\\\reg query \"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\" /v MachineGuid`, util.execOptsWin, function (error, stdout) {\n            parts = stdout.toString().split('\\n\\r')[0].split('REG_SZ');\n            result.os = parts.length > 1 ? parts[1].replace(/\\r+|\\n+|\\s+/ig, '').toLowerCase() : '';\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          });\n        });\n      }\n    });\n  });\n}\n\nexports.uuid = uuid;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// printers.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 15. printers\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst winPrinterStatus = {\n  1: 'Other',\n  2: 'Unknown',\n  3: 'Idle',\n  4: 'Printing',\n  5: 'Warmup',\n  6: 'Stopped Printing',\n  7: 'Offline',\n};\n\nfunction parseLinuxCupsHeader(lines) {\n  const result = {};\n  if (lines && lines.length) {\n    if (lines[0].indexOf(' CUPS v') > 0) {\n      const parts = lines[0].split(' CUPS v');\n      result.cupsVersion = parts[1];\n    }\n  }\n  return result;\n}\n\nfunction parseLinuxCupsPrinter(lines) {\n  const result = {};\n  const printerId = util.getValue(lines, 'PrinterId', ' ');\n  result.id = printerId ? parseInt(printerId, 10) : null;\n  result.name = util.getValue(lines, 'Info', ' ');\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = util.getValue(lines, 'DeviceURI', ' ');\n  result.uuid = util.getValue(lines, 'UUID', ' ');\n  result.status = util.getValue(lines, 'State', ' ');\n  result.local = util.getValue(lines, 'Location', ' ').toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseLinuxLpstatPrinter(lines, id) {\n  const result = {};\n  result.id = id;\n  result.name = util.getValue(lines, 'Description', ':', true);\n  result.model = lines.length > 0 && lines[0] ? lines[0].split(' ')[0] : '';\n  result.uri = null;\n  result.uuid = null;\n  result.status = lines.length > 0 && lines[0] ? (lines[0].indexOf(' idle') > 0 ? 'idle' : (lines[0].indexOf(' printing') > 0 ? 'printing' : 'unknown')) : null;\n  result.local = util.getValue(lines, 'Location', ':', true).toLowerCase().startsWith('local');\n  result.default = null;\n  result.shared = util.getValue(lines, 'Shared', ' ').toLowerCase().startsWith('yes');\n\n  return result;\n}\n\nfunction parseDarwinPrinters(printerObject, id) {\n  const result = {};\n  const uriParts = printerObject.uri.split('/');\n  result.id = id;\n  result.name = printerObject._name;\n  result.model = uriParts.length ? uriParts[uriParts.length - 1] : '';\n  result.uri = printerObject.uri;\n  result.uuid = null;\n  result.status = printerObject.status;\n  result.local = printerObject.printserver === 'local';\n  result.default = printerObject.default === 'yes';\n  result.shared = printerObject.shared === 'yes';\n\n  return result;\n}\n\nfunction parseWindowsPrinters(lines, id) {\n  const result = {};\n  const status = parseInt(util.getValue(lines, 'PrinterStatus', ':'), 10);\n\n  result.id = id;\n  result.name = util.getValue(lines, 'name', ':');\n  result.model = util.getValue(lines, 'DriverName', ':');\n  result.uri = null;\n  result.uuid = null;\n  result.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;\n  result.local = util.getValue(lines, 'Local', ':').toUpperCase() === 'TRUE';\n  result.default = util.getValue(lines, 'Default', ':').toUpperCase() === 'TRUE';\n  result.shared = util.getValue(lines, 'Shared', ':').toUpperCase() === 'TRUE';\n\n  return result;\n}\n\nfunction printer(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'cat /etc/cups/printers.conf 2>/dev/null';\n        exec(cmd, function (error, stdout) {\n          // printers.conf\n          if (!error) {\n            const parts = stdout.toString().split('<Printer ');\n            const printerHeader = parseLinuxCupsHeader(parts[0]);\n            for (let i = 1; i < parts.length; i++) {\n              const printers = parseLinuxCupsPrinter(parts[i].split('\\n'));\n              if (printers.name) {\n                printers.engine = 'CUPS';\n                printers.engineVersion = printerHeader.cupsVersion;\n                result.push(printers);\n              }\n            }\n          }\n          if (result.length === 0) {\n            if (_linux) {\n              cmd = 'export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL';\n              // lpstat\n              exec(cmd, function (error, stdout) {\n                const parts = ('\\n' + stdout.toString()).split('\\nprinter ');\n                for (let i = 1; i < parts.length; i++) {\n                  const printers = parseLinuxLpstatPrinter(parts[i].split('\\n'), i);\n                  result.push(printers);\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } else {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        let cmd = 'system_profiler SPPrintersDataType -json';\n        exec(cmd, function (error, stdout) {\n          if (!error) {\n            try {\n              const outObj = JSON.parse(stdout.toString());\n              if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {\n                for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {\n                  const printer = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);\n                  result.push(printer);\n                }\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const printer = parseWindowsPrinters(parts[i].split('\\n'), i);\n              if (printer.name || printer.model) {\n                result.push(printer);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.printer = printer;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// processes.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 10. Processes\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\n\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nconst _processes_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _services_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\nconst _process_cpu = {\n  all: 0,\n  all_utime: 0,\n  all_stime: 0,\n  list: {},\n  ms: 0,\n  result: {}\n};\n\nconst _winStatusValues = {\n  '0': 'unknown',\n  '1': 'other',\n  '2': 'ready',\n  '3': 'running',\n  '4': 'blocked',\n  '5': 'suspended blocked',\n  '6': 'suspended ready',\n  '7': 'terminated',\n  '8': 'stopped',\n  '9': 'growing',\n};\n\nfunction parseTimeUnix(time) {\n  let result = time;\n  let parts = time.replace(/ +/g, ' ').split(' ');\n  if (parts.length === 5) {\n    result = parts[4] + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(parts[1].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + parts[2]).slice(-2) + ' ' + parts[3];\n  }\n  return result;\n}\n\nfunction parseElapsedTime(etime) {\n  let current = new Date();\n  current = new Date(current.getTime() - current.getTimezoneOffset() * 60000);\n\n  const elapsed = etime.split('-');\n\n  const timeIndex = elapsed.length - 1;\n  const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;\n\n  const timeStr = elapsed[timeIndex].split(':');\n  const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;\n  const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);\n  const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);\n  const ms = (((((days * 24 + hours) * 60) + mins) * 60 + secs) * 1000);\n\n  let res = new Date(current.getTime());\n  let result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  try {\n    res = new Date(current.getTime() - ms);\n    result = res.toISOString().substring(0, 10) + ' ' + res.toISOString().substring(11, 19);\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\n// --------------------------\n// PS - services\n// pass a comma separated string with services to check (mysql, apache, postgresql, ...)\n// this function gives an array back, if the services are running.\n\nfunction services(srv, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(srv) && !callback) {\n    callback = srv;\n    srv = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof srv !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      if (srv) {\n        let srvString = '';\n        srvString.__proto__.toLowerCase = util.stringToLower;\n        srvString.__proto__.replace = util.stringReplace;\n        srvString.__proto__.trim = util.stringTrim;\n\n        const s = util.sanitizeShellString(srv);\n        for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n          if (s[i] !== undefined) {\n            srvString = srvString + s[i];\n          }\n        }\n\n        srvString = srvString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n        if (srvString === '') {\n          srvString = '*';\n        }\n        if (util.isPrototypePolluted() && srvString !== '*') {\n          srvString = '------';\n        }\n        let srvs = srvString.split('|');\n        let result = [];\n        let dataSrv = [];\n\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n          if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === '*') {\n            try {\n              const tmpsrv = execSync('systemctl --all --type=service --no-legend 2> /dev/null').toString().split('\\n');\n              srvs = [];\n              for (const s of tmpsrv) {\n                const name = s.split('.service')[0];\n                if (name && s.indexOf(' not-found ') === -1) {\n                  srvs.push(name.trim());\n                }\n              }\n              srvString = srvs.join('|');\n            } catch (d) {\n              try {\n                srvString = '';\n                const tmpsrv = execSync('service --status-all 2> /dev/null').toString().split('\\n');\n                for (const s of tmpsrv) {\n                  const parts = s.split(']');\n                  if (parts.length === 2) {\n                    srvString += (srvString !== '' ? '|' : '') + parts[1].trim();\n                  }\n                }\n                srvs = srvString.split('|');\n              } catch (e) {\n                try {\n                  const srvStr = execSync('ls /etc/init.d/ -m 2> /dev/null').toString().split('\\n').join('');\n                  srvString = '';\n                  if (srvStr) {\n                    const tmpsrv = srvStr.split(',');\n                    for (const s of tmpsrv) {\n                      const name = s.trim();\n                      if (name) {\n                        srvString += (srvString !== '' ? '|' : '') + name;\n                      }\n                    }\n                    srvs = srvString.split('|');\n                  }\n                } catch (f) {\n                  srvString = '';\n                  srvs = [];\n                }\n              }\n            }\n          }\n          if ((_darwin) && srvString === '*') { // service enumeration not yet suported on mac OS\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n          let args = (_darwin) ? ['-caxo', 'pcpu,pmem,pid,command'] : ['-axo', 'pcpu,pmem,pid,command'];\n          if (srvString !== '' && srvs.length > 0) {\n            util.execSafe('ps', args).then((stdout) => {\n              if (stdout) {\n                let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                srvs.forEach(function (srv) {\n                  let ps;\n                  if (_darwin) {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(srv) !== -1);\n                    });\n\n                  } else {\n                    ps = lines.filter(function (e) {\n                      return (e.toLowerCase().indexOf(' ' + srv + ':') !== -1) || (e.toLowerCase().indexOf('/' + srv) !== -1);\n                    });\n                  }\n                  const pids = [];\n                  for (const p of ps) {\n                    const pid = p.trim().split(' ')[2];\n                    if (pid) {\n                      pids.push(parseInt(pid, 10));\n                    }\n                  }\n                  result.push({\n                    name: srv,\n                    running: ps.length > 0,\n                    startmode: '',\n                    pids: pids,\n                    cpu: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[0]);\n                    }, 0)).toFixed(2)),\n                    mem: parseFloat((ps.reduce(function (pv, cv) {\n                      return pv + parseFloat(cv.trim().split(' ')[1]);\n                    }, 0)).toFixed(2))\n                  });\n                });\n                if (_linux) {\n                  // calc process_cpu - ps is not accurate in linux!\n                  let cmd = 'cat /proc/stat | grep \"cpu \"';\n                  for (let i in result) {\n                    for (let j in result[i].pids) {\n                      cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                    }\n                  }\n                  exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                    let curr_processes = stdout.toString().split('\\n');\n\n                    // first line (all - /proc/stat)\n                    let all = parseProcStat(curr_processes.shift());\n\n                    // process\n                    let list_new = {};\n                    let resultProcess = {};\n                    curr_processes.forEach((element) => {\n                      resultProcess = calcProcStatLinux(element, all, _services_cpu);\n\n                      if (resultProcess.pid) {\n                        let listPos = -1;\n                        for (let i in result) {\n                          for (let j in result[i].pids) {\n                            if (parseInt(result[i].pids[j]) === parseInt(resultProcess.pid)) {\n                              listPos = i;\n                            }\n                          }\n                        }\n                        if (listPos >= 0) {\n                          result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                        }\n\n                        // save new values\n                        list_new[resultProcess.pid] = {\n                          cpuu: resultProcess.cpuu,\n                          cpus: resultProcess.cpus,\n                          utime: resultProcess.utime,\n                          stime: resultProcess.stime,\n                          cutime: resultProcess.cutime,\n                          cstime: resultProcess.cstime\n                        };\n                      }\n                    });\n\n                    // store old values\n                    _services_cpu.all = all;\n                    _services_cpu.list = Object.assign({}, list_new);\n                    _services_cpu.ms = Date.now() - _services_cpu.ms;\n                    _services_cpu.result = Object.assign({}, result);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              } else {\n                args = ['-o', 'comm'];\n                util.execSafe('ps', args).then((stdout) => {\n                  if (stdout) {\n                    let lines = stdout.replace(/ +/g, ' ').replace(/,+/g, '.').split('\\n');\n                    srvs.forEach(function (srv) {\n                      let ps = lines.filter(function (e) {\n                        return e.indexOf(srv) !== -1;\n                      });\n                      result.push({\n                        name: srv,\n                        running: ps.length > 0,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  } else {\n                    srvs.forEach(function (srv) {\n                      result.push({\n                        name: srv,\n                        running: false,\n                        startmode: '',\n                        cpu: 0,\n                        mem: 0\n                      });\n                    });\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  }\n                });\n              }\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n        if (_windows) {\n          try {\n            let wincommand = 'Get-CimInstance Win32_Service';\n            if (srvs[0] !== '*') {\n              wincommand += ' -Filter \"';\n              srvs.forEach((srv) => {\n                wincommand += `Name='${srv}' or `;\n              });\n              wincommand = `${wincommand.slice(0, -4)}\"`;\n            }\n            wincommand += ' | select Name,Caption,Started,StartMode,ProcessId | fl';\n            util.powerShell(wincommand).then((stdout, error) => {\n              if (!error) {\n                let serviceSections = stdout.split(/\\n\\s*\\n/);\n                serviceSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let srvName = util.getValue(lines, 'Name', ':', true).toLowerCase();\n                    let srvCaption = util.getValue(lines, 'Caption', ':', true).toLowerCase();\n                    let started = util.getValue(lines, 'Started', ':', true);\n                    let startMode = util.getValue(lines, 'StartMode', ':', true);\n                    let pid = util.getValue(lines, 'ProcessId', ':', true);\n                    if (srvString === '*' || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {\n                      result.push({\n                        name: srvName,\n                        running: (started.toLowerCase() === 'true'),\n                        startmode: startMode,\n                        pids: [pid],\n                        cpu: 0,\n                        mem: 0\n                      });\n                      dataSrv.push(srvName);\n                      dataSrv.push(srvCaption);\n                    }\n                  }\n\n                });\n\n                if (srvString !== '*') {\n                  let srvsMissing = srvs.filter(function (e) {\n                    return dataSrv.indexOf(e) === -1;\n                  });\n                  srvsMissing.forEach(function (srvName) {\n                    result.push({\n                      name: srvName,\n                      running: false,\n                      startmode: '',\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              } else {\n                srvs.forEach(function (srvName) {\n                  result.push({\n                    name: srvName,\n                    running: false,\n                    startmode: '',\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) { callback([]); }\n        resolve([]);\n      }\n    });\n  });\n}\n\nexports.services = services;\n\nfunction parseProcStat(line) {\n  let parts = line.replace(/ +/g, ' ').split(' ');\n  let user = (parts.length >= 2 ? parseInt(parts[1]) : 0);\n  let nice = (parts.length >= 3 ? parseInt(parts[2]) : 0);\n  let system = (parts.length >= 4 ? parseInt(parts[3]) : 0);\n  let idle = (parts.length >= 5 ? parseInt(parts[4]) : 0);\n  let iowait = (parts.length >= 6 ? parseInt(parts[5]) : 0);\n  let irq = (parts.length >= 7 ? parseInt(parts[6]) : 0);\n  let softirq = (parts.length >= 8 ? parseInt(parts[7]) : 0);\n  let steal = (parts.length >= 9 ? parseInt(parts[8]) : 0);\n  let guest = (parts.length >= 10 ? parseInt(parts[9]) : 0);\n  let guest_nice = (parts.length >= 11 ? parseInt(parts[10]) : 0);\n  return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;\n}\n\nfunction calcProcStatLinux(line, all, _cpu_old) {\n  let statparts = line.replace(/ +/g, ' ').split(')');\n  if (statparts.length >= 2) {\n    let parts = statparts[1].split(' ');\n    if (parts.length >= 16) {\n      let pid = parseInt(statparts[0].split(' ')[0]);\n      let utime = parseInt(parts[12]);\n      let stime = parseInt(parts[13]);\n      let cutime = parseInt(parts[14]);\n      let cstime = parseInt(parts[15]);\n\n      // calc\n      let cpuu = 0;\n      let cpus = 0;\n      if (_cpu_old.all > 0 && _cpu_old.list[pid]) {\n        cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100; // user\n        cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100; // system\n      } else {\n        cpuu = (utime + cutime) / (all) * 100; // user\n        cpus = (stime + cstime) / (all) * 100; // system\n      }\n      return {\n        pid: pid,\n        utime: utime,\n        stime: stime,\n        cutime: cutime,\n        cstime: cstime,\n        cpuu: cpuu,\n        cpus: cpus\n      };\n    } else {\n      return {\n        pid: 0,\n        utime: 0,\n        stime: 0,\n        cutime: 0,\n        cstime: 0,\n        cpuu: 0,\n        cpus: 0\n      };\n    }\n  } else {\n    return {\n      pid: 0,\n      utime: 0,\n      stime: 0,\n      cutime: 0,\n      cstime: 0,\n      cpuu: 0,\n      cpus: 0\n    };\n  }\n}\n\nfunction calcProcStatWin(procStat, all, _cpu_old) {\n  // calc\n  let cpuu = 0;\n  let cpus = 0;\n  if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {\n    cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100; // user\n    cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100; // system\n  } else {\n    cpuu = (procStat.utime) / (all) * 100; // user\n    cpus = (procStat.stime) / (all) * 100; // system\n  }\n  return {\n    pid: procStat.pid,\n    utime: procStat.utime,\n    stime: procStat.stime,\n    cpuu: cpuu > 0 ? cpuu : 0,\n    cpus: cpus > 0 ? cpus : 0\n  };\n}\n\n\n\n// --------------------------\n// running processes\n\nfunction processes(callback) {\n\n  let parsedhead = [];\n\n  function getName(command) {\n    command = command || '';\n    let result = command.split(' ')[0];\n    if (result.substr(-1) === ':') {\n      result = result.substr(0, result.length - 1);\n    }\n    if (result.substr(0, 1) !== '[') {\n      let parts = result.split('/');\n      if (isNaN(parseInt(parts[parts.length - 1]))) {\n        result = parts[parts.length - 1];\n      } else {\n        result = parts[0];\n      }\n    }\n    return result;\n  }\n\n  function parseLine(line) {\n\n    let offset = 0;\n    let offset2 = 0;\n\n    function checkColumn(i) {\n      offset = offset2;\n      if (parsedhead[i]) {\n        offset2 = line.substring(parsedhead[i].to + offset, 10000).indexOf(' ');\n      } else {\n        offset2 = 10000;\n      }\n    }\n\n    checkColumn(0);\n    const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));\n    checkColumn(1);\n    const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));\n    checkColumn(2);\n    const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, '.'));\n    checkColumn(3);\n    const mem = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, '.'));\n    checkColumn(4);\n    const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));\n    checkColumn(5);\n    const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));\n    checkColumn(6);\n    const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));\n    checkColumn(7);\n    const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;\n    checkColumn(8);\n    const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());\n    checkColumn(9);\n    let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();\n    state = (state[0] === 'R' ? 'running' : (state[0] === 'S' ? 'sleeping' : (state[0] === 'T' ? 'stopped' : (state[0] === 'W' ? 'paging' : (state[0] === 'X' ? 'dead' : (state[0] === 'Z' ? 'zombie' : ((state[0] === 'D' || state[0] === 'U') ? 'blocked' : 'unknown')))))));\n    checkColumn(10);\n    let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();\n    if (tty === '?' || tty === '??') { tty = ''; }\n    checkColumn(11);\n    const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();\n    checkColumn(12);\n    let cmdPath = '';\n    let command = '';\n    let params = '';\n    let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();\n    if (fullcommand.substr(fullcommand.length - 1) === ']') { fullcommand = fullcommand.slice(0, -1); }\n    if (fullcommand.substr(0, 1) === '[') { command = fullcommand.substring(1); }\n    else {\n      const p1 = fullcommand.indexOf('(');\n      const p2 = fullcommand.indexOf(')');\n      const p3 = fullcommand.indexOf('/');\n      const p4 = fullcommand.indexOf(':');\n      if (p1 < p2 && p1 < p3 && p3 < p2) {\n        command = fullcommand.split(' ')[0];\n        command = command.replace(/:/g, '');\n      } else {\n        if (p4 > 0 && (p3 === -1 || p3 > 3)) {\n          command = fullcommand.split(' ')[0];\n          command = command.replace(/:/g, '');\n        } else {\n          // try to figure out where parameter starts\n          let firstParamPos = fullcommand.indexOf(' -');\n          let firstParamPathPos = fullcommand.indexOf(' /');\n          firstParamPos = (firstParamPos >= 0 ? firstParamPos : 10000);\n          firstParamPathPos = (firstParamPathPos >= 0 ? firstParamPathPos : 10000);\n          const firstPos = Math.min(firstParamPos, firstParamPathPos);\n          let tmpCommand = fullcommand.substr(0, firstPos);\n          const tmpParams = fullcommand.substr(firstPos);\n          const lastSlashPos = tmpCommand.lastIndexOf('/');\n          if (lastSlashPos >= 0) {\n            cmdPath = tmpCommand.substr(0, lastSlashPos);\n            tmpCommand = tmpCommand.substr(lastSlashPos + 1);\n          }\n\n          if (firstPos === 10000 && tmpCommand.indexOf(' ') > -1) {\n            const parts = tmpCommand.split(' ');\n            if (fs.existsSync(path.join(cmdPath, parts[0]))) {\n              command = parts.shift();\n              params = (parts.join(' ') + ' ' + tmpParams).trim();\n            } else {\n              command = tmpCommand.trim();\n              params = tmpParams.trim();\n            }\n          } else {\n            command = tmpCommand.trim();\n            params = tmpParams.trim();\n          }\n        }\n      }\n\n    }\n\n    return ({\n      pid: pid,\n      parentPid: ppid,\n      name: _linux ? getName(command) : command,\n      cpu: cpu,\n      cpuu: 0,\n      cpus: 0,\n      mem: mem,\n      priority: priority,\n      memVsz: vsz,\n      memRss: rss,\n      nice: nice,\n      started: started,\n      state: state,\n      tty: tty,\n      user: user,\n      command: command,\n      params: params,\n      path: cmdPath\n    });\n  }\n\n  function parseProcesses(lines) {\n    let result = [];\n    if (lines.length > 1) {\n      let head = lines[0];\n      parsedhead = util.parseHead(head, 8);\n      lines.shift();\n      lines.forEach(function (line) {\n        if (line.trim() !== '') {\n          result.push(parseLine(line));\n        }\n      });\n    }\n    return result;\n  }\n  function parseProcesses2(lines) {\n\n    function formatDateTime(time) {\n      const month = ('0' + (time.getMonth() + 1).toString()).slice(-2);\n      const year = time.getFullYear().toString();\n      const day = ('0' + time.getDate().toString()).slice(-2);\n      const hours = ('0' + time.getHours().toString()).slice(-2);\n      const mins = ('0' + time.getMinutes().toString()).slice(-2);\n      const secs = ('0' + time.getSeconds().toString()).slice(-2);\n\n      return (year + '-' + month + '-' + day + ' ' + hours + ':' + mins + ':' + secs);\n    }\n\n    function parseElapsed(etime) {\n      let started = '';\n      if (etime.indexOf('d') >= 0) {\n        const elapsed_parts = etime.split('d');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1000));\n      } else if (etime.indexOf('h') >= 0) {\n        const elapsed_parts = etime.split('h');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1000));\n      } else if (etime.indexOf(':') >= 0) {\n        const elapsed_parts = etime.split(':');\n        started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1000 : elapsed_parts[0] * 1000)));\n      }\n      return started;\n    }\n\n    let result = [];\n    lines.forEach(function (line) {\n      if (line.trim() !== '') {\n        line = line.trim().replace(/ +/g, ' ').replace(/,+/g, '.');\n        const parts = line.split(' ');\n        const command = parts.slice(9).join(' ');\n        const pmem = parseFloat((1.0 * parseInt(parts[3]) * 1024 / os.totalmem()).toFixed(1));\n        const started = parseElapsed(parts[5]);\n\n        result.push({\n          pid: parseInt(parts[0]),\n          parentPid: parseInt(parts[1]),\n          name: getName(command),\n          cpu: 0,\n          cpuu: 0,\n          cpus: 0,\n          mem: pmem,\n          priority: 0,\n          memVsz: parseInt(parts[2]),\n          memRss: parseInt(parts[3]),\n          nice: parseInt(parts[4]),\n          started: started,\n          state: (parts[6] === 'R' ? 'running' : (parts[6] === 'S' ? 'sleeping' : (parts[6] === 'T' ? 'stopped' : (parts[6] === 'W' ? 'paging' : (parts[6] === 'X' ? 'dead' : (parts[6] === 'Z' ? 'zombie' : ((parts[6] === 'D' || parts[6] === 'U') ? 'blocked' : 'unknown'))))))),\n          tty: parts[7],\n          user: parts[8],\n          command: command\n        });\n      }\n    });\n    return result;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        all: 0,\n        running: 0,\n        blocked: 0,\n        sleeping: 0,\n        unknown: 0,\n        list: []\n      };\n\n      let cmd = '';\n\n      if ((_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500) || _processes_cpu.ms === 0) {\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n          if (_linux) { cmd = 'export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL'; }\n          if (_freebsd || _openbsd || _netbsd) { cmd = 'export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL'; }\n          if (_darwin) { cmd = 'ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r'; }\n          if (_sunos) { cmd = 'ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm'; }\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error && stdout.toString().trim()) {\n              result.list = (parseProcesses(stdout.toString().split('\\n'))).slice();\n              result.all = result.list.length;\n              result.running = result.list.filter(function (e) {\n                return e.state === 'running';\n              }).length;\n              result.blocked = result.list.filter(function (e) {\n                return e.state === 'blocked';\n              }).length;\n              result.sleeping = result.list.filter(function (e) {\n                return e.state === 'sleeping';\n              }).length;\n\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                cmd = 'cat /proc/stat | grep \"cpu \"';\n                result.list.forEach((element) => {\n                  cmd += (';cat /proc/' + element.pid + '/stat');\n                });\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _processes_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // store pcpu in outer array\n                      let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                      if (listPos >= 0) {\n                        result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                        result.list[listPos].cpuu = resultProcess.cpuu;\n                        result.list[listPos].cpus = resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  // store old values\n                  _processes_cpu.all = all;\n                  _processes_cpu.list = Object.assign({}, list_new);\n                  _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                  _processes_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm';\n              if (_sunos) {\n                cmd = 'ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm';\n              }\n              exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                if (!error) {\n                  let lines = stdout.toString().split('\\n');\n                  lines.shift();\n\n                  result.list = parseProcesses2(lines).slice();\n                  result.all = result.list.length;\n                  result.running = result.list.filter(function (e) {\n                    return e.state === 'running';\n                  }).length;\n                  result.blocked = result.list.filter(function (e) {\n                    return e.state === 'blocked';\n                  }).length;\n                  result.sleeping = result.list.filter(function (e) {\n                    return e.state === 'sleeping';\n                  }).length;\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            }\n          });\n        } else if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n=\"CreationDate\";e={$_.CreationDate.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procs = [];\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let parentPid = parseInt(util.getValue(lines, 'ParentProcessId', ':', true), 10);\n                    let statusValue = util.getValue(lines, 'ExecutionState', ':');\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let commandLine = util.getValue(lines, 'CommandLine', ':', true);\n                    // get additional command line data\n                    let additionalCommand = false;\n                    lines.forEach((line) => {\n                      if (additionalCommand && line.toLowerCase().startsWith(' ')) {\n                        commandLine += ' ' + line.trim();\n                      } else {\n                        additionalCommand = false;\n                      }\n                      if (line.toLowerCase().startsWith('commandline')) {\n                        additionalCommand = true;\n                      }\n                    });\n                    let commandPath = util.getValue(lines, 'ExecutablePath', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let memw = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n                    result.all++;\n                    if (!statusValue) { result.unknown++; }\n                    if (statusValue === '3') { result.running++; }\n                    if (statusValue === '4' || statusValue === '5') { result.blocked++; }\n\n                    procStats.push({\n                      pid: pid,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                    });\n                    procs.push({\n                      pid: pid,\n                      parentPid: parentPid,\n                      name: name,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem: memw / os.totalmem() * 100,\n                      priority: parseInt(util.getValue(lines, 'Priority', ':', true), 10),\n                      memVsz: parseInt(util.getValue(lines, 'PageFileUsage', ':', true), 10),\n                      memRss: Math.floor(parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10) / 1024),\n                      nice: 0,\n                      started: util.getValue(lines, 'CreationDate', ':', true),\n                      state: (!statusValue ? _winStatusValues[0] : _winStatusValues[statusValue]),\n                      tty: '',\n                      user: '',\n                      command: commandLine || name,\n                      path: commandPath,\n                      params: ''\n                    });\n                  }\n                });\n\n                result.sleeping = result.all - result.running - result.blocked - result.unknown;\n                result.list = procs;\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);\n\n                  // store pcpu in outer array\n                  let listPos = result.list.map(function (e) { return e.pid; }).indexOf(resultProcess.pid);\n                  if (listPos >= 0) {\n                    result.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;\n                    result.list[listPos].cpuu = resultProcess.cpuu;\n                    result.list[listPos].cpus = resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _processes_cpu.all = allcpuu + allcpus;\n                _processes_cpu.all_utime = allcpuu;\n                _processes_cpu.all_stime = allcpus;\n                _processes_cpu.list = Object.assign({}, list_new);\n                _processes_cpu.ms = Date.now() - _processes_cpu.ms;\n                _processes_cpu.result = Object.assign({}, result);\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } else {\n        if (callback) { callback(_processes_cpu.result); }\n        resolve(_processes_cpu.result);\n      }\n    });\n  });\n}\n\nexports.processes = processes;\n\n// --------------------------\n// PS - process load\n// get detailed information about a certain process\n// (PID, CPU-Usage %, Mem-Usage %)\n\nfunction processLoad(proc, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(proc) && !callback) {\n    callback = proc;\n    proc = '';\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      proc = proc || '';\n\n      if (typeof proc !== 'string') {\n        if (callback) { callback([]); }\n        return resolve([]);\n      }\n\n      let processesString = '';\n      processesString.__proto__.toLowerCase = util.stringToLower;\n      processesString.__proto__.replace = util.stringReplace;\n      processesString.__proto__.trim = util.stringTrim;\n\n      const s = util.sanitizeShellString(proc);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (s[i] !== undefined) {\n          processesString = processesString + s[i];\n        }\n      }\n\n      processesString = processesString.trim().toLowerCase().replace(/, /g, '|').replace(/,+/g, '|');\n      if (processesString === '') {\n        processesString = '*';\n      }\n      if (util.isPrototypePolluted() && processesString !== '*') {\n        processesString = '------';\n      }\n      let processes = processesString.split('|');\n      let result = [];\n\n      const procSanitized = util.isPrototypePolluted() ? '' : util.sanitizeShellString(proc);\n\n      // from here new\n      // let result = {\n      //   'proc': procSanitized,\n      //   'pid': null,\n      //   'cpu': 0,\n      //   'mem': 0\n      // };\n      if (procSanitized && processes.length && processes[0] !== '------') {\n        if (_windows) {\n          try {\n            util.powerShell('Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl').then((stdout, error) => {\n              if (!error) {\n                let processSections = stdout.split(/\\n\\s*\\n/);\n                let procStats = [];\n                let list_new = {};\n                let allcpuu = 0;\n                let allcpus = 0;\n\n                // go through all processes\n                processSections.forEach((element) => {\n                  if (element.trim() !== '') {\n                    let lines = element.trim().split('\\r\\n');\n                    let pid = parseInt(util.getValue(lines, 'ProcessId', ':', true), 10);\n                    let name = util.getValue(lines, 'Caption', ':', true);\n                    let utime = parseInt(util.getValue(lines, 'UserModeTime', ':', true), 10);\n                    let stime = parseInt(util.getValue(lines, 'KernelModeTime', ':', true), 10);\n                    let mem = parseInt(util.getValue(lines, 'WorkingSetSize', ':', true), 10);\n                    allcpuu = allcpuu + utime;\n                    allcpus = allcpus + stime;\n\n                    procStats.push({\n                      pid: pid,\n                      name,\n                      utime: utime,\n                      stime: stime,\n                      cpu: 0,\n                      cpuu: 0,\n                      cpus: 0,\n                      mem\n                    });\n                    let pname = '';\n                    let inList = false;\n                    processes.forEach(function (proc) {\n                      if (name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                        inList = true;\n                        pname = proc;\n                      }\n                    });\n\n                    if (processesString === '*' || inList) {\n                      let processFound = false;\n                      result.forEach(function (item) {\n                        if (item.proc.toLowerCase() === pname.toLowerCase()) {\n                          item.pids.push(pid);\n                          item.mem += mem / os.totalmem() * 100;\n                          processFound = true;\n                        }\n                      });\n                      if (!processFound) {\n                        result.push({\n                          proc: pname,\n                          pid: pid,\n                          pids: [pid],\n                          cpu: 0,\n                          mem: mem / os.totalmem() * 100\n                        });\n                      }\n                    }\n                  }\n                });\n\n                // add missing processes\n                if (processesString !== '*') {\n                  let processesMissing = processes.filter(function (name) {\n                    return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n\n                  });\n                  processesMissing.forEach(function (procName) {\n                    result.push({\n                      proc: procName,\n                      pid: null,\n                      pids: [],\n                      cpu: 0,\n                      mem: 0\n                    });\n                  });\n                }\n\n                // calculate proc stats for each proc\n                procStats.forEach((element) => {\n                  let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);\n\n                  let listPos = -1;\n                  for (let j = 0; j < result.length; j++) {\n                    if (result[j].pid === resultProcess.pid || result[j].pids.indexOf(resultProcess.pid) >= 0) { listPos = j; }\n                  }\n                  if (listPos >= 0) {\n                    result[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;\n                  }\n\n                  // save new values\n                  list_new[resultProcess.pid] = {\n                    cpuu: resultProcess.cpuu,\n                    cpus: resultProcess.cpus,\n                    utime: resultProcess.utime,\n                    stime: resultProcess.stime\n                  };\n                });\n\n                // store old values\n                _process_cpu.all = allcpuu + allcpus;\n                _process_cpu.all_utime = allcpuu;\n                _process_cpu.all_stime = allcpus;\n                _process_cpu.list = Object.assign({}, list_new);\n                _process_cpu.ms = Date.now() - _process_cpu.ms;\n                _process_cpu.result = JSON.parse(JSON.stringify(result));\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            });\n          } catch (e) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n\n        if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {\n          const params = ['-axo', 'pid,ppid,pcpu,pmem,comm'];\n          util.execSafe('ps', params).then((stdout) => {\n            if (stdout) {\n              let procStats = [];\n              let lines = stdout.toString().split('\\n').filter(function (line) {\n                if (processesString === '*') { return true; }\n                if (line.toLowerCase().indexOf('grep') !== -1) { return false; } // remove this??\n                let found = false;\n                processes.forEach(function (item) {\n                  found = found || (line.toLowerCase().indexOf(item.toLowerCase()) >= 0);\n                });\n                return found;\n              });\n\n              lines.forEach(function (line) {\n                let data = line.trim().replace(/ +/g, ' ').split(' ');\n                if (data.length > 4) {\n                  procStats.push({\n                    name: data[4].substring(data[4].lastIndexOf('/') + 1),\n                    pid: parseInt(data[0]) || 0,\n                    ppid: parseInt(data[1]) || 0,\n                    cpu: parseFloat(data[2].replace(',', '.')),\n                    mem: parseFloat(data[3].replace(',', '.'))\n                  });\n                }\n              });\n\n              procStats.forEach(function (item) {\n                let listPos = -1;\n                let inList = false;\n                let name = '';\n                for (let j = 0; j < result.length; j++) {\n                  if (item.name.toLowerCase().indexOf(result[j].proc.toLowerCase()) >= 0) {\n                    listPos = j;\n                  }\n                }\n                processes.forEach(function (proc) {\n\n                  if (item.name.toLowerCase().indexOf(proc.toLowerCase()) >= 0 && !inList) {\n                    inList = true;\n                    name = proc;\n                  }\n                });\n                if ((processesString === '*') || inList) {\n                  if (listPos < 0) {\n                    result.push({\n                      proc: name,\n                      pid: item.pid,\n                      pids: [item.pid],\n                      cpu: item.cpu,\n                      mem: item.mem\n                    });\n                  } else {\n                    if (item.ppid < 10) {\n                      result[listPos].pid = item.pid;\n                    }\n                    result[listPos].pids.push(item.pid);\n                    result[listPos].cpu += item.cpu;\n                    result[listPos].mem += item.mem;\n                  }\n                }\n              });\n\n              if (processesString !== '*') {\n                // add missing processes\n                let processesMissing = processes.filter(function (name) {\n                  return procStats.filter(function (item) { return item.name.toLowerCase().indexOf(name) >= 0; }).length === 0;\n                });\n                processesMissing.forEach(function (procName) {\n                  result.push({\n                    proc: procName,\n                    pid: null,\n                    pids: [],\n                    cpu: 0,\n                    mem: 0\n                  });\n                });\n              }\n              if (_linux) {\n                // calc process_cpu - ps is not accurate in linux!\n                result.forEach(function (item) {\n                  item.cpu = 0;\n                });\n                let cmd = 'cat /proc/stat | grep \"cpu \"';\n                for (let i in result) {\n                  for (let j in result[i].pids) {\n                    cmd += (';cat /proc/' + result[i].pids[j] + '/stat');\n                  }\n                }\n                exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n                  let curr_processes = stdout.toString().split('\\n');\n\n                  // first line (all - /proc/stat)\n                  let all = parseProcStat(curr_processes.shift());\n\n                  // process\n                  let list_new = {};\n                  let resultProcess = {};\n                  curr_processes.forEach((element) => {\n                    resultProcess = calcProcStatLinux(element, all, _process_cpu);\n\n                    if (resultProcess.pid) {\n\n                      // find result item\n                      let resultItemId = -1;\n                      for (let i in result) {\n                        if (result[i].pids.indexOf(resultProcess.pid) >= 0) {\n                          resultItemId = i;\n                        }\n                      }\n                      // store pcpu in outer result\n                      if (resultItemId >= 0) {\n                        result[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;\n                      }\n\n                      // save new values\n                      list_new[resultProcess.pid] = {\n                        cpuu: resultProcess.cpuu,\n                        cpus: resultProcess.cpus,\n                        utime: resultProcess.utime,\n                        stime: resultProcess.stime,\n                        cutime: resultProcess.cutime,\n                        cstime: resultProcess.cstime\n                      };\n                    }\n                  });\n\n                  result.forEach(function (item) {\n                    item.cpu = Math.round(item.cpu * 100) / 100;\n                  });\n\n                  _process_cpu.all = all;\n                  _process_cpu.list = Object.assign({}, list_new);\n                  _process_cpu.ms = Date.now() - _process_cpu.ms;\n                  _process_cpu.result = Object.assign({}, result);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              } else {\n                if (callback) { callback(result); }\n                resolve(result);\n              }\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        }\n      }\n    });\n  });\n}\n\nexports.processLoad = processLoad;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// system.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 2. System (Hardware, BIOS, Base Board)\n// ----------------------------------------------------------------------------------\n\nconst fs = require('fs');\nconst os = require('os');\nconst util = require('./util');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst execPromise = util.promisify(require('child_process').exec);\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction system(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: 'Computer',\n        version: '',\n        serial: '-',\n        uuid: '-',\n        sku: '-',\n        virtual: false\n      };\n\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        exec('export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL', function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'manufacturer');\n          result.model = util.getValue(lines, 'product name');\n          result.version = util.getValue(lines, 'version');\n          result.serial = util.getValue(lines, 'serial number');\n          result.uuid = util.getValue(lines, 'uuid').toLowerCase();\n          result.sku = util.getValue(lines, 'sku number');\n          // Non-Root values\n          const cmd = `echo -n \"product_name: \"; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;\n            echo -n \"product_serial: \"; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;\n            echo -n \"product_uuid: \"; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;\n            echo -n \"product_version: \"; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;\n            echo -n \"sys_vendor: \"; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = result.manufacturer === '' ? util.getValue(lines, 'sys_vendor') : result.manufacturer;\n            result.model = result.model === '' ? util.getValue(lines, 'product_name') : result.model;\n            result.version = result.version === '' ? util.getValue(lines, 'product_version') : result.version;\n            result.serial = result.serial === '' ? util.getValue(lines, 'product_serial') : result.serial;\n            result.uuid = result.uuid === '' ? util.getValue(lines, 'product_uuid').toLowerCase() : result.uuid;\n          } catch (e) {\n            util.noop();\n          }\n          if (!result.serial || result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (!result.manufacturer || result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = ''; }\n          if (!result.model || result.model.toLowerCase().indexOf('o.e.m.') !== -1) { result.model = 'Computer'; }\n          if (!result.version || result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = ''; }\n          if (!result.sku || result.sku.toLowerCase().indexOf('o.e.m.') !== -1) { result.sku = '-'; }\n\n          // detect virtual (1)\n          if (result.model.toLowerCase() === 'virtualbox' || result.model.toLowerCase() === 'kvm' || result.model.toLowerCase() === 'virtual machine' || result.model.toLowerCase() === 'bochs' || result.model.toLowerCase().startsWith('vmware') || result.model.toLowerCase().startsWith('droplet')) {\n            result.virtual = true;\n            switch (result.model.toLowerCase()) {\n              case 'virtualbox':\n                result.virtualHost = 'VirtualBox';\n                break;\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'kvm':\n                result.virtualHost = 'KVM';\n                break;\n              case 'bochs':\n                result.virtualHost = 'bochs';\n                break;\n            }\n          }\n          if (result.manufacturer.toLowerCase().startsWith('vmware') || result.manufacturer.toLowerCase() === 'xen') {\n            result.virtual = true;\n            switch (result.manufacturer.toLowerCase()) {\n              case 'vmware':\n                result.virtualHost = 'VMware';\n                break;\n              case 'xen':\n                result.virtualHost = 'Xen';\n                break;\n            }\n          }\n          if (!result.virtual) {\n            try {\n              const disksById = execSync('ls -1 /dev/disk/by-id/ 2>/dev/null').toString();\n              if (disksById.indexOf('_QEMU_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'QEMU';\n              }\n              if (disksById.indexOf('_VBOX_') >= 0) {\n                result.virtual = true;\n                result.virtualHost = 'VirtualBox';\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          if (!result.virtual && (os.release().toLowerCase().indexOf('microsoft') >= 0 || os.release().toLowerCase().endsWith('wsl2'))) {\n            const kernelVersion = parseFloat(os.release().toLowerCase());\n            result.virtual = true;\n            result.manufacturer = 'Microsoft';\n            result.model = 'WSL';\n            result.version = kernelVersion < 4.19 ? '1' : '2';\n          }\n          if ((_freebsd || _openbsd || _netbsd) && !result.virtualHost) {\n            try {\n              const procInfo = execSync('dmidecode -t 4');\n              const procLines = procInfo.toString().split('\\n');\n              const procManufacturer = util.getValue(procLines, 'manufacturer', ':', true);\n              switch (procManufacturer.toLowerCase()) {\n                case 'virtualbox':\n                  result.virtualHost = 'VirtualBox';\n                  break;\n                case 'vmware':\n                  result.virtualHost = 'VMware';\n                  break;\n                case 'kvm':\n                  result.virtualHost = 'KVM';\n                  break;\n                case 'bochs':\n                  result.virtualHost = 'bochs';\n                  break;\n              }\n            } catch (e) {\n              util.noop();\n            }\n          }\n          // detect docker\n          if (fs.existsSync('/.dockerenv') || fs.existsSync('/.dockerinit')) {\n            result.model = 'Docker Container';\n          }\n          try {\n            const stdout = execSync('dmesg 2>/dev/null | grep -iE \"virtual|hypervisor\" | grep -iE \"vmware|qemu|kvm|xen\" | grep -viE \"Nested Virtualization|/virtual/\"');\n            // detect virtual machines\n            let lines = stdout.toString().split('\\n');\n            if (lines.length > 0) {\n              if (result.model === 'Computer') { result.model = 'Virtual machine'; }\n              result.virtual = true;\n              if (stdout.toString().toLowerCase().indexOf('vmware') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'VMware';\n              }\n              if (stdout.toString().toLowerCase().indexOf('qemu') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'QEMU';\n              }\n              if (stdout.toString().toLowerCase().indexOf('xen') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'Xen';\n              }\n              if (stdout.toString().toLowerCase().indexOf('kvm') >= 0 && !result.virtualHost) {\n                result.virtualHost = 'KVM';\n              }\n            }\n          } catch (e) {\n            util.noop();\n          }\n\n          if (result.manufacturer === '' && result.model === 'Computer' && result.version === '') {\n            // Check Raspberry Pi\n            fs.readFile('/proc/cpuinfo', function (error, stdout) {\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                result.model = util.getValue(lines, 'hardware', ':', true).toUpperCase();\n                result.version = util.getValue(lines, 'revision', ':', true).toLowerCase();\n                result.serial = util.getValue(lines, 'serial', ':', true);\n                const model = util.getValue(lines, 'model:', ':', true);\n                // reference values: https://elinux.org/RPi_HardwareHistory\n                // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n                if ((result.model === 'BCM2835' || result.model === 'BCM2708' || result.model === 'BCM2709' || result.model === 'BCM2710' || result.model === 'BCM2711' || result.model === 'BCM2836' || result.model === 'BCM2837') && model.toLowerCase().indexOf('raspberry') >= 0) {\n                  const rPIRevision = util.decodePiCpuinfo(lines);\n                  result.model = rPIRevision.model;\n                  result.version = rPIRevision.revisionCode;\n                  result.manufacturer = 'Raspberry Pi Foundation';\n                  result.raspberry = {\n                    manufacturer: rPIRevision.manufacturer,\n                    processor: rPIRevision.processor,\n                    type: rPIRevision.type,\n                    revision: rPIRevision.revision\n                  };\n                }\n              }\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true, true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.uuid = util.getValue(lines, 'ioplatformuuid', '=', true).toLowerCase();\n            result.sku = util.getValue(lines, 'board-id', '=', true);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.split('\\r\\n');\n              result.manufacturer = util.getValue(lines, 'vendor', ':');\n              result.model = util.getValue(lines, 'name', ':');\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'identifyingnumber', ':');\n              result.uuid = util.getValue(lines, 'uuid', ':').toLowerCase();\n              // detect virtual (1)\n              const model = result.model.toLowerCase();\n              if (model === 'virtualbox' || model === 'kvm' || model === 'virtual machine' || model === 'bochs' || model.startsWith('vmware') || model.startsWith('qemu') || model.startsWith('parallels')) {\n                result.virtual = true;\n                if (model.startsWith('virtualbox')) { result.virtualHost = 'VirtualBox'; }\n                if (model.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (model.startsWith('kvm')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('bochs')) { result.virtualHost = 'bochs'; }\n                if (model.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (model.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              const manufacturer = result.manufacturer.toLowerCase();\n              if (manufacturer.startsWith('vmware') || manufacturer.startsWith('qemu') || manufacturer === 'xen' || manufacturer.startsWith('parallels')) {\n                result.virtual = true;\n                if (manufacturer.startsWith('vmware')) { result.virtualHost = 'VMware'; }\n                if (manufacturer.startsWith('xen')) { result.virtualHost = 'Xen'; }\n                if (manufacturer.startsWith('qemu')) { result.virtualHost = 'KVM'; }\n                if (manufacturer.startsWith('parallels')) { result.virtualHost = 'Parallels'; }\n              }\n              util.powerShell('Get-CimInstance MS_Systeminformation -Namespace \"root/wmi\" | select systemsku | fl ').then((stdout, error) => {\n                if (!error) {\n                  let lines = stdout.split('\\r\\n');\n                  result.sku = util.getValue(lines, 'systemsku', ':');\n                }\n                if (!result.virtual) {\n                  util.powerShell('Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion').then((stdout, error) => {\n                    if (!error) {\n                      let lines = stdout.toString();\n                      if (lines.indexOf('VRTUAL') >= 0 || lines.indexOf('A M I ') >= 0 || lines.indexOf('VirtualBox') >= 0 || lines.indexOf('VMWare') >= 0 || lines.indexOf('Xen') >= 0 || lines.indexOf('Parallels') >= 0) {\n                        result.virtual = true;\n                        if (lines.indexOf('VirtualBox') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VirtualBox';\n                        }\n                        if (lines.indexOf('VMware') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'VMware';\n                        }\n                        if (lines.indexOf('Xen') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Xen';\n                        }\n                        if (lines.indexOf('VRTUAL') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Hyper-V';\n                        }\n                        if (lines.indexOf('A M I') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Virtual PC';\n                        }\n                        if (lines.indexOf('Parallels') >= 0 && !result.virtualHost) {\n                          result.virtualHost = 'Parallels';\n                        }\n                      }\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    } else {\n                      if (callback) { callback(result); }\n                      resolve(result);\n                    }\n                  });\n                } else {\n                  if (callback) { callback(result); }\n                  resolve(result);\n                }\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.system = system;\n\nfunction bios(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        vendor: '',\n        version: '',\n        releaseDate: '',\n        revision: '',\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL';\n        }\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.vendor = util.getValue(lines, 'Vendor');\n          result.version = util.getValue(lines, 'Version');\n          let datetime = util.getValue(lines, 'Release Date');\n          result.releaseDate = util.parseDateTime(datetime).date;\n          result.revision = util.getValue(lines, 'BIOS Revision');\n          result.serial = util.getValue(lines, 'SerialNumber');\n          let language = util.getValue(lines, 'Currently Installed Language').split('|')[0];\n          if (language) {\n            result.language = language;\n          }\n          if (lines.length && stdout.toString().indexOf('Characteristics:') >= 0) {\n            const features = [];\n            lines.forEach(line => {\n              if (line.indexOf(' is supported') >= 0) {\n                const feature = line.split(' is supported')[0].trim();\n                features.push(feature);\n              }\n            });\n            result.features = features;\n          }\n          // Non-Root values\n          const cmd = `echo -n \"bios_date: \"; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;\n            echo -n \"bios_vendor: \"; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;\n            echo -n \"bios_version: \"; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.vendor = !result.vendor ? util.getValue(lines, 'bios_vendor') : result.vendor;\n            result.version = !result.version ? util.getValue(lines, 'bios_version') : result.version;\n            datetime = util.getValue(lines, 'bios_date');\n            result.releaseDate = !result.releaseDate ? util.parseDateTime(datetime).date : result.releaseDate;\n          } catch (e) {\n            util.noop();\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        result.vendor = 'Apple Inc.';\n        exec(\n          'system_profiler SPHardwareDataType -json', function (error, stdout) {\n            try {\n              const hardwareData = JSON.parse(stdout.toString());\n              if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {\n                let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;\n                bootRomVersion = bootRomVersion ? bootRomVersion.split('(')[0].trim() : null;\n                result.version = bootRomVersion;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n      }\n      if (_sunos) {\n        result.vendor = 'Sun Microsystems';\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n=\"ReleaseDate\";e={$_.ReleaseDate.ToString(\"yyyy-MM-dd\")}},BuildNumber,SerialNumber | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              const description = util.getValue(lines, 'description', ':');\n              if (description.indexOf(' Version ') !== -1) {\n                // ... Phoenix ROM BIOS PLUS Version 1.10 A04\n                result.vendor = description.split(' Version ')[0].trim();\n                result.version = description.split(' Version ')[1].trim();\n              } else if (description.indexOf(' Ver: ') !== -1) {\n                // ... BIOS Date: 06/27/16 17:50:16 Ver: 1.4.5\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = description.split(' Ver: ')[1].trim();\n              } else {\n                result.vendor = util.getValue(lines, 'manufacturer', ':');\n                result.version = util.getValue(lines, 'version', ':');\n              }\n              result.releaseDate = util.getValue(lines, 'releasedate', ':');\n              result.revision = util.getValue(lines, 'buildnumber', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.bios = bios;\n\nfunction baseboard(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        memMax: null,\n        memSlots: null\n      };\n      let cmd = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        if (process.arch === 'arm') {\n          cmd = 'cat /proc/cpuinfo | grep Serial';\n          // 'BCM2709', 'BCM2835', 'BCM2708' -->\n        } else {\n          cmd = 'export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL';\n        }\n        const workload = [];\n        workload.push(execPromise(cmd));\n        workload.push(execPromise('export LC_ALL=C; dmidecode -t memory 2>/dev/null'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'Manufacturer');\n          result.model = util.getValue(lines, 'Product Name');\n          result.version = util.getValue(lines, 'Version');\n          result.serial = util.getValue(lines, 'Serial Number');\n          result.assetTag = util.getValue(lines, 'Asset Tag');\n          // Non-Root values\n          const cmd = `echo -n \"board_asset_tag: \"; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;\n            echo -n \"board_name: \"; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;\n            echo -n \"board_serial: \"; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;\n            echo -n \"board_vendor: \"; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;\n            echo -n \"board_version: \"; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;\n          try {\n            lines = execSync(cmd).toString().split('\\n');\n            result.manufacturer = !result.manufacturer ? util.getValue(lines, 'board_vendor') : result.manufacturer;\n            result.model = !result.model ? util.getValue(lines, 'board_name') : result.model;\n            result.version = !result.version ? util.getValue(lines, 'board_version') : result.version;\n            result.serial = !result.serial ? util.getValue(lines, 'board_serial') : result.serial;\n            result.assetTag = !result.assetTag ? util.getValue(lines, 'board_asset_tag') : result.assetTag;\n          } catch (e) {\n            util.noop();\n          }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          // mem\n          lines = data.results[1] ? data.results[1].toString().split('\\n') : [''];\n          result.memMax = util.toInt(util.getValue(lines, 'Maximum Capacity')) * 1024 * 1024 * 1024 || null;\n          result.memSlots = util.toInt(util.getValue(lines, 'Number Of Devices')) || null;\n\n          // raspberry\n          let linesRpi = '';\n          try {\n            linesRpi = fs.readFileSync('/proc/cpuinfo').toString().split('\\n');\n          } catch (e) {\n            util.noop();\n          }\n          const hardware = util.getValue(linesRpi, 'hardware');\n          if (hardware.startsWith('BCM')) {\n            const rpi = util.decodePiCpuinfo(linesRpi);\n            result.manufacturer = rpi.manufacturer;\n            result.model = 'Raspberry Pi';\n            result.serial = rpi.serial;\n            result.version = rpi.type + ' - ' + rpi.revision;\n            result.memMax = os.totalmem();\n            result.memSlots = 0;\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        const workload = [];\n        workload.push(execPromise('ioreg -c IOPlatformExpertDevice -d 2'));\n        workload.push(execPromise('system_profiler SPMemoryDataType'));\n        util.promiseAll(\n          workload\n        ).then((data) => {\n          let lines = data.results[0] ? data.results[0].toString().replace(/[<>\"]/g, '').split('\\n') : [''];\n          result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n          result.model = util.getValue(lines, 'model', '=', true);\n          result.version = util.getValue(lines, 'version', '=', true);\n          result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n          result.assetTag = util.getValue(lines, 'board-id', '=', true);\n\n          // mem\n          let devices = data.results[1] ? data.results[1].toString().split('        BANK ') : [''];\n          if (devices.length === 1) {\n            devices = data.results[1] ? data.results[1].toString().split('        DIMM') : [''];\n          }\n          devices.shift();\n          result.memSlots = devices.length;\n\n          if (os.arch() === 'arm64') {\n            result.memSlots = 0;\n            result.memMax = os.totalmem();\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          const workload = [];\n          const win10plus = parseInt(os.release()) >= 10;\n          const maxCapacityAttribute = win10plus ? 'MaxCapacityEx' : 'MaxCapacity';\n          workload.push(util.powerShell('Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl'));\n          workload.push(util.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));\n          util.promiseAll(\n            workload\n          ).then((data) => {\n            let lines = data.results[0] ? data.results[0].toString().split('\\r\\n') : [''];\n\n            result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n            result.model = util.getValue(lines, 'model', ':');\n            if (!result.model) {\n              result.model = util.getValue(lines, 'product', ':');\n            }\n            result.version = util.getValue(lines, 'version', ':');\n            result.serial = util.getValue(lines, 'serialnumber', ':');\n            result.assetTag = util.getValue(lines, 'partnumber', ':');\n            if (!result.assetTag) {\n              result.assetTag = util.getValue(lines, 'sku', ':');\n            }\n\n            // memphysical\n            lines = data.results[1] ? data.results[1].toString().split('\\r\\n') : [''];\n            result.memMax = util.toInt(util.getValue(lines, maxCapacityAttribute, ':')) * (win10plus ? 1024 : 1) || null;\n            result.memSlots = util.toInt(util.getValue(lines, 'MemoryDevices', ':')) || null;\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.baseboard = baseboard;\n\nfunction chassis(callback) {\n  const chassisTypes = ['Other',\n    'Unknown',\n    'Desktop',\n    'Low Profile Desktop',\n    'Pizza Box',\n    'Mini Tower',\n    'Tower',\n    'Portable',\n    'Laptop',\n    'Notebook',\n    'Hand Held',\n    'Docking Station',\n    'All in One',\n    'Sub Notebook',\n    'Space-Saving',\n    'Lunch Box',\n    'Main System Chassis',\n    'Expansion Chassis',\n    'SubChassis',\n    'Bus Expansion Chassis',\n    'Peripheral Chassis',\n    'Storage Chassis',\n    'Rack Mount Chassis',\n    'Sealed-Case PC',\n    'Multi-System Chassis',\n    'Compact PCI',\n    'Advanced TCA',\n    'Blade',\n    'Blade Enclosure',\n    'Tablet',\n    'Convertible',\n    'Detachable',\n    'IoT Gateway ',\n    'Embedded PC',\n    'Mini PC',\n    'Stick PC',\n  ];\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      let result = {\n        manufacturer: '',\n        model: '',\n        type: '',\n        version: '',\n        serial: '-',\n        assetTag: '-',\n        sku: '',\n      };\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        const cmd = `echo -n \"chassis_asset_tag: \"; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;\n            echo -n \"chassis_serial: \"; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;\n            echo -n \"chassis_type: \"; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;\n            echo -n \"chassis_vendor: \"; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;\n            echo -n \"chassis_version: \"; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;\n        exec(cmd, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          result.manufacturer = util.getValue(lines, 'chassis_vendor');\n          const ctype = parseInt(util.getValue(lines, 'chassis_type').replace(/\\D/g, ''));\n          result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n          result.version = util.getValue(lines, 'chassis_version');\n          result.serial = util.getValue(lines, 'chassis_serial');\n          result.assetTag = util.getValue(lines, 'chassis_asset_tag');\n          if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n          if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n          if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n          if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        exec('ioreg -c IOPlatformExpertDevice -d 2', function (error, stdout) {\n          if (!error) {\n            let lines = stdout.toString().replace(/[<>\"]/g, '').split('\\n');\n            result.manufacturer = util.getValue(lines, 'manufacturer', '=', true);\n            result.model = util.getValue(lines, 'model', '=', true);\n            result.version = util.getValue(lines, 'version', '=', true);\n            result.serial = util.getValue(lines, 'ioplatformserialnumber', '=', true);\n            result.assetTag = util.getValue(lines, 'board-id', '=', true);\n          }\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n      if (_windows) {\n        try {\n          util.powerShell('Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU | fl').then((stdout, error) => {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n\n              result.manufacturer = util.getValue(lines, 'manufacturer', ':');\n              result.model = util.getValue(lines, 'model', ':');\n              const ctype = parseInt(util.getValue(lines, 'ChassisTypes', ':').replace(/\\D/g, ''));\n              result.type = (ctype && !isNaN(ctype) && ctype < chassisTypes.length) ? chassisTypes[ctype - 1] : '';\n              result.version = util.getValue(lines, 'version', ':');\n              result.serial = util.getValue(lines, 'serialnumber', ':');\n              result.assetTag = util.getValue(lines, 'partnumber', ':');\n              result.sku = util.getValue(lines, 'sku', ':');\n              if (result.manufacturer.toLowerCase().indexOf('o.e.m.') !== -1) { result.manufacturer = '-'; }\n              if (result.version.toLowerCase().indexOf('o.e.m.') !== -1) { result.version = '-'; }\n              if (result.serial.toLowerCase().indexOf('o.e.m.') !== -1) { result.serial = '-'; }\n              if (result.assetTag.toLowerCase().indexOf('o.e.m.') !== -1) { result.assetTag = '-'; }\n            }\n\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.chassis = chassis;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// usb.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 16. usb\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction getLinuxUsbType(type, name) {\n  let result = type;\n  const str = (name + ' ' + type).toLowerCase();\n  if (str.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (str.indexOf('hub') >= 0) { result = 'Hub'; }\n  else if (str.indexOf('keybrd') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (str.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (str.indexOf('stora') >= 0) { result = 'Storage'; }\n  else if (str.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (str.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (str.indexOf('audio') >= 0) { result = 'Audio'; }\n\n  return result;\n}\n\nfunction parseLinuxUsb(usb) {\n  const result = {};\n  const lines = usb.split('\\n');\n  if (lines && lines.length && lines[0].indexOf('Device') >= 0) {\n    const parts = lines[0].split(' ');\n    result.bus = parseInt(parts[0], 10);\n    if (parts[2]) {\n      result.deviceId = parseInt(parts[2], 10);\n    } else {\n      result.deviceId = null;\n    }\n  } else {\n    result.bus = null;\n    result.deviceId = null;\n  }\n  const idVendor = util.getValue(lines, 'idVendor', ' ', true).trim();\n  let vendorParts = idVendor.split(' ');\n  vendorParts.shift();\n  const vendor = vendorParts.join(' ');\n\n  const idProduct = util.getValue(lines, 'idProduct', ' ', true).trim();\n  let productParts = idProduct.split(' ');\n  productParts.shift();\n  const product = productParts.join(' ');\n\n  const interfaceClass = util.getValue(lines, 'bInterfaceClass', ' ', true).trim();\n  let interfaceClassParts = interfaceClass.split(' ');\n  interfaceClassParts.shift();\n  const usbType = interfaceClassParts.join(' ');\n\n  const iManufacturer = util.getValue(lines, 'iManufacturer', ' ', true).trim();\n  let iManufacturerParts = iManufacturer.split(' ');\n  iManufacturerParts.shift();\n  const manufacturer = iManufacturerParts.join(' ');\n\n  result.id = (idVendor.startsWith('0x') ? idVendor.split(' ')[0].substr(2, 10) : '') + ':' + (idProduct.startsWith('0x') ? idProduct.split(' ')[0].substr(2, 10) : '');\n  result.name = product;\n  result.type = getLinuxUsbType(usbType, product);\n  result.removable = null;\n  result.vendor = vendor;\n  result.manufacturer = manufacturer;\n  result.maxPower = util.getValue(lines, 'MaxPower', ' ', true);\n  result.serialNumber = null;\n\n  return result;\n}\n\nfunction getDarwinUsbType(name) {\n  let result = '';\n  if (name.indexOf('camera') >= 0) { result = 'Camera'; }\n  else if (name.indexOf('touch bar') >= 0) { result = 'Touch Bar'; }\n  else if (name.indexOf('controller') >= 0) { result = 'Controller'; }\n  else if (name.indexOf('headset') >= 0) { result = 'Audio'; }\n  else if (name.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (name.indexOf('trackpad') >= 0) { result = 'Trackpad'; }\n  else if (name.indexOf('sensor') >= 0) { result = 'Sensor'; }\n  else if (name.indexOf('bthusb') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('bth') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('rfcomm') >= 0) { result = 'Bluetooth'; }\n  else if (name.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf(' hub') >= 0) { result = 'Hub'; }\n  else if (name.indexOf('mouse') >= 0) { result = 'Mouse'; }\n  else if (name.indexOf('mic') >= 0) { result = 'Microphone'; }\n  else if (name.indexOf('removable') >= 0) { result = 'Storage'; }\n  return result;\n}\n\n\nfunction parseDarwinUsb(usb, id) {\n  const result = {};\n  result.id = id;\n\n  usb = usb.replace(/ \\|/g, '');\n  usb = usb.trim();\n  let lines = usb.split('\\n');\n  lines.shift();\n  try {\n    for (let i = 0; i < lines.length; i++) {\n      lines[i] = lines[i].trim();\n      lines[i] = lines[i].replace(/=/g, ':');\n      if (lines[i] !== '{' && lines[i] !== '}' && lines[i + 1] && lines[i + 1].trim() !== '}') {\n        lines[i] = lines[i] + ',';\n      }\n      lines[i] = lines[i].replace(': Yes,', ': \"Yes\",');\n      lines[i] = lines[i].replace(': No,', ': \"No\",');\n    }\n    const usbObj = JSON.parse(lines.join('\\n'));\n    const removableDrive = usbObj['Built-In'].toLowerCase() !== 'yes' && usbObj['non-removable'].toLowerCase() === 'no';\n\n    result.bus = null;\n    result.deviceId = null;\n    result.id = usbObj['USB Address'] || null;\n    result.name = usbObj['kUSBProductString'] || usbObj['USB Product Name'] || null;\n    result.type = getDarwinUsbType((usbObj['kUSBProductString'] || usbObj['USB Product Name'] || '').toLowerCase() + (removableDrive ? ' removable' : ''));\n    result.removable = usbObj['non-removable'].toLowerCase() === 'no';\n    result.vendor = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.manufacturer = usbObj['kUSBVendorString'] || usbObj['USB Vendor Name'] || null;\n    result.maxPower = null;\n    result.serialNumber = usbObj['kUSBSerialNumberString'] || null;\n\n    if (result.name) {\n      return result;\n    } else {\n      return null;\n    }\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction getWindowsUsbTypeCreation(creationclass, name) {\n  let result = '';\n  if (name.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (name.indexOf('speicher') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbhub') >= 0) { result = 'Hub'; }\n  else if (creationclass.indexOf('storage') >= 0) { result = 'Storage'; }\n  else if (creationclass.indexOf('usbcontroller') >= 0) { result = 'Controller'; }\n  else if (creationclass.indexOf('keyboard') >= 0) { result = 'Keyboard'; }\n  else if (creationclass.indexOf('pointing') >= 0) { result = 'Mouse'; }\n  else if (creationclass.indexOf('disk') >= 0) { result = 'Storage'; }\n  return result;\n}\n\nfunction parseWindowsUsb(lines, id) {\n  const usbType = getWindowsUsbTypeCreation(util.getValue(lines, 'CreationClassName', ':').toLowerCase(), util.getValue(lines, 'name', ':').toLowerCase());\n\n  if (usbType) {\n    const result = {};\n    result.bus = null;\n    result.deviceId = util.getValue(lines, 'deviceid', ':');\n    result.id = id;\n    result.name = util.getValue(lines, 'name', ':');\n    result.type = usbType;\n    result.removable = null;\n    result.vendor = null;\n    result.manufacturer = util.getValue(lines, 'Manufacturer', ':');\n    result.maxPower = null;\n    result.serialNumber = null;\n\n    return result;\n  } else {\n    return null;\n  }\n}\n\nfunction usb(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        const cmd = 'export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = ('\\n\\n' + stdout.toString()).split('\\n\\nBus ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseLinuxUsb(parts[i]);\n              result.push(usb);\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_darwin) {\n        let cmd = 'ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l';\n        exec(cmd, { maxBuffer: 1024 * 1024 * 128 }, function (error, stdout) {\n          if (!error) {\n            const parts = (stdout.toString()).split(' +-o ');\n            for (let i = 1; i < parts.length; i++) {\n              const usb = parseDarwinUsb(parts[i]);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        util.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match \"USB\"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {\n          if (!error) {\n            const parts = stdout.toString().split(/\\n\\s*\\n/);\n            for (let i = 0; i < parts.length; i++) {\n              const usb = parseWindowsUsb(parts[i].split('\\n'), i);\n              if (usb) {\n                result.push(usb);\n              }\n            }\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      }\n      if (_sunos || _freebsd || _openbsd || _netbsd) {\n        resolve(null);\n      }\n    });\n  });\n}\n\nexports.usb = usb;\n\n","'use strict';\n// @ts-check\n// ==================================================================================\n// users.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 11. Users/Sessions\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nfunction parseUsersLinux(lines, phase) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let w_first = true;\n  let w_header = [];\n  let w_pos = [];\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: l[2],\n          time: l[3],\n          ip: (l && l.length > 4) ? l[4].replace(/\\(/g, '').replace(/\\)/g, '') : ''\n        });\n      } else {\n        // w part\n        if (w_first) {    // header\n          w_header = l;\n          w_header.forEach(function (item) {\n            w_pos.push(line.indexOf(item));\n          });\n          w_first = false;\n        } else {\n          // split by w_pos\n          result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();\n          result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();\n          result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\\(/g, '').replace(/\\)/g, '').trim();\n          result_w.command = line.substring(w_pos[7], 1000).trim();\n          // find corresponding 'who' line\n          who_line = result_who.filter(function (obj) {\n            return (obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty);\n          });\n          if (who_line.length === 1) {\n            result.push({\n              user: who_line[0].user,\n              tty: who_line[0].tty,\n              date: who_line[0].date,\n              time: who_line[0].time,\n              ip: who_line[0].ip,\n              command: result_w.command\n            });\n          }\n        }\n      }\n    }\n  });\n  if (result.length === 0 && phase === 2) {\n    return result_who;\n  } else {\n    return result;\n  }\n}\n\nfunction parseUsersDarwin(lines) {\n  let result = [];\n  let result_who = [];\n  let result_w = {};\n  let who_line = {};\n\n  let is_whopart = true;\n  lines.forEach(function (line) {\n    if (line === '---') {\n      is_whopart = false;\n    } else {\n      let l = line.replace(/ +/g, ' ').split(' ');\n\n      // who part\n      if (is_whopart) {\n        result_who.push({\n          user: l[0],\n          tty: l[1],\n          date: ('' + new Date().getFullYear()) + '-' + ('0' + ('JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'.indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + '-' + ('0' + l[3]).slice(-2),\n          time: l[4],\n        });\n      } else {\n        // w part\n        // split by w_pos\n        result_w.user = l[0];\n        result_w.tty = l[1];\n        result_w.ip = (l[2] !== '-') ? l[2] : '';\n        result_w.command = l.slice(5, 1000).join(' ');\n        // find corresponding 'who' line\n        who_line = result_who.filter(function (obj) {\n          return (obj.user === result_w.user && (obj.tty.substring(3, 1000) === result_w.tty || obj.tty === result_w.tty));\n        });\n        if (who_line.length === 1) {\n          result.push({\n            user: who_line[0].user,\n            tty: who_line[0].tty,\n            date: who_line[0].date,\n            time: who_line[0].time,\n            ip: result_w.ip,\n            command: result_w.command\n          });\n        }\n      }\n    }\n  });\n  return result;\n}\n\nfunction users(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n\n      // linux\n      if (_linux) {\n        exec('who --ips; echo \"---\"; w | tail -n +2', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersLinux(lines, 1);\n            if (result.length === 0) {\n              exec('who; echo \"---\"; w | tail -n +2', function (error, stdout) {\n                if (!error) {\n                  // lines / split\n                  lines = stdout.toString().split('\\n');\n                  result = parseUsersLinux(lines, 2);\n                }\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } else {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          } else {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        });\n      }\n      if (_freebsd || _openbsd || _netbsd) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        exec('who; echo \"---\"; w -h', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n\n      if (_darwin) {\n        exec('who; echo \"---\"; w -ih', function (error, stdout) {\n          if (!error) {\n            // lines / split\n            let lines = stdout.toString().split('\\n');\n            result = parseUsersDarwin(lines);\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        try {\n          let cmd = 'Get-CimInstance Win32_LogonSession | select LogonId,@{n=\"StartTime\";e={$_.StartTime.ToString(\"yyyy-MM-dd HH:mm:ss\")}} | fl' + '; echo \\'#-#-#-#\\';';\n          cmd += 'Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ' + '; echo \\'#-#-#-#\\';';\n          cmd += '$process = (Get-CimInstance Win32_Process -Filter \"name = \\'explorer.exe\\'\"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo \\'#-#-#-#\\';';\n          cmd += 'query user';\n          util.powerShell(cmd).then((data) => {\n            if (data) {\n              data = data.split('#-#-#-#');\n              let sessions = parseWinSessions((data[0] || '').split(/\\n\\s*\\n/));\n              let loggedons = parseWinLoggedOn((data[1] || '').split(/\\n\\s*\\n/));\n              let queryUser = parseWinUsersQuery((data[3] || '').split('\\r\\n'));\n              let users = parseWinUsers((data[2] || '').split(/\\n\\s*\\n/), queryUser);\n              for (let id in loggedons) {\n                if ({}.hasOwnProperty.call(loggedons, id)) {\n                  loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : '';\n                }\n              }\n              users.forEach(user => {\n                let dateTime = '';\n                for (let id in loggedons) {\n                  if ({}.hasOwnProperty.call(loggedons, id)) {\n                    if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {\n                      dateTime = loggedons[id].dateTime;\n                    }\n                  }\n                }\n\n                result.push({\n                  user: user.user,\n                  tty: user.tty,\n                  date: `${dateTime.substring(0, 10)}`,\n                  time: `${dateTime.substring(11, 19)}`,\n                  ip: '',\n                  command: ''\n                });\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction parseWinSessions(sessionParts) {\n  const sessions = {};\n  sessionParts.forEach(session => {\n    const lines = session.split('\\r\\n');\n    const id = util.getValue(lines, 'LogonId');\n    const starttime = util.getValue(lines, 'starttime');\n    if (id) {\n      sessions[id] = starttime;\n    }\n  });\n  return sessions;\n}\n\nfunction fuzzyMatch(name1, name2) {\n  name1 = name1.toLowerCase();\n  name2 = name2.toLowerCase();\n  let eq = 0;\n  let len = name1.length;\n  if (name2.length > len) { len = name2.length; }\n\n  for (let i = 0; i < len; i++) {\n    const c1 = name1[i] || '';\n    const c2 = name2[i] || '';\n    if (c1 === c2) { eq++; }\n  }\n  return (len > 10 ? eq / len > 0.9 : (len > 0 ? eq / len > 0.8 : false));\n}\n\nfunction parseWinUsers(userParts, userQuery) {\n  const users = [];\n  userParts.forEach(user => {\n    const lines = user.split('\\r\\n');\n\n    const domain = util.getValue(lines, 'domain', ':', true);\n    const username = util.getValue(lines, 'user', ':', true);\n    const sessionid = util.getValue(lines, 'sessionid', ':', true);\n\n    if (username) {\n      const quser = userQuery.filter(item => fuzzyMatch(item.user, username));\n      users.push({\n        domain,\n        user: username,\n        tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid\n      });\n    }\n  });\n  return users;\n}\n\nfunction parseWinLoggedOn(loggedonParts) {\n  const loggedons = {};\n  loggedonParts.forEach(loggedon => {\n    const lines = loggedon.split('\\r\\n');\n\n    const antecendent = util.getValue(lines, 'antecedent', ':', true);\n    let parts = antecendent.split('=');\n    const name = parts.length > 2 ? parts[1].split(',')[0].replace(/\"/g, '').trim() : '';\n    const domain = parts.length > 2 ? parts[2].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    const dependent = util.getValue(lines, 'dependent', ':', true);\n    parts = dependent.split('=');\n    const id = parts.length > 1 ? parts[1].replace(/\"/g, '').replace(/\\)/g, '').trim() : '';\n    if (id) {\n      loggedons[id] = {\n        domain,\n        user: name\n      };\n    }\n  });\n  return loggedons;\n}\n\nfunction parseWinUsersQuery(lines) {\n  lines = lines.filter(item => item);\n  let result = [];\n  const header = lines[0];\n  const headerDelimiter = [];\n  if (header) {\n    const start = (header[0] === ' ') ? 1 : 0;\n    headerDelimiter.push(start - 1);\n    let nextSpace = 0;\n    for (let i = start + 1; i < header.length; i++) {\n      if (header[i] === ' ' && ((header[i - 1] === ' ') || (header[i - 1] === '.'))) {\n        nextSpace = i;\n      } else {\n        if (nextSpace) {\n          headerDelimiter.push(nextSpace);\n          nextSpace = 0;\n        }\n      }\n    }\n    for (let i = 1; i < lines.length; i++) {\n      if (lines[i].trim()) {\n        const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || '';\n        const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || '';\n        result.push({\n          user: user,\n          tty: tty,\n        });\n      }\n    }\n  }\n  return result;\n}\n\nexports.users = users;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst path = require('path');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\nlet _smartMonToolsInstalled = null;\n\nconst WINDIR = process.env.WINDIR || 'C:\\\\Windows';\n\n// powerShell\nlet _psChild;\nlet _psResult = '';\nlet _psCmds = [];\nlet _psPersistent = false;\nconst _psToUTF8 = '$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ';\nconst _psCmdStart = '--###START###--';\nconst _psError = '--ERROR--';\nconst _psCmdSeperator = '--###ENDCMD###--';\nconst _psIdSeperator = '--##ID##--';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\n\nconst stringReplace = new String().replace;\nconst stringToLower = new String().toLowerCase;\nconst stringToString = new String().toString;\nconst stringSubstr = new String().substr;\nconst stringTrim = new String().trim;\nconst stringStartWith = new String().startsWith;\nconst mathMin = Math.min;\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed, lineMatch) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  lineMatch = lineMatch || false;\n  let result = '';\n  lines.forEach((line) => {\n    let lineLower = line.toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      lineLower = lineLower.trim();\n    }\n    if (lineLower.startsWith(property) && (lineMatch ? (lineLower.match(property + separator)) || (lineLower.match(property + ' ' + separator)) : true)) {\n      const parts = trimmed ? line.trim().split(separator) : line.split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        result = parts.join(separator).trim();\n      }\n    }\n  });\n  return result;\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('ös') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 5000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (let i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC', execOptsWin).toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        powerShell(getWmic() + ' ' + command).then(stdout => {\n          resolve(stdout, '');\n        });\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? `\"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\\\VBoxManage.exe\"` : 'vboxmanage';\n}\n\nfunction powerShellProceedResults(data) {\n  let id = '';\n  let parts;\n  let res = '';\n  // startID\n  if (data.indexOf(_psCmdStart) >= 0) {\n    parts = data.split(_psCmdStart);\n    const parts2 = parts[1].split(_psIdSeperator);\n    id = parts2[0];\n    if (parts2.length > 1) {\n      data = parts2.slice(1).join(_psIdSeperator);\n    }\n  }\n  // result;\n  if (data.indexOf(_psCmdSeperator) >= 0) {\n    parts = data.split(_psCmdSeperator);\n    res = parts[0];\n  }\n  let remove = -1;\n  for (let i = 0; i < _psCmds.length; i++) {\n    if (_psCmds[i].id === id) {\n      remove = i;\n      _psCmds[i].callback(res);\n    }\n  }\n  if (remove >= 0) {\n    _psCmds.splice(remove, 1);\n  }\n}\n\nfunction powerShellStart() {\n  if (!_psChild) {\n    _psChild = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-Command', '-'], {\n      stdio: 'pipe',\n      windowsHide: true,\n      maxBuffer: 1024 * 20000,\n      encoding: 'UTF-8',\n      env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n    });\n    if (_psChild && _psChild.pid) {\n      _psPersistent = true;\n      _psChild.stdout.on('data', function (data) {\n        _psResult = _psResult + data.toString('utf8');\n        if (data.indexOf(_psCmdSeperator) >= 0) {\n          powerShellProceedResults(_psResult);\n          _psResult = '';\n        }\n      });\n      _psChild.stderr.on('data', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('error', function () {\n        powerShellProceedResults(_psResult + _psError);\n      });\n      _psChild.on('close', function () {\n        _psChild.kill();\n      });\n    }\n  }\n}\n\nfunction powerShellRelease() {\n  try {\n    if (_psChild) {\n      _psChild.stdin.write('exit' + os.EOL);\n      _psChild.stdin.end();\n      _psPersistent = false;\n    }\n  } catch (e) {\n    if (_psChild) { _psChild.kill(); }\n  }\n  _psChild = null;\n}\n\nfunction powerShell(cmd) {\n\n  if (_psPersistent) {\n    const id = Math.random().toString(36).substring(2, 12);\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        function callback(data) {\n          resolve(data);\n        }\n        _psCmds.push({\n          id,\n          cmd,\n          callback,\n          start: new Date()\n        });\n        try {\n          if (_psChild && _psChild.pid) {\n            _psChild.stdin.write(_psToUTF8 + 'echo ' + _psCmdStart + id + _psIdSeperator + '; ' + os.EOL + cmd + os.EOL + 'echo ' + _psCmdSeperator + os.EOL);\n          }\n        } catch (e) {\n          resolve('');\n        }\n      });\n    });\n\n  } else {\n    let result = '';\n\n    return new Promise((resolve) => {\n      process.nextTick(() => {\n        try {\n          const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n            stdio: 'pipe',\n            windowsHide: true,\n            maxBuffer: 1024 * 20000,\n            encoding: 'UTF-8',\n            env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n          });\n\n          if (child && !child.pid) {\n            child.on('error', function () {\n              resolve(result);\n            });\n          }\n          if (child && child.pid) {\n            child.stdout.on('data', function (data) {\n              result = result + data.toString('utf8');\n            });\n            child.stderr.on('data', function () {\n              child.kill();\n              resolve(result);\n            });\n            child.on('close', function () {\n              child.kill();\n\n              resolve(result);\n            });\n            child.on('error', function () {\n              child.kill();\n              resolve(result);\n            });\n            try {\n              child.stdin.write(_psToUTF8 + cmd + os.EOL);\n              child.stdin.write('exit' + os.EOL);\n              child.stdin.end();\n            } catch (e) {\n              child.kill();\n              resolve(result);\n            }\n          } else {\n            resolve(result);\n          }\n        } catch (e) {\n          resolve(result);\n        }\n      });\n    });\n  }\n}\n\nfunction execSafe(cmd, args, options) {\n  let result = '';\n  options = options || {};\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn(cmd, args, options);\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result += data.toString();\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp', execOptsWin);\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '').trim() : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction smartMonToolsInstalled() {\n  if (_smartMonToolsInstalled !== null) {\n    return _smartMonToolsInstalled;\n  }\n  _smartMonToolsInstalled = false;\n  if (_windows) {\n    try {\n      const pathArray = execSync('WHERE smartctl 2>nul', execOptsWin).toString().split('\\r\\n');\n      if (pathArray && pathArray.length) {\n        _smartMonToolsInstalled = pathArray[0].indexOf(':\\\\') >= 0;\n      } else {\n        _smartMonToolsInstalled = false;\n      }\n    } catch (e) {\n      _smartMonToolsInstalled = false;\n    }\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    const pathArray = execSync('which smartctl 2>/dev/null', execOptsWin).toString().split('\\r\\n');\n    _smartMonToolsInstalled = pathArray.length > 0;\n  }\n  return _smartMonToolsInstalled;\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2711',\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).toString().split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id', '=');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str, strict) {\n  if (typeof strict === 'undefined') { strict = false; }\n  const s = str || '';\n  let result = '';\n  for (let i = 0; i <= mathMin(s.length, 2000); i++) {\n    if (!(s[i] === undefined ||\n      s[i] === '>' ||\n      s[i] === '<' ||\n      s[i] === '*' ||\n      s[i] === '?' ||\n      s[i] === '[' ||\n      s[i] === ']' ||\n      s[i] === '|' ||\n      s[i] === '˚' ||\n      s[i] === '$' ||\n      s[i] === ';' ||\n      s[i] === '&' ||\n      s[i] === '(' ||\n      s[i] === ')' ||\n      s[i] === ']' ||\n      s[i] === '#' ||\n      s[i] === '\\\\' ||\n      s[i] === '\\t' ||\n      s[i] === '\\n' ||\n      s[i] === '\\'' ||\n      s[i] === '`' ||\n      s[i] === '\"' ||\n      s[i].length > 1 ||\n      (strict && s[i] === '@') ||\n      (strict && s[i] === ' ') ||\n      (strict && s[i] == '{') ||\n      (strict && s[i] == ')'))) {\n      result = result + s[i];\n    }\n  }\n  return result;\n}\n\nfunction isPrototypePolluted() {\n  const s = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  let notPolluted = true;\n  let st = '';\n\n  st.__proto__.replace = stringReplace;\n  st.__proto__.toLowerCase = stringToLower;\n  st.__proto__.toString = stringToString;\n  st.__proto__.substr = stringSubstr;\n\n  notPolluted = notPolluted || (s.length !== 62);\n  const ms = Date.now();\n  if (typeof ms === 'number' && ms > 1600000000000) {\n    const l = ms % 100 + 15;\n    for (let i = 0; i < l; i++) {\n      const r = Math.random() * 61.99999999 + 1;\n      const rs = parseInt(Math.floor(r).toString(), 10);\n      const rs2 = parseInt(r.toString().split('.')[0], 10);\n      const q = Math.random() * 61.99999999 + 1;\n      const qs = parseInt(Math.floor(q).toString(), 10);\n      const qs2 = parseInt(q.toString().split('.')[0], 10);\n      notPolluted = notPolluted && (r !== q);\n      notPolluted = notPolluted && rs === rs2 && qs === qs2;\n      st += s[rs - 1];\n    }\n    notPolluted = notPolluted && st.length === l;\n    // string manipulation\n    let p = Math.random() * l * 0.9999999999;\n    let stm = st.substr(0, p) + ' ' + st.substr(p, 2000);\n    stm.__proto__.replace = stringReplace;\n    let sto = stm.replace(/ /g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '{' + st.substr(p, 2000);\n    sto = stm.replace(/{/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '*' + st.substr(p, 2000);\n    sto = stm.replace(/\\*/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '$' + st.substr(p, 2000);\n    sto = stm.replace(/\\$/g, '');\n    notPolluted = notPolluted && st === sto;\n\n    // lower\n    const stl = st.toLowerCase();\n    notPolluted = notPolluted && (stl.length === l) && stl[l - 1] && !(stl[l]);\n    for (let i = 0; i < l; i++) {\n      const s1 = st[i];\n      s1.__proto__.toLowerCase = stringToLower;\n      const s2 = stl ? stl[i] : '';\n      const s1l = s1.toLowerCase();\n      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !(s1l[1]);\n    }\n  }\n  return !notPolluted;\n}\n\nfunction hex2bin(hex) {\n  return ('00000000' + (parseInt(hex, 16)).toString(2)).substr(-8);\n}\n\nfunction getFilesInPath(source) {\n  const lstatSync = fs.lstatSync;\n  const readdirSync = fs.readdirSync;\n  const join = path.join;\n\n  function isDirectory(source) {\n    return lstatSync(source).isDirectory();\n  }\n  function isFile(source) { return lstatSync(source).isFile(); }\n\n  function getDirectories(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isDirectory);\n  }\n  function getFiles(source) {\n    return readdirSync(source).map(function (name) { return join(source, name); }).filter(isFile);\n  }\n\n  function getFilesRecursively(source) {\n    try {\n      let dirs = getDirectories(source);\n      let files = dirs\n        .map(function (dir) { return getFilesRecursively(dir); })\n        .reduce(function (a, b) { return a.concat(b); }, []);\n      return files.concat(getFiles(source));\n    } catch (e) {\n      return [];\n    }\n  }\n\n  if (fs.existsSync(source)) {\n    return getFilesRecursively(source);\n  } else {\n    return [];\n  }\n}\n\nfunction decodePiCpuinfo(lines) {\n\n  // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n\n  const oldRevisionCodes = {\n    '0002': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0003': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0004': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0005': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '0006': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0007': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0008': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0009': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '000d': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '000e': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '000f': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0010': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0011': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0012': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0013': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0014': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0015': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: '512MB\tEmbest',\n      processor: 'BCM2835'\n    }\n  };\n\n  const processorList = [\n    'BCM2835',\n    'BCM2836',\n    'BCM2837',\n    'BCM2711',\n  ];\n  const manufacturerList = [\n    'Sony UK',\n    'Egoman',\n    'Embest',\n    'Sony Japan',\n    'Embest',\n    'Stadium'\n  ];\n  const typeList = {\n    '00': 'A',\n    '01': 'B',\n    '02': 'A+',\n    '03': 'B+',\n    '04': '2B',\n    '05': 'Alpha (early prototype)',\n    '06': 'CM1',\n    '08': '3B',\n    '09': 'Zero',\n    '0a': 'CM3',\n    '0c': 'Zero W',\n    '0d': '3B+',\n    '0e': '3A+',\n    '0f': 'Internal use only',\n    '10': 'CM3+',\n    '11': '4B',\n    '12': 'Zero 2 W',\n    '13': '400',\n    '14': 'CM4'\n  };\n\n  const revisionCode = getValue(lines, 'revision', ':', true);\n  const model = getValue(lines, 'model:', ':', true);\n  const serial = getValue(lines, 'serial', ':', true);\n\n  let result = {};\n  if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {\n    // old revision codes\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: oldRevisionCodes[revisionCode].memory,\n      manufacturer: oldRevisionCodes[revisionCode].manufacturer,\n      processor: oldRevisionCodes[revisionCode].processor,\n      type: oldRevisionCodes[revisionCode].type,\n      revision: oldRevisionCodes[revisionCode].revision,\n    };\n\n  } else {\n    // new revision code\n    const revision = ('00000000' + getValue(lines, 'revision', ':', true).toLowerCase()).substr(-8);\n    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;\n    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];\n    const processor = processorList[parseInt(revision.substr(4, 1), 10)];\n    const typeCode = revision.substr(5, 2);\n\n\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: 256 * Math.pow(2, memSizeCode),\n      manufacturer,\n      processor,\n      type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : '',\n      revision: '1.' + revision.substr(7, 1),\n    };\n  }\n  return result;\n}\n\nfunction promiseAll(promises) {\n  const resolvingPromises = promises.map(function (promise) {\n    return new Promise(function (resolve) {\n      let payload = new Array(2);\n      promise.then(function (result) {\n        payload[0] = result;\n      })\n        .catch(function (error) {\n          payload[1] = error;\n        })\n        .then(function () {\n          // The wrapped Promise returns an array: 0 = result, 1 = error ... we resolve all\n          resolve(payload);\n        });\n    });\n  });\n  const errors = [];\n  const results = [];\n\n  // Execute all wrapped Promises\n  return Promise.all(resolvingPromises)\n    .then(function (items) {\n      items.forEach(function (payload) {\n        if (payload[1]) {\n          errors.push(payload[1]);\n          results.push(null);\n        } else {\n          errors.push(null);\n          results.push(payload[0]);\n        }\n      });\n\n      return {\n        errors: errors,\n        results: results\n      };\n    });\n}\n\nfunction promisify(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction promisifySave(nodeStyleFunction) {\n  return function () {\n    const args = Array.prototype.slice.call(arguments);\n    return new Promise(function (resolve) {\n      args.push(function (err, data) {\n        resolve(data);\n      });\n      nodeStyleFunction.apply(null, args);\n    });\n  };\n}\n\nfunction linuxVersion() {\n  let result = '';\n  if (_linux) {\n    try {\n      result = execSync('uname -v').toString();\n    } catch (e) {\n      result = '';\n    }\n  }\n  return result;\n}\n\nfunction plistParser(xmlStr) {\n  const tags = ['array', 'dict', 'key', 'string', 'integer', 'date', 'real', 'data', 'boolean', 'arrayEmpty'];\n  const startStr = '<plist version';\n\n  let pos = xmlStr.indexOf(startStr);\n  let len = xmlStr.length;\n  while (xmlStr[pos] !== '>' && pos < len) {\n    pos++;\n  }\n\n  let depth = 0;\n  let inTagStart = false;\n  let inTagContent = false;\n  let inTagEnd = false;\n  let metaData = [{ tagStart: '', tagEnd: '', tagContent: '', key: '', data: null }];\n  let c = '';\n  let cn = xmlStr[pos];\n\n  while (pos < len) {\n    c = cn;\n    if (pos + 1 < len) { cn = xmlStr[pos + 1]; }\n    if (c === '<') {\n      inTagContent = false;\n      if (cn === '/') { inTagEnd = true; }\n      else if (metaData[depth].tagStart) {\n        metaData[depth].tagContent = '';\n        if (!metaData[depth].data) { metaData[depth].data = metaData[depth].tagStart === 'array' ? [] : {}; }\n        depth++;\n        metaData.push({ tagStart: '', tagEnd: '', tagContent: '', key: null, data: null });\n        inTagStart = true;\n        inTagContent = false;\n      }\n      else if (!inTagStart) { inTagStart = true; }\n    } else if (c === '>') {\n      if (metaData[depth].tagStart === 'true/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = true; }\n      if (metaData[depth].tagStart === 'false/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/boolean'; metaData[depth].data = false; }\n      if (metaData[depth].tagStart === 'array/') { inTagStart = false; inTagEnd = true; metaData[depth].tagStart = ''; metaData[depth].tagEnd = '/arrayEmpty'; metaData[depth].data = []; }\n      if (inTagContent) { inTagContent = false; }\n      if (inTagStart) {\n        inTagStart = false;\n        inTagContent = true;\n        if (metaData[depth].tagStart === 'array') {\n          metaData[depth].data = [];\n        }\n        if (metaData[depth].tagStart === 'dict') {\n          metaData[depth].data = {};\n        }\n      }\n      if (inTagEnd) {\n        inTagEnd = false;\n        if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {\n          if (metaData[depth].tagEnd === '/dict' || metaData[depth].tagEnd === '/array') {\n            if (depth > 1 && metaData[depth - 2].tagStart === 'array') {\n              metaData[depth - 2].data.push(metaData[depth - 1].data);\n            }\n            if (depth > 1 && metaData[depth - 2].tagStart === 'dict') {\n              metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;\n            }\n            depth--;\n            metaData.pop();\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n          else {\n            if (metaData[depth].tagEnd === '/key' && metaData[depth].tagContent) {\n              metaData[depth].key = metaData[depth].tagContent;\n            } else {\n              if (metaData[depth].tagEnd === '/real' && metaData[depth].tagContent) { metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/integer' && metaData[depth].tagContent) { metaData[depth].data = parseInt(metaData[depth].tagContent) || 0; }\n              if (metaData[depth].tagEnd === '/string' && metaData[depth].tagContent) { metaData[depth].data = metaData[depth].tagContent || ''; }\n              if (metaData[depth].tagEnd === '/boolean') { metaData[depth].data = metaData[depth].tagContent || false; }\n              if (metaData[depth].tagEnd === '/arrayEmpty') { metaData[depth].data = metaData[depth].tagContent || []; }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'array') { metaData[depth - 1].data.push(metaData[depth].data); }\n              if (depth > 0 && metaData[depth - 1].tagStart === 'dict') { metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data; }\n            }\n            metaData[depth].tagContent = '';\n            metaData[depth].tagStart = '';\n            metaData[depth].tagEnd = '';\n          }\n        }\n        metaData[depth].tagEnd = '';\n        inTagStart = false;\n        inTagContent = false;\n      }\n    } else {\n      if (inTagStart) { metaData[depth].tagStart += c; }\n      if (inTagEnd) { metaData[depth].tagEnd += c; }\n      if (inTagContent) { metaData[depth].tagContent += c; }\n    }\n    pos++;\n  }\n  return metaData[0].data;\n}\n\nfunction strIsNumeric(str) {\n  return typeof str === 'string' && !isNaN(str) && !isNaN(parseFloat(str));\n}\n\nfunction plistReader(output) {\n  const lines = output.split('\\n');\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].indexOf(' = ') >= 0) {\n      const lineParts = lines[i].split(' = ');\n      lineParts[0] = lineParts[0].trim();\n      if (!lineParts[0].startsWith('\"')) {\n        lineParts[0] = '\"' + lineParts[0] + '\"';\n      }\n      lineParts[1] = lineParts[1].trim();\n      if (lineParts[1].indexOf('\"') === -1 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1);\n        if (!strIsNumeric(valueString)) {\n          lineParts[1] = `\"${valueString}\";`;\n        }\n      }\n      if (lineParts[1].indexOf('\"') >= 0 && lineParts[1].endsWith(';')) {\n        const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/\"/g, '');\n        if (strIsNumeric(valueString)) {\n          lineParts[1] = `${valueString};`;\n        }\n      }\n      lines[i] = lineParts.join(' : ');\n    }\n    lines[i] = lines[i].replace(/\\(/g, '[').replace(/\\)/g, ']').replace(/;/g, ',').trim();\n    if (lines[i].startsWith('}') && lines[i - 1] && lines[i - 1].endsWith(',')) {\n      lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);\n    }\n  }\n  output = lines.join('');\n  let obj = {};\n  try {\n    obj = JSON.parse(output);\n  } catch (e) {\n    noop();\n  }\n  return obj;\n}\n\nfunction semverCompare(v1, v2) {\n  let res = 0;\n  const parts1 = v1.split('.');\n  const parts2 = v2.split('.');\n  if (parts1[0] < parts2[0]) { res = 1; }\n  else if (parts1[0] > parts2[0]) { res = -1; }\n  else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {\n    if (parts1[1] < parts2[1]) { res = 1; }\n    else if (parts1[1] > parts2[1]) { res = -1; }\n    else if (parts1[1] === parts2[1]) {\n      if (parts1.length >= 3 && parts2.length >= 3) {\n        if (parts1[2] < parts2[2]) { res = 1; }\n        else if (parts1[2] > parts2[2]) { res = -1; }\n      } else if (parts2.length >= 3) {\n        res = 1;\n      }\n    }\n  }\n  return res;\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.powerShellStart = powerShellStart;\nexports.powerShellRelease = powerShellRelease;\nexports.execSafe = execSafe;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\nexports.isPrototypePolluted = isPrototypePolluted;\nexports.decodePiCpuinfo = decodePiCpuinfo;\nexports.promiseAll = promiseAll;\nexports.promisify = promisify;\nexports.promisifySave = promisifySave;\nexports.smartMonToolsInstalled = smartMonToolsInstalled;\nexports.linuxVersion = linuxVersion;\nexports.plistParser = plistParser;\nexports.plistReader = plistReader;\nexports.stringReplace = stringReplace;\nexports.stringToLower = stringToLower;\nexports.stringToString = stringToString;\nexports.stringSubstr = stringSubstr;\nexports.stringTrim = stringTrim;\nexports.stringStartWith = stringStartWith;\nexports.mathMin = mathMin;\nexports.WINDIR = WINDIR;\nexports.getFilesInPath = getFilesInPath;\nexports.semverCompare = semverCompare;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// virtualbox.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 14. Docker\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nfunction vboxInfo(callback) {\n\n  // fallback - if only callback is given\n  let result = [];\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(util.getVboxmanage() + ' list vms --long', function (error, stdout) {\n          let parts = (os.EOL + stdout.toString()).split(os.EOL + 'Name:');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = ('Name:' + part).split(os.EOL);\n            const state = util.getValue(lines, 'State');\n            const running = state.startsWith('running');\n            const runningSinceString = running ? state.replace('running (since ', '').replace(')', '').trim() : '';\n            let runningSince = 0;\n            try {\n              if (running) {\n                const sinceDateObj = new Date(runningSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            const stoppedSinceString = !running ? state.replace('powered off (since', '').replace(')', '').trim() : '';\n            let stoppedSince = 0;\n            try {\n              if (!running) {\n                const sinceDateObj = new Date(stoppedSinceString);\n                const offset = sinceDateObj.getTimezoneOffset();\n                stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1000) + offset * 60;\n              }\n            } catch (e) {\n              util.noop();\n            }\n            result.push({\n              id: util.getValue(lines, 'UUID'),\n              name: util.getValue(lines, 'Name'),\n              running,\n              started: runningSinceString,\n              runningSince,\n              stopped: stoppedSinceString,\n              stoppedSince,\n              guestOS: util.getValue(lines, 'Guest OS'),\n              hardwareUUID: util.getValue(lines, 'Hardware UUID'),\n              memory: parseInt(util.getValue(lines, 'Memory size', '     '), 10),\n              vram: parseInt(util.getValue(lines, 'VRAM size'), 10),\n              cpus: parseInt(util.getValue(lines, 'Number of CPUs'), 10),\n              cpuExepCap: util.getValue(lines, 'CPU exec cap'),\n              cpuProfile: util.getValue(lines, 'CPUProfile'),\n              chipset: util.getValue(lines, 'Chipset'),\n              firmware: util.getValue(lines, 'Firmware'),\n              pageFusion: util.getValue(lines, 'Page Fusion') === 'enabled',\n              configFile: util.getValue(lines, 'Config file'),\n              snapshotFolder: util.getValue(lines, 'Snapshot folder'),\n              logFolder: util.getValue(lines, 'Log folder'),\n              hpet: util.getValue(lines, 'HPET') === 'enabled',\n              pae: util.getValue(lines, 'PAE') === 'enabled',\n              longMode: util.getValue(lines, 'Long Mode') === 'enabled',\n              tripleFaultReset: util.getValue(lines, 'Triple Fault Reset') === 'enabled',\n              apic: util.getValue(lines, 'APIC') === 'enabled',\n              x2Apic: util.getValue(lines, 'X2APIC') === 'enabled',\n              acpi: util.getValue(lines, 'ACPI') === 'enabled',\n              ioApic: util.getValue(lines, 'IOAPIC') === 'enabled',\n              biosApicMode: util.getValue(lines, 'BIOS APIC mode'),\n              bootMenuMode: util.getValue(lines, 'Boot menu mode'),\n              bootDevice1: util.getValue(lines, 'Boot Device 1'),\n              bootDevice2: util.getValue(lines, 'Boot Device 2'),\n              bootDevice3: util.getValue(lines, 'Boot Device 3'),\n              bootDevice4: util.getValue(lines, 'Boot Device 4'),\n              timeOffset: util.getValue(lines, 'Time offset'),\n              rtc: util.getValue(lines, 'RTC'),\n            });\n          });\n\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      } catch (e) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.vboxInfo = vboxInfo;\n","'use strict';\n// @ts-check\n// ==================================================================================\n// wifi.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2023\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. wifi\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux' || _platform === 'android');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\n\nfunction wifiDBFromQuality(quality) {\n  return (parseFloat(quality) / 2 - 100);\n}\n\nfunction wifiQualityFromDB(db) {\n  const result = 2 * (parseFloat(db) + 100);\n  return result <= 100 ? result : 100;\n}\n\nconst _wifi_frequencies = {\n  1: 2412,\n  2: 2417,\n  3: 2422,\n  4: 2427,\n  5: 2432,\n  6: 2437,\n  7: 2442,\n  8: 2447,\n  9: 2452,\n  10: 2457,\n  11: 2462,\n  12: 2467,\n  13: 2472,\n  14: 2484,\n  32: 5160,\n  34: 5170,\n  36: 5180,\n  38: 5190,\n  40: 5200,\n  42: 5210,\n  44: 5220,\n  46: 5230,\n  48: 5240,\n  50: 5250,\n  52: 5260,\n  54: 5270,\n  56: 5280,\n  58: 5290,\n  60: 5300,\n  62: 5310,\n  64: 5320,\n  68: 5340,\n  96: 5480,\n  100: 5500,\n  102: 5510,\n  104: 5520,\n  106: 5530,\n  108: 5540,\n  110: 5550,\n  112: 5560,\n  114: 5570,\n  116: 5580,\n  118: 5590,\n  120: 5600,\n  122: 5610,\n  124: 5620,\n  126: 5630,\n  128: 5640,\n  132: 5660,\n  134: 5670,\n  136: 5680,\n  138: 5690,\n  140: 5700,\n  142: 5710,\n  144: 5720,\n  149: 5745,\n  151: 5755,\n  153: 5765,\n  155: 5775,\n  157: 5785,\n  159: 5795,\n  161: 5805,\n  165: 5825,\n  169: 5845,\n  173: 5865,\n  183: 4915,\n  184: 4920,\n  185: 4925,\n  187: 4935,\n  188: 4940,\n  189: 4945,\n  192: 4960,\n  196: 4980\n};\n\nfunction wifiFrequencyFromChannel(channel) {\n  return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;\n}\n\nfunction wifiChannelFromFrequencs(frequency) {\n  let channel = 0;\n  for (let key in _wifi_frequencies) {\n    if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {\n      if (_wifi_frequencies[key] === frequency) { channel = util.toInt(key); }\n    }\n  }\n  return channel;\n}\n\nfunction ifaceListLinux() {\n  const result = [];\n  const cmd = 'iw dev 2>/dev/null';\n  try {\n    const all = execSync(cmd).toString().split('\\n').map(line => line.trim()).join('\\n');\n    const parts = all.split('\\nInterface ');\n    parts.shift();\n    parts.forEach(ifaceDetails => {\n      const lines = ifaceDetails.split('\\n');\n      const iface = lines[0];\n      const id = util.toInt(util.getValue(lines, 'ifindex', ' '));\n      const mac = util.getValue(lines, 'addr', ' ');\n      const channel = util.toInt(util.getValue(lines, 'channel', ' '));\n      result.push({\n        id,\n        iface,\n        mac,\n        channel\n      });\n    });\n    return result;\n  } catch (e) {\n    try {\n      const all = execSync('nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null').toString();\n      const parts = all.split('\\nGENERAL.DEVICE:');\n      let i = 1;\n      parts.forEach(ifaceDetails => {\n        const lines = ifaceDetails.split('\\n');\n        const iface = util.getValue(lines, 'GENERAL.DEVICE');\n        const type = util.getValue(lines, 'GENERAL.TYPE');\n        const id = i++; // // util.getValue(lines, 'GENERAL.PATH');\n        const mac = util.getValue(lines, 'GENERAL.HWADDR');\n        const channel = '';\n        if (type.toLowerCase() === 'wifi') {\n          result.push({\n            id,\n            iface,\n            mac,\n            channel\n          });\n        }\n      });\n      return result;\n    } catch (e) {\n      return [];\n    }\n  }\n}\n\nfunction nmiDeviceLinux(iface) {\n  const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const ssid = util.getValue(lines, 'GENERAL.CONNECTION');\n    return {\n      iface,\n      type: util.getValue(lines, 'GENERAL.TYPE'),\n      vendor: util.getValue(lines, 'GENERAL.VENDOR'),\n      product: util.getValue(lines, 'GENERAL.PRODUCT'),\n      mac: util.getValue(lines, 'GENERAL.HWADDR').toLowerCase(),\n      ssid: ssid !== '--' ? ssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction nmiConnectionLinux(ssid) {\n  const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const bssid = util.getValue(lines, '802-11-wireless.seen-bssids').toLowerCase();\n    return {\n      ssid: ssid !== '--' ? ssid : null,\n      uuid: util.getValue(lines, 'connection.uuid'),\n      type: util.getValue(lines, 'connection.type'),\n      autoconnect: util.getValue(lines, 'connection.autoconnect') === 'yes',\n      security: util.getValue(lines, '802-11-wireless-security.key-mgmt'),\n      bssid: bssid !== '--' ? bssid : null\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction wpaConnectionLinux(iface) {\n  const cmd = `wpa_cli -i ${iface} status 2>&1`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    const freq = util.toInt(util.getValue(lines, 'freq', '='));\n    return {\n      ssid: util.getValue(lines, 'ssid', '='),\n      uuid: util.getValue(lines, 'uuid', '='),\n      security: util.getValue(lines, 'key_mgmt', '='),\n      freq,\n      channel: wifiChannelFromFrequencs(freq),\n      bssid: util.getValue(lines, 'bssid', '=').toLowerCase()\n    };\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction getWifiNetworkListNmi() {\n  const result = [];\n  const cmd = 'nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null';\n  try {\n    const stdout = execSync(cmd, { maxBuffer: 1024 * 20000 });\n    const parts = stdout.toString().split('ACTIVE:');\n    parts.shift();\n    parts.forEach(part => {\n      part = 'ACTIVE:' + part;\n      const lines = part.split(os.EOL);\n      const channel = util.getValue(lines, 'CHAN');\n      const frequency = util.getValue(lines, 'FREQ').toLowerCase().replace('mhz', '').trim();\n      const security = util.getValue(lines, 'SECURITY').replace('(', '').replace(')', '');\n      const wpaFlags = util.getValue(lines, 'WPA-FLAGS').replace('(', '').replace(')', '');\n      const rsnFlags = util.getValue(lines, 'RSN-FLAGS').replace('(', '').replace(')', '');\n      result.push({\n        ssid: util.getValue(lines, 'SSID'),\n        bssid: util.getValue(lines, 'BSSID').toLowerCase(),\n        mode: util.getValue(lines, 'MODE'),\n        channel: channel ? parseInt(channel, 10) : null,\n        frequency: frequency ? parseInt(frequency, 10) : null,\n        signalLevel: wifiDBFromQuality(util.getValue(lines, 'SIGNAL')),\n        quality: parseFloat(util.getValue(lines, 'SIGNAL')),\n        security: security && security !== 'none' ? security.split(' ') : [],\n        wpaFlags: wpaFlags && wpaFlags !== 'none' ? wpaFlags.split(' ') : [],\n        rsnFlags: rsnFlags && rsnFlags !== 'none' ? rsnFlags.split(' ') : []\n      });\n    });\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getWifiNetworkListIw(iface) {\n  const result = [];\n  try {\n    let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`).toString().split('        Cell ');\n    if (iwlistParts[0].indexOf('resource busy') >= 0) { return -1; }\n    if (iwlistParts.length > 1) {\n      iwlistParts.shift();\n      iwlistParts.forEach(element => {\n        const lines = element.split('\\n');\n        const channel = util.getValue(lines, 'channel', ':', true);\n        const address = (lines && lines.length && lines[0].indexOf('Address:') >= 0 ? lines[0].split('Address:')[1].trim().toLowerCase() : '');\n        const mode = util.getValue(lines, 'mode', ':', true);\n        const frequency = util.getValue(lines, 'frequency', ':', true);\n        const qualityString = util.getValue(lines, 'Quality', '=', true);\n        const dbParts = qualityString.toLowerCase().split('signal level=');\n        const db = dbParts.length > 1 ? util.toInt(dbParts[1]) : 0;\n        const quality = db ? wifiQualityFromDB(db) : 0;\n        const ssid = util.getValue(lines, 'essid', ':', true);\n\n        // security and wpa-flags\n        const isWpa = element.indexOf(' WPA ') >= 0;\n        const isWpa2 = element.indexOf('WPA2 ') >= 0;\n        const security = [];\n        if (isWpa) { security.push('WPA'); }\n        if (isWpa2) { security.push('WPA2'); }\n        const wpaFlags = [];\n        let wpaFlag = '';\n        lines.forEach(function (line) {\n          const l = line.trim().toLowerCase();\n          if (l.indexOf('group cipher') >= 0) {\n            if (wpaFlag) {\n              wpaFlags.push(wpaFlag);\n            }\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              wpaFlag = parts[1].trim().toUpperCase();\n            }\n          }\n          if (l.indexOf('pairwise cipher') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('tkip')) { wpaFlag = (wpaFlag ? 'TKIP/' + wpaFlag : 'TKIP'); }\n              else if (parts[1].indexOf('ccmp')) { wpaFlag = (wpaFlag ? 'CCMP/' + wpaFlag : 'CCMP'); }\n              else if (parts[1].indexOf('proprietary')) { wpaFlag = (wpaFlag ? 'PROP/' + wpaFlag : 'PROP'); }\n            }\n          }\n          if (l.indexOf('authentication suites') >= 0) {\n            const parts = l.split(':');\n            if (parts.length > 1) {\n              if (parts[1].indexOf('802.1x')) { wpaFlag = (wpaFlag ? '802.1x/' + wpaFlag : '802.1x'); }\n              else if (parts[1].indexOf('psk')) { wpaFlag = (wpaFlag ? 'PSK/' + wpaFlag : 'PSK'); }\n            }\n          }\n        });\n        if (wpaFlag) {\n          wpaFlags.push(wpaFlag);\n        }\n\n        result.push({\n          ssid,\n          bssid: address,\n          mode,\n          channel: channel ? util.toInt(channel) : null,\n          frequency: frequency ? util.toInt(frequency.replace('.', '')) : null,\n          signalLevel: db,\n          quality,\n          security,\n          wpaFlags,\n          rsnFlags: []\n        });\n      });\n    }\n    return result;\n  } catch (e) {\n    return -1;\n  }\n}\n\nfunction parseWifiDarwin(wifiObj) {\n  const result = [];\n  if (wifiObj) {\n    wifiObj.forEach(function (wifiItem) {\n      const signalLevel = wifiItem.RSSI;\n      let security = [];\n      let wpaFlags = [];\n      if (wifiItem.WPA_IE) {\n        security.push('WPA');\n        if (wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS) {\n          wifiItem.WPA_IE.IE_KEY_WPA_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('PSK/TKIP') === -1) { wpaFlags.push('PSK/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      if (wifiItem.RSN_IE) {\n        security.push('WPA2');\n        if (wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS) {\n          wifiItem.RSN_IE.IE_KEY_RSN_UCIPHERS.forEach(function (ciphers) {\n            if (ciphers === 0 && wpaFlags.indexOf('unknown/TKIP') === -1) { wpaFlags.push('unknown/TKIP'); }\n            if (ciphers === 2 && wpaFlags.indexOf('TKIP/TKIP') === -1) { wpaFlags.push('TKIP/TKIP'); }\n            if (ciphers === 4 && wpaFlags.indexOf('PSK/AES') === -1) { wpaFlags.push('PSK/AES'); }\n          });\n        }\n      }\n      result.push({\n        ssid: wifiItem.SSID_STR,\n        bssid: wifiItem.BSSID,\n        mode: '',\n        channel: wifiItem.CHANNEL,\n        frequency: wifiFrequencyFromChannel(wifiItem.CHANNEL),\n        signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,\n        quality: wifiQualityFromDB(signalLevel),\n        security,\n        wpaFlags,\n        rsnFlags: []\n      });\n    });\n  }\n  return result;\n}\nfunction wifiNetworks(callback) {\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux) {\n        result = getWifiNetworkListNmi();\n        if (result.length === 0) {\n          try {\n            const iwconfigParts = execSync('export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL').toString().split('\\n\\n');\n            let iface = '';\n            iwconfigParts.forEach(element => {\n              if (element.indexOf('no wireless') === -1 && element.trim() !== '') {\n                iface = element.split(' ')[0];\n              }\n            });\n            if (iface) {\n              const res = getWifiNetworkListIw(iface);\n              if (res === -1) {\n                // try again after 4 secs\n                setTimeout(function (iface) {\n                  const res = getWifiNetworkListIw(iface);\n                  if (res != -1) { result = res; }\n                  if (callback) {\n                    callback(result);\n                  }\n                  resolve(result);\n                }, 4000);\n              } else {\n                result = res;\n                if (callback) {\n                  callback(result);\n                }\n                resolve(result);\n              }\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          } catch (e) {\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        } else {\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        }\n      } else if (_darwin) {\n        let cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s -x';\n        exec(cmd, { maxBuffer: 1024 * 40000 }, function (error, stdout) {\n          const output = stdout.toString();\n          result = parseWifiDarwin(util.plistParser(output));\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show networks mode=Bssid';\n        util.powerShell(cmd).then((stdout) => {\n          const ssidParts = stdout.toString('utf8').split(os.EOL + os.EOL + 'SSID ');\n          ssidParts.shift();\n\n          ssidParts.forEach(ssidPart => {\n            const ssidLines = ssidPart.split(os.EOL);\n            if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(':') >= 0) {\n              const bssidsParts = ssidPart.split(' BSSID');\n              bssidsParts.shift();\n\n              bssidsParts.forEach((bssidPart) => {\n                const bssidLines = bssidPart.split(os.EOL);\n                const bssidLine = bssidLines[0].split(':');\n                bssidLine.shift();\n                const bssid = bssidLine.join(':').trim().toLowerCase();\n                const channel = bssidLines[3].split(':').pop().trim();\n                const quality = bssidLines[1].split(':').pop().trim();\n\n                result.push({\n                  ssid: ssidLines[0].split(':').pop().trim(),\n                  bssid,\n                  mode: '',\n                  channel: channel ? parseInt(channel, 10) : null,\n                  frequency: wifiFrequencyFromChannel(channel),\n                  signalLevel: wifiDBFromQuality(quality),\n                  quality: quality ? parseInt(quality, 10) : null,\n                  security: [ssidLines[2].split(':').pop().trim()],\n                  wpaFlags: [ssidLines[3].split(':').pop().trim()],\n                  rsnFlags: []\n                });\n              });\n            }\n          });\n\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiNetworks = wifiNetworks;\n\nfunction getVendor(model) {\n  model = model.toLowerCase();\n  let result = '';\n  if (model.indexOf('intel') >= 0) { result = 'Intel'; }\n  else if (model.indexOf('realtek') >= 0) { result = 'Realtek'; }\n  else if (model.indexOf('qualcom') >= 0) { result = 'Qualcom'; }\n  else if (model.indexOf('broadcom') >= 0) { result = 'Broadcom'; }\n  else if (model.indexOf('cavium') >= 0) { result = 'Cavium'; }\n  else if (model.indexOf('cisco') >= 0) { result = 'Cisco'; }\n  else if (model.indexOf('marvel') >= 0) { result = 'Marvel'; }\n  else if (model.indexOf('zyxel') >= 0) { result = 'Zyxel'; }\n  else if (model.indexOf('melanox') >= 0) { result = 'Melanox'; }\n  else if (model.indexOf('d-link') >= 0) { result = 'D-Link'; }\n  else if (model.indexOf('tp-link') >= 0) { result = 'TP-Link'; }\n  else if (model.indexOf('asus') >= 0) { result = 'Asus'; }\n  else if (model.indexOf('linksys') >= 0) { result = 'Linksys'; }\n  return result;\n}\n\nfunction wifiConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        const networkList = getWifiNetworkListNmi();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          const wpaDetails = wpaConnectionLinux(ifaceDetail.iface);\n          const ssid = nmiDetails.ssid || wpaDetails.ssid;\n          const network = networkList.filter(nw => nw.ssid === ssid);\n          const nmiConnection = nmiConnectionLinux(ssid);\n          const channel = network && network.length && network[0].channel ? network[0].channel : (wpaDetails.channel ? wpaDetails.channel : null);\n          const bssid = network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null);\n          if (ssid && bssid) {\n            result.push({\n              id: ifaceDetail.id,\n              iface: ifaceDetail.iface,\n              model: nmiDetails.product,\n              ssid,\n              bssid: network && network.length && network[0].bssid ? network[0].bssid : (wpaDetails.bssid ? wpaDetails.bssid : null),\n              channel,\n              frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n              type: nmiConnection.type ? nmiConnection.type : '802.11',\n              security: nmiConnection.security ? nmiConnection.security : (wpaDetails.security ? wpaDetails.security : null),\n              signalLevel: network && network.length && network[0].signalLevel ? network[0].signalLevel : null,\n              txRate: null\n            });\n          }\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            cmd = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I';\n            exec(cmd, function (error, stdout) {\n              const lines2 = stdout.toString().split('\\n');\n              if (lines.length > 10) {\n                const ssid = util.getValue(lines2, 'ssid', ':', true);\n                const bssid = util.getValue(lines2, 'bssid', ':', true);\n                const security = util.getValue(lines2, 'link auth', ':', true);\n                const txRate = util.getValue(lines2, 'lastTxRate', ':', true);\n                const channel = util.getValue(lines2, 'channel', ':', true).split(',')[0];\n                const type = '802.11';\n                const rssi = util.toInt(util.getValue(lines2, 'agrCtlRSSI', ':', true));\n                const noise = util.toInt(util.getValue(lines2, 'agrCtlNoise', ':', true));\n                const signalLevel = rssi - noise;\n                if (ssid || bssid) {\n                  result.push({\n                    id: 'Wi-Fi',\n                    iface,\n                    model,\n                    ssid,\n                    bssid,\n                    channel: util.toInt(channel),\n                    frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                    type,\n                    security,\n                    signalLevel,\n                    txRate\n                  });\n                }\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const ssid = util.getValue(lines, 'SSID', ':', true);\n              const bssid = util.getValue(lines, 'BSSID', ':', true);\n              const signalLevel = util.getValue(lines, 'Signal', ':', true);\n              const type = util.getValue(lines, 'Radio type', ':', true) || util.getValue(lines, 'Type de radio', ':', true) || util.getValue(lines, 'Funktyp', ':', true) || null;\n              const security = util.getValue(lines, 'authentication', ':', true) || util.getValue(lines, 'Authentification', ':', true) || util.getValue(lines, 'Authentifizierung', ':', true) || null;\n              const channel = util.getValue(lines, 'Channel', ':', true) || util.getValue(lines, 'Canal', ':', true) || util.getValue(lines, 'Kanal', ':', true) || null;\n              const txRate = util.getValue(lines, 'Transmit rate (mbps)', ':', true) || util.getValue(lines, 'Transmission (mbit/s)', ':', true) || util.getValue(lines, 'Empfangsrate (MBit/s)', ':', true) || null;\n              if (model && id && ssid && bssid) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  ssid,\n                  bssid,\n                  channel: util.toInt(channel),\n                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,\n                  type,\n                  security,\n                  signalLevel,\n                  txRate: util.toInt(txRate) || null\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiConnections = wifiConnections;\n\nfunction wifiInterfaces(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      const result = [];\n\n      if (_linux) {\n        const ifaces = ifaceListLinux();\n        ifaces.forEach(ifaceDetail => {\n          const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);\n          result.push({\n            id: ifaceDetail.id,\n            iface: ifaceDetail.iface,\n            model: nmiDetails.product ? nmiDetails.product : null,\n            vendor: nmiDetails.vendor ? nmiDetails.vendor : null,\n            mac: ifaceDetail.mac,\n          });\n        });\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      } else if (_darwin) {\n        let cmd = 'system_profiler SPNetworkDataType';\n        exec(cmd, function (error, stdout) {\n          const parts1 = stdout.toString().split('\\n\\n    Wi-Fi:\\n\\n');\n          if (parts1.length > 1) {\n            const lines = parts1[1].split('\\n\\n')[0].split('\\n');\n            const iface = util.getValue(lines, 'BSD Device Name', ':', true);\n            const mac = util.getValue(lines, 'MAC Address', ':', true);\n            const model = util.getValue(lines, 'hardware', ':', true);\n            result.push({\n              id: 'Wi-Fi',\n              iface,\n              model,\n              vendor: '',\n              mac\n            });\n          }\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else if (_windows) {\n        let cmd = 'netsh wlan show interfaces';\n        util.powerShell(cmd).then(function (stdout) {\n          const allLines = stdout.toString().split('\\r\\n');\n          for (let i = 0; i < allLines.length; i++) {\n            allLines[i] = allLines[i].trim();\n          }\n          const parts = allLines.join('\\r\\n').split(':\\r\\n\\r\\n');\n          parts.shift();\n          parts.forEach(part => {\n            const lines = part.split('\\r\\n');\n            if (lines.length >= 5) {\n              const iface = lines[0].indexOf(':') >= 0 ? lines[0].split(':')[1].trim() : '';\n              const model = lines[1].indexOf(':') >= 0 ? lines[1].split(':')[1].trim() : '';\n              const id = lines[2].indexOf(':') >= 0 ? lines[2].split(':')[1].trim() : '';\n              const macParts = lines[3].indexOf(':') >= 0 ? lines[3].split(':') : [];\n              macParts.shift();\n              const mac = macParts.join(':').trim();\n              const vendor = getVendor(model);\n              if (iface && model && id && mac) {\n                result.push({\n                  id,\n                  iface,\n                  model,\n                  vendor,\n                  mac,\n                });\n              }\n            }\n          });\n          if (callback) {\n            callback(result);\n          }\n          resolve(result);\n        });\n      } else {\n        if (callback) {\n          callback(result);\n        }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.wifiInterfaces = wifiInterfaces;\n","module.exports={\n  \"name\": \"systeminformation\",\n  \"version\": \"5.17.12\",\n  \"description\": \"Advanced, lightweight system and OS information library\",\n  \"license\": \"MIT\",\n  \"author\": \"Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)\",\n  \"homepage\": \"https://systeminformation.io\",\n  \"main\": \"./lib/index.js\",\n  \"bin\": {\n    \"systeminformation\": \"lib/cli.js\"\n  },\n  \"types\": \"./lib/index.d.ts\",\n  \"scripts\": {\n    \"test\": \"node ./test/test.js\"\n  },\n  \"files\": [\n    \"lib/\"\n  ],\n  \"keywords\": [\n    \"system information\",\n    \"sysinfo\",\n    \"monitor\",\n    \"monitoring\",\n    \"os\",\n    \"linux\",\n    \"osx\",\n    \"windows\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"cpu\",\n    \"cpuload\",\n    \"physical cores\",\n    \"logical cores\",\n    \"processor\",\n    \"cores\",\n    \"threads\",\n    \"socket type\",\n    \"memory\",\n    \"file system\",\n    \"fsstats\",\n    \"diskio\",\n    \"block devices\",\n    \"netstats\",\n    \"network\",\n    \"network interfaces\",\n    \"network connections\",\n    \"network stats\",\n    \"iface\",\n    \"printer\",\n    \"processes\",\n    \"users\",\n    \"internet\",\n    \"battery\",\n    \"docker\",\n    \"docker stats\",\n    \"docker processes\",\n    \"graphics\",\n    \"graphic card\",\n    \"graphic controller\",\n    \"gpu\",\n    \"display\",\n    \"smart\",\n    \"disk layout\",\n    \"usb\",\n    \"audio\",\n    \"bluetooth\",\n    \"wifi\",\n    \"wifinetworks\",\n    \"virtual box\",\n    \"virtualbox\",\n    \"vm\",\n    \"backend\",\n    \"hardware\",\n    \"BIOS\",\n    \"chassis\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/sebhildebrandt/systeminformation.git\"\n  },\n  \"funding\": {\n    \"type\": \"Buy me a coffee\",\n    \"url\": \"https://www.buymeacoffee.com/systeminfo\"\n  },\n  \"os\": [\n    \"darwin\",\n    \"linux\",\n    \"win32\",\n    \"freebsd\",\n    \"openbsd\",\n    \"netbsd\",\n    \"sunos\",\n    \"android\"\n  ],\n  \"engines\": {\n    \"node\": \">=8.0.0\"\n  }\n}\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBpbGVycy9jb21waWxlci5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMiLCJhcHAvY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcyIsImFwcC9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcyIsImFwcC9jb3JlL2NvcmUuanMiLCJhcHAvY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMiLCJhcHAvY29yZS9lcnJvcnMvY29tcGlsZUVycm9yLmpzIiwiYXBwL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcyIsImFwcC9jb3JlL2Vycm9ycy9lcnJvck1hbmFnZXIuanMiLCJhcHAvY29yZS9lcnJvcnMvc3dldmFFcnJvci5qcyIsImFwcC9jb3JlL2V4ZWN1dGlvbi9jb21wb3NhYmxlTG9hZGVyLmpzIiwiYXBwL2NvcmUvZXhlY3V0aW9uL2V4ZWN1dGlvbk1hbmFnZXIuanMiLCJhcHAvY29yZS9leGVjdXRpb24vc3VwcG9ydExpYnJhcnkuanMiLCJhcHAvY29yZS9uZXR3b3JrL2RhdGFQcm9jZXNzaW5nRGV2aWNlLmpzIiwiYXBwL2NvcmUvbmV0d29yay9wb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0LmpzIiwiYXBwL2NvcmUvb2ZmbG9hZGluZy9hdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzLmpzIiwiYXBwL2NvcmUvb2ZmbG9hZGluZy9vZmZsb2FkaW5nRGVjaXNpb24uanMiLCJhcHAvY29yZS9vZmZsb2FkaW5nL29mZmxvYWRpbmdUYXJnZXQuanMiLCJhcHAvY29yZS9ydW5uZXJzL2Fzc2VtYmx5U2NyaXB0UnVubmVyLmpzIiwiYXBwL2NvcmUvcnVubmVycy9ydW5uZXIuanMiLCJhcHAvY29yZS9zd2V2YVNjcmlwdC9zd2V2YVNjcmlwdC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9fcnVsZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9mb3JtYXRzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcnVsZXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3NjaGVtYV9vYmouanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbGxPZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2FueU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZGVwZW5kZW5jaWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2l0ZW1zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWF4SXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhMZW5ndGguanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tYXhQcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWF4aW11bS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21pbkl0ZW1zLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbWluUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL21pbmltdW0uanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9tdWx0aXBsZU9mLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbm90LmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvb25lT2YuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlZi5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvdW5pcXVlSXRlbXMuanMiLCJub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9hanYvbGliL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbiIsIm5vZGVfbW9kdWxlcy9hcy1iaW5kL2Rpc3QvYXMtYmluZC5janMuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtbXF0dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hdmFpbGFibGUtdHlwZWQtYXJyYXlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ibC9ibC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xvbmUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2QvYXV0by1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZHVwbGV4aWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VuZC1vZi1zdHJlYW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS8jL2NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvYXJyYXkvZnJvbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2FycmF5L2Zyb20vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9hcnJheS9mcm9tL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9mdW5jdGlvbi9pcy1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L2Z1bmN0aW9uL25vb3AuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9tYXRoL3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L251bWJlci9pcy1uYW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvaXMtbmFuL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL2lzLW5hbi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvbnVtYmVyL3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9udW1iZXIvdG8tcG9zLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvX2l0ZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2Fzc2lnbi9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9hc3NpZ24vc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9jb3B5LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvaXMtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qva2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9rZXlzL2lzLWltcGxlbWVudGVkLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L2tleXMvc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9tYXAuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvc3RyaW5nLyMvY29udGFpbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvIy9jb250YWlucy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9lczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZXM1LWV4dC9zdHJpbmcvaXMtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3IvZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9nZXQuanMiLCJub2RlX21vZHVsZXMvZXM2LWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci9pcy1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtaXRlcmF0b3Ivc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtbWFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1tYXAvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9pcy1uYXRpdmUtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9saWIvaXRlcmF0b3Ita2luZHMuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9saWIvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvZXM2LW1hcC9wb2x5ZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvaXMtaW1wbGVtZW50ZWQuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9pcy1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZXM2LXN5bWJvbC9saWIvcHJpdmF0ZS9nZW5lcmF0ZS1uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvbGliL3ByaXZhdGUvc2V0dXAvc3RhbmRhcmQtc3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL2xpYi9wcml2YXRlL3NldHVwL3N5bWJvbC1yZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9lczYtc3ltYm9sL3BvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL2VzNi1zeW1ib2wvdmFsaWRhdGUtc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9leHQvZ2xvYmFsLXRoaXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZXh0L2dsb2JhbC10aGlzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V4dC9nbG9iYWwtdGhpcy9pcy1pbXBsZW1lbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9mb3JlYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbi1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1nZW5lcmF0b3ItZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qcy10b2tlbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC9tcXR0LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L251bWJlcnMuanMiLCJub2RlX21vZHVsZXMvbXF0dC1wYWNrZXQvcGFja2V0LmpzIiwibm9kZV9tb2R1bGVzL21xdHQtcGFja2V0L3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0LXBhY2tldC93cml0ZVRvU3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2NsaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi9jb25uZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3QvdGNwLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3QvdGxzLmpzIiwibm9kZV9tb2R1bGVzL21xdHQvbGliL2Nvbm5lY3Qvd3MuanMiLCJub2RlX21vZHVsZXMvbXF0dC9saWIvY29ubmVjdC93eC5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi9zdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9tcXR0L2xpYi92YWxpZGF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvb3MtYnJvd3NlcmlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlaW50ZXJ2YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tc2hpZnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL2Z1bmN0aW9uL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3Jlc29sdmUtZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3NhZmUtdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvbGliL3RvLXNob3J0LXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL29iamVjdC9pcy5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3BsYWluLWZ1bmN0aW9uL2Vuc3VyZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3BsYWluLWZ1bmN0aW9uL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvcHJvdG90eXBlL2lzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGUvc3RyaW5nL2NvZXJjZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3ZhbHVlL2Vuc3VyZS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlL3ZhbHVlL2lzLmpzIiwibm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0LXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0LXN0cmVhbS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC1zdHJlYW0vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQtc3RyZWFtL3dzLWZhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9hdWRpby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvYmF0dGVyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvYmx1ZXRvb3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9jcHUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2RvY2tlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvZG9ja2VyU29ja2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9maWxlc3lzdGVtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9ncmFwaGljcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL2ludGVybmV0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9tZW1vcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL25ldHdvcmsuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL29zaW5mby5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvcHJpbnRlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvcHJvY2Vzc2VzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N5c3RlbWluZm9ybWF0aW9uL2xpYi9zeXN0ZW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3VzYi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zeXN0ZW1pbmZvcm1hdGlvbi9saWIvdXNlcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3ZpcnR1YWxib3guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vbGliL3dpZmkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc3lzdGVtaW5mb3JtYXRpb24vcGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBOzs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNubEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDem1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDamhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzU4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9rQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbnZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6b0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDendDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdHhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuLy92YXIge2FzYywgYXNzZW1ibHlzY3JpcHR9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Fzc2VtYmx5c2NyaXB0L2Rpc3Qvc2RrLmpzJyk7XG4vL3ZhciBBc0JpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXMtYmluZC9kaXN0L2FzLWJpbmQuY2pzLmpzJyk7XG4vL3ZhciBBc0JpbmRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXMtYmluZC9kaXN0L3RyYW5zZm9ybS5janMnKTtcbnZhciBSdW5uZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3J1bm5lcnMvcnVubmVyLmpzJyk7XG52YXIgQ29tcGlsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBpbGVycy9jb21waWxlci5qcycpO1xudmFyIEFzQmluZCA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcy1iaW5kL2Rpc3QvYXMtYmluZC5janMuanMnKTtcbnZhciBDb21wb3NhYmxlID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NhYmxlLmpzJyk7XG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xudmFyIENvbXBpbGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2NvbXBpbGVFcnJvci5qcycpO1xuY29uc3QgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZXJyb3JzL0V4ZWN1dGlvbkVycm9yLmpzXCIpO1xuY29uc3Qgb2ZmbG9hZGluZ0RlY2lzaW9uID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvb2ZmbG9hZGluZ0RlY2lzaW9uXCIpO1xuXG4vL3ZhciBBc3NlbWJseVNjcmlwdEdldHRlclRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vYXNzZW1ibHlTY3JpcHRHZXR0ZXJUcmFuc2Zvcm0uanMnKTtcblxuLyoqIGluY2x1ZGUgd2ViLXdvcmtlciBsaWJyYXJ5IGZvciBOb2RlanMgKiovXG5cbmlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIE5vZGUgd29ya2VyIG1vZHVsZVwiKTtcbiAgICB2YXIgV29ya2VyTm9kZUpTID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL25vZGUnKTtcbn1cblxuXG4vKipcbiAqIFRoZSBBc3NlbWJseVNjcmlwdENvbXBpbGVyIHN1cHBvcnRzIHN0cmljdCBUeXBlU2NyaXB0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb21waWxlclxuICpcbiAqL1xuZnVuY3Rpb24gQXNzZW1ibHlTY3JpcHRDb21waWxlcihzdXBwb3J0TGliKSB7XG4gICAgdGhpcy53b3JrZXIgPSBudWxsO1xuICAgIHRoaXMuaW50ZXJuYWxHZXR0ZXJQcmVmaXggPSBcIl9pbnRlcm5hbF9nZXRfXCI7XG4gICAgdGhpcy5zdXBwb3J0TGlicmFyeURlY2xhcmVzID0gdGhpcy5nZW5lcmF0ZVN1cHBvcnRMaWJyYXJ5RGVjbGFyZXMoc3VwcG9ydExpYik7XG4gICAgdGhpcy5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb24gPSBcIlRoZSBsaWIgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBmdW5jdGlvbiBmcm9tIHRoZSBzdXBwb3J0IGxpYnJhcnkuXFxuXCIgK1xuICAgICAgICBcInN5bmNocm9ub3VzIGZ1bmN0aW9ucyByZXR1cm4gdGhlaXIgcmVzdWx0IGltbWVkaWF0ZWx5LCB3aGlsZSB0aGUgY2FsbGJhY2sgZm9yIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIGFsbCBjdXJyZW50bHkgcnVubmluZyBBc3NlbWJseVNjcmlwdCBjb2RlIGlzIGZpbmlzaGVkLlxcblwiICtcbiAgICAgICAgXCJDYWxsYmFjayBmdW5jdGlvbnMgY2FuIGhhdmUgbGVzcyBwYXJhbWV0ZXJzIHRoYW4gdGhlIGxpc3RlZCBwYXJhbWV0ZXJzLCBpbiB3aGljaCBjYXNlIG9ubHkgdGhlIGZpcnN0IHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cXG5cIiArXG4gICAgICAgIFwiRnVuY3Rpb25zOlxcblwiO1xuICAgIHRoaXMucmVzb2x2ZUNvbXBpbGUgPSBudWxsO1xufVxuXG4vL2luaGVyaXQgcHJvcGVydGllc1xuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBpbGVyLnByb3RvdHlwZSk7XG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VtYmx5U2NyaXB0Q29tcGlsZXI7XG5cbi8qKlxuICogZ2VuZXJhdGVzIGRlY2xhcmUgc3RhdGVtZW50cyBuZWNlc3NhcnksIHRvIGFjY2VzcyBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBmcm9tIEFzc2VtYmx5U2NyaXB0XG4gKiBhZGRpdGlvbmFsbHkgdGhlIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkXG4gKiBAcGFyYW0gc3VwcG9ydExpYlxuICovXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5nZW5lcmF0ZVN1cHBvcnRMaWJyYXJ5RGVjbGFyZXMgPSBmdW5jdGlvbiAoc3VwcG9ydExpYikge1xuICAgIGxldCBkb2NzID0gXCJcIjtcbiAgICBsZXQgZGVjbGFyZXMgPSBcIm5hbWVzcGFjZSBsaWIge1xcblwiO1xuICAgIGZvcihsZXQgZnVuY05hbWUgaW4gc3VwcG9ydExpYi5mdW5jdGlvbnMpIHtcbiAgICAgICAgbGV0IHJldHVyblNpZyA9IHN1cHBvcnRMaWIuZnVuY3Rpb25zW2Z1bmNOYW1lXS5sYW5ndWFnZVNwZWNpZmljLnR5cGVzY3JpcHQucmV0dXJuU2lnIHx8IFwidm9pZFwiO1xuICAgICAgICBsZXQgcGFyYW1TaWcgPSBzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0ubGFuZ3VhZ2VTcGVjaWZpYy50eXBlc2NyaXB0LnBhcmFtZXRlclNpZztcbiAgICAgICAgLy9jYWxsYmFjayBmdW5jdGlvbiBuYW1lIGlzIGZpcnN0IHBhcmFtZXRlciBmb3IgYXN5bmNocm9ub3VzIGZ1bmN0aW9uc1xuICAgICAgICBpZihzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0uYXN5bmMpIHtcbiAgICAgICAgICAgIHBhcmFtU2lnID0gXCJjYWxsYmFjazogc3RyaW5nIHwgbnVsbFwiICsgKHR5cGVvZiBwYXJhbVNpZyAhPT0gdW5kZWZpbmVkID8gXCIsIFwiK3BhcmFtU2lnIDogXCJcIik7XG4gICAgICAgICAgICByZXR1cm5TaWcgPSBcInZvaWRcIjtcbiAgICAgICAgfVxuICAgICAgICBkb2NzICs9IGZ1bmNOYW1lK1wiOlxcblwiK1xuICAgICAgICAgICAgXCIgIERlc2NyaXB0aW9uOiBcIitzdXBwb3J0TGliLmZ1bmN0aW9uc1tmdW5jTmFtZV0uZGVzY3JpcHRpb24rXCJcXG5cIitcbiAgICAgICAgICAgIFwiICBQYXJhbWV0ZXJzOiBcXFwiXCIrcGFyYW1TaWcrXCJcXFwiXFxuXCIrXG4gICAgICAgICAgICBcIiAgXCIrKHN1cHBvcnRMaWIuZnVuY3Rpb25zW2Z1bmNOYW1lXS5hc3luYz9cbiAgICAgICAgICAgICAgICBcIkFzeW5jIGZ1bmN0aW9uOiBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSBcXFwiXCIrc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdLmxhbmd1YWdlU3BlY2lmaWMudHlwZXNjcmlwdC5yZXR1cm5TaWcrXCJcXFwiIHJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgXCJTeW5jIGZ1bmN0aW9uOiByZXR1cm5zIFxcXCJcIityZXR1cm5TaWcrXCJcXFwiXCIpK1xuICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgZGVjbGFyZXMgKz0gXCJleHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBwYXJhbVNpZyArIFwiKTpcIiArIHJldHVyblNpZyArIFwiO1xcblwiO1xuICAgIH1cbiAgICBkZWNsYXJlcyArPSBcIn1cIjtcbiAgICB0aGlzLnN1cHBvcnRMaWJyYXJ5RG9jdW1lbnRhdGlvbiA9IGRvY3M7XG4gICAgY29uc29sZS5sb2coXCJTdXBwb3J0IGZ1bmN0aW9uczpcIik7XG4gICAgY29uc29sZS5sb2codGhpcy5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb24pO1xuICAgIGNvbnNvbGUubG9nKGRlY2xhcmVzKVxuICAgIHJldHVybiBkZWNsYXJlcztcbn1cblxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuc2V0dXAgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIXRoaXMuc2V0dXBDb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgQXNzZW1ibHlTY3JpcHQgY29tcGlsZXJcIik7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdFdvcmtlcigpO1xuXG4gICAgICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtc2cgdG8gd29ya2VyJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXR1cENvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldHVwIGNvbXBsZXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29tcGlsZUVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb21waWxlUmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxmLnJlc29sdmVDb21waWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc29sdmVDb21waWxlKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUuaW5pdFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHR5cGVvZiB0aGlzLndvcmtlciAhPSAndW5kZWZpbmVkJyAmJiB0aGlzLndvcmtlciAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIC8vZGlmZmVyZW50IHBhdGggZm9yIE5vZGVKU1xuICAgIGlmKHN3ZXZhLmluQnJvd3Nlcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWQgd29ya2VyIGZvciB3ZWJicm93c2VyXCIpO1xuICAgICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoJy9ub2RlX21vZHVsZXMvc3dldmEtY29yZS9hcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlcldvcmtlci5qcycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZCB3b3JrZXIgZm9yIE5vZGVKU1wiKTtcbiAgICAgICAgdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyTm9kZUpTKCdhcHAvY29yZS9jb21waWxlcnMvYXNzZW1ibHlTY3JpcHRDb21waWxlcldvcmtlci5qcycpO1xuICAgIH1cbn1cbi8vIE1BXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gYXN5bmMgZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgd2hpbGUgKHRoaXMuY3VycmVudGx5Q29tcGlsaW5nKSB7XG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmVXYWl0ID0+IHNldFRpbWVvdXQocmVzb2x2ZVdhaXQsIDEpKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50bHlDb21waWxpbmcgPSB0cnVlO1xuXG4gICAgLy9sb2FkIGNvbXBpbGVyXG4gICAgYXdhaXQgdGhpcy5zZXR1cCgpO1xuXG4gICAgbGV0IGRvbmVDb21waWxpbmcgPSBmYWxzZTtcbiAgICBsZXQgb2ZmbG9hZGluZyA9IGZhbHNlO1xuICAgIGxldCBpbnRlcnZhbElEO1xuICAgIGxldCBvZExpc3QgPXN3ZXZhLkV4ZWN1dGlvbk1hbmFnZXIuZ2V0T0RMaXN0KCk7IC8vdG9kbzogdXNlciBpbnB1dFxuICAgIGNvbnNvbGUubG9nKFwib2RMaXN0IGluIEFTQyBjb21waWxlciA9IFwiLG9kTGlzdCk7XG5cbiAgICBsZXQgZW5kQ1BVID0gMDtcbiAgICBsZXQgY3B1TW9uaXRvcj0wO1xuICAgIC8vIGluaXRpYWwgbWVtIC8gYmF0dGVyeSBjaGVja1xuICAgIG9mZmxvYWRpbmcgPSBhd2FpdCBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KTtcbiAgICBjb25zb2xlLmxvZygnaW5pdGlhbCBvZmZsb2FkaW5nIGRlY2lzaW9uID0gJyxvZmZsb2FkaW5nKTtcbiAgICBpZiAob2ZmbG9hZGluZykge1xuICAgICAgICAvLyBvcHRpbWl6YXRpb246IHNwZWVkIGlzIGtleSB3ZSBkbyB0aGlzIGFmdGVyIHJlc29sdmluZyBwcm9taXNlXG4gICAgICAgIC8vY2xlYXJJbnRlcnZhbChpbnRlcnZhbElEKTtcbiAgICAgICAgLy9hYm9ydCBydW5uaW5nIGNvbXBpbGF0aW9uXG4gICAgICAgIHJldHVybiAoJ29mZmxvYWRpbmcnKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0Q1BVID1wZXJmb3JtYW5jZS5ub3coKTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgLy9tb25pdG9yaW5nIHRoZSBjb21waWxhdGlvbiBwcm9jZXNzXG4gICAgICAgIG5ldyBQcm9taXNlKCBhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZ2luIHBlcmlvZGljIG1vbml0b3JpbmcgZXhlY3V0aW9uLi4uJyk7XG4gICAgICAgICAgICAvLyBpbnRlcnZhbCBjaGVja1xuICAgICAgICAgICAgaW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbmRDUFUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBjcHVNb25pdG9yID0gKChlbmRDUFUgLSBzdGFydENQVSkvNTAwMCkqMTAwO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0NQVSBUSU1FPSAnLCBjcHVNb25pdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoY3B1TW9uaXRvciA+IG9kTGlzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9mZmxvYWRpbmdPdXRwdXQkIE1vbml0b3JpbmcgPSBDUFUgbGltaXQgZXhjZWVkZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29mZmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmbG9hZGluZyA9IGF3YWl0IG9mZmxvYWRpbmdEZWNpc2lvbihvZExpc3QpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwZXJpb2RpYyBvZmZsb2FkaW5nIGRlY2lzaW9uID0gJywgb2ZmbG9hZGluZyk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uOiBzcGVlZCBpcyBrZXkgd2UgZG8gdGhpcyBhZnRlciByZXNvbHZpbmcgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvL2NsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJRCk7XG4gICAgICAgICAgICAgICAgICAgIC8vYWJvcnQgcnVubmluZyBjb21waWxhdGlvblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdvZmZsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSksXG5cbiAgICAgICAgLy8gY29tcGlsaW5nIHRoZSBtb2R1bGVcbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29tcGlsZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBkb25lQ29tcGlsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOiBcImNvbXBpbGVcIiwgc291cmNlOiBzZWxmLnByZXBhcmVTb3VyY2VDb2RlKG1vZHVsZS5zb3VyY2UpfSk7XG5cbiAgICAgICAgfSlcblxuICAgIF0pLlxuICAgIHRoZW4oKHdyKSA9PiB7XG5cbiAgICAgICAgbGV0IHdvcmtlclJlc3VsdCA9IHdyO1xuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJRCk7IC8vY2xlYXIgbW9uaXRvcmluZyBpbnRlcnZhbCBpZiBubyBvZmZsb2FkaW5nIG5lY2Vzc2FyeVxuICAgICAgICBjb25zb2xlLmxvZygnd29ya2VyUmVzdWx0Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHdvcmtlclJlc3VsdCk7XG4gICAgICAgIHRoaXMuY3VycmVudGx5Q29tcGlsaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlQ29tcGlsZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHdvcmtlclJlc3VsdC50eXBlID09PSBcImNvbXBpbGVSZXN1bHRcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIE9mZmxvYWRpbmcgbm90IG5lZWRlZC4gUHJvY2VlZCBhcyBub3JtYWwnKTtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJSZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAod29ya2VyUmVzdWx0ID09PSAnb2ZmbG9hZGluZycpIHtcbiAgICAgICAgICAgIC8vdG9kbzogb2ZmbG9hZGluZyBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5pbml0V29ya2VyKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9mZmxvYWRpbmdPdXRwdXQkIE9mZmxvYWRpbmcgbmVjZXNzYXJ5LiBDYWxsYmFjayB0cmlnZ2VyZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gJ29mZmxvYWRpbmcnOyAvL3RvZG86IGlzIFN0cmluZyBhIGdvb2QgRFQgZm9yIHJldHVybiA/XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVFcnJvcih3b3JrZXJSZXN1bHQubWVzc2FnZSwgbW9kdWxlLmNvbnRleHQpOyAgLy8gQ29tcGlsZXIgRXJyb3IgaGFuZGxpbmdcblxuICAgIH0pO1xuXG59XG5cblxuQXNzZW1ibHlTY3JpcHRDb21waWxlci5wcm90b3R5cGUucHJlcGFyZVNvdXJjZUNvZGUgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBsZXQgZ2V0dGVycyA9IHRoaXMuZ2VuZXJhdGVHbG9iYWxHZXR0ZXJzKHNvdXJjZSk7XG4gICAgbGV0IHNvdXJjZVN0ciA9IHNvdXJjZS5qb2luKFwiXFxuXCIpO1xuICAgIHJldHVybiB0aGlzLnN1cHBvcnRMaWJyYXJ5RGVjbGFyZXMgKyBzb3VyY2VTdHIgKyBnZXR0ZXJzO1xufVxuXG5Bc3NlbWJseVNjcmlwdENvbXBpbGVyLnByb3RvdHlwZS5nZW5lcmF0ZUdsb2JhbEdldHRlcnMgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBsZXQgZ2V0dGVycyA9IFwiXCI7XG4gICAgZm9yKGxldCBsaW5lIGluIHNvdXJjZSkge1xuICAgICAgICBpZihzb3VyY2UuaW5jbHVkZXModGhpcy5pbnRlcm5hbEdldHRlclByZWZpeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlRXJyb3IoXCJEbyBub3QgdXNlIFwiK3RoaXMuaW50ZXJuYWxHZXR0ZXJQcmVmaXgrXCIgZm9yIG5hbWVzIGluIHlvdXIgc291cmNlLCBhcyBpdCBpcyByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNlLlwiLCBcImNvbXBpbGVFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHNvdXJjZVtsaW5lXS5pbmRleE9mKFwiZXhwb3J0IHZhclwiKSA9PT0gMCkge1xuICAgICAgICAgICAgbGV0IHRtcCA9IHNvdXJjZVtsaW5lXS5zcGxpdCgnPScpWzBdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IFwiYW55cmVmXCI7XG4gICAgICAgICAgICBpZih0bXAubGVuZ3RoID49IDIpXG4gICAgICAgICAgICAgICAgdHlwZSA9IHRtcFsxXS5zcGxpdCgvW1xccz1dKy8pLmZpbHRlcih4ID0+IHggIT09IFwiXCIpWzBdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlRXJyb3IoXCJFeHBvcnRlZCB2YXJpYWJsZXMgcmVxdWlyZSBhbiBleHBsaWNpdCB0eXBlISBcXG5cXFwiXCIrc291cmNlW2xpbmVdK1wiXFxcIiBkb2VzIG5vdCBjb250YWluIGEgdHlwZS5cIiwgXCJjb21waWxlRXJyb3JcIik7XG4gICAgICAgICAgICB0bXAgPSB0bXBbMF0uc3BsaXQoL1tcXHM9XSsvKS5maWx0ZXIoeCA9PiB4ICE9PSBcIlwiKTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gdG1wW3RtcC5sZW5ndGgtMV07XG4gICAgICAgICAgICBnZXR0ZXJzICs9IFwiZXhwb3J0IGZ1bmN0aW9uIFwiK3RoaXMuaW50ZXJuYWxHZXR0ZXJQcmVmaXgrbmFtZStcIigpOlwiK3R5cGUrXCIgeyByZXR1cm4gXCIrbmFtZStcIjsgfVxcblwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlcnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZW1ibHlTY3JpcHRDb21waWxlcjsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIGNvbXBpbGVyIGxvYWRzIHRoZSBuZWNlc3NhcnkgcmVzb3VyY2VzIGZvciBjb21waWxhdGlvbiBvZiBhIGxhbmd1YWdlLCBjb21waWxlcyBjb2RlIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgYmluYXJ5LlxuICogSXQgaGFzIHR3byBwaGFzZXM6IEEgc2V0dXAgcGhhc2UsIHdlcmUgYWxsIGRlcGVuZGVuY2llcyBhcmUgbG9hZGVkIGFuZCBpbml0aWFsaXplZCBhbmQgYW4gb3BlcmF0aW9uYWwgcGhhc2UsIHdoaWNoIGlzIHVzZWQgdG8gY29tcGlsZSBjb2RlXG4gKiBcbiAqIFRoZSBzZXR1cCBuZWVkcyB0byBiZSBkb25lIG9ubHkgb25jZSwgd2hpbGUgdGhlIGV4ZWN1dGlvbiBjYW4gYmUgcmVwZWF0ZWQgb24gZGlmZmVyZW50IGRhdGEuXG4gKiBBZGRpdGlvbmFsbHkgdGhlIHNldHVwIHNob3VsZCBvbmx5IGJlIGNhbGxlZCwgd2hlbiB0aGUgY29tcGlsZXIgaXMgbmVlZGVkLCBiZWNhdXNlIHNvbWUgZGVwZW5kZW5jaWVzIGZvciBjb21waWxpbmcgY2FuIGJlIHZlcnkgbGFyZ2VcbiAqIFxuICogVGhpcyBpcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHJldHVybmluZyB0aGUgaW5wdXQgc291cmNlIGFzIHRoZSBjb21waWxlZCBjb2RlLiBJdCBjYW4gYmUgdXNlZCBmb3IgaW50ZXJwcmV0ZWQgbGFuZ3VhZ2VzLlxuICpcbiAqIEBwYXJhbSB7U3VwcG9ydExpYnJhcnl9IHN1cHBvcnRMaWJyYXJ5IC0gc291cmNlIGNvZGUgdG8gY29tcGlsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbXBpbGVyKHN1cHBvcnRMaWJyYXJ5KSB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcywgaWYgZGVwZW5kZW5jaWVzIGFyZSBsb2FkZWQuXG4gICAgICogQG5hbWUgQ29tcGlsZXIjc2V0dXBDb21wbGV0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNldHVwQ29tcGxldGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBEb2N1bWVudGF0aW9uIGZvciBmdW5jdGlvbnMgaW4gc3VwcG9ydCBsaWJyYXJ5IC0gc2hvdWxkIGluY2x1ZGUgc3BlY2lmaWNzIG9uIGxhbmd1YWdlIHN5bnRheFxuICAgICAqIEF2YWlsYWJsZSBhZnRlciBDb21waWxlciNzZXR1cCgpIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKiBAbmFtZSBDb21waWxlciNzZXR1cENvbXBsZXRlZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb24gPSBcIlwiO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIHByb3ZpZGVkIHNvdXJjZSBjb2RlXG4gKiBAcGFyYW0ge21vZHVsZX0gc291cmNlIC0gc291cmNlIGNvZGUgdG8gY29tcGlsZVxuICogQHJldHVybiB7b2JqZWN0fSBjb250YWluaW5nIGJpbmFyeURhdGEgYW5kIG9wdGlvbmFsbHkgb3RoZXIgcHJvcGVydGllcyBvZiBzcGVjaWZpYyBjb21waWxlcnNcbiAqL1xuQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbiAgIFxuLyoqXG4gKiBMb2FkcyBkZXBlbmRlbmNpZXNcbiAqL1xuQ29tcGlsZXIucHJvdG90eXBlLnNldHVwID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIGlmKCF0aGlzLnNldHVwQ29tcGxldGVkKSB7XG4gICAgICAgIHRoaXMuc2V0dXBDb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBpbGVyIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvZGVmaW5pdGlvbkVycm9yLmpzJyk7XG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xudmFyIENsb25lID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nsb25lL2Nsb25lLmpzJyk7XG5cbi8qKlxuICogQ29tcG9zYWJsZXMgcHJvY2VzcyBkYXRhLiBUaGV5IGNhbiBiZSBsaW5rZWQgaW50byBuZXR3b3Jrcy5cbiAqIEBhYnN0cmFjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2FibGUoKSB7XG59XG4vKipcbiAqIEEgZGVmaW5pdGlvbiBvZiBhIEpTT04gb2JqZWN0LlxuICogQHNlZSB7QGxpbmsgaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kb2N1bWVudGF0aW9uLmh0bWx9XG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBKU09OU2NoZW1hXG4gKi9cblxuLyoqXG4gKiBUaGUgaW5pdGFsaXphdGlvbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgY29tcG9zYWJsZXMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBjb21wb3NhYmxlSW5pdGFsaXplclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lPXNvbWVDb21wb3NhYmxlXSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlPW1vZHVsZV0gLSBUaGUgdHlwZSBvZiB0aGUgY29tcG9zYWJsZTogJ21vZHVsZScgb3IgJ2NvbXBvc2l0aW9uJy5cbiAqIEBwcm9wZXJ0eSB7SlNPTlNjaGVtYX0gW2RhdGFJblNjaGVtYT1udWxsXSAtIFRoZSBzY2hlbWEgb2YgdGhlIGV4cGVjdGVkIGRhdGEgb2JqZWN0IHJlY2VpdmVkIGZyb20gb3RoZXIgY29tcG9zYWJsZXMuXG4gKiBAcHJvcGVydHkge0pTT05TY2hlbWF9IFtkYXRhT3V0U2NoZW1hPW51bGxdIC0gVGhlIHNjaGVtYSBvZiB0aGUgZGF0YSBvYmplY3QgcGFzc2VkIG9uIHRvIGxhdGVyIGNvbXBvc2FibGVzLlxuICogQHByb3BlcnR5IHtKU09OU2NoZW1hfSBbaW5wdXRTY2hlbWE9bnVsbF0gLSBUaGUgc2NoZW1hIG9mIHRoZSBpbnB1dCBvYmplY3QgcmVjZWl2ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBleGVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFtkYXRhSW5OYW1lcz1bJ2RhdGEnXV0gLSBUaGUgbmFtZXMgb2YgdGhlIGV4cGVjdGVkIHByb3BlcnRpZXMgb2YgdGhlIHJlY2VpdmVkIGRhdGEgb2JqZWN0LlxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgZWxlbWVudCwgdGhlIGFycmF5IGlzIGlnbm9yZWQgYW5kIHRoZSB3aG9sZSBkYXRhIG9iamVjdCBpcyB0YWtlbiAobm8gcHJvcGVydHkgbmFtZXMgbmVlZGVkKS5cbiAqIE11bHRpcGxlIHByb3BlcnRpZXMgYXJlIG5lZWRlZCwgaWYgeW91IHdhbnQgdG8gcmVjZWl2ZSBkYXRhIGZyb20gbXVsdGlwbGUgb3RoZXIgY29tcG9zYWJsZXMuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW2RhdGFPdXROYW1lcz1bJ3Jlc3VsdCddXSAtIFRoZSBuYW1lcyBvZiB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcyBvZiB0aGUgcHJvZHVjZWQgZGF0YSBvYmplY3QuXG4gKiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBlbGVtZW50LCB0aGUgYXJyYXkgaXMgaWdub3JlZCBhbmQgdGhlIHdob2xlIGRhdGEgb2JqZWN0IGlzIHRha2VuIChubyBwcm9wZXJ0eSBuYW1lcyBuZWVkZWQpLlxuICogTXVsdGlwbGUgcHJvcGVydGllcyBhcmUgbmVlZGVkLCBpZiB5b3Ugd2FudCB0byBzZW5kIGRhdGEgdG8gbXVsdGlwbGUgb3RoZXIgY29tcG9zYWJsZXMuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW2lucHV0TmFtZXM9W11dIC0gVGhlIG5hbWVzIG9mIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzIG9mIHRoZSBpbnB1dCBvYmplY3QuXG4gKiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBlbGVtZW50LCB0aGUgYXJyYXkgaXMgaWdub3JlZCBhbmQgdGhlIHdob2xlIGlucHV0IG9iamVjdCBpcyB0YWtlbiAobm8gcHJvcGVydHkgbmFtZXMgbmVlZGVkKS5cbiAqL1xuXG4vKiogSW5pdGlhbGl6ZXMgdGhlIG9iamVjdCB3aXRoIGEgcHJvcGVydHkgb2JqZWN0LlxuICAqIE5vdCBkZWZpbmVkIFByb3BlcnRpZXMgd2lsbCBnZXQgYSBkZWZhdWx0IHZhbHVlLlxuICogIEBwcm90ZWN0ZWRcbiAqICBAcGFyYW0ge2NvbXBvc2FibGVJbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zYWJsZS5cbiAqL1xuQ29tcG9zYWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChpbml0aWFsaXphdGlvbk9iamVjdCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnbmFtZScsICdzb21lQ29tcG9zYWJsZScpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAndHlwZScsICdtb2R1bGUnKTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2RhdGFJblNjaGVtYScsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnZGF0YU91dFNjaGVtYScsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnaW5wdXRTY2hlbWEnLCBudWxsKTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnZGF0YUluTmFtZXMnLCBbXSk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdkYXRhT3V0TmFtZXMnLCBbXSk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdpbnB1dE5hbWVzJywgW10pO1xuXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIGV4cGVjdGVkIHByb3BlcnRpZXMgZm9yIHRoZSByZWNlaXZlZCBkYXRhIG9iamVjdC5cbiAgICAgKiBAbmFtZSBDb21wb3NhYmxlI2RhdGFJblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYXRhSW4gPSB0aGlzLmRhdGFJbk5hbWVzLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICogQW1vdW50IG9mIGV4cGVjdGVkIHByb3BlcnRpZXMgZm9yIHRoZSBwcm9kdWNlZCBkYXRhIG9iamVjdC5cbiAgICAqIEBuYW1lIENvbXBvc2FibGUjZGF0YU91dFxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMuZGF0YU91dCA9IHRoaXMuZGF0YU91dE5hbWVzLmxlbmd0aDtcblxuICAgIC8qKlxuICAgICogQW1vdW50IG9mIGV4cGVjdGVkIHByb3BlcnRpZXMgZm9yIHRoZSByZWNlaXZlZCBpbnB1dCBvYmplY3RcbiAgICAqIEBuYW1lIENvbXBvc2FibGUjaW5wdXRJblxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMuaW5wdXRJbiA9IHRoaXMuaW5wdXROYW1lcy5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAqIFRoZSBjb250ZXh0IG9mIHRoZSBjb21wb3NhYmxlIHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAgICogQG5hbWUgQ29tcG9zYWJsZSNjb250ZXh0XG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJ1snICsgdGhpcy5uYW1lICsgJ10nO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBpbml0aWFsaXplIGludGVybmFsIHZhcmlhYmxlcy4gU2V0cyBhbHNvIGRlZmF1bHQgdmFsdWVzLlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtjb21wb3NhYmxlSW5pdGFsaXplcn0gaW5pdGlhbGl6YXRpb25PYmplY3QgLSBUaGUgb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGNvbXBvc2FibGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdmFsdWUgdG8gc2V0LiBUaGUgbmFtZSBtdXN0IGJlIHRoZSBzYW1lIGJvdGggZm9yICd0aGlzJyBhbmQgaW5pdGlhbGl6YXRpb25PYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdFZhbHVlIC0gQSBkZWZhdWx0IHZhbHVlIGlzIHNldCwgaWYgaW5pdGlhbGl6YXRpb25PYmplY3QgZG9lcyBub3QgY29udGFpbiBzdWNoIGEgcHJvcGVydHkga2V5LlxuICovXG5Db21wb3NhYmxlLnByb3RvdHlwZS5pbml0aWFsaXplUHJvcGVydHkgPSBmdW5jdGlvbiAoaW5pdGlhbGl6YXRpb25PYmplY3QsXG4gICAgcHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChpbml0aWFsaXphdGlvbk9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdmFyIG9iaiA9IGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgaW50ZXJuYWwgZnVuY3Rpb25zLiBTZXRzIGFsc28gZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge2NvbXBvc2FibGVJbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB2YWx1ZSB0byBzZXQuIFRoZSBuYW1lIG11c3QgYmUgdGhlIHNhbWUgYm90aCBmb3IgJ3RoaXMnIGFuZCBpbml0aWFsaXphdGlvbk9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZEFyZ3VtZW50c0NvdW50IC0gVGhlIGFtb3VudCBvZiBhcmd1bWVudHMgdGhlIGV4cGVjdGVkIGZ1bmN0aW9uIG5lZWRzIHRvIGhhdmUuIE9uIG1pc21hdGNoIGFuIGVycm9yIGlzIHRocm93bi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlZmF1bHRWYWx1ZSAtIEEgZGVmYXVsdCB2YWx1ZSBpcyBzZXQsIGlmIGluaXRpYWxpemF0aW9uT2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gc3VjaCBhIHByb3BlcnR5IGtleS5cbiAqL1xuQ29tcG9zYWJsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGluaXRpYWxpemF0aW9uT2JqZWN0LFxuICAgIHByb3BlcnR5LCBleHBlY3RlZEFyZ3VtZW50c0NvdW50LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoaW5pdGlhbGl6YXRpb25PYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIC8vY2hlY2sgaWYgaXQgaXMgcmVhbGx5IGEgZnVuY3Rpb25cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vdGhlIGV4cGVjdGVkIGZ1bmN0aW9ucyAod2hpY2ggY2FuIGJlIGRlZmluZWQgYnkgdGhlIGNvbXBvc2FibGUgY3JlYXRvcnMpIGhhdmUgYSBmaXhlZCBzaWduYXR1cmUgKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAvL3NvIGNoZWNrIGhlcmUgZm9yIHZhbGlkYXRpb24uXG4gICAgICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25PYmplY3RbcHJvcGVydHldLmxlbmd0aCA+PSBleHBlY3RlZEFyZ3VtZW50c0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ2Z1bmN0aW9uIFwiJyArIHByb3BlcnR5ICsgJ1wiIHJlcXVpcmVzIGF0IGxlYXN0ICcgK1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEFyZ3VtZW50c0NvdW50ICsgJyBhcmd1bWVudHMsIGJ1dCBwcm92aWRlcyBvbmx5ICcgK1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQsIGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluaXRpYWxpemF0aW9uT2JqZWN0W3Byb3BlcnR5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBmb3Igbm93IGlnbm9yZSwgYXMgc29tZSBmdW5jdGlvbnMgYXJlIG9wdGlvbmFsXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignXCInICsgcHJvcGVydHkgKyAnXCIgaXMgcmVzZXJ2ZWQgZm9yIGZ1bmN0aW9ucywgYnV0IG5vdCBkZWZpbmVkIGFzIG9uZScsXG4gICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBpbml0aWFsaXphdGlvbk9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBDbG9uZXMgdGhlIGN1cnJlbnQgY29tcG9zYWJsZSBhbmQgb3ZlcndyaXRlcy9hZGRzIGFsbCB0aGUgcHJvcGVydGllcyBzcGVjaWZpZWQgaW4gYW4gZXh0ZW5kZXIgb2JqZWN0LlxuICogVGhpcyBhbGxvd3Mgc29tZSBzb3J0IG9mIGNvbXBvc2FibGUgaW5oZXJpdGFuY2UuXG4gKiBAdGhpcyBDb21wb3NhYmxlXG4gKiBAcGFyYW0ge0NvbXBvc2FibGV9IGV4dGVuZGVyIC0gVGhlIHBhcnRpYWwgY29tcG9zYWJsZSBmcm9tIHdoaWNoIHRvIHRha2UgdGhlIG5ldyB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Q29tcG9zYWJsZX0gVGhlIGNsb25lZCBhbmQgZXh0ZW5kZWQgY29tcG9zYWJsZSBvYmplY3QuXG4gKi9cbkNvbXBvc2FibGUucHJvdG90eXBlLmV4dGVuZFdpdGggPSBmdW5jdGlvbiAoZXh0ZW5kZXIpIHtcbiAgICB2YXIgY2xvbmVkID0gQ2xvbmUodGhpcyk7XG4gICAgZm9yICh2YXIga2V5IGluIGV4dGVuZGVyKSB7XG4gICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBjbG9uZSAnZXh0ZW5kcycgYXMgaXQgaXMgYW4gaW5kaWNhdG9yLCB0aGF0IGEgY29tcG9zYWJsZSB3YW50cyB0byBleHRlbmQgYW5vdGhlci4gSS5lLiBXaGF0IHdlIGFyZSBkb2luZyBoZXJlIDopXG4gICAgICAgIGlmIChleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPSAnZXh0ZW5kcycpIHtcbiAgICAgICAgICAgIGNsb25lZFtrZXldID0gZXh0ZW5kZXJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBjb250ZXh0IGR1cmluZyB0aGUgZXhlY3V0aW9uLiBJdCB1c2VzIHRoZSBwYXJlbnQncyBjb250ZXh0IGFuZCB0aGUgYWxpYXMsIHRoZSBwYXJlbnQgaGFzIGdpdmVuIHRoaXMgY29tcG9zYWJsZS5cbiAqIGxvb2tzIGxpa2U6IENvbXBvc2l0aW9uW2NvbXBvc2l0aW9uMV0uTW9kdWxlW21vZHVsZTFdXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSBwYXJlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgLSBUaGUgYWxpYXMgKG5hbWUpIHVzZWQgaW4gdGhlIHBhcmVudCBmb3IgdGhpcyBjb21wb3NhYmxlLlxuICogQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBjb250ZXh0LlxuICovXG5Db21wb3NhYmxlLnByb3RvdHlwZS5nZXROZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvL2FsaWFzIGlzIG9wdGlvbmFsLCBzbyBjaGVjayBpZiBpdCBpcyBkZWZpbmVkXG4gICAgICAgIGlmICh0eXBlb2YgYWxpYXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhbGlhcyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxpYXMgPSAnOiAnICsgYWxpYXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQgKyAnLicgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnWycgKyB0aGlzLm5hbWUgKyBhbGlhcyArICddJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbn1cbi8qKlxuICogVmFsaWRhdGVzLCBpZiBhIGdpdmVuIG9iamVjdCBoYXMgdGhlIGV4cGVjdGVkIHN0cnVjdHVyZSAodHlwZWNoZWNrKSBjb21wYXRpYmxlIHRvIHRoaXMgY29tcG9zYWJsZS5cbiAqIElmIGF2YWlsYWJsZSwgaXQgdXNlcyB0aGUgcHJvdmlkZWQgSlNPTiBzY2hlbWEsIG90aGVyd2lzZSAobm9jaCBzY2htZW1hIGF2YWlsYWJsZSkgaXQgb25seSBjaGVja3MsIGlmIHRoZSBvYmplY3QgaGFzIGFsbCByZXF1aXJlZCBwcm9wZXJ0eSBrZXlzLiBEZWZpbmVkIGJ5IHRoZSAqTmFtZXMgYXJyYXlzIChzZWUge0BsaW5rIGNvbXBvc2FibGVJbml0YWxpemVyfSkuXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBvYmplY3QsIG5lZWRlZCB0byBzZWxlY3QgdGhlIGNvcnJlY3QgdHlwZSBkZWZpbml0aW9uLiBVc2UgJ2RhdGFJbicsICdkYXRhT3V0JyAsICdpbnB1dCcgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIE9iamVjdCwgdGhhdCBzaG91bGQgYmUgdmFsaWRhdGVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSwgaWYgdGhlIG9iamVjdCBpcyBjb21wYXRpYmxlIHRvIHRoaXMgY29tcG9zYWJsZSByZWdhcmRpbmcgdGhlIGdpdmVuIHR5cGUuXG4gKi9cbkNvbXBvc2FibGUucHJvdG90eXBlLnZhbGlkYXRlVHlwZXMgPSBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG4gICAgdmFyIHR5cGVOYW1lcyA9IHRoaXNbdHlwZSArICdOYW1lcyddO1xuICAgIHZhciB0eXBlU2NoZW1hID0gdGhpc1t0eXBlICsgJ1NjaGVtYSddO1xuICAgIFxuICAgIC8vaWYgcHJvcGVydGllcyBhcmUgYWxsIHByZXNlbnQgYW5kIGEgc2NoZW1hIGlzIHByb3ZpZGVkLCB3ZSBjYW4gcGVyZm9ybSBhIG1vcmUgZGV0YWlsZWQgY2hlY2tcbiAgICBpZiAodHlwZVNjaGVtYSAhPT0gbnVsbCkge1xuICAgICAgICAvL3VzZSB0aGUgdmFsaWRhdG9yIGxpYnJhcnkgb24gdGhlIG9iamVjdFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gc3dldmEuQWp2LnZhbGlkYXRlKHR5cGVTY2hlbWEsIG9iaik7XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKG5ldyBFeGVjdXRpb25FcnJvcignT2JqZWN0IGRvZXMgbm90IG1hdGNoIHRoZSBnaXZlbiAnICsgdHlwZSArICdTY2hlbWE6ICcgKyBzd2V2YS5BanYuZXJyb3JzVGV4dChzd2V2YS5BanYuZXJyb3JzKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBvYmopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgaWdub3JlLCBiZWNhdXNlIGFuIGludmFsaWQgc2NoZW1hIGxpa2UgZ2VuZXJhdGVkIGJ5IEFzc2VtYmx5U2NyaXB0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb3VyY2UgYW5kXG4gICAgICAgICAgICBhbHJlYWR5IG1hdGNoZXMgdGhlIGlucHV0L291dHB1dCBkYXRhLiBDb25zaWRlciBhZGRpbmcgdGhlIGN1c3RvbSB0eXBlcyB0byB0aGUgdmFsaWRhdG9yLCBpZiB0aGlzIGlzIG5vdCB0aGVcbiAgICAgICAgICAgIGNhc2UgZm9yIGZ1dHVyZSBhZGRlZCBsYW5ndWFnZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBGdW5jdGlvbiB0byBzdGFydCB0aGUgZGF0YSBwcm9jZXNzaW5nLiBIZXJlIG9ubHkgYSBkdW1teSBpcyBkZWZpbmVkLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGEgZGF0YSBvYmplY3QgcmVjZWl2ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IHJlY2VpdmVkLlxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSAtIFRoZSBwcm9jZXNzZWQgZGF0YS5cbiAqL1xuQ29tcG9zYWJsZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmUoMCk7XG4gICAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2FibGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tcG9zYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zYWJsZS5qcycpO1xudmFyIE1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvbW9kdWxlLmpzJyk7XG52YXIgRGVmaW5pdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvZGVmaW5pdGlvbkVycm9yLmpzJyk7XG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgaG93IGEgY29tcG9zYWJsZSBpcyBsaW5rZWQgdG8gYW5vdGhlclxuICogQHR5cGVkZWYge09iamVjdH0gbGlua1R5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0byAtIFRoZSBhbGlhcy9uYW1lIG9mIHRoZSB0YXJnZXQgY29tcG9zYWJsZSAoaS5lLiB1bmRlciB3aGljaCBrZXkgaXQgaXMgZGVmaW5lZCBpbiB0aGUgY29tcG9zYWJsZXMgZGljdGlvbmFyeSBvZiB0aGUgY29tcG9zaXRpb24pXG4gKiBAcHJvcGVydHkge3N0cmluZ3xPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBtYXBwaW5nIC0gSG93IGRhdGFPdXQgYW5kIGRhdGFJbiBvZiB0d28gY29tcG9zYWJsZXMgYXJlIG1hcHBlZCB0byBlYWNoIG90aGVyLlxuICogSWYgbm8gbWFwcGluZyBpcyBzcGVjaWZpZWQsIHRoZSB3aG9sZSBkYXRhT3V0IG9iamVjdCBpcyB0YWtlbiBhcyB0aGUgZGF0YUluIG9iamVjdC5cbiAqIElmIGEgc3RyaW5nIGlzIHNwZWNpZmllZCBhcyBhIHZhbHVlLCBpdCBpcyBtYXBwZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGRhdGFJbiBwcm9wZXJ0eS5cbiAqIElmIGEgZGljdGlvbmFyeSBpcyBzcGVjaWZpZWQsIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgZGF0YU91dCBwcm9wZXJ0eSBhbmQgdGhldmFsdWUgdGhlIGRhdGFJbiBwcm9wZXJ0eSBpdCBpcyBtYXBwZWQgdG8uXG4gKiBBbGwgc3RyaW5nIHZhbHVlcyBtdXN0IGJlIHVzaW5nIHRoZSBnaXZlbiB2YWx1ZXMgb2YgdGhlIGRhdGFJbk5hbWVzIGFuZCBkYXRhT3V0TmFtZXMgYXJyYXlzIGRlZmluZWQgaW4gdGhlIGNvbXBvc2FibGUuXG4gKi9cblxuLyoqXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBtYXAgdGhlIGlucHV0IG9iamVjdCBvZiB0aGUgY29tcG9zaXRpb24gdG8gdGhlIGlucHV0IG9iamVjdCBvZiBpbmRpdmlkdWFsIGNvbXBvc2FibGVzLlxuICogQmFzaWNhbGx5IHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2ggY29tcG9zYWJsZSBhbmQgdGhlIHJldHVybiB2YWx1ZSBpcyB0aGVuIHVzZWQgYXMgaXRzIGlucHV0IG9iamVjdC5cbiAqIEZvciBleGFtcGxlIHlvdSBjYW4gdXNlIGFuIGlucHV0IG9iamVjdCwgd2hlcmUgeW91IHNwZWNpZnkgaW4gZGV0YWlsIGZvciBldmVyeSBjb21wb3NhYmxlIHRoZSB2YWx1ZSwgdGhlbiB5b3UgY291bGQgc2ltcGx5XG4gKiByZXR1cm4gaW5wdXRbY29tcG9zYWJsZU5hbWVdO1xuICogXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICogXG4gKiBAY2FsbGJhY2sgQ29tcG9zaXRpb25+bWFwSW5wdXRGdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgY29tcG9zaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9zYWJsZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9zYWJsZSByZXF1ZXN0aW5nIGFuIGlucHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gY29tcG9zYWJsZXMgLSBBIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2FibGVzIHVzZWQgYnkgdGhlIGNvbXBvc2l0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBIGxpYnJhcnkgb2JqZWN0IHByb3ZpZGVzIGFjY2VzcyB0byBsaWJzIGZyb20gd2l0aGluIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgdmFsdWUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdGluZyBjb21wb3NhYmxlIGFzIHRoZSBpbnB1dCBvYmplY3QuXG4gKi9cblxuLyoqXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBtYXAgdGhlIGRhdGEgb2JqZWN0IG9mIHRoZSBjb21wb3NpdGlvbiB0byB0aGUgZGF0YSBvYmplY3Qgb2YgaW5kaXZpZHVhbCBjb21wb3NhYmxlcy5cbiAqIEJhc2ljYWxseSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoIGNvbXBvc2FibGUgYW5kIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlbiB1c2VkIGFzIGl0cyBkYXRhIG9iamVjdC5cbiAqIEZvciBleGFtcGxlIHlvdSBjYW4gdXNlIGEgZGF0YSBvYmplY3QsIHdoZXJlIHlvdSBzcGVjaWZ5IGluIGRldGFpbCBmb3IgZXZlcnkgY29tcG9zYWJsZSB0aGUgdmFsdWUsIHRoZW4geW91IGNvdWxkIHNpbXBseVxuICogcmV0dXJuIGRhdGFbY29tcG9zYWJsZU5hbWVdO1xuICogXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICogXG4gKiBAY2FsbGJhY2sgQ29tcG9zaXRpb25+bWFwRGF0YUluRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdpdmVuIHRvIHRoZSBjb21wb3NpdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb3NhYmxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlIHJlcXVlc3RpbmcgYSBkYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gY29tcG9zYWJsZXMgLSBBIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2FibGVzIHVzZWQgYnkgdGhlIGNvbXBvc2l0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBIGxpYnJhcnkgb2JqZWN0IHByb3ZpZGVzIGFjY2VzcyB0byBsaWJzIGZyb20gd2l0aGluIHRoZSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgdmFsdWUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdGluZyBjb21wb3NhYmxlIGFzIHRoZSBkYXRhIG9iamVjdC5cbiAqL1xuXG4vKipcbiAqIEEgdXNlciBkZWZpbmVhYmxlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgcmVzdWx0aW5nIGRhdGEgb2JqZWN0IG9mIHRoZSBkYXRhIHByb2Nlc3NpbmcgcGlwZWxpbmUuXG4gKiBZb3UgY291bGQgZm9yIGV4YW1wbGUgYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvciByZW1vdmUgc29tZSwgY29udmVydCB2YWx1ZXMgZXRjLlxuICogXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICogXG4gKiBAY2FsbGJhY2sgQ29tcG9zaXRpb25+bWFwRGF0YU91dEZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IC0gVGhlIGRhdGEgb2JqZWN0IHByb2R1Y2VkIGJ5IHRoZSBjb21wb3NhYmxlcyB3aXRob3V0IG91dGdvaW5nIGxpbmtzIChlbmQgb2YgZGF0YSBwcm9jZXNzaW5nKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgdmFsdWUgdGhlIGNvbXBvc2l0aW9uIHJldHVybnMgYXMgdGhlIGRhdGFwcm9jZXNzaW5nIHJlc3VsdC5cbiAqL1xuXG5cbi8qKlxuICogVGhlIGluaXRhbGl6YXRpb24gb2JqZWN0IHdpdGggb3B0aW9uYWwgcHJvcGVydGllcyB0byBpbml0aWFsaXplIGNvbXBvc2FibGVzLlxuICogQHR5cGVkZWYge2NvbXBvc2FibGVJbml0YWxpemVyfSBjb21wb3NpdGlvbkluaXRhbGl6ZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gW2NvbXBvc2FibGVzPXt9XSAtIEEgZGljdGlvbmFyeSBvZiBhbGwgY29tcG9zYWJsZXMgdXNlZCBieSB0aGUgY29tcG9zaXRpb24uIFxuICogVGhlIGtleSByZXByZXNlbnRzIHRoZSBpbnRlcm5hbCBhbGlhcywgdGhlIHZhbHVlIHJlcHJlc2VudHMgXG4gKiB0aGUgY29tcG9zYWJsZSBuYW1lLCB3aGljaCBpcyB1c2VkIHRvIGxvYWQgdGhlIGNvbXBvc2FibGUgaW5mb3JtYXRpb24uXG4gKiBcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIEFycmF5LjxsaW5rVHlwZT4+fSBbbGlua3M9e31dIC0gQSBkaWN0aW9uYXJ5IGRlc2NyaWJpbmcgYW4gZWRnZSBsaXN0IG9mIGhvdyB0aGUgY29tcG9zYWJsZXMgYXJlIGxpbmtlZC5cbiAqIFRoZSBrZXkgZGVzY3JpYmVzIHRoZSBvcmlnaW4gY29tcG9zYWJsZSwgdGhlIHZhbHVlIGRlc2NyaWJlcyBhbiBhcnJheSBvZiB0YXJnZXQgY29tcG9zYWJsZXMgd2l0aCBtYXBwaW5nIGluZm9ybWF0aW9uIG9mIHRoZSBkYXRhIHByb3BlcnRpZXMuXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0aW9ufm1hcElucHV0RnVuY3Rpb259IFttYXBJbnB1dF0gLSBBIGZ1bmN0aW9uIHRvIG1hcCB0aGUgaW5wdXQgb2JqZWN0IG9mIHRoZSBjb21wb3NpdGlvbiB0byB0aGUgaW5wdXQgb2JqZWN0IG9mIGluZGl2aWR1YWwgY29tcG9zYWJsZXMuXG4gKiBUaGUgZGVmYXVsdCByZXF1aXJlcyBhbiBpbnB1dCBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgY29ycmVzcG9uZHMgdG8gYSBjb21wb3NhYmxlIGFsaWFzL25hbWUgYW5kIG1hcHMgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byB0aGlzIGNvbXBvc2FibGUgaW5wdXQuXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0aW9ufm1hcERhdGFJbkZ1bmN0aW9ufSBbbWFwRGF0YUluXSAtIEEgZnVuY3Rpb24gdG8gbWFwIHRoZSBkYXRhIG9iamVjdCBvZiB0aGUgY29tcG9zaXRpb24gdG8gdGhlIGRhdGEgb2JqZWN0IG9mIGluZGl2aWR1YWwgY29tcG9zYWJsZXMuXG4gKiBUaGUgZGVmYXVsdCByZXF1aXJlcyBhIGRhdGEgb2JqZWN0LCB3aGVyZSBlYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGEgY29tcG9zYWJsZSBhbGlhcy9uYW1lIGFuZCBtYXBzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gdGhpcyBjb21wb3NhYmxlIGRhdGEuXG4gKiBAcHJvcGVydHkge0NvbXBvc2l0aW9ufm1hcERhdGFPdXRGdW5jdGlvbn0gW21hcERhdGFPdXRdIC0gQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBkYXRhIG9iamVjdCBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBtYWtpbmcgaXQgYXZhaWxhYmxlLlxuICogVGhlIGRlZmF1bHQgZG9lcyBub3QgY2hhbmdlIHRoZSBvdXRwdXQgb2JqZWN0LlxuICovXG5cbi8qKlxuICogQSBjb21wb3NpdGlvbiBjYW4gY29uc2lzdCBvZiBtdWx0aXBsZSBvdGhlciBjb21wb3NpdGlvbnMgb3IgY29tcG9zYWJsZXMuXG4gKiBJdCBvcmNoaXN0cmF0ZXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY29tcG9zYWJsZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbXBvc2FibGVcbiAqIEBwYXJhbSB7Y29tcG9zaXRpb25Jbml0YWxpemVyfSBpbml0aWFsaXphdGlvbk9iamVjdCAtIFRoZSBvYmplY3Qgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tcG9zaXRpb24uXG4gKiBcbiAqL1xuZnVuY3Rpb24gQ29tcG9zaXRpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsIG1hbmFnZXIpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuXG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdjb21wb3NhYmxlcycsIHt9KTtcbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ2xpbmtzJywge30pO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdtYXBJbnB1dCcsIDQsIGZ1bmN0aW9uIChpbnB1dCwgY29tcG9zYWJsZU5hbWUsIGNvbXBvc2FibGVzLCBsaWJzKSB7XG4gICAgICAgIGlmIChpbnB1dC5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFtjb21wb3NhYmxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ21hcERhdGFJbicsIDQsIGZ1bmN0aW9uIChkYXRhLCBjb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZXMsIGxpYnMpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtjb21wb3NhYmxlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ21hcERhdGFPdXQnLCAyLCBmdW5jdGlvbiAob3V0cHV0LCBsaWJzKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gICAgLy9jYWxsIHRvIHRoZSBwYXJlbnQgY2xhc3MgaW5pdGFsaXphdGlvbiBmdW5jdGlvblxuICAgIHRoaXMuaW5pdGlhbGl6ZShpbml0aWFsaXphdGlvbk9iamVjdCk7XG5cbiAgICAvKipcbiAgICAqIEluZGljYXRlcywgaWYgdGhlIGNvbXBvc2l0aW9uIGlzIHJlYWR5IHRvIHVzZS4gVGhpcyBpcyBpbXBvcnRhbnQsIGFzIHJlcXVpcmVkIGNvbXBvc2FibGVzIG1pZ2h0IG5lZWQgdG8gYmUgbG9hZGVkIGZpcnN0LlxuICAgICogQHByb3RlY3RlZFxuICAgICogQG5hbWUgQ29tcG9zaXRpb24jaXNSZWFkeVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cbiAgICB0aGlzLmlzUmVhZHkgPSBmYWxzZTtcbn1cbi8vaW5oZXJpdCBwcm9wZXJ0aWVzXG5Db21wb3NpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvc2FibGUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHN0YXJ0cyB0byByZWN1cnNpdmVseSBsb2FkIGNvbXBvc2FibGVzIHJlcXVpcmVkIGJ5IHRoaXMgY29tcG9zaXRpb24uXG4gKiBTZWUge0BsaW5rIENvbXBvc2FibGVMb2FkZXJ9IGZvciBtb3JlIGRldGFpbHMgb24gaGUgbG9hZGluZyBwcm9jZXNzLlxuICogV2hlbiBmaW5pc2hlZCBhbGwgcmVxdWlyZWQgY29tcG9zYWJsZXMgYXJlIGluIG1lbW9yeSBhbmQgY2FuIGJlIHVzZWQuXG4gKiBBcyBsb2FkaW5nIGlzIGFzeW5jIGl0IHJldHVybnMgYSBwcm9taXNlLiBcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBbiBlbXB0eSBwcm9taXNlLCBzaWduYWxpbmcgdGhhdCBldmVyeXRoaW5nIHdhcyBsb2FkZWQuXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5sb2FkQ29tcG9zYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vY29sbGVjdHMgYW4gYXJyYXkgb2YgbG9hZGluZyBwcm9taXNlcywgd2hpY2ggaXMgdGhlbiBmaWxsZWRcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLmNvbXBvc2FibGVzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgZWFjaCByZXF1aXJlZCBjb21wb3NhYmxlIHRoZSBjb21wb3NhYmxlIGlzIGxvYWRlZCB1c2luZyB0aGUgc3BlY2lmaWVkIG5hbWUgb2YgaXRcbiAgICAgICAgICAgICAgICAvL3RoZSBuYW1lIGl0c2VsZiBhY3RzIGFzIGEgcGFydCBvZiBhIFVSTFxuICAgICAgICAgICAgICAgIC8vYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2FibGVzIGRpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2l0aW9uIGlzIHBhc3NlZCwgc28gdGhlXG4gICAgICAgICAgICAgICAgLy9zdHJpbmcgdmFsdWVzIChuYW1lcykgb2YgdGhlIHJlcXVpcmVkIGNvbXBvc2l0aW9ucyBhcmUgbGF0ZXIgcmVwbGFjZWQgd2l0aCB0aGUgY29tb3NpdGlvbiBvYmplY3RzLFxuICAgICAgICAgICAgICAgIC8vd2hpY2ggY2FuIHRoZW4gYmUgdXNlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb21wb3NhYmxlc1trZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHN3ZXZhLkNvbXBvc2FibGVMb2FkZXIubG9hZChzZWxmLmNvbXBvc2FibGVzW2tleV0sIHNlbGYuY29tcG9zYWJsZXMsIGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9vdGhlcndpc2UgY3JlYXRlIGZyb20gZ2l2ZW4gb2JqZWN0IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZi5jb21wb3NhYmxlc1trZXldLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGU9PSdtb2R1bGUnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZXNba2V5XSA9IG5ldyBNb2R1bGUoc2VsZi5jb21wb3NhYmxlc1trZXldLCBzZWxmLm1hbmFnZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlc1trZXldID0gbmV3IENvbXBvc2l0aW9uKHNlbGYuY29tcG9zYWJsZXNba2V5XSwgc2VsZi5tYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9pbnZva2UgYWxsIHByb21pc2VzIGFuZCB3YWl0IGZvciB0aGVtIHRvIGZpbmlzaFxuICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL3doZW4gYWxsIHByb21pc2VzIGFyZSBmaW5pc2hlZCwgYWxsIGNvbXBvbmVudHMgYXJlIGxvYWRlZCwgc28gdGhlIGNvbXBvc2l0aW9uIGlzIHJlYWR5IHRvIGJlIHVzZWRcbiAgICAgICAgICAgIHNlbGYuaXNSZWFkeSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vaW1wb3J0YW50OiBhcyB3ZSBhcmUgZGVhbGluZyBoZXJlIHdpdGggYXN5bmMgb3BlcmF0aW9ucywgb25lIG1pZ2h0IHRyeSB0byBleGVjdXRlIHRoZSBjb21wb3NpdGlvbiwgYmVmb3JlXG4gICAgICAgICAgICAvL2l0IGlzIHJlYWR5IHRvIGJlIHVzZWQuIEluIHRoaXMgY2FzZSB0aGUgZXhlY3V0aW9uIGlzIGRlbGF5ZWQgYW5kIGluZGljYXRlZCAod2FudHNUb0V4ZWN1dGU9dHJ1ZSlcbiAgICAgICAgICAgIC8vbm93IGlmIHRoZSBsb2FkaW5nIGlzIGZpbmlzaGVkLCBpdCBjYW4gZGlyZWN0bHkgc3RhcnQgdGhlIGV4ZWN1dGlvbiBkaXJlY3RseSBpdHNlbGYsIHVzaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICAgICAgICAgICAgLy9ubyBwb2xsaW5nIG5lZWRlZCA6KVxuICAgICAgICAgICAgaWYgKHNlbGYud2FudHNUb0V4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndhbnRzVG9FeGVjdXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlU3RhcnRlckNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgXG4gICAgICAgICAgICAvL29rIGFsbCBsb2FkZWQsIG5vdyB3ZSBjYW4gYW5hbHl6ZSBncmFwaCBhbmQgY2hlY2sgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIHNlbGYuYW5hbHl6ZUxpbmtHcmFwaCgpO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaW5kaWNhdGUgdG8gdGhlIG91dHNpZGUsIHRoYXQgd2UgYXJlIGRvbmUgd2l0aCBldmVyeXRoaW5nIGFuZCB0aGUgY29tcG9zaXRpb24gY2FuIGJlIHVzZWRcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFsbCBjb21wb3NhYmxlczogJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQsIHNlbGYuY29tcG9zYWJsZXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzLCBpZiBhbGwgdGhlIGRhdGEgYSBjb21wb3NhYmxlIHJlcXVpcmVzIGlzIGFscmVhZHkgYXZhaWxhYmxlLlxuICogQXMgY29tcG9zYWJsZXMgYXJlIGV4ZWN1dGVkIGluIGEgZ3JhcGgsIHNvbWUgY29tcG9zYWJsZXMgZGVwZW5kIG9uIHRoZSBjYWxjdWxhdGlvbnMgb2Ygb3RoZXJzIGFuZCBoYXZlIHRvIHdhaXQgZm9yIHRoZSBkYXRhLlxuICogXG4gKiBGb3IgdGhpcyBwdXJwb3NlLCB0aGUge0BsaW5rIENvbXBvc2FibGUjZGF0YUlufSBwcm9wZXJ0eSBpcyB1c2VkIGFzIGEgY291bnQsIHRoYXQgaGFzIHRvIGJlIHJlYWNoZWRcbiAqIGJ5IHRoZSBhbW91bnQgb2YgcHJvcGVydGllcyBzdG9yZWQgZm9yIHRoaXMgY29tcG9zYWJsZSBpbiB7QGxpbmtzIENvbXBvc2l0aW9uI3BhcmFtZXRlcnN9LlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvc2FibGVOYW1lIC0gVGhlIGFsaWFzIG9mIHRoZSBjb21wb3NhYmxlIG9iamVjdCwgZm9yIHdoaWNoIHRoZSBjaGVjayBzaG91bGQgYmUgcGVyZm9ybWVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUsIGlmIGFsbCBkYXRhIHJlcXVpcmVkIGZvciB0aGUgY29tcG9zYWJsZSBpcyBhdmFpbGFibGUuXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5oYXNQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGNvbXBvc2FibGVOYW1lKSB7XG4gICAgLy9ob3cgbWFueSBwYXJhbWV0ZXJzIGRvZXMgdGhlIGNvbXBvc2FibGUgbmVlZD9cbiAgICBcbiAgICB2YXIgcGFyYW1ldGVyc05lZWRlZCA9IFtdO1xuICAgIGlmKHR5cGVvZiB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGVOYW1lXS5kYXRhSW5Db25uZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtZXRlcnNOZWVkZWQgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGVOYW1lXS5kYXRhSW5Db25uZWN0ZWQpO1xuICAgIH1cbiAgICBcbiAgICBcbiAgICAvL2lmIGl0IGRvZXMgbm90IG5lZWQgYW55LCB3ZSBhcmUgZ29vZCBoZXJlXG4gICAgaWYgKHBhcmFtZXRlcnNOZWVkZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvL2lmIHdlIGFyZSBzdGlsbCBoZXJlLCBpdCBuZWVkcyBhdCBsZWFzdCBvbmVcbiAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGNvbXBvc2FibGVOYW1lKSkge1xuICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy9ub3QgZW5vdWdoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyc05lZWRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNOZWVkZWRbaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXVtwYXJhbWV0ZXJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGRzIG5ldyBkYXRhIHRvIHRoZSBhdmFpbGFibGUgcG9vbCBvdGhlciBjb21wb3NhYmxlcyB1c2UuXG4gKiBUaGlzIGFsbG93cyBkZXBlbmRhbnQgY29tcG9zYWJsZXMgdG8gZmV0Y2ggdGhlIGRhdGEgYW5kIHN0YXJ0IGV4ZWN1dGlvbi5cbiAqIEl0IHNhdmVzIHRoZSBkYXRhIGFzIGEgc3Via2V5IG9mIGEgc3Via2V5IG9mIHtAbGlua3MgQ29tcG9zaXRpb24jcGFyYW1ldGVyc306XG4gKiB0aGlzLnBhcmFtZXRlcnNbY29tcG9zYWJsZV1bcHJvcGVydHldID0gdmFsdWVcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb3NhYmxlTmFtZSAtIFRoZSBhbGlhcyBvZiB0aGUgY29tcG9zYWJsZSBvYmplY3QgZm9yIHdoaWNoIHRoZSBkYXRhIGlzIGludGVuZGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gc2F2ZSB0aGUgZGF0YSBhcywgdGhlIHZhbHVlIG11c3QgY29ycmVzcG9uZCB0byBhIHZhbHVlIGRlZmluZWRcbiAqIGluIHtAbGlua3MgQ29tcG9zYWJsZSNkYXRhSW5OYW1lc30gKHdlIG5lZWQgY29ycmVjdCBtYXBwaW5nKS5cbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW58c3RyaW5nfG51bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGRhdGEgdG8gYWRkLlxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuYWRkUGFyYW1ldGVyID0gZnVuY3Rpb24gKGNvbXBvc2FibGVOYW1lLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAvL2lmIG5vIGtleSBmb3IgY29tcG9zYWJsZSBwcmVzZW50LCBjcmVhdGUgb25lXG4gICAgaWYgKCF0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyc1tjb21wb3NhYmxlTmFtZV0gPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmFtZXRlcnNbY29tcG9zYWJsZU5hbWVdW3Byb3BlcnR5XSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgY29tcG9zaXRpb24sIHNvIGl0IGNhbiBiZSBleGVjdXRlZCBhZ2Fpbi5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9zaXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHt9OyAgICBcbiAgICB0aGlzLm91dHB1dCA9IHt9O1xuICAgIHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb21wb3NhYmxlcykge1xuICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbXBvc2FibGU6IGtleSxcbiAgICAgICAgICAgICAgICBjbGVhcmVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG59XG5cbi8qKlxuICogQ2hlY2tzLCBpZiB0aGUgY29tcG9zYWJsZSBncmFwaCBvZiB0aGUgY29tcG9zaXRpb24gY29udGFpbnMgY3ljbGVzIChlbmQgdGhlcmVmb3JlIGlzIG5vdCBhIERBRykuXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzdGFydGluZ05vZGVBcnJheSAtIEFuIGFycmF5IHdpdGggdGhlIGFsaWFzZXMgb2YgYWxsIGNvbXBvc2FibGVzLCB0aGF0IGRvIG5vdCBoYXZlIGFuIGluY29taW5nIGVkZ2UvbGluay5cbiAqIFRoZXkgYXJlIGNvbnNpZGVyZWQgYXMgdGhlIGZpcnN0IG5vZGVzLCB0aGF0IGdldCBleGVjdXRlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlLCBpZiB0aGUgZ3JhcGggY29udGFpbnMgY3ljbGVzLlxuICovXG5Db21wb3NpdGlvbi5wcm90b3R5cGUuaGFzQ3ljbGVzID0gZnVuY3Rpb24gKHN0YXJ0aW5nTm9kZUFycmF5KSB7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICAvL2ZpcnN0IGNyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbXBvc2FibGVzIGluIHRoZSBjb21wb3NpdGlvbiAobm9kZXMpXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcG9zYWJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zYWJsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgbm9kZXNba2V5XSA9IHt9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9jcmVhdGUgYSBjb3B5IG9mIHRoZSBsaW5rcyB3aXRob3V0IG1hcHBpbmcgaW5mb3JtYXRpb24gKGVkZ2VzKVxuICAgIGZvciAodmFyIGZyb21Ob2RlIGluIHRoaXMubGlua3MpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua3MuaGFzT3duUHJvcGVydHkoZnJvbU5vZGUpKSB7XG4gICAgICAgICAgICBlZGdlc1tmcm9tTm9kZV0gPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgZnJvbUVuZHBvaW50IGluIHRoaXMubGlua3NbZnJvbU5vZGVdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua3NbZnJvbU5vZGVdLmhhc093blByb3BlcnR5KGZyb21FbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvTm9kZSBpbiB0aGlzLmxpbmtzW2Zyb21Ob2RlXVtmcm9tRW5kcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XS5oYXNPd25Qcm9wZXJ0eSh0b05vZGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tmcm9tTm9kZV0ucHVzaCh0b05vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtzW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlZGdlc1trZXldLnB1c2godGhpcy5saW5rc1trZXldW2ldLnRvKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgXG4gICAgLy9LYWhuJ3MgYWxnb3JpdGhtXG4gICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub3BvbG9naWNhbF9zb3J0aW5nXG4gICAgdmFyIEwgPSBbXTtcbiAgICB2YXIgUyA9IHN0YXJ0aW5nTm9kZUFycmF5LnNsaWNlKCk7XG4gICAgdmFyIHVuaXF1ZUwgPSB0cnVlO1xuICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG4gPSBTLnBvcCgpO1xuXG4gICAgICAgIC8vc29ydGluZyBvbmx5IHdvcmtzLCBpZiBhbGwgZWxlbWVudHMgYXJlIHVuaXF1ZSFcbiAgICAgICAgaWYgKEwuaW5kZXhPZihuKSA+PSAwKSB7XG4gICAgICAgICAgICB1bmlxdWVMID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBMLnB1c2gobik7XG4gICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlc1tuXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtID0gZWRnZXNbbl1baV07XG4gICAgICAgICAgICAgICAgZWRnZXNbbl0uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICAgICAgaS0tO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhc0luY29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGVkZ2VzW2tleV0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZXNba2V5XVtrXSA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNJbmNvbWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzSW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzSW5jb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgUy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbbl0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlZGdlc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9pZiBlZGdlcyBleGlzdCwgb3IgTCBoYXMgbm9uIHVuaXF1ZSBlbGVtZW50czogdGhlcmUgaXMgYSBjeWNsZVxuICAgIGlmIChPYmplY3Qua2V5cyhlZGdlcykubGVuZ3RoID4gMCB8fCAhdW5pcXVlTCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBDaGVja3MsIGlmIHRoZSBzY2hlbWFzIG9mIHR3byBvYmplY3RzIGFyZSBjb21wYXRpYmxlLlxuICogVHdvIG9iamVjdHMgYXJlIGNvbXBhdGlibGUsIGlmIG9uZSBvZiB0aGVtIGhhcyBubyBzY2hlbWEgZGVmaW5pdGlvbiwgb3IgaWYgdGhlIGZpcnN0IHNjaGVtYSBpcyBpZGVudGljYWwgdG8gdGhlIHNlY29uZCBvbmUgaW4gYSByZWN1cnNpdmUgY29tcGFyaXNvbi5cbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmoxTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaXJzdCBvYmplY3QgKGZyb20pLiBPbmx5IHVzZWQgZm9yIGVycm9yIG91dHB1dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmoyTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzZWNvbmQgb2JqZWN0ICh0bykuIE9ubHkgdXNlZCBmb3IgZXJyb3Igb3V0cHV0LlxuICogQHBhcmFtIHtKU09OU2NoZW1hfSBvYmoxU2NoZW1hIC0gVGhlIHNjaGVtYSBvZnRoZSBmaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0ge0pTT05TY2hlbWF9IG9iajJTY2hlbWEgLSBUaGUgc2NoZW1hIG9mdGhlIHNlY29uZCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gW21hcHBpbmdGcm9tXSAtIFRoZSByZWxldmFudCBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBmaXJzdCBvYmplY3QgKHNvdXJjZS9mcm9tKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWFwcGluZ1RvXSAtIFRoZSByZWxldmFudCBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBzZWNvbmQgb2JqZWN0ICh0YXJnZXQvdG8pLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUsIGlmIHRoZSBvYmplY3Qgd2l0aCBvYmoxU2NoZW1hIGNhbiBiZSB1c2VkLCB3aGVyZSBvYmoyU2NoZW1hIGlzIHJlcXVpcmVkLiBcbiAqL1xuQ29tcG9zaXRpb24ucHJvdG90eXBlLmNoZWNrU2NoZW1hQ29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uIChvYmoxTmFtZSwgb2JqMk5hbWUsIG9iajFTY2hlbWEsIG9iajJTY2hlbWEsIG1hcHBpbmdGcm9tLCBtYXBwaW5nVG8pIHtcbiAgICAvL3NjaGVtYXMgYXJlIG9wdGlvbmFsIChudWxsKSwgc28gZ2l2ZSB0aGUgYmVuZWZpdCBvZiB0aGUgZG91YnRcbiAgICBpZiAob2JqMVNjaGVtYSA9PSBudWxsIHx8IG9iajJTY2hlbWEgPT0gbnVsbCkgeyBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vdXNlIHRvIHN0b3JlIGVycm9yIG1lc3NhZ2VzXG4gICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgIC8vZnVuY3Rpb24gZm9yIHJlY3Vyc2lvbiwgZGVhbHMgd2l0aCB0aGUgbWV0YSBpbmZvcm1hdGlvbiBsZXZlbCAodHlwZSwgcHJvcGVydGllcywgcmVxdWlyZWQsIGV0Yykgb2YgdGhlIEpTT05TY2hlbWFcbiAgICAvL2xldmVsIGluZGljYXRlcyB0aGUgcG9wZXJ0eSBjaGFpbiBhbmQgaXMgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICBmdW5jdGlvbiBtZXRhTGV2ZWwobGV2ZWwsIGZyb20sIHRvKSB7XG4gICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSB0YXJnZXQga2V5cyAob2JqMlNjaGVtYSlcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvKSB7XG4gICAgICAgICAgICAvL3RoZSBzb3VyY2UgKG9iajFTY2hlbWEpIG11c3QgaGF2ZSBhbGwga2V5cyB0aGUgdGFyZ2V0IGhhc1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2l0ZW1zJyAmJiBrZXkgIT09ICdyZXF1aXJlZCcgJiYgIWZyb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtaXNzaW5nIHByb3BlcnR5IFwiJyArIGtleSArICdcIidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5LCBwcm9jZWVkIHRvIHRoZSBtZXRhLWxldmVsXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnaXRlbXMnICYmIGZyb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghbWV0YUxldmVsKGxldmVsICsgJy4nICsga2V5LCBmcm9tW2tleV0sIHRvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHByb3BlcnRpZXMgYXJlIGRlZmluZWQsIHByb2NlZWQgd2l0aCB0aGUgcmVjdXJzaW9uIHVzaW5nIHRoZSBwcm9wZXJ0eUxldmVsXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdwcm9wZXJ0aWVzJyAmJiBmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5TGV2ZWwobGV2ZWwgKyAnLicgKyBrZXksIGZyb21ba2V5XSwgdG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgd2UgZ2V0IHRvIHRoZSByZXF1aXJlZCBhcnJheS4uLlxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAncmVxdWlyZWQnICYmIGZyb20uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vc3BlY2lhbDogcmVxdWlyZWQgYXJyYXkgb3JkZXIgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBmcm9tW2tleV0uc29ydCgpO1xuICAgICAgICAgICAgICAgIHRvW2tleV0uc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgLy9maXJzdCBjaGVjayBpZiB0aGUgbGVuZ3RoIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgaWYgKGZyb21ba2V5XS5sZW5ndGggIT09IHRvW2tleV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2FycmF5IGxlbmd0aCBkaWZmZXJlbnQgZm9yIFwiJyArIGtleSArICdcIiAnICsgZnJvbVtrZXldLnRvU3RyaW5nKCkgKyAnICE9ICcgKyB0b1trZXldLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHdlIG5lZWQgdG8gY29tcGFyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyb21ba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbVtrZXldW2ldICE9PSB0b1trZXldW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2FycmF5IGVsZW1lbnQgZGlmZmVyZW5jZSBmb3IgXCInICsga2V5ICsgJ1wiICggJyArIGZyb21ba2V5XVtpXSArICcgIT0gJyArIHRvW2tleV1baV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnICkgJyArIGZyb21ba2V5XS50b1N0cmluZygpICsgJyAhPSAnICsgdG9ba2V5XS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaWYgd2UgZ2V0IHNvbWV0aGluZyBlbHNlLCB3ZSBjb21wYXJlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIC8vdGhpcyBzaG91bGQgYmUgYWxsIHByaW1pdGl2ZSB0eXBlcywgYnV0IEknbSBub3Qgc3VyZSBpZiBJIGRpZG4ndCBtaXNzIGFueSBwb3NzaWJsZSBub24tcHJpbWl0aXZlXG4gICAgICAgICAgICAvL2luIHRoZSBhYm92ZSBpZi1lbHNlXG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIGlmIChmcm9tW2tleV0gIT09IHRvW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5lcXVhbCBwcm9wZXJ0eSB2YWx1ZSBcIicgKyBrZXkgKyAnXCIgKCAnICsgZnJvbVtrZXldICsgJyAhPSAnICsgdG9ba2V5XSArICcgKSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vZnVuY3Rpb24gZm9yIHJlY3Vyc2lvbiwgZGVhbGluZyB3aXRoIHRoZSBlbnVtZXJhdGlvbiBvZiBwcm9wZXJ0eSBrZXlzIG9mIGEgc2NoZW1hXG4gICAgZnVuY3Rpb24gcHJvcGVydHlMZXZlbChsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRvKSB7XG4gICAgICAgICAgICAvL2Zyb20gbXVzdCBoYXZlIGF0IGxlYXN0IGFsbCBrZXlzIHRvIGhhc1xuICAgICAgICAgICAgaWYgKCFmcm9tLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyBwcm9wZXJ0eSBcIicgKyBrZXkgKyAnXCInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udGludWUsIGJ5IGNoZWNraW5nIHRoZSBtZXRhLWxldmVsIG9mIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghbWV0YUxldmVsKGxldmVsICsgJy4nICsga2V5LCBmcm9tW2tleV0sIHRvW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIC8vaGVscGVyIGZ1bmN0aW9uLCB0aGF0IGhlbHBzIHRvIG5hcnJvdyB0aGUgc2NvcGUsIGlmIGEgbWFwcGluZ1RvL21hcHBpbmdGcm9tIGlzIGdpdmVuXG4gICAgLy9pdCBiYXNpY2FsbHkgdHJhdmVyc2VzIHRoZSBzY2hlbWEgdG8gdGhlIGRlc2lyZWQgbWFwcGluZyBwcm9wZXJ0eSBhbmQgcmV0dXJucyBpdCBhcyB0aGUgbmV3IHNjaGVtYVxuICAgIGZ1bmN0aW9uIHNjb3BlT25NYXBwaW5nKHNjaGVtYSwgbWFwcGluZykge1xuICAgICAgICB2YXIgaGFzU2NoZW1hID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KCdwcm9wZXJ0aWVzJykpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShtYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEucHJvcGVydGllc1ttYXBwaW5nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICAvL2NvcHkgdGhlIG9yaWdpbmFsIHNjaGVtYXMgZm9yIGVycm9yIG91dHB1dCAod2UgbWlnaHQgbW9kaWZ5IG91ciByZWZlcmVuY2UgbGF0ZXIgdG8gbmFycm93IHRoZSBzY29wZSwgYnV0IFxuICAgIC8vd2Ugc3RpbGwgd2FudCB0byBzaG93IHRoZSBmdWxsIHNjaGVtYSBmb3IgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICB2YXIgT3JpZ2luYWxPYmoxU2NoZW1hID0gb2JqMVNjaGVtYTsgXG4gICAgdmFyIE9yaWdpbmFsT2JqMlNjaGVtYSA9IG9iajJTY2hlbWE7XG5cbiAgICAvL21hcHBpbmdzIGFyZSBvcHRpb25hbCwgc28gc2NoZWNrIGlmIHRoZXkgYXJlIGRlZmluZWQgYW5kIG5hcnJvdyB0aGUgc2NvcGVzXG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nVG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc2NvcGVPbk1hcHBpbmcob2JqMlNjaGVtYSwgbWFwcGluZ1RvKTtcbiAgICAgICAgaWYgKHRlbXApIHtcbiAgICAgICAgICAgIG9iajJTY2hlbWEgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6ICcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb21wb3NhYmxlIFwiJyArIG9iajJOYW1lICsgJ1wiIGhhcyBubyBzY2hlbWEgZm9yIHByb3BlcnR5IFwiJyArIG1hcHBpbmdUbyArICdcIiBwcm92aWRlZCBieSBjb21wb3NhYmxlIFwiJyArIG9iajFOYW1lICsgJ1wiJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nRnJvbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBzY29wZU9uTWFwcGluZyhvYmoxU2NoZW1hLCBtYXBwaW5nRnJvbSk7XG4gICAgICAgIGlmICh0ZW1wKSB7XG4gICAgICAgICAgICBvYmoxU2NoZW1hID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgIGxldmVsOiAnJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29tcG9zYWJsZSBcIicgKyBvYmoxTmFtZSArICdcIiBoYXMgbm8gc2NoZW1hIGZvciBwcm9wZXJ0eSBcIicgKyBtYXBwaW5nRnJvbSArICdcIiByZXF1aXJlZCBieSBjb21wb3NhYmxlIFwiJyArIG9iajJOYW1lICsgJ1wiJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9pZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBlcnJvciB5ZXQsIHdlIGNhbiBzdGFydCB0aGUgcmVjdXJzaW9uXG4gICAgXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXN1bHQgPSBtZXRhTGV2ZWwoJycsIG9iajFTY2hlbWEsIG9iajJTY2hlbWEpO1xuICAgIH1cblxuICAgIC8vb3V0cHV0IGFuIGVycm9yIG1lc3NhZ2VcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdmFyIHJlbGV2YW50TWFwcGluZyA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmdGcm9tID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgbWFwcGluZ1RvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVsZXZhbnRNYXBwaW5nID0gJyBmb3IgdGhlIG1hcHBpbmcgXCInICsgbWFwcGluZ0Zyb20gKyAnXCIgLT4gXCInICsgbWFwcGluZ1RvICsgJ1wiJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWFwcGluZ1RvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVsZXZhbnRNYXBwaW5nID0gJyBmb3IgdGhlIG1hcHBpbmcgXCInICsgbWFwcGluZ1RvICsgJ1wiJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmYXVsdHlPYmplY3QgPSB7fTtcbiAgICAgICAgZmF1bHR5T2JqZWN0W29iajFOYW1lXSA9IE9yaWdpbmFsT2JqMVNjaGVtYTtcbiAgICAgICAgZmF1bHR5T2JqZWN0W29iajJOYW1lXSA9IE9yaWdpbmFsT2JqMlNjaGVtYTtcbiAgICAgICAgXG5cbiAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ1NjaGVtYXMgb2YgXCInICsgb2JqMU5hbWUgKyAnXCIgYW5kIFwiJyArIG9iajJOYW1lICsgJ1wiIGluY29tcGF0aWJsZScgKyByZWxldmFudE1hcHBpbmcgKyAnOiAnXG4gICAgICAgICAgICArIGVycm9yLmxldmVsICsgJzogJyArIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBmYXVsdHlPYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogU3RhdGljYWxseSBhbmFseXplcyB0aGUgZ3JhcGggYmVmb3JlIGV4ZWN1dGlvbi5cbiAqIENoZWNrcyBmb3IgY29tcGF0YWJpbGl0eSBvZiBjb21wb3NhYmxlcywgYWJzZW5jZSBvZiBjeWNsZXMgaW4gdGhlIGxpbmthZ2UgZGVmaW5pdGlvbiBldGMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5hbmFseXplTGlua0dyYXBoID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEZhbHNlLCBpZiBubyBlcnJvcnMgaW4gdGhlIGxpbmsgZ3JhcGggZGVmaW5pdGlvbiB3ZXJlIGRldGVjdGVkLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmFtZSBDb21wb3NpdGlvbiNpbnZhbGlkTGlua0dyYXBoXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkTGlua0dyYXBoID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgYWxsIHRoZSBhbGlhc2VzIG9mIHRoZSBjb21wb3NhYmxlcywgdGhhdCBoYXZlIG5vIGluZ29pbmcgbGluaywgaS5lLiB0aGUgJ3N0YXJ0J1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAbmFtZSBDb21wb3NpdGlvbiNzdGFydGluZ0NvbXBvc2FibGVzXG4gICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcG9zYWJsZXMpO1xuICAgIC8qKlxuICAgICogRGljdGlvbmFyeSBvZiBhbGwgdGhlIGFsaWFzZXMgb2YgdGhlIGNvbXBvc2FibGVzLCB0aGF0IGhhdmUgbm8gb3V0Z29pbmcgbGluaywgaS5lLiB0aGUgJ2VuZCdcbiAgICAqIERpY3Rpb25hcnksIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBzb21lIGxvb2t1cHMgb2YgdGhlIGtleSB2YWx1ZXMgbGF0ZXIgb24uXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAbmFtZSBDb21wb3NpdGlvbiNzdGFydGluZ0NvbXBvc2FibGVzXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAgICAqL1xuICAgIHRoaXMuZW5kaW5nQ29tcG9zYWJsZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb21wb3NhYmxlcykge1xuICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmVuZGluZ0NvbXBvc2FibGVzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9maW5kIHN0YXJ0aW5nQ29tcG9zYWJsZXMgdGhhdCBoYXZlIG5vIGluZ29pbmcgZWRnZXNcbiAgICAvL2ZpbmQgZW5kaW5nQ29tcG9zYWJsZXMgdGhhdCBoYXZlIG5vIG91dGdvaW5nIGVkZ2VzXG4gICBcblxuICAgIGZvciAodmFyIGZyb21Ob2RlIGluIHRoaXMubGlua3MpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua3MuaGFzT3duUHJvcGVydHkoZnJvbU5vZGUpKSB7XG4gICAgICAgICAgIFxuXG4gICAgICAgICAgICBmb3IgKHZhciBmcm9tRW5kcG9pbnQgaW4gdGhpcy5saW5rc1tmcm9tTm9kZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rc1tmcm9tTm9kZV0uaGFzT3duUHJvcGVydHkoZnJvbUVuZHBvaW50KSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvTm9kZSBpbiB0aGlzLmxpbmtzW2Zyb21Ob2RlXVtmcm9tRW5kcG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rc1tmcm9tTm9kZV1bZnJvbUVuZHBvaW50XS5oYXNPd25Qcm9wZXJ0eSh0b05vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvRW5kcG9pbnQgPSB0aGlzLmxpbmtzW2Zyb21Ob2RlXVtmcm9tRW5kcG9pbnRdW3RvTm9kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBsaW5raW5nIHRvIGV4aXN0aW5nIGNvbXBvc2FibGUhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uRXJyb3IoJ0NvbXBvc2FibGUgXCInICsgZnJvbU5vZGUgKyAnXCIgbGlua3MgdG8gdW5kZWZpbmVkIGNvbXBvc2FibGUgXCInICsgdG9Ob2RlICsgJ1wiIScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRMaW5rR3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29tcG9zYWJsZSBoYXMgbm8gc3VjaCBkYXRhT3V0LCBpdCB0cmllcyB0byBtYXAgdG8gYW5vdGhlciBjb21wb3NhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2FibGVzW2Zyb21Ob2RlXS5kYXRhT3V0TmFtZXMuaW5kZXhPZihmcm9tRW5kcG9pbnQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbkVycm9yKCdDb21wb3NhYmxlIFwiJyArIGZyb21Ob2RlICsgJ1wiIG1hcHMgdW5kZWZpbmVkIGRhdGFPdXQgXCInICsgZnJvbUVuZHBvaW50ICsgJ1wiIHRvIGNvbXBvc2FibGUgXCInICsgdG9Ob2RlICsgJ1wiIScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCwgdGhpcy5jb21wb3NhYmxlc1tmcm9tTm9kZV0uZGF0YU91dE5hbWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRMaW5rR3JhcGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbXBvc2FibGUgaGFzIG5vIHN1Y2ggZGF0YUluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluTmFtZXMuaW5kZXhPZih0b0VuZHBvaW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignQ29tcG9zYWJsZSBcIicgKyBmcm9tTm9kZSArICdcIiBsaW5rcyB0byB1bmRlZmluZWQgZGF0YUluIFwiJyArIHRvRW5kcG9pbnQgKyAnXCIgb2YgY29tcG9zYWJsZSBcIicgKyB0b05vZGUgKyAnXCIhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCB0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluTmFtZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZGl0aW9uYWxseSBjaGVjayBmb3Igc2NoZW1hIGNvbXBhdGliaWxpdHkgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1tmcm9tTm9kZV0uZGF0YU91dFNjaGVtYSAmJiB0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluU2NoZW1hICE9IG51bGwpIHsvL3NjaGVtYXMgYXJlIG9wdGlvbmFsLCBzbyBvbmx5IGNoZWNrIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhdGlibGVTY2hlbWFzID0gdGhpcy5jaGVja1NjaGVtYUNvbXBhdGliaWxpdHkoZnJvbU5vZGUsIHRvTm9kZSwgdGhpcy5jb21wb3NhYmxlc1tmcm9tTm9kZV0uZGF0YU91dFNjaGVtYSwgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJblNjaGVtYSxmcm9tRW5kcG9pbnQsIHRvRW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wYXRpYmxlU2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZExpbmtHcmFwaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbXBvc2FibGVzW3RvTm9kZV0uZGF0YUluQ29ubmVjdGVkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb3NhYmxlc1t0b05vZGVdLmRhdGFJbkNvbm5lY3RlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zYWJsZXNbdG9Ob2RlXS5kYXRhSW5Db25uZWN0ZWRbdG9FbmRwb2ludF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgb25lIGNvbXBvc2FibGUgQSBwb2ludHMgdG8gY29tcG9zYWJsZSBCLCB0aGVuIEIgY2Fubm90IGJlIHN0YXJ0aW5nQ29tcG9zYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wSW5kZXggPSB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMuaW5kZXhPZih0b05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXMuc3BsaWNlKHByb3BJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgb25lIGNvbXBvc2FibGUgQSBwb2ludHMgdG8gY29tcG9zYWJsZSBCLCB0aGVuIEEgY2Fubm90IGJlIGVuZGluZ0NvbXBvc2FibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRpbmdDb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShmcm9tTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZW5kaW5nQ29tcG9zYWJsZXNbZnJvbU5vZGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgXG5cbiAgICAvL2NoZWNrIGZvciBjeWNsZXNcbiAgICB2YXIgaGFzQ3ljbGVzID0gdGhpcy5oYXNDeWNsZXModGhpcy5zdGFydGluZ0NvbXBvc2FibGVzKTtcbiAgICBpZiAoaGFzQ3ljbGVzKSB7XG4gICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignVGhlcmUgYXJlIGN5Y2xlcyBpbiB0aGUgbGlua2FnZSBvZiBjb21wb3NhYmxlcyEnLFxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQsIHRoaXMubGlua3MpKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkTGlua0dyYXBoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvL2V4dHJhY3QgaW1wbGljaXQgaW5mb3JtYXRpb25cbiAgICB0aGlzLmRhdGFJbiA9IHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7XG4gICAgdGhpcy5kYXRhT3V0ID0gT2JqZWN0LmtleXModGhpcy5lbmRpbmdDb21wb3NhYmxlcykubGVuZ3RoO1xuXG4gICAgdGhpcy5kYXRhSW5OYW1lcyA9IFtdO1xuICAgIHRoaXMuZGF0YU91dE5hbWVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgIFxuICAgICAgICBpZiAodGhpcy5jb21wb3NhYmxlc1t0aGlzLnN0YXJ0aW5nQ29tcG9zYWJsZXNbaV1dLmRhdGFJbk5hbWVzLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFJbk5hbWVzLnB1c2godGhpcy5zdGFydGluZ0NvbXBvc2FibGVzW2ldKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmVuZGluZ0NvbXBvc2FibGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGluZ0NvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YU91dE5hbWVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbn1cbi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWxsIGNvbXBvc2FibGVzLCBhcyBzb29uIGFzIHRoZXkgY2FuIGJlIGV4ZWN1dGVkIChoYXZlIGFsbCByZXF1aXJlZCBkYXRhIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gSW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4ZWN1dGlvbiBjb250ZXh0LCBzZWUge0BsaW5rIENvbXBvc2FibGUjY29udGV4dH1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9zaXRpb24ucHJvdG90eXBlLmNvbXBvc2FibGVRdWV1ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgXG4gICAgLy9rZWVwIGFuIGFycmF5IG9mIGFsbCBjb21wb3NhYmxlc1xuICAgIC8vZXhlY3V0ZWQgY29tcG9zYWJsZXMgZ2V0IG1hcmtlZFxuICAgIC8qXG4gICAgY29uc29sZS5sb2coXCJDUUUgOiBjb250ZXh0ID1cIik7XG4gICAgY29uc29sZS5sb2coY29udGV4dCk7XG4gICAgY29uc29sZS5sb2coXCJDUUUgOiB0aGlzID1cIik7XG4gICAgY29uc29sZS5sb2codGhpcyk7XG4gICAgY29uc29sZS5sb2coXCJDUUUgOiB1bmNsZWFyZWRDb21wb3NhYmxlcyA9XCIpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXMpO1xuICAgICovXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvL3NraXAgYWxyZWFkeSBleGVjdXRlZCBjb21wb3NhYmxlc1xuICAgICAgICBpZiAodGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jbGVhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGNvbXBvc2FibGVOYW1lID0gdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jb21wb3NhYmxlO1xuXG4gICAgICAgIFxuICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBpbnB1dCA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICAvL2NoZWNrIGlmIGNvbXBvc2FibGUgaGFzIGFsbCBkYXRhIGl0IGRlcGVuZHMgb24gYXZhaWxhYmxlXG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5oYXNQYXJhbWV0ZXJzKGNvbXBvc2FibGVOYW1lKSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZpbGwgZGF0YSBhbmQgaW5wdXQgZm9yIG5leHQgY29tcG9zYWJsZSBjYWxsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5wYXJhbWV0ZXJzW2NvbXBvc2FibGVOYW1lXTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMubWFwSW5wdXQodGhpcy5pbnB1dCwgY29tcG9zYWJsZU5hbWUsIHRoaXMuY29tcG9zYWJsZXMsIHN3ZXZhLmxpYnMpO1xuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL25vdCBjb250aW51ZWQgPSBjb21wb3NhYmxlTmFtZSBjYW4gYmUgZXhlY3V0ZWQgKGhhcyBkYXRhIHZhaWxhYmxlKVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vY2xvc3VyZSBmdW5jdGlvbiwgdG8gZ2V0IHRoZSBjdXJyZW50IGNvbXBvc2FibGUgZm9yIGVhY2ggZnVuY3Rpb25cbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoY29tcG9zYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBjb21wb3NhYmxlIGRvZXMgbm90IHByb3ZpZGUgZGF0YSB0byBvdGhlciBjb21wb3NhYmxlcyAoZW5kIG9mIGV4ZWN1dGlvbiBjaGFpbilcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbmRpbmdDb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShjb21wb3NhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxDbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBoYXZlIG9ubHkgb25lIG91dHB1dCBjb21wb3NhYmxlLCB3ZSBkbyBub3QgbmVlZCBhIG5hbWVkIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBjcmVhdGUgYSBwcm9wZXJ0eSB1c2luZyB0aGUgZW5kaW5nLWNvbXBvc2FibGUgYWxpYXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuZW5kaW5nQ29tcG9zYWJsZXMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3V0cHV0W2NvbXBvc2FibGVOYW1lXSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGlzIHdhcyB0aGUgbGFzdCBjb21wb3NhYmxlIChhbGwgaGF2ZSBiZWVuIGV4ZWN1dGVkKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlbGYudW5sY2VhcmVkQ29tcG9zYWJsZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi51bmxjZWFyZWRDb21wb3NhYmxlc1trXS5jbGVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ2xlYXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyB3YXMgdGhlIGxhc3QgZW5kaW5nQ29tcG9zYWJsZSwgZmluaXNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDbGVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV4ZWN1dGVGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2lmIGNvbXBvc2FibGUgcHJvdmlkZXMgZGF0YSB0byBvdGhlciBjb21wb3NhYmxlcyBcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGlua3NbY29tcG9zYWJsZU5hbWVdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZyb21FbmRwb2ludCBpbiBzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXS5oYXNPd25Qcm9wZXJ0eShmcm9tRW5kcG9pbnQpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdG9Ob2RlIGluIHNlbGYubGlua3NbY29tcG9zYWJsZU5hbWVdW2Zyb21FbmRwb2ludF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxpbmtzW2NvbXBvc2FibGVOYW1lXVtmcm9tRW5kcG9pbnRdLmhhc093blByb3BlcnR5KHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9FbmRwb2ludCA9IHNlbGYubGlua3NbY29tcG9zYWJsZU5hbWVdW2Zyb21FbmRwb2ludF1bdG9Ob2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRQYXJhbWV0ZXIodG9Ob2RlLCB0b0VuZHBvaW50LCBvdXRwdXRbZnJvbUVuZHBvaW50XSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9yZWN1cnNpdmUgZXhlY3V0aW9uIG9mIHRoZSBuZXh0IGNvbXBvc2FibGVzLCBhcyB0aGlzIG9uZSBqdXN0IGZpbmlzaGVkIGFuZCBwcm9iYWJseSByZXNvbHZlZCBzb21lIGRhdGEgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzZWxmLnBhcmFtZXRlcnMpXG5cbiAgICAgICAgICAgICAgICBzZWxmLm1hbmFnZXIuYWRkUmVleGVjdXRpb25MaXN0ZW5lcihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZWVkc1JlbG9hZGluZ1Zpc3VhbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByb2dyZXNzID0gcmVzdWx0Lm1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyYW1ldGVycyA9IHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm91dHB1dCA9IHJlc3VsdC5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMuZGF0YS5vdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubXF0dF9jbGllbnQgPSByZXN1bHQubXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEuY2xpZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBpZihyZXN1bHQubGFzdFJldHVybmVkRGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBmb3IgKHZhciBrZXkgaW4gc2VsZi5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBpZihzZWxmLmNvbXBvc2FibGVzW2tleV0ubmFtZSA9PSByZXN1bHQubmFtZSl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICB2YXIgb3V0cHV0ID0gIHNlbGYuY29tcG9zYWJsZXNba2V5XS5kYXRhT3V0TmFtZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBmb3IgKHZhciBpIGluIHNlbGYuY29tcG9zYWJsZXNba2V5XS5kYXRhSW5OYW1lcyl7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHNlbGYucGFyYW1ldGVyc1trZXldW3NlbGYuY29tcG9zYWJsZXNba2V5XS5kYXRhSW5OYW1lc1tpXV0gPSByZXN1bHQubGFzdFJldHVybmVkRGF0YVtvdXRwdXRdO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi51bmxjZWFyZWRDb21wb3NhYmxlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0Lm1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLnVuY2xlYXJlZENvbXBvc2FibGVzQ2xvbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24uYXBwbHkoc2VsZiwgW3NlbGYuY29udGV4dF0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVjb21wdXRpbmcgZGVtbyByZXN1bHQnKTtcbiAgICAgICAgICAgICAgICB9LCBzZWxmLm1xdHRfbW9kdWxlX25hbWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZVF1ZXVlRXhlY3V0aW9uLmFwcGx5KHNlbGYsIFtjb250ZXh0XSk7XG5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgICAgIC8vbWFyayBjb21wb3NhYmxlIGFzIGNsZWFyZWRcbiAgICAgICAgaWYgKCF0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNsZWFyZWQpIHtcblxuICAgICAgICAgICAgLy9SZXRyaWV2ZSBEYXRhIG5lZWRlZCBmb3IgdGhlIEFTWU5DIGNhbGxzIG9mIHRoZSBNUVRUIG5vZGVzXG4gICAgICAgICAgICAvL0NoZWNrIGlmIHRoZSBjdXJyZW50IG5vZGUgYWJvdXQgdG8gYmUgY2xlYXJlZCBpcyBhbiBNUVRUIG5vZGVcbiAgICAgICAgICB2YXIgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbXBvc2FibGVzW3RoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXNbaV0uY29tcG9zYWJsZV0uc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKXtcbiAgICAgICAgICAgIHNlbGYubXF0dF9tb2R1bGVfbmFtZSA9IHRoaXMuY29tcG9zYWJsZXNbdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jb21wb3NhYmxlXS5uYW1lO1xuICAgICAgICAgICAgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICBtb2R1bGVfbmFtZTogdGhpcy5jb21wb3NhYmxlc1t0aGlzLnVubGNlYXJlZENvbXBvc2FibGVzW2ldLmNvbXBvc2FibGVdLm5hbWUsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB0aGlzLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgICAgICAgICB1bmNsZWFyZWRDb21wb3NhYmxlc0Nsb25lOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudW5sY2VhcmVkQ29tcG9zYWJsZXMpKSxcbiAgICAgICAgICAgICAgICBwcm9jZXNzOiB0aGlzLnByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5tcXR0X2NsaWVudFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLm1xdHRfbW9kdWxlX25hbWUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdGhpcy51bmxjZWFyZWRDb21wb3NhYmxlc1tpXS5jbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAvL2V4ZWN1dGUgY29tcG9zYWJsZVxuICAgICAgICAgICAgdGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlTmFtZV0uZXhlY3V0ZShkYXRhLCBpbnB1dCwgY29udGV4dCwgY29tcG9zYWJsZU5hbWUsIG1xdHRfc3dldmFfcGFyYW1ldGVycywgdGhpcy5wcm9ncmVzcylcbiAgICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICAgLy9hID0+IGNvbnNvbGUubG9nKGEpKVxuICAgICAgICAgICAgICAgICAgICBmdW5jKGNvbXBvc2FibGVOYW1lKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZXJyb3IgaXMgbG9nZ2VkIGVhcmxpZXIsIGJ1dCBob3cgdG8gaGFuZGxlP1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICBcbiAgICB9XG59XG4vKipcbiAqIFN0YXJ0cyBleGVjdXRpb24gb2YgdGhlIGNvbXBvc2FibGUsIGluaXRpYWxpemVzIHJlcXVpcmVkIGRhdGEuIFVzZSB0aGlzIGZ1bmN0aW9uIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgYSBjb21wb3NhYmxlIVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSByZWxldmFudCB0byB0aGUgcHJvY2Vzc2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIElucHV0IGluZm9ybWF0aW9uIG9uIGhvdyB0byBwcm9jZXNzIHRoZSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBFeGVjdXRpb24gY29udGV4dC4gU2VlIHtAbGluayBDb21wb3NhYmxlI2NvbnRleHR9LlxuICogQHBhcmFtIHtzdHJpbmd9IFthbGlhc10gLSBOYW1lLCB1bmRlciB3aGljaCB0aGUgY29tcG9zYWJsZSBpcyBrbm93biB0byBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Byb2dyZXNzXSAtIENhbGxiYWNrIGZvciBwcm9ncmVzcyB0cmFja2luZywgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZHVsZSBmaW5pc2hlcyBleGVjdXRpb24uXG4gKi9cbkNvbXBvc2l0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0LCBjb250ZXh0LCBhbGlhcywgcHJvZ3Jlc3MpIHtcbiAgICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgY29udGV4dCA9IHRoaXMuZ2V0TmV3Q29udGV4dChjb250ZXh0LCBhbGlhcyk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIFxuICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICBcbiAgICAvL3JldHVybiBhIHByb21pc2UsIHNpbmNlIGV4ZWN1dGlvbiBpcyBhc3luY1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vZG8gbm90IGJvdGhlciBleGVjdXRpbmcsIGlmIGxpbmsgZ3JhcGggZGVmaW5pdGlvbiBpcyBpbnZhbGlkLCBvciB0aGUgcHJvdmlkZWQgZGF0YSBvciBpbnB1dCBvYmplY3QgZG8gbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzY2hlbWEgZGVmaW5pdGlvbnNcbiAgICAgICAgaWYgKCFzZWxmLmludmFsaWRMaW5rR3JhcGggJiYgc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhSW4nLCBkYXRhKSAmJiBzZWxmLnZhbGlkYXRlVHlwZXMoJ2lucHV0JywgaW5wdXQpKSB7XG4gICAgICAgICAgICAvL2VhY2ggc3RhcnRpbmcgY29tcG9zYWJsZSBoYXMgYW4gb3duIGRhdGEgcGFydFxuICAgICAgICAgICAgLy91c2UgdXNlci1kZWZpbmFibGUge0BsaW5rIENvbXBvc2l0aW9ufm1hcERhdGFJbkZ1bmN0aW9ufSB0byBtYXAgdGhlIGRhdGEgdG8gdGhlIHN0YXJ0aW5nIGNvbXBvc2FibGVzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc3RhcnRpbmdDb21wb3NhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb3NhYmxlTmFtZSA9IHNlbGYuc3RhcnRpbmdDb21wb3NhYmxlc1tpXTsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmFtZXRlcnNbY29tcG9zYWJsZU5hbWVdID0gc2VsZi5tYXBEYXRhSW4oc2VsZi5kYXRhLCBjb21wb3NhYmxlTmFtZSwgc2VsZi5jb21wb3NhYmxlcywgc3dldmEubGlicyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGVmaW5lIGNhbGxiYWNrIGZvciB3aGVuIGV4ZWN1dGlvbiBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgc2VsZi5leGVjdXRlRmluaXNoZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzd2V2YS5FcnJvck1hbmFnZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgIG5ldyBFeGVjdXRpb25FcnJvcignU29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQ6ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHN3ZXZhLkVycm9yTWFuYWdlci5nZXRMYXN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgaXMgbm8gZXJyb3JcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy91c2UgdXNlci1kZWZpbmFibGUge0BsaW5rIENvbXBvc2l0aW9ufm1hcERhdGFPdXRGdW5jdGlvbn0gdG8gY3JlYXRlIHRoZSBmaW5hbCBvdXRwdXQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWxmLm1hcERhdGFPdXQoc2VsZi5vdXRwdXQsIHN3ZXZhLmxpYnMpO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhbGlkYXRlIG91dHB1dCB1c2luZyBwcm92aWRlZCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YU91dCcsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGYubmVlZHNSZWxvYWRpbmdWaXN1YWxpemF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLnNlbmREYXRhVG9WaXN1YWxpemF0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYWxsIGNvbXBvc2FibGVzIGFyZSBsb2FkZWQsIHNvIGV4ZWN1dGlvbiBjYW4gc3RhcnQgZGlyZWN0bHlcbiAgICAgICAgICAgIGlmIChzZWxmLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBvc2FibGVRdWV1ZUV4ZWN1dGlvbi5hcHBseShzZWxmLCBbY29udGV4dF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZGVsYXkgZXhlY3V0aW9uIHRvIHtAbGluayBDb21wb3NpdGlvbiNsb2FkQ29tcG9zYWJsZXN9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL3dlIHdhbnQgdG8gZXhlY3V0ZSwgYnV0IGNhbm5vdDogdGVsbCBzbyB0aGUgaW5pdGlhbGl6YXRpb24vbG9hZGluZyBwYXJ0XG4gICAgICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9leGVjdXRlIHZpYSBjYWxsYmFjaywgYXMgc29vbiBhcyBsb2FkaW5nIGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgc2VsZi5leGVjdXRlU3RhcnRlckNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb21wb3NhYmxlUXVldWVFeGVjdXRpb24uYXBwbHkoc2VsZiwgW2NvbnRleHRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0aW9uOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbXBvc2FibGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2FibGUuanMnKTtcbi8vdmFyIENvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcycpO1xudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcblxuLyoqXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBIVFRQIHJlcXVlc3QgYXMgYSBwcm9taXNlLiBJdCBpcyB1c2VkIHRvIGNhbGwgYSByZW1vdGUgc2VydmljZSB1c2luZyBpdHMgQVBJLlxuICpcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcbiAqIEEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gaXMgYWNjZXNzaWJsZSBmcm9tIGluc2lkZSB0aGUgZnVuY3Rpb24gdW5kZXIgbGlicy5nZXQsIHdoaWNoIHRha2VzIHRoZSBvYmplY3QgYW5kIGRlc2lyZWQgcHJvcGVydHkga2V5IGFzIGEgc3RyaW5nIGFuZFxuICogYWN0cyBhcyBbXS5cbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGNhbGxiYWNrIE1vZHVsZX5yZXF1ZXN0RnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEFuIG9iamVjdCBhbGxvd2luZyBhY2Nlc3MgdG8gbGlicmFyaWVzIGluc2lkZSB0aGUgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBBIHVzZXIgZGVmaW5lYWJsZSBmdW5jdGlvbiB0byBoYW5kbGUgZXJyb3JzIGZyb20gZmFpbGVkIHNlcnZpY2UgY2FsbHMuXG4gKlxuICogQXR0ZW50aW9uISBUaGUgdXNlciBkZWZpbmFibGUgZnVuY3Rpb25zIHVzZSBhIGxpbWl0ZWQgc3Vic2V0IG9iIEphdmFTY3JpcHQuIFlvdSBjYW5ub3QgdXNlIGRhbmdlcmVvdXMgb3BlcmF0aW9ucywgbGlrZSBhY2Nlc3NpbmcgdGhpcywgZXZhbCwgZXRjLlxuICogTW9yZW92ZXIsIHRoZSBbXSBhY2Nlc3NvciBpcyBmb3JiaWRkZW4sIGFzIGl0IGNhbm5vdCBiZSBmaWx0ZXJlZCBiZWZvcmUgZXhlY3V0aW9uIVxuICogQSByZXBsYWNlbWVudCBmdW5jdGlvbiBpcyBhY2Nlc3NpYmxlIGZyb20gaW5zaWRlIHRoZSBmdW5jdGlvbiB1bmRlciBsaWJzLmdldCwgd2hpY2ggdGFrZXMgdGhlIG9iamVjdCBhbmQgZGVzaXJlZCBwcm9wZXJ0eSBrZXkgYXMgYSBzdHJpbmcgYW5kXG4gKiBhY3RzIGFzIFtdLlxuICogU2VlIHtAbGluayBTd2V2YVNjcmlwdH0gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAY2FsbGJhY2sgTW9kdWxlfnJlcXVlc3RFcnJvckZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gdGhlIHNlcnZpY2UgY2FsbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBvYmplY3QgZ2l2ZW4gdG8gdGhlIG1vZHVsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsaWJzIC0gQW4gb2JqZWN0IGFsbG93aW5nIGFjY2VzcyB0byBsaWJyYXJpZXMgaW5zaWRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuXG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIHRoZSByZXNwb25zZSBvZiB0aGUgc2VydmljZS5cbiAqXG4gKiBBdHRlbnRpb24hIFRoZSB1c2VyIGRlZmluYWJsZSBmdW5jdGlvbnMgdXNlIGEgbGltaXRlZCBzdWJzZXQgb2IgSmF2YVNjcmlwdC4gWW91IGNhbm5vdCB1c2UgZGFuZ2VyZW91cyBvcGVyYXRpb25zLCBsaWtlIGFjY2Vzc2luZyB0aGlzLCBldmFsLCBldGMuXG4gKiBNb3Jlb3ZlciwgdGhlIFtdIGFjY2Vzc29yIGlzIGZvcmJpZGRlbiwgYXMgaXQgY2Fubm90IGJlIGZpbHRlcmVkIGJlZm9yZSBleGVjdXRpb24hXG4gKiBBIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgZnJvbSBpbnNpZGUgdGhlIGZ1bmN0aW9uIHVuZGVyIGxpYnMuZ2V0LCB3aGljaCB0YWtlcyB0aGUgb2JqZWN0IGFuZCBkZXNpcmVkIHByb3BlcnR5IGtleSBhcyBhIHN0cmluZyBhbmRcbiAqIGFjdHMgYXMgW10uXG4gKiBTZWUge0BsaW5rIFN3ZXZhU2NyaXB0fSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBjYWxsYmFjayBNb2R1bGV+cmVxdWVzdEVycm9yRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBvYmplY3QgZnJvbSB0aGUgc2VydmljZSBjYWxsLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHBhcmFtIHtPYmplY3R9IGxpYnMgLSBBbiBvYmplY3QgYWxsb3dpbmcgYWNjZXNzIHRvIGxpYnJhcmllcyBpbnNpZGUgdGhlIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogQSB1c2VyIGRlZmluZWFibGUgZnVuY3Rpb24gdG8gZG8gYWxsIGNvbXB1dGF0aW9uIGxvY2FsbHksIG5vIHNlcnZpY2UgaXMgY2FsbGVkLlxuICpcbiAqIEF0dGVudGlvbiEgVGhlIHVzZXIgZGVmaW5hYmxlIGZ1bmN0aW9ucyB1c2UgYSBsaW1pdGVkIHN1YnNldCBvYiBKYXZhU2NyaXB0LiBZb3UgY2Fubm90IHVzZSBkYW5nZXJlb3VzIG9wZXJhdGlvbnMsIGxpa2UgYWNjZXNzaW5nIHRoaXMsIGV2YWwsIGV0Yy5cbiAqIE1vcmVvdmVyLCB0aGUgW10gYWNjZXNzb3IgaXMgZm9yYmlkZGVuLCBhcyBpdCBjYW5ub3QgYmUgZmlsdGVyZWQgYmVmb3JlIGV4ZWN1dGlvbiFcbiAqIEEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gaXMgYWNjZXNzaWJsZSBmcm9tIGluc2lkZSB0aGUgZnVuY3Rpb24gdW5kZXIgbGlicy5nZXQsIHdoaWNoIHRha2VzIHRoZSBvYmplY3QgYW5kIGRlc2lyZWQgcHJvcGVydHkga2V5IGFzIGEgc3RyaW5nIGFuZFxuICogYWN0cyBhcyBbXS5cbiAqIFNlZSB7QGxpbmsgU3dldmFTY3JpcHR9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGNhbGxiYWNrIE1vZHVsZX5jb21wdXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGdpdmVuIHRvIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbGlicyAtIEFuIG9iamVjdCBhbGxvd2luZyBhY2Nlc3MgdG8gbGlicmFyaWVzIGluc2lkZSB0aGUgZnVuY3Rpb24uXG4gKi9cblxuXG4vKipcbiAqIFRoZSBpbml0YWxpemF0aW9uIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBtb2R1bGVzLlxuICogQHR5cGVkZWYge2NvbXBvc2FibGVJbml0YWxpemVyfSBtb2R1bGVJbml0YWxpemVyXG4gKiBAcHJvcGVydHkge01vZHVsZX5yZXF1ZXN0RnVuY3Rpb259IFtyZXF1ZXN0XSAtIENyZWF0ZXMgYSBIVFRQIHJlcXVlc3QgdG8gY2FsbCB0aGUgYXBwcm9wcmlhdGUgc2VydmljZS5cbiAqIEBwcm9wZXJ0eSB7TW9kdWxlfnJlcXVlc3RFcnJvckZ1bmN0aW9ufSBbcmVxdWVzdF0gLSBJZiB0aGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCBpcyB1c2VkIHRvIGhhbmRsZSBlcnJvcnMsIGlmIHRoZSBzZXJ2aWNlIGNhbGwgd2FzIHVuc3VjY2Vzc2Z1bC5cbiAqIEBwcm9wZXJ0eSB7TW9kdWxlfnJlc3BvbnNlRnVuY3Rpb259IFtyZXF1ZXN0XSAtIEZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgdGhlIHNlcnZpY2UgcmVzcG9uc2UgdG8gYmUgdXNlZCBsYXRlciBvbi5cbiAqIEBwcm9wZXJ0eSB7TW9kdWxlfmNvbXB1dGVGdW5jdGlvbn0gW3JlcXVlc3RdIC0gSWYgcHJvdmlkZWQsIG5vIHNlcnZpY2UgaXMgY2FsbGVkLCBidXQgYWxsIGNvbXB1dGF0aW9uIGlzIHBlcmZvcm1lZCBsb2NhbGx5IGluIHRoaXMgZnVuY3Rpb24uXG4gKlxuICovXG5cbi8qKlxuICogQSBtb2R1bGUgaXMgdGhlIHNtYWxsZXN0IHVuaXQgb2YgZXhlY3V0aW9uLlxuICogSXQgc2VydmVzIGFzIGFuIGVudmVsb3BlIHRvIGEgc2VydmljZSBjYWxsIGFuZCBjYW4gb3B0aW9uYWxseSBkbyBhbGwgY29tcHV0YXRpb25zIGxvY2FsbHkgd2lodG91dCBhIHJlbW90ZSBzZXJ2aWNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb21wb3NhYmxlXG4gKiBAcGFyYW0ge21vZHVsZUluaXRhbGl6ZXJ9IGluaXRpYWxpemF0aW9uT2JqZWN0IC0gVGhlIG9iamVjdCB3aXRoIG9wdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBjb21wb3NpdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIE1vZHVsZShpbml0aWFsaXphdGlvbk9iamVjdCwgbWFuYWdlcikge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoaW5pdGlhbGl6YXRpb25PYmplY3QpO1xuXG4gICAgLy8gZ2VuZXJhbCBub2RlIHR5cGVcblxuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAncnVuJywgMywgbnVsbCk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdsYW5ndWFnZScsICd0eXBlc2NyaXB0Jyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVQcm9wZXJ0eShpbml0aWFsaXphdGlvbk9iamVjdCwgJ3NvdXJjZScsIG51bGwpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3BlcnR5KGluaXRpYWxpemF0aW9uT2JqZWN0LCAnYmluYXJ5JywgbnVsbCk7XG4gICAgdGhpcy5pbml0aWFsaXplUHJvcGVydHkoaW5pdGlhbGl6YXRpb25PYmplY3QsICdiaW5hcnlIYXNoJywgbnVsbCk7XG5cbiAgICAvKnRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAncmVxdWVzdEVycm9yJywgMywgbnVsbCk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ3Jlc3BvbnNlJywgMyxcbiAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSwgaW5wdXQsIGxpYnMpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbdGhpcy5kYXRhT3V0TmFtZXNbMF1dID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0pOyovXG5cbiAgICAvLyBub3cgdGhlIGFzeW5jaHJvbm91cyBub2RlIHR5cGVcblxuICAgIHRoaXMuaW5pdGlhbGl6ZUZ1bmN0aW9uKGluaXRpYWxpemF0aW9uT2JqZWN0LCAnc3Vic2NyaWJlJywgMywgbnVsbCk7XG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdvbkNvbm5lY3QnLCAzLCBudWxsKTtcbiAgICB0aGlzLmluaXRpYWxpemVGdW5jdGlvbihpbml0aWFsaXphdGlvbk9iamVjdCwgJ29uU3Vic2NyaXB0aW9uJywgMywgbnVsbCk7XG4gICAgdGhpcy5pbml0aWFsaXplRnVuY3Rpb24oaW5pdGlhbGl6YXRpb25PYmplY3QsICdvbk1lc3NhZ2VSZWNlaXZlZCcsIDQsIG51bGwpO1xufVxuXG4vL2luaGVyaXQgcHJvcGVydGllc1xuTW9kdWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9zYWJsZS5wcm90b3R5cGUpO1xuTW9kdWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZHVsZTtcblxuTW9kdWxlLnByb3RvdHlwZS5sYXN0UmV0dXJuZWREYXRhID0gbnVsbDtcblxuLyoqXG4gKiBDYWxscyB0aGUgc2VydmljZSB1c2luZyB0aGUgY3JlYXRlZCBIVFRQIHJlcXVlc3QgcmVjZWl2ZWQgZnJvbSB7QGxpbmsgTW9kdWxlfnJlcXVlc3RGdW5jdGlvbn0uXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtQcm9taXNlfSByZXF1ZXN0IC0gVGhlIGFzeW5jIHNlcnZpY2UgY2FsbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBkYXRhIGlucHV0IG9iamVjdCBnaXZlbiB0byB0aGUgbW9kdWxlLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gQSBwcm9taXNlIHdpdGggdGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqL1xuTW9kdWxlLnByb3RvdHlwZS5jYWxsU2VydmljZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5yZXNwb25zZShyZXNwb25zZSwgaW5wdXQsIHN3ZXZhLmxpYnMpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBoYXZlIGEgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGVycm9ycyBmcm9tIHNlcnZpY2UgZGlyZWN0bHkuLi5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYucmVxdWVzdEVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5yZXF1ZXN0RXJyb3IocmVzcG9uc2UsIGlucHV0LCBzd2V2YS5saWJzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGhpcyBvbmUgc3Vic2NyaWJlcyB0byBhIHRvcGljIG9uIGEgbWVzc2FnZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0gc3Vic2NyaWJlXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuTW9kdWxlLnByb3RvdHlwZS5jYWxsU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHN1YnNjcmliZSwgZGF0YSwgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzLCBpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgY2xpZW50ID0gc3Vic2NyaWJlO1xuICAgICAgICAgICAgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzLmRhdGEuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAgICAgY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYub25Db25uZWN0KGNsaWVudCwgaW5wdXQsIHN3ZXZhLmxpYnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXN0UmV0dXJuZWREYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmV0dXJuZWREYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsaWVudC5vbignbWVzc2FnZScsIGZ1bmN0aW9uICh0b3BpYywgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChtcXR0X3N3ZXZhX3BhcmFtZXRlcnMgIT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMgPSBtcXR0X3N3ZXZhX3BhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5sYXN0UmV0dXJuZWREYXRhID0gc2VsZi5vbk1lc3NhZ2VSZWNlaXZlZChzZWxmLmxhc3RSZXR1cm5lZERhdGEsIHRvcGljLCBtZXNzYWdlLCBzd2V2YS5saWJzKTtcbiAgICAgICAgICAgICAgICAvLyBub3cgbm90aWZ5IHRoZSBleGVjdXRpb24gbWFuYWdlclxuICAgICAgICAgICAgICAgIHNlbGYubWFuYWdlci5vbk1vZHVsZVVwZGF0ZShzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXNvbHZlKHNlbGYub25TdWJzY3JpcHRpb24oZGF0YSwgaW5wdXQsIHN3ZXZhLmxpYnMpKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBmdW5jdGlvbiB0byBkZWFsIHdpdGggZXJyb3JzIGZyb20gc2VydmljZSBkaXJlY3RseS4uLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlcXVlc3RFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5yZXF1ZXN0RXJyb3IocmVzcG9uc2UsIGlucHV0LCBzd2V2YS5saWJzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgbW9kdWxlLCBpLmUuIHBlcmZvcm1zIHRoZSBjb21wdXRhdGlvbiBlaXRoZXIgYnkgY2FsbGluZyBhIHNlcnZpY2Ugb3IgbG9jYWxseS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgcmVsZXZhbnQgdG8gdGhlIHByb2Nlc3NpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBJbnB1dCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gcHJvY2VzcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gRXhlY3V0aW9uIGNvbnRleHQuIFNlZSB7QGxpbmsgQ29tcG9zYWJsZSNjb250ZXh0fS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYWxpYXNdIC0gTmFtZSwgdW5kZXIgd2hpY2ggdGhlIGNvbXBvc2FibGUgaXMga25vd24gdG8gaXRzIHBhcmVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9ncmVzc10gLSBDYWxsYmFjayBmb3IgcHJvZ3Jlc3MgdHJhY2tpbmcsIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2R1bGUgZmluaXNoZXMgZXhlY3V0aW9uLlxuICovXG5Nb2R1bGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXQsIGNvbnRleHQsIGFsaWFzLCBtcXR0X3N3ZXZhX3BhcmFtZXRlcnMsIHByb2dyZXNzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNvbnNvbGUubG9nKFwiY29udGV4dCA9PT1cIik7XG4gICAgY29uc29sZS5sb2coY29udGV4dCk7XG4gICAgY29uc29sZS5sb2coXCJNb2R1bGUgdG8gYmUgZXhlY3V0ZWQgPVwiKTtcbiAgICBjb25zb2xlLmxvZyhzZWxmKTtcbiAgICBjb250ZXh0ID0gdGhpcy5nZXROZXdDb250ZXh0KGNvbnRleHQsIGFsaWFzKTtcblxuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0ge307XG4gICAgfVxuXG5cbiAgICAvLyBQcm9taXNlIHRvIGFib3J0IGlmIG9mZmxvYWRpbmcgaXMgbmVjZXNzYXJ5XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy9iZWdpbiBwcm9taXNlXG4gICAgICAgIC8vb25seSBleGVjdXRlLCBpZiBkYXRhIGFuZCBpbnB1dCBvYmplY3RzIGFyZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbmFsIHNjaGFtYXNcbiAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YUluJywgZGF0YSkgJiYgc2VsZi52YWxpZGF0ZVR5cGVzKCdpbnB1dCcsIGlucHV0KSkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklucHV0IGRhdGEgZm9yIFwiICsgYWxpYXMgKyBcIjogXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnNvdXJjZSAhPSBudWxsKSB7IC8vVE9ETzogdHlwZW9mIHNlbGYucnVuID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIC8vIGlmIGEgY29tcHV0YXRpb24gZnVuY3Rpb24gaXMgZGVmaW5lZCwgdGhlbiBza2lwIHNlcnZpY2UgY2FsbHMgYW5kIGNvbXB1dGUgbG9jYWxseVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVhFQ1VURSBcIiArIHNlbGYubmFtZSArIFwiW1wiICsgYWxpYXMgKyBcIl0gVVNJTkc6IFwiICsgc3dldmEucnVubmVyc1tzZWxmLmxhbmd1YWdlXS5uYW1lKTtcbiAgICAgICAgICAgICAgICAvL2NvbnN0IHJlc3VsdCA9IGF3YWl0IHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0uZXhlYyhzZWxmLCBkYXRhLCBpbnB1dCwge3NpZ25hbH0pO1xuXG4gICAgICAgICAgICAgICAgLy89PT0gT0ZGTE9BRElORyA9PT0gTU9EVUxFIEVYRUNVVElPTiBCRUdJTlMgSEVSRVxuICAgICAgICAgICAgICAgIHN3ZXZhLnJ1bm5lcnNbc2VsZi5sYW5ndWFnZV0uZXhlYyhzZWxmLCBkYXRhLCBpbnB1dCkudGhlbigocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXN1bHQgZGF0YSBmb3IgXCIgKyBhbGlhcyArIFwiOiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0nb2ZmbG9hZGluZycpe1xuICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2ZmbG9hZGluZycpIC8vdG9kbzogcmVzb2x2ZSBvciByZWplY3QgaGVyZSA/XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBNQVAgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIHJlc3VsdCA9IHNlbGYucnVuKGRhdGEsIGlucHV0LCBzd2V2YS5saWJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudmFsaWRhdGVUeXBlcygnZGF0YU91dCcsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVwb3J0IHByb2dyZXNzLCBpZiBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKGFsaWFzLCBzZWxmLm5hbWUsIGNvbnRleHQscmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgbW9kdWxlIGV4ZWN1dGlvbiBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZsb2FkaW5nIGNhbGxiYWNrIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc3Vic2NyaWJpbmcgdG8gYW4gYXN5bmNocm9ub3VzIG1lc3NhZ2UgcXVldWVcbiAgICAgICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1xdHRfc3dldmFfcGFyYW1ldGVycy5kYXRhLmNsaWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBzZWxmLnN1YnNjcmliZShkYXRhLCBpbnB1dCwgc3dldmEubGlicyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jYWxsU3Vic2NyaXB0aW9uKGNsaWVudCwgZGF0YSwgbXF0dF9zd2V2YV9wYXJhbWV0ZXJzLCBpbnB1dCkudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy92YWxpZGF0ZSBvdXRwdXRcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi52YWxpZGF0ZVR5cGVzKCdkYXRhT3V0Jywgb3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAvL3JlcG9ydCBwcm9ncmVzcywgaWYgY2FsbGJhY2sgaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyhhbGlhcywgc2VsZi5uYW1lLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGFzdFJldHVybmVkRGF0YSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmLnJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gSFRUUCByZXF1ZXN0IG5vZGUsIGNhbGwgc2VydmljZSB1c2luZyBhbiBIVFRQIHJlcXVlc3RcblxuICAgICAgICAgICAgc2VsZi5jYWxsU2VydmljZShzZWxmLnJlcXVlc3QoZGF0YSwgaW5wdXQsIHN3ZXZhLmxpYnMpLCBpbnB1dCkudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIG91dHB1dCBpcyBhbHJlYWR5IHRoZSBIVFRQIHJlc3BvbnNlXG5cbiAgICAgICAgICAgICAgICAvL3ZhbGlkYXRlIG91dHB1dFxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnZhbGlkYXRlVHlwZXMoJ2RhdGFPdXQnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmVwb3J0IHByb2dyZXNzLCBpZiBjYWxsYmFjayBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKGFsaWFzLCBzZWxmLm5hbWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzd2V2YS5FcnJvck1hbmFnZXIuZ2V0TGFzdEVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3Qoc3dldmEuRXJyb3JNYW5hZ2VyLmdldExhc3RFcnJvcigpKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlOyIsIi8vZ2xvYmFsIG9iamVjdCBpbml0aWFsaXphdGlvblxudmFyIGdsb2JhbE9iamVjdDtcblxudmFyIGluQnJvd3NlciA9IGZhbHNlO1xuXG50cnkge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgZ2xvYmFsT2JqZWN0ID0gd2luZG93O1xuICAgICAgICBpbkJyb3dzZXIgPSB0cnVlO1xuICAgIH1cbn1cbmNhdGNoIChlKSB7XG4gICAgZ2xvYmFsT2JqZWN0ID0gZ2xvYmFsO1xufVxuXG4vL3ByZXZlbnQgbG9hZGluZyBldmVyeXRoaW5nIHR3aWNlIG9uIGVkaXRvci1wYWdlXG5pZighZ2xvYmFsT2JqZWN0LnN3ZXZhKSB7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhID0ge307XG5cbiAgICBnbG9iYWxPYmplY3Quc3dldmEuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xuXG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLmFzeW5jbXF0dCA9IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9hc3luYy1tcXR0Jyk7XG5cbiAgICB2YXIgQWp2ID0gcmVxdWlyZSgnLi4vLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LmpzJyk7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLkFqdiA9IG5ldyBBanYoKTtcblxuICAgIHZhciBDb21wb3NhYmxlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vYXBwL2NvcmUvZXhlY3V0aW9uL2NvbXBvc2FibGVMb2FkZXIuanMnKTtcbiAgICBnbG9iYWxPYmplY3Quc3dldmEuQ29tcG9zYWJsZUxvYWRlciA9IG5ldyBDb21wb3NhYmxlTG9hZGVyKCcnKTtcblxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5FeGVjdXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi4vLi4vYXBwL2NvcmUvZXhlY3V0aW9uL2V4ZWN1dGlvbk1hbmFnZXIuanMnKTtcblxuICAgIHZhciBFcnJvck1hbmFnZXIgPSByZXF1aXJlKCcuLi8uLi9hcHAvY29yZS9lcnJvcnMvZXJyb3JNYW5hZ2VyLmpzJyk7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLkVycm9yTWFuYWdlciA9IG5ldyBFcnJvck1hbmFnZXIoKTtcblxuICAgIHZhciBTd2V2YVNjcmlwdCA9IHJlcXVpcmUoJy4uLy4uL2FwcC9jb3JlL3N3ZXZhU2NyaXB0L3N3ZXZhU2NyaXB0LmpzJyk7XG4gICAgZ2xvYmFsT2JqZWN0LnN3ZXZhLlN3ZXZhU2NyaXB0ID0gbmV3IFN3ZXZhU2NyaXB0KCk7XG5cbiAgICB2YXIgQXNzZW1ibHlTY3JpcHRSdW5uZXIgPSByZXF1aXJlKCcuLi8uLi9hcHAvY29yZS9ydW5uZXJzL2Fzc2VtYmx5U2NyaXB0UnVubmVyLmpzJyk7XG5cbiAgICAvKlxuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5heGlvcyA9IHJlcXVpcmUoJy4uLy4uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2F4aW9zLm1pbi5qcycpO1xuICAgIGdsb2JhbE9iamVjdC5zd2V2YS5saWJzID0ge1xuICAgICAgICBheGlvczogZ2xvYmFsT2JqZWN0LnN3ZXZhLmF4aW9zLFxuICAgICAgICBtcXR0OiBnbG9iYWxPYmplY3Quc3dldmEuYXN5bmNtcXR0LFxuICAgICAgICBnZXQ6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5nZXQsXG4gICAgICAgIHNldDogZ2xvYmFsT2JqZWN0LnN3ZXZhLlN3ZXZhU2NyaXB0LnNldCxcbiAgICAgICAgLy9tcXR0Y2xpZW50OiBnbG9iYWxPYmplY3Quc3dldmEuU3dldmFTY3JpcHQuY2xpZW50LFxuICAgICAgICAvL21xdHRzdWJzY3JpYmU6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5zdWJzY3JpYmUsXG4gICAgICAgIGFkZGRhdGE6IGdsb2JhbE9iamVjdC5zd2V2YS5Td2V2YVNjcmlwdC5hZGRkYXRhXG4gICAgfSovXG5cbiAgICBnbG9iYWxPYmplY3Quc3dldmEucnVubmVycyA9IHt9O1xuXG4gICAgdmFyIHR5cGVzY3JpcHQgPSBuZXcgQXNzZW1ibHlTY3JpcHRSdW5uZXIoKTtcbiAgICBnbG9iYWxPYmplY3Quc3dldmEucnVubmVyc1t0eXBlc2NyaXB0LmlkXSA9IHR5cGVzY3JpcHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsT2JqZWN0LnN3ZXZhOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN3ZXZhRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9zd2V2YUVycm9yLmpzJyk7XG4vKipcbiAqIEFuIGV4ZWN1dGlvbiBlcnJvciBzaG91bGQgYmUgdXNlZCwgaWYgdGhlIGVycm9yIG9jY3VyZWQgZHVyaW5nIGV4ZWN1dGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU3dldmFFcnJvclxuICovXG5mdW5jdGlvbiBFeGVjdXRpb25FcnJvcihtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpIHtcbiAgICBTd2V2YUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KTtcbiAgICB0aGlzLm5hbWUgPSAnRXhlY3V0aW9uRXJyb3InO1xufVxuRXhlY3V0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTd2V2YUVycm9yLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRXJyb3IiLCIndXNlIHN0cmljdCc7XG5cbnZhciBEZWZpbml0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9kZWZpbml0aW9uRXJyb3IuanMnKTtcbi8qKlxuICogQSBjb21waWxlIGVycm9yIHNob3VsZCBiZSB1c2VkLCBpZiAgdGhlIGVycm9yIHdhcyB0aHJvd24gYnkgdGhlIGNvbXBpbGVyLCBiZWZvcmUgYWN0dWFsIGV4ZWN1dGlvbiBhbmQgdmFsaWRhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGVmaW5pdGlvbkVycm9yXG4gKi9cbmZ1bmN0aW9uIENvbXBpbGVFcnJvcihtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpIHtcbiAgICBEZWZpbml0aW9uRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpO1xuICAgIHRoaXMubmFtZSA9ICdDb21waWxlRXJyb3InO1xufVxuQ29tcGlsZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVmaW5pdGlvbkVycm9yLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGlsZUVycm9yOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN3ZXZhRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9zd2V2YUVycm9yLmpzJyk7XG4vKipcbiAqIEEgZGVmaW5pdGlvbiBlcnJvciBzaG91bGQgYmUgdXNlZCwgaWYgIHRoZSBlcnJvciBvY2N1cmVkIGJlY2F1c2Ugb2YgaW5jb21wYXRpYmxlIGRlZmluaXRpb25zIG9mIGNvbXBvc2FibGVzLCBpLmUuIGJlZm9yZSBhY3R1YWwgZXhlY3V0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTd2V2YUVycm9yXG4gKi9cbmZ1bmN0aW9uIERlZmluaXRpb25FcnJvcihtZXNzYWdlLCBjb250ZXh0LCBmYXVsdHlPYmplY3QpIHtcbiAgICBTd2V2YUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgY29udGV4dCwgZmF1bHR5T2JqZWN0KTtcbiAgICB0aGlzLm5hbWUgPSAnRGVmaW5pdGlvbkVycm9yJztcbn1cbkRlZmluaXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN3ZXZhRXJyb3IucHJvdG90eXBlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZpbml0aW9uRXJyb3I7IiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBBZ2dyZWdhdGVzIHtAbGluayBTd2V2YUVycm9yfSBtZXNzYWdlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFcnJvck1hbmFnZXIoKSB7XG4gICAgLyoqXG4gICAgKiBBbiBhcnJheSBzdG9yaW5nIHRoZSBlcnJvciBtZXNzYWdlcy5cbiAgICAqIEBuYW1lIEVycm9yTWFuYWdlciNxdWV1ZVxuICAgICogQHR5cGUge0FycmF5LjxFcnJvcj59XG4gICAgKi9cbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG4vKipcbiAqIFJlc2V0cyB0aGUgRXJyb3JNYW5hZ2VyLlxuICovXG5FcnJvck1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbn1cbi8qKlxuICogQXBwZW5kcyBlcnJvcnMgdG8gdGhlIGludGVybmFsIHF1ZXVlLCBsb2dzIHRoZW0gYW5kIHJldHVybnMgdGhlIGVycm9yIG9iamVjdFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0LlxuICogQHJldHVybnMge0Vycm9yfSAtIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbkVycm9yTWFuYWdlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goZXJyb3IpO1xuICAgIGNvbnNvbGUubG9nKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEdldHMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHN0b3JlZCBlcnJvcnMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIEFsbCBzdG9yZWQgZXJyb3JzIHNlcGFyYXRlZCBieSBhIGxpbmVicmVhay5cbiAqL1xuRXJyb3JNYW5hZ2VyLnByb3RvdHlwZS5nZXRMb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gdGhpcy5xdWV1ZVtpXS50b1N0cmluZygpICsgJ1xcbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEByZXR1cm5zIHtFcnJvcn0gLSBUaGUgbGFzdCBlcnJvciB0aGF0IHdhcyByZWNvcmRlZC5cbiAqL1xuRXJyb3JNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVt0aGlzLnF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFcnJvck1hbmFnZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVycm9yIG9iamVjdCB3aXRoIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2U6IFdoYXQgd2VudCB3cm9uZz9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gVGhlIGV4ZWN1dGlvbiBjb250ZXh0LCBpbiB3aGF0IGNvbXBvc2FibGUgZGlkIHRoZSBlcnJvciBvY2N1cj9cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmF1bHR5T2JqZWN0XSAtIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yIGNhdXNlLlxuICovXG5mdW5jdGlvbiBTd2V2YUVycm9yKG1lc3NhZ2UsIGNvbnRleHQsIGZhdWx0eU9iamVjdCkge1xuICAgIC8qKlxuICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yIG9iamVjdC5cbiAgICAqIEBuYW1lIFN3ZXZhRXJyb3IjbmFtZVxuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqL1xuICAgIHRoaXMubmFtZSA9ICdTd2V2YUVycm9yJztcblxuICAgIC8qKlxuICAgICogVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgKiBAbmFtZSBTd2V2YUVycm9yI21lc3NhZ2VcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdEZWZhdWx0IE1lc3NhZ2UnO1xuXG4gICAgLyoqXG4gICAgKiBUaGUgY2FsbHN0YWNrIG9mIHRoZSBlcnJvci5cbiAgICAqIEBuYW1lIFN3ZXZhRXJyb3Ijc3RhY2tcbiAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgKi9cbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcblxuICAgIC8qKlxuICAgICogVGhlIGV4ZWN1dGlvbiBjb250ZXh0IG9mIHRoZSBlcnJvciAoaW4gd2hpY2ggY29tcG9zYWJsZSBpdCBvY2N1cmVkKS5cbiAgICAqIEBuYW1lIFN3ZXZhRXJyb3IjY29udGV4dFxuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgIFxuICAgIGlmIChmYXVsdHlPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vc2hhbGxvdyBjb3B5OiBzaG91bGQgcHJvdmlkZSBlbm91Z2ggaW5mb3JtYXRpb24gYW5kIHNhdmUgUkFNXG4gICAgICAgIC8vY29weSBpcyBuZWVkZWQsIGFzIHdlIG5lZWQgdGhlIG9iamVjdCBleGFjdGx5IGF0IHRoZSB0aW1lIHRoZSBlcnJvciBvY2N1cnJlZFxuICAgICAgICB0aGlzLmZhdWx0eU9iamVjdCA9IGZhdWx0eU9iamVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGZhdWx0eU9iamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy9tYWtlIGZ1bmN0aW9ucyB0byBzdHJpbmdzICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmZhdWx0eU9iamVjdCA9IGZhdWx0eU9iamVjdC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmYXVsdHlPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmF1bHR5T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZhdWx0eU9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmF1bHR5T2JqZWN0W2tleV0gPSBmYXVsdHlPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZmF1bHR5T2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgdGltZXN0YW1wIG9mIHRoZSBlcnJvci5cbiAgICAqIEBuYW1lIFN3ZXZhRXJyb3IjdGltZVxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG5cbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gXCIrY29udGV4dCtcIiBjcmVhdGVkISBTdGFja3RyYWNlOlwiKTtcbiAgICBjb25zb2xlLnRyYWNlKCk7XG59XG4vL2luaGVyaXQgcHJvcGVydGllc1xuU3dldmFFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxufSk7XG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIHRpbWVzdGFtcC5cbiAqL1xuU3dldmFFcnJvci5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy50aW1lKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBlcnJvciBvYmplY3QgdG8gc3RyaW5nIGluY2x1ZGluZyByZWxldmFudCBpbmZvcm1hdGlvbiAodGltZXN0YW1wLCBuYW1lLCBjb250ZXh0LCBtZXNzYWdlLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uKS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvci5cbiAqL1xuU3dldmFFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZhdWx0eU9iamVjdCA9ICcnO1xuICAgIGlmICh0eXBlb2YgdGhpcy5mYXVsdHlPYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vdHJhbnNmb3JtIG9iamVjdCB0byBwcmV0dHkgcHJpbnRlZCBzdHJpbmcgKHdpdGggaWRlbnRhdGlvbikuXG4gICAgICAgIGZhdWx0eU9iamVjdCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZmF1bHR5T2JqZWN0LCBudWxsLCA0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZhdWx0eU9iamVjdCA9IHRoaXMuZmF1bHR5T2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vY29uc3RydWN0IHN0cmluZ1xuICAgIHJldHVybiAnWycgKyB0aGlzLmdldFRpbWUoKSArICddIFN3ZXZhRXJyb3IgJyArIHRoaXMubmFtZSArICcgaW4gJyArIHRoaXMuY29udGV4dCArICc6ICcgKyB0aGlzLm1lc3NhZ2UgKyAnXFxuJ1xuICAgICAgICArIGZhdWx0eU9iamVjdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gU3dldmFFcnJvcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBNb2R1bGUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL21vZHVsZS5qcycpO1xudmFyIENvbXBvc2l0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29yZS9jb21wb3NhYmxlcy9jb21wb3NpdGlvbi5qcycpO1xudmFyIERlZmluaXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvZXJyb3JzL2RlZmluaXRpb25FcnJvci5qcycpO1xuXG4vKipcbiAqIFJlc3BvbnNpYmxlIGZvciBkeW5hbWljYWxseSBsb2FkaW5nIGNvbXBvc2FibGVzIGZyb20gYSB3ZWIgYWRkcmVzcy5cbiAqIExvYWRlZCBjb21wb3NhYmxlcyBhcmUgc3RvcmVkIGluIGFuIGludGVybmFsIGRpY3Rpb25hcnksIHNvIHRoZXkgb25seSBuZWVkIHRvIGJlIGRvd25sb2FkZWQgb25jZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IFtiYXNlUGF0aD0nJ10gLSBUaGUgYmFzZSBhZGRyZXNzIGZyb20gd2hpY2ggdG8gZG93bmxvYWQgdGhlIGNvbXBvc2FibGUuIEdldHMgcHJlcGVuZGVkIHRvIHRoZSBjb21wb3NhYmxlIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1ZmZpeD0uanNvbl0gLSBUaGUgc3VmZml4IHRoYXQgZ2V0cyBhcHBlbmRlZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lLlxuICovXG5mdW5jdGlvbiBDb21wb3NhYmxlTG9hZGVyKGJhc2VQYXRoLCBzdWZmaXgpIHtcbiAgICAvKipcbiAgICAqIFRoZSBiYXNlIGFkZHJlc3MgZnJvbSB3aGljaCB0byBkb3dubG9hZCB0aGUgY29tcG9zYWJsZS4gR2V0cyBwcmVwZW5kZWQgdG8gdGhlIGNvbXBvc2FibGUgbmFtZS5cbiAgICAqIEBuYW1lIENvbXBvc2FibGVMb2FkZXIjYmFzZVBhdGhcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGggfHwgJyc7XG4gICAgLyoqXG4gICAgKiBUaGUgc3VmZml4IHRoYXQgZ2V0cyBhcHBlbmRlZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lLlxuICAgICogQG5hbWUgQ29tcG9zYWJsZUxvYWRlciNzdWZmaXhcbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKi9cbiAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeCB8fCAnJztcbiAgICAvKipcbiAgICAqIERpY3Rpb25hcnkgb2YgdGhlIGNvbXBvc2FibGUgbmFtZXMgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvbXBvc2FibGUgb2JqZWN0cy5cbiAgICAqIEBuYW1lIENvbXBvc2FibGVMb2FkZXIjY29tcG9zYWJsZXNcbiAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQ29tcG9zYWJsZT59XG4gICAgKi9cbiAgICB0aGlzLmNvbXBvc2FibGVzID0ge307XG4gICAgLyoqXG4gICAgKiBEaWN0aW9uYXJ5IG9mIGEgd2FpdGluZyBsaXN0LCB3aGVyZSBsb2FkZWQgY29tcG9zYWJsZXMgY2FuIGJlIGFzc2lnbmVkIHRvIGV4dGVybmFsIG9iamVjdHNcbiAgICAqIEBuYW1lIENvbXBvc2FibGVMb2FkZXIjd2FpdGluZ0xpc3RcbiAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn1cbiAgICAqL1xuICAgIHRoaXMud2FpdGluZ0xpc3QgPSB7fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2Ygc3RvcmVkIGNvbXBvc2FibGVzLlxuICovXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbXBvc2FibGVzKS5sZW5ndGg7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUgdG8gcmV0dXJuLlxuICogQHJldHVybnMge0NvbXBvc2FibGV9IC0gVGhlIGNvbXBvc2FibGUgb2JqZWN0LlxuICovXG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvc2FibGVzW25hbWVdO1xufVxuLyoqXG4gKiBDb21wb3NhYmxlIG9iamVjdHMgY2FuIGJlIGRpcmVjdGx5IGFkZGVkLCB3aXRob3V0IGhhdmluZyB0byBkb3dubG9hZCB0aGVtLlxuICogVGhpcyBjYW4gYmUgdXNlZCBlLmcuIGZvciByYXBpZCBwcm90b3R5cGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUgdG8gYWRkLlxuICogQHBhcmFubSB7Q29tcG9zYWJsZX0gY29tcG9zYWJsZSAtIFRoZSBjb21wb3NhYmxlIHRvIGFkZC5cbiAqL1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIGNvbXBvc2FibGUpIHtcbiAgICB0aGlzLmNvbXBvc2FibGVzW25hbWVdID0gY29tcG9zYWJsZTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9zYWJsZSBpbnRvIGEgZnVsbCBjb21wb3NhYmxlIG9iamVjdC5cbiAqIFNpbmNlIGNvbXBvc2FibGVzIGNhbiBoYXZlIGN1c3RvbSBmdW5jdGlvbnMgZGVmaW5lZCwgYW5kIEpTT04gZG9lcyBub3Qgc3VwcG9ydCBmdW5jdGlvbnMsIHdlIGNhbm5vdCB1c2UgSlNPTi5wYXJzZS5cbiAqIEluc3RlYWQgZnVuY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHN0cmluZyBhcnJheXMgaW4gSlNPTiBhbmQgdGhlbiBhc3NlbWJsZWQuXG4gKiB7QGxpbmsgU3dldmFTY3JpcHR9IGlzIHVzZWQgdG8gc2FuaXRpemUgdGhlIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiAtIFRoZSBKU09OIG9iamVjdCBvZiB0aGUgY29tcG9zYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2YgZXhlY3V0aW9uIChmb3IgZXJyb3IgbWVzc2FnZXMpLlxuICogQHJldHVybnMge2NvbXBvc2FibGVJbml0YWxpemVyfSAtIENvbXBvc2FibGUgaW5pdGFsaXphdGlvbiBvYmplY3QuXG4gKi9cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNvbnZlcnRUb09iamVjdCA9IGZ1bmN0aW9uIChqc29uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGpzb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZvciAodmFyIGtleSBpbiBqc29uKSB7XG4gICAgICAgIGlmIChqc29uLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgLy9kZWNvZGUgYmFzZTY0IGVuY29kZWQgYmluYXJpZXNcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ2JpbmFyeScgJiYgIShqc29uW2tleV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coanNvbilcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb250ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGpzb25ba2V5XSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codHlwZW9mIGpzb25ba2V5XSkqL1xuICAgICAgICAgICAgICAgIGxldCBiaW5hcnlMaXN0ID0gYXRvYihqc29uW2tleV0pO1xuICAgICAgICAgICAgICAganNvbltrZXldID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5TGlzdC5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgbWFwcGluZyBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzb3VyY2UnICYmIChqc29uW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIGpzb25ba2V5XVswXSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhqc29uW2tleV1bMF0pO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgc3RyaW5nIGFycmF5IHN0YXJ0cyB3aXRoICdmdW5jdGlvbicgLT4gYXNzZW1ibGUgZnVuY3Rpb24gaW50byBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKCdmdW5jdGlvbicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2FuaXRpemUgdGhlIHNjcmlwdCB0byBwcmV2ZW50IG1hbGljaW91cyBjb2RlIGV4ZWN1dGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGpzb25ba2V5XSA9IHN3ZXZhLlN3ZXZhU2NyaXB0LnNhbml0aXplKGpzb25ba2V5XS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignQ291bGQgbm90IHNhbml0aXplIGZ1bmN0aW9uIFwiJyArIGtleSArICdcIiB3aGVuIGxvYWRpbmcgXCInICsgY29udGV4dCArICdcIjogJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgc2VsZi5jb252ZXJ0SnNvblRvQ29kZShqc29uKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKi8vVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgbWFwcGluZyBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdzb3VyY2UnICYmIHR5cGVvZiBqc29uW2tleV1bMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhqc29uW2tleV1bMF0pO1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgc3RyaW5nIGFycmF5IHN0YXJ0cyB3aXRoICdmdW5jdGlvbicgLT4gYXNzZW1ibGUgZnVuY3Rpb24gaW50byBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnRyaW0oKS5pbmRleE9mKCdmdW5jdGlvbicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3Qgc2FuaXRpemUgdGhlIHNjcmlwdCB0byBwcmV2ZW50IG1hbGljaW91cyBjb2RlIGV4ZWN1dGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGpzb25ba2V5XSA9IHN3ZXZhLlN3ZXZhU2NyaXB0LnNhbml0aXplKGpzb25ba2V5XS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb25FcnJvcignQ291bGQgbm90IHNhbml0aXplIGZ1bmN0aW9uIFwiJyArIGtleSArICdcIiB3aGVuIGxvYWRpbmcgXCInICsgY29udGV4dCArICdcIjogJyArIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgc2VsZi5jb252ZXJ0SnNvblRvQ29kZShqc29uKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSovXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGpzb25ba2V5XSA9IHRoaXMuY29udmVydFRvT2JqZWN0KGpzb25ba2V5XSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy9UT0RPOiByZXBsYWNlIGRlZmF1bHQgbW9kdWxlc1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdE1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJ7XFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJ0eXBlXFxcIjogXFxcIm1vZHVsZVxcXCIsXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJuYW1lXFxcIjogXFxcIk1vZHVsZVxcXCIsXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJkZXNjcmlwdGlvblxcXCI6IFxcXCJOZXcgTW9kdWxlIHRlbXBsYXRlXFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImRhdGFJbk5hbWVzXFxcIjogW1xcblwiICtcbiAgICAgICAgXCIgICAgICAgIFxcXCJudW1cXFwiXFxuXCIgK1xuICAgICAgICBcIiAgICAgIF0sXFxuXCIgK1xuICAgICAgICBcIiAgICAgIFxcXCJkYXRhSW5TY2hlbWFcXFwiOiB7fSxcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImRhdGFPdXROYW1lc1xcXCI6IFtcXG5cIiArXG4gICAgICAgIFwiICAgICAgICBcXFwib3V0XFxcIlxcblwiICtcbiAgICAgICAgXCIgICAgICBdLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiZGF0YU91dFNjaGVtYVxcXCI6IHt9LFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiaW5wdXROYW1lc1xcXCI6IFtdLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiaW5wdXRTY2hlbWFcXFwiOiB7fSxcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcInNvdXJjZVxcXCI6IFtcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImV4cG9ydCB2YXIgYTppMzIgPSA0MjtcXFwiLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwiZXhwb3J0IGZ1bmN0aW9uIHJ1bihudW06IGkzMik6IGkzMiB7XFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcImlmIChhID4gbnVtKXtcXFwiLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwicmV0dXJuIGJ9XFxcIixcXG5cIiArXG4gICAgICAgIFwiICAgICAgXFxcInJldHVybiBudW1cXFwiLFxcblwiICtcbiAgICAgICAgXCIgICAgICBcXFwifVxcXCJcXG5cIiArXG4gICAgICAgIFwiICAgICAgXVxcblwiICtcbiAgICAgICAgXCJ9XCI7XG59XG5Db21wb3NhYmxlTG9hZGVyLnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwie1xcbiAgICB0eXBlOiBcXCdjb21wb3NpdGlvblxcJyxcXG4gICAgbmFtZTogXFwnY29tcG9zaXRpb24xXFwnLFxcbiAgICBkYXRhSW5OYW1lczogW10sXFxuICAgIGRhdGFJblNjaGVtYToge30sXFxuICAgIGRhdGFPdXROYW1lczpbXFwncmVzdWx0XFwnXSxcXG4gICAgZGF0YU91dFNjaGVtYToge30sXFxuICAgIGlucHV0TmFtZXM6IFtdLFxcbiAgICBpbnB1dFNjaGVtYToge30sXFxuICAgIG1hcERhdGFJbjogZnVuY3Rpb24gKGRhdGEsIGNvbXBvc2FibGVOYW1lLCBjb21wb3NhYmxlcywgbGlicykge1xcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoY29tcG9zYWJsZU5hbWUpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGxpYnMuZ2V0KGRhdGEsIGNvbXBvc2FibGVOYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICB9LFxcbiAgICBtYXBEYXRhT3V0OiBmdW5jdGlvbiAob3V0cHV0LCBsaWJzKSB7XFxuICAgICAgICByZXR1cm4gb3V0cHV0O1xcbiAgICB9LFxcbiAgICBtYXBJbnB1dDogZnVuY3Rpb24gKGlucHV0LCBtb2R1bGVOYW1lLCBtb2R1bGVzLCBsaWJzKSB7XFxuICAgICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkobW9kdWxlTmFtZSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gbGlicy5nZXQoaW5wdXQsIG1vZHVsZU5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG59XCI7XG59XG5cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNvbnZlcnRDb2RlVG9Kc29uID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIFxuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgXG4gICAgdmFyIHJlZ2V4RnVuY3Rpb24gPSBuZXcgUmVnRXhwKC9eXFxzKihcXHcpK1xccyo6XFxzKmZ1bmN0aW9uLyk7XG4gICAgdmFyIHJlZ2V4UHJvcGVydHkgPSBuZXcgUmVnRXhwKC9eXFxzKihcXHcpK1xccyovKTtcblxuICAgIHZhciBmdW5jTGluZXMgPSBmYWxzZTtcbiAgICB2YXIgZnVuY0xpbmVzRmlyc3QgPSBmYWxzZTtcbiAgICB2YXIgYnJhY2VDb3VudCA9IDA7XG4gICAgdmFyIGZ1bmNMaW5lc0p1c3RGaW5pc2hlZD0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTsgICAgICAgIFxuICAgICAgICBpZiAoIWZ1bmNMaW5lcykge1xuICAgICAgICAgICAgaWYgKGZ1bmNMaW5lc0p1c3RGaW5pc2hlZCAmJiBsaW5lLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzSnVzdEZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWdleEZ1bmN0aW9uLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBmdW5jTGluZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGluZS5pbmRleE9mKCdmdW5jdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVQYXJ0ID0gbGluZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhQcm9wZXJ0eS5leGVjKGxpbmVQYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUGFydCA9IGxpbmVQYXJ0LnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdcIicgKyBsaW5lUGFydC5zbGljZShtYXRjaC5pbmRleCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpICsgJ1wiJyArIGxpbmVQYXJ0LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZVBhcnQgPSBsaW5lUGFydC5yZXBsYWNlKC8nL2csICdcIicpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVQYXJ0O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdbXCInICsgbGluZS5zbGljZShpbmRleCkgKyAnXCIsXFxuJztcbiAgICAgICAgICAgICAgICBmdW5jTGluZXNGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleFByb3BlcnR5LmV4ZWMobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1wiJyArIGxpbmUuc2xpY2UobWF0Y2guaW5kZXgsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSArICdcIicgKyBsaW5lLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvJy9nLCAnXCInKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUgKyAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY0xpbmVzKSB7XG4gICAgICAgICAgICB2YXIgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpblNpbmdsZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBsaW5lW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGMgPT0gJ1wiJyAmJiAhaW5TaW5nbGVRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXM7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGspICsgJ1xcXFwnICsgbGluZS5zbGljZShrKTtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09ICdcXCcnICYmICFpblF1b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpblF1b3RlcyA9ICFpblNpbmdsZVF1b3RlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSAneycgJiYgIWluUXVvdGVzICYmICFpblNpbmdsZVF1b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICBicmFjZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gJ30nICYmICFpblF1b3RlcyAmJiAhaW5TaW5nbGVRdW90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VDb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jTGluZXNGaXJzdCkge1xuICAgICAgICAgICAgICAgIGZ1bmNMaW5lc0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKCdcXFxcbicsICdcXFxcXFxcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAoYnJhY2VDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgJiYgbGluZS5pbmRleE9mKCcsJykgPj0gbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXCInICsgbGluZSArICdcIicgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXCInICsgbGluZSArICdcIicgKyAnLCcgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChicmFjZUNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICBmdW5jTGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmdW5jTGluZXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXVxcbic7XG4gICAgICAgICAgICAgICAgZnVuY0xpbmVzSnVzdEZpbmlzaGVkPXRydWU7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHQuaW5kZXhPZigneycpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAneycgKyByZXN1bHQgKyAnfSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNvbnZlcnRKc29uVG9Db2RlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGZ1bmN0aW9uIGdldFNwYWNlcyhzcGFjZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShvYmplY3QsIGxldmVsLCBzcGFjZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIHZhciBpZGVudCA9IGdldFNwYWNlcyhsZXZlbCAqIHNwYWNlcyk7XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIga2V5U3RyaW5nID0gKGtleS5pbmRleE9mKCcgJykgPj0gMCkgPyAoJ1xcJycgKyBrZXkgKyAnXFwnJykgOiBrZXk7XG4gICAgICAgICAgICByZXN1bHQgKz0gaWRlbnQgKyBrZXlTdHJpbmcgKyAnOiAnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcJycgKyBvYmplY3Rba2V5XSArICdcXCcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdFtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlDb250ZW50ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdFtrZXldLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG9iamVjdFtrZXldWzBdID09PSAnc3RyaW5nJyAmJiBvYmplY3Rba2V5XVswXS50cmltKCkuaW5kZXhPZignZnVuY3Rpb24nKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RlY29kZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVybmFsTGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvYmplY3Rba2V5XS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gb2JqZWN0W2tleV1ba10udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ30nKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsTGV2ZWwtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsTGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbExldmVsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbnRlbnQgKz0gKGsgPT0gMCA/ICcnIDogaWRlbnQpICsgZ2V0U3BhY2VzKHNwYWNlcyAqIGludGVybmFsTGV2ZWwpICsgbGluZSArIChrID49IG9iamVjdFtrZXldLmxlbmd0aCAtIDEgPyAnJyA6ICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwICYmIGxpbmUuaW5kZXhPZigneycpID09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbExldmVsKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGFycmF5Q29udGVudCArIGlkZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvYmplY3Rba2V5XS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb2JqZWN0W2tleV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9IGlkZW50ICsgZ2V0U3BhY2VzKHNwYWNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbnRlbnQgKz0gJ1xcJycgKyBlbGVtZW50ICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheUNvbnRlbnQgKz0gJ3tcXG4nICsgc3RyaW5naWZ5KG9iamVjdFtrZXldLCBsZXZlbCArIDEsIHNwYWNlcykgKyBpZGVudCArICd9JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Q29udGVudCArPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IG9iamVjdFtrZXldLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9ICcsJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb250ZW50ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdbXFxuJyArIGFycmF5Q29udGVudCArIGlkZW50ICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3tcXG4nICsgc3RyaW5naWZ5KG9iamVjdFtrZXldLCBsZXZlbCArIDEsIHNwYWNlcykgKyBpZGVudCArICd9JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFwnJyArIG9iamVjdFtrZXldICsgJ1xcJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gJ3tcXG4nK3N0cmluZ2lmeShvYmosIDEsIDQpKyd9Jztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24sIHRoYXQgYXNzaWducyB0aGUgY29tcG9zYWJsZXMgdG8gdGhlIGludGVybmFsIGRpY3Rpb25hcnkgYW5kIG9wdGlvbmFsbHkgdG8gZXh0ZXJuYWwgb2JqZWN0cyB3aXRoIGEgc3BlY2lmaWVkIHByb3BlcnR5LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBkaXJlY3RseSBmaWxsIGFub3RoZXIgZXh0ZXJuYWwgZGljdGlvbmFyeSBvZiBjb21wb3NhYmxlcywgbGlrZSB0aGUge0BsaW5rIENvbXBvc2l0aW9ufSBjb21wb3NhYmxlIGRpY3Rpb25hcnkuXG4gKiBAcHJvdGVjdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb3NhYmxlLlxuICogQHBhcmFtIHtDb21wb3NhYmxlfSBjb21wb3NhYmxlIC0gVGhlIGNvbXBvc2FibGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFthc3NpZ25Ub09iamVjdF0gLSBUaGUgZXh0ZXJuYWwgb2JqZWN0IHRvIHdpY2ggdGhlIGNvbXBvc2FibGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBUaGUgcG9ycGVydHkgb2YgdGhlIGV4dGVybmFsIG9iamVjdCB0byB3aWNoIHRoZSBjb21wb3NhYmxlIHNob3VsZCBiZSBhc3NpZ25lZCB0by5cbiAqL1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUuYXNzaWduTG9hZGVkQ29tcG9zYWJsZXMgPSBmdW5jdGlvbiAobmFtZSwgY29tcG9zYWJsZSwgYXNzaWduVG9PYmplY3QsIHByb3BlcnR5KSB7XG4gICAgdGhpcy5jb21wb3NhYmxlc1tuYW1lXSA9IGNvbXBvc2FibGU7XG5cbiAgICAvL2NoZWNrIGlmIHRoZSBvcHRpb25hbCBhc3NpZ25Ub09iamVjdCBpcyBnaXZlblxuICAgIGlmICh0eXBlb2YgYXNzaWduVG9PYmplY3QgIT09ICd1bmRlZmluZWQnICYmIGFzc2lnblRvT2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXNzaWduVG9PYmplY3RbcHJvcGVydHldID0gY29tcG9zYWJsZTtcbiAgICB9XG5cbiAgICAvL2RlYWwgd2l0aCB3YWl0aW5nbGlzdDogYXMgdGhlIGNhbGxlciBoYXMgdG8gd2FpdCBmb3IgJ3RoZW4nIHdlLCBjYW4gc2V0IHRoZSByZXF1aXJlZCB2YWx1ZXMgbm93IHdpdGggc29tZSBkZWxheVxuICAgIGlmICh0aGlzLndhaXRpbmdMaXN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIC8vZm9yIGVhY2ggb2JqZWN0LCB0aGF0IHdhaXRzIGZvciB0aGUgY29tcG9zYWJsZSB0byBiZSBhc3NpZ25lZCB0b1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2FpdGluZ0xpc3RbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc3NpZ25UbyA9IHRoaXMud2FpdGluZ0xpc3RbbmFtZV1baV0uYXNzaWduVG87XG4gICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXMud2FpdGluZ0xpc3RbbmFtZV1baV0ucHJvcDtcblxuICAgICAgICAgICAgYXNzaWduVG9bcHJvcF0gPSBjb21wb3NhYmxlO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIGVsZW1lbnQgZnJvbSB0aGUgd2FpdGluZ0xpc3RcbiAgICAgICAgZGVsZXRlIHRoaXMud2FpdGluZ0xpc3RbbmFtZV07XG4gICAgfVxufVxuLyoqXG4gKiBMb2FkcyBhIGNvbXBvc2FibGUgYnkgdGhlIGdpdmVuIG5hbWUgZnJvbSBhIHdlYiByZXNvdXJjZS5cbiAqIElmIG5vIGJhc2VQYXRoIHdhcyBnaXZlbiBpbiB0aGUgY29uc3RydWN0b3IsIHVzZSB0aGUgZnVsbCB3ZWIgYWRkcmVzcyBhcyB0aGUgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvc2FibGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW2Fzc2lnblRvT2JqZWN0XSAtIFRoZSBleHRlcm5hbCBvYmplY3QgdG8gd2ljaCB0aGUgY29tcG9zYWJsZSBzaG91bGQgYmUgYXNzaWduZWQgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIFRoZSBwb3JwZXJ0eSBvZiB0aGUgZXh0ZXJuYWwgb2JqZWN0IHRvIHdpY2ggdGhlIGNvbXBvc2FibGUgc2hvdWxkIGJlIGFzc2lnbmVkIHRvLlxuICogQHJldHVybnMge1Byb21pc2U8Q29tcG9zYWJsZT59IC0gVGhlIGxvYWRlZCBjb21wb3NhYmxlIG9iamVjdC5cbiAqL1xuQ29tcG9zYWJsZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChuYW1lLCBhc3NpZ25Ub09iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL3JldHVybiBhIHByb21pc2UsIHNpbmNlIGxvYWRpbmcgaXMgYW5zeW5jaHJvbnVvdXNcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvL2NoZWNrIGlmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IGxvYWRlZCBvciBpcyBjdXJyZW50bHkgYmVpbmcgbG9hZGVkXG4gICAgICAgIGlmIChzZWxmLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAvL3dlIGhhdmUgb25seSBvdXIgcGxhY2Vob2xkZXIsIG5vIHJlYWwgdmFsdWUgeWV0XG4gICAgICAgICAgICAvL3RoaXMgbWVhbnMgdGhlIGNvbXBvc2FibGUgaXMgY3VycmVudGx5IHJlcXVlc3RlZCwgYnV0IG5vdCBsb2FkZWRcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbXBvc2FibGVzW25hbWVdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy9wdXQgaW4gd2FpdGluZ2xpc3QsIHdoaWNoIGlzIGNoZWNrZWQgYWZ0ZXIgZWFjaCBsb2FkXG4gICAgICAgICAgICAgICAgLy9idXQgb25seSwgaWYgaXQgbmVlZHMgdG8gYmUgYXNzaWduZWQgZXh0ZXJuYWxseVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXNzaWduVG9PYmplY3QgIT09ICd1bmRlZmluZWQnICYmIGFzc2lnblRvT2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLndhaXRpbmdMaXN0Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLndhaXRpbmdMaXN0W25hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi53YWl0aW5nTGlzdFtuYW1lXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnblRvOiBhc3NpZ25Ub09iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2xvYWQgZnJvbSBkaWN0aW9uYXJ5XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLmNvbXBvc2FibGVzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXNzaWduVG9PYmplY3QgIT09ICd1bmRlZmluZWQnICYmIGFzc2lnblRvT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnblRvT2JqZWN0W3Byb3BlcnR5XSA9IHNlbGYuY29tcG9zYWJsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5jb21wb3NhYmxlc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgICAgIC8vbm90IGFscmVhZHkgaW4gZGljdGlvbmFyeSwgbmVlZHMgdG8gYmUgbG9hZGVkXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9zZXQga2V5IGFuZCBwcmV2ZW50IHVubmVjZXNzYXJ5IGxvYWRzLCB3aGlsZSBsb2FkaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgICAgIHNlbGYuY29tcG9zYWJsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgLy9jb25zdHJ1Y3QgdXJsXG4gICAgICAgICAgICB2YXIgdXJsID0gc2VsZi5iYXNlUGF0aCArIG5hbWUgKyBzZWxmLnN1ZmZpeDtcblxuICAgICAgICAgICAgc3dldmEuYXhpb3MuZ2V0KHVybClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCB0aGUgcmVzcG9uc2UgSlNPTiB0byBhbiBhY3R1YWwgY29tcG9zYWJsZVxuICAgICAgICAgICAgICAgIHZhciBjb21wb3NhYmxlID0gc2VsZi5jb252ZXJ0VG9PYmplY3QocmVzcG9uc2UuZGF0YSwgdXJsKTtcbiAgICAgICAgICAgICAgICAvL2Nsb3N1ZSBmdW5jdGlvbiwgZHVtbXlcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzLCByZWopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyhjb21wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxQcm9taXNlID0gbmV3IFByb21pc2UoZnVuYyhjb21wb3NhYmxlKSk7XG5cbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGNvbXBvc2FibGUganVzdCBleHRlbmRzIGV4aXN0aW5nIG9uZVxuICAgICAgICAgICAgICAgIGlmIChjb21wb3NhYmxlLmhhc093blByb3BlcnR5KCdleHRlbmRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VDb21wb3NhYmxlTmFtZSA9IGNvbXBvc2FibGUuZXh0ZW5kcztcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgYSBjbG9zdXJlIHRvIGxvYWQgdGhlIGJhc2UgY29tcG9zYWJsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYzIgPSBmdW5jdGlvbiAoYmFzZUNvbXBvc2FibGVOYW1lLCBjb21wb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkKGJhc2VDb21wb3NhYmxlTmFtZSkudGhlbihmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V4dGVuZCBsb2FkZWQgY29tcG9zYWJsZSB3aXRoIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMoY29tcC5leHRlbmRXaXRoKGNvbXBvc2FibGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy9hZGp1c3QgaW50ZXJuYWwgcHJvbWlzZSB0byBsb2FkIHRoZSBiYXNlIGNvbXBvc2FibGUgZmlyc3QsIGJlZm9yZSBleHRlbmRpbmcgaXQuXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmMyKGJhc2VDb21wb3NhYmxlTmFtZSwgY29tcG9zYWJsZSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGludGVybmFsUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjb21wb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vbG9nIGFzIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbG9hZGVkICcgKyBjb21wb3NhYmxlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBsb2FkZWQgY29tcG9zYWJsZSBpcyBhIG1vZHVsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zYWJsZS50eXBlID09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0cnVjdCBNb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2FibGUgPSBuZXcgTW9kdWxlKGNvbXBvc2FibGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFzc2lnbkxvYWRlZENvbXBvc2FibGVzKG5hbWUsIGNvbXBvc2FibGUsIGFzc2lnblRvT2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29tcG9zYWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGxvYWRlZCBjb21wb3NhYmxlIGlzIGEgY29tcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnN0cnVjdCBDb21wb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zYWJsZSA9IG5ldyBDb21wb3NpdGlvbihjb21wb3NhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hc3NpZ25Mb2FkZWRDb21wb3NhYmxlcyhuYW1lLCBjb21wb3NhYmxlLCBhc3NpZ25Ub09iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2FkIGNvbXBvc2FibGVzIHJlcXVpcmVkIGZvciB0aGUgY29tcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2FibGUubG9hZENvbXBvc2FibGVzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb21wb3NhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChzZWxmLmJhc2VQYXRoICsgbmFtZSArIHNlbGYuc3VmZml4KTsgLy9jb3VsZCBub3QgbG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBkaWN0aW9uYXJpZXMuXG4gKi9cbkNvbXBvc2FibGVMb2FkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29tcG9zYWJsZXMgPSB7fTtcbiAgICB0aGlzLndhaXRpbmdMaXN0ID0ge307XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2FibGVMb2FkZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xudmFyIE1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvbW9kdWxlLmpzJyk7XG52YXIgQ29tcG9zaXRpb24gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBvc2FibGVzL2NvbXBvc2l0aW9uLmpzJyk7XG5cbi8vTUFcbmxldCBwb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0ID0gcmVxdWlyZShcIi4uL25ldHdvcmsvcG90ZW50aWFsT2ZmbG9hZGluZ1RhcmdldC5qc1wiKTtcbmxldCBkYXRhUHJvY2Vzc2luZ0RldmljZSA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL2RhdGFQcm9jZXNzaW5nRGV2aWNlLmpzXCIpO1xuXG4vLyAqKioqIFAyUCBuZXR3b3JrICoqKipcbmxldCBwZWVyID0gbmV3IFBlZXIoJycse1xuICAgIGhvc3Q6XCJtaWxraS1wc3kuZGJpcy5yd3RoLWFhY2hlbi5kZVwiLFxuICAgIHBvcnQ6NDQzLFxuICAgIHBhdGg6XCIvZGlzY292ZXJ5TmV0d29ya1wiXG59KTtcbmNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBDb25uZWN0aW9uIHRvIHRoZSBTV2VWQSBQMlAgbmV0d29yayBzdWNjZXNzZnVsIScpXG4vL0V2ZW50LWJhc2VkIHNjcmlwdFxuLy8rKysrKysrKysgREVWSUNFIGlzIFBPVCArKysrKysrKytcbnBlZXIub24oJ2Nvbm5lY3Rpb24nLCAoY29ubmVjdGlvbikgPT4ge1xuICAgIGNvbm5lY3Rpb24ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YSA9PT0gJ3BlZXInKXtcbiAgICAgICAgICAgIGxldCBtc2cgPSAnb2ZmbG9hZGluZ091dHB1dCQgUG90ZW50aWFsIE9mZmxvYWRpbmcgVGFyZ2V0IGZyb20gZGV2aWNlID0gJyArIGNvbm5lY3Rpb24ucGVlcjtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICBwb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9KTsgfSk7XG4vLysrKysrKysrKyBERVZJQ0UgaXMgRFBEICsrKysrKysrK1xuXG5mdW5jdGlvbiBicm9hZGNhc3RUb0Rpc2NvdmVyeU5ldHdvcmsoaW50ZXJtZWRpYXRlUGlwZWxpbmVBbmRSZXN1bHRzKSB7XG4gICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIGJyb2FkY2FzdGluZyB0byBkaXNjb3ZlcnkgbmV0d29yay4uLi4nKTtcbiAgICBkYXRhUHJvY2Vzc2luZ0RldmljZShpbnRlcm1lZGlhdGVQaXBlbGluZUFuZFJlc3VsdHMpO1xuICAgIHBlZXIubGlzdEFsbFBlZXJzKChwZWVySWRzKSA9PiB7XG4gICAgICAgIHBlZXJJZHNcbiAgICAgICAgICAgIC5maWx0ZXIoKHBlZXJJZCkgPT4gcGVlcklkICE9PSBwZWVyLmlkKSAvLyBGaWx0ZXIgb3V0IGRldmljZSBJRFxuICAgICAgICAgICAgLmZvckVhY2goKHBlZXJJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBwZWVyLmNvbm5lY3QocGVlcklkKTtcbiAgICAgICAgICAgICAgICBjb25uLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBEaXNjb3ZlcmVkIFBlZXIgPSAnICsgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubi5zZW5kKCdwZWVyJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29ubi5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRpc2NvdmVyaW5nIFBlZXIgOiAnICsgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLy8gKioqKiBFTkQgUDJQIG5ldHdvcmsgKioqKlxuXG4vLyAqKioqKioqKioqKioqIEdldHRlcnMgYW5kIFNldHRlcnMgKioqKioqKioqKioqKioqKlxuXG4vL2RlZmF1bHQgdmFsdWVzXG5sZXQgb2RMaXN0ID0gWzAsMCwwXTtcbmxldCBvckxpc3QgPSBbMCwwLGZhbHNlXTtcbmxldCBpbnRlcm1lZGlhdGVQaXBlbGluZSA9IHt9O1xubGV0IGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0cyA9e307XG5FeGVjdXRpb25NYW5hZ2VyLnNldE9ETGlzdCA9IGZ1bmN0aW9uIChvZExpc3RJbnB1dCkge1xuICAgIG9kTGlzdD1vZExpc3RJbnB1dDtcbn1cbkV4ZWN1dGlvbk1hbmFnZXIuZ2V0T0RMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvZExpc3Q7XG59XG5cbkV4ZWN1dGlvbk1hbmFnZXIuc2V0T1JMaXN0ID0gZnVuY3Rpb24gKG9yTGlzdElucHV0KSB7XG4gICAgb3JMaXN0PW9yTGlzdElucHV0O1xufVxuRXhlY3V0aW9uTWFuYWdlci5nZXRPUkxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9yTGlzdDtcbn1cblxuRXhlY3V0aW9uTWFuYWdlci5zZXRJbml0aWFsSW50ZXJtZWRpYXRlUGlwZWxpbmUgPSBmdW5jdGlvbiAoaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dCkge1xuICAgIC8vcHJlcGFyZSB0aGUgaW50ZXJtZWRpYXRlIHBpcGVsaW5lIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgICBmb3IgKGxldCBrZXkgaW4gaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlcykge1xuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJtZWRpYXRlUGlwZWxpbmVJbnB1dC5jb21wb3NhYmxlc1trZXldLm1hbmFnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJtZWRpYXRlUGlwZWxpbmUgPSBpbnRlcm1lZGlhdGVQaXBlbGluZUlucHV0O1xuXG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBpbnRlcm1lZGlhdGUgcGlwZWxpbmUgPScsaW50ZXJtZWRpYXRlUGlwZWxpbmUpO1xuXG59XG5cbkV4ZWN1dGlvbk1hbmFnZXIuZ2V0TGlzdE9mUGVlcnMgPSBmdW5jdGlvbiBsaXN0T2ZQZWVycygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcGVlci5saXN0QWxsUGVlcnMoKHBlZXJJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBwZWVySWRzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigocGVlcklkKSA9PiBwZWVySWQgIT09IHBlZXIuaWQpXG4gICAgICAgICAgICAgICAgLm1hcCgocGVlcklkKSA9PiBwZWVySWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIHJlc29sdmUobGlzdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8qKioqKiogZW5kIFdlYiBHRVRURVJTIGFuZCBTRVRURVJTICoqKioqKioqKioqXG5cbi8qKlxuICogQW4gRXhlY3V0aW9uTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgdGhlIGV4ZWN1dGlvbiBwcm9jZXNzIG9mIGNvbXBvc2l0aW9ucyBhbmQgbW9kdWxlcy5cbiAqIEl0IGhhcyB0d28gcGhhc2VzOiBBIHNldHVwIHBoYXNlLCB3ZXJlIGFsbCBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgYW5kIGFuIGV4ZWN1dGlvbiBwaGFzZSxcbiAqIHRoYXQgZXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIGJ5IHByb3ZpZGluZyBkYXRhIGFuZCBpbnB1dCBvYmplY3RzIHRvIHRoZW0uXG4gKlxuICogVGhlIHNldHVwIG5lZWRzIHRvIGJlIGRvbmUgb25seSBvbmNlLCB3aGlsZSB0aGUgZXhlY3V0aW9uIGNhbiBiZSByZXBlYXRlZCBvbiBkaWZmZXJlbnQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIE5hbWUgb2YgdGhlIGV4ZWN1dGlvbiBtYW5hZ2VyLlxuICovXG5mdW5jdGlvbiBFeGVjdXRpb25NYW5hZ2VyKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0V4ZWN1dGlvbk1hbmFnZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgaG93IG1hbnkgbW9kdWxlcyBhcmUgdXNlZCBjdXJyZW50bHkuXG4gICAgICogQG5hbWUgRXhlY3V0aW9uTWFuYWdlciNtb2R1bGVzVG90YWxcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW9kdWxlc1RvdGFsID0gMTtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgaG93IG1hbnkgbW9kdWxlcyBoYXZlIGZpbmlzaGVkIGV4ZWN1dGlvbi5cbiAgICAgKiBAbmFtZSBFeGVjdXRpb25NYW5hZ2VyI21vZHVsZXNEb25lXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1vZHVsZXNEb25lID0gMDtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byB0cmFjayBwcm9ncmVzcywgZ2V0cyBjYWxsZWQgZXZlcnl0aW1lIGEgbW9kdWxlIGZpbmlzaGVzLlxuICAgICAqIEBuYW1lIEV4ZWN1dGlvbk1hbmFnZXIjcHJvZ3Jlc3NDYWxsYmFja1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gbnVsbDtcblxuICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyYWNrIHByb2dyZXNzLlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byB1cGRhdGUgdmlzdWFsaXphdGlvbiBvbiBNUVRUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgcmVleGVjdXRpbmcgdGhlIHN3ZXZhLWdyYXBoLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIHZpc3VhbGl6YXRpb24uXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLm9uTVFUVERhdGFSZWNpZXZlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlVmlzdWFsaXphdGlvbk5vdGlmaWVyID0gY2FsbGJhY2s7XG59O1xuXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kRGF0YVRvVmlzdWFsaXphdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAodGhpcy51cGRhdGVWaXN1YWxpemF0aW9uTm90aWZpZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXN1YWxpemF0aW9uTm90aWZpZXIocmVzdWx0KTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIGFueSBhc3luY2hyb25vdXMgbm9kZSByZS1leGVjdXRlcyBwYXJ0cyBvZiB0aGUgY29tcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmFkZFJlZXhlY3V0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1vZHVsZV9uYW1lKSB7XG4gICAgaWYgKHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlZXhlY3V0aW9uTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWV4ZWN1dGlvbkxpc3RlbmVyc1trZXldLm1vZHVsZV9uYW1lID09PSBtb2R1bGVfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWV4ZWN1dGlvbkxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBtb2R1bGVfbmFtZVxuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAobW9kdWxlX25hbWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBtb2R1bGVfbmFtZTogbW9kdWxlX25hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5FeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5vbk1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0ubW9kdWxlX25hbWUgPT09IG1vZHVsZS5tcXR0X3N3ZXZhX3BhcmFtZXRlcnMubW9kdWxlX25hbWUpIHRoaXMucmVleGVjdXRpb25MaXN0ZW5lcnNbaV0uY2FsbGJhY2sobW9kdWxlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFsbCByZXF1aXJlZCBjb21wb3NhYmxlcywgbG9hZHMgZGVwZW5kZW5jaWVzLCB2YWxpZGF0ZXMuXG4gKlxuICogKElGKSBQQVJTRSBwaXBlbGluZSB0byBKUyBvYmplY3Qgc2VsZiBnbG9hYmwgdG8gdGhlIGV4ZWN1dGlvbk1hbmFnZXIgIVxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xDb21wb3NhYmxlPn0gZXhlY3V0aW9uQXJyYXkgLSBBcnJheSBvZiBjb21wb3NhYmxlcyB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1B1cmVPYmplY3Q9ZmFsc2VdIC0gU2V0IHRoaXMgdG8gdHJ1ZSwgaWYgcGFzc2luZyBwdXJlIEphdmFTY3JpcHQgT2JqZWN0cyBhbmQgbm90IGp1c3QgSlNPTi5cbiAqL1xuLy9HbG9iYWwgdmFyaWFibGUgbmFtZXNcblxuXG5cbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKGV4ZWN1dGlvbkFycmF5LCBpc1B1cmVPYmplY3QpIHtcblxuICAgIC8vaW50ZXJuYWwgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNvdW50IGhvdyBtYW55IG1vZHVsZXMgYXJlIGN1cnJlbnRseSB1c2VkXG4gICAgZnVuY3Rpb24gY291bnRNb2R1bGVzKGNvbXBvc2FibGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb3NhYmxlLmNvbXBvc2FibGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9zYWJsZS5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NhYmxlLmNvbXBvc2FibGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhrZXksIGNvbXBvc2FibGUuY29tcG9zYWJsZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGNvdW50TW9kdWxlcyhjb21wb3NhYmxlLmNvbXBvc2FibGVzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1VQREFURUQgQ29tcG9zYWJsZSA9JywgY29tcG9zYWJsZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtYmVyIG9mIHNldCB1cCBub2RlcyBpbiBDb21wb3NhYmxlOiBcIiArIGNvdW50KTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZWVkc0xvYWRpbmcgPSBbXTtcbiAgICB0aGlzLmNvbXBvc2FibGVzID0ge307XG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG5cbiAgICB0aGlzLndhbnRzVG9FeGVjdXRlID0gZmFsc2U7XG4gICAgLy9pZiBpdCBpcyBub3QgYW4gYXJyYXksIG1ha2UgaXQgb25lXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4ZWN1dGlvbkFycmF5KSkge1xuICAgICAgICBleGVjdXRpb25BcnJheSA9IFtleGVjdXRpb25BcnJheV07XG4gICAgfVxuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIC8vZm9yIGVhY2ggY29tcG9zYWJsZSwgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tcG9zYWJsZSA9IGV4ZWN1dGlvbkFycmF5W2ldO1xuICAgICAgICAvL2lmIGNvbXBvc2FibGUgaXMgcHJvdmlkZWQgYXMgc3RyaW5nLCBpLmUuIG5hbWUgaXQgbmVlZHMgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9zYWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2goY29tcG9zYWJsZSk7XG4gICAgICAgICAgICBuZWVkc0xvYWRpbmcucHVzaChzd2V2YS5Db21wb3NhYmxlTG9hZGVyLmxvYWQoY29tcG9zYWJsZSwgdGhpcy5jb21wb3NhYmxlcywgY29tcG9zYWJsZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vb3RoZXJ3aXNlIGEgY29tcG9zYWJsZSBvYmplY3QgaXMgZ2l2ZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzUHVyZU9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWlzUHVyZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbXBvc2FibGUgPSBzd2V2YS5Db21wb3NhYmxlTG9hZGVyLmNvbnZlcnRUb09iamVjdChjb21wb3NhYmxlLCAnSlNPTicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcG9zYWJsZS50eXBlID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zYWJsZXNbY29tcG9zYWJsZS5uYW1lXSA9IG5ldyBNb2R1bGUoY29tcG9zYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0gPSBuZXcgQ29tcG9zaXRpb24oY29tcG9zYWJsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc3dldmEuQ29tcG9zYWJsZUxvYWRlci5hZGQoY29tcG9zYWJsZS5uYW1lLCB0aGlzLmNvbXBvc2FibGVzW2NvbXBvc2FibGUubmFtZV0pO1xuICAgICAgICAgICAgICAgIC8vY29tcG9zYWJsZXMgb2YgYSBjb21wb3NpdGlvbiBuZWVkIGFsc28gdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgbmVlZHNMb2FkaW5nLnB1c2godGhpcy5jb21wb3NhYmxlc1tjb21wb3NhYmxlLm5hbWVdLmxvYWRDb21wb3NhYmxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzLnB1c2goY29tcG9zYWJsZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvL25vdyB3YWl0IGZvciBldmVyeXRoaW5nIHRvIGxvYWRcbiAgICBQcm9taXNlLmFsbChuZWVkc0xvYWRpbmcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdSQVcgUGlwbGluZSAvIFVzZXIgSW5wdXQ9JywgY29tcG9zYWJsZSk7XG4gICAgICAgIC8vbGV0J3MgY2hlY2ssIGhvdyBtYW55IG1vZHVsZXMgYXJlIHVzZWQgaW4gdG90YWwgdG8gaGF2ZSBhIHJvdWdoIGVzdGltYXRlIGZvciBwcm9ncmVzcyB0cmFja2luZ1xuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2R1bGVDb3VudCArPSBjb3VudE1vZHVsZXMoc3dldmEuQ29tcG9zYWJsZUxvYWRlci5nZXQobmFtZXNbaV0pKTtcblxuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9kdWxlc1RvdGFsID0gbW9kdWxlQ291bnQ7XG4gICAgICAgIHNlbGYubW9kdWxlc0RvbmUgPSAwO1xuXG4gICAgICAgIC8vY29tcG9zYWJsZXMgc2hvdWxkIG5vdyBjb250YWluIGV2ZXJ5dGhpbmdcbiAgICAgICAgc2VsZi5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FsbCBsb2FkZWQnKTtcbiAgICAgICAgLy9pZiB3ZSB3YW50IHRvIGV4ZWN1dGUsIGJlZm9yZSBzZXR1cCBpcyByZWFkeSwgaXQgaXMgZGVsYXllZCBhbmQgY29udGludWVkIGZyb20gaGVyZVxuICAgICAgICBpZiAoc2VsZi53YW50c1RvRXhlY3V0ZSkge1xuICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5leGVjdXRlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN3ZXZhLkVycm9yTWFuYWdlci5lcnJvcihcbiAgICAgICAgICAgICAgICBuZXcgRXhlY3V0aW9uRXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGFsbCBtb2R1bGVzOiAnICsgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmFtZSwgZXJyb3IpKTtcbiAgICAgICAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCBwcm9ncmVzcyBzdGF0ZSBhbmQgY2FsbHMgdGhlIG9wdGlvbmFsbHkgcmVnaXN0ZXJlZCBwcm9ncmVzc0NhbGxiYWNrLlxuICogSXQgY291bnRzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBtb2R1bGVzIHRoYXQgaGF2ZSBmaW5pc2hlZCBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIC0gVGhlIGFsaWFzIG9mIHRoZSBtb2R1bGUsIHVuZGVyIHdoaWNoIGl0IGlzIGtub3duIHRvIHRoZSBwYXJlbnQgY29tcG9zaXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtb2R1bGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IHVuZGVyIHdoaWNoIHRoZSBtb2R1bGUgaXMgZXhlY3V0ZWQgKGl0cyBwYXJlbnRzKS5cbiAqL1xuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUucHJvZ3Jlc3NVcGRhdGUgPSBmdW5jdGlvbiAoYWxpYXMsIG5hbWUsIGNvbnRleHQscmVzdWx0KSB7XG4gICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEZpbmlzaGVkIGV4ZWN1dGluZyAnLGFsaWFzKTtcbiAgICBpZiAocmVzdWx0PT09J29mZmxvYWRpbmcnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT0ZGTE9BRElORyBmbGFnIGNhdGNoZWQgaW4gRXhlYyBtYW5hZ2VyICEnKTtcblxuICAgICAgICAgICAgLy9wcmVwYXJlIHBpcGVsaW5lIHRvIGJlIGNvbXBhdGlibGUgZm9yIG9mZmxvYWRpbmdcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnRlcm1lZGlhdGVQaXBlbGluZS5jb21wb3NhYmxlc1trZXldLm1hbmFnZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2FibGVzTm9kZSA9IGludGVybWVkaWF0ZVBpcGVsaW5lLmNvbXBvc2FibGVzW2tleV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBjb21wb3NhYmxlc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvc2FibGVzTm9kZVtwcm9wXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbXBvc2FibGVzTm9kZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlUGlwZWxpbmUgPUpTT04uc3RyaW5naWZ5KGludGVybWVkaWF0ZVBpcGVsaW5lKTtcblxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzPSBKU09OLnN0cmluZ2lmeShpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHMpO1xuICAgICAgICAgICAgbGV0IG1lcmdlZFBpcCA9e2ludGVybWVkaWF0ZVBpcGVsaW5lOmludGVybWVkaWF0ZVBpcGVsaW5lLGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0czppbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHN9O1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdvZmZsb2FkaW5nIHRoZSBtZXJnZWQgUGlwZWxpbmUuLi4nKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobWVyZ2VkUGlwKTtcblxuICAgICAgICAgICAgYnJvYWRjYXN0VG9EaXNjb3ZlcnlOZXR3b3JrKG1lcmdlZFBpcCk7IC8vT2ZmbG9hZCBtZXJnZWQgUGlwZWxpbmUgdG8gYmVzdCBQT1RcblxuXG4gICAgfVxuXG4gICAgLy9kZXRlY3RzIGFuIG9mZmxvYWRlZCBwaXBlbGluZSA6KVxuICAgIGlmIChPYmplY3Qua2V5cyhpbnRlcm1lZGlhdGVQaXBlbGluZSkubGVuZ3RoICE9PSAwKVxuICAgIHtcbiAgICAgICAgLy9jb25zaWRlciByZXN1bHQgYXMgbGlua2VkIG5vZGVzIGlucHV0XG4gICAgICAgIGxldCBub2RlTGlua3MgPSBpbnRlcm1lZGlhdGVQaXBlbGluZS5saW5rcztcbiAgICAgICAgbGV0IG1vZHVsZVJlc3VsdCA9IHJlc3VsdC5vdXQ7XG5cbiAgICAgICAgaWYgKG5vZGVMaW5rcy5oYXNPd25Qcm9wZXJ0eShhbGlhcykpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NoZWVzZWNha2UgIScpXG4gICAgICAgICAgICBsZXQgbGlua3NBcnJheSA9T2JqZWN0LmVudHJpZXMobm9kZUxpbmtzW2FsaWFzXS5vdXQpWzBdO1xuICAgICAgICAgICAgY29uc29sZS5sb2cobGlua3NBcnJheSk7XG5cbiAgICAgICAgICAgIGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0c1tsaW5rc0FycmF5WzBdXT17XG4gICAgICAgICAgICAgICAgXCJudW1cIjptb2R1bGVSZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbnRlcm1lZGlhdGVQaXBlbGluZVJlc3VsdHMpO1xuICAgICAgICAgICAgZGVsZXRlIGludGVybWVkaWF0ZVBpcGVsaW5lLmNvbXBvc2FibGVzW2FsaWFzXTtcbiAgICAgICAgfWVsc2Uge1xuXG4gICAgICAgICAgICAvL2NvbnNpZGVyIHJlc3VsdCBhcyBub2RlIG91dHB1dFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Nyb2lzc2FudCAhJylcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVBpcGVsaW5lUmVzdWx0c1thbGlhc109e1xuICAgICAgICAgICAgICAgIFwib3V0XCI6bW9kdWxlUmVzdWx0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVsZXRlIGludGVybWVkaWF0ZVBpcGVsaW5lLmNvbXBvc2FibGVzW2FsaWFzXTtcbiAgICAgICAgfVxuXG5cbiAgICBpZiAodGhpcy5wcm9ncmVzc0NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc0RvbmUrKztcblxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aGlzLm1vZHVsZXNEb25lIC8gK3RoaXMubW9kdWxlc1RvdGFsO1xuXG4gICAgICAgIC8vbWFrZSBhIHZhbHVlIDAtMTAwIGFuZCBjdXQgb2ZmIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFjaygocHJvZ3Jlc3MgKiAxMDApLnRvRml4ZWQoMCkpO1xuICAgICAgICAvL1RPRE8gc2VuZCB0aGlzIHRvIGZyb250ZW5kXG4gICAgfX1cbn1cblxuXG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGNvbXBvc2FibGVzIHRoYXQgd2VyZSBpbml0YWxpemVkIGR1cmluZyB7QGxpbmsgRXhlY3V0aW9uTWFuYWdlciNzZXR1cH0uXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHVzZSBmb3IgdGhlIGV4ZWN1dGlvbi4gSWYgbXVsdGlwbGUgY29tcG9zYWJsZXMgd2lsbCBiZSBleGVjdXRlZCxcbiAqIHRoZSBkYXRhIHByb3BlcnR5IG5hbWVzIG11c3QgY29ycmVzcG9uZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lcyBmb3IgYSBjb3JyZWN0IG1hcHBpbmcgb2YgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgb2JqZWN0IGZvciB0aGUgZXhlY3V0aW9uLiBJZiBtdWx0aXBsZSBjb21wb3NhYmxlcyB3aWxsIGJlIGV4ZWN1dGVkLFxuICogdGhlIGlucHV0IHByb3BlcnR5IG5hbWVzIG11c3QgY29ycmVzcG9uZCB0byB0aGUgY29tcG9zYWJsZSBuYW1lcyBmb3IgYSBjb3JyZWN0IG1hcHBpbmcgb2YgdGhlIGlucHV0LlxuICovXG5cblxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dCkge1xuICAgIC8qKlxuICAgICAqIEFuIEFycmF5IG9mIGV4ZWN1dGlvbnMsIHdoaWNoIGFyZSByZXByZXNlbnRpbmcgTW9kdWxlcyAobm9kZXMpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB2YXIgZXhlY3V0aW9ucyA9IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8qXG4gICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vIEV4ZWMgTWFuYWdlciBpbnB1dHMgLy8vLy8vLy8vLy8vLy9cIik7XG4gICAgY29uc29sZS5sb2coXCJkYXRhXCIpO1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIGNvbnNvbGUubG9nKFwiaW5wdXRcIik7XG4gICAgY29uc29sZS5sb2coaW5wdXQpO1xuICAgIGNvbnNvbGUubG9nKCdzZWxmJyk7XG4gICAgY29uc29sZS5sb2coc2VsZik7XG4gICAgY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSBQaXBlbGluZScpO1xuICAgIGNvbnNvbGUubG9nKGludGVybWVkaWF0ZVBpcGVsaW5lKTtcbiAgICBjb25zb2xlLmxvZyhcIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAqL1xuICAgIGNvbnNvbGUubG9nKCdiZWdpbiB0aGUgZXhlY3V0aW9uJyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy9jbG9zdXJlIGZ1bmN0aW9uXG4gICAgICAgIC8vY29tcG9zYWJsZXMgaXMgdGhlIHBpcGVsaW5lXG4gICAgICAgIC8vZXhlY3V0aW9ucyBpcyB0aGUgbGlzdCBvZiBwcm9taXNlcyBNb2R1bGUgdG8gYmUgZXhlY3V0ZWRcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoY29tcG9zYWJsZXMsIGV4ZWN1dGlvbnMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLyBmdW5jIGlucHV0cyAvLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb21wb3NhYmxlcz0gJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb21wb3NhYmxlcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXhlY3V0aW9ucz0gJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleGVjdXRpb25zKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb25seU9uZUNvbXBvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBvbmx5IG9uZSBjb21wb3NhYmxlIHdpbGwgYmUgZXhlY3V0ZWQsIGJlY2F1c2UgdGhlbiB5b3UgZG9uJ3QgZ28gaW50byB0aGUgbG9vcC5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoY29tcG9zYWJsZXMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvbmx5T25lQ29tcG9zYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NhYmxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vIGlmIGNvbmRpdGlvbiAvLy8vLy8vLy8vLy8vL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb21wb3NhYmxlc1trZXldPSAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBvc2FibGVzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2lucHV0W2tleV0gJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbnB1dFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdrZXk9ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWxmLnByb2dyZXNzVXBkYXRlLmJpbmQoc2VsZik9ICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc2VsZi5wcm9ncmVzc1VwZGF0ZS5iaW5kKHNlbGYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmx5T25lQ29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXhlY3V0ZSBmdW5jdGlvbiBpcyBkZWZpbmVkIGluIG1vZHVsZS5qc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbnMucHVzaChjb21wb3NhYmxlc1trZXldLmV4ZWN1dGUoZGF0YSwgaW5wdXQsICcnLCBrZXksIHNlbGYucHJvZ3Jlc3NVcGRhdGUuYmluZChzZWxmKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCIgPT09PT09IE9ubHkgT25lIENvbXBvc2FibGUgPT09PSBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT09IE9GRkxPQURJTkcgPT09IE1PRFVMRSBFWEVDVVRJT04gSVMgSU5JVElBTElaRUQgIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbnMucHVzaChjb21wb3NhYmxlc1trZXldLmV4ZWN1dGUoZGF0YVtrZXldLCBpbnB1dFtrZXldIHx8IHt9LCAnJywga2V5LCBzZWxmLnByb2dyZXNzVXBkYXRlLmJpbmQoc2VsZikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiID09PT09PSBNb3JlIHRoYW4gMSBjb21wb3NhYmxlID09PT0gXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBsb29wIHRvIG1vbml0b3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgcGlwZWxpbmUgYW5kIHVwZGF0ZSB0aGUgb2ZmbG9hZGluZyBwaXBlbGluZVxuXG4gICAgICAgICAgICAgICAgLy90b2RvOiBpbXBsZW1lbnQgYSBsb29wIHRoYXQgdXBkYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIHBpcGVsaW5lIGVhY2ggdGltZSBhIG1vZHVsZSBpcyBleGVjdXRlZFxuICAgICAgICAgICAgICAgIC8vICggcHJvbWlzZSBpcyBmdWxsZmlsbGVkKSBhbmQgc3RvcHMgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgcGlwZWxpbmUgaWYgb25lIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAvL21vbml0b3JQcm9taXNlcyhleGVjdXRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8vIEVMU0UgTk8gT0ZGTE9BRElORyAuLi5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFsbCB0aGUgZXhlY3V0aW9uIFByb21pc2VzIGhhdmUgcmVzb2x2ZWQuLi5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChleGVjdXRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhbGwgcHJvbWlzZXMgcmVzb2x2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlPbmVDb21wb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmx5T25lQ29tcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dldmEuRXJyb3JNYW5hZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEV4ZWN1dGlvbkVycm9yKCdTb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZDogJyArIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lLCByZXN1bHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZWxmLmlzUmVhZHkpIHtcbiAgICAgICAgICAgIGZ1bmMoc2VsZi5jb21wb3NhYmxlcywgZXhlY3V0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53YW50c1RvRXhlY3V0ZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmV4ZWN1dGVDYWxsYmFjayA9IGZ1bmMoc2VsZi5jb21wb3NhYmxlcywgZXhlY3V0aW9ucywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy9hbGlhc1xuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUucnVuID0gRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUuZXhlY3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uTWFuYWdlclxuXG5cbi8qXG5cbi8vLy8vLy8vLy8vLy8vICBFWFBFUlQgTU9ERSAgLy8vLy8vLy8vLy8vLy9cblxuLy8gaW5wdXRzIGFyZSBleHRyYWN0ZWQgZnJvbSBkZXZpY2VcbkV4ZWN1dGlvbk1hbmFnZXIucHJvdG90eXBlLmRldmljZU1vbml0b3JpbmdJbmRleCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICBhc3luYyBmdW5jdGlvbiBkZXZpY2VNb25pdG9yaW5nSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvL3RoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICAgICAgbGV0IG1ldHJpY3MgPSBbXTtcblxuICAgICAgICAgICAgLy9IYXJkd2FyZSBtZXRyaWNzIGluIExpbnV4IGVudmlyb25tZW50czpcbiAgICAgICAgICAgIGxldCBjcHUgPSBhd2FpdCBjdXJyZW50Q1BVdXNhZ2UoKVxuICAgICAgICAgICAgbGV0IG1lbSA9IGF3YWl0IGN1cnJlbnRNZW1vcnl1c2FnZSgpXG4gICAgICAgICAgICBsZXQgc3RvcmFnZSA9IGF3YWl0IGF2YWlsYWJsZVN0b3JhZ2UoKVxuICAgICAgICAgICAgbGV0IGJhdHRlcnkgPSBhd2FpdCBhdmFpbGFibGVCYXR0ZXJ5KClcbiAgICAgICAgICAgIGxldCBjaGFyZ2luZyA9IGF3YWl0IGlzQ2hhcmdpbmcoKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNwdVwiLGNwdSxcIlxcbiBtZW1cIiwgbWVtLCBcIlxcbiBzdG9yYWdlXCIsIHN0b3JhZ2UsIFwiXFxuIGJhdHRlcnlcIiwgYmF0dGVyeSwgXCJcXG4gY2hhcmdpbmdcIiwgY2hhcmdpbmcpO1xuICAgICAgICAgICAgcmVzb2x2ZShtZXRyaWNzLnB1c2goY3B1LCBtZW0sIHN0b3JhZ2UsYmF0dGVyeSxjaGFyZ2luZykpO1xuXG5cbiAgICAgICAgICAgIC8vZm9yIHdpbmRvd3MgdGVzdGluZyBwdXJwb3Nlc1xuICAgICAgICAgICAgbGV0IGNwdSA9IDYwOyAvL2F2ZyBmcmVlIGNwdSB2YWx1ZSBmb3IgMyBtZWFzdXJlbWVudHMgaW4gJVxuICAgICAgICAgICAgbGV0IG1lbSA9IDEwMDAwMDsgLy8gYXZpbGFibGUgZnJlZSBtZW0gdmFsdWUgaW4gYnl0ZXNcbiAgICAgICAgICAgIGxldCBzdG9yYWdlID0gMjAwMDAwMDsgLy8gYXZpbGFibGUgZnJlZSBzdG9yYWdlIHZhbHVlIGluIGJ5dGVzXG4gICAgICAgICAgICBsZXQgYmF0dGVyeSA9IDgwO1xuICAgICAgICAgICAgbGV0IGNoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjcHVcIixjcHUsXCJcXG4gbWVtXCIsIG1lbSwgXCJcXG4gc3RvcmFnZVwiLCBzdG9yYWdlLCBcIlxcbiBiYXR0ZXJ5XCIsIGJhdHRlcnksIFwiXFxuIGNoYXJnaW5nXCIsIGNoYXJnaW5nKTtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChjcHUsIG1lbSwgc3RvcmFnZSwgYmF0dGVyeSwgY2hhcmdpbmcpXG4gICAgICAgICAgICByZXNvbHZlKG1ldHJpY3MpO1xuXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IGRldmljZU1vbml0b3JpbmdJbmRleCgpO1xuXG59XG4qL1xuXG4vKlxuLy9pbnB1dHMgYXJlIGV4dHJhY3RlZCBmcm9tIGZyb250ZW5kIC0+IHVzZXIgaW5wdXQgaW4gYmFja2VuZFxuRXhlY3V0aW9uTWFuYWdlci5wcm90b3R5cGUub2ZmbG9hZGluZ0RlY2lzaW9uID0gYXN5bmMgZnVuY3Rpb24gKG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KSB7XG4gICAgYXN5bmMgZnVuY3Rpb24gb2ZmbG9hZGluZ0RlY2lzc2lvbih3cG4sIG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkbWkgPSBhd2FpdCBFeGVjdXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZXZpY2VNb25pdG9yaW5nSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCBkZWNpc2lvbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy9bMF06Y3B1XG4gICAgICAgICAgICAvL1sxXTogbWVtb3J5XG4gICAgICAgICAgICAvL1syXTogc3RvcmFnZVxuICAgICAgICAgICAgLy9kbWlbM106IGJhdHRlcnlcbiAgICAgICAgICAgIC8vZG1pWzRdOiBpcyBjaGFyZ2luZ1xuICAgICAgICAgICAgaWYgKG9kX0NQVSA9PT0gMCB8fCBvZF9tZW0gPT09IDAgfHwgb2RfYmF0dGVyeSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod3BuWzBdID4gKGRtaVswXSAqIG9kX0NQVSkgfHwgd3BuWzFdID4gKGRtaVsxXSAqIG9kX21lbSkgfHwgZG1pWzNdIDwgb2RfYmF0dGVyeSkge1xuICAgICAgICAgICAgICAgIGRlY2lzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGVjaXNpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgb2ZmbG9hZGluZ0RlY2lzc2lvbihbc3dldmEuQ29tcG9zYWJsZUxvYWRlclsndG90YWxDUFVSZXEnXSwgc3dldmEuQ29tcG9zYWJsZUxvYWRlclsndG90YWxNZW1SZXEnXV0sIG9kX0NQVSwgb2RfbWVtLCBvZF9iYXR0ZXJ5KTtcblxufVxuKi9cblxuLy8vLy8vLy8vLy8vLy8gIEVORCAgRVhQRVJUIE1PREUgIC8vLy8vLy8vLy8vLy8vXG4iLCIvKipcbiAqIENyZWF0ZXMgaW5zdGFuY2Ugb2Ygc3VwcG9ydCBsaWJyYXJ5XG4gKlxuICogQWxsb3cgbG9hZGluZyBmdW5jdGlvbmFsaXR5IHNlcGFyYXRlbHksIGRlcGVuZGluZyBvbiB3aGF0IGlzIG5lZWRlZCBmb3IgYSBzcGVjaWZpYyBydW5uZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBTdXBwb3J0TGlicmFyeSgpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IHt9O1xufVxuXG5TdXBwb3J0TGlicmFyeS5wcm90b3R5cGUubG9hZFRlc3RTeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMudGVzdCA9IHtcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljOiB7XG4gICAgICAgICAgICB0eXBlc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyU2lnOiBcInVybDogc3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmV0dXJuU2lnOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmM6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwgKyB1cmw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5TdXBwb3J0TGlicmFyeS5wcm90b3R5cGUubG9hZExvZ2dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZnVuY3Rpb25zLmxvZyA9IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTG9nIHRoZSB0ZXh0IHRvIHRoZSBicm93c2VyIGNvbnNvbGVcIixcbiAgICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgICBsYW5ndWFnZVNwZWNpZmljOiB7XG4gICAgICAgICAgICB0eXBlc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyU2lnOiBcInRleHQ6IHN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJ2b2lkXCJcbiAgICAgICAgICAgIH19LFxuICAgICAgICBmdW5jOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICAgIH19O1xufVxuU3VwcG9ydExpYnJhcnkucHJvdG90eXBlLmxvYWRIVFRQID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMuaHR0cFJlcXVlc3QgPSB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNlbmQgYSBIVFRQKFMpIHJlcXVlc3QgdXNpbmcgdGhlIGZldGNoIGFwaS4gUmV0dXJucyBzdGF0dXM9LTEgb24gdGltZW91dCFcIixcbiAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWM6e1xuICAgICAgICAgICAgdHlwZXNjcmlwdDoge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlclNpZzogXCJ1cmw6IHN0cmluZywgaGVhZGVyczpzdHJpbmcgPSBudWxsIHwgbnVsbCwgbWV0aG9kOnN0cmluZyA9ICdHRVQnIHwgbnVsbCwgYm9keTpzdHJpbmcgPSBudWxsIHwgbnVsbCwgY2FjaGU6c3RyaW5nID0gJ25vLXN0b3JlJyB8IG51bGwsIHRpbWVvdXQ6aTMyID0gNTAwMFwiLFxuICAgICAgICAgICAgICAgIHJldHVyblNpZzogXCJ0ZXh0OiBzdHJpbmcsIHN0YXR1czogaW50XCJcbiAgICAgICAgfX0sXG4gICAgICAgIGZ1bmM6IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGhlYWRlcnMsIG1ldGhvZCwgYm9keSwgY2FjaGUsIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGxldCBpbml0ID0ge307XG5cbiAgICAgICAgICAgIGlmKGhlYWRlcnMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpbml0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgaWYobWV0aG9kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICBpZihib2R5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgIGlmKGNhY2hlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5pdC5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGluaXQuY2FjaGUgPSBcIm5vLXN0b3JlXCI7XG5cbiAgICAgICAgICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGluaXQuc2lnbmFsID0gY29udHJvbGxlci5zaWduYWw7XG5cbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIGluaXQpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUkVTUE9OU0U6XCIpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGV4dCwgcmVzcG9uc2Uuc3RhdHVzXTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiVElNRU9VVFwiLCAtMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH19O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1cHBvcnRMaWJyYXJ5OyIsImxldCBvZmZsb2FkaW5nVGFyZ2V0ID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvb2ZmbG9hZGluZ1RhcmdldC5qc1wiKTtcblxuZnVuY3Rpb24gY3JlYXRlUGVlcihpZCwgY2FsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gICAgbGV0IHBlZXIgPSBuZXcgUGVlcihpZCwge1xuICAgICAgICBob3N0OiBcIm1pbGtpLXBzeS5kYmlzLnJ3dGgtYWFjaGVuLmRlXCIsIC8vbG9jYWxob3N0XG4gICAgICAgIHBvcnQ6IDQ0MywgLy85MDAxXG4gICAgICAgIHBhdGg6IFwiL29mZmxvYWRpbmdOZXR3b3JrXCIsXG4gICAgfSk7XG4gICAgcGVlci5vbignb3BlbicsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTXkgcGVlciBJRCBpcyA9ICcgKyBJRCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcGVlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH0pO1xuICAgIHBlZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGVlciBJRCAnICsgSUQrJyBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwZWVyO1xufVxuXG5mdW5jdGlvbiBkYXRhUHJvY2Vzc2luZ0RldmljZShwaXBlbGluZSkge1xuICAgIGxldCBpZEFuZERNSXBhaXJzID0ge307XG4gICAgbGV0IGNvbm5lY3Rpb25zID0ge307XG4gICAgbGV0IGFsbFJlY2VpdmVkID0gZmFsc2U7XG4gICAgbGV0IHBlZXIgPSBjcmVhdGVQZWVyKCdzb3VyY2UnLCAoKSA9PiB7XG5cbiAgICAgICAgcGVlci5vbignY29ubmVjdGlvbicsIChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAvL3RvIGNoZWNrIHdoaWNoIHBlZXIgc2VudCBhIG1zZyBhbmQgd2hpY2ggZGlkbid0IFlFVCFcbiAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24ucGVlcl09ZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgY29ubmVjdGVkIHRvIHBlZXIgPSAnK2Nvbm5lY3Rpb24ucGVlcik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjb25uZWN0aW9ucyk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhW2RhdGEubGVuZ3RoLTFdPT09J2RtaScpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVjZWl2ZWQgRE1JIGZyb206ICcsY29ubmVjdGlvbi5wZWVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlIHRoZSBmbGFnXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24ucGVlcl09dHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29ubmVjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZEFuZERNSXBhaXJzW2Nvbm5lY3Rpb24ucGVlcl09IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsUmVjZWl2ZWQ9IE9iamVjdC52YWx1ZXMoY29ubmVjdGlvbnMpLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWxsUmVjZWl2ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vdG9kbzogaGF2ZSBhIHRpbWVvdXQgZm9yIHJvYnVzdG5lc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbFJlY2VpdmVkKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NNc2dzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkVycm9yIGVuY291bnRlcmVkIHdoaWxlIHJlY2VpdmluZyB0aGUgZG1pXCIpO1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc01zZ3MgKCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZW50ZXJlZCBwcm9jZXNzTXNncyBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIGxldCBwb3RJZCA9IG9mZmxvYWRpbmdUYXJnZXQoaWRBbmRETUlwYWlycyk7IC8vVE9ETzogY2hhbmdlIHByb2Nlc3NMaXN0IHRvIGNob29zZUJlc3RQT1RcbiAgICAgICAgICAgIGlmIChwb3RJZCA9PT0gbnVsbCApe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnb2ZmbG9hZGluZ091dHB1dCQgVGhlcmUgaXMgbm8gc3VpdGFibGUgb2ZmbG9hZGluZyBwZWVyIGF2YWlsYWJsZSAhIE9mZmxvYWQgdG8gdGhlIGNsb3VkLi4uJyk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBjaG9zZW4gcG90SUQgZm9yIG9mZmxvYWRpbmcgPSAnICsgcG90SWQpO1xuXG4gICAgICAgICAgICBsZXQgY29ubiA9IHBlZXIuY29ubmVjdChwb3RJZCk7XG4gICAgICAgICAgICBjb25uLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBjb25uZWN0aW9uIG9wZW5lZCB3aXRoIGNob3NlbiBQT1QgIScpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTRU5UIFBJUEVMSU5FID0gJyxwaXBlbGluZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1R5cGUgb2YgUElQRUxJTkUgPSAnLCB0eXBlb2YgcGlwZWxpbmUpO1xuICAgICAgICAgICAgICAgIGNvbm4uc2VuZChwaXBlbGluZSk7IC8vc2VuZCBwaXBlbGluZSBoZXJlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29ubi5vbignZGF0YScsIChkYXRhKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGlwZWxpbmUgcmVzdWx0OiAnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTsgLy9yZWNlaXZlIHBpcGVsaW5lIHJlc3VsdHMgaGVyZVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIE9mZmxvYWRlZCBSZXN1bHQgPScpO1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICBtc2cgPSAnb2ZmbG9hZGluZ091dHB1dCQgJyttc2c7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICBwZWVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG59XG5tb2R1bGUuZXhwb3J0cyA9ZGF0YVByb2Nlc3NpbmdEZXZpY2UiLCJcbmxldCBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzID0gcmVxdWlyZShcIi4uL29mZmxvYWRpbmcvYXZhaWxhYmxlT2ZmbG9hZGluZ1Jlc291cmNlc1wiKTtcblxuZnVuY3Rpb24gY3JlYXRlUGVlcihpZCwgY2FsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gICAgbGV0IHBlZXIgPSBuZXcgUGVlcihpZCwge1xuICAgICAgICBob3N0OiBcIm1pbGtpLXBzeS5kYmlzLnJ3dGgtYWFjaGVuLmRlXCIsIC8vbG9jYWxob3N0XG4gICAgICAgIHBvcnQ6IDQ0MywgLy85MDAxXG4gICAgICAgIHBhdGg6IFwiL29mZmxvYWRpbmdOZXR3b3JrXCIsXG4gICAgfSk7XG4gICAgcGVlci5vbignb3BlbicsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTXkgcGVlciBJRCBpcyA9ICcgKyBJRCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcGVlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH0pO1xuICAgIHBlZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIGZ1bmN0aW9uIChJRCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGVlciBJRCAnICsgSUQrJyBkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwZWVyO1xufVxuXG5mdW5jdGlvbiBwb3RlbnRpYWxPZmZsb2FkaW5nVGFyZ2V0KCkge1xuICAgIGxldCBwZWVyID0gY3JlYXRlUGVlcignJywgKCkgPT4ge1xuICAgICAgICBwZWVyLm9uKCdjb25uZWN0aW9uJywgKGNvKT0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEkgYW0gY2hvc2VuIGJ5IFNvdXJjZSBQZWVyICEnKTtcbiAgICAgICAgICAgIGNvLm9uKCdkYXRhJywgKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBQaXBlbGluZSBhbmQgc2VuZCByZXN1bHRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0YSByZWNlaXZlZCBmcm9tIFNvdXJjZSA9ICcsZGF0YSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBpcyB0aGVyZSBhIHdheSB0byBjaGVjayBpZiByZWNlaXZlZCBkYXRlIGlzIHJlYWxseSBhIHBpcGVsaW5lID8geWVzXG4gICAgICAgICAgICAgICAgLy9UT0RPOiB1c2VyIGlucHV0ID9cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgUHJvY2Vzc2luZyBvZmZsb2FkZWQgcGlwZWxpbmUgLi4uJyk7XG4gICAgICAgICAgICAgICAgLy8gc2V0dXAgYW5kIHByb2Nlc3MgdGhlIHBpcGVsaW5lXG4gICAgICAgICAgICAgICAgcHJvY2Vzc1BpcGVsaW5lKGRhdGEpLnRoZW4oKHJlc3VsdCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIHBpcGVsaW5lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnT0ZGTE9BRElORyBSRVNVTFQgPSAnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIEZpbmlzaGVkIHByb2Nlc3NpbmcgdGhlIG9mZmxvYWRlZCBwaXBlbGluZScpXG4gICAgICAgICAgICAgICAgICAgIGNvLnNlbmQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIFJlc3VsdCBzZW50IHRvIG9mZmxvYWRpbmcgc291cmNlIHBlZXInKVxuXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gcGVlci5jb25uZWN0KCdzb3VyY2UnKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBjb25uZWN0ZWQgdG8gcGVlciA9ICcrY29ubmVjdGlvbi5wZWVyKTtcblxuICAgICAgICAgICAgLy9UT0RPOiBnZXQgaW5wdXQgZnJvbSBleGVjdXRpb24gbWFuYWdlciBHRVQgZnJvbnRlbmQuXG4gICAgICAgICAgICAvL2lucHV0IG9mZmxvYWRpbmcgcmVzb3VyY2VzIGxpbWl0cyBNVVNUIGJlIGdsb2JhbCB2YWx1ZSBmcm9tIHVzZXIgaW5wdXQgKGZyb250ZW5kKVxuICAgICAgICAgICAgbGV0IG9yTGlzdD0gc3dldmEuRXhlY3V0aW9uTWFuYWdlci5nZXRPUkxpc3QoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvckxpc3QgR0VUIGluIHBvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQgPSAnLG9yTGlzdCk7XG4gICAgICAgICAgICBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzKG9yTGlzdCkudGhlbihyZXN1bHQgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdCBpcyA9JyxyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vcHVzaCBzdHJpbmcgJ2RtaScgYXMgbGFzdCBlbnRyeSBpbiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2RtaScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvL3NlbmQgZG1pIGFzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChyZXN1bHQpO1xuXG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRCeXRlcyhieXRlcywgZGVjaW1hbHMgPSAyKSB7XG4gICAgaWYgKGJ5dGVzID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnMCBCeXRlcyc7XG4gICAgfVxuXG4gICAgY29uc3QgayA9IDEwMjQ7XG4gICAgY29uc3QgZG0gPSBkZWNpbWFscyA8IDAgPyAwIDogZGVjaW1hbHM7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ0J5dGVzJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ107XG5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoZG0pKTtcblxuICAgIHJldHVybiBgJHtzaXplfSAke3NpemVzW2ldfWA7XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lKG1pbGxpc2Vjb25kcykge1xuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApICUgNjA7XG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gKDEwMDAgKiA2MCkpICUgNjA7XG5cbiAgICBjb25zdCBmb3JtYXR0ZWRUaW1lID0gW107XG5cbiAgICBpZiAobWludXRlcyA+IDApIHtcbiAgICAgICAgZm9ybWF0dGVkVGltZS5wdXNoKG1pbnV0ZXMgKyAobWludXRlcyA9PT0gMSA/ICcgbWludXRlJyA6ICcgbWludXRlcycpKTtcbiAgICB9XG4gICAgaWYgKHNlY29uZHMgPjApe1xuICAgICAgICBmb3JtYXR0ZWRUaW1lLnB1c2goc2Vjb25kcyArIChzZWNvbmRzID09PSAxID8gJyBzZWNvbmQnIDogJyBzZWNvbmRzJykpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRUaW1lLmpvaW4oJywgJyk7XG59XG5cbi8vVE9ETzogcHJvY2VzcyBwaXBlbGluZSBpbiBleGVcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NQaXBlbGluZShyZWNlaXZlZFBpcGVsaW5lKXtcbiAgICAvL1RPRE86IGV4dHJhY3QgaW50ZXJtZWRpYXRlIHJlc3VsdCBmcm9tIHBpcGVsaW5lIHdpdGggYSBuZXcga2V5IGluIHRoZSBvYmplY3RcblxuICAgIGNvbnNvbGUubG9nKCdlbnRlcmVkIHByb2Nlc3NQaXBlbGluZSBpcyBQT1QgLi4uJyk7XG4gICAgY29uc29sZS5sb2cocmVjZWl2ZWRQaXBlbGluZSk7XG5cbiAgICBsZXQge2ludGVybWVkaWF0ZVBpcGVsaW5lOm9iMSwgaW50ZXJtZWRpYXRlUGlwZWxpbmVSZXN1bHRzOm9iMn0gPSByZWNlaXZlZFBpcGVsaW5lO1xuICAgIGNvbnNvbGUubG9nKCdwaXBlbGluZSA9ICcsb2IxKTtcbiAgICBjb25zb2xlLmxvZygncGlwZWxpbmUgaW5wdXRzID0gJyxvYjIpO1xuICAgIGxldCBwaXBlbGluZSA9IEpTT04ucGFyc2Uob2IxKTtcbiAgICBsZXQgcGlwZWxpbmVJbnB1dHMgPSBKU09OLnBhcnNlKG9iMik7XG4gICAgY29uc29sZS5sb2coJ3BpcGVsaW5lID0gJywgcGlwZWxpbmUpO1xuICAgIGNvbnNvbGUubG9nKCdwaXBlbGluZSBpbnB1dHMgPSAnLCBwaXBlbGluZUlucHV0cyk7XG5cblxuICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbWFuYWdlciA9IG5ldyBzd2V2YS5FeGVjdXRpb25NYW5hZ2VyKCk7XG4gICAgICAgICAgICBtYW5hZ2VyLnNldHVwKHBpcGVsaW5lKTtcblxuICAgICAgICAgICAgbGV0IHN0YXJ0TWVtRXhlY3V0ZSA9IHBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZTtcbiAgICAgICAgICAgIGxldCBzdGFydFRpbWVFeGVjdXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBvZmZsb2FkZWRSZXN1bHQgPSBhd2FpdCBtYW5hZ2VyLmV4ZWN1dGUocGlwZWxpbmVJbnB1dHMsIHt9KTtcbiAgICAgICAgICAgIGxldCBlbmRUaW1lRXhlY3V0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBsZXQgZW5kTWVtRXhlY3V0ZSA9IHBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPVVRQVVQgb2ZmbG9hZGVkIG1zZyA9ICcsb2ZmbG9hZGVkUmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBPZmZsb2FkZWQgdGFzayBFeGVjdXRpb24gdGltZTogJyxmb3JtYXRUaW1lKGVuZFRpbWVFeGVjdXRlLXN0YXJ0VGltZUV4ZWN1dGUpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBPZmZsb2FkZWQgdGFzayBFeGVjdXRpb24gTWVtb3J5OiAnLGZvcm1hdEJ5dGVzKGVuZE1lbUV4ZWN1dGUtc3RhcnRNZW1FeGVjdXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gb2ZmbG9hZGVkUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZXhlY3V0aW5nIHRoZSBvZmZsb2FkZWQgcGlwZWxpbmUgPSAnLGUsJ1xcblBsZWFzZSB0cnkgYWdhaW4nKTtcbiAgICAgICAgICAgIHJldHVybiAnRXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZXhlY3V0aW5nIHRoZSBvZmZsb2FkZWQgcGlwZWxpbmUuIFBsZWFzZSB0cnkgYWdhaW4nO1xuICAgIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBvdGVudGlhbE9mZmxvYWRpbmdUYXJnZXQiLCIvL1VTRVIgaW5wdXQgb3JMaXN0OlxuXG4vLyBmb3IgV2ViIGVudmlyb25tZW50OlxuLy8gb3JMaXN0ID0gW21lbSUsIGJhdHRlcnklLCBpc0NoYXJnaW5nIChiaW5hcnkpXVxuXG4vL2ZvciBOb2RlLkpTIGVudmlyb25tZW50OlxuLy8gb3JMaXN0ID0gW2NwdSUsIG1lbSUsIGJhdHRlcnklLCBpc0NoYXJnaW5nIChiaW5hcnkpXVxuXG5hc3luYyBmdW5jdGlvbiBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzKG9yTGlzdCkge1xuICAgIGlmIChvckxpc3RbMF0gPT09IDAgfHwgb3JMaXN0WzFdID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwwLDAsZmFsc2VdO1xuICAgIH1cblxuICAgIGxldCBjcHVMb2FkID0gMDtcbiAgICBsZXQgbWVtVXNhZ2UgPSAwO1xuICAgIGxldCBiYXR0ZXJ5UGVyY2VudCA9IDA7XG4gICAgbGV0IGJhdHRlcnlJc0NoYXJnaW5nID0gZmFsc2U7XG5cbiAgICBsZXQgbGlzdE9mTWV0cmljcyA9W107XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgLy9Ccm93c2VyIGVudmlyb25tZW50XG4gICAgICAgIG1lbVVzYWdlID0gKHBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIHBlcmZvcm1hbmNlLm1lbW9yeS5qc0hlYXBTaXplTGltaXQpICogMTAwO1xuICAgICAgICBsZXQgYmF0dGVyeSA9IGF3YWl0IG5hdmlnYXRvci5nZXRCYXR0ZXJ5KCk7XG4gICAgICAgIGJhdHRlcnlQZXJjZW50ID0gYmF0dGVyeS5sZXZlbCAqIDEwMDtcbiAgICAgICAgYmF0dGVyeUlzQ2hhcmdpbmcgPSBiYXR0ZXJ5LmNoYXJnaW5nO1xuICAgICAgICBjb25zb2xlLmxvZygnbWVtVXNhZ2UgPSAnLG1lbVVzYWdlLCdiYXR0ZXJ5ID0gJyxiYXR0ZXJ5UGVyY2VudCwgJ2lzQ2hhcmdpbmcgPSAnLGJhdHRlcnlJc0NoYXJnaW5nKTtcblxuICAgIH1lbHNle1xuICAgICAgICAvL05vZGVKUyBlbnZpcm9ubWVudFxuICAgICAgICBsZXQgc2kgPSByZXF1aXJlKCdzeXN0ZW1pbmZvcm1hdGlvbicpO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsIChbXG4gICAgICAgICAgICBzaS5jdXJyZW50TG9hZCgpLFxuICAgICAgICAgICAgc2kubWVtKCksXG4gICAgICAgICAgICBzaS5iYXR0ZXJ5KClcbiAgICAgICAgXSkudGhlbigoW2NwdSwgbWVtLCBiYXR0ZXJ5XSkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lbVJTUyA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgICAgIG1lbVVzYWdlID0gIChtZW1SU1MucnNzIC8gbWVtLmF2YWlsYWJsZSkgKiAxMDA7XG4gICAgICAgICAgICBjcHVMb2FkID0gY3B1LmF2Z0xvYWQ7XG4gICAgICAgICAgICBiYXR0ZXJ5UGVyY2VudCA9IGJhdHRlcnkucGVyY2VudDtcbiAgICAgICAgICAgIGJhdHRlcnlJc0NoYXJnaW5nID0gYmF0dGVyeS5hY0Nvbm5lY3RlZDtcbiAgICAgICAgICAgIC8vY3VycmVudCBjcHUgbG9hZCBoaWdoZXIgdGhhbiB1c2VyIGxpbWl0IChvbmx5IGZvciBOb2RlLmpzIGVudmlyb25tZW50KVxuICAgICAgICAgICAgaWYgKGNwdUxvYWQgPiBvckxpc3RbMF0pe1xuICAgICAgICAgICAgICAgIHJldHVybiBbMCwwLDAsZmFsc2VdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjcHUgPSAnLGNwdUxvYWQsICdtZW1Vc2FnZSA9ICcsbWVtVXNhZ2UsJ2JhdHRlcnkgPSAnLGJhdHRlcnlQZXJjZW50LCAnaXNDaGFyZ2luZyA9ICcsYmF0dGVyeUlzQ2hhcmdpbmcpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQgZXh0cmFjdGluZyBtZXRyaWNzIGluIHRoZSBOb2RlSlMgZW52aXJvbm1lbnQuIEVSUk9SID0gJyArIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICAgbWVtVXNhZ2UgPiBvckxpc3RbMF0gfHwgLy8gbWVtIHVzYWdlIGlzIGhpZ2hlciB0aGFuIGxpbWl0XG4gICAgICAgIGJhdHRlcnlQZXJjZW50IDwgb3JMaXN0WzFdIHx8IC8vIGJhdHRlcnkgaXMgbG93ZXIgdGhhbiBtaW5pbXVtIHNldCBieSB1c2VyXG4gICAgICAgIGJhdHRlcnlJc0NoYXJnaW5nICE9PSBvckxpc3RbMl1cbiAgICApXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgUGVlciBub3Qgc3Ryb25nIGVub3VnaCBmb3IgdGhlIG9mZmxvYWRlZCB0YXNrJylcbiAgICAgICAgcmV0dXJuIFswLDAsMCxmYWxzZV1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAvL091dHB1dCBtZXRyaWNzIGluIHBlcmNlbnQgJVxuICAgICAgICBsaXN0T2ZNZXRyaWNzLnB1c2goY3B1TG9hZCwoMTAwLW1lbVVzYWdlKSxiYXR0ZXJ5UGVyY2VudCxiYXR0ZXJ5SXNDaGFyZ2luZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBQZWVyIGlzIHN0cm9uZyBlbm91Z2ggdG8gcHJvY2VzcyB0aGUgb2ZmbG9hZGVkIHRhc2snKVxuICAgICAgICByZXR1cm4gbGlzdE9mTWV0cmljcztcblxuICAgIH1cblxufVxubW9kdWxlLmV4cG9ydHMgPSBhdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzXG5cbi8qXG4vLyBURVNUIGZ1bmN0aW9uIGZvciBOb2RlLmpzIGVudmlyb25tZW50XG5zZXRJbnRlcnZhbCgoKSA9PntcbmNvbnN0IHN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5hdmFpbGFibGVPZmZsb2FkaW5nUmVzb3VyY2VzKFswLDEwLDEwLHRydWVdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnRUaW1lKTtcbiAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgIGNvbnNvbGUubG9nKCdFbGFwc2VkIHRpbWU6ICcrKGVuZFRpbWVbMF0gKiAxMDAwICsgZW5kVGltZVsxXSAvIDEwMDAwMDApLnRvRml4ZWQoMikrICcgbXMnKTtcblxufSk7fSwzMDAwKTtcbiovXG5cbiIsIi8qXG4qXG5Vc2UgdGhpcyBmdW5jdGlvbiB0byBtb25pdG9yIGFueSBTV2VWQSBleGVjdXRpb24gYW5kIGRldGVybWluZSBuZWNlc3NpdHkgb2Ygb2ZmbG9hZGluZ1xuYmFzZWQgb24gQ1BVICwgTWVtb3J5IGFuZCBCYXR0ZXJ5IG1ldHJpY3MuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgaW4gYm90aFxuV2ViIGFuZCBOb2RlSlMgZW52aXJvbm1lbnRzICFcbiogVVNFUiBJbnB1dCBvZExpc3QgPSBbTGltaXRfY3B1ICUsIExpbWl0X21lbSAlLCBMaW1pdF9iYXR0ZXJ5ICVdXG4qL1xuXG5hc3luYyBmdW5jdGlvbiBvZmZsb2FkaW5nRGVjaXNpb24ob2RMaXN0KSB7XG4gICAgaWYgKG9kTGlzdFswXSA9PT0gMCB8fCBvZExpc3RbMV0gPT09IDAgfHwgb2RMaXN0WzJdID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgY3B1TG9hZCA9IDA7XG4gICAgbGV0IG1lbVVzYWdlID0gMDtcbiAgICBsZXQgYmF0dGVyeVBlcmNlbnQgPSAwO1xuICAgIGxldCBvZmZsb2FkaW5nID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgLy9Ccm93c2VyIGVudmlyb25tZW50XG4gICAgICAgIG1lbVVzYWdlID0gKHBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZSAvIHBlcmZvcm1hbmNlLm1lbW9yeS5qc0hlYXBTaXplTGltaXQpICogMTAwO1xuICAgICAgICBsZXQgYmF0dGVyeSA9IGF3YWl0IG5hdmlnYXRvci5nZXRCYXR0ZXJ5KCk7XG4gICAgICAgIGJhdHRlcnlQZXJjZW50ID0gYmF0dGVyeS5sZXZlbCAqIDEwMDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnTWVhc3VyZWQgbWVtID0gJyxtZW1Vc2FnZSwnYmF0dGVyeSA9ICcsYmF0dGVyeVBlcmNlbnQpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL05vZGVKUyBlbnZpcm9ubWVudFxuICAgICAgICBsZXQgc2kgPSByZXF1aXJlKCdzeXN0ZW1pbmZvcm1hdGlvbicpO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsIChbXG4gICAgICAgICAgICBzaS5jdXJyZW50TG9hZCgpLFxuICAgICAgICAgICAgc2kubWVtKCksXG4gICAgICAgICAgICBzaS5iYXR0ZXJ5KClcbiAgICAgICAgXSkudGhlbigoW2NwdSwgbWVtLCBiYXR0ZXJ5XSkgPT4ge1xuICAgICAgICAgICAgbGV0IG1lbVJTUyA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgICAgIG1lbVVzYWdlID0gKG1lbVJTUy5yc3MgLyBtZW0uYXZhaWxhYmxlKSAqIDEwMDtcbiAgICAgICAgICAgIGNwdUxvYWQgPSBjcHUuYXZnTG9hZDtcbiAgICAgICAgICAgIGJhdHRlcnlQZXJjZW50ID0gYmF0dGVyeS5wZXJjZW50O1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NwdSA9ICcsY3B1TG9hZCwgJ21lbSA9ICcsbWVtVXNhZ2UsJ2JhdHRlcnkgPSAnLGJhdHRlcnlQZXJjZW50KTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkIGV4dHJhY3RpbmcgbWV0cmljcyBpbiB0aGUgTm9kZUpTIGVudmlyb25tZW50LiBFUlJPUiA9ICcgKyBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgICAgICAgICBpZiAoY3B1TG9hZCA+IG9kTGlzdFswXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvZmZsb2FkaW5nT3V0cHV0JCBNb25pdG9yaW5nID0gQ1BVIGxpbWl0IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgb2ZmbG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lbVVzYWdlID4gb2RMaXN0WzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmdPdXRwdXQkIE1vbml0b3JpbmcgPSBNZW1vcnkgbGltaXQgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICBvZmZsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmF0dGVyeVBlcmNlbnQgPCBvZExpc3RbMl0pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgTW9uaXRvcmluZyA9IEJhdHRlcnkgbGltaXQgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICBvZmZsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgIHJldHVybiBvZmZsb2FkaW5nO1xufVxubW9kdWxlLmV4cG9ydHMgPSBvZmZsb2FkaW5nRGVjaXNpb25cblxuXG5cblxuLypcbi8vIFRFU1QgZnVuY3Rpb24gZm9yIE5vZGUuanMgZW52aXJvbm1lbnRcblxuLy9sZXQgdGltZSA9MDtcbmxldCBpPTA7XG5sZXQgb2RMaXN0ID1bMTAsMTAsOTBdO1xubGV0IHN0YXJ0VGltZSA9IG51bGw7XG5sZXQgZW5kVGltZSA9bnVsbDtcbmxldCBhdmdMaXN0PVtdIDtcblxuXG5zZXRJbnRlcnZhbCgoKT0+e1xuICAgICAgIHN0YXJ0VGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgb2ZmbG9hZGluZ0RlY2lzaW9uKG9kTGlzdCkudGhlbiAoKHJlc3VsdCk9PntcbiAgICAgICBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUoc3RhcnRUaW1lKTtcblxuICAgICAgIGNvbnNvbGUubG9nKCdNb25pdG9yaW5nIFJvdW5kICMnK2kpO1xuICAgICAgIGkrKztcbiAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgIGNvbnNvbGUubG9nKCdFbGFwc2VkIHRpbWU6ICcrKGVuZFRpbWVbMF0gKiAxMDAwICsgZW5kVGltZVsxXSAvIDEwMDAwMDApLnRvRml4ZWQoMikrICcgbXMnKTtcbiAgIH0pO1xuXG5cbn0sMzAwMCk7XG4qL1xuXG5cbiIsIlxuLy8gb3JMaXN0ID0gW2NwdSUsIG1lbSUsIGJhdHRlcnklLCBpc0NoYXJnaW5nIChiaW5hcnkpXVxuXG5mdW5jdGlvbiBkZWNpc2lvblZhbHVlT2ZQT1Qob2ZmbG9hZGluZ1Jlc291cmNlc0xpc3Qpe1xuICAgIGxldCBhZHZhbnRhZ2VDUFUgPSAxLW9mZmxvYWRpbmdSZXNvdXJjZXNMaXN0WzBdOyAvL05vZGUuanMgZW52LiBvbmx5XG5cbiAgICBsZXQgYWR2YW50YWdlTWVtID0gb2ZmbG9hZGluZ1Jlc291cmNlc0xpc3RbMV07IC8vIGZyZWUgbWVtb3J5IGluICVcblxuICAgIC8vYmF0dGVyeSBpcyBjaGFyZ2luZz0gTUFYIGFkdmFudGFnZSAhXG4gICAgbGV0IGFkdmFudGFnZUJhdHRlcnkgPSAwO1xuICAgIC8vYmF0dGVyeSBpcyBub3QgY2hhcmdpbmdcbiAgICBpZiAoIW9mZmxvYWRpbmdSZXNvdXJjZXNMaXN0WzNdKXtcbiAgICAgICAgYWR2YW50YWdlQmF0dGVyeSA9IDEwMC1vZmZsb2FkaW5nUmVzb3VyY2VzTGlzdFsyXTtcbiAgICB9XG4gICAgLy9yZXR1cm4gYWR2YW50YWdlQ1BVICsgYWR2YW50YWdlTWVtIC0gYWR2YW50YWdlQmF0dGVyeTtcbiAgICByZXR1cm4gYWR2YW50YWdlQ1BVICsgYWR2YW50YWdlTWVtIC0gYWR2YW50YWdlQmF0dGVyeTtcbn1cblxuXG4vL1dlIHF1YWxpZnkgYnkgXCJiZXN0XCIgdGhlIHBlZXIgd2l0aCBoaWdoZXN0IGN1cnJlbnQgY29tcHV0YXRpb24gYW5kIGJhdHRlcnlcblxuLy9pbnB1dCBpRGFuZE9ScGFpcnM9IHsgaWQgOiBbIG9yIGxpc3QgXSB9XG5mdW5jdGlvbiBvZmZsb2FkaW5nVGFyZ2V0IChpRGFuZE9ScGFpcnMpe1xuICAgIGxldCBiZXN0UE9USWQ9bnVsbDtcbiAgICBsZXQgdGVtcCA9IDA7XG4gICAgZm9yICggbGV0IGtleSBpbiBpRGFuZE9ScGFpcnMgKXtcblxuICAgICAgICBsZXQgZHBvdCA9IGRlY2lzaW9uVmFsdWVPZlBPVChpRGFuZE9ScGFpcnNba2V5XSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQRUVSID0gJytrZXkrJyBEUE9EID0gJytkcG90KTtcbiAgICAgICAgaWYgKCBkcG90PnRlbXApe1xuICAgICAgICAgICAgdGVtcD1kcG90O1xuICAgICAgICAgICAgYmVzdFBPVElkPWtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygnb2ZmbG9hZGluZ091dHB1dCQgYmVzdCBQT1QgaXMgPSAnLGJlc3RQT1RJZCk7XG4gICAgcmV0dXJuIGJlc3RQT1RJZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gb2ZmbG9hZGluZ1RhcmdldFxuXG4vKlxuLy9mb3IgdGVzdGluZyBwdXJwb3NlcyAoTm9kZS5qcyBlbnYuKVxubGV0IHBhaXJzID0ge1xuICAgICdpZDEnIDogWzEwLDIwLDYwLGZhbHNlXSxcbiAgICAnaWQyJyA6IFs1MCwzMCwxMDAsZmFsc2VdLFxuICAgICdpZDMnIDogWzk5LDQwLDEwLHRydWVdLFxuICAgICdpZDQnIDogWyAwLjAwLCA3My4yMCwgODAsIGZhbHNlIF1cbn1cbm9mZmxvYWRpbmdUYXJnZXQocGFpcnMpO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFzQmluZCA9IHJlcXVpcmUoJy4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcy1iaW5kL2Rpc3QvYXMtYmluZC5janMuanMnKTtcbnZhciBSdW5uZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3J1bm5lcnMvcnVubmVyLmpzJyk7XG52YXIgQ29tcGlsZXIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2NvbXBpbGVycy9hc3NlbWJseVNjcmlwdENvbXBpbGVyLmpzJyk7XG52YXIgQ29tcG9zYWJsZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9zYWJsZXMvY29tcG9zYWJsZS5qcycpO1xudmFyIEV4ZWN1dGlvbkVycm9yID0gcmVxdWlyZSgnLi4vLi4vY29yZS9lcnJvcnMvRXhlY3V0aW9uRXJyb3IuanMnKTtcbnZhciBEZWZpbml0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2Vycm9ycy9FeGVjdXRpb25FcnJvci5qcycpO1xudmFyIFN1cHBvcnRMaWJyYXJ5ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9leGVjdXRpb24vc3VwcG9ydExpYnJhcnkuanMnKTtcblxuXG4vKipcbiAqIFBhcmFtZXRlcnMgaW4gdGhlIEFzc2VtYmx5U2NyaXB0IHJ1biBmdW5jdGlvbiBzdGFydGluZyB3aXRoIHRoaXMgc3RyaW5nIGFyZSB1c2VkIGZvciB0aGUgdXNlciBpbnB1dHMuXG4gKi9cbmNvbnN0IHVzZXJJbnB1dFNlcGFyYXRvciA9IFwiaW5wdXRfXCI7XG5cbi8qKlxuICogVGhlIEFzc2VtYmx5U2NyaXB0IHJ1bm5lciBzdXBwb3J0cyBzdHJpY3QgVHlwZVNjcmlwdFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUnVubmVyXG4gKlxuICovXG5mdW5jdGlvbiBBc3NlbWJseVNjcmlwdFJ1bm5lcigpIHtcbiAgICB0aGlzLnN1cHBvcnRMaWIgPSBuZXcgU3VwcG9ydExpYnJhcnkoKTtcbiAgICB0aGlzLnN1cHBvcnRMaWIubG9hZEhUVFAoKTtcbiAgICB0aGlzLnN1cHBvcnRMaWIubG9hZExvZ2dlcigpO1xuICAgIHRoaXMuc3VwcG9ydExpYi5sb2FkVGVzdFN5bmMoKTtcbiAgICB0aGlzLmNvbXBpbGVyID0gbmV3IENvbXBpbGVyKHRoaXMuc3VwcG9ydExpYik7XG59XG5cbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZS5nZXRIVE1MRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGRlc2NyaXB0aW9uID0gXCJGaW5kIHRoZSBvZmZpY2lhbCBBc3NlbWJseVNjcmlwdCBkb2N1bWVudGF0aW9uIG9uIDxhIGhyZWY9J2h0dHBzOi8vd3d3LmFzc2VtYmx5c2NyaXB0Lm9yZy9pbnRyb2R1Y3Rpb24uaHRtbCcgdGFyZ2V0PSdfYmxhbmsnPmFzc2VtYmx5c2NyaXB0Lm9yZzwvYT4uXFxuXCIgK1xuICAgICAgICBcIlRoZSBleHBvcnRlZCA8Yj5ydW48L2I+IGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHBhcmFtZXRlcnMgYXMgZGF0YSBpbnB1dHMgYW5kIHJldHVybmVkIGRhdGEgYXMgYW4gb3V0cHV0IGNhbGxlZCA8Yj5vdXQ8L2I+LiBVc2VyIGlucHV0cyBoYXZlIHRvIGJlIHByZWZpeGVkIHdpdGggPGI+aW5wdXRfPC9iPiBhbmQgYmUgdGhlIGZpcnN0IHBhcmFtZXRlcnMuXFxuXCIgK1xuICAgICAgICBcIkFkZGl0aW9uYWwgb3V0cHV0cyBhcmUgZ2VuZXJhdGVkIGZvciBleHBvcnRlZCBnbG9iYWwgdmFyaWFibGVzLiBUaGlzIGFsbG93cyByZXR1cm5pbmcgdmFsdWVzIHJlc3VsdGluZyBmcm9tIGFzeW5jaHJvbm91cyBjYWxsYmFja3MuXFxuXCIgK1xuICAgICAgICBcIklmIHRoZSA8Yj5ydW48L2I+IGZ1bmN0aW9uIGhhcyB0aGUgcmV0dXJuIHR5cGUgXFxcInZvaWRcXFwiIG5vIGRlZmF1bHQgb3V0cHV0IGlzIGdlbmVyYXRlZC5cXG5cIjtcbiAgICBkZXNjcmlwdGlvbiArPSBcIlxcblwiICsgdGhpcy5jb21waWxlci5zdXBwb3J0TGlicmFyeURvY3VtZW50YXRpb247XG5cbiAgICAvL0hUTUwgbmV3IGxpbmVzXG4gICAgZGVzY3JpcHRpb24ucmVwbGFjZUFsbChcIlxcblwiLCBcIjxicj5cIik7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xufTtcblxuLy9pbmhlcml0IHByb3BlcnRpZXNcbkFzc2VtYmx5U2NyaXB0UnVubmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUnVubmVyLnByb3RvdHlwZSk7XG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlbWJseVNjcmlwdFJ1bm5lcjtcblxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLm5hbWUgPSBcIlR5cGVTY3JpcHQgKHVzaW5nIEFzc2VtYmx5U2NyaXB0KVwiO1xuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmlkID0gXCJ0eXBlc2NyaXB0XCI7XG5cbi8vPT09IE9GRkxPQURJTkcgPT09IE1vZHVsZSA9PiBBU0MgY29kZSB0byBXQVNNIGJpbmFyeVxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLnByZXBhcmUgPSBhc3luYyBmdW5jdGlvbiAobW9kdWxlLCBjYWxsYmFja0xpc3QgPSBbXSkge1xuICAgIGxldCBkZWZpbml0aW9uRGF0YSA9IG51bGw7XG5cbiAgICBpZiAoIW1vZHVsZS5iaW5hcnkgfHwgbW9kdWxlLmJpbmFyeS5sZW5ndGggPT09IDAgfHwgbW9kdWxlLmJpbmFyeUhhc2ggIT09IHRoaXMuY2FsY3VsYXRlQmluYXJ5SGFzaChtb2R1bGUuYmluYXJ5KSkge1xuICAgICAgICBtb2R1bGUuYmluYXJ5SGFzaCA9IG51bGw7XG4gICAgICAgIC8vIG1vbml0b3JlZCBjb21waWxhdGlvbiBpbiBBU0Njb21waWxlci5qc1xuICAgICAgICBsZXQgY29tcGlsZXJSZXN1bHQgPSBhd2FpdCB0aGlzLmNvbXBpbGVyLmNvbXBpbGUobW9kdWxlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb21waWxlclJlc3VsdCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coY29tcGlsZXJSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyUmVzdWx0ID09PSAnb2ZmbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgICAvL3RvZG86IE9mZmxvYWRpbmcgbmVlZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJvZmZsb2FkaW5nIGludGVyY2VwdGVkIGluIEFTQ1J1bm5lci5wcmVwYXJlKClcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZmxvYWRpbmcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuYmluYXJ5ID0gY29tcGlsZXJSZXN1bHQuYmluYXJ5RGF0YTtcbiAgICAgICAgICAgICAgICBtb2R1bGUuYmluYXJ5SGFzaCA9IHRoaXMuY2FsY3VsYXRlQmluYXJ5SGFzaChtb2R1bGUuYmluYXJ5KTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uRGF0YSA9IGNvbXBpbGVyUmVzdWx0LmRlZmluaXRpb25EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICBjb25zdCBtb2R1bGVJbnN0YW5jZSA9IGF3YWl0IEFzQmluZC5pbnN0YW50aWF0ZShtb2R1bGUuYmluYXJ5LCB7XG4gICAgICAgIG1vZHVsZTogdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uRGVzY3JpcHRpb24oY2FsbGJhY2tMaXN0KVxuICAgIH0pO1xuXG4gICAgaWYgKGRlZmluaXRpb25EYXRhICE9IG51bGwpXG4gICAgICAgIHRoaXMuY3JlYXRlRGF0YVNjaGVtYShtb2R1bGUsIG1vZHVsZUluc3RhbmNlLCBkZWZpbml0aW9uRGF0YSk7XG5cbiAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2U7XG59XG5cblxuLyoqXG4gKiAgd3JhcHBlciBmb3JcbiAqL1xuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmdlbmVyYXRlRnVuY3Rpb25EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFja0xpc3QpIHtcbiAgICBsZXQgZnVuY3Rpb25zID0ge307XG5cbiAgICBmb3IgKGxldCBmdW5jTmFtZSBpbiB0aGlzLnN1cHBvcnRMaWIuZnVuY3Rpb25zKSB7XG4gICAgICAgIGxldCBmdW5jRGVzYyA9IHRoaXMuc3VwcG9ydExpYi5mdW5jdGlvbnNbZnVuY05hbWVdO1xuICAgICAgICBsZXQgZnVuY3Rpb25SZWZlcmVuY2U7XG5cbiAgICAgICAgaWYgKGZ1bmNEZXNjLmFzeW5jKSB7XG4gICAgICAgICAgICAvL3BhcmFtcyBoYXMgY2FsbGJhY2sgbmFtZSBhcyBmaXJzdCBhcmd1bWVudCBmb2xsb3dlZCBieSByZWd1bGFyIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlID0gZnVuY3Rpb24gKC4uLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGxldCBjYWxsYmFja05hbWUgPSBwYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgcGFyYW1zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFja0xpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2U6IGZ1bmNEZXNjLmZ1bmMoLi4ucGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmdW5jTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tOYW1lOiBjYWxsYmFja05hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVmZXJlbmNlID0gZnVuY0Rlc2MuZnVuYztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uc1tcImxpYi5cIiArIGZ1bmNOYW1lXSA9IGZ1bmN0aW9uUmVmZXJlbmNlO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIChtb2R1bGUsIGRhdGEsIGlucHV0KSB7XG5cbiAgICBsZXQgY2FsbGJhY2tMaXN0ID0gW107XG4gICAgLypcbiAgICBjb25zb2xlLmxvZyhcIi8vLy8vLy8vLy8vLy8gQVNDIHJ1bm5lciBpbnB1dHMgLy8vLy8vLy8vLy8vLy9cIik7XG4gICAgY29uc29sZS5sb2coXCJtb2R1bGVcIik7XG4gICAgY29uc29sZS5sb2cobW9kdWxlKTtcbiAgICBjb25zb2xlLmxvZyhcImRhdGFcIik7XG4gICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgY29uc29sZS5sb2coXCJpbnB1dFwiKTtcbiAgICBjb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgY29uc29sZS5sb2coXCIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cIik7XG4gICAgICovXG4gICAgLy9jb21waWxlIGFuZCB1cGRhdGUgc2NoZW1hXG4gICAgbGV0IGluc3RhbmNlID0gYXdhaXQgdGhpcy5wcmVwYXJlKG1vZHVsZSwgY2FsbGJhY2tMaXN0KTtcbiAgICBjb25zb2xlLmxvZygnaW5zdGFuY2UnKTtcbiAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSk7XG4gICAgaWYgKGluc3RhbmNlID09PSAnb2ZmbG9hZGluZycpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ29mZmxvYWRpbmcgaW50ZXJjZXB0ZWQgaW4gQVNDUnVubmVyLmV4ZWMoKScpO1xuICAgICAgICByZXR1cm4gJ29mZmxvYWRpbmcnO1xuXG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdtb2R1bGUgcHJlcGFyZWQ9ICcpO1xuICAgIGNvbnNvbGUubG9nKG1vZHVsZSk7XG5cbiAgICBsZXQgcHJlcGFyZWRQYXJhbXMgPSBbXTtcbiAgICBpZiAobW9kdWxlLmlucHV0TmFtZXMubGVuZ3RoID4gMClcbiAgICAgICAgcHJlcGFyZWRQYXJhbXMgPSBwcmVwYXJlZFBhcmFtcy5jb25jYXQodGhpcy5maW5kUGFyYW1Bc3NpZ25tZW50KG1vZHVsZS5pbnB1dE5hbWVzLCBpbnB1dCwgbW9kdWxlLmNvbnRleHQpKTtcbiAgICBpZiAobW9kdWxlLmRhdGFJbk5hbWVzLmxlbmd0aCA+IDApXG4gICAgICAgIHByZXBhcmVkUGFyYW1zID0gcHJlcGFyZWRQYXJhbXMuY29uY2F0KHRoaXMuZmluZFBhcmFtQXNzaWdubWVudChtb2R1bGUuZGF0YUluTmFtZXMsIGRhdGEsIG1vZHVsZS5jb250ZXh0KSk7XG5cbiAgICAvL01vZHVsZSBpbnB1dFxuICAgIGNvbnNvbGUubG9nKCdNb2R1bGUgc291cmNlIGNvZGUgaW5wdXQnKTtcbiAgICBjb25zb2xlLmxvZyhwcmVwYXJlZFBhcmFtcyk7XG5cbiAgICAvLyByZXR1cm5WYWx1ZSByZXR1cm5zIHRoZSByZXN1bHQgZnJvbSB0aGUgYmluYXJ5IGV4ZWN1dGlvbiBvZiB0aGUgV0FTTSBtb2R1bGVcbiAgICAvL3RvZG8gZXhlY3V0ZSB0aGlzIGFmdGVyIGNoZWNraW5nIERNSSAhIGlmKCkgZWxzZSAuLi5cbiAgICAvLyBUT0RPIFByb21pc2UuUmFjZSBoZXJlISEhISEhISFcbiAgICBsZXQgcmV0dXJuVmFsdWUgPSBpbnN0YW5jZS5leHBvcnRzLnJ1biguLi5wcmVwYXJlZFBhcmFtcyk7XG4gICAgY29uc29sZS5sb2coJ3JldHVyblZhbHVlID0gJyk7XG4gICAgY29uc29sZS5sb2cocmV0dXJuVmFsdWUpO1xuXG4gICAgLy9maW5pc2ggZXhlY3V0aW5nIGFsbCBhc3luY2hyb25vdXMgZnVuY3Rpb25zICggaWYgY2FsbGJhY2sgZnVuY3Rpb25zIGFyZSBuZWVkZWQgYnkgdGhlIG1vZHVsZSApXG4gICAgd2hpbGUgKGNhbGxiYWNrTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVtYWluaW5nIENhbGxiYWNrOiBcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKGNhbGxiYWNrTGlzdFswXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy90b2RvOiBtb25pdG9yIHRoaXM/XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjYWxsYmFja0xpc3RbMF0ucHJvbWlzZTtcblxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRpb25FcnJvcihcIkVycm9yIGluIHN1cHBvcnQgZnVuY3Rpb24gXCIgKyBjYWxsYmFja0xpc3RbMF0uZnVuY05hbWUgKyBcIiB3aXRoIHBhcmFtZXRlcnMgXCIgKyBjYWxsYmFja0xpc3RbMF0ucGFyYW1zICsgXCIhXCIsIG1vZHVsZS5jb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgbGV0IGNhbGxiYWNrRGVzY3JpcHRvciA9IGluc3RhbmNlLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zW2NhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWVdO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFja0Rlc2NyaXB0b3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIkNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggbmFtZSBcIiArIGNhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWUgKyBcIiBub3QgZm91bmQhXCIsIG1vZHVsZS5jb250ZXh0KTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZSAhPSBudWxsICYmIGNhbGxiYWNrTGlzdFswXS5jYWxsYmFja05hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9tYXRjaCBudW1iZXIgb2YgcGFyYW1ldGVycyBvZiBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2tQYXJhbUNvdW50ID0gY2FsbGJhY2tEZXNjcmlwdG9yLnBhcmFtZXRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlcGFyZWRSZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgY2FsbGJhY2tQYXJhbUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnNbY2FsbGJhY2tMaXN0WzBdLmNhbGxiYWNrTmFtZV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vVG9kbzogZG8gc29tZXRoaW5nIHdpdGggY2FsbGJhY2sgcmV0dXJucz9cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbHVlID0gaW5zdGFuY2UuZXhwb3J0c1tjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lXSguLi5wcmVwYXJlZFJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDYWxsYmFjayByZXR1cm46IFwiICsgcmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRpb25FcnJvcihcIkVycm9yIHdoaWxlIGNhbGxpbmcgY2FsbGJhY2sgZnVuY3Rpb24gXCIgKyBjYWxsYmFja0xpc3RbMF0uY2FsbGJhY2tOYW1lICsgXCIgd2l0aCBwYXJhbWV0ZXJzICdcIiArIHJlc3VsdCArIFwiJyFcIiwgbW9kdWxlLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrTGlzdC5zaGlmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0T3V0cHV0RGF0YShpbnN0YW5jZSwgcmV0dXJuVmFsdWUpO1xufVxuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuY29sbGVjdE91dHB1dERhdGEgPSBmdW5jdGlvbiAobW9kdWxlSW5zdGFuY2UsIHJldHVyblZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuXG4gICAgaWYgKHJldHVyblZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0Lm91dCA9IHJldHVyblZhbHVlO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZygnQXNCaW5kJyk7XG4gICAgY29uc29sZS5sb2coQXNCaW5kKTtcbiAgICBjb25zb2xlLmxvZygnbW9kdWxlSW5zdGFuY2UnKTtcbiAgICBjb25zb2xlLmxvZyhtb2R1bGVJbnN0YW5jZSk7XG5cblxuICAgIGZvciAobGV0IGV4cG9ydGVkT2JqIGluIG1vZHVsZUluc3RhbmNlLmV4cG9ydHMpIHtcbiAgICAgICAgaWYgKG1vZHVsZUluc3RhbmNlLmV4cG9ydHNbZXhwb3J0ZWRPYmpdIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuR2xvYmFsICYmICFleHBvcnRlZE9iai5zdGFydHNXaXRoKFwiX19cIikpIHtcbiAgICAgICAgICAgIHJlc3VsdFtleHBvcnRlZE9ial0gPSBtb2R1bGVJbnN0YW5jZS5leHBvcnRzW3RoaXMuY29tcGlsZXIuaW50ZXJuYWxHZXR0ZXJQcmVmaXggKyBleHBvcnRlZE9ial0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZygncmVzdWx0Jyk7XG4gICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5Bc3NlbWJseVNjcmlwdFJ1bm5lci5wcm90b3R5cGUuZmluZFBhcmFtQXNzaWdubWVudCA9IGZ1bmN0aW9uIChuYW1lcywgdmFsdWVzLCBjb250ZXh0KSB7XG4gICAgbGV0IHByZXBhcmVkUGFyYW1zID0gW107XG4gICAgZm9yIChsZXQgaSBpbiBuYW1lcykge1xuICAgICAgICBsZXQgbWF0Y2hGb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQgJiYgdmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlucHV0TmFtZSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNbaV0gPT09IGlucHV0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlZFBhcmFtcy5wdXNoKHZhbHVlc1tpbnB1dE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2hGb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWZpbml0aW9uRXJyb3IoXCJNaXNtYXRjaCBiZXR3ZWVuIHJlY2VpdmVkIGFuZCBleHBlY3RlZCBwYXJhbWV0ZXJzIVxcbkV4cGVjdGVkIFxcXCJcIiArIG5hbWVzW2ldICsgXCJcXFwiLCBidXQgbm90IGNvbnRhaW5lZCBpbiByZWNlaXZlZCBwYXJhbWV0ZXJzOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlcyksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbXM7XG59XG5cblxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLnBhcnNlQXNzZW1ibHlTY3JpcHRWYXJpYWJsZU5hbWVzID0gZnVuY3Rpb24gKGRlZmluaXRpb25EYXRhKSB7XG4gICAgbGV0IHBhcmFtTmFtZXMgPSBBcnJheSgpO1xuICAgIGxldCBsaW5lcyA9IGRlZmluaXRpb25EYXRhLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAobGV0IGxpbmUgaW4gbGluZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzW2xpbmVdLmluZGV4T2YoXCJleHBvcnQgZnVuY3Rpb24gcnVuXCIpID09PSAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gbGluZXNbbGluZV0uc3Vic3RyaW5nKGxpbmVzW2xpbmVdLmluZGV4T2YoJygnKSArIDEsIGxpbmVzW2xpbmVdLmluZGV4T2YoJyknKSkuc3BsaXQoJywgJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbU5hbWUgPSBwYXJhbXNbaV0uc3Vic3RyaW5nKDAsIHBhcmFtc1tpXS5pbmRleE9mKFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtTmFtZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyYW1OYW1lcztcbn1cblxuQXNzZW1ibHlTY3JpcHRSdW5uZXIucHJvdG90eXBlLmNyZWF0ZURhdGFTY2hlbWEgPSBmdW5jdGlvbiAobW9kdWxlLCBtb2R1bGVJbnN0YW5jZSwgZGVmaW5pdGlvbkRhdGEpIHtcbiAgICBsZXQgcnVuID0gbW9kdWxlSW5zdGFuY2UudHlwZURlc2NyaXB0b3IuZXhwb3J0ZWRGdW5jdGlvbnMucnVuO1xuXG4gICAgLy92ZXJpZnkgZW50cnlwb2ludCBleGlzdHNcbiAgICBpZiAocnVuID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBEZWZpbml0aW9uRXJyb3IoXCJNaXNzaW5nIGVudHJ5cG9pbnQ6IGV4cG9ydGVkIGZ1bmN0aW9uIG5hbWVkIHJ1biBpcyByZXF1aXJlZCwgYXMgYW4gZW50cnlwb2ludC5cIiwgbW9kdWxlLmNvbnRleHQpO1xuXG4gICAgLy9pbnB1dHNcbiAgICAvL3BhcnNlIHBhcmFtZXRlciBuYW1lcyBvZiBydW4gZnVuY3Rpb24gLSByZXBsYWNlLCBpZiBBc3NlbWJseVNjcmlwdCBBUEksIHRvIGFjY2VzcyBwYXJhbWV0ZXIgbmFtZXMgYmVjb21lcyBhdmFpbGFibGVcbiAgICBsZXQgcGFyYW1OYW1lcyA9IHRoaXMucGFyc2VBc3NlbWJseVNjcmlwdFZhcmlhYmxlTmFtZXMoZGVmaW5pdGlvbkRhdGEpO1xuXG4gICAgaWYgKHJ1bi5wYXJhbWV0ZXJzLmxlbmd0aCAhPT0gcGFyYW1OYW1lcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBEZWZpbml0aW9uRXJyb3IoXCJQYXJhbWV0ZXIgbGVuZ3RoIG1pc21hdGNoISBQYXJhbWV0ZXJzIGNvdWxkIG5vdCBiZSBwYXJzZWQgZnVsbHkhXCIsIG1vZHVsZS5jb250ZXh0KTtcblxuICAgIG1vZHVsZS5kYXRhSW5OYW1lcyA9IFtdO1xuICAgIG1vZHVsZS5pbnB1dE5hbWVzID0gW107XG4gICAgbW9kdWxlLmRhdGFJblNjaGVtYSA9IHt0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiB7fX07XG4gICAgbW9kdWxlLmlucHV0U2NoZW1hID0ge3R5cGU6IFwib2JqZWN0XCIsIHByb3BlcnRpZXM6IHt9fTtcblxuICAgIGZvciAobGV0IGkgaW4gcnVuLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHBhcmFtTmFtZXNbaV0uc3RhcnRzV2l0aCh1c2VySW5wdXRTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBtb2R1bGUuaW5wdXROYW1lcy5wdXNoKHBhcmFtTmFtZXNbaV0pO1xuXG4gICAgICAgICAgICBtb2R1bGUuaW5wdXRTY2hlbWEucHJvcGVydGllc1twYXJhbU5hbWVzW2ldXSA9IHt0eXBlOiBydW4ucGFyYW1ldGVyc1tpXX07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2R1bGUuZGF0YUluTmFtZXMucHVzaChwYXJhbU5hbWVzW2ldKTtcblxuICAgICAgICAgICAgbW9kdWxlLmRhdGFJblNjaGVtYS5wcm9wZXJ0aWVzW3BhcmFtTmFtZXNbaV1dID0ge3R5cGU6IHJ1bi5wYXJhbWV0ZXJzW2ldfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vb3V0cHV0c1xuICAgIG1vZHVsZS5kYXRhT3V0TmFtZXMgPSBbXTtcbiAgICBtb2R1bGUuZGF0YU91dFNjaGVtYSA9IHt0eXBlOiBcIm9iamVjdFwiLCBwcm9wZXJ0aWVzOiB7fX07XG4gICAgZm9yIChsZXQgZXhwb3J0ZWRPYmogaW4gbW9kdWxlSW5zdGFuY2UuZXhwb3J0cykge1xuICAgICAgICBpZiAobW9kdWxlSW5zdGFuY2UuZXhwb3J0c1tleHBvcnRlZE9ial0gaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5HbG9iYWwgJiYgIWV4cG9ydGVkT2JqLnN0YXJ0c1dpdGgoXCJfX1wiKSkge1xuICAgICAgICAgICAgbW9kdWxlLmRhdGFPdXROYW1lcy5wdXNoKGV4cG9ydGVkT2JqKTtcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0U2NoZW1hLnByb3BlcnRpZXNbZXhwb3J0ZWRPYmpdID0ge3R5cGU6IG1vZHVsZUluc3RhbmNlLnR5cGVEZXNjcmlwdG9yLmV4cG9ydGVkRnVuY3Rpb25zW3RoaXMuY29tcGlsZXIuaW50ZXJuYWxHZXR0ZXJQcmVmaXggKyBleHBvcnRlZE9ial19XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJ1bi5yZXR1cm5UeXBlICE9PSAndm9pZCcpIHtcbiAgICAgICAgaWYgKCFtb2R1bGUuZGF0YU91dE5hbWVzLmluY2x1ZGVzKCdvdXQnKSkge1xuICAgICAgICAgICAgbW9kdWxlLmRhdGFPdXROYW1lcy5wdXNoKCdvdXQnKTtcbiAgICAgICAgICAgIG1vZHVsZS5kYXRhT3V0U2NoZW1hLnByb3BlcnRpZXNbJ291dCddID0ge3R5cGU6IHJ1bi5yZXR1cm5UeXBlfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERlZmluaXRpb25FcnJvcihcIkR1cGxpY2F0ZSBwYXJhbWV0ZXIgY2FsbGVkICdvdXQnISBEbyBub3QgdXNlICdvdXQnIGFzIGEgbmFtZSBmb3IgZXhwb3J0ZWQgdmFyaWFibGVzIVwiLCBtb2R1bGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlbWJseVNjcmlwdFJ1bm5lcjsiLCIndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBUaGUgcnVubmVyIGV4ZWN1dGVzIHRoZSBjb21waWxlZCBjb2RlIG1hZGUgYXZhaWxhYmxlIGJ5IHRoZSBjb21waWxlciBhbmQgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIG1hdGNoaW5nIGNvbXBpbGVyXG4gKiBJdCBoYXMgdHdvIHBoYXNlczogQSBzZXR1cCBwaGFzZSwgd2VyZSBhbGwgZGVwZW5kZW5jaWVzIGFyZSBsb2FkZWQgYW5kIGluaXRpYWxpemVkIGFuZCBhbiBvcGVyYXRpb25hbCBwaGFzZSwgd2hpY2ggaXMgdXNlZCB0byBjb21waWxlIGNvZGVcbiAqIFRoZSBzZXR1cCBuZWVkcyB0byBiZSBkb25lIG9ubHkgb25jZSwgd2hpbGUgdGhlIGV4ZWN1dGlvbiBjYW4gYmUgcmVwZWF0ZWQgb24gZGlmZmVyZW50IGRhdGEuXG4gKiBcbiAqIFRoaXMgaXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCB3aGljaCBzaG91bGQgYmUgc3ViY2xhc3NlZCBmb3IgZWFjaCBzdXBwb3J0ZWQgbGFuZ3VhZ2VcbiAqIFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqL1xuZnVuY3Rpb24gUnVubmVyKCkge1xuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcywgaWYgZGVwZW5kZW5jaWVzIGFyZSBsb2FkZWQuXG4gICAgKiBAbmFtZSBFeGVjdXRpb25NYW5hZ2VyI21vZHVsZXNUb3RhbFxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cbiAgICB0aGlzLnNldHVwQ29tcGxldGVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUnVuIHRoZSBwcm92aWRlZCBiaW5hcnkgb3Igc291cmNlIGNvZGVcbiAqIEBwYXJhbSB7bW9kdWxlfSBtb2R1bGUgLSBtb2R1bGUgY29udGFpbmluZyBzb3VyY2UgY29kZS9iaW5hcnkgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGRhdGEgcGFzc2VkIHRvIHRoZSBwcm9jZXNzaW5nIG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIGlucHV0cyBwYXNzZWQgdG8gdGhlIHByb2Nlc3Npbmcgbm9kZVxuICogQGFic3RyYWN0XG4gKi9cblJ1bm5lci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChtb2R1bGUsIGRhdGEsIGlucHV0KSB7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgcHJvdmlkZWQgbW9kdWxlIGZvciBleGVjdXRpb246XG4gKiAtIGNvbXBpbGUsIGlmIG5vdCBhbHJlYWR5IGNvbXBpbGVkXG4gKiAtIHVwZGF0ZSByZWZlcmVuY2VzIHRvIGJpbmFyeS9oYXNoXG4gKiAtIHVwZGF0ZSBkYXRhIHNjaGVtZXNcbiAqIFRoaXMgaXMgYWxzbyB1c2VkIHRvIHZhbGlkYXRlIG5ldyBzb3VyY2UgY29kZSB3aGlsZSBlZGl0aW5nXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IG1vZHVsZSAtIG1vZHVsZSBjb250YWluaW5nIHNvdXJjZSBjb2RlL2JpbmFyeSB0byBydW5cbiAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgcmVhZHkgdG8gZXhlY3V0ZVxuICogQHRocm93cyBDb21waWxlRXJyb3JcbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKG1vZHVsZSkge31cblxuLyoqXG4gKiBFbmQgdXNlciBmcmllbmRseSBOYW1lXG4gKi9cblJ1bm5lci5wcm90b3R5cGUubmFtZSA9IFwiQWJzdHJhY3QgUnVubmVyXCJcblxuLyoqXG4gKiBJRCB1c2VkIGludGVybmFsbHksIHRvIGlkZW50aWZ5IHJ1bm5lcnNcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5pZCA9IFwiYWJzdHJhY3RfcnVubmVyXCJcblxuLyoqXG4gKiBAcmV0dXJuIERlc2NyaXB0aW9uIG9mIHRoZSBydW5uZXIgaW5jbHVkaW5nIGEgbGluayB0byB0aGUgb2ZmaWNpYWwgZG9jdW1lbnRhdGlvbiBhbmQgc3VwcG9ydCBsaWJyYXJ5IGV4cGxhbmF0aW9uIGFzIGh0bWwuXG4gKiBAYWJzdHJhY3RcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5nZXRIVE1MRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7fVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBIYXNoIHVzZWQgdG8gY29tcGFyZSBiaW5hcmllc1xuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYmluYXJ5IC0gYmluYXJ5IHRvIGhhc2hcbiAqIEByZXR1cm4gaGFzaFxuICpcbiAqL1xuUnVubmVyLnByb3RvdHlwZS5jYWxjdWxhdGVCaW5hcnlIYXNoID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgIGxldCBoYXNoID0gMDtcbiAgICBmb3IobGV0IGkgaW4gYmluYXJ5KSB7XG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgOCktaGFzaCkrYmluYXJ5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgZGF0YSBzY2hlbWEgYmFzZWQgb24gc291cmNlL2JpbmFyeSBhbmQgd3JpdGUgcmVzdWx0cyB0byB0aGUgbW9kdWxlXG4gKiBUaGUgcHJvcGVydGllcyBkYXRhSW5TY2hlbWEsIGRhdGFPdXRTY2hlbWEsIGlucHV0U2NoZW1hLCBkYXRhSW5OYW1lcywgZGF0YU91dE5hbWVzLCBpbnB1dE5hbWVzIG9mIHRoZSBtb2R1bGUgY2FuIGJlIHdyaXR0ZW5cbiAqIENhbGxlZCBhdXRvbWF0aWNhbGx5LCB3aGVuIG5ldyBzb3VyY2UgaXMgY29tcGlsZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBtYW51YWxseSByZWdlbmVyYXRlIGRhdGEgc2NoZW1hXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IG1vZHVsZSAtIG1vZHVsZSBjb250YWluaW5nIHNvdXJjZSBjb2RlL2JpbmFyeVxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5SdW5uZXIucHJvdG90eXBlLmNyZWF0ZURhdGFTY2hlbWEgPSBmdW5jdGlvbiAobW9kdWxlKSB7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUnVubmVyIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEpzVG9rZW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXRva2Vucy9pbmRleC5qcycpO1xuLyoqXG4gKiBSZXNwb25zaWJsZSB0byB2ZXJpZnkgaWYgYSBzdHJpbmcgY29tcGxpZXMgdG8gYSBzYWZlICBKYXZhU2NyaXB0IHN1YnNldC5cbiAqIEEgYmxhY2tsaXN0IHVzZWQgdG8gZW5zdXJlIG5vIGhhcm1mdWwgb3BlcmF0aW9uIGNhbiBiZSBwZXJmb3JtZWQgYnkgdXNlciBkZWZpbmVkIHNjcmlwdHMuXG4gKiBDdXJyZW50bHkgdGhlIGZvbGxvd2luZyB0b2tlbnMgYXJlIGZvcmJpZGRlbjpcbiAqIGFyZ3VtZW50cywgY2FsbGVlLCBjYWxsZXIsIGNvbnN0cnVjdG9yLCBldmFsLCBwcm90b3R5cGUsIHN0YWNrLCB1bndhdGNoLCB2YWx1ZU9mLCB3YXRjaCwgX19wcm90b19fLCBfX3BhcmVudF9fLCAndGhpcycsIHdpbmRvdywgZG9jdW1lbnQsICdbJywgJ10nLCBGdW5jdGlvbiwgJ3dpdGgnLCB1bmV2YWwsIHRvU291cmNlLCBzZXRUaW1lb3V0LCBzZXRJbnRlcnZhbFxuICogVXNlIHtAbGluayBTd2V2YVNjcmlwdCNnZXR9IGFzIGEgcmVwbGFjZW1lbnQgZm9yIFtdLlxuICogXG4gKiBBZGRpdGlvbmFsbHkgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbWFza2VkLlxuICogQGNvbnN0cnVjdG9yIFxuICovXG5mdW5jdGlvbiBTd2V2YVNjcmlwdCgpIHtcbiAgICAvKipcbiAgICAqIExpc3Qgb2YgZm9yYmlkZGVuIHRva2VucywgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBKYXZhU2NyaXB0IHN1YnNldC5cbiAgICAqIEBuYW1lIFN3ZXZhU2NyaXB0I2ZvcmJpZGRlbkxpc3RcbiAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59XG4gICAgKi9cbiAgICB0aGlzLmZvcmJpZGRlbkxpc3QgPSB7XG4gICAgICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICAgICAgY2FsbGVlOiB0cnVlLFxuICAgICAgICBjYWxsZXI6IHRydWUsXG4gICAgICAgIGNvbnN0cnVjdG9yOiB0cnVlLFxuICAgICAgICBldmFsOiB0cnVlLFxuICAgICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICB1bndhdGNoOiB0cnVlLFxuICAgICAgICB2YWx1ZU9mOiB0cnVlLFxuICAgICAgICB3YXRjaDogdHJ1ZSxcblxuICAgICAgICBfX3Byb3RvX186IHRydWUsXG4gICAgICAgIF9fcGFyZW50X186IHRydWUsXG4gICAgICAgICd0aGlzJzogdHJ1ZSxcbiAgICAgICAgd2luZG93OiB0cnVlLFxuICAgICAgICBkb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgJ1snOiB0cnVlLFxuICAgICAgICAnXSc6IHRydWUsXG4gICAgICAgIEZ1bmN0aW9uOiB0cnVlLFxuICAgICAgICAnd2l0aCc6IHRydWUsXG4gICAgICAgIHVuZXZhbDogdHJ1ZSxcbiAgICAgICAgdG9Tb3VyY2U6IHRydWUsXG4gICAgICAgIHNldFRpbWVvdXQ6IHRydWUsXG4gICAgICAgIHNldEludGVydmFsOiB0cnVlXG4gICAgfVxuICAgIC8qKlxuICAgICogTGlzdCBvZiBhbGxvd2VkIGdsb2JhbCB2YXJpYWJsZXMsIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXNrZWQuXG4gICAgKiBUaGlzIGlzIGN1cnJlbnRseTogTWF0aCwgY29uc29sZSBcbiAgICAqIEBuYW1lIFN3ZXZhU2NyaXB0I2FsbG93ZWRHbG9iYWxzXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICovXG4gICAgdGhpcy5hbGxvd2VkR2xvYmFscyA9IHtcbiAgICAgICAgTWF0aDogdHJ1ZSxcbiAgICAgICAgY29uc29sZTogdHJ1ZSxcbiAgICAgICAgJ3RydWUnOiB0cnVlLFxuICAgICAgICAnZmFsc2UnOiB0cnVlXG4gICAgfVxufVxuXG4vKipcbiAqIFZlcmlmaWVzIGlmIGEgSmF2YVNjcmlwdCBjb2RlIGNvbXBsaWVzIHRvIHRoZSBzYWZlciBKYXZhU2NyaXB0IHN1YnNldC5cbiAqIERvZXMgbm90IHJld3JpdGUgb3IgY2hhbmdlIHRoZSBjb2RlLCB0aGVyZWZvciB5b3Ugc2hvdWxkIERFTlkgYW55dGhpbmcsIHRoYXQgaXMgY29uc2lkZXJlZCBoYXJtZnVsIGJ5IHRoaXMgZnVuY3Rpb24uXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gVGhlIEphdmFTY3JpcHQgY29kZSB0byB2ZXJpZnkgZm9yIHNhZmV0eS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlLCBpZiB0aGUgY29kZSBkb2VzIG5vdCBjb250YWluIGZvcmJpZGRlbiB0b2tlbnMuXG4gKi9cblN3ZXZhU2NyaXB0LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vZ2V0IGFuIGFycmF5IG9mIHRva2VucyB1c2luZyB0aGUgdG9rZW5pemVyIChleHRlcm5hbCBsaWJyYXJ5KVxuICAgICAgICB2YXIgdG9rZW5zID0gY29kZS5tYXRjaChKc1Rva2Vucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGUubWVzc2FnZVxuICAgICAgICB9XG4gICAgfVxuICAgXG4gICAgLy9jaGVjayBmb3IgZWFjaCB0b2tlblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXS50cmltKCk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvL2lmIHRva2VuIG5vbiBlbXB0eTogaXMgaXQgaW4gdGhlIGJsYWNrbGlzdD9cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmJpZGRlbkxpc3QuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgdXNhZ2Ugb2YgJyArIHRva2VuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vaWYgbm8gcmV0dXJuIHJlYWNoZWQgYmVmb3JlLCB3ZSBjYW4gYXNzdW1lIHRoZXJlIHdhcyBubyBmb3JiaWRkZW4gdG9rZW4gcHJlc2VudFxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICBlcnJvcjogJydcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIHRoZSBmb3JiaWRkZW4gW10gYWNjZXNzb3IsIGJ5IGNoZWNraW5nIHRoZSBwcm9wZXJ0eSBuYW1lIGR1cmluZyBydW50aW1lLlxuICogSWYgYSBmb3JiaWRkZW4gcHJvcGVydHkgKHNlZSB7QGxpbmsgU3dldmFTY3JpcHR9KSBpcyB1c2VkLCB0aGUgcHJvcGVydHkgaXMgbm90IGFjY2Vzc2VkLlxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXF1aXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHJvcGVydHkgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmUgdGhlIHZhbHVlIGZyb20uXG4gKiByZXR1cm5zIHtPYmplY3R8Ym9vbGVhbnxzdHJpbmd8bnVtYmVyfSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGFuIGlsbGVnYWwgcHJvcGVydHkgbmFtZSBpcyB1c2VkIG51bGwuXG4gKi9cblN3ZXZhU2NyaXB0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHZhciBmb3JiaWRkZW5MaXN0ID0ge1xuICAgICAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgICAgIGNhbGxlZTogdHJ1ZSxcbiAgICAgICAgY2FsbGVyOiB0cnVlLFxuICAgICAgICBjb25zdHJ1Y3RvcjogdHJ1ZSxcbiAgICAgICAgZXZhbDogdHJ1ZSxcbiAgICAgICAgcHJvdG90eXBlOiB0cnVlLFxuICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgdW53YXRjaDogdHJ1ZSxcbiAgICAgICAgdmFsdWVPZjogdHJ1ZSxcbiAgICAgICAgd2F0Y2g6IHRydWUsXG5cbiAgICAgICAgX19wcm90b19fOiB0cnVlLFxuICAgICAgICBfX3BhcmVudF9fOiB0cnVlLFxuICAgICAgICAndGhpcyc6IHRydWUsXG4gICAgICAgIHdpbmRvdzogdHJ1ZSxcbiAgICAgICAgZG9jdW1lbnQ6IHRydWUsXG4gICAgICAgICdbJzogdHJ1ZSxcbiAgICAgICAgJ10nOiB0cnVlLFxuICAgICAgICBGdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgJ3dpdGgnOiB0cnVlLFxuICAgICAgICB1bmV2YWw6IHRydWUsXG4gICAgICAgIHRvU291cmNlOiB0cnVlLFxuICAgICAgICBzZXRUaW1lb3V0OiB0cnVlLFxuICAgICAgICBzZXRJbnRlcnZhbDogdHJ1ZVxuICAgIH1cbiAgICAvL2lmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCBjaGVjayBmb3IgYmVpbmcgaW4gdGhlIGJsYWNrbGlzdFxuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghb2JqZWN0LndpbmRvdyAmJiAhZm9yYmlkZGVuTGlzdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vbnVtYmVycyBhcmUgbm90IGNoZWNrZWQgZm9yIGJlaW5nIGluIHRoZSBibGFja2xpc3RcbiAgICBlbHNlIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoJ0lsbGVnYWwgcHJvcGVydHkgbmFtZTogJyArIHByb3BlcnR5KTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuU3dldmFTY3JpcHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHZhciBmb3JiaWRkZW5MaXN0ID0ge1xuICAgICAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgICAgIGNhbGxlZTogdHJ1ZSxcbiAgICAgICAgY2FsbGVyOiB0cnVlLFxuICAgICAgICBjb25zdHJ1Y3RvcjogdHJ1ZSxcbiAgICAgICAgZXZhbDogdHJ1ZSxcbiAgICAgICAgcHJvdG90eXBlOiB0cnVlLFxuICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgdW53YXRjaDogdHJ1ZSxcbiAgICAgICAgdmFsdWVPZjogdHJ1ZSxcbiAgICAgICAgd2F0Y2g6IHRydWUsXG5cbiAgICAgICAgX19wcm90b19fOiB0cnVlLFxuICAgICAgICBfX3BhcmVudF9fOiB0cnVlLFxuICAgICAgICAndGhpcyc6IHRydWUsXG4gICAgICAgIHdpbmRvdzogdHJ1ZSxcbiAgICAgICAgZG9jdW1lbnQ6IHRydWUsXG4gICAgICAgICdbJzogdHJ1ZSxcbiAgICAgICAgJ10nOiB0cnVlLFxuICAgICAgICBGdW5jdGlvbjogdHJ1ZSxcbiAgICAgICAgJ3dpdGgnOiB0cnVlLFxuICAgICAgICB1bmV2YWw6IHRydWUsXG4gICAgICAgIHRvU291cmNlOiB0cnVlLFxuICAgICAgICBzZXRUaW1lb3V0OiB0cnVlLFxuICAgICAgICBzZXRJbnRlcnZhbDogdHJ1ZVxuICAgIH1cbiAgICAvL2lmIGEgc3RyaW5nIGlzIHByb3ZpZGVkLCBjaGVjayBmb3IgYmVpbmcgaW4gdGhlIGJsYWNrbGlzdFxuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghb2JqZWN0LndpbmRvdyAmJiAhZm9yYmlkZGVuTGlzdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lsbGVnYWwgcHJvcGVydHkgbmFtZTogJyArIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL251bWJlcnMgYXJlIG5vdCBjaGVja2VkIGZvciBiZWluZyBpbiB0aGUgYmxhY2tsaXN0XG4gICAgZWxzZSBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTYW5pdGl6ZXMgZ2l2ZW4gSmF2YXNjcmlwdCBjb2RlIGJ5IHZlcmlmeWluZyBpZiBpdCBpcyBhIHNhZmVyIHN1YnNldCBvZiBKYXZhU2NyaXB0IGFuZCBtYXNraW5nIGdsb2JhbCB2YXJpYWJsZXMuXG4gKiB7QGxpbmsgU3dldmFTY3JpcHQjdmVyaWZ5fSBpcyBwZXJmb3JtZWQgaW50ZXJuYWxseSwgc28geW91IGRvIG5vdCBuZWVkIHRvIHZlcmlmeSBleHBsaWNpdGx5IGJlZm9yZWhhbmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIFRoZSBKYXZhU2NyaXB0IGZ1bmN0aW9uIHRvIHNhbml0aXplLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3JDYWxsYmFjayAtIEEgY2FsbGJhY2sgY2FsbGVkLCB3aGVuIGFuIGVycm9yIG9jY3VycywgaGFzIGEgc3RyaW5nIGFzIGEgcGFyYW1ldGVyIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJuc3tmdW5jdGlvbn0gLSBBIGZ1bmN0aW9uLCB0aGF0IGNhbiBiZSBleGVjdXRlZFxuICovXG5Td2V2YVNjcmlwdC5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAoY29kZSwgZXJyb3JDYWxsYmFjaykge1xuICAgIC8vYWxsIGluIG9uZSBsaW5lXG4gICAgLy9jb2RlID0gY29kZS5yZXBsYWNlKC8oXFxyXFxufFxcbnxcXHIpL2dtLCBcIlwiKTsgXG4gICBcbiAgICB2YXIgZXJyb3IgPSAnJztcbiAgICAvL2ZpcnN0IG1ha2Ugc3VyZSBpdCBpcyB2YWxpZCBTd2V2YVNjcmlwdFxuICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52ZXJpZnkoY29kZSk7ICAgIFxuICAgIGlmICh2YWxpZGF0aW9uLnZhbGlkKSB7ICAgICAgICBcbiAgICAgICAgdmFyIGFsbG93ZWRHbG9iYWxzID0gdGhpcy5hbGxvd2VkR2xvYmFscztcbiAgICAgICAgLy9nZXQgYWxsIGdsb2JhbCB2YXJpYWJsZXMgZXhjZXB0IHRoZSBleGNlcHRpb25zIHdlIGRlZmluZWQgaW4ge0BsaW5rIFN3ZXZhU2NyaXB0I2FsbG93ZWRHbG9iYWxzfVxuICAgICAgICB2YXIgZ2xvYmFscyA9IE9iamVjdC5rZXlzKHdpbmRvdykuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAhYWxsb3dlZEdsb2JhbHMuaGFzT3duUHJvcGVydHkob2JqKVxuICAgICAgICB9KS5qb2luKCcsJyk7XG4gICAgICAgIC8vd2Ugd2FudCB0byBzaGFkb3cgYWxsIGdsb2JhbCB2YXJpYWJsZXMgZXhjZXB0IHRoZSBvbmVzIHdlIGFsbG93LCBieSBkZWNsYXJpbmcgdGhlbSBhcyBsb2NhbCB2YXJpYWJsZXNcbiAgICAgICAgLy9odHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3Bvc3RzLzI2OTE3OTM4L3JldmlzaW9uc1xuICAgICAgICAvL3ZhciBmdW5jUmVnID0gL2Z1bmN0aW9uICpcXCgoW14oKV0qKVxcKVsgXFxuXFx0XSp7KC4qKX0vZ21pO1xuICAgICAgICB2YXIgZnVuY1JlZyA9IC9mdW5jdGlvblxccypcXCgoW14oKV0qKVxcKVxcc1xceygoLnxcXG4pKilcXH0vZ21pO1xuICAgICAgICB2YXIgbWF0Y2ggPSBmdW5jUmVnLmV4ZWMoY29kZSk7XG4gICAgICAgXG4gICAgICAgIC8vd2UgZXh0cmFjdCBmdW50aW9uIGhlYWRlciAoZGVjcmxhcmF0aW9uIHdpdGggcGFyYW1ldGVycykgYW5kIGJvZHlcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZW5mb3JjZSBzdHJpY3QgYmVoYXZpb3IsIHNoYWRvdyBnbG9iYWxzLCBhcHBlbmQgdmVyaWZpZWQgY29kZVxuICAgICAgICAgICAgdmFyIGZuX3RleHQgPSAnXCJ1c2Ugc3RyaWN0XCI7IHZhciAnICsgZ2xvYmFscyArICc7JyArIG1hdGNoWzJdICsgJzsnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZm4gPSBuZXcgRnVuY3Rpb24obWF0Y2hbMV0uc3BsaXQoJywnKSwgZm5fdGV4dCk7Ly9nZW5lcmF0ZSBzYW5pdGl6ZWQgZnVuY3Rpb25cblxuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSAnTm90IGEgdmFsaWQgSlMgZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcnJvciA9IHZhbGlkYXRpb24uZXJyb3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3dldmFTY3JpcHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tcGlsZVNjaGVtYSA9IHJlcXVpcmUoJy4vY29tcGlsZScpXG4gICAgLCByZXNvbHZlID0gcmVxdWlyZSgnLi9jb21waWxlL3Jlc29sdmUnKVxuICAgICwgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJylcbiAgICAsIFNjaGVtYU9iamVjdCA9IHJlcXVpcmUoJy4vY29tcGlsZS9zY2hlbWFfb2JqJylcbiAgICAsIHN0YWJsZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpXG4gICAgLCBmb3JtYXRzID0gcmVxdWlyZSgnLi9jb21waWxlL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBanY7XG5cbnZhciBNRVRBX1NDSEVNQV9JRCA9ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSc7XG52YXIgU0NIRU1BX1VSSV9GT1JNQVQgPSAvXig/Oig/OlthLXpdW2EtejAtOSstLl0qOik/XFwvXFwvKT9bXlxcc10qJC9pO1xuZnVuY3Rpb24gU0NIRU1BX1VSSV9GT1JNQVRfRlVOQyhzdHIpIHtcbiAgICByZXR1cm4gU0NIRU1BX1VSSV9GT1JNQVQudGVzdChzdHIpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdG9yIGluc3RhbmNlLlxuICogVXNhZ2U6IGBBanYob3B0cylgXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBvcHRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFqdiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBanYob3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBanYpKSByZXR1cm4gbmV3IEFqdihvcHRzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMuX3NjaGVtYXMgPSB7fTtcbiAgICB0aGlzLl9yZWZzID0ge307XG4gICAgdGhpcy5fZm9ybWF0cyA9IGZvcm1hdHModGhpcy5vcHRzLmZvcm1hdCk7XG4gICAgdGhpcy5fY2FjaGUgPSB0aGlzLm9wdHMuY2FjaGUgfHwgbmV3IENhY2hlO1xuICAgIHRoaXMuX2xvYWRpbmdTY2hlbWFzID0ge307XG5cbiAgICAvLyB0aGlzIGlzIGRvbmUgb24gcHVycG9zZSwgc28gdGhhdCBtZXRob2RzIGFyZSBib3VuZCB0byB0aGUgaW5zdGFuY2VcbiAgICAvLyAod2l0aG91dCB1c2luZyBiaW5kKSBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgd2l0aG91dCB0aGUgaW5zdGFuY2VcbiAgICB0aGlzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgdGhpcy5jb21waWxlID0gY29tcGlsZTtcbiAgICB0aGlzLmNvbXBpbGVBc3luYyA9IGNvbXBpbGVBc3luYztcbiAgICB0aGlzLmFkZFNjaGVtYSA9IGFkZFNjaGVtYTtcbiAgICB0aGlzLmFkZE1ldGFTY2hlbWEgPSBhZGRNZXRhU2NoZW1hO1xuICAgIHRoaXMudmFsaWRhdGVTY2hlbWEgPSB2YWxpZGF0ZVNjaGVtYTtcbiAgICB0aGlzLmdldFNjaGVtYSA9IGdldFNjaGVtYTtcbiAgICB0aGlzLnJlbW92ZVNjaGVtYSA9IHJlbW92ZVNjaGVtYTtcbiAgICB0aGlzLmFkZEZvcm1hdCA9IGFkZEZvcm1hdDtcbiAgICB0aGlzLmVycm9yc1RleHQgPSBlcnJvcnNUZXh0O1xuXG4gICAgdGhpcy5fY29tcGlsZSA9IF9jb21waWxlO1xuXG4gICAgYWRkSW5pdGlhbFNjaGVtYXMoKTtcbiAgICBpZiAodGhpcy5vcHRzLmZvcm1hdHMpIGFkZEluaXRpYWxGb3JtYXRzKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gICAgICogU2NoZW1hIHdpbGwgYmUgY29tcGlsZWQgYW5kIGNhY2hlZCAodXNpbmcgc2VyaWFsaXplZCBKU09OIGFzIGtleS4gW2pzb24tc3RhYmxlLXN0cmluZ2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL2pzb24tc3RhYmxlLXN0cmluZ2lmeSkgaXMgdXNlZCB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtBbnl9IGRhdGEgdG8gYmUgdmFsaWRhdGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdmFsaWRhdGlvbiByZXN1bHQuIEVycm9ycyBmcm9tIHRoZSBsYXN0IHZhbGlkYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgaW4gYGFqdi5lcnJvcnNgIChhbmQgYWxzbyBpbiBjb21waWxlZCBzY2hlbWE6IGBzY2hlbWEuZXJyb3JzYCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCBkYXRhKSB7XG4gICAgICAgIHZhciB2O1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdiA9IGdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoJ25vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCInICsgc2NoZW1hS2V5UmVmICsgJ1wiJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hT2JqID0gX2FkZFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgdiA9IHNjaGVtYU9iai52YWxpZGF0ZSB8fCBfY29tcGlsZShzY2hlbWFPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbGlkID0gdihkYXRhKTtcbiAgICAgICAgc2VsZi5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHZhbGlkYXRpbmcgZnVuY3Rpb24gZm9yIHBhc3NlZCBzY2hlbWEuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHZhbGlkYXRpbmcgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21waWxlKHNjaGVtYSkge1xuICAgICAgICB2YXIgc2NoZW1hT2JqID0gX2FkZFNjaGVtYShzY2hlbWEpO1xuICAgICAgICByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IF9jb21waWxlKHNjaGVtYU9iaik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYSB3aXRoIGFzeW5jaHJvbm91cyBsb2FkaW5nIG9mIG1pc3Npbmcgc2NoZW1hcy5cbiAgICAgKiBgbG9hZFNjaGVtYWAgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzY2hlbWEgdXJpIGFuZCBub2RlLXN0eWxlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IHNjaGVtYVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBub2RlLXN0eWxlIGNhbGxiYWNrLCBpdCBpcyBhbHdheXMgY2FsbGVkIHdpdGggMiBwYXJhbWV0ZXJzOiBlcnJvciAob3IgbnVsbCkgYW5kIHZhbGlkYXRpbmcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGlsZUFzeW5jKHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNjaGVtYU9iajtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYU9iaiA9IF9hZGRTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYU9iai52YWxpZGF0ZSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKG51bGwsIHNjaGVtYU9iai52YWxpZGF0ZSk7IH0pO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRzLmxvYWRTY2hlbWEgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgX2NvbXBpbGVBc3luYyhzY2hlbWEsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2hlbWEsIGNhbGxiYWNrLCBmaXJzdENhbGwpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRlO1xuICAgICAgICB0cnkgeyB2YWxpZGF0ZSA9IGNvbXBpbGUoc2NoZW1hKTsgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICBpZiAoZS5taXNzaW5nU2NoZW1hKSBsb2FkTWlzc2luZ1NjaGVtYShlKTtcbiAgICAgICAgICAgIGVsc2UgZGVmZXJDYWxsYmFjayhlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlckNhbGxiYWNrKG51bGwsIHZhbGlkYXRlKTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShlKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gZS5taXNzaW5nU2NoZW1hO1xuICAgICAgICAgICAgaWYgKHNlbGYuX3JlZnNbcmVmXSB8fCBzZWxmLl9zY2hlbWFzW3JlZl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignU2NoZW1hICcgKyByZWYgKyAnIGlzIGxvYWRlZCBidXQnICsgZS5taXNzaW5nUmVmICsgJ2Nhbm5vdCBiZSByZXNvbHZlZCcpKTtcbiAgICAgICAgICAgIHZhciBfY2FsbGJhY2tzID0gc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgICAgICAgIGlmIChfY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfY2FsbGJhY2tzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl0gPSBbX2NhbGxiYWNrcywgc2NoZW1hTG9hZGVkXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NbX2NhbGxiYWNrcy5sZW5ndGhdID0gc2NoZW1hTG9hZGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2FkaW5nU2NoZW1hc1tyZWZdID0gc2NoZW1hTG9hZGVkO1xuICAgICAgICAgICAgICAgIHNlbGYub3B0cy5sb2FkU2NoZW1hKHJlZiwgZnVuY3Rpb24gKGVyciwgc2NoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY2FsbGJhY2tzID0gc2VsZi5fbG9hZGluZ1NjaGVtYXNbcmVmXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX2NhbGxiYWNrcyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrcyhlcnIsIHNjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxfY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NbaV0oZXJyLCBzY2gpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzY2hlbWFMb2FkZWQoZXJyLCBzY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzZWxmLl9yZWZzW3JlZl0gfHwgc2VsZi5fc2NoZW1hc1tyZWZdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTY2hlbWEoc2NoLCByZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9jb21waWxlQXN5bmMoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVmZXJDYWxsYmFjayhlcnIsIHZhbGlkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RDYWxsKSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIsIHZhbGlkYXRlKTsgfSk7XG4gICAgICAgICAgICBlbHNlIGNhbGxiYWNrKGVyciwgdmFsaWRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHNjaGVtYSBzY2hlbWEgb3IgYXJyYXkgb2Ygc2NoZW1hcy4gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFNjaGVtYShzY2hlbWEsIGtleSwgX3NraXBWYWxpZGF0aW9uLCBfbWV0YSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKXtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIGFkZFNjaGVtYShzY2hlbWFbaV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBrZXkvaWQgaGF2ZSAjIGluc2lkZT9cbiAgICAgICAga2V5ID0gcmVzb2x2ZS5ub3JtYWxpemVJZChrZXkgfHwgc2NoZW1hLmlkKTtcbiAgICAgICAgY2hlY2tVbmlxdWUoa2V5KTtcbiAgICAgICAgdmFyIHNjaGVtYU9iaiA9IHNlbGYuX3NjaGVtYXNba2V5XSA9IF9hZGRTY2hlbWEoc2NoZW1hLCBfc2tpcFZhbGlkYXRpb24pO1xuICAgICAgICBzY2hlbWFPYmoubWV0YSA9IF9tZXRhO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gICAgICogcmVtb3ZlQWRkaXRpb25hbCBvcHRpb24gaXMgYWx3YXkgc2V0IHRvIGZhbHNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgb3B0aW9uYWwgc2NoZW1hIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIF9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICBhZGRTY2hlbWEoc2NoZW1hLCBrZXksIF9za2lwVmFsaWRhdGlvbiwgdHJ1ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBzY2hlbWFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgdG8gdmFsaWRhdGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICB2YXIgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hIHx8IE1FVEFfU0NIRU1BX0lEO1xuICAgICAgICB2YXIgY3VycmVudFVyaUZvcm1hdCA9IHNlbGYuX2Zvcm1hdHMudXJpO1xuICAgICAgICBzZWxmLl9mb3JtYXRzLnVyaSA9IHR5cGVvZiBjdXJyZW50VXJpRm9ybWF0ID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFNDSEVNQV9VUklfRk9STUFUX0ZVTkNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFNDSEVNQV9VUklfRk9STUFUO1xuICAgICAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICBzZWxmLl9mb3JtYXRzLnVyaSA9IGN1cnJlbnRVcmlGb3JtYXQ7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldCBjb21waWxlZCBzY2hlbWEgZnJvbSB0aGUgaW5zdGFuY2UgYnkgYGtleWAgb3IgYHJlZmAuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXlSZWYgYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAoYHNjaGVtYS5pZGAgb3IgcmVzb2x2ZWQgaWQpLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2hlbWEgdmFsaWRhdGluZyBmdW5jdGlvbiAod2l0aCBwcm9wZXJ0eSBgc2NoZW1hYCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2NoZW1hKGtleVJlZikge1xuICAgICAgICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaihrZXlSZWYpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFPYmopIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiBnZXRTY2hlbWEoc2NoZW1hT2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX2dldFNjaGVtYU9iaihrZXlSZWYpIHtcbiAgICAgICAga2V5UmVmID0gcmVzb2x2ZS5ub3JtYWxpemVJZChrZXlSZWYpO1xuICAgICAgICByZXR1cm4gc2VsZi5fc2NoZW1hc1trZXlSZWZdIHx8IHNlbGYuX3JlZnNba2V5UmVmXTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjYWNoZWQgc2NoZW1hXG4gICAgICogRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaihzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NhY2hlLmRlbChzY2hlbWFPYmouanNvblN0cik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3NjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5fcmVmc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICB2YXIganNvblN0ciA9IHN0YWJsZVN0cmluZ2lmeShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2NhY2hlLmRlbChqc29uU3RyKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBzY2hlbWFLZXlSZWYuaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIF9hZGRTY2hlbWEoc2NoZW1hLCBza2lwVmFsaWRhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSAhPSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgc2hvdWxkIGJlIG9iamVjdCcpO1xuICAgICAgICB2YXIganNvblN0ciA9IHN0YWJsZVN0cmluZ2lmeShzY2hlbWEpO1xuICAgICAgICB2YXIgY2FjaGVkID0gc2VsZi5fY2FjaGUuZ2V0KGpzb25TdHIpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuXG4gICAgICAgIHZhciBpZCA9IHJlc29sdmUubm9ybWFsaXplSWQoc2NoZW1hLmlkKTtcbiAgICAgICAgaWYgKGlkKSBjaGVja1VuaXF1ZShpZCk7XG5cbiAgICAgICAgdmFyIG9rID0gc2tpcFZhbGlkYXRpb24gfHwgc2VsZi5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICB8fCB2YWxpZGF0ZVNjaGVtYShzY2hlbWEpO1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICdzY2hlbWEgaXMgaW52YWxpZDonICsgZXJyb3JzVGV4dCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0cy52YWxpZGF0ZVNjaGVtYSA9PSAnbG9nJykgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsUmVmcyA9IHJlc29sdmUuaWRzLmNhbGwoc2VsZiwgc2NoZW1hKTtcblxuICAgICAgICB2YXIgc2NoZW1hT2JqID0gbmV3IFNjaGVtYU9iamVjdCh7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgIGxvY2FsUmVmczogbG9jYWxSZWZzLFxuICAgICAgICAgICAganNvblN0cjoganNvblN0cixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlkWzBdICE9ICcjJykgc2VsZi5fcmVmc1tpZF0gPSBzY2hlbWFPYmo7XG4gICAgICAgIHNlbGYuX2NhY2hlLnB1dChqc29uU3RyLCBzY2hlbWFPYmopO1xuXG4gICAgICAgIHJldHVybiBzY2hlbWFPYmo7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBfY29tcGlsZShzY2hlbWFPYmosIHJvb3QpIHtcbiAgICAgICAgaWYgKHNjaGVtYU9iai5jb21waWxpbmcpIHtcbiAgICAgICAgICAgIHNjaGVtYU9iai52YWxpZGF0ZSA9IGNhbGxWYWxpZGF0ZTtcbiAgICAgICAgICAgIGNhbGxWYWxpZGF0ZS5zY2hlbWEgPSBzY2hlbWFPYmouc2NoZW1hO1xuICAgICAgICAgICAgY2FsbFZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBjYWxsVmFsaWRhdGUucm9vdCA9IHJvb3QgPyByb290IDogY2FsbFZhbGlkYXRlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxWYWxpZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY3VycmVudFJBID0gc2VsZi5vcHRzLnJlbW92ZUFkZGl0aW9uYWw7XG4gICAgICAgIGlmIChjdXJyZW50UkEgJiYgc2NoZW1hT2JqLm1ldGEpIHNlbGYub3B0cy5yZW1vdmVBZGRpdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIHZhciB2O1xuICAgICAgICB0cnkgeyB2ID0gY29tcGlsZVNjaGVtYS5jYWxsKHNlbGYsIHNjaGVtYU9iai5zY2hlbWEsIHJvb3QsIHNjaGVtYU9iai5sb2NhbFJlZnMpOyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc2NoZW1hT2JqLmNvbXBpbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRSQSkgc2VsZi5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPSBjdXJyZW50UkE7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWFPYmoudmFsaWRhdGUgPSB2O1xuICAgICAgICBzY2hlbWFPYmoucmVmcyA9IHYucmVmcztcbiAgICAgICAgc2NoZW1hT2JqLnJlZlZhbCA9IHYucmVmVmFsO1xuICAgICAgICBzY2hlbWFPYmoucm9vdCA9IHYucm9vdDtcbiAgICAgICAgcmV0dXJuIHY7XG5cblxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHNjaGVtYU9iai52YWxpZGF0ZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gdi5lcnJvcnM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBlcnJvcnNUZXh0KGVycm9ycywgb3B0cykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgc2VsZi5lcnJvcnM7XG4gICAgICAgIGlmICghZXJyb3JzKSByZXR1cm4gJ05vIGVycm9ycyc7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gb3B0cy5zZXBhcmF0b3IgfHwgJywgJztcbiAgICAgICAgdmFyIGRhdGFWYXIgPSBvcHRzLmRhdGFWYXIgfHwgJ2RhdGEnO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gZXJyb3JzLnJlZHVjZShmdW5jdGlvbih0eHQsIGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlID8gdHh0ICsgZGF0YVZhciArIGUuZGF0YVBhdGggKyAnICcgKyBlLm1lc3NhZ2UgKyBzZXBhcmF0b3IgOiB0eHQ7XG4gICAgICAgIH0sICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgLXNlcGFyYXRvci5sZW5ndGgpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSAnc3RyaW5nJykgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgICAgICBzZWxmLl9mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgICAgIGlmIChzZWxmLm9wdHMubWV0YSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBtZXRhU2NoZW1hID0gcmVxdWlyZSgnLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA0Lmpzb24nKTtcbiAgICAgICAgICAgIGFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIHRydWUpO1xuICAgICAgICAgICAgc2VsZi5fcmVmc1snaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWEnXSA9IE1FVEFfU0NIRU1BX0lEO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdHNTY2hlbWFzID0gc2VsZi5vcHRzLnNjaGVtYXM7XG4gICAgICAgIGlmICghb3B0c1NjaGVtYXMpIHJldHVybjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKSBhZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICAgICAgICBlbHNlIGZvciAodmFyIGtleSBpbiBvcHRzU2NoZW1hcykgYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmLm9wdHMuZm9ybWF0cykge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHNlbGYub3B0cy5mb3JtYXRzW25hbWVdO1xuICAgICAgICAgICAgYWRkRm9ybWF0KG5hbWUsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNoZWNrVW5pcXVlKGlkKSB7XG4gICAgICAgIGlmIChzZWxmLl9zY2hlbWFzW2lkXSB8fCBzZWxmLl9yZWZzW2lkXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDYWNoZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ2FjaGUoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG5cblxuQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIENhY2hlX3B1dChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fY2FjaGVba2V5XSA9IHZhbHVlO1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gQ2FjaGVfZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gQ2FjaGVfZGVsKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVtrZXldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9hbGwgcmVxdWlyZXMgbXVzdCBiZSBleHBsaWNpdCBiZWNhdXNlIGJyb3dzZXJpZnkgd29uJ3Qgd29yayB3aXRoIGR5bmFtaWMgcmVxdWlyZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICAnJHJlZic6IHJlcXVpcmUoJy4uL2RvdGpzL3JlZicpLFxuICBhbnlPZjogcmVxdWlyZSgnLi4vZG90anMvYW55T2YnKSxcbiAgZm9ybWF0OiByZXF1aXJlKCcuLi9kb3Rqcy9mb3JtYXQnKSxcbiAgbWF4TGVuZ3RoOiByZXF1aXJlKCcuLi9kb3Rqcy9tYXhMZW5ndGgnKSxcbiAgbWluSXRlbXM6IHJlcXVpcmUoJy4uL2RvdGpzL21pbkl0ZW1zJyksXG4gIG1pbmltdW06IHJlcXVpcmUoJy4uL2RvdGpzL21pbmltdW0nKSxcbiAgb25lT2Y6IHJlcXVpcmUoJy4uL2RvdGpzL29uZU9mJyksXG4gIHJlcXVpcmVkOiByZXF1aXJlKCcuLi9kb3Rqcy9yZXF1aXJlZCcpLFxuICBkZXBlbmRlbmNpZXM6IHJlcXVpcmUoJy4uL2RvdGpzL2RlcGVuZGVuY2llcycpLFxuICBpdGVtczogcmVxdWlyZSgnLi4vZG90anMvaXRlbXMnKSxcbiAgbWF4UHJvcGVydGllczogcmVxdWlyZSgnLi4vZG90anMvbWF4UHJvcGVydGllcycpLFxuICBtaW5MZW5ndGg6IHJlcXVpcmUoJy4uL2RvdGpzL21pbkxlbmd0aCcpLFxuICBtdWx0aXBsZU9mOiByZXF1aXJlKCcuLi9kb3Rqcy9tdWx0aXBsZU9mJyksXG4gIHBhdHRlcm46IHJlcXVpcmUoJy4uL2RvdGpzL3BhdHRlcm4nKSxcbiAgdW5pcXVlSXRlbXM6IHJlcXVpcmUoJy4uL2RvdGpzL3VuaXF1ZUl0ZW1zJyksXG4gIGFsbE9mOiByZXF1aXJlKCcuLi9kb3Rqcy9hbGxPZicpLFxuICBlbnVtOiByZXF1aXJlKCcuLi9kb3Rqcy9lbnVtJyksXG4gIG1heEl0ZW1zOiByZXF1aXJlKCcuLi9kb3Rqcy9tYXhJdGVtcycpLFxuICBtYXhpbXVtOiByZXF1aXJlKCcuLi9kb3Rqcy9tYXhpbXVtJyksXG4gIG1pblByb3BlcnRpZXM6IHJlcXVpcmUoJy4uL2RvdGpzL21pblByb3BlcnRpZXMnKSxcbiAgbm90OiByZXF1aXJlKCcuLi9kb3Rqcy9ub3QnKSxcbiAgcHJvcGVydGllczogcmVxdWlyZSgnLi4vZG90anMvcHJvcGVydGllcycpLFxuICB2YWxpZGF0ZTogcmVxdWlyZSgnLi4vZG90anMvdmFsaWRhdGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgYXJyQSA9IEFycmF5LmlzQXJyYXkoYSlcbiAgICAsIGFyckIgPSBBcnJheS5pc0FycmF5KGIpXG4gICAgLCBpO1xuXG4gIGlmIChhcnJBICYmIGFyckIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhcnJBICE9IGFyckIpIHJldHVybiBmYWxzZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKGJba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspXG4gICAgICBpZighZXF1YWwoYVtrZXlzW2ldXSwgYltrZXlzW2ldXSkpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIERBVEUgPSAvXlxcZFxcZFxcZFxcZC0oXFxkXFxkKS0oXFxkXFxkKSQvO1xudmFyIERBWVMgPSBbMCwzMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07XG52YXIgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQ6XFxkXFxkKSQvO1xudmFyIEhPU1ROQU1FID0gL15bYS16XSg/Oig/OlstMC05YS16XXswLDYxfSk/WzAtOWEtel0pPyhcXC5bYS16XSg/Oig/OlstMC05YS16XXswLDYxfSk/WzAtOWEtel0pPykqJC9pO1xudmFyIFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBcXC8/XXwlWzAtOWEtZl17Mn0pKik/KD86XFwjKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBcXC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0cztcblxuZnVuY3Rpb24gZm9ybWF0cyhtb2RlKSB7XG4gIG1vZGUgPSBtb2RlID09ICdmdWxsJyA/ICdmdWxsJyA6ICdmYXN0JztcbiAgcmV0dXJuIHV0aWwuY29weShmb3JtYXRzW21vZGVdKTtcbn1cblxuXG5mb3JtYXRzLmZhc3QgPSB7XG4gIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgZGF0ZTogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLyxcbiAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICdkYXRlLXRpbWUnOiAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0IF1bMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZCg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZDpcXGRcXGQpJC9pLFxuICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gIHVyaTogL14oPzpbYS16XVthLXowLTkrLS5dKik/KD86XFw6fFxcLylcXC8/W15cXHNdKiQvaSxcbiAgLy8gZW1haWwgKHNvdXJjZXMgZnJvbSBqc2VuIHZhbGlkYXRvcik6XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsbGZ1bCB2aW9sYXRpb24nKVxuICBlbWFpbDogL15bYS16MC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pLFxuICBob3N0bmFtZTogSE9TVE5BTUUsXG4gIC8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgLy8gb3B0aW1pemVkIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTM0OTcvcmVndWxhci1leHByZXNzaW9uLXRoYXQtbWF0Y2hlcy12YWxpZC1pcHY2LWFkZHJlc3Nlc1xuICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICByZWdleDogcmVnZXhcbn07XG5cblxuZm9ybWF0cy5mdWxsID0ge1xuICBkYXRlOiBkYXRlLFxuICAnZGF0ZS10aW1lJzogZGF0ZV90aW1lLFxuICB1cmk6IHVyaSxcbiAgZW1haWw6IC9eW2EtejAtOSEjJCUmJyorXFwvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJycqK1xcLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gIGhvc3RuYW1lOiBob3N0bmFtZSxcbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgaXB2NjogL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaSxcbiAgcmVnZXg6IHJlZ2V4XG59O1xuXG5cbmZ1bmN0aW9uIGRhdGUoc3RyKSB7XG4gIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2goREFURSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtb250aCA9ICttYXRjaGVzWzFdO1xuICB2YXIgZGF5ID0gK21hdGNoZXNbMl07XG4gIHJldHVybiBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyICYmIGRheSA+PSAxICYmIGRheSA8PSBEQVlTW21vbnRoXTtcbn1cblxuXG5mdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdmFyIGRhdGVUaW1lID0gc3RyLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3QnKTtcbiAgaWYgKCFkYXRlKGRhdGVUaW1lWzBdKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXRjaGVzID0gZGF0ZVRpbWVbMV0ubWF0Y2goVElNRSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBob3VyID0gbWF0Y2hlc1sxXTtcbiAgdmFyIG1pbnV0ZSA9IG1hdGNoZXNbMl07XG4gIHZhciBzZWNvbmQgPSBtYXRjaGVzWzNdO1xuICByZXR1cm4gaG91ciA8PSAyMyAmJiBtaW51dGUgPD0gNTkgJiYgc2Vjb25kIDw9IDU5O1xufVxuXG5cbmZ1bmN0aW9uIGhvc3RuYW1lKHN0cikge1xuICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMDM0I3NlY3Rpb24tMy41XG4gIHJldHVybiBzdHIubGVuZ3RoIDw9IDI1NSAmJiBIT1NUTkFNRS50ZXN0KHN0cik7XG59XG5cblxudmFyIE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfFxcOi87XG5mdW5jdGlvbiB1cmkoc3RyKSB7XG4gIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpO1xufVxuXG5cbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXNvbHZlID0gcmVxdWlyZSgnLi9yZXNvbHZlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbiAgLCBlcXVhbCA9IHJlcXVpcmUoJy4vZXF1YWwnKTtcblxudHJ5IHsgdmFyIGJlYXV0aWZ5ID0gcmVxdWlyZSgnJyArICdqcy1iZWF1dGlmeScpLmpzX2JlYXV0aWZ5OyB9IGNhdGNoKGUpIHt9XG5cbnZhciBSVUxFUyA9IHJlcXVpcmUoJy4vcnVsZXMnKVxuICAsIHZhbGlkYXRlR2VuZXJhdG9yID0gcmVxdWlyZSgnLi4vZG90anMvdmFsaWRhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hLCByb290LCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlLCBldmlsOiB0cnVlICovXG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgcmVmVmFsID0gWyB1bmRlZmluZWQgXSBcbiAgICAsIHJlZnMgPSB7fVxuICAgICwgcGF0dGVybnMgPSBbXVxuICAgICwgcGF0dGVybnNIYXNoID0ge307XG5cbiAgcm9vdCA9IHJvb3QgfHwgeyBzY2hlbWE6IHNjaGVtYSwgcmVmVmFsOiByZWZWYWwsIHJlZnM6IHJlZnMgfTtcblxuICB2YXIgZm9ybWF0cyA9IHRoaXMuX2Zvcm1hdHM7XG5cbiAgcmV0dXJuIGxvY2FsQ29tcGlsZShzY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcblxuXG4gIGZ1bmN0aW9uIGxvY2FsQ29tcGlsZShfc2NoZW1hLCBfcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpIHtcbiAgICB2YXIgaXNSb290ID0gIV9yb290IHx8IChfcm9vdCAmJiBfcm9vdC5zY2hlbWEgPT0gX3NjaGVtYSk7XG4gICAgaWYgKF9yb290LnNjaGVtYSAhPSByb290LnNjaGVtYSlcbiAgICAgIHJldHVybiBjb21waWxlLmNhbGwoc2VsZiwgX3NjaGVtYSwgX3Jvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcblxuICAgIHZhciB2YWxpZGF0ZUNvZGUgPSB2YWxpZGF0ZUdlbmVyYXRvcih7XG4gICAgICBpc1RvcDogdHJ1ZSxcbiAgICAgIHNjaGVtYTogX3NjaGVtYSxcbiAgICAgIGlzUm9vdDogaXNSb290LFxuICAgICAgYmFzZUlkOiBiYXNlSWQsXG4gICAgICByb290OiBfcm9vdCxcbiAgICAgIHNjaGVtYVBhdGg6ICcnLFxuICAgICAgZXJyb3JQYXRoOiAnXCJcIicsXG4gICAgICBSVUxFUzogUlVMRVMsXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVHZW5lcmF0b3IsXG4gICAgICB1dGlsOiB1dGlsLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIHJlc29sdmVSZWY6IHJlc29sdmVSZWYsXG4gICAgICB1c2VQYXR0ZXJuOiB1c2VQYXR0ZXJuLFxuICAgICAgb3B0czogc2VsZi5vcHRzLFxuICAgICAgZm9ybWF0czogZm9ybWF0c1xuICAgIH0pO1xuXG4gICAgdmFsaWRhdGVDb2RlID0gcmVmc0NvZGUocmVmVmFsKSArIHBhdHRlcm5zQ29kZShwYXR0ZXJucykgKyB2YWxpZGF0ZUNvZGU7XG5cbiAgICBpZiAoc2VsZi5vcHRzLmJlYXV0aWZ5KSB7XG4gICAgICB2YXIgb3B0cyA9IHNlbGYub3B0cy5iZWF1dGlmeSA9PT0gdHJ1ZSA/IHsgaW5kZW50X3NpemU6IDIgfSA6IHNlbGYub3B0cy5iZWF1dGlmeTtcbiAgICAgIGlmIChiZWF1dGlmeSkgdmFsaWRhdGVDb2RlID0gYmVhdXRpZnkodmFsaWRhdGVDb2RlLCBvcHRzKTtcbiAgICAgIGVsc2UgY29uc29sZS5lcnJvcignXCJucG0gaW5zdGFsbCBqcy1iZWF1dGlmeVwiIHRvIHVzZSBiZWF1dGlmeSBvcHRpb24nKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ1xcblxcblxcbiAqKiogXFxuJywgdmFsaWRhdGVDb2RlKTtcbiAgICB2YXIgdmFsaWRhdGU7XG4gICAgLy8gdHJ5IHtcbiAgICAgIGV2YWwodmFsaWRhdGVDb2RlKTtcbiAgICAgIHJlZlZhbFswXSA9IHZhbGlkYXRlO1xuICAgIC8vIH0gY2F0Y2goZSkge1xuICAgIC8vICAgY29uc29sZS5sb2coJ0Vycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6JywgdmFsaWRhdGVDb2RlKTtcbiAgICAvLyAgIHRocm93IGU7XG4gICAgLy8gfVxuXG4gICAgdmFsaWRhdGUuc2NoZW1hID0gX3NjaGVtYTtcbiAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgIHZhbGlkYXRlLnJlZnMgPSByZWZzO1xuICAgIHZhbGlkYXRlLnJlZlZhbCA9IHJlZlZhbDtcbiAgICB2YWxpZGF0ZS5yb290ID0gaXNSb290ID8gdmFsaWRhdGUgOiBfcm9vdDtcblxuICAgIHJldHVybiB2YWxpZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWYoYmFzZUlkLCByZWYsIGlzUm9vdCkge1xuICAgIHJlZiA9IHJlc29sdmUudXJsKGJhc2VJZCwgcmVmKTtcbiAgICB2YXIgcmVmSW5kZXggPSByZWZzW3JlZl07XG4gICAgdmFyIF9yZWZWYWwsIHJlZkNvZGU7XG4gICAgaWYgKHJlZkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF9yZWZWYWwgPSByZWZWYWxbcmVmSW5kZXhdO1xuICAgICAgcmVmQ29kZSA9ICdyZWZWYWxbJyArIHJlZkluZGV4ICsgJ10nO1xuICAgICAgcmV0dXJuIHJlc29sdmVkUmVmKF9yZWZWYWwsIHJlZkNvZGUpO1xuICAgIH1cbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdmFyIHJvb3RSZWZJZCA9IHJvb3QucmVmc1tyZWZdO1xuICAgICAgaWYgKHJvb3RSZWZJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9yZWZWYWwgPSByb290LnJlZlZhbFtyb290UmVmSWRdO1xuICAgICAgICByZWZDb2RlID0gYWRkTG9jYWxSZWYocmVmLCBfcmVmVmFsKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUmVmKF9yZWZWYWwsIHJlZkNvZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYpO1xuICAgIHZhciB2ID0gcmVzb2x2ZS5jYWxsKHNlbGYsIGxvY2FsQ29tcGlsZSwgcm9vdCwgcmVmKTtcbiAgICBpZiAoIXYpIHtcbiAgICAgIHZhciBsb2NhbFNjaGVtYSA9IGxvY2FsUmVmcyAmJiBsb2NhbFJlZnNbcmVmXTtcbiAgICAgIGlmIChsb2NhbFNjaGVtYSkge1xuICAgICAgICB2ID0gcmVzb2x2ZS5pbmxpbmVSZWYobG9jYWxTY2hlbWEsIHNlbGYub3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICAgICAgPyBsb2NhbFNjaGVtYVxuICAgICAgICAgICAgOiBjb21waWxlLmNhbGwoc2VsZiwgbG9jYWxTY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodikge1xuICAgICAgcmVwbGFjZUxvY2FsUmVmKHJlZiwgdik7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRSZWYodiwgcmVmQ29kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTG9jYWxSZWYocmVmLCB2KSB7XG4gICAgdmFyIHJlZklkID0gcmVmVmFsLmxlbmd0aDtcbiAgICByZWZWYWxbcmVmSWRdID0gdjtcbiAgICByZWZzW3JlZl0gPSByZWZJZDtcbiAgICByZXR1cm4gJ3JlZlZhbCcgKyByZWZJZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VMb2NhbFJlZihyZWYsIHYpIHtcbiAgICB2YXIgcmVmSWQgPSByZWZzW3JlZl07XG4gICAgcmVmVmFsW3JlZklkXSA9IHY7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlZFJlZihzY2hlbWEsIGNvZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyB7IHNjaGVtYTogc2NoZW1hLCBjb2RlOiBjb2RlIH1cbiAgICAgICAgICAgIDogY29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZVBhdHRlcm4ocmVnZXhTdHIpIHtcbiAgICB2YXIgaW5kZXggPSBwYXR0ZXJuc0hhc2hbcmVnZXhTdHJdO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IHBhdHRlcm5zSGFzaFtyZWdleFN0cl0gPSBwYXR0ZXJucy5sZW5ndGg7XG4gICAgICBwYXR0ZXJuc1tpbmRleF0gPSByZWdleFN0cjtcbiAgICB9XG4gICAgcmV0dXJuICdwYXR0ZXJuJyArIGluZGV4O1xuICB9XG59XG5cblxuZnVuY3Rpb24gcGF0dGVybnNDb2RlKHBhdHRlcm5zKSB7XG4gIHJldHVybiBfYXJyQ29kZShwYXR0ZXJucywgcGF0dGVybkNvZGUpO1xufVxuXG5cbmZ1bmN0aW9uIHBhdHRlcm5Db2RlKGksIHBhdHRlcm5zKSB7XG4gIHJldHVybiAndmFyIHBhdHRlcm4nICsgaSArICcgPSBuZXcgUmVnRXhwKCcgKyB1dGlsLnRvUXVvdGVkU3RyaW5nKHBhdHRlcm5zW2ldKSArICcpOyc7XG59XG5cblxuZnVuY3Rpb24gcmVmc0NvZGUocmVmVmFsKSB7XG4gIHJldHVybiBfYXJyQ29kZShyZWZWYWwsIHJlZkNvZGUpO1xufVxuXG5cbmZ1bmN0aW9uIHJlZkNvZGUoaSwgcmVmVmFsKSB7XG4gIHJldHVybiByZWZWYWxbaV0gPyAndmFyIHJlZlZhbCcgKyBpICsgJyA9IHJlZlZhbFsnICsgaSArICddOycgOiAnJztcbn1cblxuXG5mdW5jdGlvbiBfYXJyQ29kZShhcnIsIHN0YXRlbWVudCkge1xuICBpZiAoIWFyci5sZW5ndGgpIHJldHVybiAnJztcbiAgdmFyIGNvZGUgPSAnJztcbiAgZm9yICh2YXIgaT0wOyBpPGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2RlICs9IHN0YXRlbWVudChpLCBhcnIpO1xuICByZXR1cm4gY29kZTtcbn1cblxuXG4vKipcbiAqIEZ1bmN0aW9ucyBiZWxvdyBhcmUgdXNlZCBpbnNpZGUgY29tcGlsZWQgdmFsaWRhdGlvbnMgZnVuY3Rpb25cbiAqL1xuXG52YXIgdWNzMmxlbmd0aCA9IHV0aWwudWNzMmxlbmd0aDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG4gICwgZXF1YWwgPSByZXF1aXJlKCcuL2VxdWFsJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbiAgLCBTY2hlbWFPYmplY3QgPSByZXF1aXJlKCcuL3NjaGVtYV9vYmonKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlO1xuXG5yZXNvbHZlLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG5yZXNvbHZlLmZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5yZXNvbHZlLnVybCA9IHJlc29sdmVVcmw7XG5yZXNvbHZlLmlkcyA9IHJlc29sdmVJZHM7XG5yZXNvbHZlLmlubGluZVJlZiA9IGlubGluZVJlZjtcblxuZnVuY3Rpb24gcmVzb2x2ZShjb21waWxlLCByb290LCByZWYpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZdO1xuICBpZiAodHlwZW9mIHJlZlZhbCA9PSAnc3RyaW5nJykge1xuICAgIGlmICh0aGlzLl9yZWZzW3JlZlZhbF0pIHJlZlZhbCA9IHRoaXMuX3JlZnNbcmVmVmFsXTtcbiAgICBlbHNlIHJldHVybiByZXNvbHZlLmNhbGwodGhpcywgY29tcGlsZSwgcm9vdCwgcmVmVmFsKTtcbiAgfVxuICBcbiAgcmVmVmFsID0gcmVmVmFsIHx8IHRoaXMuX3NjaGVtYXNbcmVmXTtcbiAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdClcbiAgICByZXR1cm4gaW5saW5lUmVmKHJlZlZhbC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICAgICAgPyByZWZWYWwuc2NoZW1hXG4gICAgICAgICAgICA6IHJlZlZhbC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG5cbiAgdmFyIHJlcyA9IF9yZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgdmFyIHNjaGVtYSwgdiwgYmFzZUlkO1xuICBpZiAocmVzKSB7XG4gICAgc2NoZW1hID0gcmVzLnNjaGVtYTtcbiAgICByb290ID0gcmVzLnJvb3Q7XG4gICAgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgfVxuXG4gIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpXG4gICAgdiA9IHNjaGVtYS52YWxpZGF0ZSB8fCBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLnNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICBlbHNlIGlmIChzY2hlbWEpXG4gICAgdiA9IGlubGluZVJlZihzY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICA/IHNjaGVtYVxuICAgICAgICA6IGNvbXBpbGUuY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIHVuZGVmaW5lZCwgYmFzZUlkKTtcblxuICByZXR1cm4gdjtcbn1cblxuXG5mdW5jdGlvbiBfcmVzb2x2ZShyb290LCByZWYpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgcCA9IHVybC5wYXJzZShyZWYsIGZhbHNlLCB0cnVlKVxuICAgICwgcmVmUGF0aCA9IF9nZXRGdWxsUGF0aChwKVxuICAgICwgYmFzZUlkID0gZ2V0RnVsbFBhdGgocm9vdC5zY2hlbWEuaWQpO1xuICBpZiAocmVmUGF0aCAhPT0gYmFzZUlkKSB7XG4gICAgdmFyIGlkID0gbm9ybWFsaXplSWQocmVmUGF0aCk7XG4gICAgdmFyIHJlZlZhbCA9IHRoaXMuX3JlZnNbaWRdO1xuICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVJlY3Vyc2l2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZlZhbCwgcCk7XG4gICAgfSBlbHNlIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKSB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gICAgICByb290ID0gcmVmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZWYWwgPSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgICAgaWYgKCFyZWZWYWwudmFsaWRhdGUpIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgICAgaWYgKGlkID09IG5vcm1hbGl6ZUlkKHJlZikpXG4gICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiByZWZWYWwsIHJvb3Q6IHJvb3QsIGJhc2VJZDogYmFzZUlkIH07XG4gICAgICAgIHJvb3QgPSByZWZWYWw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcm9vdC5zY2hlbWEpIHJldHVybjtcbiAgICBiYXNlSWQgPSBnZXRGdWxsUGF0aChyb290LnNjaGVtYS5pZCk7XG4gIH1cbiAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgYmFzZUlkLCByb290LnNjaGVtYSwgcm9vdCk7XG59XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY3Vyc2l2ZShyb290LCByZWYsIHBhcnNlZFJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZXMgPSBfcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gIGlmIChyZXMpIHtcbiAgICB2YXIgc2NoZW1hID0gcmVzLnNjaGVtYTtcbiAgICB2YXIgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICByb290ID0gcmVzLnJvb3Q7XG4gICAgaWYgKHNjaGVtYS5pZCkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS5pZCk7XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCk7XG4gIH1cbn1cblxuXG52YXIgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSB1dGlsLnRvSGFzaChbJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZW51bSddKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgYmFzZUlkLCBzY2hlbWEsIHJvb3QpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICBwYXJzZWRSZWYuaGFzaCA9IHBhcnNlZFJlZi5oYXNoIHx8ICcnO1xuICBpZiAocGFyc2VkUmVmLmhhc2guc2xpY2UoMCwyKSAhPSAnIy8nKSByZXR1cm47XG4gIHZhciBwYXJ0cyA9IHBhcnNlZFJlZi5oYXNoLnNwbGl0KCcvJyk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQgPSB1bmVzY2FwZUZyYWdtZW50KHBhcnQpO1xuICAgICAgc2NoZW1hID0gc2NoZW1hW3BhcnRdO1xuICAgICAgaWYgKCFzY2hlbWEpIGJyZWFrO1xuICAgICAgaWYgKHNjaGVtYS5pZCAmJiAhUFJFVkVOVF9TQ09QRV9DSEFOR0VbcGFydF0pIGJhc2VJZCA9IHJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuaWQpO1xuICAgICAgaWYgKHNjaGVtYS4kcmVmKSB7XG4gICAgICAgIHZhciAkcmVmID0gcmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgdmFyIHJlcyA9IF9yZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgJHJlZik7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgICAgICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2NoZW1hICYmIHNjaGVtYSAhPSByb290LnNjaGVtYSlcbiAgICByZXR1cm4geyBzY2hlbWE6IHNjaGVtYSwgcm9vdDogcm9vdCwgYmFzZUlkOiBiYXNlSWQgfTtcbn1cblxuXG52YXIgU0lNUExFX0lOTElORUQgPSB1dGlsLnRvSGFzaChbXG4gICd0eXBlJywgJ2Zvcm1hdCcsICdwYXR0ZXJuJyxcbiAgJ21heExlbmd0aCcsICdtaW5MZW5ndGgnLFxuICAnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJyxcbiAgJ21heEl0ZW1zJywgJ21pbkl0ZW1zJyxcbiAgJ21heGltdW0nLCAnbWluaW11bScsXG4gICd1bmlxdWVJdGVtcycsICdtdWx0aXBsZU9mJyxcbiAgJ3JlcXVpcmVkJywgJ2VudW0nIFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCkge1xuICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNoZWNrTm9SZWYoc2NoZW1hKTtcbiAgZWxzZSBpZiAobGltaXQpIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbn1cblxuXG5mdW5jdGlvbiBjaGVja05vUmVmKHNjaGVtYSkge1xuICB2YXIgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcgJiYgIWNoZWNrTm9SZWYoaXRlbSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgaWYgKGtleSA9PSAnJHJlZicpIHJldHVybiBmYWxzZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpdGVtID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hKSB7XG4gIHZhciBjb3VudCA9IDAsIGl0ZW07XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8c2NoZW1hLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtID0gc2NoZW1hW2ldO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSBjb3VudCArPSBjb3VudEtleXMoaXRlbSk7XG4gICAgICBpZiAoY291bnQgPT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgaWYgKGtleSA9PSAnJHJlZicpIHJldHVybiBJbmZpbml0eTtcbiAgICAgIGlmIChTSU1QTEVfSU5MSU5FRFtrZXldKSBjb3VudCsrO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSBjb3VudCArPSBjb3VudEtleXMoaXRlbSkgKyAxO1xuICAgICAgICBpZiAoY291bnQgPT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5cbmZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgICAgICAgIC5yZXBsYWNlKC9+MS9nLCAnLycpXG4gICAgICAgICAgLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpO1xufVxuXG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkLCBub3JtYWxpemUpIHtcbiAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICB2YXIgcCA9IHVybC5wYXJzZShpZCwgZmFsc2UsIHRydWUpO1xuICByZXR1cm4gX2dldEZ1bGxQYXRoKHApO1xufVxuXG5cbmZ1bmN0aW9uIF9nZXRGdWxsUGF0aChwKSB7XG4gIHJldHVybiAocC5wcm90b2NvbHx8JycpICsgKHAucHJvdG9jb2w/Jy8vJzonJykgKyAocC5ob3N0fHwnJykgKyAocC5wYXRofHwnJykgICsgJyMnO1xufVxuXG5cbnZhciBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgJycpIDogJyc7XG59XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlSWQsIGlkKSB7XG4gIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICByZXR1cm4gdXJsLnJlc29sdmUoYmFzZUlkLCBpZCk7XG59XG5cblxuZnVuY3Rpb24gcmVzb2x2ZUlkcyhzY2hlbWEpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICB2YXIgaWQgPSBub3JtYWxpemVJZChzY2hlbWEuaWQpO1xuICB2YXIgbG9jYWxSZWZzID0ge307XG4gIF9yZXNvbHZlSWRzLmNhbGwodGhpcywgc2NoZW1hLCBnZXRGdWxsUGF0aChpZCwgZmFsc2UpLCBpZCk7XG4gIHJldHVybiBsb2NhbFJlZnM7XG5cbiAgZnVuY3Rpb24gX3Jlc29sdmVJZHMoc2NoZW1hLCBmdWxsUGF0aCwgYmFzZUlkKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2NoZW1hLmxlbmd0aDsgaSsrKVxuICAgICAgICBfcmVzb2x2ZUlkcy5jYWxsKHRoaXMsIHNjaGVtYVtpXSwgZnVsbFBhdGgrJy8nK2ksIGJhc2VJZCk7XG4gICAgZWxzZSBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmlkID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpZCA9IGJhc2VJZCA9IGJhc2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVybC5yZXNvbHZlKGJhc2VJZCwgc2NoZW1hLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZUlkKHNjaGVtYS5pZCk7XG5cbiAgICAgICAgdmFyIHJlZlZhbCA9IHRoaXMuX3JlZnNbaWRdO1xuICAgICAgICBpZiAodHlwZW9mIHJlZlZhbCA9PSAnc3RyaW5nJykgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgICAgICBpZiAocmVmVmFsICYmIHJlZlZhbC5zY2hlbWEpIHtcbiAgICAgICAgICBpZiAoIWVxdWFsKHNjaGVtYSwgcmVmVmFsLnNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIFwiJyArIGlkICsgJ1wiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaWQgIT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgaWYgKGlkWzBdID09ICcjJykge1xuICAgICAgICAgICAgaWYgKGxvY2FsUmVmc1tpZF0gJiYgIWVxdWFsKHNjaGVtYSwgbG9jYWxSZWZzW2lkXSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgICAgIGxvY2FsUmVmc1tpZF0gPSBzY2hlbWE7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB0aGlzLl9yZWZzW2lkXSA9IGZ1bGxQYXRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKVxuICAgICAgICBfcmVzb2x2ZUlkcy5jYWxsKHRoaXMsIHNjaGVtYVtrZXldLCBmdWxsUGF0aCsnLycrZXNjYXBlRnJhZ21lbnQoa2V5KSwgYmFzZUlkKTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJ1bGVNb2R1bGVzID0gcmVxdWlyZSgnLi9fcnVsZXMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIFJVTEVTID0gbW9kdWxlLmV4cG9ydHMgPSBbXG4gIHsgdHlwZTogJ251bWJlcicsXG4gICAgcnVsZXM6IFsgJ21heGltdW0nLCAnbWluaW11bScsICdtdWx0aXBsZU9mJ10gfSxcbiAgeyB0eXBlOiAnc3RyaW5nJyxcbiAgICBydWxlczogWyAnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsICdwYXR0ZXJuJywgJ2Zvcm1hdCcgXSB9LFxuICB7IHR5cGU6ICdhcnJheScsXG4gICAgcnVsZXM6IFsgJ21heEl0ZW1zJywgJ21pbkl0ZW1zJywgJ3VuaXF1ZUl0ZW1zJywgJ2l0ZW1zJyBdIH0sXG4gIHsgdHlwZTogJ29iamVjdCcsXG4gICAgcnVsZXM6IFsgJ21heFByb3BlcnRpZXMnLCAnbWluUHJvcGVydGllcycsICdyZXF1aXJlZCcsICdkZXBlbmRlbmNpZXMnLCAncHJvcGVydGllcycgXSB9LFxuICB7IHJ1bGVzOiBbICckcmVmJywgJ2VudW0nLCAnbm90JywgJ2FueU9mJywgJ29uZU9mJywgJ2FsbE9mJyBdIH1cbl07XG5cblJVTEVTLmFsbCA9IFsgJ3R5cGUnLCAnYWRkaXRpb25hbFByb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnIF07XG5cblxuUlVMRVMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgZ3JvdXAucnVsZXMgPSBncm91cC5ydWxlcy5tYXAoZnVuY3Rpb24gKGtleXdvcmQpIHtcbiAgICBSVUxFUy5hbGwucHVzaChrZXl3b3JkKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5d29yZDoga2V5d29yZCxcbiAgICAgIGNvZGU6IHJ1bGVNb2R1bGVzW2tleXdvcmRdXG4gICAgfTtcbiAgfSk7XG59KTtcblxuUlVMRVMuYWxsID0gdXRpbC50b0hhc2goUlVMRVMuYWxsKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3Q7XG5cbmZ1bmN0aW9uIFNjaGVtYU9iamVjdChvYmopIHtcbiAgICB1dGlsLmNvcHkob2JqLCB0aGlzKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogY29weSxcbiAgY2hlY2tEYXRhVHlwZTogY2hlY2tEYXRhVHlwZSxcbiAgY2hlY2tEYXRhVHlwZXM6IGNoZWNrRGF0YVR5cGVzLFxuICB0b0hhc2g6IHRvSGFzaCxcbiAgZ2V0UHJvcGVydHk6IGdldFByb3BlcnR5LFxuICBlc2NhcGVRdW90ZXM6IGVzY2FwZVF1b3RlcyxcbiAgdWNzMmxlbmd0aDogdWNzMmxlbmd0aCxcbiAgdmFyT2NjdXJlbmNlczogdmFyT2NjdXJlbmNlcyxcbiAgdmFyUmVwbGFjZTogdmFyUmVwbGFjZSxcbiAgY2xlYW5VcENvZGU6IGNsZWFuVXBDb2RlLFxuICBjbGVhblVwVmFyRXJyb3JzOiBjbGVhblVwVmFyRXJyb3JzLFxuICBzY2hlbWFIYXNSdWxlczogc2NoZW1hSGFzUnVsZXMsXG4gIHN0YWJsZVN0cmluZ2lmeTogcmVxdWlyZSgnanNvbi1zdGFibGUtc3RyaW5naWZ5JyksXG4gIHRvUXVvdGVkU3RyaW5nOiB0b1F1b3RlZFN0cmluZyxcbiAgZ2V0UGF0aEV4cHI6IGdldFBhdGhFeHByLFxuICBnZXRQYXRoOiBnZXRQYXRoXG59O1xuXG5cbmZ1bmN0aW9uIGNvcHkobywgdG8pIHtcbiAgdG8gPSB0byB8fCB7fTtcbiAgZm9yICh2YXIga2V5IGluIG8pIHRvW2tleV0gPSBvW2tleV07XG4gIHJldHVybiB0bztcbn1cblxuXG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBuZWdhdGUpIHtcbiAgdmFyIEVRVUFMID0gbmVnYXRlID8gJyAhPT0gJyA6ICcgPT09ICdcbiAgICAsIEFORCA9IG5lZ2F0ZSA/ICcgfHwgJyA6ICcgJiYgJ1xuICAgICwgT0sgPSBuZWdhdGUgPyAnIScgOiAnJ1xuICAgICwgTk9UID0gbmVnYXRlID8gJycgOiAnISc7XG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlICdudWxsJzogcmV0dXJuIGRhdGEgKyBFUVVBTCArICdudWxsJztcbiAgICBjYXNlICdhcnJheSc6IHJldHVybiBPSyArICdBcnJheS5pc0FycmF5KCcgKyBkYXRhICsgJyknO1xuICAgIGNhc2UgJ29iamVjdCc6IHJldHVybiAnKCcgKyBPSyArIGRhdGEgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCJvYmplY3RcIicgKyBBTkQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBOT1QgKyAnQXJyYXkuaXNBcnJheSgnICsgZGF0YSArICcpKSc7XG4gICAgY2FzZSAnaW50ZWdlcic6IHJldHVybiAnKHR5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wibnVtYmVyXCInICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIE5PVCArICcoJyArIGRhdGEgKyAnICUgMSkpJztcbiAgICBkZWZhdWx0OiByZXR1cm4gJ3R5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wiJyArIGRhdGFUeXBlICsgJ1wiJztcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKGRhdGFUeXBlcywgZGF0YSkge1xuICBzd2l0Y2ggKGRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgdHJ1ZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICB2YXIgdHlwZXMgPSB0b0hhc2goZGF0YVR5cGVzKTtcbiAgICAgIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICAgICAgY29kZSA9IHR5cGVzLm51bGwgPyAnKCc6ICcoIScgKyBkYXRhICsgJyB8fCAnO1xuICAgICAgICBjb2RlICs9ICd0eXBlb2YgJyArIGRhdGEgKyAnICE9PSBcIm9iamVjdFwiKSc7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5udWxsO1xuICAgICAgICBkZWxldGUgdHlwZXMuYXJyYXk7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5vYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAodHlwZXMubnVtYmVyKSBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICAgIGZvciAodmFyIHQgaW4gdHlwZXMpXG4gICAgICAgIGNvZGUgKz0gKGNvZGUgPyAnICYmICcgOiAnJyApICsgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIGNvZGU7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gIHZhciBoYXNoID0ge307XG4gIGZvciAodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gIHJldHVybiBoYXNoO1xufVxuXG5cbnZhciBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG52YXIgU0lOR0xFX1FVT1RFID0gLyd8XFxcXC9nO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBJREVOVElGSUVSLnRlc3Qoa2V5KVxuICAgICAgICAgID8gJy4nICsga2V5XG4gICAgICAgICAgOiBcIlsnXCIgKyBrZXkucmVwbGFjZShTSU5HTEVfUVVPVEUsICdcXFxcJCYnKSArIFwiJ11cIjtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShTSU5HTEVfUVVPVEUsICdcXFxcJCYnKTtcbn1cblxuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gIHZhciBsZW5ndGggPSAwXG4gICAgLCBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBwb3MgPSAwXG4gICAgLCB2YWx1ZTtcbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGxlbmd0aCsrO1xuICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIHBvcyA8IGxlbikge1xuICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoKHZhbHVlICYgMHhGQzAwKSA9PSAweERDMDApIHBvcysrOyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cblxuZnVuY3Rpb24gdmFyT2NjdXJlbmNlcyhzdHIsIGRhdGFWYXIpIHtcbiAgZGF0YVZhciArPSAnW14wLTldJztcbiAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2gobmV3IFJlZ0V4cChkYXRhVmFyLCAnZycpKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzLmxlbmd0aCA6IDA7XG59XG5cblxuZnVuY3Rpb24gdmFyUmVwbGFjZShzdHIsIGRhdGFWYXIsIGV4cHIpIHtcbiAgZGF0YVZhciArPSAnKFteMC05XSknO1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChkYXRhVmFyLCAnZycpLCBleHByICsgJyQxJyk7XG59XG5cblxudmFyIEVNUFRZX0VMU0UgPSAvZWxzZVxccyp7XFxzKn0vZ1xuICAsIEVNUFRZX0lGX05PX0VMU0UgPSAvaWZcXHMqXFwoW14pXStcXClcXHMqXFx7XFxzKlxcfSg/IVxccyplbHNlKS9nXG4gICwgRU1QVFlfSUZfV0lUSF9FTFNFID0gL2lmXFxzKlxcKChbXildKylcXClcXHMqXFx7XFxzKlxcfVxccyplbHNlKD8hXFxzKmlmKS9nO1xuZnVuY3Rpb24gY2xlYW5VcENvZGUob3V0KSB7XG4gIHJldHVybiBvdXQucmVwbGFjZShFTVBUWV9FTFNFLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX0lGX05PX0VMU0UsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoRU1QVFlfSUZfV0lUSF9FTFNFLCAnaWYgKCEoJDEpKScpO1xufVxuXG5cbnZhciBFUlJPUlNfUkVHRVhQID0gL1tedlxcLl1lcnJvcnMvZ1xuICAsIFJFTU9WRV9FUlJPUlMgPSAvdmFyIGVycm9ycyA9IDA7fHZhciB2RXJyb3JzID0gbnVsbDt8dmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsvZ1xuICAsIFJFVFVSTl9WQUxJRCA9ICdyZXR1cm4gZXJyb3JzID09PSAwOydcbiAgLCBSRVRVUk5fVFJVRSA9ICd2YWxpZGF0ZS5lcnJvcnMgPSBudWxsOyByZXR1cm4gdHJ1ZTsnO1xuXG5mdW5jdGlvbiBjbGVhblVwVmFyRXJyb3JzKG91dCkge1xuICB2YXIgbWF0Y2hlcyA9IG91dC5tYXRjaChFUlJPUlNfUkVHRVhQKTtcbiAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuIG91dC5yZXBsYWNlKFJFTU9WRV9FUlJPUlMsICcnKVxuICAgICAgICAgICAgICAucmVwbGFjZShSRVRVUk5fVkFMSUQsIFJFVFVSTl9UUlVFKTtcbiAgZWxzZVxuICAgIHJldHVybiBvdXQ7XG59XG5cblxuZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBydWxlcykge1xuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSBpZiAocnVsZXNba2V5XSkgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gdG9RdW90ZWRTdHJpbmcgKHN0cikge1xuICByZXR1cm4gJ1xcJycgKyBlc2NhcGVRdW90ZXMoc3RyKSArICdcXCcnO1xufVxuXG5cbmZ1bmN0aW9uIGdldFBhdGhFeHByIChjdXJyZW50UGF0aCwgZXhwciwganNvblBvaW50ZXJzLCBpc051bWJlcikge1xuICB2YXIgcGF0aCA9IGpzb25Qb2ludGVyc1xuICAgICAgICAgICAgICA/ICdcXCcvXFwnICsgJyArIGV4cHIgKyAoaXNOdW1iZXIgPyAnJyA6ICcucmVwbGFjZSgvfi9nLCBcXCd+MFxcJykucmVwbGFjZSgvXFxcXC8vZywgXFwnfjFcXCcpJylcbiAgICAgICAgICAgICAgOiAoaXNOdW1iZXIgPyAnXFwnW1xcJyArICcgKyBleHByICsgJyArIFxcJ11cXCcnIDogJ1xcJ1tcXFxcXFwnXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXFxcXFxcJ11cXCcnKTtcbiAgcmV0dXJuIGpvaW5QYXRocyhjdXJyZW50UGF0aCwgcGF0aCk7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aCAoY3VycmVudFBhdGgsIHByb3AsIGpzb25Qb2ludGVycykge1xuICB2YXIgcGF0aCA9IGpzb25Qb2ludGVyc1xuICAgICAgICAgICAgICA/IHRvUXVvdGVkU3RyaW5nKCcvJyArIHByb3AucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJykpXG4gICAgICAgICAgICAgIDogdG9RdW90ZWRTdHJpbmcoZ2V0UHJvcGVydHkocHJvcCkpO1xuICByZXR1cm4gam9pblBhdGhzKGN1cnJlbnRQYXRoLCBwYXRoKTtcbn1cblxuXG5mdW5jdGlvbiBqb2luUGF0aHMgKGEsIGIpIHtcbiAgaWYgKGEgPT0gJ1wiXCInKSByZXR1cm4gYjtcbiAgcmV0dXJuIChhICsgJyArICcgKyBiKS5yZXBsYWNlKC8nIFxcKyAnL2csICcnKTtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYWxsT2YoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydhbGxPZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdhbGxPZicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpLFxuICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gIGlmIChhcnIxKSB7XG4gICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgIG91dCArPSAnICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICc7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMuc2xpY2UoMCwgLTEpKTtcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2FueU9mKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnYW55T2YnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnYW55T2YnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KSxcbiAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRub0VtcHR5U2NoZW1hID0gJHNjaGVtYS5ldmVyeShmdW5jdGlvbigkc2NoKSB7XG4gICAgcmV0dXJuIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKTtcbiAgfSk7XG4gIGlmICgkbm9FbXB0eVNjaGVtYSkge1xuICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7IHZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICAnO1xuICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgIG91dCArPSAnICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCR2YWxpZCkgKyAnIHx8IHZhbGlkJyArICgkaXQubGV2ZWwpICsgJzsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ2FueU9mJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBzb21lIHNjaGVtYSBpbiBhbnlPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gZWxzZSB7IGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gJztcbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gICAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9kZXBlbmRlbmNpZXMoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydkZXBlbmRlbmNpZXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnZGVwZW5kZW5jaWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkc2NoZW1hRGVwcyA9IHt9LFxuICAgICRwcm9wZXJ0eURlcHMgPSB7fTtcbiAgZm9yICgkcHJvcGVydHkgaW4gJHNjaGVtYSkge1xuICAgIHZhciAkc2NoID0gJHNjaGVtYVskcHJvcGVydHldO1xuICAgIHZhciAkZGVwcyA9IEFycmF5LmlzQXJyYXkoJHNjaCkgPyAkcHJvcGVydHlEZXBzIDogJHNjaGVtYURlcHM7XG4gICAgJGRlcHNbJHByb3BlcnR5XSA9ICRzY2g7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyc7XG4gIGZvciAodmFyICRwcm9wZXJ0eSBpbiAkcHJvcGVydHlEZXBzKSB7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJGRhdGEpICsgKGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5KSkgKyAnICE9PSB1bmRlZmluZWQpIHsgJztcbiAgICAkZGVwcyA9ICRwcm9wZXJ0eURlcHNbJHByb3BlcnR5XTtcbiAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgdmFyIGFycjEgPSAkZGVwcztcbiAgICBpZiAoYXJyMSkge1xuICAgICAgdmFyICRkZXAsICRpID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgJGRlcCA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgIGlmICgkaSkge1xuICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgJyArICgkZGF0YSkgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkZGVwKSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9ICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBoYXZlICc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAncHJvcGVydGllcyAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIHdoZW4gcHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICcgaXMgcHJlc2VudFxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG46ICcgKyAoJGRlcHMubGVuZ3RoKSArICcsIGRlcHM6IFxcJyc7XG4gICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJ1xcJywgcHJvcGVydHk6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnZGVwZW5kZW5jaWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgaGF2ZSAnO1xuICAgICAgICBpZiAoJGRlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBvdXQgKz0gJ3Byb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJ3Byb3BlcnRpZXMgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB3aGVuIHByb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnIGlzIHByZXNlbnRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBuOiAnICsgKCRkZXBzLmxlbmd0aCkgKyAnLCBkZXBzOiBcXCcnO1xuICAgICAgICBpZiAoJGRlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICdcXCcsIHByb3BlcnR5OiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJ1xcJyB9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICAgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0nO1xuICB9XG4gIGZvciAodmFyICRwcm9wZXJ0eSBpbiAkc2NoZW1hRGVwcykge1xuICAgIHZhciAkc2NoID0gJHNjaGVtYURlcHNbJHByb3BlcnR5XTtcbiAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnW1xcJycgKyAoJHByb3BlcnR5KSArICdcXCddICE9PSB1bmRlZmluZWQpIHsgJztcbiAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5KTtcbiAgICAgIG91dCArPSAnICcgKyAoaXQudmFsaWRhdGUoJGl0KSkgKyAnIH0gICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAgICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9lbnVtKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnZW51bSddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdlbnVtJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpID0gJ2knICsgJGx2bDtcbiAgb3V0ICs9ICd2YXIgZW51bVNjaGVtYScgKyAoJGx2bCkgKyAnID0gdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlO2ZvciAodmFyICcgKyAoJGkpICsgJz0wOyAnICsgKCRpKSArICc8ZW51bVNjaGVtYScgKyAoJGx2bCkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIGlmIChlcXVhbCgnICsgKCRkYXRhKSArICcsIGVudW1TY2hlbWEnICsgKCRsdmwpICsgJ1snICsgKCRpKSArICddKSkgeyAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgYnJlYWs7IH0gaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdlbnVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBlcXVhbCB0byBvbmUgb2YgdmFsdWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ2VudW0nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlIGVxdWFsIHRvIG9uZSBvZiB2YWx1ZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0nO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2Zvcm1hdChpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2Zvcm1hdCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdmb3JtYXQnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICB2YXIgJGZvcm1hdCA9IGl0LmZvcm1hdHNbJHNjaGVtYV07XG4gIGlmIChpdC5vcHRzLmZvcm1hdCAhPT0gZmFsc2UgJiYgJGZvcm1hdCkge1xuICAgIG91dCArPSAnIGlmICghICAgJztcbiAgICBpZiAodHlwZW9mICRmb3JtYXQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3V0ICs9ICcgZm9ybWF0cycgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkc2NoZW1hKSkgKyAnICgnICsgKCRkYXRhKSArICcpICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGZvcm1hdHMnICsgKGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSkpICsgJyAudGVzdCgnICsgKCRkYXRhKSArICcpICc7XG4gICAgfVxuICAgIG91dCArPSAnKSB7ICAnO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnZm9ybWF0JykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggZm9ybWF0ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnZm9ybWF0JykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggZm9ybWF0ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9pdGVtcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ2l0ZW1zJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ2l0ZW1zJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0O1xuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7dmFyICcgKyAoJHZhbGlkKSArICc7JztcbiAgaWYgKEFycmF5LmlzQXJyYXkoJHNjaGVtYSkpIHtcbiAgICB2YXIgJGFkZGl0aW9uYWxJdGVtcyA9IGl0LnNjaGVtYS5hZGRpdGlvbmFsSXRlbXM7XG4gICAgaWYgKCRhZGRpdGlvbmFsSXRlbXMgPT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkZGF0YSkgKyAnLmxlbmd0aCA8PSAnICsgKCRzY2hlbWEubGVuZ3RoKSArICc7ICBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICc7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbEl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcgaXRlbXNcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbEl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcgaXRlbXNcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgaWYgKGFycjEpIHtcbiAgICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRpKSArICcpIHsgJztcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaSwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpICsgJ10nO1xuICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICAnO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgJGFkZGl0aW9uYWxJdGVtcyA9PSAnb2JqZWN0JyAmJiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRhZGRpdGlvbmFsSXRlbXMsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICRpdC5zY2hlbWEgPSAkYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5hZGRpdGlvbmFsSXRlbXMnO1xuICAgICAgb3V0ICs9ICcgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcpIHsgIGZvciAodmFyIGknICsgKCRsdmwpICsgJyA9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgaScgKyAoJGx2bCkgKyAnIDwgJyArICgkZGF0YSkgKyAnLmxlbmd0aDsgaScgKyAoJGx2bCkgKyAnKyspIHsgJztcbiAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJ2knICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1tpJyArICRsdmwgKyAnXSc7XG4gICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIGJyZWFrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSB9ICAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAnO1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKSkge1xuICAgICRpdC5zY2hlbWEgPSAkc2NoZW1hO1xuICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgIGZvciAodmFyIGknICsgKCRsdmwpICsgJyA9ICcgKyAoMCkgKyAnOyBpJyArICgkbHZsKSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyBpJyArICgkbHZsKSArICcrKykgeyAnO1xuICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJ2knICsgJGx2bCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbaScgKyAkbHZsICsgJ10nO1xuICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIGJyZWFrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21heEl0ZW1zKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbWF4SXRlbXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWF4SXRlbXMnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICgnICsgKCRkYXRhKSArICcubGVuZ3RoID4gJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21heEl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBtb3JlIHRoYW4gJyArICgkc2NoZW1hKSArICcgaXRlbXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfV07IHJldHVybiBmYWxzZTsgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhJdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX21heExlbmd0aChpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21heExlbmd0aCddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtYXhMZW5ndGgnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBvdXQgKz0gJ2lmICggJztcbiAgaWYgKGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdWNzMmxlbmd0aCgnICsgKCRkYXRhKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgPiAnICsgKCRzY2hlbWEpICsgJykgeyAgJztcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgnbWF4TGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgbG9uZ2VyIHRoYW4gJyArICgkc2NoZW1hKSArICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ21heExlbmd0aCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIGxvbmdlciB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGNoYXJhY3RlcnNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4UHJvcGVydGllcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21heFByb3BlcnRpZXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWF4UHJvcGVydGllcycsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKE9iamVjdC5rZXlzKCcgKyAoJGRhdGEpICsgJykubGVuZ3RoID4gJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21heFByb3BlcnRpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBwcm9wZXJ0aWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWF4UHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWF4aW11bShpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21heGltdW0nXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWF4aW11bScsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkZXhjbHVzaXZlID0gaXQuc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUsXG4gICAgJG9wID0gJGV4Y2x1c2l2ZSA/ICc8JyA6ICc8PScsXG4gICAgJG5vdE9wID0gJGV4Y2x1c2l2ZSA/ICc+PScgOiAnPic7XG4gIG91dCArPSAnaWYgKCcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdtYXhpbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWF4aW11bScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgY29uZGl0aW9uOiBcXCcnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnIH0nO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5JdGVtcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21pbkl0ZW1zJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ21pbkl0ZW1zJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA8ICcgKyAoJHNjaGVtYSkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5JdGVtcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWluSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIGxlc3MgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBpdGVtc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9taW5MZW5ndGgoaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydtaW5MZW5ndGgnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWluTGVuZ3RoJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmIChpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgJyArICgkZGF0YSkgKyAnLmxlbmd0aCAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHVjczJsZW5ndGgoJyArICgkZGF0YSkgKyAnKSAnO1xuICB9XG4gIG91dCArPSAnIDwgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pbkxlbmd0aCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIHNob3J0ZXIgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBjaGFyYWN0ZXJzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWluTGVuZ3RoJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgc2hvcnRlciB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIGNoYXJhY3RlcnNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWluUHJvcGVydGllcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21pblByb3BlcnRpZXMnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWluUHJvcGVydGllcycsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIG91dCArPSAnaWYgKE9iamVjdC5rZXlzKCcgKyAoJGRhdGEpICsgJykubGVuZ3RoIDwgJyArICgkc2NoZW1hKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ21pblByb3BlcnRpZXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIGxlc3MgdGhhbiAnICsgKCRzY2hlbWEpICsgJyBwcm9wZXJ0aWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWluUHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbGVzcyB0aGFuICcgKyAoJHNjaGVtYSkgKyAnIHByb3BlcnRpZXNcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbWluaW11bShpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ21pbmltdW0nXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnbWluaW11bScsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkZXhjbHVzaXZlID0gaXQuc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IHRydWUsXG4gICAgJG9wID0gJGV4Y2x1c2l2ZSA/ICc+JyA6ICc+PScsXG4gICAgJG5vdE9wID0gJGV4Y2x1c2l2ZSA/ICc8PScgOiAnPCc7XG4gIG91dCArPSAnaWYgKCcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnKSB7ICAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdtaW5pbXVtJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBjb25kaXRpb246IFxcJycgKyAoJG9wKSArICcgJyArICgkc2NoZW1hKSArICdcXCcgfSc7XG4gICAgfVxuICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbWluaW11bScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWEpICsgJ1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoJHNjaGVtYSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgY29uZGl0aW9uOiBcXCcnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYSkgKyAnXFwnIH0nO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tdWx0aXBsZU9mKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbXVsdGlwbGVPZiddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdtdWx0aXBsZU9mJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgb3V0ICs9ICd2YXIgZGl2aXNpb24nICsgKCRsdmwpICsgJyA9ICcgKyAoJGRhdGEpICsgJyAvICcgKyAoJHNjaGVtYSkgKyAnO2lmICgnICsgKCRkYXRhKSArICcgLyAnICsgKCRzY2hlbWEpICsgJyAhPT0gcGFyc2VJbnQoZGl2aXNpb24nICsgKCRsdmwpICsgJykpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ211bHRpcGxlT2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlIG11bHRpcGxlIG9mICcgKyAoJHNjaGVtYSkgKyAnXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnbXVsdGlwbGVPZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgbXVsdGlwbGUgb2YgJyArICgkc2NoZW1hKSArICdcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbm90KGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsnbm90J10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ25vdCcsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpLFxuICAgICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzOyAgJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICBvdXQgKz0gJyAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAgJztcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdub3QnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgdmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdub3QnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgdmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdub3QnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSB2YWxpZFxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmIChmYWxzZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9vbmVPZihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ29uZU9mJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ29uZU9mJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgcHJldlZhbGlkJyArICgkbHZsKSArICcgPSBmYWxzZTt2YXIgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciB2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgPSB0cnVlOyAnO1xuICAgICAgfVxuICAgICAgaWYgKCRpKSB7XG4gICAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcgJiYgcHJldlZhbGlkJyArICgkbHZsKSArICcpICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgZWxzZSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpICcgKyAoJHZhbGlkKSArICcgPSBwcmV2VmFsaWQnICsgKCRsdmwpICsgJyA9IHRydWU7JztcbiAgICB9XG4gIH1cbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgb3V0ICs9ICcnICsgKCRjbG9zaW5nQnJhY2VzKSArICdpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ29uZU9mJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnb25lT2YnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9IGVsc2UgeyBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9JztcbiAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3BhdHRlcm4oaXQpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbCxcbiAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAkc2NoZW1hID0gaXQuc2NoZW1hWydwYXR0ZXJuJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ3BhdHRlcm4nLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBuZXcgUmVnRXhwKCRzY2hlbWEpO1xuICBvdXQgKz0gJ2lmICghICcgKyAoaXQudXNlUGF0dGVybigkc2NoZW1hKSkgKyAnLnRlc3QoJyArICgkZGF0YSkgKyAnKSApIHsgICc7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ3BhdHRlcm4nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHBhdHRlcm4gXCInICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcIlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3BhdHRlcm4nKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHBhdHRlcm4gXCInICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcIlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgZXNjYXBlZDogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnIH0nO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9wcm9wZXJ0aWVzKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsncHJvcGVydGllcyddLFxuICAgICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuJyArICdwcm9wZXJ0aWVzJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCksXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0O1xuICB2YXIgJHNjaGVtYUtleXMgPSBPYmplY3Qua2V5cygkc2NoZW1hIHx8IHt9KSxcbiAgICAkcFByb3BlcnRpZXMgPSBpdC5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMgfHwge30sXG4gICAgJHBQcm9wZXJ0eUtleXMgPSBPYmplY3Qua2V5cygkcFByb3BlcnRpZXMpLFxuICAgICRhUHJvcGVydGllcyA9IGl0LnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAkc29tZVByb3BlcnRpZXMgPSAkc2NoZW1hS2V5cy5sZW5ndGggfHwgJHBQcm9wZXJ0eUtleXMubGVuZ3RoLFxuICAgICRub0FkZGl0aW9uYWwgPSAkYVByb3BlcnRpZXMgPT09IGZhbHNlLFxuICAgICRhZGRpdGlvbmFsSXNTY2hlbWEgPSB0eXBlb2YgJGFQcm9wZXJ0aWVzID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKCRhUHJvcGVydGllcykubGVuZ3RoLFxuICAgICRyZW1vdmVBZGRpdGlvbmFsID0gaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsLFxuICAgICRjaGVja0FkZGl0aW9uYWwgPSAkbm9BZGRpdGlvbmFsIHx8ICRhZGRpdGlvbmFsSXNTY2hlbWEgfHwgJHJlbW92ZUFkZGl0aW9uYWwsXG4gICAgJHJlcXVpcmVkUHJvcGVydGllcyA9IGl0LnV0aWwudG9IYXNoKGl0LnNjaGVtYS5yZXF1aXJlZCB8fCBbXSk7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsnO1xuICBpZiAoJGNoZWNrQWRkaXRpb25hbCkge1xuICAgIG91dCArPSAnIGZvciAodmFyIGtleScgKyAoJGx2bCkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIGlmICgkc29tZVByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnIHZhciBpc0FkZGl0aW9uYWwnICsgKCRsdmwpICsgJyA9ICEoZmFsc2UgJztcbiAgICAgIGlmICgkc2NoZW1hS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICBvdXQgKz0gJyB8fCB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICdba2V5JyArICgkbHZsKSArICddICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFycjEgPSAkc2NoZW1hS2V5cztcbiAgICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTEgPSAtMSxcbiAgICAgICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCBrZXknICsgKCRsdmwpICsgJyA9PSAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHByb3BlcnR5S2V5KSkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoJHBQcm9wZXJ0eUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnIyID0gJHBQcm9wZXJ0eUtleXM7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwUHJvcGVydHksICRpID0gLTEsXG4gICAgICAgICAgICBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMikge1xuICAgICAgICAgICAgJHBQcm9wZXJ0eSA9IGFycjJbJGkgKz0gMV07XG4gICAgICAgICAgICBvdXQgKz0gJyB8fCAnICsgKGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkpICsgJy50ZXN0KGtleScgKyAoJGx2bCkgKyAnKSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgKTsgaWYgKGlzQWRkaXRpb25hbCcgKyAoJGx2bCkgKyAnKSB7ICc7XG4gICAgfVxuICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSAnYWxsJykge1xuICAgICAgb3V0ICs9ICcgZGVsZXRlICcgKyAoJGRhdGEpICsgJ1trZXknICsgKCRsdmwpICsgJ107ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAna2V5JyArICRsdmwsIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgIGlmICgkbm9BZGRpdGlvbmFsKSB7XG4gICAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCkge1xuICAgICAgICAgIG91dCArPSAnIGRlbGV0ZSAnICsgKCRkYXRhKSArICdba2V5JyArICgkbHZsKSArICddOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IGZhbHNlOyAgJztcbiAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXFwnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnICB9XTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdhZGRpdGlvbmFsUHJvcGVydGllcycpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xcJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyAgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBicmVhazsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJGFkZGl0aW9uYWxJc1NjaGVtYSkge1xuICAgICAgICBpZiAoJHJlbW92ZUFkZGl0aW9uYWwgPT0gJ2ZhaWxpbmcnKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgICc7XG4gICAgICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRhUHJvcGVydGllcztcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLmFkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdba2V5JyArICRsdmwgKyAnXSc7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIGlmICghdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7IGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZhbGlkYXRlLmVycm9ycyAhPT0gbnVsbCkgeyBpZiAoZXJyb3JzKSB2YWxpZGF0ZS5lcnJvcnMubGVuZ3RoID0gZXJyb3JzOyBlbHNlIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7IH0gZGVsZXRlICcgKyAoJGRhdGEpICsgJ1trZXknICsgKCRsdmwpICsgJ107IH0gICc7XG4gICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbFByb3BlcnRpZXMnO1xuICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1trZXknICsgJGx2bCArICddJztcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICghdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSBicmVhazsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgIH1cbiAgICBpZiAoJHNvbWVQcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIHsgJztcbiAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICB9XG4gIH1cbiAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCkge1xuICAgIHZhciBhcnIzID0gJHNjaGVtYUtleXM7XG4gICAgaWYgKGFycjMpIHtcbiAgICAgIHZhciAkcHJvcGVydHlLZXksIGkzID0gLTEsXG4gICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyM1tpMyArPSAxXTtcbiAgICAgICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eUtleV07XG4gICAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAkcGFzc0RhdGEgPSAkZGF0YSArICRwcm9wO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAkcHJvcDtcbiAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKGl0LmVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgJGNvZGUgPSBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKTtcbiAgICAgICAgICAgIHZhciAkdXNlRGF0YSA9ICRwYXNzRGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyICR1c2VEYXRhID0gJG5leHREYXRhO1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHJlcXVpcmVkUHJvcGVydGllc1skcHJvcGVydHlLZXldKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQpIHsgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gZmFsc2U7ICc7XG4gICAgICAgICAgICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGgsXG4gICAgICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHlcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHlcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gICAgICAgICAgICBvdXQgKz0gJyB9IGVsc2UgeyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQpIHsgdmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnID0gdHJ1ZTsgfSBlbHNlIHsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgIT09IHVuZGVmaW5lZCkgeyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgfSAnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKHZhbGlkJyArICgkaXQubGV2ZWwpICsgJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgYXJyNCA9ICRwUHJvcGVydHlLZXlzO1xuICBpZiAoYXJyNCkge1xuICAgIHZhciAkcFByb3BlcnR5LCBpNCA9IC0xLFxuICAgICAgbDQgPSBhcnI0Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGk0IDwgbDQpIHtcbiAgICAgICRwUHJvcGVydHkgPSBhcnI0W2k0ICs9IDFdO1xuICAgICAgdmFyICRzY2ggPSAkcFByb3BlcnRpZXNbJHBQcm9wZXJ0eV07XG4gICAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnBhdHRlcm5Qcm9wZXJ0aWVzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHBQcm9wZXJ0eSk7XG4gICAgICAgIG91dCArPSAnIGZvciAodmFyIGtleScgKyAoJGx2bCkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyBpZiAoJyArIChpdC51c2VQYXR0ZXJuKCRwUHJvcGVydHkpKSArICcudGVzdChrZXknICsgKCRsdmwpICsgJykpIHsgJztcbiAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAna2V5JyArICRsdmwsIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1trZXknICsgJGx2bCArICddJztcbiAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCF2YWxpZCcgKyAoJGl0LmxldmVsKSArICcpIGJyZWFrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBlbHNlIHZhbGlkJyArICgkaXQubGV2ZWwpICsgJyA9IHRydWU7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3JlZihpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJyRyZWYnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAnJHJlZicsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKSxcbiAgICAkdmFsaWQgPSAndmFsaWQnICsgJGx2bCxcbiAgICAkZXJycyA9ICdlcnJzJyArICRsdmw7XG4gIGlmICgkc2NoZW1hID09ICcjJyB8fCAkc2NoZW1hID09ICcjLycpIHtcbiAgICBpZiAoaXQuaXNSb290KSB7XG4gICAgICBvdXQgKz0gJyAgaWYgKCEgJyArICgndmFsaWRhdGUnKSArICcoJyArICgkZGF0YSkgKyAnLCAoZGF0YVBhdGggfHwgXFwnXFwnKSc7XG4gICAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSApIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCd2YWxpZGF0ZScpICsgJy5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KCcgKyAoJ3ZhbGlkYXRlJykgKyAnLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9ICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgIGlmICghICcgKyAoJ3Jvb3QucmVmVmFsWzBdJykgKyAnKCcgKyAoJGRhdGEpICsgJywgKGRhdGFQYXRoIHx8IFxcJ1xcJyknO1xuICAgICAgaWYgKGl0LmVycm9yUGF0aCAhPSAnXCJcIicpIHtcbiAgICAgICAgb3V0ICs9ICcgKyAnICsgKGl0LmVycm9yUGF0aCk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgKSB7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gJyArICgncm9vdC5yZWZWYWxbMF0nKSArICcuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdCgnICsgKCdyb290LnJlZlZhbFswXScpICsgJy5lcnJvcnMpOyBlcnJvcnMgPSB2RXJyb3JzLmxlbmd0aDsgfSAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciAkcmVmVmFsID0gaXQucmVzb2x2ZVJlZihpdC5iYXNlSWQsICRzY2hlbWEsIGl0LmlzUm9vdCk7XG4gICAgaWYgKCRyZWZWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyICRtZXNzYWdlID0gJ2NhblxcJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJyArICRzY2hlbWEgKyAnIGZyb20gaWQgJyArIGl0LmJhc2VJZDtcbiAgICAgIGlmIChpdC5vcHRzLm1pc3NpbmdSZWZzID09ICdmYWlsJykge1xuICAgICAgICBjb25zb2xlLmxvZygkbWVzc2FnZSk7XG4gICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJyRyZWYnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnY2FuXFxcXFxcJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSkgKyAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBlc2NhcGVkOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgnJHJlZicpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdjYW5cXFxcXFwndCByZXNvbHZlIHJlZmVyZW5jZSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKSArICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSkpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGVzY2FwZWQ6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyB9JztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoZmFsc2UpIHsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpdC5vcHRzLm1pc3NpbmdSZWZzID09ICdpZ25vcmUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCRtZXNzYWdlKTtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgJGVycm9yID0gbmV3IEVycm9yKCRtZXNzYWdlKTtcbiAgICAgICAgJGVycm9yLm1pc3NpbmdSZWYgPSBpdC5yZXNvbHZlLnVybChpdC5iYXNlSWQsICRzY2hlbWEpO1xuICAgICAgICAkZXJyb3IubWlzc2luZ1NjaGVtYSA9IGl0LnJlc29sdmUubm9ybWFsaXplSWQoaXQucmVzb2x2ZS5mdWxsUGF0aCgkZXJyb3IubWlzc2luZ1JlZikpO1xuICAgICAgICB0aHJvdyAkZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgJHJlZlZhbCA9PSAnc3RyaW5nJykge1xuICAgICAgb3V0ICs9ICcgIGlmICghICcgKyAoJHJlZlZhbCkgKyAnKCcgKyAoJGRhdGEpICsgJywgKGRhdGFQYXRoIHx8IFxcJ1xcJyknO1xuICAgICAgaWYgKGl0LmVycm9yUGF0aCAhPSAnXCJcIicpIHtcbiAgICAgICAgb3V0ICs9ICcgKyAnICsgKGl0LmVycm9yUGF0aCk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgKSB7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gJyArICgkcmVmVmFsKSArICcuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdCgnICsgKCRyZWZWYWwpICsgJy5lcnJvcnMpOyBlcnJvcnMgPSB2RXJyb3JzLmxlbmd0aDsgfSAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpLFxuICAgICAgICAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAgICAgJGl0LmxldmVsKys7XG4gICAgICAkaXQuc2NoZW1hID0gJHJlZlZhbC5zY2hlbWE7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICcnO1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgIGlmICgvdmFsaWRhdGVcXC5zY2hlbWEvLnRlc3QoJGNvZGUpKSB7XG4gICAgICAgIG91dCArPSAnIHZhciByb290U2NoZW1hJyArICgkaXQubGV2ZWwpICsgJyA9IHZhbGlkYXRlLnNjaGVtYTsgdmFsaWRhdGUuc2NoZW1hID0gJyArICgkcmVmVmFsLmNvZGUpICsgJzsgJyArICgkY29kZSkgKyAnIHZhbGlkYXRlLnNjaGVtYSA9IHJvb3RTY2hlbWEnICsgKCRpdC5sZXZlbCkgKyAnOyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAodmFsaWQnICsgKCRpdC5sZXZlbCkgKyAnKSB7ICc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3JlcXVpcmVkKGl0KSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgJHNjaGVtYSA9IGl0LnNjaGVtYVsncmVxdWlyZWQnXSxcbiAgICAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLicgKyAncmVxdWlyZWQnLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyksXG4gICAgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGVycnMgPSAnZXJycycgKyAkbHZsO1xuICBpZiAoaXQuc2NoZW1hLnByb3BlcnRpZXMgJiYgT2JqZWN0LmtleXMoaXQuc2NoZW1hLnByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgIHZhciAkcmVxdWlyZWQgPSBbXTtcbiAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgaWYgKGFycjEpIHtcbiAgICAgIHZhciAkcHJvcGVydHksIGkxID0gLTEsXG4gICAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkxIDwgbDEpIHtcbiAgICAgICAgJHByb3BlcnR5ID0gYXJyMVtpMSArPSAxXTtcbiAgICAgICAgdmFyICRwcm9wZXJ0eVNjaCA9IGl0LnNjaGVtYS5wcm9wZXJ0aWVzWyRwcm9wZXJ0eV07XG4gICAgICAgIGlmICghKCRwcm9wZXJ0eVNjaCAmJiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRwcm9wZXJ0eVNjaCwgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAgICAgICAkcmVxdWlyZWRbJHJlcXVpcmVkLmxlbmd0aF0gPSAkcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyICRyZXF1aXJlZCA9ICRzY2hlbWE7XG4gIH1cbiAgaWYgKCRyZXF1aXJlZC5sZW5ndGgpIHtcbiAgICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIHZhciBtaXNzaW5nJyArICgkbHZsKSArICc7ICc7XG4gICAgICBpZiAoJHJlcXVpcmVkLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgICAgIHZhciBhcnIyID0gJHJlcXVpcmVkO1xuICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgIHZhciAkcHJvcGVydHksICRpID0gLTEsXG4gICAgICAgICAgICBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMikge1xuICAgICAgICAgICAgJHByb3BlcnR5ID0gYXJyMlskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkaSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpO1xuICAgICAgICAgICAgb3V0ICs9ICcgKCAnICsgKCRkYXRhKSArICgkcHJvcCkgKyAnID09PSB1bmRlZmluZWQgJiYgKG1pc3NpbmcnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eSA6ICRwcm9wKSkgKyAnKSApICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAgIHZhciAkcHJvcGVydHlQYXRoID0gJ21pc3NpbmcnICsgJGx2bCxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuanNvblBvaW50ZXJzID8gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgdHJ1ZSkgOiAkY3VycmVudEVycm9yUGF0aCArICcgKyAnICsgJHByb3BlcnR5UGF0aDtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnOyAnO1xuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArIFwiXFwnXCIgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcIlxcJ1wiICsgXFwnJztcbiAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICBvdXQgKz0gJyBmb3IgKHZhciAnICsgKCRpKSArICcgPSAwOyAnICsgKCRpKSArICcgPCBzY2hlbWEnICsgKCRsdmwpICsgJy5sZW5ndGg7ICcgKyAoJGkpICsgJysrKSB7IHZhciAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkZGF0YSkgKyAnW3NjaGVtYScgKyAoJGx2bCkgKyAnWycgKyAoJGkpICsgJ11dICE9PSB1bmRlZmluZWQ7IGlmICghJyArICgkdmFsaWQpICsgJykgYnJlYWs7IH0gIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH1dOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVxcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkcmVxdWlyZWQubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgIHZhciBhcnIzID0gJHJlcXVpcmVkO1xuICAgICAgICBpZiAoYXJyMykge1xuICAgICAgICAgIHZhciAkcHJvcGVydHksICRpID0gLTEsXG4gICAgICAgICAgICBsMyA9IGFycjMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMykge1xuICAgICAgICAgICAgJHByb3BlcnR5ID0gYXJyM1skaSArPSAxXTtcbiAgICAgICAgICAgIHZhciAkcHJvcCA9IGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5KSxcbiAgICAgICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wKTtcbiAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YSkgKyAoJHByb3ApICsgJyA9PT0gdW5kZWZpbmVkKSB7ICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdpcyBhIHJlcXVpcmVkIHByb3BlcnR5XFwnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyAgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnOyAnO1xuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArIFwiXFwnXCIgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcIlxcJ1wiICsgXFwnJztcbiAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICBvdXQgKz0gJyBmb3IgKHZhciAnICsgKCRpKSArICcgPSAwOyAnICsgKCRpKSArICcgPCBzY2hlbWEnICsgKCRsdmwpICsgJy5sZW5ndGg7ICcgKyAoJGkpICsgJysrKSB7IGlmICgnICsgKCRkYXRhKSArICdbc2NoZW1hJyArICgkbHZsKSArICdbJyArICgkaSkgKyAnXV0gPT09IHVuZGVmaW5lZCkgeyAgdmFyIGVyciA9ICAgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHlcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0nO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9IH0gJztcbiAgICAgIH1cbiAgICB9XG4gICAgaXQuZXJyb3JQYXRoID0gJGN1cnJlbnRFcnJvclBhdGg7XG4gIH0gZWxzZSBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGlmICh0cnVlKSB7JztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV91bmlxdWVJdGVtcyhpdCkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsLFxuICAgICRzY2hlbWEgPSBpdC5zY2hlbWFbJ3VuaXF1ZUl0ZW1zJ10sXG4gICAgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy4nICsgJ3VuaXF1ZUl0ZW1zJyxcbiAgICAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpLFxuICAgICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRlcnJzID0gJ2VycnMnICsgJGx2bDtcbiAgaWYgKCRzY2hlbWEgJiYgaXQub3B0cy51bmlxdWVJdGVtcyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkdmFsaWQpICsgJyA9IHRydWU7IGlmICgnICsgKCRkYXRhKSArICcubGVuZ3RoID4gMSkgeyB2YXIgaSA9ICcgKyAoJGRhdGEpICsgJy5sZW5ndGgsIGo7IG91dGVyOiBmb3IgKDtpLS07KSB7IGZvciAoaiA9IGk7IGotLTspIHsgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJ1tpXSwgJyArICgkZGF0YSkgKyAnW2pdKSkgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGJyZWFrIG91dGVyOyB9IH0gfSB9IGlmICghJyArICgkdmFsaWQpICsgJykgeyAgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWyB7IGtleXdvcmQ6IFxcJycgKyAoJ3VuaXF1ZUl0ZW1zJykgKyAnXFwnLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyBcXCcgKyBqICsgXFwnIGFuZCBcXCcgKyBpICsgXFwnIGFyZSBpZGVudGljYWwpXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArICgkc2NoZW1hKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyBpOiBpLCBqOiBqIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgndW5pcXVlSXRlbXMnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjIFxcJyArIGogKyBcXCcgYW5kIFxcJyArIGkgKyBcXCcgYXJlIGlkZW50aWNhbClcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UgfHwgaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnICsgKCRzY2hlbWEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICBvdXQgKz0gJywgcGFyYW1zOiB7IGk6IGksIGo6IGogfSc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9OyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3ZhbGlkYXRlKGl0KSB7XG4gIHZhciBvdXQgPSAnJztcbiAgaWYgKGl0LmlzVG9wKSB7XG4gICAgdmFyICR0b3AgPSBpdC5pc1RvcCxcbiAgICAgICRsdmwgPSBpdC5sZXZlbCA9IDAsXG4gICAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCA9IDAsXG4gICAgICAkZGF0YSA9ICdkYXRhJztcbiAgICBpdC5yb290SWQgPSBpdC5yZXNvbHZlLmZ1bGxQYXRoKGl0LnJvb3Quc2NoZW1hLmlkKTtcbiAgICBpdC5iYXNlSWQgPSBpdC5iYXNlSWQgfHwgaXQucm9vdElkO1xuICAgIGRlbGV0ZSBpdC5pc1RvcDtcbiAgICBvdXQgKz0gJyB2YWxpZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBkYXRhUGF0aCkgeyBcXCd1c2Ugc3RyaWN0XFwnOyB2YXIgdkVycm9ycyA9IG51bGw7ICc7XG4gICAgb3V0ICs9ICcgdmFyIGVycm9ycyA9IDA7ICAgICAnO1xuICB9IGVsc2Uge1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWwsXG4gICAgICAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbCxcbiAgICAgICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgICBpZiAoaXQuc2NoZW1hLmlkKSBpdC5iYXNlSWQgPSBpdC5yZXNvbHZlLnVybChpdC5iYXNlSWQsIGl0LnNjaGVtYS5pZCk7XG4gICAgb3V0ICs9ICcgdmFyIGVycnNfJyArICgkbHZsKSArICcgPSBlcnJvcnM7JztcbiAgfVxuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmwsXG4gICAgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycyxcbiAgICAkY2xvc2luZ0JyYWNlczEgPSAnJyxcbiAgICAkY2xvc2luZ0JyYWNlczIgPSAnJztcbiAgdmFyICR0eXBlU2NoZW1hID0gaXQuc2NoZW1hLnR5cGU7XG4gIHZhciBhcnIxID0gaXQuUlVMRVM7XG4gIGlmIChhcnIxKSB7XG4gICAgdmFyICRydWxlc0dyb3VwLCBpMSA9IC0xLFxuICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGkxIDwgbDEpIHtcbiAgICAgICRydWxlc0dyb3VwID0gYXJyMVtpMSArPSAxXTtcbiAgICAgIGlmICgkc2hvdWxkVXNlR3JvdXAoJHJ1bGVzR3JvdXApKSB7XG4gICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoaXQudXRpbC5jaGVja0RhdGFUeXBlKCRydWxlc0dyb3VwLnR5cGUsICRkYXRhKSkgKyAnKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycjIgPSAkcnVsZXNHcm91cC5ydWxlcztcbiAgICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgICB2YXIgJHJ1bGUsIGkyID0gLTEsXG4gICAgICAgICAgICBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoaTIgPCBsMikge1xuICAgICAgICAgICAgJHJ1bGUgPSBhcnIyW2kyICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRzaG91bGRVc2VSdWxlKCRydWxlKSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRydWxlLmNvZGUoaXQpKSArICcgJztcbiAgICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAkY2xvc2luZ0JyYWNlczEgKz0gJ30nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlczEpICsgJyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzMSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIGlmICgkdHlwZVNjaGVtYSAmJiAkdHlwZVNjaGVtYSA9PT0gJHJ1bGVzR3JvdXAudHlwZSkge1xuICAgICAgICAgICAgdmFyICR0eXBlQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBvdXQgKz0gJyBlbHNlIHsgICc7XG4gICAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgndHlwZScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlIHx8IGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdbXFwnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiJywnXCIpKSArICdcXCddJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcnICsgKCR0eXBlU2NoZW1hKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgfSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICB2YXIgZXJyID0gICB7IGtleXdvcmQ6IFxcJycgKyAoJ3R5cGUnKSArICdcXCcsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJztcbiAgICAgICAgICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnW1xcJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIicsJ1wiKSkgKyAnXFwnXSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnXFwnJyArICgkdHlwZVNjaGVtYSkgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuaTE4bikge1xuICAgICAgICAgICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgdHlwZTogXFwnJztcbiAgICAgICAgICAgICAgICBpZiAoJGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSAnXFwnIH0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH07IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmIChlcnJvcnMgPT09ICc7XG4gICAgICAgICAgaWYgKCR0b3ApIHtcbiAgICAgICAgICAgIG91dCArPSAnMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnZXJyc18nICsgKCRsdmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzMiArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCR0eXBlU2NoZW1hICYmICEkdHlwZUNoZWNrZWQpIHtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy50eXBlJyxcbiAgICAgICRpc0FycmF5ID0gQXJyYXkuaXNBcnJheSgkdHlwZVNjaGVtYSksXG4gICAgICAkbWV0aG9kID0gJGlzQXJyYXkgPyAnY2hlY2tEYXRhVHlwZXMnIDogJ2NoZWNrRGF0YVR5cGUnO1xuICAgIG91dCArPSAnIGlmICgnICsgKGl0LnV0aWxbJG1ldGhvZF0oJHR5cGVTY2hlbWEsICRkYXRhLCB0cnVlKSkgKyAnKSB7ICAnO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbIHsga2V5d29yZDogXFwnJyArICgndHlwZScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICc7XG4gICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgIG91dCArPSAnW1xcJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIicsJ1wiKSkgKyAnXFwnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICdcXCcnICsgKCR0eXBlU2NoZW1hKSArICdcXCcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgdHlwZTogXFwnJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfV07IHJldHVybiBmYWxzZTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgIHsga2V5d29yZDogXFwnJyArICgndHlwZScpICsgJ1xcJywgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSB8fCBpdC5vcHRzLmkxOG4pIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICc7XG4gICAgICAgIGlmICgkaXNBcnJheSkge1xuICAgICAgICAgIG91dCArPSAnW1xcJycgKyAoJHR5cGVTY2hlbWEuam9pbihcIicsJ1wiKSkgKyAnXFwnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICdcXCcnICsgKCR0eXBlU2NoZW1hKSArICdcXCcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy5pMThuKSB7XG4gICAgICAgIG91dCArPSAnLCBwYXJhbXM6IHsgdHlwZTogXFwnJztcbiAgICAgICAgaWYgKCRpc0FycmF5KSB7XG4gICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnXFwnIH0nO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfTsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0nO1xuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlczIpICsgJyAnO1xuICB9XG4gIGlmICgkdG9wKSB7XG4gICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgJztcbiAgICBvdXQgKz0gJyByZXR1cm4gZXJyb3JzID09PSAwOyAgICAgICAnO1xuICAgIG91dCArPSAnIH0nO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gZXJyb3JzID09PSBlcnJzXycgKyAoJGx2bCkgKyAnOyc7XG4gIH1cbiAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICBpZiAoJHRvcCAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ID0gaXQudXRpbC5jbGVhblVwVmFyRXJyb3JzKG91dCk7XG4gIH1cblxuICBmdW5jdGlvbiAkc2hvdWxkVXNlR3JvdXAoJHJ1bGVzR3JvdXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRydWxlc0dyb3VwLnJ1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgaWYgKCRzaG91bGRVc2VSdWxlKCRydWxlc0dyb3VwLnJ1bGVzW2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiAkc2hvdWxkVXNlUnVsZSgkcnVsZSkge1xuICAgIHJldHVybiBpdC5zY2hlbWFbJHJ1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fCAoJHJ1bGUua2V5d29yZCA9PSAncHJvcGVydGllcycgJiYgKGl0LnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgdHlwZW9mIGl0LnNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PSAnb2JqZWN0JyB8fCAoaXQuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICYmIE9iamVjdC5rZXlzKGl0LnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykubGVuZ3RoKSkpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJpZFwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICAgIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHsgXCIkcmVmXCI6IFwiI1wiIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3NpdGl2ZUludGVnZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgXCJtaW5pbXVtXCI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3NpdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICAgICAgICBcImFsbE9mXCI6IFsgeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sIHsgXCJkZWZhdWx0XCI6IDAgfSBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic2ltcGxlVHlwZXNcIjoge1xuICAgICAgICAgICAgXCJlbnVtXCI6IFsgXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7IFwidHlwZVwiOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJpZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwidXJpXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCIkc2NoZW1hXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgICAgICB9LFxuICAgICAgICBcInRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHt9LFxuICAgICAgICBcIm11bHRpcGxlT2ZcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgICAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4aW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibWluaW11bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4TGVuZ3RoXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICBcIm1pbkxlbmd0aFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvcG9zaXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgICBcInBhdHRlcm5cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcImZvcm1hdFwiOiBcInJlZ2V4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiNcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4SXRlbXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgIFwibWluSXRlbXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCIgfSxcbiAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJcIiB9LFxuICAgICAgICBcIm1pblByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwXCIgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIiB9LFxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICAgICAgeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgICAgICB9LFxuICAgICAgICBcImRlZmluaXRpb25zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogeyBcIiRyZWZcIjogXCIjXCIgfSxcbiAgICAgICAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgICAgICB9LFxuICAgICAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7IFwiJHJlZlwiOiBcIiNcIiB9LFxuICAgICAgICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiI1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwiIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZW51bVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgICBcImFueU9mXCI6IFtcbiAgICAgICAgICAgICAgICB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIiB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpdGVtc1wiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhbGxPZlwiOiB7IFwiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgICBcImFueU9mXCI6IHsgXCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICAgIFwib25lT2ZcIjogeyBcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgICAgXCJub3RcIjogeyBcIiRyZWZcIjogXCIjXCIgfVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjogWyBcIm1heGltdW1cIiBdLFxuICAgICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjogWyBcIm1pbmltdW1cIiBdXG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjoge31cbn1cbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5LGU9U3ltYm9sKCkscj1uZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiLHtmYXRhbDohMH0pO2Z1bmN0aW9uIG4odCxlKXtsZXQgbj1uZXcgVWludDMyQXJyYXkodClbZSstND4+PjJdPj4+MTtjb25zdCBzPW5ldyBVaW50MTZBcnJheSh0LGUsbik7aWYobjw9MTkyKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnMpO3RyeXtyZXR1cm4gci5kZWNvZGUocyl9Y2F0Y2h7bGV0IHQ9XCJcIixlPTA7Zm9yKDtuLWU+MTAyNDspdCs9U3RyaW5nLmZyb21DaGFyQ29kZSguLi5zLnN1YmFycmF5KGUsZSs9MTAyNCkpO3JldHVybiB0K1N0cmluZy5mcm9tQ2hhckNvZGUoLi4ucy5zdWJhcnJheShlKSl9fWZ1bmN0aW9uIHModCl7Y29uc3QgZT17fTtmdW5jdGlvbiByKHQsZSl7cmV0dXJuIHQ/bih0LmJ1ZmZlcixlKTpcIjx5ZXQgdW5rbm93bj5cIn1jb25zdCBzPXQuZW52PXQuZW52fHx7fTtyZXR1cm4gcy5hYm9ydD1zLmFib3J0fHxmdW5jdGlvbih0LG4sbyxpKXtjb25zdCBhPWUubWVtb3J5fHxzLm1lbW9yeTt0aHJvdyBFcnJvcihgYWJvcnQ6ICR7cihhLHQpfSBhdCAke3IoYSxuKX06JHtvfToke2l9YCl9LHMudHJhY2U9cy50cmFjZXx8ZnVuY3Rpb24odCxuLC4uLm8pe2NvbnN0IGk9ZS5tZW1vcnl8fHMubWVtb3J5O2NvbnNvbGUubG9nKGB0cmFjZTogJHtyKGksdCl9JHtuP1wiIFwiOlwiXCJ9JHtvLnNsaWNlKDAsbikuam9pbihcIiwgXCIpfWApfSxzLnNlZWQ9cy5zZWVkfHxEYXRlLm5vdyx0Lk1hdGg9dC5NYXRofHxNYXRoLHQuRGF0ZT10LkRhdGV8fERhdGUsZX1jb25zdCBvPWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJPcGVyYXRpb24gcmVxdWlyZXMgY29tcGlsaW5nIHdpdGggLS1leHBvcnRSdW50aW1lXCIpfTtmdW5jdGlvbiBpKGUscil7Y29uc3Qgcz1yLmV4cG9ydHMsaT1zLm1lbW9yeSxhPXMudGFibGUsYz1zLl9fbmV3fHxvLHU9cy5fX3Bpbnx8byx5PXMuX191bnBpbnx8byxsPXMuX19jb2xsZWN0fHxvLHA9cy5fX3J0dGlfYmFzZSxkPXA/ZnVuY3Rpb24odCl7cmV0dXJuIHRbcD4+PjJdfTpvO2Z1bmN0aW9uIGIodCl7Y29uc3QgZT1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcik7aWYoKHQ+Pj49MCk+PWQoZSkpdGhyb3cgRXJyb3IoYGludmFsaWQgaWQ6ICR7dH1gKTtyZXR1cm4gZVsocCs0Pj4+MikrMip0XX0odCk7aWYoISg3JmUpKXRocm93IEVycm9yKGBub3QgYW4gYXJyYXk6ICR7dH0sIGZsYWdzPSR7ZX1gKTtyZXR1cm4gZX1mdW5jdGlvbiBoKHQpe2NvbnN0IGU9bmV3IFVpbnQzMkFycmF5KGkuYnVmZmVyKTtpZigodD4+Pj0wKT49ZChlKSl0aHJvdyBFcnJvcihgaW52YWxpZCBpZDogJHt0fWApO3JldHVybiBlWyhwKzQ+Pj4yKSsyKnQrMV19ZnVuY3Rpb24gbSh0KXtyZXR1cm4gMzEtTWF0aC5jbHozMih0Pj4+NiYzMSl9ZnVuY3Rpb24gZyh0LGUscil7Y29uc3Qgbj1pLmJ1ZmZlcjtpZihyKXN3aXRjaCh0KXtjYXNlIDI6cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobik7Y2FzZSAzOnJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG4pfWVsc2Ugc3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gbmV3KGU/SW50OEFycmF5OlVpbnQ4QXJyYXkpKG4pO2Nhc2UgMTpyZXR1cm4gbmV3KGU/SW50MTZBcnJheTpVaW50MTZBcnJheSkobik7Y2FzZSAyOnJldHVybiBuZXcoZT9JbnQzMkFycmF5OlVpbnQzMkFycmF5KShuKTtjYXNlIDM6cmV0dXJuIG5ldyhlP0JpZ0ludDY0QXJyYXk6QmlnVWludDY0QXJyYXkpKG4pfXRocm93IEVycm9yKGB1bnN1cHBvcnRlZCBhbGlnbjogJHt0fWApfWZ1bmN0aW9uIEEodCl7Y29uc3QgZT1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpLHI9YihlW3QrLTg+Pj4yXSksbj1tKHIpO2xldCBzPTQmcj90OmVbdCs0Pj4+Ml07Y29uc3Qgbz0yJnI/ZVt0KzEyPj4+Ml06ZVtzKy00Pj4+Ml0+Pj5uO3JldHVybiBnKG4sMjA0OCZyLDQwOTYmcikuc3ViYXJyYXkocz4+Pj1uLHMrbyl9ZnVuY3Rpb24gdyh0LGUscil7cmV0dXJuIG5ldyB0KF8odCxlLHIpKX1mdW5jdGlvbiBfKHQsZSxyKXtjb25zdCBuPWkuYnVmZmVyLHM9bmV3IFVpbnQzMkFycmF5KG4pLG89c1tyKzQ+Pj4yXTtyZXR1cm4gbmV3IHQobixvLHNbbystND4+PjJdPj4+ZSl9ZnVuY3Rpb24gVCh0LHIsbil7ZVtgX19nZXQke3J9YF09dy5iaW5kKG51bGwsdCxuKSxlW2BfX2dldCR7cn1WaWV3YF09Xy5iaW5kKG51bGwsdCxuKX1yZXR1cm4gZS5fX25ldz1jLGUuX19waW49dSxlLl9fdW5waW49eSxlLl9fY29sbGVjdD1sLGUuX19uZXdTdHJpbmc9ZnVuY3Rpb24odCl7aWYobnVsbD09dClyZXR1cm4gMDtjb25zdCBlPXQubGVuZ3RoLHI9YyhlPDwxLDEpLG49bmV3IFVpbnQxNkFycmF5KGkuYnVmZmVyKTtmb3IodmFyIHM9MCxvPXI+Pj4xO3M8ZTsrK3MpbltvK3NdPXQuY2hhckNvZGVBdChzKTtyZXR1cm4gcn0sZS5fX25ld0FycmF5QnVmZmVyPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpcmV0dXJuIDA7Y29uc3QgZT1uZXcgVWludDhBcnJheSh0KSxyPWMoZS5sZW5ndGgsMCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGkuYnVmZmVyKS5zZXQoZSxyKSxyfSxlLl9fZ2V0U3RyaW5nPWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiBudWxsO2NvbnN0IGU9aS5idWZmZXI7aWYoMSE9PW5ldyBVaW50MzJBcnJheShlKVt0Ky04Pj4+Ml0pdGhyb3cgRXJyb3IoYG5vdCBhIHN0cmluZzogJHt0fWApO3JldHVybiBuKGUsdCl9LGUuX19uZXdBcnJheT1mdW5jdGlvbih0LGUpe2NvbnN0IHI9Yih0KSxuPW0ocikscz1lLmxlbmd0aCxvPWMoczw8biw0JnI/dDowKTtsZXQgYTtpZig0JnIpYT1vO2Vsc2V7dShvKTtjb25zdCBlPWMoMiZyPzE2OjEyLHQpO3kobyk7Y29uc3QgZj1uZXcgVWludDMyQXJyYXkoaS5idWZmZXIpO2ZbZSswPj4+Ml09byxmW2UrND4+PjJdPW8sZltlKzg+Pj4yXT1zPDxuLDImciYmKGZbZSsxMj4+PjJdPXMpLGE9ZX1jb25zdCBmPWcobiwyMDQ4JnIsNDA5NiZyKTtpZigxNjM4NCZyKWZvcihsZXQgdD0wO3Q8czsrK3Qpe2NvbnN0IHI9ZVt0XTtmWyhvPj4+bikrdF09cn1lbHNlIGYuc2V0KGUsbz4+Pm4pO3JldHVybiBhfSxlLl9fZ2V0QXJyYXlWaWV3PUEsZS5fX2dldEFycmF5PWZ1bmN0aW9uKHQpe2NvbnN0IGU9QSh0KSxyPWUubGVuZ3RoLG49bmV3IEFycmF5KHIpO2ZvcihsZXQgdD0wO3Q8cjt0Kyspblt0XT1lW3RdO3JldHVybiBufSxlLl9fZ2V0QXJyYXlCdWZmZXI9ZnVuY3Rpb24odCl7Y29uc3QgZT1pLmJ1ZmZlcixyPW5ldyBVaW50MzJBcnJheShlKVt0Ky00Pj4+Ml07cmV0dXJuIGUuc2xpY2UodCx0K3IpfSxbSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldLmZvckVhY2goKHQ9PntUKHQsdC5uYW1lLDMxLU1hdGguY2x6MzIodC5CWVRFU19QRVJfRUxFTUVOVCkpfSkpLHQmJltCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5XS5mb3JFYWNoKCh0PT57VCh0LHQubmFtZS5zbGljZSgzKSwzKX0pKSxlLl9faW5zdGFuY2VvZj1mdW5jdGlvbih0LGUpe2NvbnN0IHI9bmV3IFVpbnQzMkFycmF5KGkuYnVmZmVyKTtsZXQgbj1yW3QrLTg+Pj4yXTtpZihuPD1kKHIpKWRve2lmKG49PWUpcmV0dXJuITA7bj1oKG4pfXdoaWxlKG4pO3JldHVybiExfSxlLm1lbW9yeT1lLm1lbW9yeXx8aSxlLnRhYmxlPWUudGFibGV8fGEsZihzLGUpfWZ1bmN0aW9uIGEodCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlc3BvbnNlJiZ0IGluc3RhbmNlb2YgUmVzcG9uc2V9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZX1hc3luYyBmdW5jdGlvbiB1KHQsZT17fSl7aWYoYSh0PWF3YWl0IHQpKXJldHVybiB5KHQsZSk7Y29uc3Qgcj1jKHQpP3Q6YXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZSh0KSxuPXMoZSksbz1hd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShyLGUpO3JldHVybnttb2R1bGU6cixpbnN0YW5jZTpvLGV4cG9ydHM6aShuLG8pfX1hc3luYyBmdW5jdGlvbiB5KHQsZT17fSl7aWYoIVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKXJldHVybiB1KGEodD1hd2FpdCB0KT90LmFycmF5QnVmZmVyKCk6dCxlKTtjb25zdCByPXMoZSksbj1hd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh0LGUpLG89aShyLG4uaW5zdGFuY2UpO3JldHVybnsuLi5uLGV4cG9ydHM6b319ZnVuY3Rpb24gZih0LHI9e30pe2NvbnN0IG49dC5fX2FyZ3VtZW50c0xlbmd0aD9lPT57dC5fX2FyZ3VtZW50c0xlbmd0aC52YWx1ZT1lfTp0Ll9fc2V0QXJndW1lbnRzTGVuZ3RofHx0Ll9fc2V0YXJnY3x8KCgpPT57fSk7Zm9yKGxldCBzIGluIHQpe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxzKSljb250aW51ZTtjb25zdCBvPXRbc107bGV0IGk9cy5zcGxpdChcIi5cIiksYT1yO2Zvcig7aS5sZW5ndGg+MTspe2xldCB0PWkuc2hpZnQoKTtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSx0KXx8KGFbdF09e30pLGE9YVt0XX1sZXQgYz1pWzBdLHU9Yy5pbmRleE9mKFwiI1wiKTtpZih1Pj0wKXtjb25zdCByPWMuc3Vic3RyaW5nKDAsdSksaT1hW3JdO2lmKHZvaWQgMD09PWl8fCFpLnByb3RvdHlwZSl7Y29uc3QgdD1mdW5jdGlvbiguLi5lKXtyZXR1cm4gdC53cmFwKHQucHJvdG90eXBlLmNvbnN0cnVjdG9yKDAsLi4uZSkpfTt0LnByb3RvdHlwZT17dmFsdWVPZigpe3JldHVybiB0aGlzW2VdfX0sdC53cmFwPWZ1bmN0aW9uKHIpe3JldHVybiBPYmplY3QuY3JlYXRlKHQucHJvdG90eXBlLHtbZV06e3ZhbHVlOnIsd3JpdGFibGU6ITF9fSl9LGkmJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGkpLmZvckVhY2goKGU9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpLGUpKSkpLGFbcl09dH1pZihjPWMuc3Vic3RyaW5nKHUrMSksYT1hW3JdLnByb3RvdHlwZSwvXihnZXR8c2V0KTovLnRlc3QoYykpe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjPWMuc3Vic3RyaW5nKDQpKSl7bGV0IHI9dFtzLnJlcGxhY2UoXCJzZXQ6XCIsXCJnZXQ6XCIpXSxuPXRbcy5yZXBsYWNlKFwiZ2V0OlwiLFwic2V0OlwiKV07T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYyx7Z2V0KCl7cmV0dXJuIHIodGhpc1tlXSl9LHNldCh0KXtuKHRoaXNbZV0sdCl9LGVudW1lcmFibGU6ITB9KX19ZWxzZVwiY29uc3RydWN0b3JcIj09PWM/KGFbY109KC4uLnQpPT4obih0Lmxlbmd0aCksbyguLi50KSkpLm9yaWdpbmFsPW86KGFbY109ZnVuY3Rpb24oLi4udCl7cmV0dXJuIG4odC5sZW5ndGgpLG8odGhpc1tlXSwuLi50KX0pLm9yaWdpbmFsPW99ZWxzZS9eKGdldHxzZXQpOi8udGVzdChjKT9PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjPWMuc3Vic3RyaW5nKDQpKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYyx7Z2V0OnRbcy5yZXBsYWNlKFwic2V0OlwiLFwiZ2V0OlwiKV0sc2V0OnRbcy5yZXBsYWNlKFwiZ2V0OlwiLFwic2V0OlwiKV0sZW51bWVyYWJsZTohMH0pOlwiZnVuY3Rpb25cIj09dHlwZW9mIG8mJm8hPT1uPyhhW2NdPSguLi50KT0+KG4odC5sZW5ndGgpLG8oLi4udCkpKS5vcmlnaW5hbD1vOmFbY109b31yZXR1cm4gcn12YXIgbD17aW5zdGFudGlhdGU6dSxpbnN0YW50aWF0ZVN5bmM6ZnVuY3Rpb24odCxlPXt9KXtjb25zdCByPWModCk/dDpuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHQpLG49cyhlKSxvPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShyLGUpO3JldHVybnttb2R1bGU6cixpbnN0YW5jZTpvLGV4cG9ydHM6aShuLG8pfX0saW5zdGFudGlhdGVTdHJlYW1pbmc6eSxkZW1hbmdsZTpmfTtmdW5jdGlvbiBwKHQsZSxyKXtyZXR1cm4gZX1mdW5jdGlvbiBkKHQsZSxyKXtyZXR1cm4gdC5leHBvcnRzW2BfX2dldCR7ZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RhcnRzV2l0aChcIn5saWIvdHlwZWRhcnJheS9cIik/KCh0PXQuc2xpY2UoXCJ+bGliL3R5cGVkYXJyYXkvXCIubGVuZ3RoKSkuc3RhcnRzV2l0aChcIkJpZ1wiKSYmKHQ9dC5zbGljZSgzKSksdCk6dH0ocil9Vmlld2BdKGUpfWZ1bmN0aW9uIGIodCxlLHIpe3JldHVybiB0LmV4cG9ydHMuX19uZXdBcnJheSh0LmdldFR5cGVJZChyKSxlKX1mdW5jdGlvbiBoKHQpe2lmKCF0LnN0YXJ0c1dpdGgoXCJ+bGliL2FycmF5L0FycmF5XCIpKXRocm93IEVycm9yKGAke0pTT04uc3RyaW5naWZ5KHQpfSBpcyBub3QgYW4gYXJyYXkgdHlwZWApO3JldHVybiB0LnNsaWNlKFwifmxpYi9hcnJheS9BcnJheTxcIi5sZW5ndGgsLTEpfWNvbnN0IG09bmV3IE1hcChbW1widm9pZFwiLHthc2NUb0pzOnAsanNUb0FzYzpwfV0sWy9eKGl8dXxmKSg4fDE2fDMyfDY0KXxbdWldc2l6ZXxib29sfGV4dGVybnJlZiQvLHthc2NUb0pzOnAsanNUb0FzYzpwfV0sW1wifmxpYi9zdHJpbmcvU3RyaW5nXCIse2FzY1RvSnM6ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LmV4cG9ydHMuX19nZXRTdHJpbmcoZSl9LGpzVG9Bc2M6ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LmV4cG9ydHMuX19uZXdTdHJpbmcoZSl9fV0sW1wifmxpYi90eXBlZGFycmF5L0ludDhBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0ludDE2QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9JbnQzMkFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvVWludDhBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L1VpbnQxNkFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvVWludDMyQXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9JbnQ2NEFycmF5XCIse2FzY1RvSnM6ZCxqc1RvQXNjOmJ9XSxbXCJ+bGliL3R5cGVkYXJyYXkvVWludDY0QXJyYXlcIix7YXNjVG9KczpkLGpzVG9Bc2M6Yn1dLFtcIn5saWIvdHlwZWRhcnJheS9VaW50OENsYW1wZWRBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0Zsb2F0MzJBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi90eXBlZGFycmF5L0Zsb2F0NjRBcnJheVwiLHthc2NUb0pzOmQsanNUb0FzYzpifV0sW1wifmxpYi9hcnJheWJ1ZmZlci9BcnJheUJ1ZmZlclwiLHthc2NUb0pzOmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdC5leHBvcnRzLl9fZ2V0QXJyYXlCdWZmZXIoZSl9LGpzVG9Bc2M6ZnVuY3Rpb24odCxlLHIpe2NvbnN0IG49dC5leHBvcnRzLl9fbmV3KGUuYnl0ZUxlbmd0aCx0LmdldFR5cGVJZChyKSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHQuZXhwb3J0cy5tZW1vcnkuYnVmZmVyLG4sZS5ieXRlTGVuZ3RoKS5zZXQobmV3IFVpbnQ4QXJyYXkoZSkpLG59fV0sWy9efmxpYlxcL2FycmF5XFwvQXJyYXk8Lis+JC8se2FzY1RvSnM6ZnVuY3Rpb24odCxlLHIpe2NvbnN0IG49aChyKSxzPUEobik7cmV0dXJuIHQuZXhwb3J0cy5fX2dldEFycmF5KGUpLm1hcCgoZT0+cy5hc2NUb0pzKHQsZSxuKSkpfSxqc1RvQXNjOmZ1bmN0aW9uKHQsZSxyKXtjb25zdCBuPWgocikscz1BKG4pLG89ZS5tYXAoKGU9PnMuanNUb0FzYyh0LGUsbikpKTtyZXR1cm4gdC5leHBvcnRzLl9fbmV3QXJyYXkodC5nZXRUeXBlSWQociksbyl9fV1dKSxnPW5ldyBTZXQ7ZnVuY3Rpb24gQSh0KXtmb3IoY29uc3RbZSxyXW9mIG0paWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn1lbHNlIGlmKGU9PT10KXJldHVybiByO3JldHVybiBnLmhhcyh0KXx8KGNvbnNvbGUud2FybihgTm8gY29udmVydGVyIGZvciAke0pTT04uc3RyaW5naWZ5KHQpfSwgdXNpbmcgcGFzcy10aHJvdWdoYCksZy5hZGQodCkpLHthc2NUb0pzOnAsanNUb0FzYzpwfX1mdW5jdGlvbiB3KHQpe3ZhciBlO3JldHVybiBudWxsPT09KGU9QSh0KSl8fHZvaWQgMD09PWU/dm9pZCAwOmUuYXNjVG9Kc31mdW5jdGlvbiBfKHQpe3ZhciBlO3JldHVybiBudWxsPT09KGU9QSh0KSl8fHZvaWQgMD09PWU/dm9pZCAwOmUuanNUb0FzY31mdW5jdGlvbiBUKHQsZSxyKXtjb25zdCBuPXIucGFyYW1ldGVycy5tYXAodykscz1fKHIucmV0dXJuVHlwZSk7cmV0dXJuIGZ1bmN0aW9uKC4uLm8pe2lmKG8ubGVuZ3RoIT1uLmxlbmd0aCl0aHJvdyBFcnJvcihgRXhwZWN0ZWQgJHtuLmxlbmd0aH0gYXJndW1lbnRzLCBnb3QgJHtvLmxlbmd0aH1gKTtjb25zdCBpPW8ubWFwKCgoZSxzKT0+bltzXSh0LGUsci5wYXJhbWV0ZXJzW3NdKSkpLGE9ZSguLi5pKTtyZXR1cm4gcyh0LGEsci5yZXR1cm5UeXBlKX19ZnVuY3Rpb24gaih0LGUscil7Y29uc3Qgbj1yLnBhcmFtZXRlcnMubWFwKF8pLHM9dyhyLnJldHVyblR5cGUpO3JldHVybiguLi5vKT0+e2lmKG8ubGVuZ3RoIT1uLmxlbmd0aCl0aHJvdyBFcnJvcihgRXhwZWN0ZWQgJHtuLmxlbmd0aH0gYXJndW1lbnRzLCBnb3QgJHtvLmxlbmd0aH1gKTtjb25zdCBpPVtdLGE9by5tYXAoKChlLHMpPT57Y29uc3Qgbz1uW3NdKHQsZSxyLnBhcmFtZXRlcnNbc10pO3JldHVybiBvIT09ZSYmKHQuZXhwb3J0cy5fX3BpbihvKSxpLnB1c2gobykpLG99KSksYz1lKC4uLmEpO3JldHVybiBpLmZvckVhY2goKGU9PnQuZXhwb3J0cy5fX3VucGluKGUpKSkscyh0LGMsci5yZXR1cm5UeXBlKX19ZnVuY3Rpb24geCh0LHtkZXB0aDplPU51bWJlci5QT1NJVElWRV9JTkZJTklUWX09e30pe3JldHVybiBlPD0wfHwhdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQ/dDpPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModCkubWFwKCgoW3Qscl0pPT5bdCx4KHIse2RlcHRoOmUtMX0pXSkpKX1mdW5jdGlvbiBPKHQpe2NvbnN0IGU9V2ViQXNzZW1ibHkuTW9kdWxlLmN1c3RvbVNlY3Rpb25zKHQsXCJhcy1iaW5kX2JpbmRpbmdzXCIpLHI9bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZVswXSkpO3RyeXtyZXR1cm4gSlNPTi5wYXJzZShyKX1jYXRjaCh0KXt0aHJvdyBFcnJvcihgQ291bGRu4oCZdCBkZWNvZGUgdHlwZSBkZXNjcmlwdG9yOiAke3QubWVzc2FnZX1gKX19Y2xhc3MgVXtjb25zdHJ1Y3Rvcigpe3RoaXMudW5ib3VuZEV4cG9ydHM9e30sdGhpcy5leHBvcnRzPXt9LHRoaXMuaW1wb3J0T2JqZWN0PXt9fWdldFR5cGVJZCh0KXtpZih0IGluIHRoaXMudHlwZURlc2NyaXB0b3IudHlwZUlkcylyZXR1cm4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzW3RdLmlkO3Rocm93IEVycm9yKGBVbmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0KX1gKX1nZXRUeXBlU2l6ZSh0KXtpZih0IGluIHRoaXMudHlwZURlc2NyaXB0b3IudHlwZUlkcylyZXR1cm4gdGhpcy50eXBlRGVzY3JpcHRvci50eXBlSWRzW3RdLmJ5dGVTaXplO3Rocm93IEVycm9yKGBVbmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0KX1gKX1fdmFsaWRhdGUoKXtpZighV2ViQXNzZW1ibHkuTW9kdWxlLmV4cG9ydHModGhpcy5tb2R1bGUpLmZpbmQoKHQ9PlwiX19uZXdcIj09PXQubmFtZSkpKXRocm93IEVycm9yKFwiVGhlIEFzc2VtYmx5U2NyaXB0IHdhc20gbW9kdWxlIHdhcyBub3QgYnVpbHQgd2l0aCAtLWV4cG9ydFJ1bnRpbWUsIHdoaWNoIGlzIHJlcXVpcmVkLlwiKTtpZigxIT09V2ViQXNzZW1ibHkuTW9kdWxlLmN1c3RvbVNlY3Rpb25zKHRoaXMubW9kdWxlLFwiYXMtYmluZF9iaW5kaW5nc1wiKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIEFzc2VtYmx5U2NyaXB0IHdhc20gbW9kdWxlIHdhcyBub3QgYnVpbHQgd2l0aCB0aGUgYXMtYmluZCB0cmFuc2Zvcm0uXCIpfWFzeW5jIF9pbnN0YW50aWF0ZSh0LGUpe3RoaXMubW9kdWxlPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKHQpe2lmKHQ9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKHQpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZXNwb25zZSYmdCBpbnN0YW5jZW9mIFJlc3BvbnNlKXtpZihXZWJBc3NlbWJseS5jb21waWxlU3RyZWFtaW5nKXJldHVybiBXZWJBc3NlbWJseS5jb21waWxlU3RyZWFtaW5nKHQpO3Q9YXdhaXQgdC5hcnJheUJ1ZmZlcigpfXJldHVybiBXZWJBc3NlbWJseS5jb21waWxlKHQpfSh0KSx0aGlzLl92YWxpZGF0ZSgpLHRoaXMudHlwZURlc2NyaXB0b3I9Tyh0aGlzLm1vZHVsZSksdGhpcy5faW5zdGFudGlhdGVCaW5kSW1wb3J0RnVuY3Rpb25zKGUpLHRoaXMubG9hZGVkTW9kdWxlPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGwuaW5zdGFudGlhdGUodCxlKX0odGhpcy5tb2R1bGUsdGhpcy5pbXBvcnRPYmplY3QpLHRoaXMuX2luc3RhbnRpYXRlQmluZFVuYm91bmRFeHBvcnRzKCl9X2luc3RhbnRpYXRlU3luYyh0LGUpe3RoaXMubW9kdWxlPW5ldyBXZWJBc3NlbWJseS5Nb2R1bGUodCksdGhpcy5fdmFsaWRhdGUoKSx0aGlzLnR5cGVEZXNjcmlwdG9yPU8odGhpcy5tb2R1bGUpLHRoaXMuX2luc3RhbnRpYXRlQmluZEltcG9ydEZ1bmN0aW9ucyhlKSx0aGlzLmxvYWRlZE1vZHVsZT1mdW5jdGlvbih0LGUpe3JldHVybiBsLmluc3RhbnRpYXRlU3luYyh0LGUpfSh0aGlzLm1vZHVsZSx0aGlzLmltcG9ydE9iamVjdCksdGhpcy5faW5zdGFudGlhdGVCaW5kVW5ib3VuZEV4cG9ydHMoKX1faW5zdGFudGlhdGVCaW5kSW1wb3J0RnVuY3Rpb25zKHQpe3RoaXMuaW1wb3J0T2JqZWN0PXgodCx7ZGVwdGg6Mn0pO2Zvcihjb25zdFtlLHJdb2YgT2JqZWN0LmVudHJpZXModGhpcy50eXBlRGVzY3JpcHRvci5pbXBvcnRlZEZ1bmN0aW9ucykpZm9yKGNvbnN0W24sc11vZiBPYmplY3QuZW50cmllcyhyKSl0aGlzLmltcG9ydE9iamVjdFtlXVtgX19hc2JpbmRfdW5ib3VuZF8ke259YF09dFtlXVtuXSx0aGlzLmltcG9ydE9iamVjdFtlXVtuXT1UKHRoaXMsdFtlXVtuXSxzKX1faW5zdGFudGlhdGVCaW5kVW5ib3VuZEV4cG9ydHMoKXtjb25zdCB0PXRoaXMubG9hZGVkTW9kdWxlLmV4cG9ydHM7dGhpcy5leHBvcnRzPXgodCx7ZGVwdGg6MX0pO2Zvcihjb25zdFtlLHJdb2YgT2JqZWN0LmVudHJpZXModGhpcy50eXBlRGVzY3JpcHRvci5leHBvcnRlZEZ1bmN0aW9ucykpdGhpcy5leHBvcnRzW2VdPWoodGhpcyx0W2VdLHIpfX1leHBvcnRzLmNvbnZlcnRlcnM9bSxleHBvcnRzLmluc3RhbnRpYXRlPWFzeW5jIGZ1bmN0aW9uKHQsZSl7bGV0IHI9bmV3IFU7cmV0dXJuIGF3YWl0IHIuX2luc3RhbnRpYXRlKHQsZSkscn0sZXhwb3J0cy5pbnN0YW50aWF0ZVN5bmM9ZnVuY3Rpb24odCxlKXtsZXQgcj1uZXcgVTtyZXR1cm4gci5faW5zdGFudGlhdGVTeW5jKHQsZSkscn0sZXhwb3J0cy52ZXJzaW9uPVwiMC44LjFcIjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIG1xdHQgPSByZXF1aXJlKFwibXF0dFwiKTtcbnZhciBpbkFycmF5ID0gcmVxdWlyZShcImluLWFycmF5XCIpO1xuXG52YXIgUmVndWxhckNsaWVudFByb3RvdHlwZSA9IG1xdHQuTXF0dENsaWVudC5wcm90b3R5cGU7XG5cbnZhciBBU1lOQ19NRVRIT0RTID0gW1wicHVibGlzaFwiLFxuXHRcInN1YnNjcmliZVwiLFxuXHRcInVuc3Vic2NyaWJlXCIsXG5cdFwidW5zdWJzY3JpYmVcIixcblx0XCJlbmRcIlxuXTtcblxudmFyIFNZTkNfTUVUSE9EUyA9IFtcblx0XCJlbWl0XCIsXG5cdFwiYWRkTGlzdGVuZXJcIixcblx0XCJvblwiLFxuXHRcIm9uY2VcIixcblx0XCJyZW1vdmVMaXN0ZW5lclwiLFxuXHRcInJlbW92ZUFsbExpc3RlbmVyc1wiLFxuXHRcInNldE1heExpc3RlbmVyc1wiLFxuXHRcImdldE1heExpc3RlbmVyc1wiLFxuXHRcImxpc3RlbmVyc1wiLFxuXHRcImxpc3RlbmVyQ291bnRcIlxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNvbm5lY3Q6IGNvbm5lY3QsXG5cdEFzeW5jQ2xpZW50OiBBc3luY0NsaWVudFxufTtcblxuZnVuY3Rpb24gY29ubmVjdChicm9rZXJVUkwsIG9wdHMpIHtcblx0dmFyIGNsaWVudCA9IG1xdHQuY29ubmVjdChicm9rZXJVUkwsIG9wdHMpO1xuXG5cdHZhciBhc3luY0NsaWVudCA9IG5ldyBBc3luY0NsaWVudChjbGllbnQpO1xuXG5cdHJldHVybiBhc3luY0NsaWVudDtcbn1cblxuZnVuY3Rpb24gQXN5bmNDbGllbnQoY2xpZW50KSB7XG5cdHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbn1cblxuQXN5bmNDbGllbnQucHJvdG90eXBlID0ge1xuXHRzZXQgaGFuZGxlTWVzc2FnZShuZXdIYW5kbGVyKSB7XG5cdFx0dGhpcy5fY2xpZW50LmhhbmRsZU1lc3NhZ2UgPSBuZXdIYW5kbGVyO1xuXHR9LFxuXHRnZXQgaGFuZGxlTWVzc2FnZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xpZW50LmhhbmRsZU1lc3NhZ2U7XG5cdH1cbn07XG5cbkFTWU5DX01FVEhPRFMuZm9yRWFjaChkZWZpbmVBc3luYyk7XG5TWU5DX01FVEhPRFMuZm9yRWFjaChkZWZpbmVQYXNzdGhyb3VnaCk7XG5cbmZ1bmN0aW9uIGRlZmluZVBhc3N0aHJvdWdoKG5hbWUpIHtcblx0QXN5bmNDbGllbnQucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaWVudCA9IHRoaXMuX2NsaWVudDtcblx0XHRyZXR1cm4gY2xpZW50W25hbWVdLmFwcGx5KGNsaWVudCwgYXJndW1lbnRzKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lQXN5bmMobmFtZSkge1xuXHRBc3luY0NsaWVudC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBhc3luY01ldGhvZCgpIHtcblx0XHR2YXIgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuXHRcdHZhciBhcmdzID0gW107XG5cdFx0dmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGZvciAoaTsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRhcmdzLnB1c2gobWFrZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuXHRcdFx0Y2xpZW50W25hbWVdLmFwcGx5KGNsaWVudCwgYXJncyk7XG5cdFx0fSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1ha2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdGlmIChlcnIpXG5cdFx0XHRyZWplY3QoZXJyKTtcblx0XHRlbHNlIHJlc29sdmUoZGF0YSk7XG5cdH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJ2YXIgRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleCcpXG4gICwgdXRpbCAgICAgICAgID0gcmVxdWlyZSgndXRpbCcpXG4gICwgQnVmZmVyICAgICAgID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuXG5mdW5jdGlvbiBCdWZmZXJMaXN0IChjYWxsYmFjaykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGNhbGxiYWNrKVxuXG4gIHRoaXMuX2J1ZnMgID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFja1xuXG4gICAgdmFyIHBpcGVyID0gZnVuY3Rpb24gcGlwZXIgKGVycikge1xuICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKGVycilcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLm9uKCdwaXBlJywgZnVuY3Rpb24gb25QaXBlIChzcmMpIHtcbiAgICAgIHNyYy5vbignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICAgIHRoaXMub24oJ3VucGlwZScsIGZ1bmN0aW9uIG9uVW5waXBlIChzcmMpIHtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXBwZW5kKGNhbGxiYWNrKVxuICB9XG5cbiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcylcbn1cblxuXG51dGlsLmluaGVyaXRzKEJ1ZmZlckxpc3QsIER1cGxleFN0cmVhbSlcblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fb2Zmc2V0ID0gZnVuY3Rpb24gX29mZnNldCAob2Zmc2V0KSB7XG4gIHZhciB0b3QgPSAwLCBpID0gMCwgX3RcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIFsgMCwgMCBdXG4gIGZvciAoOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIF90ID0gdG90ICsgdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICBpZiAob2Zmc2V0IDwgX3QgfHwgaSA9PSB0aGlzLl9idWZzLmxlbmd0aCAtIDEpXG4gICAgICByZXR1cm4gWyBpLCBvZmZzZXQgLSB0b3QgXVxuICAgIHRvdCA9IF90XG4gIH1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKGJ1Zikge1xuICB2YXIgaSA9IDBcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ1ZikpIHtcbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYXBwZW5kKGJ1ZltpXSlcbiAgfSBlbHNlIGlmIChidWYgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSB7XG4gICAgLy8gdW53cmFwIGFyZ3VtZW50IGludG8gaW5kaXZpZHVhbCBCdWZmZXJMaXN0c1xuICAgIGZvciAoOyBpIDwgYnVmLl9idWZzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5hcHBlbmQoYnVmLl9idWZzW2ldKVxuICB9IGVsc2UgaWYgKGJ1ZiAhPSBudWxsKSB7XG4gICAgLy8gY29lcmNlIG51bWJlciBhcmd1bWVudHMgdG8gc3RyaW5ncywgc2luY2UgQnVmZmVyKG51bWJlcikgZG9lc1xuICAgIC8vIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IGFsbG9jYXRpb25cbiAgICBpZiAodHlwZW9mIGJ1ZiA9PSAnbnVtYmVyJylcbiAgICAgIGJ1ZiA9IGJ1Zi50b1N0cmluZygpXG5cbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmKSk7XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gX3dyaXRlIChidWYsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB0aGlzLl9hcHBlbmRCdWZmZXIoYnVmKVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJylcbiAgICBjYWxsYmFjaygpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiBfcmVhZCAoc2l6ZSkge1xuICBpZiAoIXRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLnB1c2gobnVsbClcblxuICBzaXplID0gTWF0aC5taW4oc2l6ZSwgdGhpcy5sZW5ndGgpXG4gIHRoaXMucHVzaCh0aGlzLnNsaWNlKDAsIHNpemUpKVxuICB0aGlzLmNvbnN1bWUoc2l6ZSlcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKGNodW5rKSB7XG4gIER1cGxleFN0cmVhbS5wcm90b3R5cGUuZW5kLmNhbGwodGhpcywgY2h1bmspXG5cbiAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5zbGljZSgpKVxuICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICB9XG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICByZXR1cm4gdGhpcy5zbGljZShpbmRleCwgaW5kZXggKyAxKVswXVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAnbnVtYmVyJyAmJiBzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ251bWJlcicgJiYgZW5kIDwgMClcbiAgICBlbmQgKz0gdGhpcy5sZW5ndGhcbiAgcmV0dXJuIHRoaXMuY29weShudWxsLCAwLCBzdGFydCwgZW5kKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkc3QsIGRzdFN0YXJ0LCBzcmNTdGFydCwgc3JjRW5kKSB7XG4gIGlmICh0eXBlb2Ygc3JjU3RhcnQgIT0gJ251bWJlcicgfHwgc3JjU3RhcnQgPCAwKVxuICAgIHNyY1N0YXJ0ID0gMFxuICBpZiAodHlwZW9mIHNyY0VuZCAhPSAnbnVtYmVyJyB8fCBzcmNFbmQgPiB0aGlzLmxlbmd0aClcbiAgICBzcmNFbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoc3JjU3RhcnQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcbiAgaWYgKHNyY0VuZCA8PSAwKVxuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG5cbiAgdmFyIGNvcHkgICA9ICEhZHN0XG4gICAgLCBvZmYgICAgPSB0aGlzLl9vZmZzZXQoc3JjU3RhcnQpXG4gICAgLCBsZW4gICAgPSBzcmNFbmQgLSBzcmNTdGFydFxuICAgICwgYnl0ZXMgID0gbGVuXG4gICAgLCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICAgICwgc3RhcnQgID0gb2ZmWzFdXG4gICAgLCBsXG4gICAgLCBpXG5cbiAgLy8gY29weS9zbGljZSBldmVyeXRoaW5nXG4gIGlmIChzcmNTdGFydCA9PT0gMCAmJiBzcmNFbmQgPT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIHsgLy8gc2xpY2UsIGJ1dCBmdWxsIGNvbmNhdCBpZiBtdWx0aXBsZSBidWZmZXJzXG4gICAgICByZXR1cm4gdGhpcy5fYnVmcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLl9idWZzWzBdXG4gICAgICAgIDogQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZzLCB0aGlzLmxlbmd0aClcbiAgICB9XG5cbiAgICAvLyBjb3B5LCBuZWVkIHRvIGNvcHkgaW5kaXZpZHVhbCBidWZmZXJzXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZilcbiAgICAgIGJ1Zm9mZiArPSB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBkc3RcbiAgfVxuXG4gIC8vIGVhc3ksIGNoZWFwIGNhc2Ugd2hlcmUgaXQncyBhIHN1YnNldCBvZiBvbmUgb2YgdGhlIGJ1ZmZlcnNcbiAgaWYgKGJ5dGVzIDw9IHRoaXMuX2J1ZnNbb2ZmWzBdXS5sZW5ndGggLSBzdGFydCkge1xuICAgIHJldHVybiBjb3B5XG4gICAgICA/IHRoaXMuX2J1ZnNbb2ZmWzBdXS5jb3B5KGRzdCwgZHN0U3RhcnQsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgOiB0aGlzLl9idWZzW29mZlswXV0uc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gIH1cblxuICBpZiAoIWNvcHkpIC8vIGEgc2xpY2UsIHdlIG5lZWQgc29tZXRoaW5nIHRvIGNvcHkgaW4gdG9cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuXG4gIGZvciAoaSA9IG9mZlswXTsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsID0gdGhpcy5fYnVmc1tpXS5sZW5ndGggLSBzdGFydFxuXG4gICAgaWYgKGJ5dGVzID4gbCkge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydClcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICBidWZvZmYgKz0gbFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBieXRlcyAtPSBsXG5cbiAgICBpZiAoc3RhcnQpXG4gICAgICBzdGFydCA9IDBcbiAgfVxuXG4gIC8vIHNhZmVndWFyZCBzbyB0aGF0IHdlIGRvbid0IHJldHVybiB1bmluaXRpYWxpemVkIG1lbW9yeVxuICBpZiAoZHN0Lmxlbmd0aCA+IGJ1Zm9mZikgcmV0dXJuIGRzdC5zbGljZSgwLCBidWZvZmYpXG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aFxuXG4gIGlmIChzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8IDApXG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KHN0YXJ0KVxuICAgICwgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KGVuZClcbiAgICAsIGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT0gMClcbiAgICBidWZmZXJzLnBvcCgpXG4gIGVsc2VcbiAgICBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoLTFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXS5zbGljZSgwLCBlbmRPZmZzZXRbMV0pXG5cbiAgaWYgKHN0YXJ0T2Zmc2V0WzFdICE9IDApXG4gICAgYnVmZmVyc1swXSA9IGJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnRPZmZzZXRbMV0pXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1ZmZlcnMpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gY29uc3VtZSAoYnl0ZXMpIHtcbiAgLy8gZmlyc3QsIG5vcm1hbGl6ZSB0aGUgYXJndW1lbnQsIGluIGFjY29yZGFuY2Ugd2l0aCBob3cgQnVmZmVyIGRvZXMgaXRcbiAgYnl0ZXMgPSBNYXRoLnRydW5jKGJ5dGVzKVxuICAvLyBkbyBub3RoaW5nIGlmIG5vdCBhIHBvc2l0aXZlIG51bWJlclxuICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGVzKSB8fCBieXRlcyA8PSAwKSByZXR1cm4gdGhpc1xuXG4gIHdoaWxlICh0aGlzLl9idWZzLmxlbmd0aCkge1xuICAgIGlmIChieXRlcyA+PSB0aGlzLl9idWZzWzBdLmxlbmd0aCkge1xuICAgICAgYnl0ZXMgLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMubGVuZ3RoIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLl9idWZzLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1swXSA9IHRoaXMuX2J1ZnNbMF0uc2xpY2UoYnl0ZXMpXG4gICAgICB0aGlzLmxlbmd0aCAtPSBieXRlc1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiBkdXBsaWNhdGUgKCkge1xuICB2YXIgaSA9IDBcbiAgICAsIGNvcHkgPSBuZXcgQnVmZmVyTGlzdCgpXG5cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKVxuICAgIGNvcHkuYXBwZW5kKHRoaXMuX2J1ZnNbaV0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHRoaXMuX2J1ZnMubGVuZ3RoID0gMFxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5wdXNoKG51bGwpXG59XG5cblxuOyhmdW5jdGlvbiAoKSB7XG4gIHZhciBtZXRob2RzID0ge1xuICAgICAgJ3JlYWREb3VibGVCRScgOiA4XG4gICAgLCAncmVhZERvdWJsZUxFJyA6IDhcbiAgICAsICdyZWFkRmxvYXRCRScgIDogNFxuICAgICwgJ3JlYWRGbG9hdExFJyAgOiA0XG4gICAgLCAncmVhZEludDMyQkUnICA6IDRcbiAgICAsICdyZWFkSW50MzJMRScgIDogNFxuICAgICwgJ3JlYWRVSW50MzJCRScgOiA0XG4gICAgLCAncmVhZFVJbnQzMkxFJyA6IDRcbiAgICAsICdyZWFkSW50MTZCRScgIDogMlxuICAgICwgJ3JlYWRJbnQxNkxFJyAgOiAyXG4gICAgLCAncmVhZFVJbnQxNkJFJyA6IDJcbiAgICAsICdyZWFkVUludDE2TEUnIDogMlxuICAgICwgJ3JlYWRJbnQ4JyAgICAgOiAxXG4gICAgLCAncmVhZFVJbnQ4JyAgICA6IDFcbiAgfVxuXG4gIGZvciAodmFyIG0gaW4gbWV0aG9kcykge1xuICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgIH1cbiAgICB9KG0pKVxuICB9XG59KCkpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiMTAwXCI6IFwiQ29udGludWVcIixcbiAgXCIxMDFcIjogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIFwiMTAyXCI6IFwiUHJvY2Vzc2luZ1wiLFxuICBcIjIwMFwiOiBcIk9LXCIsXG4gIFwiMjAxXCI6IFwiQ3JlYXRlZFwiLFxuICBcIjIwMlwiOiBcIkFjY2VwdGVkXCIsXG4gIFwiMjAzXCI6IFwiTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb25cIixcbiAgXCIyMDRcIjogXCJObyBDb250ZW50XCIsXG4gIFwiMjA1XCI6IFwiUmVzZXQgQ29udGVudFwiLFxuICBcIjIwNlwiOiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICBcIjIwN1wiOiBcIk11bHRpLVN0YXR1c1wiLFxuICBcIjIwOFwiOiBcIkFscmVhZHkgUmVwb3J0ZWRcIixcbiAgXCIyMjZcIjogXCJJTSBVc2VkXCIsXG4gIFwiMzAwXCI6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICBcIjMwMVwiOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gIFwiMzAyXCI6IFwiRm91bmRcIixcbiAgXCIzMDNcIjogXCJTZWUgT3RoZXJcIixcbiAgXCIzMDRcIjogXCJOb3QgTW9kaWZpZWRcIixcbiAgXCIzMDVcIjogXCJVc2UgUHJveHlcIixcbiAgXCIzMDdcIjogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgXCIzMDhcIjogXCJQZXJtYW5lbnQgUmVkaXJlY3RcIixcbiAgXCI0MDBcIjogXCJCYWQgUmVxdWVzdFwiLFxuICBcIjQwMVwiOiBcIlVuYXV0aG9yaXplZFwiLFxuICBcIjQwMlwiOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgXCI0MDNcIjogXCJGb3JiaWRkZW5cIixcbiAgXCI0MDRcIjogXCJOb3QgRm91bmRcIixcbiAgXCI0MDVcIjogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgXCI0MDZcIjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICBcIjQwN1wiOiBcIlByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDA4XCI6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIFwiNDA5XCI6IFwiQ29uZmxpY3RcIixcbiAgXCI0MTBcIjogXCJHb25lXCIsXG4gIFwiNDExXCI6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIFwiNDEyXCI6IFwiUHJlY29uZGl0aW9uIEZhaWxlZFwiLFxuICBcIjQxM1wiOiBcIlBheWxvYWQgVG9vIExhcmdlXCIsXG4gIFwiNDE0XCI6IFwiVVJJIFRvbyBMb25nXCIsXG4gIFwiNDE1XCI6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICBcIjQxNlwiOiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiLFxuICBcIjQxN1wiOiBcIkV4cGVjdGF0aW9uIEZhaWxlZFwiLFxuICBcIjQxOFwiOiBcIkknbSBhIHRlYXBvdFwiLFxuICBcIjQyMVwiOiBcIk1pc2RpcmVjdGVkIFJlcXVlc3RcIixcbiAgXCI0MjJcIjogXCJVbnByb2Nlc3NhYmxlIEVudGl0eVwiLFxuICBcIjQyM1wiOiBcIkxvY2tlZFwiLFxuICBcIjQyNFwiOiBcIkZhaWxlZCBEZXBlbmRlbmN5XCIsXG4gIFwiNDI1XCI6IFwiVW5vcmRlcmVkIENvbGxlY3Rpb25cIixcbiAgXCI0MjZcIjogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gIFwiNDI4XCI6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gIFwiNDI5XCI6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgXCI0MzFcIjogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gIFwiNDUxXCI6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgXCI1MDBcIjogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgXCI1MDFcIjogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgXCI1MDJcIjogXCJCYWQgR2F0ZXdheVwiLFxuICBcIjUwM1wiOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgXCI1MDRcIjogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgXCI1MDVcIjogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICBcIjUwNlwiOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gIFwiNTA3XCI6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgXCI1MDhcIjogXCJMb29wIERldGVjdGVkXCIsXG4gIFwiNTA5XCI6IFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXCIsXG4gIFwiNTEwXCI6IFwiTm90IEV4dGVuZGVkXCIsXG4gIFwiNTExXCI6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCJ2YXIgY2xvbmUgPSAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiovXG5mdW5jdGlvbiBjbG9uZShwYXJlbnQsIGNpcmN1bGFyLCBkZXB0aCwgcHJvdG90eXBlKSB7XG4gIHZhciBmaWx0ZXI7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgZmlsdGVyID0gY2lyY3VsYXIuZmlsdGVyO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXJcbiAgfVxuICAvLyBtYWludGFpbiB0d28gYXJyYXlzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzLCB3aGVyZSBjb3JyZXNwb25kaW5nIHBhcmVudHNcbiAgLy8gYW5kIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgaW5kZXhcbiAgdmFyIGFsbFBhcmVudHMgPSBbXTtcbiAgdmFyIGFsbENoaWxkcmVuID0gW107XG5cbiAgdmFyIHVzZUJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PSAndW5kZWZpbmVkJylcbiAgICBjaXJjdWxhciA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBkZXB0aCA9PSAndW5kZWZpbmVkJylcbiAgICBkZXB0aCA9IEluZmluaXR5O1xuXG4gIC8vIHJlY3Vyc2UgdGhpcyBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNldCBhbGxQYXJlbnRzIGFuZCBhbGxDaGlsZHJlblxuICBmdW5jdGlvbiBfY2xvbmUocGFyZW50LCBkZXB0aCkge1xuICAgIC8vIGNsb25pbmcgbnVsbCBhbHdheXMgcmV0dXJucyBudWxsXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufTtcbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcbmNsb25lLl9faXNEYXRlID0gX19pc0RhdGU7XG5cbmZ1bmN0aW9uIF9faXNBcnJheShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufTtcbmNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzO1xuXG5yZXR1cm4gY2xvbmU7XG59KSgpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCJ0eXBlL3ZhbHVlL2lzXCIpXG4gICwgZW5zdXJlVmFsdWUgICAgICAgICA9IHJlcXVpcmUoXCJ0eXBlL3ZhbHVlL2Vuc3VyZVwiKVxuICAsIGVuc3VyZVBsYWluRnVuY3Rpb24gPSByZXF1aXJlKFwidHlwZS9wbGFpbi1mdW5jdGlvbi9lbnN1cmVcIilcbiAgLCBjb3B5ICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2NvcHlcIilcbiAgLCBub3JtYWxpemVPcHRpb25zICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCIpXG4gICwgbWFwICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9tYXBcIik7XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlZmluZTtcblxuZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlc2MsIG9wdGlvbnMpIHtcblx0dmFyIHZhbHVlID0gZW5zdXJlVmFsdWUoZGVzYykgJiYgZW5zdXJlUGxhaW5GdW5jdGlvbihkZXNjLnZhbHVlKSwgZGdzO1xuXHRkZ3MgPSBjb3B5KGRlc2MpO1xuXHRkZWxldGUgZGdzLndyaXRhYmxlO1xuXHRkZWxldGUgZGdzLnZhbHVlO1xuXHRkZ3MuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghb3B0aW9ucy5vdmVyd3JpdGVEZWZpbml0aW9uICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHJldHVybiB2YWx1ZTtcblx0XHRkZXNjLnZhbHVlID0gYmluZC5jYWxsKHZhbHVlLCBvcHRpb25zLnJlc29sdmVDb250ZXh0ID8gb3B0aW9ucy5yZXNvbHZlQ29udGV4dCh0aGlzKSA6IHRoaXMpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGRlc2MpO1xuXHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHR9O1xuXHRyZXR1cm4gZGdzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBvcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhhcmd1bWVudHNbMV0pO1xuXHRpZiAoaXNWYWx1ZShvcHRpb25zLnJlc29sdmVDb250ZXh0KSkgZW5zdXJlUGxhaW5GdW5jdGlvbihvcHRpb25zLnJlc29sdmVDb250ZXh0KTtcblx0cmV0dXJuIG1hcChwcm9wcywgZnVuY3Rpb24gKGRlc2MsIG5hbWUpIHsgcmV0dXJuIGRlZmluZShuYW1lLCBkZXNjLCBvcHRpb25zKTsgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlICAgICAgICAgPSByZXF1aXJlKFwidHlwZS92YWx1ZS9pc1wiKVxuICAsIGlzUGxhaW5GdW5jdGlvbiA9IHJlcXVpcmUoXCJ0eXBlL3BsYWluLWZ1bmN0aW9uL2lzXCIpXG4gICwgYXNzaWduICAgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiKVxuICAsIG5vcm1hbGl6ZU9wdHMgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9uc1wiKVxuICAsIGNvbnRhaW5zICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCIpO1xuXG52YXIgZCA9IChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkc2NyLCB2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIHcsIG9wdGlvbnMsIGRlc2M7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCB0eXBlb2YgZHNjciAhPT0gXCJzdHJpbmdcIikge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoaXNWYWx1ZShkc2NyKSkge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsIFwiY1wiKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCBcImVcIik7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJ3XCIpO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn0pO1xuXG5kLmdzID0gZnVuY3Rpb24gKGRzY3IsIGdldCwgc2V0LyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgb3B0aW9ucywgZGVzYztcblx0aWYgKHR5cGVvZiBkc2NyICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmICghaXNWYWx1ZShnZXQpKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc1BsYWluRnVuY3Rpb24oZ2V0KSkge1xuXHRcdG9wdGlvbnMgPSBnZXQ7XG5cdFx0Z2V0ID0gc2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc1ZhbHVlKHNldCkpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzUGxhaW5GdW5jdGlvbihzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGlzVmFsdWUoZHNjcikpIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCBcImNcIik7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJlXCIpO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fVxuXG5cdGRlc2MgPSB7IGdldDogZ2V0LCBzZXQ6IHNldCwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlIH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2hpZnQgPSByZXF1aXJlKCdzdHJlYW0tc2hpZnQnKVxuXG52YXIgU0lHTkFMX0ZMVVNIID0gKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pXG4gID8gQnVmZmVyLmZyb20oWzBdKVxuICA6IG5ldyBCdWZmZXIoWzBdKVxuXG52YXIgb251bmNvcmsgPSBmdW5jdGlvbihzZWxmLCBmbikge1xuICBpZiAoc2VsZi5fY29ya2VkKSBzZWxmLm9uY2UoJ3VuY29yaycsIGZuKVxuICBlbHNlIGZuKClcbn1cblxudmFyIGF1dG9EZXN0cm95ID0gZnVuY3Rpb24gKHNlbGYsIGVycikge1xuICBpZiAoc2VsZi5fYXV0b0Rlc3Ryb3kpIHNlbGYuZGVzdHJveShlcnIpXG59XG5cbnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbihzZWxmLCBlbmQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIGF1dG9EZXN0cm95KHNlbGYsIGVyci5tZXNzYWdlID09PSAncHJlbWF0dXJlIGNsb3NlJyA/IG51bGwgOiBlcnIpXG4gICAgZWxzZSBpZiAoZW5kICYmICFzZWxmLl9lbmRlZCkgc2VsZi5lbmQoKVxuICB9XG59XG5cbnZhciBlbmQgPSBmdW5jdGlvbih3cywgZm4pIHtcbiAgaWYgKCF3cykgcmV0dXJuIGZuKClcbiAgaWYgKHdzLl93cml0YWJsZVN0YXRlICYmIHdzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSByZXR1cm4gZm4oKVxuICBpZiAod3MuX3dyaXRhYmxlU3RhdGUpIHJldHVybiB3cy5lbmQoZm4pXG4gIHdzLmVuZCgpXG4gIGZuKClcbn1cblxudmFyIHRvU3RyZWFtczIgPSBmdW5jdGlvbihycykge1xuICByZXR1cm4gbmV3IChzdHJlYW0uUmVhZGFibGUpKHtvYmplY3RNb2RlOnRydWUsIGhpZ2hXYXRlck1hcms6MTZ9KS53cmFwKHJzKVxufVxuXG52YXIgRHVwbGV4aWZ5ID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXhpZnkpKSByZXR1cm4gbmV3IER1cGxleGlmeSh3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpXG4gIHN0cmVhbS5EdXBsZXguY2FsbCh0aGlzLCBvcHRzKVxuXG4gIHRoaXMuX3dyaXRhYmxlID0gbnVsbFxuICB0aGlzLl9yZWFkYWJsZSA9IG51bGxcbiAgdGhpcy5fcmVhZGFibGUyID0gbnVsbFxuXG4gIHRoaXMuX2F1dG9EZXN0cm95ID0gIW9wdHMgfHwgb3B0cy5hdXRvRGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZERlc3Ryb3kgPSAhb3B0cyB8fCBvcHRzLmRlc3Ryb3kgIT09IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmRFbmQgPSAhb3B0cyB8fCBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgdGhpcy5fY29ya2VkID0gMSAvLyBzdGFydCBjb3JrZWRcbiAgdGhpcy5fb25kcmFpbiA9IG51bGxcbiAgdGhpcy5fZHJhaW5lZCA9IGZhbHNlXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxuICB0aGlzLl91bndyaXRlID0gbnVsbFxuICB0aGlzLl91bnJlYWQgPSBudWxsXG4gIHRoaXMuX2VuZGVkID0gZmFsc2VcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG5cbiAgaWYgKHdyaXRhYmxlKSB0aGlzLnNldFdyaXRhYmxlKHdyaXRhYmxlKVxuICBpZiAocmVhZGFibGUpIHRoaXMuc2V0UmVhZGFibGUocmVhZGFibGUpXG59XG5cbmluaGVyaXRzKER1cGxleGlmeSwgc3RyZWFtLkR1cGxleClcblxuRHVwbGV4aWZ5Lm9iaiA9IGZ1bmN0aW9uKHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBvcHRzLm9iamVjdE1vZGUgPSB0cnVlXG4gIG9wdHMuaGlnaFdhdGVyTWFyayA9IDE2XG4gIHJldHVybiBuZXcgRHVwbGV4aWZ5KHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIGlmICgrK3RoaXMuX2NvcmtlZCA9PT0gMSkgdGhpcy5lbWl0KCdjb3JrJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2NvcmtlZCAmJiAtLXRoaXMuX2NvcmtlZCA9PT0gMCkgdGhpcy5lbWl0KCd1bmNvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFdyaXRhYmxlID0gZnVuY3Rpb24od3JpdGFibGUpIHtcbiAgaWYgKHRoaXMuX3Vud3JpdGUpIHRoaXMuX3Vud3JpdGUoKVxuXG4gIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgIGlmICh3cml0YWJsZSAmJiB3cml0YWJsZS5kZXN0cm95KSB3cml0YWJsZS5kZXN0cm95KClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh3cml0YWJsZSA9PT0gbnVsbCB8fCB3cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICB0aGlzLmVuZCgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHVuZW5kID0gZW9zKHdyaXRhYmxlLCB7d3JpdGFibGU6dHJ1ZSwgcmVhZGFibGU6ZmFsc2V9LCBkZXN0cm95ZXIodGhpcywgdGhpcy5fZm9yd2FyZEVuZCkpXG5cbiAgdmFyIG9uZHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb25kcmFpbiA9IHNlbGYuX29uZHJhaW5cbiAgICBzZWxmLl9vbmRyYWluID0gbnVsbFxuICAgIGlmIChvbmRyYWluKSBvbmRyYWluKClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3dyaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgaWYgKHRoaXMuX3Vud3JpdGUpIHByb2Nlc3MubmV4dFRpY2sob25kcmFpbikgLy8gZm9yY2UgYSBkcmFpbiBvbiBzdHJlYW0gcmVzZXQgdG8gYXZvaWQgbGl2ZWxvY2tzXG5cbiAgdGhpcy5fd3JpdGFibGUgPSB3cml0YWJsZVxuICB0aGlzLl93cml0YWJsZS5vbignZHJhaW4nLCBvbmRyYWluKVxuICB0aGlzLl91bndyaXRlID0gY2xlYXJcblxuICB0aGlzLnVuY29yaygpIC8vIGFsd2F5cyB1bmNvcmsgc2V0V3JpdGFibGVcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5zZXRSZWFkYWJsZSA9IGZ1bmN0aW9uKHJlYWRhYmxlKSB7XG4gIGlmICh0aGlzLl91bnJlYWQpIHRoaXMuX3VucmVhZCgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHJlYWRhYmxlICYmIHJlYWRhYmxlLmRlc3Ryb3kpIHJlYWRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHJlYWRhYmxlID09PSBudWxsIHx8IHJlYWRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMucHVzaChudWxsKVxuICAgIHRoaXMucmVzdW1lKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3MocmVhZGFibGUsIHt3cml0YWJsZTpmYWxzZSwgcmVhZGFibGU6dHJ1ZX0sIGRlc3Ryb3llcih0aGlzKSlcblxuICB2YXIgb25yZWFkYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2ZvcndhcmQoKVxuICB9XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wdXNoKG51bGwpXG4gIH1cblxuICB2YXIgY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9yZWFkYWJsZTIucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgb25yZWFkYWJsZSlcbiAgICBzZWxmLl9yZWFkYWJsZTIucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHVuZW5kKClcbiAgfVxuXG4gIHRoaXMuX2RyYWluZWQgPSB0cnVlXG4gIHRoaXMuX3JlYWRhYmxlID0gcmVhZGFibGVcbiAgdGhpcy5fcmVhZGFibGUyID0gcmVhZGFibGUuX3JlYWRhYmxlU3RhdGUgPyByZWFkYWJsZSA6IHRvU3RyZWFtczIocmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICB0aGlzLl9yZWFkYWJsZTIub24oJ2VuZCcsIG9uZW5kKVxuICB0aGlzLl91bnJlYWQgPSBjbGVhclxuXG4gIHRoaXMuX2ZvcndhcmQoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2RyYWluZWQgPSB0cnVlXG4gIHRoaXMuX2ZvcndhcmQoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9mb3J3YXJkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mb3J3YXJkaW5nIHx8ICF0aGlzLl9yZWFkYWJsZTIgfHwgIXRoaXMuX2RyYWluZWQpIHJldHVyblxuICB0aGlzLl9mb3J3YXJkaW5nID0gdHJ1ZVxuXG4gIHZhciBkYXRhXG5cbiAgd2hpbGUgKHRoaXMuX2RyYWluZWQgJiYgKGRhdGEgPSBzaGlmdCh0aGlzLl9yZWFkYWJsZTIpKSAhPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgY29udGludWVcbiAgICB0aGlzLl9kcmFpbmVkID0gdGhpcy5wdXNoKGRhdGEpXG4gIH1cblxuICB0aGlzLl9mb3J3YXJkaW5nID0gZmFsc2Vcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2Rlc3Ryb3koZXJyKVxuICB9KVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmIChlcnIpIHtcbiAgICB2YXIgb25kcmFpbiA9IHRoaXMuX29uZHJhaW5cbiAgICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICAgIGlmIChvbmRyYWluKSBvbmRyYWluKGVycilcbiAgICBlbHNlIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cblxuICBpZiAodGhpcy5fZm9yd2FyZERlc3Ryb3kpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGUgJiYgdGhpcy5fcmVhZGFibGUuZGVzdHJveSkgdGhpcy5fcmVhZGFibGUuZGVzdHJveSgpXG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlICYmIHRoaXMuX3dyaXRhYmxlLmRlc3Ryb3kpIHRoaXMuX3dyaXRhYmxlLmRlc3Ryb3koKVxuICB9XG5cbiAgdGhpcy5lbWl0KCdjbG9zZScpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZW5jLCBjYikge1xuICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybiBjYigpXG4gIGlmICh0aGlzLl9jb3JrZWQpIHJldHVybiBvbnVuY29yayh0aGlzLCB0aGlzLl93cml0ZS5iaW5kKHRoaXMsIGRhdGEsIGVuYywgY2IpKVxuICBpZiAoZGF0YSA9PT0gU0lHTkFMX0ZMVVNIKSByZXR1cm4gdGhpcy5fZmluaXNoKGNiKVxuICBpZiAoIXRoaXMuX3dyaXRhYmxlKSByZXR1cm4gY2IoKVxuXG4gIGlmICh0aGlzLl93cml0YWJsZS53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHRoaXMuX29uZHJhaW4gPSBjYlxuICBlbHNlIGNiKClcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuZW1pdCgncHJlZW5kJylcbiAgb251bmNvcmsodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZW5kKHNlbGYuX2ZvcndhcmRFbmQgJiYgc2VsZi5fd3JpdGFibGUsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaGF4eCB0byBub3QgZW1pdCBwcmVmaW5pc2ggdHdpY2VcbiAgICAgIGlmIChzZWxmLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID09PSBmYWxzZSkgc2VsZi5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWVcbiAgICAgIHNlbGYuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIG9udW5jb3JrKHNlbGYsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZGF0YSwgZW5jLCBjYikge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzLmVuZChudWxsLCBudWxsLCBkYXRhKVxuICBpZiAodHlwZW9mIGVuYyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKGRhdGEsIG51bGwsIGVuYylcbiAgdGhpcy5fZW5kZWQgPSB0cnVlXG4gIGlmIChkYXRhKSB0aGlzLndyaXRlKGRhdGEpXG4gIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcpIHRoaXMud3JpdGUoU0lHTkFMX0ZMVVNIKVxuICByZXR1cm4gc3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjYilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXhpZnlcbiIsInZhciBvbmNlID0gcmVxdWlyZSgnb25jZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuXHRyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzXG59O1xuXG52YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcblx0aWYgKCFvcHRzKSBvcHRzID0ge307XG5cblx0Y2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuXG5cdHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblx0dmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXHR2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IChvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGUpO1xuXHR2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpO1xuXHR2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG5cblx0dmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG5cdH07XG5cblx0dmFyIG9uZmluaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0d3JpdGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG5cdH07XG5cblx0dmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVhZGFibGUgPSBmYWxzZTtcblx0XHRpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG5cdH07XG5cblx0dmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7XG5cdFx0Y2FsbGJhY2suY2FsbChzdHJlYW0sIGV4aXRDb2RlID8gbmV3IEVycm9yKCdleGl0ZWQgd2l0aCBlcnJvciBjb2RlOiAnICsgZXhpdENvZGUpIDogbnVsbCk7XG5cdH07XG5cblx0dmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcblx0fTtcblxuXHR2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHByb2Nlc3MubmV4dFRpY2sob25jbG9zZW5leHR0aWNrKTtcblx0fTtcblxuXHR2YXIgb25jbG9zZW5leHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuXHRcdGlmIChyZWFkYWJsZSAmJiAhKHJzICYmIChycy5lbmRlZCAmJiAhcnMuZGVzdHJveWVkKSkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7XG5cdFx0aWYgKHdyaXRhYmxlICYmICEod3MgJiYgKHdzLmVuZGVkICYmICF3cy5kZXN0cm95ZWQpKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0fTtcblxuXHR2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHR9O1xuXG5cdGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuXHRcdHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtcblx0XHRlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zXG5cdFx0c3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0fVxuXG5cdGlmIChpc0NoaWxkUHJvY2VzcyhzdHJlYW0pKSBzdHJlYW0ub24oJ2V4aXQnLCBvbmV4aXQpO1xuXG5cdHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuXHRzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0aWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG5cdHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIvLyBJbnNwaXJlZCBieSBHb29nbGUgQ2xvc3VyZTpcbi8vIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vc3ZuL2RvY3MvXG4vLyBjbG9zdXJlX2dvb2dfYXJyYXlfYXJyYXkuanMuaHRtbCNnb29nLmFycmF5LmNsZWFyXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdmFsdWUgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFsdWUodGhpcykubGVuZ3RoID0gMDtcblx0cmV0dXJuIHRoaXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBudW1iZXJJc05hTiAgICAgICA9IHJlcXVpcmUoXCIuLi8uLi9udW1iZXIvaXMtbmFuXCIpXG4gICwgdG9Qb3NJbnQgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCIpXG4gICwgdmFsdWUgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgaW5kZXhPZiAgICAgICAgICAgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICAsIG9iakhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGFicyAgICAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBmbG9vciAgICAgICAgICAgICA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4Ki8pIHtcblx0dmFyIGksIGxlbmd0aCwgZnJvbUluZGV4LCB2YWw7XG5cdGlmICghbnVtYmVySXNOYU4oc2VhcmNoRWxlbWVudCkpIHJldHVybiBpbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0bGVuZ3RoID0gdG9Qb3NJbnQodmFsdWUodGhpcykubGVuZ3RoKTtcblx0ZnJvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuXHRpZiAoaXNOYU4oZnJvbUluZGV4KSkgZnJvbUluZGV4ID0gMDtcblx0ZWxzZSBpZiAoZnJvbUluZGV4ID49IDApIGZyb21JbmRleCA9IGZsb29yKGZyb21JbmRleCk7XG5cdGVsc2UgZnJvbUluZGV4ID0gdG9Qb3NJbnQodGhpcy5sZW5ndGgpIC0gZmxvb3IoYWJzKGZyb21JbmRleCkpO1xuXG5cdGZvciAoaSA9IGZyb21JbmRleDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKG9iakhhc093blByb3BlcnR5LmNhbGwodGhpcywgaSkpIHtcblx0XHRcdHZhbCA9IHRoaXNbaV07XG5cdFx0XHRpZiAobnVtYmVySXNOYU4odmFsKSkgcmV0dXJuIGk7IC8vIEpzbGludDogaWdub3JlXG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gQXJyYXkuZnJvbSA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBmcm9tID0gQXJyYXkuZnJvbSwgYXJyLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgZnJvbSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdGFyciA9IFtcInJhelwiLCBcImR3YVwiXTtcblx0cmVzdWx0ID0gZnJvbShhcnIpO1xuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHQgJiYgcmVzdWx0ICE9PSBhcnIgJiYgcmVzdWx0WzFdID09PSBcImR3YVwiKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIikuaXRlcmF0b3JcbiAgLCBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc0Z1bmN0aW9uICAgICA9IHJlcXVpcmUoXCIuLi8uLi9mdW5jdGlvbi9pcy1mdW5jdGlvblwiKVxuICAsIHRvUG9zSW50ICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGlzVmFsdWUgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC9pcy12YWx1ZVwiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBpc0FycmF5ICAgICAgICA9IEFycmF5LmlzQXJyYXlcbiAgLCBjYWxsICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVzYyAgICAgICAgICAgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH1cbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5TGlrZS8qLCBtYXBGbiwgdGhpc0FyZyovKSB7XG5cdHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXVxuXHQgICwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXVxuXHQgICwgQ29udGV4dFxuXHQgICwgaVxuXHQgICwgalxuXHQgICwgYXJyXG5cdCAgLCBsZW5ndGhcblx0ICAsIGNvZGVcblx0ICAsIGl0ZXJhdG9yXG5cdCAgLCByZXN1bHRcblx0ICAsIGdldEl0ZXJhdG9yXG5cdCAgLCB2YWx1ZTtcblxuXHRhcnJheUxpa2UgPSBPYmplY3QodmFsaWRWYWx1ZShhcnJheUxpa2UpKTtcblxuXHRpZiAoaXNWYWx1ZShtYXBGbikpIGNhbGxhYmxlKG1hcEZuKTtcblx0aWYgKCF0aGlzIHx8IHRoaXMgPT09IEFycmF5IHx8ICFpc0Z1bmN0aW9uKHRoaXMpKSB7XG5cdFx0Ly8gUmVzdWx0OiBQbGFpbiBhcnJheVxuXHRcdGlmICghbWFwRm4pIHtcblx0XHRcdGlmIChpc0FyZ3VtZW50cyhhcnJheUxpa2UpKSB7XG5cdFx0XHRcdC8vIFNvdXJjZTogQXJndW1lbnRzXG5cdFx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggIT09IDEpIHJldHVybiBBcnJheS5hcHBseShudWxsLCBhcnJheUxpa2UpO1xuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkoMSk7XG5cdFx0XHRcdGFyclswXSA9IGFycmF5TGlrZVswXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0FycmF5KGFycmF5TGlrZSkpIHtcblx0XHRcdFx0Ly8gU291cmNlOiBBcnJheVxuXHRcdFx0XHRhcnIgPSBuZXcgQXJyYXkoKGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGgpKTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSBhcnJbaV0gPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFyciA9IFtdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFJlc3VsdDogTm9uIHBsYWluIGFycmF5XG5cdFx0Q29udGV4dCA9IHRoaXM7XG5cdH1cblxuXHRpZiAoIWlzQXJyYXkoYXJyYXlMaWtlKSkge1xuXHRcdGlmICgoZ2V0SXRlcmF0b3IgPSBhcnJheUxpa2VbaXRlcmF0b3JTeW1ib2xdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyBTb3VyY2U6IEl0ZXJhdG9yXG5cdFx0XHRpdGVyYXRvciA9IGNhbGxhYmxlKGdldEl0ZXJhdG9yKS5jYWxsKGFycmF5TGlrZSk7XG5cdFx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQoKTtcblx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdGkgPSAwO1xuXHRcdFx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCByZXN1bHQudmFsdWUsIGkpIDogcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGksIGRlc2MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycltpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdFx0KytpO1xuXHRcdFx0fVxuXHRcdFx0bGVuZ3RoID0gaTtcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGFycmF5TGlrZSkpIHtcblx0XHRcdC8vIFNvdXJjZTogU3RyaW5nXG5cdFx0XHRsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdFx0aWYgKENvbnRleHQpIGFyciA9IG5ldyBDb250ZXh0KCk7XG5cdFx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhbHVlID0gYXJyYXlMaWtlW2ldO1xuXHRcdFx0XHRpZiAoaSArIDEgPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRjb2RlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG5cdFx0XHRcdFx0aWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSB2YWx1ZSArPSBhcnJheUxpa2VbKytpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IG1hcEZuID8gY2FsbC5jYWxsKG1hcEZuLCB0aGlzQXJnLCB2YWx1ZSwgaikgOiB2YWx1ZTtcblx0XHRcdFx0aWYgKENvbnRleHQpIHtcblx0XHRcdFx0XHRkZXNjLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBqLCBkZXNjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcnJbal0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQrK2o7XG5cdFx0XHR9XG5cdFx0XHRsZW5ndGggPSBqO1xuXHRcdH1cblx0fVxuXHRpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBTb3VyY2U6IGFycmF5IG9yIGFycmF5LWxpa2Vcblx0XHRsZW5ndGggPSB0b1Bvc0ludChhcnJheUxpa2UubGVuZ3RoKTtcblx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQobGVuZ3RoKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIGFycmF5TGlrZVtpXSwgaSkgOiBhcnJheUxpa2VbaV07XG5cdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRkZXNjLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcnJbaV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYgKENvbnRleHQpIHtcblx0XHRkZXNjLnZhbHVlID0gbnVsbDtcblx0XHRhcnIubGVuZ3RoID0gbGVuZ3RoO1xuXHR9XG5cdHJldHVybiBhcnI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgLCBpZCA9IG9ialRvU3RyaW5nLmNhbGwoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSkoKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gaWQ7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAsIGlzRnVuY3Rpb25TdHJpbmdUYWcgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXltvYmplY3QgW0EtWmEtejAtOV0qRnVuY3Rpb25dJC8pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jdGlvblN0cmluZ1RhZyhvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eS1mdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7fTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBNYXRoLnNpZ24gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2lnbiA9IE1hdGguc2lnbjtcblx0aWYgKHR5cGVvZiBzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHNpZ24oMTApID09PSAxICYmIHNpZ24oLTIwKSA9PT0gLTE7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblx0aWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gMCkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gdmFsdWUgPiAwID8gMSA6IC0xO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBOdW1iZXIuaXNOYU4gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU47XG5cdGlmICh0eXBlb2YgbnVtYmVySXNOYU4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gIW51bWJlcklzTmFOKHt9KSAmJiBudW1iZXJJc05hTihOYU4pICYmICFudW1iZXJJc05hTigzNCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHNpZ24gID0gcmVxdWlyZShcIi4uL21hdGgvc2lnblwiKVxuICAsIGFicyAgID0gTWF0aC5hYnNcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmIChpc05hTih2YWx1ZSkpIHJldHVybiAwO1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmICh2YWx1ZSA9PT0gMCB8fCAhaXNGaW5pdGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiBzaWduKHZhbHVlKSAqIGZsb29yKGFicyh2YWx1ZSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZShcIi4vdG8taW50ZWdlclwiKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbWF4KDAsIHRvSW50ZWdlcih2YWx1ZSkpOyB9O1xuIiwiLy8gSW50ZXJuYWwgbWV0aG9kLCB1c2VkIGJ5IGl0ZXJhdGlvbiBmdW5jdGlvbnMuXG4vLyBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyIGZvdW5kIGluIG9iamVjdFxuLy8gT3B0aW9uYWxseSB0YWtlcyBjb21wYXJlRm4gdG8gaXRlcmF0ZSBvYmplY3QgaW4gc3BlY2lmaWMgb3JkZXJcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYWxsYWJsZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgdmFsdWUgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC12YWx1ZVwiKVxuICAsIGJpbmQgICAgICAgICAgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgLCBjYWxsICAgICAgICAgICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwga2V5cyAgICAgICAgICAgICAgICAgICAgPSBPYmplY3Qua2V5c1xuICAsIG9ialByb3BlcnR5SXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kLCBkZWZWYWwpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChvYmosIGNiLyosIHRoaXNBcmcsIGNvbXBhcmVGbiovKSB7XG5cdFx0dmFyIGxpc3QsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIGNvbXBhcmVGbiA9IGFyZ3VtZW50c1szXTtcblx0XHRvYmogPSBPYmplY3QodmFsdWUob2JqKSk7XG5cdFx0Y2FsbGFibGUoY2IpO1xuXG5cdFx0bGlzdCA9IGtleXMob2JqKTtcblx0XHRpZiAoY29tcGFyZUZuKSB7XG5cdFx0XHRsaXN0LnNvcnQodHlwZW9mIGNvbXBhcmVGbiA9PT0gXCJmdW5jdGlvblwiID8gYmluZC5jYWxsKGNvbXBhcmVGbiwgb2JqKSA6IHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSBcImZ1bmN0aW9uXCIpIG1ldGhvZCA9IGxpc3RbbWV0aG9kXTtcblx0XHRyZXR1cm4gY2FsbC5jYWxsKG1ldGhvZCwgbGlzdCwgZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcblx0XHRcdGlmICghb2JqUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSkpIHJldHVybiBkZWZWYWw7XG5cdFx0XHRyZXR1cm4gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCBvYmpba2V5XSwga2V5LCBvYmosIGluZGV4KTtcblx0XHR9KTtcblx0fTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gT2JqZWN0LmFzc2lnbiA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduLCBvYmo7XG5cdGlmICh0eXBlb2YgYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0b2JqID0geyBmb286IFwicmF6XCIgfTtcblx0YXNzaWduKG9iaiwgeyBiYXI6IFwiZHdhXCIgfSwgeyB0cnp5OiBcInRyenlcIiB9KTtcblx0cmV0dXJuIG9iai5mb28gKyBvYmouYmFyICsgb2JqLnRyenkgPT09IFwicmF6ZHdhdHJ6eVwiO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5cyAgPSByZXF1aXJlKFwiLi4va2V5c1wiKVxuICAsIHZhbHVlID0gcmVxdWlyZShcIi4uL3ZhbGlkLXZhbHVlXCIpXG4gICwgbWF4ICAgPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVzdCwgc3JjLyosIOKApnNyY24qLykge1xuXHR2YXIgZXJyb3IsIGksIGxlbmd0aCA9IG1heChhcmd1bWVudHMubGVuZ3RoLCAyKSwgYXNzaWduO1xuXHRkZXN0ID0gT2JqZWN0KHZhbHVlKGRlc3QpKTtcblx0YXNzaWduID0gZnVuY3Rpb24gKGtleSkge1xuXHRcdHRyeSB7XG5cdFx0XHRkZXN0W2tleV0gPSBzcmNba2V5XTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGU7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0a2V5cyhzcmMpLmZvckVhY2goYXNzaWduKTtcblx0fVxuXHRpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgZXJyb3I7XG5cdHJldHVybiBkZXN0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYUZyb20gID0gcmVxdWlyZShcIi4uL2FycmF5L2Zyb21cIilcbiAgLCBhc3NpZ24gPSByZXF1aXJlKFwiLi9hc3NpZ25cIilcbiAgLCB2YWx1ZSAgPSByZXF1aXJlKFwiLi92YWxpZC12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLyosIHByb3BlcnR5TmFtZXMsIG9wdGlvbnMqLykge1xuXHR2YXIgY29weSA9IE9iamVjdCh2YWx1ZShvYmopKSwgcHJvcGVydHlOYW1lcyA9IGFyZ3VtZW50c1sxXSwgb3B0aW9ucyA9IE9iamVjdChhcmd1bWVudHNbMl0pO1xuXHRpZiAoY29weSAhPT0gb2JqICYmICFwcm9wZXJ0eU5hbWVzKSByZXR1cm4gY29weTtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRpZiAocHJvcGVydHlOYW1lcykge1xuXHRcdGFGcm9tKHByb3BlcnR5TmFtZXMsIGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcblx0XHRcdGlmIChvcHRpb25zLmVuc3VyZSB8fCBwcm9wZXJ0eU5hbWUgaW4gb2JqKSByZXN1bHRbcHJvcGVydHlOYW1lXSA9IG9ialtwcm9wZXJ0eU5hbWVdO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGFzc2lnbihyZXN1bHQsIG9iaik7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yODA0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgc2hpbTtcblxuaWYgKCFyZXF1aXJlKFwiLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkXCIpKCkpIHtcblx0c2hpbSA9IHJlcXVpcmUoXCIuL3NldC1wcm90b3R5cGUtb2Yvc2hpbVwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVsbE9iamVjdCwgcG9seVByb3BzLCBkZXNjO1xuXHRpZiAoIXNoaW0pIHJldHVybiBjcmVhdGU7XG5cdGlmIChzaGltLmxldmVsICE9PSAxKSByZXR1cm4gY3JlYXRlO1xuXG5cdG51bGxPYmplY3QgPSB7fTtcblx0cG9seVByb3BzID0ge307XG5cdGRlc2MgPSB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIpIHtcblx0XHRcdHBvbHlQcm9wc1tuYW1lXSA9IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWRcblx0XHRcdH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHBvbHlQcm9wc1tuYW1lXSA9IGRlc2M7XG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhudWxsT2JqZWN0LCBwb2x5UHJvcHMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaGltLCBcIm51bGxQb2x5ZmlsbFwiLCB7XG5cdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IG51bGxPYmplY3Rcblx0fSk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BzKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZShwcm90b3R5cGUgPT09IG51bGwgPyBudWxsT2JqZWN0IDogcHJvdG90eXBlLCBwcm9wcyk7XG5cdH07XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vX2l0ZXJhdGVcIikoXCJmb3JFYWNoXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbnZhciBtYXAgPSB7IGZ1bmN0aW9uOiB0cnVlLCBvYmplY3Q6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIChpc1ZhbHVlKHZhbHVlKSAmJiBtYXBbdHlwZW9mIHZhbHVlXSkgfHwgZmFsc2U7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91bmRlZmluZWQgPSByZXF1aXJlKFwiLi4vZnVuY3Rpb24vbm9vcFwiKSgpOyAvLyBTdXBwb3J0IEVTMyBlbmdpbmVzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsICE9PSBfdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbDsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3Qua2V5cyA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoXCJwcmltaXRpdmVcIik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi4vaXMtdmFsdWVcIik7XG5cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4ga2V5cyhpc1ZhbHVlKG9iamVjdCkgPyBPYmplY3Qob2JqZWN0KSA6IG9iamVjdCk7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNhbGxhYmxlID0gcmVxdWlyZShcIi4vdmFsaWQtY2FsbGFibGVcIilcbiAgLCBmb3JFYWNoICA9IHJlcXVpcmUoXCIuL2Zvci1lYWNoXCIpXG4gICwgY2FsbCAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIHJlc3VsdCA9IHt9LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuXHRjYWxsYWJsZShjYik7XG5cdGZvckVhY2gob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgdGFyZ2V0T2JqLCBpbmRleCkge1xuXHRcdHJlc3VsdFtrZXldID0gY2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB2YWx1ZSwga2V5LCB0YXJnZXRPYmosIGluZGV4KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlID0gcmVxdWlyZShcIi4vaXMtdmFsdWVcIik7XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24gKHNyYywgb2JqKSB7XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIHNyYykgb2JqW2tleV0gPSBzcmNba2V5XTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0czEvKiwg4oCmb3B0aW9ucyovKSB7XG5cdHZhciByZXN1bHQgPSBjcmVhdGUobnVsbCk7XG5cdGZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKCFpc1ZhbHVlKG9wdGlvbnMpKSByZXR1cm47XG5cdFx0cHJvY2VzcyhPYmplY3Qob3B0aW9ucyksIHJlc3VsdCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZy8qLCDigKZhcmdzKi8pIHtcblx0dmFyIHNldCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG5hbWUpIHsgc2V0W25hbWVdID0gdHJ1ZTsgfSk7XG5cdHJldHVybiBzZXQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE9iamVjdC5zZXRQcm90b3R5cGVPZiA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBwbGFpbk9iamVjdCA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgvKiBDdXN0b21DcmVhdGUqLykge1xuXHR2YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsIGN1c3RvbUNyZWF0ZSA9IGFyZ3VtZW50c1swXSB8fCBjcmVhdGU7XG5cdGlmICh0eXBlb2Ygc2V0UHJvdG90eXBlT2YgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc2V0UHJvdG90eXBlT2YoY3VzdG9tQ3JlYXRlKG51bGwpLCBwbGFpbk9iamVjdCkpID09PSBwbGFpbk9iamVjdDtcbn07XG4iLCIvKiBlc2xpbnQgbm8tcHJvdG86IFwib2ZmXCIgKi9cblxuLy8gQmlnIHRoYW5rcyB0byBAV2ViUmVmbGVjdGlvbiBmb3Igc29ydGluZyB0aGlzIG91dFxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi81NTkzNTU0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPYmplY3QgICAgICAgICA9IHJlcXVpcmUoXCIuLi9pcy1vYmplY3RcIilcbiAgLCB2YWx1ZSAgICAgICAgICAgID0gcmVxdWlyZShcIi4uL3ZhbGlkLXZhbHVlXCIpXG4gICwgb2JqSXNQcm90b3R5cGVPZiA9IE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZlxuICAsIGRlZmluZVByb3BlcnR5ICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgLCBudWxsRGVzYyAgICAgICAgID0geyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9XG4gICwgdmFsaWRhdGU7XG5cbnZhbGlkYXRlID0gZnVuY3Rpb24gKG9iaiwgcHJvdG90eXBlKSB7XG5cdHZhbHVlKG9iaik7XG5cdGlmIChwcm90b3R5cGUgPT09IG51bGwgfHwgaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIG9iajtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3RvdHlwZSBtdXN0IGJlIG51bGwgb3IgYW4gb2JqZWN0XCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKHN0YXR1cykge1xuXHR2YXIgZm4sIHNldDtcblx0aWYgKCFzdGF0dXMpIHJldHVybiBudWxsO1xuXHRpZiAoc3RhdHVzLmxldmVsID09PSAyKSB7XG5cdFx0aWYgKHN0YXR1cy5zZXQpIHtcblx0XHRcdHNldCA9IHN0YXR1cy5zZXQ7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHRzZXQuY2FsbCh2YWxpZGF0ZShvYmosIHByb3RvdHlwZSksIHByb3RvdHlwZSk7XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmbiA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSkuX19wcm90b19fID0gcHJvdG90eXBlO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4gPSBmdW5jdGlvbiBzZWxmKG9iaiwgcHJvdG90eXBlKSB7XG5cdFx0XHR2YXIgaXNOdWxsQmFzZTtcblx0XHRcdHZhbGlkYXRlKG9iaiwgcHJvdG90eXBlKTtcblx0XHRcdGlzTnVsbEJhc2UgPSBvYmpJc1Byb3RvdHlwZU9mLmNhbGwoc2VsZi5udWxsUG9seWZpbGwsIG9iaik7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVsZXRlIHNlbGYubnVsbFBvbHlmaWxsLl9fcHJvdG9fXztcblx0XHRcdGlmIChwcm90b3R5cGUgPT09IG51bGwpIHByb3RvdHlwZSA9IHNlbGYubnVsbFBvbHlmaWxsO1xuXHRcdFx0b2JqLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdGlmIChpc051bGxCYXNlKSBkZWZpbmVQcm9wZXJ0eShzZWxmLm51bGxQb2x5ZmlsbCwgXCJfX3Byb3RvX19cIiwgbnVsbERlc2MpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIFwibGV2ZWxcIiwge1xuXHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0d3JpdGFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiBzdGF0dXMubGV2ZWxcblx0fSk7XG59KShcblx0KGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdG1wT2JqMSA9IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHQgICwgdG1wT2JqMiA9IHt9XG5cdFx0ICAsIHNldFxuXHRcdCAgLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCBcIl9fcHJvdG9fX1wiKTtcblxuXHRcdGlmIChkZXNjKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzZXQgPSBkZXNjLnNldDsgLy8gT3BlcmEgY3Jhc2hlcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdHNldC5jYWxsKHRtcE9iajEsIHRtcE9iajIpO1xuXHRcdFx0fSBjYXRjaCAoaWdub3JlKSB7fVxuXHRcdFx0aWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0bXBPYmoxKSA9PT0gdG1wT2JqMikgcmV0dXJuIHsgc2V0OiBzZXQsIGxldmVsOiAyIH07XG5cdFx0fVxuXG5cdFx0dG1wT2JqMS5fX3Byb3RvX18gPSB0bXBPYmoyO1xuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IGxldmVsOiAyIH07XG5cblx0XHR0bXBPYmoxID0ge307XG5cdFx0dG1wT2JqMS5fX3Byb3RvX18gPSB0bXBPYmoyO1xuXHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IGxldmVsOiAxIH07XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKClcbik7XG5cbnJlcXVpcmUoXCIuLi9jcmVhdGVcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XG5cdHJldHVybiBmbjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgbnVsbCBvciB1bmRlZmluZWRcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gU3RyaW5nLnByb3RvdHlwZS5jb250YWlucyA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0ciA9IFwicmF6ZHdhdHJ6eVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzdHIuY29udGFpbnMgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gc3RyLmNvbnRhaW5zKFwiZHdhXCIpID09PSB0cnVlICYmIHN0ci5jb250YWlucyhcImZvb1wiKSA9PT0gZmFsc2U7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBpZCA9IG9ialRvU3RyaW5nLmNhbGwoXCJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG5cdFx0KHZhbHVlICYmXG5cdFx0XHR0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcblx0XHRcdCh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gaWQpKSB8fFxuXHRcdGZhbHNlXG5cdCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpXG4gICwgY29udGFpbnMgICAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9zdHJpbmcvIy9jb250YWluc1wiKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpXG4gICwgSXRlcmF0b3IgICAgICAgPSByZXF1aXJlKFwiLi9cIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgQXJyYXlJdGVyYXRvcjtcblxuQXJyYXlJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyciwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQXJyYXlJdGVyYXRvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmV3J1wiKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBhcnIpO1xuXHRpZiAoIWtpbmQpIGtpbmQgPSBcInZhbHVlXCI7XG5cdGVsc2UgaWYgKGNvbnRhaW5zLmNhbGwoa2luZCwgXCJrZXkrdmFsdWVcIikpIGtpbmQgPSBcImtleSt2YWx1ZVwiO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsIFwia2V5XCIpKSBraW5kID0gXCJrZXlcIjtcblx0ZWxzZSBraW5kID0gXCJ2YWx1ZVwiO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fa2luZF9fXCIsIGQoXCJcIiwga2luZCkpO1xufTtcbmlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoQXJyYXlJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4vLyBJbnRlcm5hbCAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5cbkFycmF5SXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvci5wcm90b3R5cGUsIHtcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gXCJ2YWx1ZVwiKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRpZiAodGhpcy5fX2tpbmRfXyA9PT0gXCJrZXkrdmFsdWVcIikgcmV0dXJuIFtpLCB0aGlzLl9fbGlzdF9fW2ldXTtcblx0XHRyZXR1cm4gaTtcblx0fSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoQXJyYXlJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZChcImNcIiwgXCJBcnJheSBJdGVyYXRvclwiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgY2FsbGFibGUgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBnZXQgICAgICAgICA9IHJlcXVpcmUoXCIuL2dldFwiKTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNiIC8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1vZGUsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIHJlc3VsdCwgZG9CcmVhaywgYnJva2VuLCBpLCBsZW5ndGgsIGNoYXIsIGNvZGU7XG5cdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIG1vZGUgPSBcImFycmF5XCI7XG5cdGVsc2UgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkgbW9kZSA9IFwic3RyaW5nXCI7XG5cdGVsc2UgaXRlcmFibGUgPSBnZXQoaXRlcmFibGUpO1xuXG5cdGNhbGxhYmxlKGNiKTtcblx0ZG9CcmVhayA9IGZ1bmN0aW9uICgpIHtcblx0XHRicm9rZW4gPSB0cnVlO1xuXHR9O1xuXHRpZiAobW9kZSA9PT0gXCJhcnJheVwiKSB7XG5cdFx0c29tZS5jYWxsKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGRvQnJlYWspO1xuXHRcdFx0cmV0dXJuIGJyb2tlbjtcblx0XHR9KTtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1vZGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoaSArIDEgPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSBjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHR9XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIGNoYXIsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cblx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBkb0JyZWFrKTtcblx0XHRpZiAoYnJva2VuKSByZXR1cm47XG5cdFx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIEFycmF5SXRlcmF0b3IgID0gcmVxdWlyZShcIi4vYXJyYXlcIilcbiAgLCBTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKVxuICAsIGl0ZXJhYmxlICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtaXRlcmFibGVcIilcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKHR5cGVvZiBpdGVyYWJsZShvYmopW2l0ZXJhdG9yU3ltYm9sXSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gb2JqW2l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRpZiAoaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG5cdGlmIChpc1N0cmluZyhvYmopKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG5cdHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xlYXIgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9hcnJheS8jL2NsZWFyXCIpXG4gICwgYXNzaWduICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvYXNzaWduXCIpXG4gICwgY2FsbGFibGUgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCB2YWx1ZSAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGQgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCBhdXRvQmluZCA9IHJlcXVpcmUoXCJkL2F1dG8tYmluZFwiKVxuICAsIFN5bWJvbCAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBJdGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVyYXRvciA9IGZ1bmN0aW9uIChsaXN0LCBjb250ZXh0KSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBJdGVyYXRvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciByZXF1aXJlcyAnbmV3J1wiKTtcblx0ZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0X19saXN0X186IGQoXCJ3XCIsIHZhbHVlKGxpc3QpKSxcblx0XHRfX2NvbnRleHRfXzogZChcIndcIiwgY29udGV4dCksXG5cdFx0X19uZXh0SW5kZXhfXzogZChcIndcIiwgMClcblx0fSk7XG5cdGlmICghY29udGV4dCkgcmV0dXJuO1xuXHRjYWxsYWJsZShjb250ZXh0Lm9uKTtcblx0Y29udGV4dC5vbihcIl9hZGRcIiwgdGhpcy5fb25BZGQpO1xuXHRjb250ZXh0Lm9uKFwiX2RlbGV0ZVwiLCB0aGlzLl9vbkRlbGV0ZSk7XG5cdGNvbnRleHQub24oXCJfY2xlYXJcIiwgdGhpcy5fb25DbGVhcik7XG59O1xuXG4vLyBJbnRlcm5hbCAlSXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIEl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZGVmaW5lUHJvcGVydGllcyhcblx0SXRlcmF0b3IucHJvdG90eXBlLFxuXHRhc3NpZ24oXG5cdFx0e1xuXHRcdFx0X25leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlZG9fXykge1xuXHRcdFx0XHRcdGkgPSB0aGlzLl9fcmVkb19fLnNoaWZ0KCk7XG5cdFx0XHRcdFx0aWYgKGkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA8IHRoaXMuX19saXN0X18ubGVuZ3RoKSByZXR1cm4gdGhpcy5fX25leHRJbmRleF9fKys7XG5cdFx0XHRcdHRoaXMuX3VuQmluZCgpO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSksXG5cdFx0XHRuZXh0OiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZVJlc3VsdCh0aGlzLl9uZXh0KCkpO1xuXHRcdFx0fSksXG5cdFx0XHRfY3JlYXRlUmVzdWx0OiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdGlmIChpID09PSB1bmRlZmluZWQpIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcblx0XHRcdFx0cmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLl9yZXNvbHZlKGkpIH07XG5cdFx0XHR9KSxcblx0XHRcdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9fbGlzdF9fW2ldO1xuXHRcdFx0fSksXG5cdFx0XHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fX2xpc3RfXyA9IG51bGw7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9fcmVkb19fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19jb250ZXh0X18pIHJldHVybjtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfYWRkXCIsIHRoaXMuX29uQWRkKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfZGVsZXRlXCIsIHRoaXMuX29uRGVsZXRlKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXy5vZmYoXCJfY2xlYXJcIiwgdGhpcy5fb25DbGVhcik7XG5cdFx0XHRcdHRoaXMuX19jb250ZXh0X18gPSBudWxsO1xuXHRcdFx0fSksXG5cdFx0XHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBcIltvYmplY3QgXCIgKyAodGhpc1tTeW1ib2wudG9TdHJpbmdUYWddIHx8IFwiT2JqZWN0XCIpICsgXCJdXCI7XG5cdFx0XHR9KVxuXHRcdH0sXG5cdFx0YXV0b0JpbmQoe1xuXHRcdFx0X29uQWRkOiBkKGZ1bmN0aW9uIChpbmRleCkge1xuXHRcdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0XHRcdCsrdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fcmVkb19fXCIsIGQoXCJjXCIsIFtpbmRleF0pKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBpKSB7XG5cdFx0XHRcdFx0aWYgKHJlZG8gPj0gaW5kZXgpIHRoaXMuX19yZWRvX19baV0gPSArK3JlZG87XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9fcmVkb19fLnB1c2goaW5kZXgpO1xuXHRcdFx0fSksXG5cdFx0XHRfb25EZWxldGU6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpZiAoaW5kZXggPj0gdGhpcy5fX25leHRJbmRleF9fKSByZXR1cm47XG5cdFx0XHRcdC0tdGhpcy5fX25leHRJbmRleF9fO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19yZWRvX18pIHJldHVybjtcblx0XHRcdFx0aSA9IHRoaXMuX19yZWRvX18uaW5kZXhPZihpbmRleCk7XG5cdFx0XHRcdGlmIChpICE9PSAtMSkgdGhpcy5fX3JlZG9fXy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdHRoaXMuX19yZWRvX18uZm9yRWFjaChmdW5jdGlvbiAocmVkbywgaikge1xuXHRcdFx0XHRcdGlmIChyZWRvID4gaW5kZXgpIHRoaXMuX19yZWRvX19bal0gPSAtLXJlZG87XG5cdFx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0fSksXG5cdFx0XHRfb25DbGVhcjogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVkb19fKSBjbGVhci5jYWxsKHRoaXMuX19yZWRvX18pO1xuXHRcdFx0XHR0aGlzLl9fbmV4dEluZGV4X18gPSAwO1xuXHRcdFx0fSlcblx0XHR9KVxuXHQpXG4pO1xuXG5kZWZpbmVQcm9wZXJ0eShcblx0SXRlcmF0b3IucHJvdG90eXBlLFxuXHRTeW1ib2wuaXRlcmF0b3IsXG5cdGQoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9KVxuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIilcbiAgLCBpc1ZhbHVlICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9pcy12YWx1ZVwiKVxuICAsIGlzU3RyaW5nICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiKTtcblxudmFyIGl0ZXJhdG9yU3ltYm9sID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIikuaXRlcmF0b3JcbiAgLCBpc0FycmF5ICAgICAgICA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHJldHVybiBmYWxzZTtcblx0aWYgKGlzQXJyYXkodmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc0FyZ3VtZW50cyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlW2l0ZXJhdG9yU3ltYm9sXSA9PT0gXCJmdW5jdGlvblwiO1xufTtcbiIsIi8vIFRoYW5rcyBAbWF0aGlhc2J5bmVuc1xuLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlI2l0ZXJhdGluZy1vdmVyLXN5bWJvbHNcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIilcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoXCIuL1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBTdHJpbmdJdGVyYXRvcjtcblxuU3RyaW5nSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ0l0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRzdHIgPSBTdHJpbmcoc3RyKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBzdHIpO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fbGVuZ3RoX19cIiwgZChcIlwiLCBzdHIubGVuZ3RoKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihTdHJpbmdJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4vLyBJbnRlcm5hbCAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5TdHJpbmdJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHR2YXIgY2hhciA9IHRoaXMuX19saXN0X19baV0sIGNvZGU7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA9PT0gdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gY2hhcjtcblx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgcmV0dXJuIGNoYXIgKyB0aGlzLl9fbGlzdF9fW3RoaXMuX19uZXh0SW5kZXhfXysrXTtcblx0XHRyZXR1cm4gY2hhcjtcblx0fSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiU3RyaW5nIEl0ZXJhdG9yXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNJdGVyYWJsZSA9IHJlcXVpcmUoXCIuL2lzLWl0ZXJhYmxlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gTWFwIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIG1hcCwgaXRlcmF0b3IsIHJlc3VsdDtcblx0aWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0dHJ5IHtcblx0XHQvLyBXZWJLaXQgZG9lc24ndCBzdXBwb3J0IGFyZ3VtZW50cyBhbmQgY3Jhc2hlc1xuXHRcdG1hcCA9IG5ldyBNYXAoW1sncmF6JywgJ29uZSddLCBbJ2R3YScsICd0d28nXSwgWyd0cnp5JywgJ3RocmVlJ11dKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoU3RyaW5nKG1hcCkgIT09ICdbb2JqZWN0IE1hcF0nKSByZXR1cm4gZmFsc2U7XG5cdGlmIChtYXAuc2l6ZSAhPT0gMykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5jbGVhciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5kZWxldGUgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZW50cmllcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmdldCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5oYXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAua2V5cyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5zZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAudmFsdWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cblx0aXRlcmF0b3IgPSBtYXAuZW50cmllcygpO1xuXHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cdGlmIChyZXN1bHQuZG9uZSAhPT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0aWYgKCFyZXN1bHQudmFsdWUpIHJldHVybiBmYWxzZTtcblx0aWYgKHJlc3VsdC52YWx1ZVswXSAhPT0gJ3JheicpIHJldHVybiBmYWxzZTtcblx0aWYgKHJlc3VsdC52YWx1ZVsxXSAhPT0gJ29uZScpIHJldHVybiBmYWxzZTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBFeHBvcnRzIHRydWUgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgbmF0aXZlIGBNYXBgIGltcGxlbWVudGF0aW9uLFxuLy8gd2hhdGV2ZXIgdGhhdCBpcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkpID09PSAnW29iamVjdCBNYXBdJyk7XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ByaW1pdGl2ZS1zZXQnKSgna2V5Jyxcblx0J3ZhbHVlJywgJ2tleSt2YWx1ZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yJylcbiAgLCB0b1N0cmluZ1RhZ1N5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS50b1N0cmluZ1RhZ1xuICAsIGtpbmRzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9pdGVyYXRvci1raW5kcycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCB1bkJpbmQgPSBJdGVyYXRvci5wcm90b3R5cGUuX3VuQmluZFxuICAsIE1hcEl0ZXJhdG9yO1xuXG5NYXBJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hcCwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwSXRlcmF0b3IpKSByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKG1hcCwga2luZCk7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgbWFwLl9fbWFwS2V5c0RhdGFfXywgbWFwKTtcblx0aWYgKCFraW5kIHx8ICFraW5kc1traW5kXSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2tpbmRfXzogZCgnJywga2luZCksXG5cdFx0X192YWx1ZXNfXzogZCgndycsIG1hcC5fX21hcFZhbHVlc0RhdGFfXylcblx0fSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChNYXBJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fdmFsdWVzX19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICdrZXknKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRyZXR1cm4gW3RoaXMuX19saXN0X19baV0sIHRoaXMuX192YWx1ZXNfX1tpXV07XG5cdH0pLFxuXHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9fdmFsdWVzX18gPSBudWxsO1xuXHRcdHVuQmluZC5jYWxsKHRoaXMpO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7IH0pXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBJdGVyYXRvci5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLFxuXHRkKCdjJywgJ01hcCBJdGVyYXRvcicpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBlSW5kZXhPZiAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mJylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgZWUgICAgICAgICAgICAgPSByZXF1aXJlKCdldmVudC1lbWl0dGVyJylcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuICAsIGl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9mb3Itb2YnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0b3InKVxuICAsIGlzTmF0aXZlICAgICAgID0gcmVxdWlyZSgnLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWQnKVxuXG4gICwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIE1hcFBvbHk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwUG9seSA9IGZ1bmN0aW9uICgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBrZXlzLCB2YWx1ZXMsIHNlbGY7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBQb2x5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG5cdGlmIChpc05hdGl2ZSAmJiBzZXRQcm90b3R5cGVPZiAmJiAoTWFwICE9PSBNYXBQb2x5KSkge1xuXHRcdHNlbGYgPSBzZXRQcm90b3R5cGVPZihuZXcgTWFwKCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHRzZWxmID0gdGhpcztcblx0fVxuXHRpZiAoaXRlcmFibGUgIT0gbnVsbCkgaXRlcmF0b3IoaXRlcmFibGUpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHtcblx0XHRfX21hcEtleXNEYXRhX186IGQoJ2MnLCBrZXlzID0gW10pLFxuXHRcdF9fbWFwVmFsdWVzRGF0YV9fOiBkKCdjJywgdmFsdWVzID0gW10pXG5cdH0pO1xuXHRpZiAoIWl0ZXJhYmxlKSByZXR1cm4gc2VsZjtcblx0Zm9yT2YoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBrZXkgPSB2YWxpZFZhbHVlKHZhbHVlKVswXTtcblx0XHR2YWx1ZSA9IHZhbHVlWzFdO1xuXHRcdGlmIChlSW5kZXhPZi5jYWxsKGtleXMsIGtleSkgIT09IC0xKSByZXR1cm47XG5cdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0dmFsdWVzLnB1c2godmFsdWUpO1xuXHR9LCBzZWxmKTtcblx0cmV0dXJuIHNlbGY7XG59O1xuXG5pZiAoaXNOYXRpdmUpIHtcblx0aWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBQb2x5LCBNYXApO1xuXHRNYXBQb2x5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWFwLnByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBkKE1hcFBvbHkpXG5cdH0pO1xufVxuXG5lZShkZWZpbmVQcm9wZXJ0aWVzKE1hcFBvbHkucHJvdG90eXBlLCB7XG5cdGNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aCkgcmV0dXJuO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18pO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcFZhbHVlc0RhdGFfXyk7XG5cdFx0dGhpcy5lbWl0KCdfY2xlYXInKTtcblx0fSksXG5cdGRlbGV0ZTogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0dGhpcy5fX21hcEtleXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5lbWl0KCdfZGVsZXRlJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pLFxuXHRlbnRyaWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7IH0pLFxuXHRmb3JFYWNoOiBkKGZ1bmN0aW9uIChjYi8qLCB0aGlzQXJnKi8pIHtcblx0XHR2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXSwgaXRlcmF0b3IsIHJlc3VsdDtcblx0XHRjYWxsYWJsZShjYik7XG5cdFx0aXRlcmF0b3IgPSB0aGlzLmVudHJpZXMoKTtcblx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdHdoaWxlIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW3Jlc3VsdF0sXG5cdFx0XHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fW3Jlc3VsdF0sIHRoaXMpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR9XG5cdH0pLFxuXHRnZXQ6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXHRcdHJldHVybiB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XTtcblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpICE9PSAtMSk7XG5cdH0pLFxuXHRrZXlzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5Jyk7IH0pLFxuXHRzZXQ6IGQoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpLCBlbWl0O1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fX21hcEtleXNEYXRhX18ucHVzaChrZXkpIC0gMTtcblx0XHRcdGVtaXQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XSA9IHZhbHVlO1xuXHRcdGlmIChlbWl0KSB0aGlzLmVtaXQoJ19hZGQnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSksXG5cdHNpemU6IGQuZ3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoOyB9KSxcblx0dmFsdWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAndmFsdWUnKTsgfSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcF0nOyB9KVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIGQoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZCgnYycsICdNYXAnKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpXG5cdD8gcmVxdWlyZShcImV4dC9nbG9iYWwtdGhpc1wiKS5TeW1ib2xcblx0OiByZXF1aXJlKFwiLi9wb2x5ZmlsbFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFsICAgICA9IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIilcbiAgLCB2YWxpZFR5cGVzID0geyBvYmplY3Q6IHRydWUsIHN5bWJvbDogdHJ1ZSB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0c3ltYm9sID0gU3ltYm9sKFwidGVzdCBzeW1ib2xcIik7XG5cdHRyeSB7IFN0cmluZyhzeW1ib2wpOyB9XG5cdGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIFJldHVybiAndHJ1ZScgYWxzbyBmb3IgcG9seWZpbGxzXG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLml0ZXJhdG9yXSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZV0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWddKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzeW1ib2xcIikgcmV0dXJuIHRydWU7XG5cdGlmICghdmFsdWUuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0aWYgKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09IFwiU3ltYm9sXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHZhbHVlW3ZhbHVlLmNvbnN0cnVjdG9yLnRvU3RyaW5nVGFnXSA9PT0gXCJTeW1ib2xcIjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGQgPSByZXF1aXJlKFwiZFwiKTtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYmpQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG52YXIgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc2MpIHtcblx0dmFyIHBvc3RmaXggPSAwLCBuYW1lLCBpZTExQnVnV29ya2Fyb3VuZDtcblx0d2hpbGUgKGNyZWF0ZWRbZGVzYyArIChwb3N0Zml4IHx8IFwiXCIpXSkgKytwb3N0Zml4O1xuXHRkZXNjICs9IHBvc3RmaXggfHwgXCJcIjtcblx0Y3JlYXRlZFtkZXNjXSA9IHRydWU7XG5cdG5hbWUgPSBcIkBAXCIgKyBkZXNjO1xuXHRkZWZpbmVQcm9wZXJ0eShcblx0XHRvYmpQcm90b3R5cGUsXG5cdFx0bmFtZSxcblx0XHRkLmdzKG51bGwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gRm9yIElFMTEgaXNzdWUgc2VlOlxuXHRcdFx0Ly8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2tkZXRhaWwvdmlldy8xOTI4NTA4L1xuXHRcdFx0Ly8gICAgaWUxMS1icm9rZW4tZ2V0dGVycy1vbi1kb20tb2JqZWN0c1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTJcblx0XHRcdGlmIChpZTExQnVnV29ya2Fyb3VuZCkgcmV0dXJuO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSB0cnVlO1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZCh2YWx1ZSkpO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSBmYWxzZTtcblx0XHR9KVxuXHQpO1xuXHRyZXR1cm4gbmFtZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGQgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgTmF0aXZlU3ltYm9sID0gcmVxdWlyZShcImV4dC9nbG9iYWwtdGhpc1wiKS5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFN5bWJvbFBvbHlmaWxsKSB7XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbCwge1xuXHRcdC8vIFRvIGVuc3VyZSBwcm9wZXIgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIG90aGVyIG5hdGl2ZSBmdW5jdGlvbnMgKGUuZy4gQXJyYXkuZnJvbSlcblx0XHQvLyBmYWxsYmFjayB0byBldmVudHVhbCBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgZ2l2ZW4gc3ltYm9sXG5cdFx0aGFzSW5zdGFuY2U6IGQoXG5cdFx0XHRcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5oYXNJbnN0YW5jZSkgfHwgU3ltYm9sUG9seWZpbGwoXCJoYXNJbnN0YW5jZVwiKVxuXHRcdCksXG5cdFx0aXNDb25jYXRTcHJlYWRhYmxlOiBkKFxuXHRcdFx0XCJcIixcblx0XHRcdChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSkgfHxcblx0XHRcdFx0U3ltYm9sUG9seWZpbGwoXCJpc0NvbmNhdFNwcmVhZGFibGVcIilcblx0XHQpLFxuXHRcdGl0ZXJhdG9yOiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLml0ZXJhdG9yKSB8fCBTeW1ib2xQb2x5ZmlsbChcIml0ZXJhdG9yXCIpKSxcblx0XHRtYXRjaDogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5tYXRjaCkgfHwgU3ltYm9sUG9seWZpbGwoXCJtYXRjaFwiKSksXG5cdFx0cmVwbGFjZTogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5yZXBsYWNlKSB8fCBTeW1ib2xQb2x5ZmlsbChcInJlcGxhY2VcIikpLFxuXHRcdHNlYXJjaDogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zZWFyY2gpIHx8IFN5bWJvbFBvbHlmaWxsKFwic2VhcmNoXCIpKSxcblx0XHRzcGVjaWVzOiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwZWNpZXMpIHx8IFN5bWJvbFBvbHlmaWxsKFwic3BlY2llc1wiKSksXG5cdFx0c3BsaXQ6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc3BsaXQpIHx8IFN5bWJvbFBvbHlmaWxsKFwic3BsaXRcIikpLFxuXHRcdHRvUHJpbWl0aXZlOiBkKFxuXHRcdFx0XCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9QcmltaXRpdmUpIHx8IFN5bWJvbFBvbHlmaWxsKFwidG9QcmltaXRpdmVcIilcblx0XHQpLFxuXHRcdHRvU3RyaW5nVGFnOiBkKFxuXHRcdFx0XCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudG9TdHJpbmdUYWcpIHx8IFN5bWJvbFBvbHlmaWxsKFwidG9TdHJpbmdUYWdcIilcblx0XHQpLFxuXHRcdHVuc2NvcGFibGVzOiBkKFxuXHRcdFx0XCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wudW5zY29wYWJsZXMpIHx8IFN5bWJvbFBvbHlmaWxsKFwidW5zY29wYWJsZXNcIilcblx0XHQpXG5cdH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIHZhbGlkYXRlU3ltYm9sID0gcmVxdWlyZShcIi4uLy4uLy4uL3ZhbGlkYXRlLXN5bWJvbFwiKTtcblxudmFyIHJlZ2lzdHJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU3ltYm9sUG9seWZpbGwpIHtcblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLCB7XG5cdFx0Zm9yOiBkKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmIChyZWdpc3RyeVtrZXldKSByZXR1cm4gcmVnaXN0cnlba2V5XTtcblx0XHRcdHJldHVybiAocmVnaXN0cnlba2V5XSA9IFN5bWJvbFBvbHlmaWxsKFN0cmluZyhrZXkpKSk7XG5cdFx0fSksXG5cdFx0a2V5Rm9yOiBkKGZ1bmN0aW9uIChzeW1ib2wpIHtcblx0XHRcdHZhciBrZXk7XG5cdFx0XHR2YWxpZGF0ZVN5bWJvbChzeW1ib2wpO1xuXHRcdFx0Zm9yIChrZXkgaW4gcmVnaXN0cnkpIHtcblx0XHRcdFx0aWYgKHJlZ2lzdHJ5W2tleV0gPT09IHN5bWJvbCkgcmV0dXJuIGtleTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSlcblx0fSk7XG59O1xuIiwiLy8gRVMyMDE1IFN5bWJvbCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IChvciBwYXJ0aWFsbHkpIHN1cHBvcnQgaXRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgdmFsaWRhdGVTeW1ib2wgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZGF0ZS1zeW1ib2xcIilcbiAgLCBOYXRpdmVTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIikuU3ltYm9sXG4gICwgZ2VuZXJhdGVOYW1lICAgICAgICAgPSByZXF1aXJlKFwiLi9saWIvcHJpdmF0ZS9nZW5lcmF0ZS1uYW1lXCIpXG4gICwgc2V0dXBTdGFuZGFyZFN5bWJvbHMgPSByZXF1aXJlKFwiLi9saWIvcHJpdmF0ZS9zZXR1cC9zdGFuZGFyZC1zeW1ib2xzXCIpXG4gICwgc2V0dXBTeW1ib2xSZWdpc3RyeSAgPSByZXF1aXJlKFwiLi9saWIvcHJpdmF0ZS9zZXR1cC9zeW1ib2wtcmVnaXN0cnlcIik7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzXG4gICwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBTeW1ib2xQb2x5ZmlsbCwgSGlkZGVuU3ltYm9sLCBpc05hdGl2ZVNhZmU7XG5cbmlmICh0eXBlb2YgTmF0aXZlU3ltYm9sID09PSBcImZ1bmN0aW9uXCIpIHtcblx0dHJ5IHtcblx0XHRTdHJpbmcoTmF0aXZlU3ltYm9sKCkpO1xuXHRcdGlzTmF0aXZlU2FmZSA9IHRydWU7XG5cdH0gY2F0Y2ggKGlnbm9yZSkge31cbn0gZWxzZSB7XG5cdE5hdGl2ZVN5bWJvbCA9IG51bGw7XG59XG5cbi8vIEludGVybmFsIGNvbnN0cnVjdG9yIChub3Qgb25lIGV4cG9zZWQpIGZvciBjcmVhdGluZyBTeW1ib2wgaW5zdGFuY2VzLlxuLy8gVGhpcyBvbmUgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBgc29tZVN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbGAgYWx3YXlzIHJldHVybiBmYWxzZVxuSGlkZGVuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgSGlkZGVuU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpO1xuXHRyZXR1cm4gU3ltYm9sUG9seWZpbGwoZGVzY3JpcHRpb24pO1xufTtcblxuLy8gRXhwb3NlZCBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gKHJldHVybnMgaW5zdGFuY2VzIG9mIEhpZGRlblN5bWJvbClcbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sUG9seWZpbGwgPSBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcblx0dmFyIHN5bWJvbDtcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3JcIik7XG5cdGlmIChpc05hdGl2ZVNhZmUpIHJldHVybiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuXHRzeW1ib2wgPSBjcmVhdGUoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSk7XG5cdGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBTdHJpbmcoZGVzY3JpcHRpb24pO1xuXHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcyhzeW1ib2wsIHtcblx0XHRfX2Rlc2NyaXB0aW9uX186IGQoXCJcIiwgZGVzY3JpcHRpb24pLFxuXHRcdF9fbmFtZV9fOiBkKFwiXCIsIGdlbmVyYXRlTmFtZShkZXNjcmlwdGlvbikpXG5cdH0pO1xufTtcblxuc2V0dXBTdGFuZGFyZFN5bWJvbHMoU3ltYm9sUG9seWZpbGwpO1xuc2V0dXBTeW1ib2xSZWdpc3RyeShTeW1ib2xQb2x5ZmlsbCk7XG5cbi8vIEludGVybmFsIHR3ZWFrcyBmb3IgcmVhbCBzeW1ib2wgcHJvZHVjZXJcbmRlZmluZVByb3BlcnRpZXMoSGlkZGVuU3ltYm9sLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChTeW1ib2xQb2x5ZmlsbCksXG5cdHRvU3RyaW5nOiBkKFwiXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX19uYW1lX187IH0pXG59KTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgZXhwb3NlZCBvbiBTeW1ib2wucHJvdG90eXBlXG4vLyBUaGV5IHdvbid0IGJlIGFjY2Vzc2libGUgb24gcHJvZHVjZWQgc3ltYm9sIGluc3RhbmNlcyBhcyB0aGV5IGRlcml2ZSBmcm9tIEhpZGRlblN5bWJvbC5wcm90b3R5cGVcbmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCB7XG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiU3ltYm9sIChcIiArIHZhbGlkYXRlU3ltYm9sKHRoaXMpLl9fZGVzY3JpcHRpb25fXyArIFwiKVwiOyB9KSxcblx0dmFsdWVPZjogZChmdW5jdGlvbiAoKSB7IHJldHVybiB2YWxpZGF0ZVN5bWJvbCh0aGlzKTsgfSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoXG5cdFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSxcblx0U3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmUsXG5cdGQoXCJcIiwgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzeW1ib2wgPSB2YWxpZGF0ZVN5bWJvbCh0aGlzKTtcblx0XHRpZiAodHlwZW9mIHN5bWJvbCA9PT0gXCJzeW1ib2xcIikgcmV0dXJuIHN5bWJvbDtcblx0XHRyZXR1cm4gc3ltYm9sLnRvU3RyaW5nKCk7XG5cdH0pXG4pO1xuZGVmaW5lUHJvcGVydHkoU3ltYm9sUG9seWZpbGwucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywgZChcImNcIiwgXCJTeW1ib2xcIikpO1xuXG4vLyBQcm9wZXIgaW1wbGVtZW50YXRvbiBvZiB0b1ByaW1pdGl2ZSBhbmQgdG9TdHJpbmdUYWcgZm9yIHJldHVybmVkIHN5bWJvbCBpbnN0YW5jZXNcbmRlZmluZVByb3BlcnR5KFxuXHRIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyxcblx0ZChcImNcIiwgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnXSlcbik7XG5cbi8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRvIGRlZmluZSBgdG9QcmltaXRpdmVgIGFzIGxhc3Qgb25lLCBhcyBzb21lIGltcGxlbWVudGF0aW9uc1xuLy8gaW1wbGVtZW50IGB0b1ByaW1pdGl2ZWAgbmF0aXZlbHkgd2l0aG91dCBpbXBsZW1lbnRpbmcgYHRvU3RyaW5nVGFnYCAob3Igb3RoZXIgc3BlY2lmaWVkIHN5bWJvbHMpXG4vLyBBbmQgdGhhdCBtYXkgaW52b2tlIGVycm9yIGluIGRlZmluaXRpb24gZmxvdzpcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTMjaXNzdWVjb21tZW50LTE2NDE0NjE0OVxuZGVmaW5lUHJvcGVydHkoXG5cdEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLFxuXHRkKFwiY1wiLCBTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGVbU3ltYm9sUG9seWZpbGwudG9QcmltaXRpdmVdKVxuKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKFwiLi9pcy1zeW1ib2xcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNTeW1ib2wodmFsdWUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHZhbHVlICsgXCIgaXMgbm90IGEgc3ltYm9sXCIpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwidmFyIG5haXZlRmFsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKSByZXR1cm4gc2VsZjtcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93KSByZXR1cm4gd2luZG93O1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgYHRoaXNgXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcykgcmV0dXJuIHRoaXM7XG5cblx0Ly8gVW5leHBlY3RlZCBzdHJpY3QgbW9kZSAobWF5IGhhcHBlbiBpZiBlLmcuIGJ1bmRsZWQgaW50byBFU00gbW9kdWxlKVxuXG5cdC8vIFRoYW5rcyBAbWF0aGlhc2J5bmVucyAtPiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuXHQvLyBJbiBhbGwgRVM1KyBlbmdpbmVzIGdsb2JhbCBvYmplY3QgaW5oZXJpdHMgZnJvbSBPYmplY3QucHJvdG90eXBlXG5cdC8vIChpZiB5b3UgYXBwcm9hY2hlZCBvbmUgdGhhdCBkb2Vzbid0IHBsZWFzZSByZXBvcnQpXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsIFwiX19nbG9iYWxfX1wiLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHR9KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBVbmZvcnR1bmF0ZSBjYXNlIG9mIE9iamVjdC5wcm90b3R5cGUgYmVpbmcgc2VhbGVkICh2aWEgcHJldmVudEV4dGVuc2lvbnMsIHNlYWwgb3IgZnJlZXplKVxuXHRcdHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdH1cblx0dHJ5IHtcblx0XHQvLyBTYWZhcmkgY2FzZSAod2luZG93Ll9fZ2xvYmFsX18gaXMgcmVzb2x2ZWQgd2l0aCBnbG9iYWwgY29udGV4dCwgYnV0IF9fZ2xvYmFsX18gZG9lcyBub3QpXG5cdFx0aWYgKCFfX2dsb2JhbF9fKSByZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHRcdHJldHVybiBfX2dsb2JhbF9fO1xuXHR9IGZpbmFsbHkge1xuXHRcdGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG5cdH1cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gZ2xvYmFsVGhpcyA6IHJlcXVpcmUoXCIuL2ltcGxlbWVudGF0aW9uXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcblx0aWYgKCFnbG9iYWxUaGlzKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnbG9iYWxUaGlzLkFycmF5ID09PSBBcnJheTtcbn07XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5mb3IgKHZhciBrZXkgaW4gaHR0cCkge1xuICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldXG59XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICBwYXJhbXMgPSB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpXG4gIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKVxufVxuXG5odHRwcy5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICBwYXJhbXMgPSB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpXG4gIHJldHVybiBodHRwLmdldC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1zIChwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zID0gdXJsLnBhcnNlKHBhcmFtcylcbiAgfVxuICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgIHBhcmFtcy5wcm90b2NvbCA9ICdodHRwczonXG4gIH1cbiAgaWYgKHBhcmFtcy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIFwiJyArIHBhcmFtcy5wcm90b2NvbCArICdcIiBub3Qgc3VwcG9ydGVkLiBFeHBlY3RlZCBcImh0dHBzOlwiJylcbiAgfVxuICByZXR1cm4gcGFyYW1zXG59XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLyohXG4gKiBpbi1hcnJheSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaW4tYXJyYXk+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5BcnJheSAoYXJyLCB2YWwpIHtcbiAgYXJyID0gYXJyIHx8IFtdO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA9PT0gdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQsIDIwMTUgU2ltb24gTHlkZWxsXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXG5cbi8vIFRoaXMgcmVnZXggY29tZXMgZnJvbSByZWdleC5jb2ZmZWUsIGFuZCBpcyBpbnNlcnRlZCBoZXJlIGJ5IGdlbmVyYXRlLWluZGV4LmpzXG4vLyAocnVuIGBucG0gcnVuIGJ1aWxkYCkuXG5tb2R1bGUuZXhwb3J0cyA9IC8oKFsnXCJdKSg/Oig/IVxcMnxcXFxcKS58XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKihcXDIpP3xgKD86W15gXFxcXCRdfFxcXFxbXFxzXFxTXXxcXCQoPyFcXHspfFxcJFxceyg/Oltee31dfFxce1tefV0qXFx9PykqXFx9PykqKGApPyl8KFxcL1xcLy4qKXwoXFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSooXFwqXFwvKT8pfChcXC8oPyFcXCopKD86XFxbKD86KD8hW1xcXVxcXFxdKS58XFxcXC4pKlxcXXwoPyFbXFwvXFxdXFxcXF0pLnxcXFxcLikrXFwvKD86KD8hXFxzKig/OlxcYnxbXFx1MDA4MC1cXHVGRkZGJFxcXFwnXCJ+KHtdfFsrXFwtIV0oPyE9KXxcXC4/XFxkKSl8W2dtaXl1XXsxLDV9XFxiKD8hW1xcdTAwODAtXFx1RkZGRiRcXFxcXXxcXHMqKD86WytcXC0qJSZ8Xjw+IT0/KHtdfFxcLyg/IVtcXC8qXSkpKSkpfCgoPzowW3hYXVtcXGRhLWZBLUZdK3wwW29PXVswLTddK3wwW2JCXVswMV0rfCg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPykpfCgoPyFcXGQpKD86KD8hXFxzKVskXFx3XFx1MDA4MC1cXHVGRkZGXXxcXFxcdVtcXGRhLWZBLUZdezR9fFxcXFx1XFx7W1xcZGEtZkEtRl17MSw2fVxcfSkrKXwoLS18XFwrXFwrfCYmfFxcfFxcfHw9PnxcXC57M318KD86WytcXC0qXFwvJSZ8Xl18PHsxLDJ9fD57MSwzfXwhPT98PXsxLDJ9KT0/fFs/On5dfFs7LC5bXFxdKCl7fV0pfChcXHMrKXwoXiR8W1xcc1xcU10pL2dcblxubW9kdWxlLmV4cG9ydHMubWF0Y2hUb1Rva2VuID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgdmFyIHRva2VuID0ge3R5cGU6IFwiaW52YWxpZFwiLCB2YWx1ZTogbWF0Y2hbMF19XG4gICAgICAgaWYgKG1hdGNoWyAxXSkgdG9rZW4udHlwZSA9IFwic3RyaW5nXCIgLCB0b2tlbi5jbG9zZWQgPSAhIShtYXRjaFszXSB8fCBtYXRjaFs0XSlcbiAgZWxzZSBpZiAobWF0Y2hbIDVdKSB0b2tlbi50eXBlID0gXCJjb21tZW50XCJcbiAgZWxzZSBpZiAobWF0Y2hbIDZdKSB0b2tlbi50eXBlID0gXCJjb21tZW50XCIsIHRva2VuLmNsb3NlZCA9ICEhbWF0Y2hbN11cbiAgZWxzZSBpZiAobWF0Y2hbIDhdKSB0b2tlbi50eXBlID0gXCJyZWdleFwiXG4gIGVsc2UgaWYgKG1hdGNoWyA5XSkgdG9rZW4udHlwZSA9IFwibnVtYmVyXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTBdKSB0b2tlbi50eXBlID0gXCJuYW1lXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTFdKSB0b2tlbi50eXBlID0gXCJwdW5jdHVhdG9yXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTJdKSB0b2tlbi50eXBlID0gXCJ3aGl0ZXNwYWNlXCJcbiAgcmV0dXJuIHRva2VuXG59XG4iLCJ2YXIganNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyA/IEpTT04gOiByZXF1aXJlKCdqc29uaWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIHNwYWNlID0gb3B0cy5zcGFjZSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykgc3BhY2UgPSBBcnJheShzcGFjZSsxKS5qb2luKCcgJyk7XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuICAgIHZhciByZXBsYWNlciA9IG9wdHMucmVwbGFjZXIgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcbiAgICAgICAgICAgICAgICB2YXIgYm9iaiA9IHsga2V5OiBiLCB2YWx1ZTogbm9kZVtiXSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KShvcHRzLmNtcCk7XG5cbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNwYWNlID8gKCdcXG4nICsgbmV3IEFycmF5KGxldmVsICsgMSkuam9pbihzcGFjZSkpIDogJyc7XG4gICAgICAgIHZhciBjb2xvblNlcGFyYXRvciA9IHNwYWNlID8gJzogJyA6ICc6JztcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uLnN0cmluZ2lmeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdHJpbmdpZnkobm9kZSwgaSwgbm9kZVtpXSwgbGV2ZWwrMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4ganNvbi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc2Vlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlLCBrZXksIG5vZGVba2V5XSwgbGV2ZWwrMSk7XG5cbiAgICAgICAgICAgICAgICBpZighdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0ganNvbi5zdHJpbmdpZnkoa2V5KVxuICAgICAgICAgICAgICAgICAgICArIGNvbG9uU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5zcGxpY2Uoc2Vlbi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuICAgICAgICB9XG4gICAgfSkoeyAnJzogb2JqIH0sICcnLCBvYmosIDApO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG4iLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH0sXG4gICAgcmVwO1xuXG5mdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG4gICAgXG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgIHBhcnRpYWwsXG4gICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgdmFyIGk7XG4gICAgZ2FwID0gJyc7XG4gICAgaW5kZW50ID0gJyc7XG4gICAgXG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgIC8vIG1hbnkgc3BhY2VzLlxuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbidcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLyogUHJvdG9jb2wgLSBwcm90b2NvbCBjb25zdGFudHMgKi9cbnZhciBwcm90b2NvbCA9IG1vZHVsZS5leHBvcnRzXG5cbi8qIENvbW1hbmQgY29kZSA9PiBtbmVtb25pYyAqL1xucHJvdG9jb2wudHlwZXMgPSB7XG4gIDA6ICdyZXNlcnZlZCcsXG4gIDE6ICdjb25uZWN0JyxcbiAgMjogJ2Nvbm5hY2snLFxuICAzOiAncHVibGlzaCcsXG4gIDQ6ICdwdWJhY2snLFxuICA1OiAncHVicmVjJyxcbiAgNjogJ3B1YnJlbCcsXG4gIDc6ICdwdWJjb21wJyxcbiAgODogJ3N1YnNjcmliZScsXG4gIDk6ICdzdWJhY2snLFxuICAxMDogJ3Vuc3Vic2NyaWJlJyxcbiAgMTE6ICd1bnN1YmFjaycsXG4gIDEyOiAncGluZ3JlcScsXG4gIDEzOiAncGluZ3Jlc3AnLFxuICAxNDogJ2Rpc2Nvbm5lY3QnLFxuICAxNTogJ3Jlc2VydmVkJ1xufVxuXG4vKiBNbmVtb25pYyA9PiBDb21tYW5kIGNvZGUgKi9cbnByb3RvY29sLmNvZGVzID0ge31cbmZvciAodmFyIGsgaW4gcHJvdG9jb2wudHlwZXMpIHtcbiAgdmFyIHYgPSBwcm90b2NvbC50eXBlc1trXVxuICBwcm90b2NvbC5jb2Rlc1t2XSA9IGtcbn1cblxuLyogSGVhZGVyICovXG5wcm90b2NvbC5DTURfU0hJRlQgPSA0XG5wcm90b2NvbC5DTURfTUFTSyA9IDB4RjBcbnByb3RvY29sLkRVUF9NQVNLID0gMHgwOFxucHJvdG9jb2wuUU9TX01BU0sgPSAweDAzXG5wcm90b2NvbC5RT1NfU0hJRlQgPSAxXG5wcm90b2NvbC5SRVRBSU5fTUFTSyA9IDB4MDFcblxuLyogTGVuZ3RoICovXG5wcm90b2NvbC5MRU5HVEhfTUFTSyA9IDB4N0ZcbnByb3RvY29sLkxFTkdUSF9GSU5fTUFTSyA9IDB4ODBcblxuLyogQ29ubmFjayAqL1xucHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTSyA9IDB4MDFcbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9NQVNLXSlcbnByb3RvY29sLkNPTk5BQ0tfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydjb25uYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogQ29ubmVjdCAqL1xucHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA9IDB4ODBcbnByb3RvY29sLlBBU1NXT1JEX01BU0sgPSAweDQwXG5wcm90b2NvbC5XSUxMX1JFVEFJTl9NQVNLID0gMHgyMFxucHJvdG9jb2wuV0lMTF9RT1NfTUFTSyA9IDB4MThcbnByb3RvY29sLldJTExfUU9TX1NISUZUID0gM1xucHJvdG9jb2wuV0lMTF9GTEFHX01BU0sgPSAweDA0XG5wcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgPSAweDAyXG5wcm90b2NvbC5DT05ORUNUX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snY29ubmVjdCddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbmZ1bmN0aW9uIGdlbkhlYWRlciAodHlwZSkge1xuICByZXR1cm4gWzAsIDEsIDJdLm1hcChmdW5jdGlvbiAocW9zKSB7XG4gICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKGR1cCkge1xuICAgICAgcmV0dXJuIFswLCAxXS5tYXAoZnVuY3Rpb24gKHJldGFpbikge1xuICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcigxKVxuICAgICAgICBidWYud3JpdGVVSW50OChcbiAgICAgICAgICBwcm90b2NvbC5jb2Rlc1t0eXBlXSA8PCBwcm90b2NvbC5DTURfU0hJRlQgfFxuICAgICAgICAgIChkdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDApIHxcbiAgICAgICAgICBxb3MgPDwgcHJvdG9jb2wuUU9TX1NISUZUIHwgcmV0YWluLCAwLCB0cnVlKVxuICAgICAgICByZXR1cm4gYnVmXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8qIFB1Ymxpc2ggKi9cbnByb3RvY29sLlBVQkxJU0hfSEVBREVSID0gZ2VuSGVhZGVyKCdwdWJsaXNoJylcblxuLyogU3Vic2NyaWJlICovXG5wcm90b2NvbC5TVUJTQ1JJQkVfSEVBREVSID0gZ2VuSGVhZGVyKCdzdWJzY3JpYmUnKVxuXG4vKiBVbnN1YnNjcmliZSAqL1xucHJvdG9jb2wuVU5TVUJTQ1JJQkVfSEVBREVSID0gZ2VuSGVhZGVyKCd1bnN1YnNjcmliZScpXG5cbi8qIENvbmZpcm1hdGlvbnMgKi9cbnByb3RvY29sLkFDS1MgPSB7XG4gIHVuc3ViYWNrOiBnZW5IZWFkZXIoJ3Vuc3ViYWNrJyksXG4gIHB1YmFjazogZ2VuSGVhZGVyKCdwdWJhY2snKSxcbiAgcHViY29tcDogZ2VuSGVhZGVyKCdwdWJjb21wJyksXG4gIHB1YnJlbDogZ2VuSGVhZGVyKCdwdWJyZWwnKSxcbiAgcHVicmVjOiBnZW5IZWFkZXIoJ3B1YnJlYycpXG59XG5cbnByb3RvY29sLlNVQkFDS19IRUFERVIgPSBCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ3N1YmFjayddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIFByb3RvY29sIHZlcnNpb25zICovXG5wcm90b2NvbC5WRVJTSU9OMyA9IEJ1ZmZlci5mcm9tKFszXSlcbnByb3RvY29sLlZFUlNJT040ID0gQnVmZmVyLmZyb20oWzRdKVxuXG4vKiBRb1MgKi9cbnByb3RvY29sLlFPUyA9IFswLCAxLCAyXS5tYXAoZnVuY3Rpb24gKHFvcykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oW3Fvc10pXG59KVxuXG4vKiBFbXB0eSBwYWNrZXRzICovXG5wcm90b2NvbC5FTVBUWSA9IHtcbiAgcGluZ3JlcTogQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydwaW5ncmVxJ10gPDwgNCwgMF0pLFxuICBwaW5ncmVzcDogQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydwaW5ncmVzcCddIDw8IDQsIDBdKSxcbiAgZGlzY29ubmVjdDogQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydkaXNjb25uZWN0J10gPDwgNCwgMF0pXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgd3JpdGVUb1N0cmVhbSA9IHJlcXVpcmUoJy4vd3JpdGVUb1N0cmVhbScpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gZ2VuZXJhdGUgKHBhY2tldCkge1xuICB2YXIgc3RyZWFtID0gbmV3IEFjY3VtdWxhdG9yKClcbiAgd3JpdGVUb1N0cmVhbShwYWNrZXQsIHN0cmVhbSlcbiAgcmV0dXJuIHN0cmVhbS5jb25jYXQoKVxufVxuXG5mdW5jdGlvbiBBY2N1bXVsYXRvciAoKSB7XG4gIHRoaXMuX2FycmF5ID0gbmV3IEFycmF5KDIwKVxuICB0aGlzLl9pID0gMFxufVxuXG5pbmhlcml0cyhBY2N1bXVsYXRvciwgRUUpXG5cbkFjY3VtdWxhdG9yLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLl9hcnJheVt0aGlzLl9pKytdID0gY2h1bmtcbiAgcmV0dXJuIHRydWVcbn1cblxuQWNjdW11bGF0b3IucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IDBcbiAgdmFyIGxlbmd0aHMgPSBuZXcgQXJyYXkodGhpcy5fYXJyYXkubGVuZ3RoKVxuICB2YXIgbGlzdCA9IHRoaXMuX2FycmF5XG4gIHZhciBwb3MgPSAwXG4gIHZhciBpXG4gIHZhciByZXN1bHRcblxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGggJiYgbGlzdFtpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIGxpc3RbaV0gIT09ICdzdHJpbmcnKSBsZW5ndGhzW2ldID0gbGlzdFtpXS5sZW5ndGhcbiAgICBlbHNlIGxlbmd0aHNbaV0gPSBCdWZmZXIuYnl0ZUxlbmd0aChsaXN0W2ldKVxuXG4gICAgbGVuZ3RoICs9IGxlbmd0aHNbaV1cbiAgfVxuXG4gIHJlc3VsdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG5cbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0W2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgbGlzdFtpXS5jb3B5KHJlc3VsdCwgcG9zKVxuICAgICAgcG9zICs9IGxlbmd0aHNbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LndyaXRlKGxpc3RbaV0sIHBvcylcbiAgICAgIHBvcyArPSBsZW5ndGhzW2ldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpXG5leHBvcnRzLmdlbmVyYXRlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpXG5leHBvcnRzLndyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIG1heCA9IDY1NTM2XG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlciAoaSkge1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGkgPj4gOCwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaSAmIDB4MDBGRiwgMCArIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNhY2hlICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGNhY2hlW2ldID0gZ2VuZXJhdGVCdWZmZXIoaSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2FjaGU6IGNhY2hlLFxuICBnZW5lcmF0ZUNhY2hlOiBnZW5lcmF0ZUNhY2hlLFxuICBnZW5lcmF0ZU51bWJlcjogZ2VuZXJhdGVCdWZmZXJcbn1cbiIsIlxuZnVuY3Rpb24gUGFja2V0ICgpIHtcbiAgdGhpcy5jbWQgPSBudWxsXG4gIHRoaXMucmV0YWluID0gZmFsc2VcbiAgdGhpcy5xb3MgPSAwXG4gIHRoaXMuZHVwID0gZmFsc2VcbiAgdGhpcy5sZW5ndGggPSAtMVxuICB0aGlzLnRvcGljID0gbnVsbFxuICB0aGlzLnBheWxvYWQgPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFja2V0XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJsID0gcmVxdWlyZSgnYmwnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgUGFja2V0ID0gcmVxdWlyZSgnLi9wYWNrZXQnKVxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcnNlcikpIHJldHVybiBuZXcgUGFyc2VyKClcblxuICB0aGlzLl9zdGF0ZXMgPSBbXG4gICAgJ19wYXJzZUhlYWRlcicsXG4gICAgJ19wYXJzZUxlbmd0aCcsXG4gICAgJ19wYXJzZVBheWxvYWQnLFxuICAgICdfbmV3UGFja2V0J1xuICBdXG5cbiAgdGhpcy5fcmVzZXRTdGF0ZSgpXG59XG5cbmluaGVyaXRzKFBhcnNlciwgRUUpXG5cblBhcnNlci5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG4gIHRoaXMuZXJyb3IgPSBudWxsXG4gIHRoaXMuX2xpc3QgPSBibCgpXG4gIHRoaXMuX3N0YXRlQ291bnRlciA9IDBcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMuZXJyb3IpIHRoaXMuX3Jlc2V0U3RhdGUoKVxuXG4gIHRoaXMuX2xpc3QuYXBwZW5kKGJ1ZilcblxuICB3aGlsZSAoKHRoaXMucGFja2V0Lmxlbmd0aCAhPT0gLTEgfHwgdGhpcy5fbGlzdC5sZW5ndGggPiAwKSAmJlxuICAgICAgICAgdGhpc1t0aGlzLl9zdGF0ZXNbdGhpcy5fc3RhdGVDb3VudGVyXV0oKSAmJlxuICAgICAgICAgIXRoaXMuZXJyb3IpIHtcbiAgICB0aGlzLl9zdGF0ZUNvdW50ZXIrK1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlQ291bnRlciA+PSB0aGlzLl9zdGF0ZXMubGVuZ3RoKSB0aGlzLl9zdGF0ZUNvdW50ZXIgPSAwXG4gIH1cblxuICByZXR1cm4gdGhpcy5fbGlzdC5sZW5ndGhcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VIZWFkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBieXRlIGluIHRoZSBidWZmZXJcbiAgdmFyIHplcm8gPSB0aGlzLl9saXN0LnJlYWRVSW50OCgwKVxuICB0aGlzLnBhY2tldC5jbWQgPSBjb25zdGFudHMudHlwZXNbemVybyA+PiBjb25zdGFudHMuQ01EX1NISUZUXVxuICB0aGlzLnBhY2tldC5yZXRhaW4gPSAoemVybyAmIGNvbnN0YW50cy5SRVRBSU5fTUFTSykgIT09IDBcbiAgdGhpcy5wYWNrZXQucW9zID0gKHplcm8gPj4gY29uc3RhbnRzLlFPU19TSElGVCkgJiBjb25zdGFudHMuUU9TX01BU0tcbiAgdGhpcy5wYWNrZXQuZHVwID0gKHplcm8gJiBjb25zdGFudHMuRFVQX01BU0spICE9PSAwXG5cbiAgdGhpcy5fbGlzdC5jb25zdW1lKDEpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBieXRlIGluIHRoZSBsaXN0XG4gIHZhciBieXRlcyA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIGxlbmd0aCA9IDBcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgdmFyIGN1cnJlbnRcblxuICB3aGlsZSAoYnl0ZXMgPCA1KSB7XG4gICAgY3VycmVudCA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KGJ5dGVzKyspXG4gICAgbGVuZ3RoICs9IG11bCAqIChjdXJyZW50ICYgY29uc3RhbnRzLkxFTkdUSF9NQVNLKVxuICAgIG11bCAqPSAweDgwXG5cbiAgICBpZiAoKGN1cnJlbnQgJiBjb25zdGFudHMuTEVOR1RIX0ZJTl9NQVNLKSA9PT0gMCkgYnJlYWtcbiAgICBpZiAodGhpcy5fbGlzdC5sZW5ndGggPD0gYnl0ZXMpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHQpIHtcbiAgICB0aGlzLnBhY2tldC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGlzLl9saXN0LmNvbnN1bWUoYnl0ZXMpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlUGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IGZhbHNlXG5cbiAgLy8gRG8gd2UgaGF2ZSBhIHBheWxvYWQ/IERvIHdlIGhhdmUgZW5vdWdoIGRhdGEgdG8gY29tcGxldGUgdGhlIHBheWxvYWQ/XG4gIC8vIFBJTkdzIGhhdmUgbm8gcGF5bG9hZFxuICBpZiAodGhpcy5wYWNrZXQubGVuZ3RoID09PSAwIHx8IHRoaXMuX2xpc3QubGVuZ3RoID49IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgIHRoaXMuX3BvcyA9IDBcblxuICAgIHN3aXRjaCAodGhpcy5wYWNrZXQuY21kKSB7XG4gICAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgICAgdGhpcy5fcGFyc2VDb25uZWN0KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Nvbm5hY2snOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbm5hY2soKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHVibGlzaCc6XG4gICAgICAgIHRoaXMuX3BhcnNlUHVibGlzaCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwdWJhY2snOlxuICAgICAgY2FzZSAncHVicmVjJzpcbiAgICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICBjYXNlICdwdWJjb21wJzpcbiAgICAgICAgdGhpcy5fcGFyc2VNZXNzYWdlSWQoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3Vic2NyaWJlJzpcbiAgICAgICAgdGhpcy5fcGFyc2VTdWJzY3JpYmUoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3ViYWNrJzpcbiAgICAgICAgdGhpcy5fcGFyc2VTdWJhY2soKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zdWJzY3JpYmUnOlxuICAgICAgICB0aGlzLl9wYXJzZVVuc3Vic2NyaWJlKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgICAgdGhpcy5fcGFyc2VVbnN1YmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwaW5ncmVxJzpcbiAgICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAvLyBUaGVzZSBhcmUgZW1wdHksIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3RvY29sSWQgLy8gUHJvdG9jb2wgSURcbiAgdmFyIGNsaWVudElkIC8vIENsaWVudCBJRFxuICB2YXIgdG9waWMgLy8gV2lsbCB0b3BpY1xuICB2YXIgcGF5bG9hZCAvLyBXaWxsIHBheWxvYWRcbiAgdmFyIHBhc3N3b3JkIC8vIFBhc3N3b3JkXG4gIHZhciB1c2VybmFtZSAvLyBVc2VybmFtZVxuICB2YXIgZmxhZ3MgPSB7fVxuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICAvLyBQYXJzZSBwcm90b2NvbElkXG4gIHByb3RvY29sSWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG5cbiAgaWYgKHByb3RvY29sSWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcHJvdG9jb2xJZCcpKVxuICBpZiAocHJvdG9jb2xJZCAhPT0gJ01RVFQnICYmIHByb3RvY29sSWQgIT09ICdNUUlzZHAnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICB9XG5cbiAgcGFja2V0LnByb3RvY29sSWQgPSBwcm90b2NvbElkXG5cbiAgLy8gUGFyc2UgY29uc3RhbnRzIHZlcnNpb24gbnVtYmVyXG4gIGlmICh0aGlzLl9wb3MgPj0gdGhpcy5fbGlzdC5sZW5ndGgpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG5cbiAgcGFja2V0LnByb3RvY29sVmVyc2lvbiA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcylcblxuICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSA0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICB9XG5cbiAgdGhpcy5fcG9zKytcblxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgfVxuXG4gIC8vIFBhcnNlIGNvbm5lY3QgZmxhZ3NcbiAgZmxhZ3MudXNlcm5hbWUgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5VU0VSTkFNRV9NQVNLKVxuICBmbGFncy5wYXNzd29yZCA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLlBBU1NXT1JEX01BU0spXG4gIGZsYWdzLndpbGwgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX0ZMQUdfTUFTSylcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIHBhY2tldC53aWxsID0ge31cbiAgICBwYWNrZXQud2lsbC5yZXRhaW4gPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX1JFVEFJTl9NQVNLKSAhPT0gMFxuICAgIHBhY2tldC53aWxsLnFvcyA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLldJTExfUU9TX01BU0spID4+IGNvbnN0YW50cy5XSUxMX1FPU19TSElGVFxuICB9XG5cbiAgcGFja2V0LmNsZWFuID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuQ0xFQU5fU0VTU0lPTl9NQVNLKSAhPT0gMFxuICB0aGlzLl9wb3MrK1xuXG4gIC8vIFBhcnNlIGtlZXBhbGl2ZVxuICBwYWNrZXQua2VlcGFsaXZlID0gdGhpcy5fcGFyc2VOdW0oKVxuICBpZiAocGFja2V0LmtlZXBhbGl2ZSA9PT0gLTEpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG5cbiAgLy8gUGFyc2UgY2xpZW50SWRcbiAgY2xpZW50SWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gIGlmIChjbGllbnRJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgcGFja2V0LmNsaWVudElkID0gY2xpZW50SWRcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIC8vIFBhcnNlIHdpbGwgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCB0b3BpYycpKVxuICAgIHBhY2tldC53aWxsLnRvcGljID0gdG9waWNcblxuICAgIC8vIFBhcnNlIHdpbGwgcGF5bG9hZFxuICAgIHBheWxvYWQgPSB0aGlzLl9wYXJzZUJ1ZmZlcigpXG4gICAgaWYgKHBheWxvYWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCBwYXlsb2FkJykpXG4gICAgcGFja2V0LndpbGwucGF5bG9hZCA9IHBheWxvYWRcbiAgfVxuXG4gIC8vIFBhcnNlIHVzZXJuYW1lXG4gIGlmIChmbGFncy51c2VybmFtZSkge1xuICAgIHVzZXJuYW1lID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh1c2VybmFtZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB1c2VybmFtZScpKVxuICAgIHBhY2tldC51c2VybmFtZSA9IHVzZXJuYW1lXG4gIH1cblxuICAvLyBQYXJzZSBwYXNzd29yZFxuICBpZiAoZmxhZ3MucGFzc3dvcmQpIHtcbiAgICBwYXNzd29yZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICBpZiAocGFzc3dvcmQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcGFzc3dvcmQnKSlcbiAgICBwYWNrZXQucGFzc3dvcmQgPSBwYXNzd29yZFxuICB9XG5cbiAgcmV0dXJuIHBhY2tldFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5hY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8IDIpIHJldHVybiBudWxsXG5cbiAgcGFja2V0LnNlc3Npb25QcmVzZW50ID0gISEodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspICYgY29uc3RhbnRzLlNFU1NJT05QUkVTRU5UX01BU0spXG4gIHBhY2tldC5yZXR1cm5Db2RlID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKVxuXG4gIGlmIChwYWNrZXQucmV0dXJuQ29kZSA9PT0gLTEpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcmV0dXJuIGNvZGUnKSlcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgcGFja2V0LnRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwYWNrZXQudG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAvLyBQYXJzZSBtZXNzYWdlSWRcbiAgaWYgKHBhY2tldC5xb3MgPiAwKSBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICBwYWNrZXQucGF5bG9hZCA9IHRoaXMuX2xpc3Quc2xpY2UodGhpcy5fcG9zLCBwYWNrZXQubGVuZ3RoKVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG4gIHZhciB0b3BpY1xuICB2YXIgcW9zXG5cbiAgaWYgKHBhY2tldC5xb3MgIT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignV3Jvbmcgc3Vic2NyaWJlIGhlYWRlcicpKVxuICB9XG5cbiAgcGFja2V0LnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIHdoaWxlICh0aGlzLl9wb3MgPCBwYWNrZXQubGVuZ3RoKSB7XG4gICAgLy8gUGFyc2UgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAgIGlmICh0aGlzLl9wb3MgPj0gcGFja2V0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ01hbGZvcm1lZCBTdWJzY3JpYmUgUGF5bG9hZCcpKVxuICAgIHFvcyA9IHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKVxuXG4gICAgLy8gUHVzaCBwYWlyIHRvIHN1YnNjcmlwdGlvbnNcbiAgICBwYWNrZXQuc3Vic2NyaXB0aW9ucy5wdXNoKHsgdG9waWM6IHRvcGljLCBxb3M6IHFvcyB9KVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlU3ViYWNrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBhY2tldC5ncmFudGVkID0gW11cblxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQYXJzZSBncmFudGVkIFFvU2VzXG4gIHdoaWxlICh0aGlzLl9wb3MgPCB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLnBhY2tldC5ncmFudGVkLnB1c2godGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICB3aGlsZSAodGhpcy5fcG9zIDwgcGFja2V0Lmxlbmd0aCkge1xuICAgIHZhciB0b3BpY1xuXG4gICAgLy8gUGFyc2UgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAgIC8vIFB1c2ggdG9waWMgdG8gdW5zdWJzY3JpcHRpb25zXG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5wdXNoKHRvcGljKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVW5zdWJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBtZXNzYWdlSWQnKSlcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC5tZXNzYWdlSWQgPSB0aGlzLl9wYXJzZU51bSgpXG5cbiAgaWYgKHBhY2tldC5tZXNzYWdlSWQgPT09IG51bGwpIHtcbiAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChtYXliZUJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC50b1N0cmluZygndXRmOCcsIHRoaXMuX3BvcywgZW5kKVxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMuX3BhcnNlTnVtKClcbiAgdmFyIHJlc3VsdFxuICB2YXIgZW5kID0gbGVuZ3RoICsgdGhpcy5fcG9zXG5cbiAgaWYgKGxlbmd0aCA9PT0gLTEgfHwgZW5kID4gdGhpcy5fbGlzdC5sZW5ndGggfHwgZW5kID4gdGhpcy5wYWNrZXQubGVuZ3RoKSByZXR1cm4gbnVsbFxuXG4gIHJlc3VsdCA9IHRoaXMuX2xpc3Quc2xpY2UodGhpcy5fcG9zLCBlbmQpXG5cbiAgdGhpcy5fcG9zICs9IGxlbmd0aFxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VOdW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCAtIHRoaXMuX3BvcyA8IDIpIHJldHVybiAtMVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50MTZCRSh0aGlzLl9wb3MpXG4gIHRoaXMuX3BvcyArPSAyXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9uZXdQYWNrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhY2tldCkge1xuICAgIHRoaXMuX2xpc3QuY29uc3VtZSh0aGlzLnBhY2tldC5sZW5ndGgpXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCB0aGlzLnBhY2tldClcbiAgfVxuXG4gIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fZW1pdEVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmVycm9yID0gZXJyXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyc2VyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHByb3RvY29sID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZW1wdHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbnZhciB6ZXJvQnVmID0gQnVmZmVyLmZyb20oWzBdKVxudmFyIG51bWJlcnMgPSByZXF1aXJlKCcuL251bWJlcnMnKVxudmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKS5uZXh0VGlja1xuXG52YXIgbnVtQ2FjaGUgPSBudW1iZXJzLmNhY2hlXG52YXIgZ2VuZXJhdGVOdW1iZXIgPSBudW1iZXJzLmdlbmVyYXRlTnVtYmVyXG52YXIgZ2VuZXJhdGVDYWNoZSA9IG51bWJlcnMuZ2VuZXJhdGVDYWNoZVxudmFyIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbnZhciB0b0dlbmVyYXRlID0gdHJ1ZVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5jb3JrKSB7XG4gICAgc3RyZWFtLmNvcmsoKVxuICAgIG5leHRUaWNrKHVuY29yaywgc3RyZWFtKVxuICB9XG5cbiAgaWYgKHRvR2VuZXJhdGUpIHtcbiAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICBnZW5lcmF0ZUNhY2hlKClcbiAgfVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGNvbm5lY3QocGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAnY29ubmFjayc6XG4gICAgICByZXR1cm4gY29ubmFjayhwYWNrZXQsIHN0cmVhbSlcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHJldHVybiBwdWJsaXNoKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgIHJldHVybiBjb25maXJtYXRpb24ocGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAnc3Vic2NyaWJlJzpcbiAgICAgIHJldHVybiBzdWJzY3JpYmUocGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAnc3ViYWNrJzpcbiAgICAgIHJldHVybiBzdWJhY2socGFja2V0LCBzdHJlYW0pXG4gICAgY2FzZSAndW5zdWJzY3JpYmUnOlxuICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlKHBhY2tldCwgc3RyZWFtKVxuICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgIHJldHVybiBlbXB0eVBhY2tldChwYWNrZXQsIHN0cmVhbSlcbiAgICBkZWZhdWx0OlxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVbmtub3duIGNvbW1hbmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4vKipcbiAqIENvbnRyb2xzIG51bWJlcnMgY2FjaGUuXG4gKiBTZXQgdG8gXCJmYWxzZVwiIHRvIGFsbG9jYXRlIGJ1ZmZlcnMgb24tdGhlLWZsaWdodCBpbnN0ZWFkIG9mIHByZS1nZW5lcmF0ZWQgY2FjaGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGdlbmVyYXRlLCAnY2FjaGVOdW1iZXJzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd3JpdGVOdW1iZXIgPT09IHdyaXRlTnVtYmVyQ2FjaGVkXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIW51bUNhY2hlIHx8IE9iamVjdC5rZXlzKG51bUNhY2hlKS5sZW5ndGggPT09IDApIHRvR2VuZXJhdGUgPSB0cnVlXG4gICAgICB3cml0ZU51bWJlciA9IHdyaXRlTnVtYmVyQ2FjaGVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRvR2VuZXJhdGUgPSBmYWxzZVxuICAgICAgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckdlbmVyYXRlZFxuICAgIH1cbiAgfVxufSlcblxuZnVuY3Rpb24gdW5jb3JrIChzdHJlYW0pIHtcbiAgc3RyZWFtLnVuY29yaygpXG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QgKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciBwcm90b2NvbElkID0gc2V0dGluZ3MucHJvdG9jb2xJZCB8fCAnTVFUVCdcbiAgdmFyIHByb3RvY29sVmVyc2lvbiA9IHNldHRpbmdzLnByb3RvY29sVmVyc2lvbiB8fCA0XG4gIHZhciB3aWxsID0gc2V0dGluZ3Mud2lsbFxuICB2YXIgY2xlYW4gPSBzZXR0aW5ncy5jbGVhblxuICB2YXIga2VlcGFsaXZlID0gc2V0dGluZ3Mua2VlcGFsaXZlIHx8IDBcbiAgdmFyIGNsaWVudElkID0gc2V0dGluZ3MuY2xpZW50SWQgfHwgJydcbiAgdmFyIHVzZXJuYW1lID0gc2V0dGluZ3MudXNlcm5hbWVcbiAgdmFyIHBhc3N3b3JkID0gc2V0dGluZ3MucGFzc3dvcmRcblxuICBpZiAoY2xlYW4gPT09IHVuZGVmaW5lZCkgY2xlYW4gPSB0cnVlXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBNdXN0IGJlIGEgc3RyaW5nIGFuZCBub24tZmFsc3lcbiAgaWYgKCFwcm90b2NvbElkIHx8XG4gICAgICh0eXBlb2YgcHJvdG9jb2xJZCAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwcm90b2NvbElkKSkpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IHByb3RvY29sSWQubGVuZ3RoICsgMlxuXG4gIC8vIE11c3QgYmUgMyBvciA0XG4gIGlmIChwcm90b2NvbFZlcnNpb24gIT09IDMgJiYgcHJvdG9jb2xWZXJzaW9uICE9PSA0KSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAxXG5cbiAgLy8gQ2xpZW50SWQgbWlnaHQgYmUgb21pdHRlZCBpbiAzLjEuMSwgYnV0IG9ubHkgaWYgY2xlYW5TZXNzaW9uIGlzIHNldCB0byAxXG4gIGlmICgodHlwZW9mIGNsaWVudElkID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoY2xpZW50SWQpKSAmJlxuICAgICAoY2xpZW50SWQgfHwgcHJvdG9jb2xWZXJzaW9uID09PSA0KSAmJiAoY2xpZW50SWQgfHwgY2xlYW4pKSB7XG4gICAgbGVuZ3RoICs9IGNsaWVudElkLmxlbmd0aCArIDJcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uIDwgNCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIHN1cHBsaWVkIGJlZm9yZSAzLjEuMScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICgoY2xlYW4gKiAxKSA9PT0gMCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIGdpdmVuIGlmIGNsZWFuU2Vzc2lvbiBzZXQgdG8gMCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gTXVzdCBiZSBhIHR3byBieXRlIG51bWJlclxuICBpZiAodHlwZW9mIGtlZXBhbGl2ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgIGtlZXBhbGl2ZSA8IDAgfHxcbiAgICAgIGtlZXBhbGl2ZSA+IDY1NTM1IHx8XG4gICAgICBrZWVwYWxpdmUgJSAxICE9PSAwKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIGtlZXBhbGl2ZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIGxlbmd0aCArPSAxXG5cbiAgLy8gSWYgd2lsbCBleGlzdHMuLi5cbiAgaWYgKHdpbGwpIHtcbiAgICAvLyBJdCBtdXN0IGJlIGFuIG9iamVjdFxuICAgIGlmICh0eXBlb2Ygd2lsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gSXQgbXVzdCBoYXZlIHRvcGljIHR5cGVvZiBzdHJpbmdcbiAgICBpZiAoIXdpbGwudG9waWMgfHwgdHlwZW9mIHdpbGwudG9waWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCB0b3BpYycpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh3aWxsLnRvcGljKSArIDJcbiAgICB9XG5cbiAgICAvLyBQYXlsb2FkXG4gICAgaWYgKHdpbGwucGF5bG9hZCAmJiB3aWxsLnBheWxvYWQpIHtcbiAgICAgIGlmICh3aWxsLnBheWxvYWQubGVuZ3RoID49IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsLnBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHdpbGwucGF5bG9hZCkgKyAyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoICs9IHdpbGwucGF5bG9hZC5sZW5ndGggKyAyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsIHBheWxvYWQnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCArPSAyXG4gICAgfVxuICB9XG5cbiAgLy8gVXNlcm5hbWVcbiAgdmFyIHByb3ZpZGVkVXNlcm5hbWUgPSBmYWxzZVxuICBpZiAodXNlcm5hbWUgIT0gbnVsbCkge1xuICAgIGlmIChpc1N0cmluZ09yQnVmZmVyKHVzZXJuYW1lKSkge1xuICAgICAgcHJvdmlkZWRVc2VybmFtZSA9IHRydWVcbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh1c2VybmFtZSkgKyAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB1c2VybmFtZScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gUGFzc3dvcmRcbiAgaWYgKHBhc3N3b3JkICE9IG51bGwpIHtcbiAgICBpZiAoIXByb3ZpZGVkVXNlcm5hbWUpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQgdG8gdXNlIHBhc3N3b3JkJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmdPckJ1ZmZlcihwYXNzd29yZCkpIHtcbiAgICAgIGxlbmd0aCArPSBieXRlTGVuZ3RoKHBhc3N3b3JkKSArIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHBhc3N3b3JkJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkNPTk5FQ1RfSEVBREVSKVxuXG4gIC8vIEdlbmVyYXRlIGxlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBwcm90b2NvbCBJRFxuICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgcHJvdG9jb2xJZClcbiAgc3RyZWFtLndyaXRlKFxuICAgIHByb3RvY29sVmVyc2lvbiA9PT0gNCA/IHByb3RvY29sLlZFUlNJT040IDogcHJvdG9jb2wuVkVSU0lPTjNcbiAgKVxuXG4gIC8vIENvbm5lY3QgZmxhZ3NcbiAgdmFyIGZsYWdzID0gMFxuICBmbGFncyB8PSAodXNlcm5hbWUgIT0gbnVsbCkgPyBwcm90b2NvbC5VU0VSTkFNRV9NQVNLIDogMFxuICBmbGFncyB8PSAocGFzc3dvcmQgIT0gbnVsbCkgPyBwcm90b2NvbC5QQVNTV09SRF9NQVNLIDogMFxuICBmbGFncyB8PSAod2lsbCAmJiB3aWxsLnJldGFpbikgPyBwcm90b2NvbC5XSUxMX1JFVEFJTl9NQVNLIDogMFxuICBmbGFncyB8PSAod2lsbCAmJiB3aWxsLnFvcykgPyB3aWxsLnFvcyA8PCBwcm90b2NvbC5XSUxMX1FPU19TSElGVCA6IDBcbiAgZmxhZ3MgfD0gd2lsbCA/IHByb3RvY29sLldJTExfRkxBR19NQVNLIDogMFxuICBmbGFncyB8PSBjbGVhbiA/IHByb3RvY29sLkNMRUFOX1NFU1NJT05fTUFTSyA6IDBcblxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW2ZsYWdzXSkpXG5cbiAgLy8gS2VlcGFsaXZlXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwga2VlcGFsaXZlKVxuXG4gIC8vIENsaWVudCBJRFxuICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgY2xpZW50SWQpXG5cbiAgLy8gV2lsbFxuICBpZiAod2lsbCkge1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgd2lsbC50b3BpYylcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgd2lsbC5wYXlsb2FkKVxuICB9XG5cbiAgLy8gVXNlcm5hbWUgYW5kIHBhc3N3b3JkXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHVzZXJuYW1lKVxuICB9XG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHBhc3N3b3JkKVxuICB9XG4gIC8vIFRoaXMgaXMgYSBzbWFsbCBwYWNrZXQgdGhhdCBoYXBwZW5zIG9ubHkgb25jZSBvbiBhIHN0cmVhbVxuICAvLyBXZSBhc3N1bWUgdGhlIHN0cmVhbSBpcyBhbHdheXMgZnJlZSB0byByZWNlaXZlIG1vcmUgZGF0YSBhZnRlciB0aGlzXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbm5hY2sgKG9wdHMsIHN0cmVhbSkge1xuICB2YXIgc2V0dGluZ3MgPSBvcHRzIHx8IHt9XG4gIHZhciByYyA9IHNldHRpbmdzLnJldHVybkNvZGVcblxuICAvLyBDaGVjayByZXR1cm4gY29kZVxuICBpZiAodHlwZW9mIHJjICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCByZXR1cm4gY29kZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkNPTk5BQ0tfSEVBREVSKVxuICB3cml0ZUxlbmd0aChzdHJlYW0sIDIpXG4gIHN0cmVhbS53cml0ZShvcHRzLnNlc3Npb25QcmVzZW50ID8gcHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfSEVBREVSIDogemVyb0J1ZilcblxuICByZXR1cm4gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyY10pKVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgcW9zID0gc2V0dGluZ3MucW9zIHx8IDBcbiAgdmFyIHJldGFpbiA9IHNldHRpbmdzLnJldGFpbiA/IHByb3RvY29sLlJFVEFJTl9NQVNLIDogMFxuICB2YXIgdG9waWMgPSBzZXR0aW5ncy50b3BpY1xuICB2YXIgcGF5bG9hZCA9IHNldHRpbmdzLnBheWxvYWQgfHwgZW1wdHlcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBUb3BpYyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBCdWZmZXJcbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh0b3BpYykgKyAyXG4gIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0b3BpYykpIGxlbmd0aCArPSB0b3BpYy5sZW5ndGggKyAyXG4gIGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB0b3BpYycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gR2V0IHRoZSBwYXlsb2FkIGxlbmd0aFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWQpXG4gIGVsc2UgbGVuZ3RoICs9IHBheWxvYWQubGVuZ3RoXG5cbiAgLy8gTWVzc2FnZSBJRCBtdXN0IGEgbnVtYmVyIGlmIHFvcyA+IDBcbiAgaWYgKHFvcyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHFvcykgbGVuZ3RoICs9IDJcblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlBVQkxJU0hfSEVBREVSW3Fvc11bb3B0cy5kdXAgPyAxIDogMF1bcmV0YWluID8gMSA6IDBdKVxuXG4gIC8vIFJlbWFpbmluZyBsZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gVG9waWNcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBieXRlTGVuZ3RoKHRvcGljKSlcbiAgc3RyZWFtLndyaXRlKHRvcGljKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgaWYgKHFvcyA+IDApIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gUGF5bG9hZFxuICByZXR1cm4gc3RyZWFtLndyaXRlKHBheWxvYWQpXG59XG5cbi8qIFB1YmFjaywgcHVicmVjLCBwdWJyZWwgYW5kIHB1YmNvbXAgKi9cbmZ1bmN0aW9uIGNvbmZpcm1hdGlvbiAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIHR5cGUgPSBzZXR0aW5ncy5jbWQgfHwgJ3B1YmFjaydcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBkdXAgPSAoc2V0dGluZ3MuZHVwICYmIHR5cGUgPT09ICdwdWJyZWwnKSA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgcW9zID0gMFxuXG4gIGlmICh0eXBlID09PSAncHVicmVsJykgcW9zID0gMVxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkFDS1NbdHlwZV1bcW9zXVtkdXBdWzBdKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZUxlbmd0aChzdHJlYW0sIDIpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICByZXR1cm4gd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgZHVwID0gc2V0dGluZ3MuZHVwID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciBpZCA9IHNldHRpbmdzLm1lc3NhZ2VJZFxuICB2YXIgc3VicyA9IHNldHRpbmdzLnN1YnNjcmlwdGlvbnNcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIENoZWNrIHN1YnNjcmlwdGlvbnNcbiAgaWYgKHR5cGVvZiBzdWJzID09PSAnb2JqZWN0JyAmJiBzdWJzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vicy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGl0b3BpYyA9IHN1YnNbaV0udG9waWNcbiAgICAgIHZhciBpcW9zID0gc3Vic1tpXS5xb3NcblxuICAgICAgaWYgKHR5cGVvZiBpdG9waWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCB0b3BpYycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXFvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHFvcycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGl0b3BpYykgKyAyICsgMVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucycpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgaGVhZGVyXG4gIHN0cmVhbS53cml0ZShwcm90b2NvbC5TVUJTQ1JJQkVfSEVBREVSWzFdW2R1cCA/IDEgOiAwXVswXSlcblxuICAvLyBHZW5lcmF0ZSBsZW5ndGhcbiAgd3JpdGVMZW5ndGgoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gR2VuZXJhdGUgbWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIHZhciByZXN1bHQgPSB0cnVlXG5cbiAgLy8gR2VuZXJhdGUgc3Vic1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgc3ViID0gc3Vic1tqXVxuICAgIHZhciBqdG9waWMgPSBzdWIudG9waWNcbiAgICB2YXIganFvcyA9IHN1Yi5xb3NcblxuICAgIC8vIFdyaXRlIHRvcGljIHN0cmluZ1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwganRvcGljKVxuXG4gICAgLy8gV3JpdGUgcW9zXG4gICAgcmVzdWx0ID0gc3RyZWFtLndyaXRlKHByb3RvY29sLlFPU1tqcW9zXSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gc3ViYWNrIChvcHRzLCBzdHJlYW0pIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0cyB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGdyYW50ZWQgPSBzZXR0aW5ncy5ncmFudGVkXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDaGVjayBncmFudGVkIHFvcyB2ZWN0b3JcbiAgaWYgKHR5cGVvZiBncmFudGVkID09PSAnb2JqZWN0JyAmJiBncmFudGVkLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBncmFudGVkW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlNVQkFDS19IRUFERVIpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICByZXR1cm4gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGdyYW50ZWQpKVxufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZSAob3B0cywgc3RyZWFtKSB7XG4gIHZhciBzZXR0aW5ncyA9IG9wdHMgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIHVuc3VicyA9IHNldHRpbmdzLnVuc3Vic2NyaXB0aW9uc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggKz0gMlxuICB9XG4gIC8vIENoZWNrIHVuc3Vic1xuICBpZiAodHlwZW9mIHVuc3VicyA9PT0gJ29iamVjdCcgJiYgdW5zdWJzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVuc3Vic2NyaXB0aW9ucycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh1bnN1YnNbaV0pICsgMlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlVOU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlTGVuZ3RoKHN0cmVhbSwgbGVuZ3RoKVxuXG4gIC8vIE1lc3NhZ2UgSURcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBVbnN1YnNcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgZm9yICh2YXIgaiA9IDA7IGogPCB1bnN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICByZXN1bHQgPSB3cml0ZVN0cmluZyhzdHJlYW0sIHVuc3Vic1tqXSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZW1wdHlQYWNrZXQgKG9wdHMsIHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHByb3RvY29sLkVNUFRZW29wdHMuY21kXSlcbn1cblxuLyoqXG4gKiBjYWxjTGVuZ3RoTGVuZ3RoIC0gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIHJlbWFpbmluZ1xuICogbGVuZ3RoIGZpZWxkXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGNMZW5ndGhMZW5ndGggKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID49IDAgJiYgbGVuZ3RoIDwgMTI4KSByZXR1cm4gMVxuICBlbHNlIGlmIChsZW5ndGggPj0gMTI4ICYmIGxlbmd0aCA8IDE2Mzg0KSByZXR1cm4gMlxuICBlbHNlIGlmIChsZW5ndGggPj0gMTYzODQgJiYgbGVuZ3RoIDwgMjA5NzE1MikgcmV0dXJuIDNcbiAgZWxzZSBpZiAobGVuZ3RoID49IDIwOTcxNTIgJiYgbGVuZ3RoIDwgMjY4NDM1NDU2KSByZXR1cm4gNFxuICBlbHNlIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGdlbkJ1Zkxlbmd0aCAobGVuZ3RoKSB7XG4gIHZhciBkaWdpdCA9IDBcbiAgdmFyIHBvcyA9IDBcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShjYWxjTGVuZ3RoTGVuZ3RoKGxlbmd0aCkpXG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gbGVuZ3RoICUgMTI4IHwgMFxuICAgIGxlbmd0aCA9IGxlbmd0aCAvIDEyOCB8IDBcbiAgICBpZiAobGVuZ3RoID4gMCkgZGlnaXQgPSBkaWdpdCB8IDB4ODBcblxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KGRpZ2l0LCBwb3MrKylcbiAgfSB3aGlsZSAobGVuZ3RoID4gMClcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogd3JpdGVMZW5ndGggLSB3cml0ZSBhbiBNUVRUIHN0eWxlIGxlbmd0aCBmaWVsZCB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPE51bWJlcj4gbGVuZ3RoIC0gbGVuZ3RoICg+MClcbiAqIEByZXR1cm5zIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGxlbmd0aENhY2hlID0ge31cbmZ1bmN0aW9uIHdyaXRlTGVuZ3RoIChzdHJlYW0sIGxlbmd0aCkge1xuICB2YXIgYnVmZmVyID0gbGVuZ3RoQ2FjaGVbbGVuZ3RoXVxuXG4gIGlmICghYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gZ2VuQnVmTGVuZ3RoKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoIDwgMTYzODQpIGxlbmd0aENhY2hlW2xlbmd0aF0gPSBidWZmZXJcbiAgfVxuXG4gIHN0cmVhbS53cml0ZShidWZmZXIpXG59XG5cbi8qKlxuICogd3JpdGVTdHJpbmcgLSB3cml0ZSBhIHV0Zjggc3RyaW5nIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiBzdHJpbmcgLSBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyAoc3RyZWFtLCBzdHJpbmcpIHtcbiAgdmFyIHN0cmxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cmluZylcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBzdHJsZW4pXG5cbiAgc3RyZWFtLndyaXRlKHN0cmluZywgJ3V0ZjgnKVxufVxuXG4vKipcbiAqIHdyaXRlTnVtYmVyIC0gd3JpdGUgYSB0d28gYnl0ZSBudW1iZXIgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxOdW1iZXI+IHBvcyAtIG9mZnNldFxuICogQHBhcmFtIDxTdHJpbmc+IG51bWJlciAtIG51bWJlciB0byB3cml0ZVxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cml0ZU51bWJlckNhY2hlZCAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShudW1DYWNoZVtudW1iZXJdKVxufVxuZnVuY3Rpb24gd3JpdGVOdW1iZXJHZW5lcmF0ZWQgKHN0cmVhbSwgbnVtYmVyKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUoZ2VuZXJhdGVOdW1iZXIobnVtYmVyKSlcbn1cblxuLyoqXG4gKiB3cml0ZVN0cmluZ09yQnVmZmVyIC0gd3JpdGUgYSBTdHJpbmcgb3IgQnVmZmVyIHdpdGggdGhlIGl0cyBsZW5ndGggcHJlZml4XG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gdG9Xcml0ZSAtIFN0cmluZyBvciBCdWZmZXJcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuZnVuY3Rpb24gd3JpdGVTdHJpbmdPckJ1ZmZlciAoc3RyZWFtLCB0b1dyaXRlKSB7XG4gIGlmICh0eXBlb2YgdG9Xcml0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB3cml0ZVN0cmluZyhzdHJlYW0sIHRvV3JpdGUpXG4gIH0gZWxzZSBpZiAodG9Xcml0ZSkge1xuICAgIHdyaXRlTnVtYmVyKHN0cmVhbSwgdG9Xcml0ZS5sZW5ndGgpXG4gICAgc3RyZWFtLndyaXRlKHRvV3JpdGUpXG4gIH0gZWxzZSB3cml0ZU51bWJlcihzdHJlYW0sIDApXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmICghYnVmT3JTdHJpbmcpIHJldHVybiAwXG4gIGVsc2UgaWYgKGJ1Zk9yU3RyaW5nIGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gYnVmT3JTdHJpbmcubGVuZ3RoXG4gIGVsc2UgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJ1Zk9yU3RyaW5nKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ09yQnVmZmVyIChmaWVsZCkge1xuICByZXR1cm4gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyB8fCBmaWVsZCBpbnN0YW5jZW9mIEJ1ZmZlclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlXG4iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpXG52YXIgZW9zID0gcmVxdWlyZSgnZW5kLW9mLXN0cmVhbScpXG52YXIgbXF0dFBhY2tldCA9IHJlcXVpcmUoJ21xdHQtcGFja2V0JylcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLldyaXRhYmxlXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVJbnRlcnZhbCA9IHJlcXVpcmUoJ3JlaW50ZXJ2YWwnKVxudmFyIHZhbGlkYXRpb25zID0gcmVxdWlyZSgnLi92YWxpZGF0aW9ucycpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgc2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgLy8gd29ya3MgaW4gbm9kZSB2MC44XG4gIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spXG59XG52YXIgZGVmYXVsdENvbm5lY3RPcHRpb25zID0ge1xuICBrZWVwYWxpdmU6IDYwLFxuICByZXNjaGVkdWxlUGluZ3M6IHRydWUsXG4gIHByb3RvY29sSWQ6ICdNUVRUJyxcbiAgcHJvdG9jb2xWZXJzaW9uOiA0LFxuICByZWNvbm5lY3RQZXJpb2Q6IDEwMDAsXG4gIGNvbm5lY3RUaW1lb3V0OiAzMCAqIDEwMDAsXG4gIGNsZWFuOiB0cnVlLFxuICByZXN1YnNjcmliZTogdHJ1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0SWQgKCkge1xuICByZXR1cm4gJ21xdHRqc18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc3Vic3RyKDIsIDgpXG59XG5cbmZ1bmN0aW9uIHNlbmRQYWNrZXQgKGNsaWVudCwgcGFja2V0LCBjYikge1xuICBjbGllbnQuZW1pdCgncGFja2V0c2VuZCcsIHBhY2tldClcblxuICB2YXIgcmVzdWx0ID0gbXF0dFBhY2tldC53cml0ZVRvU3RyZWFtKHBhY2tldCwgY2xpZW50LnN0cmVhbSlcblxuICBpZiAoIXJlc3VsdCAmJiBjYikge1xuICAgIGNsaWVudC5zdHJlYW0ub25jZSgnZHJhaW4nLCBjYilcbiAgfSBlbHNlIGlmIChjYikge1xuICAgIGNiKClcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaCAocXVldWUpIHtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgT2JqZWN0LmtleXMocXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgaWYgKHR5cGVvZiBxdWV1ZVttZXNzYWdlSWRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXVlW21lc3NhZ2VJZF0obmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKVxuICAgICAgICBkZWxldGUgcXVldWVbbWVzc2FnZUlkXVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVBbmRTZW5kIChjbGllbnQsIHBhY2tldCwgY2IpIHtcbiAgY2xpZW50Lm91dGdvaW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gc3RvcmVkUGFja2V0IChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IgJiYgY2IoZXJyKVxuICAgIH1cbiAgICBzZW5kUGFja2V0KGNsaWVudCwgcGFja2V0LCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gbm9wICgpIHt9XG5cbi8qKlxuICogTXF0dENsaWVudCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gLSBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIChzZWUgQ29ubmVjdGlvbiNjb25uZWN0KVxuICovXG5mdW5jdGlvbiBNcXR0Q2xpZW50IChzdHJlYW1CdWlsZGVyLCBvcHRpb25zKSB7XG4gIHZhciBrXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNcXR0Q2xpZW50KSkge1xuICAgIHJldHVybiBuZXcgTXF0dENsaWVudChzdHJlYW1CdWlsZGVyLCBvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8vIERlZmF1bHRzXG4gIGZvciAoayBpbiBkZWZhdWx0Q29ubmVjdE9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc1trXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMub3B0aW9uc1trXSA9IGRlZmF1bHRDb25uZWN0T3B0aW9uc1trXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnNba10gPSBvcHRpb25zW2tdXG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcHRpb25zLmNsaWVudElkID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2xpZW50SWQgPT09ICdzdHJpbmcnKSA/IHRoaXMub3B0aW9ucy5jbGllbnRJZCA6IGRlZmF1bHRJZCgpXG5cbiAgdGhpcy5zdHJlYW1CdWlsZGVyID0gc3RyZWFtQnVpbGRlclxuXG4gIC8vIEluZmxpZ2h0IG1lc3NhZ2Ugc3RvcmFnZXNcbiAgdGhpcy5vdXRnb2luZ1N0b3JlID0gdGhpcy5vcHRpb25zLm91dGdvaW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcbiAgdGhpcy5pbmNvbWluZ1N0b3JlID0gdGhpcy5vcHRpb25zLmluY29taW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcblxuICAvLyBTaG91bGQgUW9TIHplcm8gbWVzc2FnZXMgYmUgcXVldWVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgYnJva2VuP1xuICB0aGlzLnF1ZXVlUW9TWmVybyA9IHRoaXMub3B0aW9ucy5xdWV1ZVFvU1plcm8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiB0aGlzLm9wdGlvbnMucXVldWVRb1NaZXJvXG5cbiAgLy8gbWFwIG9mIHN1YnNjcmliZWQgdG9waWNzIHRvIHN1cHBvcnQgcmVjb25uZWN0aW9uXG4gIHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzID0ge31cblxuICAvLyBtYXAgb2YgYSBzdWJzY3JpYmUgbWVzc2FnZUlkIGFuZCBhIHRvcGljXG4gIHRoaXMubWVzc2FnZUlkVG9Ub3BpYyA9IHt9XG5cbiAgLy8gUGluZyB0aW1lciwgc2V0dXAgaW4gX3NldHVwUGluZ1RpbWVyXG4gIHRoaXMucGluZ1RpbWVyID0gbnVsbFxuICAvLyBJcyB0aGUgY2xpZW50IGNvbm5lY3RlZD9cbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAvLyBBcmUgd2UgZGlzY29ubmVjdGluZz9cbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgLy8gUGFja2V0IHF1ZXVlXG4gIHRoaXMucXVldWUgPSBbXVxuICAvLyBjb25uYWNrIHRpbWVyXG4gIHRoaXMuY29ubmFja1RpbWVyID0gbnVsbFxuICAvLyBSZWNvbm5lY3QgdGltZXJcbiAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGxcbiAgLyoqXG4gICAqIE1lc3NhZ2VJRHMgc3RhcnRpbmcgd2l0aCAxXG4gICAqIGVuc3VyZSB0aGF0IG5leHRJZCBpcyBtaW4uIDEsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXF0dGpzL01RVFQuanMvaXNzdWVzLzgxMFxuICAgKi9cbiAgdGhpcy5uZXh0SWQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NTUzNSkpXG5cbiAgLy8gSW5mbGlnaHQgY2FsbGJhY2tzXG4gIHRoaXMub3V0Z29pbmcgPSB7fVxuXG4gIC8vIE1hcmsgY29ubmVjdGVkIG9uIGNvbm5lY3RcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZVxuICAgIHZhciBvdXRTdG9yZSA9IHRoaXMub3V0Z29pbmdTdG9yZS5jcmVhdGVTdHJlYW0oKVxuXG4gICAgdGhpcy5vbmNlKCdjbG9zZScsIHJlbW92ZSlcbiAgICBvdXRTdG9yZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCByZW1vdmUpXG4gICAgfSlcbiAgICBvdXRTdG9yZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcbiAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBvdXRTdG9yZS5kZXN0cm95KClcbiAgICAgIG91dFN0b3JlID0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3JlRGVsaXZlciAoKSB7XG4gICAgICAvLyBlZGdlIGNhc2UsIHdlIHdyYXBwZWQgdGhpcyB0d2ljZVxuICAgICAgaWYgKCFvdXRTdG9yZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIHBhY2tldCA9IG91dFN0b3JlLnJlYWQoMSlcbiAgICAgIHZhciBjYlxuXG4gICAgICBpZiAoIXBhY2tldCkge1xuICAgICAgICAvLyByZWFkIHdoZW4gZGF0YSBpcyBhdmFpbGFibGUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBvdXRTdG9yZS5vbmNlKCdyZWFkYWJsZScsIHN0b3JlRGVsaXZlcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IHN0cmVhbSByZWFkIG9wZXJhdGlvbnMgd2hlbiBkaXNjb25uZWN0ZWRcbiAgICAgIGlmICghdGhhdC5kaXNjb25uZWN0aW5nICYmICF0aGF0LnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgIGNiID0gdGhhdC5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXVxuICAgICAgICB0aGF0Lm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gZnVuY3Rpb24gKGVyciwgc3RhdHVzKSB7XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIHBhc3NlZCBpbiB0byBwdWJsaXNoIGdldHMgaW52b2tlZFxuICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoZXJyLCBzdGF0dXMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RvcmVEZWxpdmVyKClcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHBhY2tldClcbiAgICAgIH0gZWxzZSBpZiAob3V0U3RvcmUuZGVzdHJveSkge1xuICAgICAgICBvdXRTdG9yZS5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdGFydCBmbG93aW5nXG4gICAgc3RvcmVEZWxpdmVyKClcbiAgfSlcblxuICAvLyBNYXJrIGRpc2Nvbm5lY3RlZCBvbiBzdHJlYW0gY2xvc2VcbiAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcbiAgfSlcblxuICAvLyBTZXR1cCBwaW5nIHRpbWVyXG4gIHRoaXMub24oJ2Nvbm5lY3QnLCB0aGlzLl9zZXR1cFBpbmdUaW1lcilcblxuICAvLyBTZW5kIHF1ZXVlZCBwYWNrZXRzXG4gIHRoaXMub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZVxuXG4gICAgZnVuY3Rpb24gZGVsaXZlciAoKSB7XG4gICAgICB2YXIgZW50cnkgPSBxdWV1ZS5zaGlmdCgpXG4gICAgICB2YXIgcGFja2V0ID0gbnVsbFxuXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBwYWNrZXQgPSBlbnRyeS5wYWNrZXRcblxuICAgICAgdGhhdC5fc2VuZFBhY2tldChcbiAgICAgICAgcGFja2V0LFxuICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmNiKSB7XG4gICAgICAgICAgICBlbnRyeS5jYihlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGl2ZXIoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgZGVsaXZlcigpXG4gIH0pXG5cbiAgdmFyIGZpcnN0Q29ubmVjdGlvbiA9IHRydWVcbiAgLy8gcmVzdWJzY3JpYmVcbiAgdGhpcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWZpcnN0Q29ubmVjdGlvbiAmJlxuICAgICAgICB0aGlzLm9wdGlvbnMuY2xlYW4gJiZcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MucmVzdWJzY3JpYmUgPSB0cnVlXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MgPSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q29ubmVjdGlvbiA9IGZhbHNlXG4gIH0pXG5cbiAgLy8gQ2xlYXIgcGluZyB0aW1lclxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhhdC5waW5nVGltZXIgIT09IG51bGwpIHtcbiAgICAgIHRoYXQucGluZ1RpbWVyLmNsZWFyKClcbiAgICAgIHRoYXQucGluZ1RpbWVyID0gbnVsbFxuICAgIH1cbiAgfSlcblxuICAvLyBTZXR1cCByZWNvbm5lY3QgdGltZXIgb24gZGlzY29ubmVjdFxuICB0aGlzLm9uKCdjbG9zZScsIHRoaXMuX3NldHVwUmVjb25uZWN0KVxuXG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuXG4gIHRoaXMuX3NldHVwU3RyZWFtKClcbn1cbmluaGVyaXRzKE1xdHRDbGllbnQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cbi8qKlxuICogc2V0dXAgdGhlIGV2ZW50IGhhbmRsZXJzIGluIHRoZSBpbm5lciBzdHJlYW0uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbm5lY3RQYWNrZXRcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciB3cml0YWJsZSA9IG5ldyBXcml0YWJsZSgpXG4gIHZhciBwYXJzZXIgPSBtcXR0UGFja2V0LnBhcnNlcih0aGlzLm9wdGlvbnMpXG4gIHZhciBjb21wbGV0ZVBhcnNlID0gbnVsbFxuICB2YXIgcGFja2V0cyA9IFtdXG5cbiAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuXG4gIHRoaXMuc3RyZWFtID0gdGhpcy5zdHJlYW1CdWlsZGVyKHRoaXMpXG5cbiAgcGFyc2VyLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgcGFja2V0cy5wdXNoKHBhY2tldClcbiAgfSlcblxuICBmdW5jdGlvbiBuZXh0VGlja1dvcmsgKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sod29yaylcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmsgKCkge1xuICAgIHZhciBwYWNrZXQgPSBwYWNrZXRzLnNoaWZ0KClcbiAgICB2YXIgZG9uZSA9IGNvbXBsZXRlUGFyc2VcblxuICAgIGlmIChwYWNrZXQpIHtcbiAgICAgIHRoYXQuX2hhbmRsZVBhY2tldChwYWNrZXQsIG5leHRUaWNrV29yaylcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGVQYXJzZSA9IG51bGxcbiAgICAgIGRvbmUoKVxuICAgIH1cbiAgfVxuXG4gIHdyaXRhYmxlLl93cml0ZSA9IGZ1bmN0aW9uIChidWYsIGVuYywgZG9uZSkge1xuICAgIGNvbXBsZXRlUGFyc2UgPSBkb25lXG4gICAgcGFyc2VyLnBhcnNlKGJ1ZilcbiAgICB3b3JrKClcbiAgfVxuXG4gIHRoaXMuc3RyZWFtLnBpcGUod3JpdGFibGUpXG5cbiAgLy8gU3VwcHJlc3MgY29ubmVjdGlvbiBlcnJvcnNcbiAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgbm9wKVxuXG4gIC8vIEVjaG8gc3RyZWFtIGNsb3NlXG4gIGVvcyh0aGlzLnN0cmVhbSwgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nsb3NlJykpXG5cbiAgLy8gU2VuZCBhIGNvbm5lY3QgcGFja2V0XG4gIGNvbm5lY3RQYWNrZXQgPSBPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucylcbiAgY29ubmVjdFBhY2tldC5jbWQgPSAnY29ubmVjdCdcbiAgLy8gYXZvaWQgbWVzc2FnZSBxdWV1ZVxuICBzZW5kUGFja2V0KHRoaXMsIGNvbm5lY3RQYWNrZXQpXG5cbiAgLy8gRWNobyBjb25uZWN0aW9uIGVycm9yc1xuICBwYXJzZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpXG5cbiAgLy8gbWFueSBkcmFpbiBsaXN0ZW5lcnMgYXJlIG5lZWRlZCBmb3IgcW9zIDEgY2FsbGJhY2tzIGlmIHRoZSBjb25uZWN0aW9uIGlzIGludGVybWl0dGVudFxuICB0aGlzLnN0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoMTAwMClcblxuICBjbGVhclRpbWVvdXQodGhpcy5jb25uYWNrVGltZXIpXG4gIHRoaXMuY29ubmFja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5fY2xlYW5VcCh0cnVlKVxuICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdFRpbWVvdXQpXG59XG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBkb25lKSB7XG4gIHRoaXMuZW1pdCgncGFja2V0cmVjZWl2ZScsIHBhY2tldClcblxuICBzd2l0Y2ggKHBhY2tldC5jbWQpIHtcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHRoaXMuX2hhbmRsZVB1Ymxpc2gocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJhY2snOlxuICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgY2FzZSAnc3ViYWNrJzpcbiAgICBjYXNlICd1bnN1YmFjayc6XG4gICAgICB0aGlzLl9oYW5kbGVBY2socGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YnJlbCc6XG4gICAgICB0aGlzLl9oYW5kbGVQdWJyZWwocGFja2V0LCBkb25lKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdjb25uYWNrJzpcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5hY2socGFja2V0KVxuICAgICAgZG9uZSgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIHRoaXMuX2hhbmRsZVBpbmdyZXNwKHBhY2tldClcbiAgICAgIGRvbmUoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIGRvIGFuIGVycm9yIGhhbmRsaW5nXG4gICAgICAvLyBvciBqdXN0IGxvZyBpdFxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2hlY2tEaXNjb25uZWN0aW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignY2xpZW50IGRpc2Nvbm5lY3RpbmcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignY2xpZW50IGRpc2Nvbm5lY3RpbmcnKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdGluZ1xufVxuXG4vKipcbiAqIHB1Ymxpc2ggLSBwdWJsaXNoIDxtZXNzYWdlPiB0byA8dG9waWM+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIC0gdG9waWMgdG8gcHVibGlzaCB0b1xuICogQHBhcmFtIHtTdHJpbmcsIEJ1ZmZlcn0gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gcHVibGlzaFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIHB1Ymxpc2ggb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7TnVtYmVyfSBxb3MgLSBxb3MgbGV2ZWwgdG8gcHVibGlzaCBvblxuICogICAge0Jvb2xlYW59IHJldGFpbiAtIHdoZXRoZXIgb3Igbm90IHRvIHJldGFpbiB0aGUgbWVzc2FnZVxuICogICAge0Jvb2xlYW59IGR1cCAtIHdoZXRoZXIgb3Igbm90IG1hcmsgYSBtZXNzYWdlIGFzIGR1cGxpY2F0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGZ1bmN0aW9uKGVycil7fVxuICogICAgY2FsbGVkIHdoZW4gcHVibGlzaCBzdWNjZWVkcyBvciBmYWlsc1xuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKlxuICogQGV4YW1wbGUgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnKTtcbiAqIEBleGFtcGxlXG4gKiAgICAgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnLCB7cW9zOiAxLCByZXRhaW46IHRydWUsIGR1cDogdHJ1ZX0pO1xuICogQGV4YW1wbGUgY2xpZW50LnB1Ymxpc2goJ3RvcGljJywgJ21lc3NhZ2UnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWMsIG1lc3NhZ2UsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYWNrZXRcblxuICAvLyAucHVibGlzaCh0b3BpYywgcGF5bG9hZCwgY2IpO1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHNcbiAgICBvcHRzID0gbnVsbFxuICB9XG5cbiAgLy8gZGVmYXVsdCBvcHRzXG4gIHZhciBkZWZhdWx0T3B0cyA9IHtxb3M6IDAsIHJldGFpbjogZmFsc2UsIGR1cDogZmFsc2V9XG4gIG9wdHMgPSB4dGVuZChkZWZhdWx0T3B0cywgb3B0cylcblxuICBpZiAodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwYWNrZXQgPSB7XG4gICAgY21kOiAncHVibGlzaCcsXG4gICAgdG9waWM6IHRvcGljLFxuICAgIHBheWxvYWQ6IG1lc3NhZ2UsXG4gICAgcW9zOiBvcHRzLnFvcyxcbiAgICByZXRhaW46IG9wdHMucmV0YWluLFxuICAgIG1lc3NhZ2VJZDogdGhpcy5fbmV4dElkKCksXG4gICAgZHVwOiBvcHRzLmR1cFxuICB9XG5cbiAgc3dpdGNoIChvcHRzLnFvcykge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDI6XG5cbiAgICAgIC8vIEFkZCB0byBjYWxsYmFja3NcbiAgICAgIHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSBjYWxsYmFjayB8fCBub3BcbiAgICAgIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0KVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogc3Vic2NyaWJlIC0gc3Vic2NyaWJlIHRvIDx0b3BpYz5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZywgQXJyYXksIE9iamVjdH0gdG9waWMgLSB0b3BpYyhzKSB0byBzdWJzY3JpYmUgdG8sIHN1cHBvcnRzIG9iamVjdHMgaW4gdGhlIGZvcm0geyd0b3BpYyc6IHFvc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25hbCBzdWJzY3JpcHRpb24gb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7TnVtYmVyfSBxb3MgLSBzdWJzY3JpYmUgcW9zIGxldmVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gZnVuY3Rpb24oZXJyLCBncmFudGVkKXt9IHdoZXJlOlxuICogICAge0Vycm9yfSBlcnIgLSBzdWJzY3JpcHRpb24gZXJyb3IgKG5vbmUgYXQgdGhlIG1vbWVudCEpXG4gKiAgICB7QXJyYXl9IGdyYW50ZWQgLSBhcnJheSBvZiB7dG9waWM6ICd0JywgcW9zOiAwfVxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycpO1xuICogQGV4YW1wbGUgY2xpZW50LnN1YnNjcmliZSgndG9waWMnLCB7cW9zOiAxfSk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKHsndG9waWMnOiAwLCAndG9waWMyJzogMX0sIGNvbnNvbGUubG9nKTtcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoJ3RvcGljJywgY29uc29sZS5sb2cpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXRcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBzdWJzID0gW11cbiAgdmFyIG9iaiA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgcmVzdWJzY3JpYmUgPSBvYmoucmVzdWJzY3JpYmVcbiAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKSB8fCBub3BcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXG4gIHZhciBpbnZhbGlkVG9waWNcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgZGVsZXRlIG9iai5yZXN1YnNjcmliZVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIG9iaiA9IFtvYmpdXG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IGNhbGxiYWNrXG4gICAgY2FsbGJhY2sgPSBub3BcbiAgfVxuXG4gIGludmFsaWRUb3BpYyA9IHZhbGlkYXRpb25zLnZhbGlkYXRlVG9waWNzKG9iailcbiAgaWYgKGludmFsaWRUb3BpYyAhPT0gbnVsbCkge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjaywgbmV3IEVycm9yKCdJbnZhbGlkIHRvcGljICcgKyBpbnZhbGlkVG9waWMpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpZiAodGhpcy5fY2hlY2tEaXNjb25uZWN0aW5nKGNhbGxiYWNrKSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgZGVmYXVsdE9wdHMgPSB7IHFvczogMCB9XG4gIG9wdHMgPSB4dGVuZChkZWZhdWx0T3B0cywgb3B0cylcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICBpZiAodGhhdC5fcmVzdWJzY3JpYmVUb3BpY3NbdG9waWNdIDwgb3B0cy5xb3MgfHxcbiAgICAgICAgICAhdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3MuaGFzT3duUHJvcGVydHkodG9waWMpIHx8XG4gICAgICAgICAgcmVzdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vicy5wdXNoKHtcbiAgICAgICAgICB0b3BpYzogdG9waWMsXG4gICAgICAgICAgcW9zOiBvcHRzLnFvc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0XG4gICAgICAua2V5cyhvYmopXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAodGhhdC5fcmVzdWJzY3JpYmVUb3BpY3Nba10gPCBvYmpba10gfHxcbiAgICAgICAgICAgICF0aGF0Ll9yZXN1YnNjcmliZVRvcGljcy5oYXNPd25Qcm9wZXJ0eShrKSB8fFxuICAgICAgICAgICAgcmVzdWJzY3JpYmUpIHtcbiAgICAgICAgICBzdWJzLnB1c2goe1xuICAgICAgICAgICAgdG9waWM6IGssXG4gICAgICAgICAgICBxb3M6IG9ialtrXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBwYWNrZXQgPSB7XG4gICAgY21kOiAnc3Vic2NyaWJlJyxcbiAgICBzdWJzY3JpcHRpb25zOiBzdWJzLFxuICAgIHFvczogMSxcbiAgICByZXRhaW46IGZhbHNlLFxuICAgIGR1cDogZmFsc2UsXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxuICB9XG5cbiAgaWYgKCFzdWJzLmxlbmd0aCkge1xuICAgIGNhbGxiYWNrKG51bGwsIFtdKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3Vic2NyaXB0aW9ucyB0byByZXN1YnNjcmliZSB0byBpbiBjYXNlIG9mIGRpc2Nvbm5lY3RcbiAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xuICAgIHZhciB0b3BpY3MgPSBbXVxuICAgIHN1YnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICBpZiAodGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCA+IDApIHtcbiAgICAgICAgdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3Nbc3ViLnRvcGljXSA9IHN1Yi5xb3NcbiAgICAgICAgdG9waWNzLnB1c2goc3ViLnRvcGljKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhhdC5tZXNzYWdlSWRUb1RvcGljW3BhY2tldC5tZXNzYWdlSWRdID0gdG9waWNzXG4gIH1cblxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gZnVuY3Rpb24gKGVyciwgcGFja2V0KSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHZhciBncmFudGVkID0gcGFja2V0LmdyYW50ZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdWJzW2ldLnFvcyA9IGdyYW50ZWRbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnIsIHN1YnMpXG4gIH1cblxuICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldClcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHVuc3Vic2NyaWJlIC0gdW5zdWJzY3JpYmUgZnJvbSB0b3BpYyhzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheX0gdG9waWMgLSB0b3BpY3MgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxiYWNrIGZpcmVkIG9uIHVuc3ViYWNrXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnKTtcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRvcGljLCBjYWxsYmFjaykge1xuICB2YXIgcGFja2V0ID0ge1xuICAgIGNtZDogJ3Vuc3Vic2NyaWJlJyxcbiAgICBxb3M6IDEsXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxuICB9XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9wXG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gW3RvcGljXVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ29iamVjdCcgJiYgdG9waWMubGVuZ3RoKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IHRvcGljXG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgZGVsZXRlIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXVxuICAgIH0pXG4gIH1cblxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gY2FsbGJhY2tcblxuICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldClcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIGVuZCAtIGNsb3NlIGNvbm5lY3Rpb25cbiAqXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSAtIGRvIG5vdCB3YWl0IGZvciBhbGwgaW4tZmxpZ2h0IG1lc3NhZ2VzIHRvIGJlIGFja2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxlZCB3aGVuIHRoZSBjbGllbnQgaGFzIGJlZW4gY2xvc2VkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGZvcmNlLCBjYikge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAodHlwZW9mIGZvcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBmb3JjZVxuICAgIGZvcmNlID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlU3RvcmVzICgpIHtcbiAgICB0aGF0LmRpc2Nvbm5lY3RlZCA9IHRydWVcbiAgICB0aGF0LmluY29taW5nU3RvcmUuY2xvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5vdXRnb2luZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuZW1pdCgnZW5kJylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBpZiAodGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QpIHtcbiAgICAgIHRoYXQuX2RlZmVycmVkUmVjb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIC8vIGRlZmVyIGNsb3Nlc1N0b3JlcyBvZiBhbiBJL08gY3ljbGUsXG4gICAgLy8ganVzdCB0byBtYWtlIHN1cmUgdGhpbmdzIGFyZVxuICAgIC8vIG9rIGZvciB3ZWJzb2NrZXRzXG4gICAgdGhhdC5fY2xlYW5VcChmb3JjZSwgc2V0SW1tZWRpYXRlLmJpbmQobnVsbCwgY2xvc2VTdG9yZXMpKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG5cbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gdHJ1ZVxuXG4gIGlmICghZm9yY2UgJiYgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID4gMCkge1xuICAgIC8vIHdhaXQgMTBtcywganVzdCB0byBiZSBzdXJlIHdlIHJlY2VpdmVkIGFsbCBvZiBpdFxuICAgIHRoaXMub25jZSgnb3V0Z29pbmdFbXB0eScsIHNldFRpbWVvdXQuYmluZChudWxsLCBmaW5pc2gsIDEwKSlcbiAgfSBlbHNlIHtcbiAgICBmaW5pc2goKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiByZW1vdmVPdXRnb2luZ01lc3NhZ2UgLSByZW1vdmUgYSBtZXNzYWdlIGluIG91dGdvaW5nIHN0b3JlXG4gKiB0aGUgb3V0Z29pbmcgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aGUgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpIGlmIHRoZSBtZXNzYWdlIGlzIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWlkIC0gbWVzc2FnZUlkIHRvIHJlbW92ZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlT3V0Z29pbmdNZXNzYWdlKGNsaWVudC5nZXRMYXN0TWVzc2FnZUlkKCkpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5yZW1vdmVPdXRnb2luZ01lc3NhZ2UgPSBmdW5jdGlvbiAobWlkKSB7XG4gIHZhciBjYiA9IHRoaXMub3V0Z29pbmdbbWlkXVxuICBkZWxldGUgdGhpcy5vdXRnb2luZ1ttaWRdXG4gIHRoaXMub3V0Z29pbmdTdG9yZS5kZWwoe21lc3NhZ2VJZDogbWlkfSwgZnVuY3Rpb24gKCkge1xuICAgIGNiKG5ldyBFcnJvcignTWVzc2FnZSByZW1vdmVkJykpXG4gIH0pXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogcmVjb25uZWN0IC0gY29ubmVjdCBhZ2FpbiB1c2luZyB0aGUgc2FtZSBvcHRpb25zIGFzIGNvbm5lY3QoKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBvcHRpb25hbCByZWNvbm5lY3Qgb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7U3RvcmV9IGluY29taW5nU3RvcmUgLSBhIHN0b3JlIGZvciB0aGUgaW5jb21pbmcgcGFja2V0c1xuICogICAge1N0b3JlfSBvdXRnb2luZ1N0b3JlIC0gYSBzdG9yZSBmb3IgdGhlIG91dGdvaW5nIHBhY2tldHNcbiAqICAgIGlmIG9wdHMgaXMgbm90IGdpdmVuLCBjdXJyZW50IHN0b3JlcyBhcmUgdXNlZFxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlID0gb3B0cy5pbmNvbWluZ1N0b3JlXG4gICAgICB0aGF0Lm9wdGlvbnMub3V0Z29pbmdTdG9yZSA9IG9wdHMub3V0Z29pbmdTdG9yZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSA9IG51bGxcbiAgICAgIHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlID0gbnVsbFxuICAgIH1cbiAgICB0aGF0LmluY29taW5nU3RvcmUgPSB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuICAgIHRoYXQub3V0Z29pbmdTdG9yZSA9IHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG4gICAgdGhhdC5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGF0LmRpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QgPSBudWxsXG4gICAgdGhhdC5fcmVjb25uZWN0KClcbiAgfVxuXG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiYgIXRoaXMuZGlzY29ubmVjdGVkKSB7XG4gICAgdGhpcy5fZGVmZXJyZWRSZWNvbm5lY3QgPSBmXG4gIH0gZWxzZSB7XG4gICAgZigpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBfcmVjb25uZWN0IC0gaW1wbGVtZW50IHJlY29ubmVjdGlvblxuICogQGFwaSBwcml2YXRlaXNoXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgncmVjb25uZWN0JylcbiAgdGhpcy5fc2V0dXBTdHJlYW0oKVxufVxuXG4vKipcbiAqIF9zZXR1cFJlY29ubmVjdCAtIHNldHVwIHJlY29ubmVjdCB0aW1lclxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2V0dXBSZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGlmICghdGhhdC5kaXNjb25uZWN0aW5nICYmICF0aGF0LnJlY29ubmVjdFRpbWVyICYmICh0aGF0Lm9wdGlvbnMucmVjb25uZWN0UGVyaW9kID4gMCkpIHtcbiAgICBpZiAoIXRoaXMucmVjb25uZWN0aW5nKSB7XG4gICAgICB0aGlzLmVtaXQoJ29mZmxpbmUnKVxuICAgICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlXG4gICAgfVxuICAgIHRoYXQucmVjb25uZWN0VGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Ll9yZWNvbm5lY3QoKVxuICAgIH0sIHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QpXG4gIH1cbn1cblxuLyoqXG4gKiBfY2xlYXJSZWNvbm5lY3QgLSBjbGVhciB0aGUgcmVjb25uZWN0IHRpbWVyXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9jbGVhclJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMucmVjb25uZWN0VGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIF9jbGVhblVwIC0gY2xlYW4gdXAgb24gY29ubmVjdGlvbiBlbmRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2xlYW5VcCA9IGZ1bmN0aW9uIChmb3JjZWQsIGRvbmUpIHtcbiAgaWYgKGRvbmUpIHtcbiAgICB0aGlzLnN0cmVhbS5vbignY2xvc2UnLCBkb25lKVxuICB9XG5cbiAgaWYgKGZvcmNlZCkge1xuICAgIGlmICgodGhpcy5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCA9PT0gMCkgJiYgdGhpcy5vcHRpb25zLmNsZWFuKSB7XG4gICAgICBmbHVzaCh0aGlzLm91dGdvaW5nKVxuICAgIH1cbiAgICB0aGlzLnN0cmVhbS5kZXN0cm95KClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zZW5kUGFja2V0KFxuICAgICAgeyBjbWQ6ICdkaXNjb25uZWN0JyB9LFxuICAgICAgc2V0SW1tZWRpYXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMuc3RyZWFtLmVuZC5iaW5kKHRoaXMuc3RyZWFtKVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIGlmICghdGhpcy5kaXNjb25uZWN0aW5nKSB7XG4gICAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuICAgIHRoaXMuX3NldHVwUmVjb25uZWN0KClcbiAgfVxuXG4gIGlmICh0aGlzLnBpbmdUaW1lciAhPT0gbnVsbCkge1xuICAgIHRoaXMucGluZ1RpbWVyLmNsZWFyKClcbiAgICB0aGlzLnBpbmdUaW1lciA9IG51bGxcbiAgfVxuXG4gIGlmIChkb25lICYmICF0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMuc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGRvbmUpXG4gICAgZG9uZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBfc2VuZFBhY2tldCAtIHNlbmQgb3IgcXVldWUgYSBwYWNrZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGUgKHNlZSBgcHJvdG9jb2xgKVxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHBhY2tldCBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHdoZW4gdGhlIHBhY2tldCBpcyBzZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NlbmRQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgaWYgKCgocGFja2V0LnFvcyB8fCAwKSA9PT0gMCAmJiB0aGlzLnF1ZXVlUW9TWmVybykgfHwgcGFja2V0LmNtZCAhPT0gJ3B1Ymxpc2gnKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goeyBwYWNrZXQ6IHBhY2tldCwgY2I6IGNiIH0pXG4gICAgfSBlbHNlIGlmIChwYWNrZXQucW9zID4gMCkge1xuICAgICAgY2IgPSB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdXG4gICAgICB0aGlzLm91dGdvaW5nU3RvcmUucHV0KHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiICYmIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihuZXcgRXJyb3IoJ05vIGNvbm5lY3Rpb24gdG8gYnJva2VyJykpXG4gICAgfVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBXaGVuIHNlbmRpbmcgYSBwYWNrZXQsIHJlc2NoZWR1bGUgdGhlIHBpbmcgdGltZXJcbiAgdGhpcy5fc2hpZnRQaW5nSW50ZXJ2YWwoKVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICByZXR1cm5cbiAgICBkZWZhdWx0OlxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBwYWNrZXQsIGNiKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKHBhY2tldC5xb3MpIHtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAxOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICBicmVha1xuICAgIC8qKlxuICAgICAqIG5vIG5lZWQgb2YgY2FzZSBoZXJlIHNpbmNlIGl0IHdpbGwgYmUgY2F1Z2h0IGJ5IGRlZmF1bHRcbiAgICAgKiBhbmQganNoaW50IGNvbXBseSB0aGF0IGJlZm9yZSBkZWZhdWx0IGl0IG11c3QgYmUgYSBicmVha1xuICAgICAqIGFueXdheSBpdCB3aWxsIHJlc3VsdCBpbiAtMSBldmFsdWF0aW9uXG4gICAgICovXG4gICAgY2FzZSAwOlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICBicmVha1xuICB9XG59XG5cbi8qKlxuICogX3NldHVwUGluZ1RpbWVyIC0gc2V0dXAgdGhlIHBpbmcgdGltZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwUGluZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAoIXRoaXMucGluZ1RpbWVyICYmIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUpIHtcbiAgICB0aGlzLnBpbmdSZXNwID0gdHJ1ZVxuICAgIHRoaXMucGluZ1RpbWVyID0gcmVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Ll9jaGVja1BpbmcoKVxuICAgIH0sIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG5cbi8qKlxuICogX3NoaWZ0UGluZ0ludGVydmFsIC0gcmVzY2hlZHVsZSB0aGUgcGluZyBpbnRlcnZhbFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2hpZnRQaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBpbmdUaW1lciAmJiB0aGlzLm9wdGlvbnMua2VlcGFsaXZlICYmIHRoaXMub3B0aW9ucy5yZXNjaGVkdWxlUGluZ3MpIHtcbiAgICB0aGlzLnBpbmdUaW1lci5yZXNjaGVkdWxlKHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG4vKipcbiAqIF9jaGVja1BpbmcgLSBjaGVjayBpZiBhIHBpbmdyZXNwIGhhcyBjb21lIGJhY2ssIGFuZCBwaW5nIHRoZSBzZXJ2ZXIgYWdhaW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NoZWNrUGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGluZ1Jlc3ApIHtcbiAgICB0aGlzLnBpbmdSZXNwID0gZmFsc2VcbiAgICB0aGlzLl9zZW5kUGFja2V0KHsgY21kOiAncGluZ3JlcScgfSlcbiAgfSBlbHNlIHtcbiAgICAvLyBkbyBhIGZvcmNlZCBjbGVhbnVwIHNpbmNlIHNvY2tldCB3aWxsIGJlIGluIGJhZCBzaGFwZVxuICAgIHRoaXMuX2NsZWFuVXAodHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQaW5ncmVzcCAtIGhhbmRsZSBhIHBpbmdyZXNwXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQaW5ncmVzcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5waW5nUmVzcCA9IHRydWVcbn1cblxuLyoqXG4gKiBfaGFuZGxlQ29ubmFja1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVDb25uYWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgcmMgPSBwYWNrZXQucmV0dXJuQ29kZVxuICB2YXIgZXJyb3JzID0gW1xuICAgICcnLFxuICAgICdVbmFjY2VwdGFibGUgcHJvdG9jb2wgdmVyc2lvbicsXG4gICAgJ0lkZW50aWZpZXIgcmVqZWN0ZWQnLFxuICAgICdTZXJ2ZXIgdW5hdmFpbGFibGUnLFxuICAgICdCYWQgdXNlcm5hbWUgb3IgcGFzc3dvcmQnLFxuICAgICdOb3QgYXV0aG9yaXplZCdcbiAgXVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcblxuICBpZiAocmMgPT09IDApIHtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5lbWl0KCdjb25uZWN0JywgcGFja2V0KVxuICB9IGVsc2UgaWYgKHJjID4gMCkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gcmVmdXNlZDogJyArIGVycm9yc1tyY10pXG4gICAgZXJyLmNvZGUgPSByY1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbn1cblxuLyoqXG4gKiBfaGFuZGxlUHVibGlzaFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG4vKlxudGhvc2UgbGF0ZSAyIGNhc2Ugc2hvdWxkIGJlIHJld3JpdGUgdG8gY29tcGx5IHdpdGggY29kaW5nIHN0eWxlOlxuXG5jYXNlIDE6XG5jYXNlIDA6XG4gIC8vIGRvIG5vdCB3YWl0IHNlbmRpbmcgYSBwdWJhY2tcbiAgLy8gbm8gY2FsbGJhY2sgcGFzc2VkXG4gIGlmICgxID09PSBxb3MpIHtcbiAgICB0aGlzLl9zZW5kUGFja2V0KHtcbiAgICAgIGNtZDogJ3B1YmFjaycsXG4gICAgICBtZXNzYWdlSWQ6IG1pZFxuICAgIH0pO1xuICB9XG4gIC8vIGVtaXQgdGhlIG1lc3NhZ2UgZXZlbnQgZm9yIGJvdGggcW9zIDEgYW5kIDBcbiAgdGhpcy5lbWl0KCdtZXNzYWdlJywgdG9waWMsIG1lc3NhZ2UsIHBhY2tldCk7XG4gIHRoaXMuaGFuZGxlTWVzc2FnZShwYWNrZXQsIGRvbmUpO1xuICBicmVhaztcbmRlZmF1bHQ6XG4gIC8vIGRvIG5vdGhpbmcgYnV0IGV2ZXJ5IHN3aXRjaCBtdXMgaGF2ZSBhIGRlZmF1bHRcbiAgLy8gbG9nIG9yIHRocm93IGFuIGVycm9yIGFib3V0IHVua25vd24gcW9zXG4gIGJyZWFrO1xuXG5mb3Igbm93IGkganVzdCBzdXBwcmVzc2VkIHRoZSB3YXJuaW5nc1xuKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQdWJsaXNoID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xuICBkb25lID0gdHlwZW9mIGRvbmUgIT09ICd1bmRlZmluZWQnID8gZG9uZSA6IG5vcFxuICB2YXIgdG9waWMgPSBwYWNrZXQudG9waWMudG9TdHJpbmcoKVxuICB2YXIgbWVzc2FnZSA9IHBhY2tldC5wYXlsb2FkXG4gIHZhciBxb3MgPSBwYWNrZXQucW9zXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHN3aXRjaCAocW9zKSB7XG4gICAgY2FzZSAyOlxuICAgICAgdGhpcy5pbmNvbWluZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBkb25lKGVycilcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHtjbWQ6ICdwdWJyZWMnLCBtZXNzYWdlSWQ6IG1pZH0sIGRvbmUpXG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDE6XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KVxuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKHBhY2tldCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKVxuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgJ3B1YmFjaycgaWYgdGhlIGFib3ZlICdoYW5kbGVNZXNzYWdlJyBtZXRob2QgZXhlY3V0ZWRcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHtjbWQ6ICdwdWJhY2snLCBtZXNzYWdlSWQ6IG1pZH0sIGRvbmUpXG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KVxuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKHBhY2tldCwgZG9uZSlcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xuICAgICAgYnJlYWtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBtZXNzYWdlcyB3aXRoIGJhY2twcmVzc3VyZSBzdXBwb3J0LCBvbmUgYXQgYSB0aW1lLlxuICogT3ZlcnJpZGUgYXQgd2lsbC5cbiAqXG4gKiBAcGFyYW0gUGFja2V0IHBhY2tldCB0aGUgcGFja2V0XG4gKiBAcGFyYW0gRnVuY3Rpb24gY2FsbGJhY2sgY2FsbCB3aGVuIGZpbmlzaGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKVxufVxuXG4vKipcbiAqIF9oYW5kbGVBY2tcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgdmFyIG1pZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHR5cGUgPSBwYWNrZXQuY21kXG4gIHZhciByZXNwb25zZSA9IG51bGxcbiAgdmFyIGNiID0gdGhpcy5vdXRnb2luZ1ttaWRdXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIGlmICghY2IpIHtcbiAgICAvLyBTZXJ2ZXIgc2VudCBhbiBhY2sgaW4gZXJyb3IsIGlnbm9yZSBpdC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFByb2Nlc3NcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgICAvLyBzYW1lIHRoaW5nIGFzIHB1YmFjayBmb3IgUW9TIDJcbiAgICBjYXNlICdwdWJhY2snOlxuICAgICAgLy8gQ2FsbGJhY2sgLSB3ZSdyZSBkb25lXG4gICAgICBkZWxldGUgdGhpcy5vdXRnb2luZ1ttaWRdXG4gICAgICB0aGlzLm91dGdvaW5nU3RvcmUuZGVsKHBhY2tldCwgY2IpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3B1YnJlYyc6XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgY21kOiAncHVicmVsJyxcbiAgICAgICAgcW9zOiAyLFxuICAgICAgICBtZXNzYWdlSWQ6IG1pZFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZW5kUGFja2V0KHJlc3BvbnNlKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICAgICAgaWYgKHBhY2tldC5ncmFudGVkLmxlbmd0aCA9PT0gMSAmJiAocGFja2V0LmdyYW50ZWRbMF0gJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAvLyBzdWJhY2sgd2l0aCBGYWlsdXJlIHN0YXR1c1xuICAgICAgICB2YXIgdG9waWNzID0gdGhpcy5tZXNzYWdlSWRUb1RvcGljW21pZF1cbiAgICAgICAgaWYgKHRvcGljcykge1xuICAgICAgICAgIHRvcGljcy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgICAgICAgZGVsZXRlIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNiKG51bGwsIHBhY2tldClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWlkXVxuICAgICAgY2IobnVsbClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBwYWNrZXQgdHlwZScpKVxuICB9XG5cbiAgaWYgKHRoaXMuZGlzY29ubmVjdGluZyAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdvdXRnb2luZ0VtcHR5JylcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQdWJyZWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2hhbmRsZVB1YnJlbCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogbm9wXG4gIHZhciBtaWQgPSBwYWNrZXQubWVzc2FnZUlkXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHZhciBjb21wID0ge2NtZDogJ3B1YmNvbXAnLCBtZXNzYWdlSWQ6IG1pZH1cblxuICB0aGF0LmluY29taW5nU3RvcmUuZ2V0KHBhY2tldCwgZnVuY3Rpb24gKGVyciwgcHViKSB7XG4gICAgaWYgKCFlcnIgJiYgcHViLmNtZCAhPT0gJ3B1YnJlbCcpIHtcbiAgICAgIHRoYXQuZW1pdCgnbWVzc2FnZScsIHB1Yi50b3BpYywgcHViLnBheWxvYWQsIHB1YilcbiAgICAgIHRoYXQuaW5jb21pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRoYXQuaGFuZGxlTWVzc2FnZShwdWIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KGNvbXAsIGNhbGxiYWNrKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fc2VuZFBhY2tldChjb21wLCBjYWxsYmFjaylcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogX25leHRJZFxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX25leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaWQgYmVjb21lcyBjdXJyZW50IHN0YXRlIG9mIHRoaXMubmV4dElkIGFuZCBpbmNyZW1lbnRzIGFmdGVyd2FyZHNcbiAgdmFyIGlkID0gdGhpcy5uZXh0SWQrK1xuICAvLyBFbnN1cmUgMTYgYml0IHVuc2lnbmVkIGludCAobWF4IDY1NTM1LCBuZXh0SWQgZ290IG9uZSBoaWdoZXIpXG4gIGlmICh0aGlzLm5leHRJZCA9PT0gNjU1MzYpIHtcbiAgICB0aGlzLm5leHRJZCA9IDFcbiAgfVxuICByZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBnZXRMYXN0TWVzc2FnZUlkXG4gKiBAcmV0dXJuIHVuc2lnbmVkIGludFxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5nZXRMYXN0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubmV4dElkID09PSAxKSA/IDY1NTM1IDogKHRoaXMubmV4dElkIC0gMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNcXR0Q2xpZW50XG4iLCIndXNlIHN0cmljdCdcblxudmFyIE1xdHRDbGllbnQgPSByZXF1aXJlKCcuLi9jbGllbnQnKVxudmFyIFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmUnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgcHJvdG9jb2xzID0ge31cblxuaWYgKHByb2Nlc3MudGl0bGUgIT09ICdicm93c2VyJykge1xuICBwcm90b2NvbHMubXF0dCA9IHJlcXVpcmUoJy4vdGNwJylcbiAgcHJvdG9jb2xzLnRjcCA9IHJlcXVpcmUoJy4vdGNwJylcbiAgcHJvdG9jb2xzLnNzbCA9IHJlcXVpcmUoJy4vdGxzJylcbiAgcHJvdG9jb2xzLnRscyA9IHJlcXVpcmUoJy4vdGxzJylcbiAgcHJvdG9jb2xzLm1xdHRzID0gcmVxdWlyZSgnLi90bHMnKVxufSBlbHNlIHtcbiAgcHJvdG9jb2xzLnd4ID0gcmVxdWlyZSgnLi93eCcpXG4gIHByb3RvY29scy53eHMgPSByZXF1aXJlKCcuL3d4Jylcbn1cblxucHJvdG9jb2xzLndzID0gcmVxdWlyZSgnLi93cycpXG5wcm90b2NvbHMud3NzID0gcmVxdWlyZSgnLi93cycpXG5cbi8qKlxuICogUGFyc2UgdGhlIGF1dGggYXR0cmlidXRlIGFuZCBtZXJnZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZUF1dGhPcHRpb25zIChvcHRzKSB7XG4gIHZhciBtYXRjaGVzXG4gIGlmIChvcHRzLmF1dGgpIHtcbiAgICBtYXRjaGVzID0gb3B0cy5hdXRoLm1hdGNoKC9eKC4rKTooLispJC8pXG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIG9wdHMudXNlcm5hbWUgPSBtYXRjaGVzWzFdXG4gICAgICBvcHRzLnBhc3N3b3JkID0gbWF0Y2hlc1syXVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzLnVzZXJuYW1lID0gb3B0cy5hdXRoXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogY29ubmVjdCAtIGNvbm5lY3QgdG8gYW4gTVFUVCBicm9rZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFticm9rZXJVcmxdIC0gdXJsIG9mIHRoZSBicm9rZXIsIG9wdGlvbmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIHNlZSBNcXR0Q2xpZW50I2NvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QgKGJyb2tlclVybCwgb3B0cykge1xuICBpZiAoKHR5cGVvZiBicm9rZXJVcmwgPT09ICdvYmplY3QnKSAmJiAhb3B0cykge1xuICAgIG9wdHMgPSBicm9rZXJVcmxcbiAgICBicm9rZXJVcmwgPSBudWxsXG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGlmIChicm9rZXJVcmwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsLnBhcnNlKGJyb2tlclVybCwgdHJ1ZSlcbiAgICBpZiAocGFyc2VkLnBvcnQgIT0gbnVsbCkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBOdW1iZXIocGFyc2VkLnBvcnQpXG4gICAgfVxuXG4gICAgb3B0cyA9IHh0ZW5kKHBhcnNlZCwgb3B0cylcblxuICAgIGlmIChvcHRzLnByb3RvY29sID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvdG9jb2wnKVxuICAgIH1cbiAgICBvcHRzLnByb3RvY29sID0gb3B0cy5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKVxuICB9XG5cbiAgLy8gbWVyZ2UgaW4gdGhlIGF1dGggb3B0aW9ucyBpZiBzdXBwbGllZFxuICBwYXJzZUF1dGhPcHRpb25zKG9wdHMpXG5cbiAgLy8gc3VwcG9ydCBjbGllbnRJZCBwYXNzZWQgaW4gdGhlIHF1ZXJ5IHN0cmluZyBvZiB0aGUgdXJsXG4gIGlmIChvcHRzLnF1ZXJ5ICYmIHR5cGVvZiBvcHRzLnF1ZXJ5LmNsaWVudElkID09PSAnc3RyaW5nJykge1xuICAgIG9wdHMuY2xpZW50SWQgPSBvcHRzLnF1ZXJ5LmNsaWVudElkXG4gIH1cblxuICBpZiAob3B0cy5jZXJ0ICYmIG9wdHMua2V5KSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgIGlmIChbJ21xdHRzJywgJ3dzcycsICd3eHMnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgICBzd2l0Y2ggKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgICAgICBjYXNlICdtcXR0JzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnbXF0dHMnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3dzJzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3NzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICd3eCc6XG4gICAgICAgICAgICBvcHRzLnByb3RvY29sID0gJ3d4cydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBmb3Igc2VjdXJlIGNvbm5lY3Rpb246IFwiJyArIG9wdHMucHJvdG9jb2wgKyAnXCIhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb24ndCBrbm93IHdoYXQgcHJvdG9jb2wgaGUgd2FudCB0byB1c2UsIG1xdHRzIG9yIHdzc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNlY3VyZSBwcm90b2NvbCBrZXknKVxuICAgIH1cbiAgfVxuXG4gIGlmICghcHJvdG9jb2xzW29wdHMucHJvdG9jb2xdKSB7XG4gICAgdmFyIGlzU2VjdXJlID0gWydtcXR0cycsICd3c3MnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpICE9PSAtMVxuICAgIG9wdHMucHJvdG9jb2wgPSBbXG4gICAgICAnbXF0dCcsXG4gICAgICAnbXF0dHMnLFxuICAgICAgJ3dzJyxcbiAgICAgICd3c3MnLFxuICAgICAgJ3d4JyxcbiAgICAgICd3eHMnXG4gICAgXS5maWx0ZXIoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NlY3VyZSAmJiBpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgLy8gU2tpcCBpbnNlY3VyZSBwcm90b2NvbHMgd2hlbiByZXF1ZXN0aW5nIGEgc2VjdXJlIG9uZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBwcm90b2NvbHNba2V5XSA9PT0gJ2Z1bmN0aW9uJylcbiAgICB9KVswXVxuICB9XG5cbiAgaWYgKG9wdHMuY2xlYW4gPT09IGZhbHNlICYmICFvcHRzLmNsaWVudElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNsaWVudElkIGZvciB1bmNsZWFuIGNsaWVudHMnKVxuICB9XG5cbiAgaWYgKG9wdHMucHJvdG9jb2wpIHtcbiAgICBvcHRzLmRlZmF1bHRQcm90b2NvbCA9IG9wdHMucHJvdG9jb2xcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIgKGNsaWVudCkge1xuICAgIGlmIChvcHRzLnNlcnZlcnMpIHtcbiAgICAgIGlmICghY2xpZW50Ll9yZWNvbm5lY3RDb3VudCB8fCBjbGllbnQuX3JlY29ubmVjdENvdW50ID09PSBvcHRzLnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNsaWVudC5fcmVjb25uZWN0Q291bnQgPSAwXG4gICAgICB9XG5cbiAgICAgIG9wdHMuaG9zdCA9IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5ob3N0XG4gICAgICBvcHRzLnBvcnQgPSBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucG9ydFxuICAgICAgb3B0cy5wcm90b2NvbCA9ICghb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLnByb3RvY29sID8gb3B0cy5kZWZhdWx0UHJvdG9jb2wgOiBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucHJvdG9jb2wpXG4gICAgICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0XG5cbiAgICAgIGNsaWVudC5fcmVjb25uZWN0Q291bnQrK1xuICAgIH1cblxuICAgIHJldHVybiBwcm90b2NvbHNbb3B0cy5wcm90b2NvbF0oY2xpZW50LCBvcHRzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNcXR0Q2xpZW50KHdyYXBwZXIsIG9wdHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdFxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Rcbm1vZHVsZS5leHBvcnRzLk1xdHRDbGllbnQgPSBNcXR0Q2xpZW50XG5tb2R1bGUuZXhwb3J0cy5TdG9yZSA9IFN0b3JlXG4iLCIndXNlIHN0cmljdCdcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKVxuXG4vKlxuICB2YXJpYWJsZXMgcG9ydCBhbmQgaG9zdCBjYW4gYmUgcmVtb3ZlZCBzaW5jZVxuICB5b3UgaGF2ZSBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaW4gb3B0cyBvYmplY3RcbiovXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKGNsaWVudCwgb3B0cykge1xuICB2YXIgcG9ydCwgaG9zdFxuICBvcHRzLnBvcnQgPSBvcHRzLnBvcnQgfHwgMTg4M1xuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcblxuICBwb3J0ID0gb3B0cy5wb3J0XG4gIGhvc3QgPSBvcHRzLmhvc3RuYW1lXG5cbiAgcmV0dXJuIG5ldC5jcmVhdGVDb25uZWN0aW9uKHBvcnQsIGhvc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyXG4iLCIndXNlIHN0cmljdCdcbnZhciB0bHMgPSByZXF1aXJlKCd0bHMnKVxuXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKG1xdHRDbGllbnQsIG9wdHMpIHtcbiAgdmFyIGNvbm5lY3Rpb25cbiAgb3B0cy5wb3J0ID0gb3B0cy5wb3J0IHx8IDg4ODNcbiAgb3B0cy5ob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcblxuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkICE9PSBmYWxzZVxuXG4gIGRlbGV0ZSBvcHRzLnBhdGhcblxuICBjb25uZWN0aW9uID0gdGxzLmNvbm5lY3Qob3B0cylcbiAgLyogZXNsaW50IG5vLXVzZS1iZWZvcmUtZGVmaW5lOiBbMiwgXCJub2Z1bmNcIl0gKi9cbiAgY29ubmVjdGlvbi5vbignc2VjdXJlQ29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAob3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgJiYgIWNvbm5lY3Rpb24uYXV0aG9yaXplZCkge1xuICAgICAgY29ubmVjdGlvbi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVExTIG5vdCBhdXRob3JpemVkJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVExTZXJyb3JzKVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiBoYW5kbGVUTFNlcnJvcnMgKGVycikge1xuICAgIC8vIEhvdyBjYW4gSSBnZXQgdmVyaWZ5IHRoaXMgZXJyb3IgaXMgYSB0bHMgZXJyb3I/XG4gICAgaWYgKG9wdHMucmVqZWN0VW5hdXRob3JpemVkKSB7XG4gICAgICBtcXR0Q2xpZW50LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cblxuICAgIC8vIGNsb3NlIHRoaXMgY29ubmVjdGlvbiB0byBtYXRjaCB0aGUgYmVoYXZpb3VyIG9mIG5ldFxuICAgIC8vIG90aGVyd2lzZSBhbGwgd2UgZ2V0IGlzIGFuIGVycm9yIGZyb20gdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBhbmQgY2xvc2UgZXZlbnQgZG9lc24ndCBmaXJlLiBUaGlzIGlzIGEgd29yayBhcm91bmRcbiAgICAvLyB0byBlbmFibGUgdGhlIHJlY29ubmVjdCBjb2RlIHRvIHdvcmsgdGhlIHNhbWUgYXMgd2l0aFxuICAgIC8vIG5ldC5jcmVhdGVDb25uZWN0aW9uXG4gICAgY29ubmVjdGlvbi5lbmQoKVxuICB9XG5cbiAgY29ubmVjdGlvbi5vbignZXJyb3InLCBoYW5kbGVUTFNlcnJvcnMpXG4gIHJldHVybiBjb25uZWN0aW9uXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJ3dlYnNvY2tldC1zdHJlYW0nKVxudmFyIHVybE1vZHVsZSA9IHJlcXVpcmUoJ3VybCcpXG52YXIgV1NTX09QVElPTlMgPSBbXG4gICdyZWplY3RVbmF1dGhvcml6ZWQnLFxuICAnY2EnLFxuICAnY2VydCcsXG4gICdrZXknLFxuICAncGZ4JyxcbiAgJ3Bhc3NwaHJhc2UnXG5dXG52YXIgSVNfQlJPV1NFUiA9IHByb2Nlc3MudGl0bGUgPT09ICdicm93c2VyJ1xuXG5mdW5jdGlvbiBidWlsZFVybCAob3B0cywgY2xpZW50KSB7XG4gIHZhciB1cmwgPSBvcHRzLnByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIGlmICh0eXBlb2YgKG9wdHMudHJhbnNmb3JtV3NVcmwpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXJsID0gb3B0cy50cmFuc2Zvcm1Xc1VybCh1cmwsIG9wdHMsIGNsaWVudClcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSAnbG9jYWxob3N0J1xuICB9XG4gIGlmICghb3B0cy5wb3J0KSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2wgPT09ICd3c3MnKSB7XG4gICAgICBvcHRzLnBvcnQgPSA0NDNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5wb3J0ID0gODBcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRzLnBhdGgpIHtcbiAgICBvcHRzLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcbiAgICBvcHRzLndzT3B0aW9ucyA9IHt9XG4gIH1cbiAgaWYgKCFJU19CUk9XU0VSICYmIG9wdHMucHJvdG9jb2wgPT09ICd3c3MnKSB7XG4gICAgLy8gQWRkIGNlcnQva2V5L2NhIGV0YyBvcHRpb25zXG4gICAgV1NTX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgIW9wdHMud3NPcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIG9wdHMud3NPcHRpb25zW3Byb3BdID0gb3B0c1twcm9wXVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0IChjbGllbnQsIG9wdHMpIHtcbiAgdmFyIHdlYnNvY2tldFN1YlByb3RvY29sID1cbiAgICAob3B0cy5wcm90b2NvbElkID09PSAnTVFJc2RwJykgJiYgKG9wdHMucHJvdG9jb2xWZXJzaW9uID09PSAzKVxuICAgICAgPyAnbXF0dHYzLjEnXG4gICAgICA6ICdtcXR0J1xuXG4gIHNldERlZmF1bHRPcHRzKG9wdHMpXG4gIHZhciB1cmwgPSBidWlsZFVybChvcHRzLCBjbGllbnQpXG4gIHJldHVybiB3ZWJzb2NrZXQodXJsLCBbd2Vic29ja2V0U3ViUHJvdG9jb2xdLCBvcHRzLndzT3B0aW9ucylcbn1cblxuZnVuY3Rpb24gYnVpbGRCdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVdlYlNvY2tldChjbGllbnQsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlckJyb3dzZXIgKGNsaWVudCwgb3B0cykge1xuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0XG4gIH1cblxuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICAvLyBUaHJvd2luZyBhbiBlcnJvciBpbiBhIFdlYiBXb3JrZXIgaWYgbm8gYGhvc3RuYW1lYCBpcyBnaXZlbiwgYmVjYXVzZSB3ZVxuICAgIC8vIGNhbiBub3QgZGV0ZXJtaW5lIHRoZSBgaG9zdG5hbWVgIGF1dG9tYXRpY2FsbHkuICBJZiBjb25uZWN0aW5nIHRvXG4gICAgLy8gbG9jYWxob3N0LCBwbGVhc2Ugc3VwcGx5IHRoZSBgaG9zdG5hbWVgIGFzIGFuIGFyZ3VtZW50LlxuICAgIGlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBob3N0LiBTcGVjaWZ5IGhvc3QgbWFudWFsbHkuJylcbiAgICB9XG4gICAgdmFyIHBhcnNlZCA9IHVybE1vZHVsZS5wYXJzZShkb2N1bWVudC5VUkwpXG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNlZC5ob3N0bmFtZVxuXG4gICAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgIG9wdHMucG9ydCA9IHBhcnNlZC5wb3J0XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVXZWJTb2NrZXQoY2xpZW50LCBvcHRzKVxufVxuXG5pZiAoSVNfQlJPV1NFUikge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlckJyb3dzZXJcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVpbGRCdWlsZGVyXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyogZ2xvYmFsIHd4ICovXG52YXIgc29ja2V0T3BlbiA9IGZhbHNlXG52YXIgc29ja2V0TXNnUXVldWUgPSBbXVxuXG5mdW5jdGlvbiBzZW5kU29ja2V0TWVzc2FnZSAobXNnKSB7XG4gIGlmIChzb2NrZXRPcGVuKSB7XG4gICAgd3guc2VuZFNvY2tldE1lc3NhZ2Uoe1xuICAgICAgZGF0YTogbXNnLmJ1ZmZlciB8fCBtc2dcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHNvY2tldE1zZ1F1ZXVlLnB1c2gobXNnKVxuICB9XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldCAodXJsLCBwcm90b2NvbHMpIHtcbiAgdmFyIHdzID0ge1xuICAgIE9QRU46IDEsXG4gICAgQ0xPU0lORzogMixcbiAgICBDTE9TRUQ6IDMsXG4gICAgcmVhZHlTdGF0ZTogc29ja2V0T3BlbiA/IDEgOiAwLFxuICAgIHNlbmQ6IHNlbmRTb2NrZXRNZXNzYWdlLFxuICAgIGNsb3NlOiB3eC5jbG9zZVNvY2tldCxcbiAgICBvbm9wZW46IG51bGwsXG4gICAgb25tZXNzYWdlOiBudWxsLFxuICAgIG9uY2xvc2U6IG51bGwsXG4gICAgb25lcnJvcjogbnVsbFxuICB9XG5cbiAgd3guY29ubmVjdFNvY2tldCh7XG4gICAgdXJsOiB1cmwsXG4gICAgcHJvdG9jb2xzOiBwcm90b2NvbHNcbiAgfSlcbiAgd3gub25Tb2NrZXRPcGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICB3cy5yZWFkeVN0YXRlID0gd3MuT1BFTlxuICAgIHNvY2tldE9wZW4gPSB0cnVlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb2NrZXRNc2dRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VuZFNvY2tldE1lc3NhZ2Uoc29ja2V0TXNnUXVldWVbaV0pXG4gICAgfVxuICAgIHNvY2tldE1zZ1F1ZXVlID0gW11cblxuICAgIHdzLm9ub3BlbiAmJiB3cy5vbm9wZW4uYXBwbHkod3MsIGFyZ3VtZW50cylcbiAgfSlcbiAgd3gub25Tb2NrZXRNZXNzYWdlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICB3cy5vbm1lc3NhZ2UgJiYgd3Mub25tZXNzYWdlLmFwcGx5KHdzLCBhcmd1bWVudHMpXG4gIH0pXG4gIHd4Lm9uU29ja2V0Q2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIHdzLm9uY2xvc2UgJiYgd3Mub25jbG9zZS5hcHBseSh3cywgYXJndW1lbnRzKVxuICAgIHdzLnJlYWR5U3RhdGUgPSB3cy5DTE9TRURcbiAgICBzb2NrZXRPcGVuID0gZmFsc2VcbiAgfSlcbiAgd3gub25Tb2NrZXRFcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgd3Mub25lcnJvciAmJiB3cy5vbmVycm9yLmFwcGx5KHdzLCBhcmd1bWVudHMpXG4gICAgd3MucmVhZHlTdGF0ZSA9IHdzLkNMT1NFRFxuICAgIHNvY2tldE9wZW4gPSBmYWxzZVxuICB9KVxuXG4gIHJldHVybiB3c1xufVxuXG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0LXN0cmVhbScpXG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCA9PT0gJ3d4cycgPyAnd3NzJyA6ICd3cydcbiAgdmFyIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgb3B0cy5wYXRoXG4gIGlmIChvcHRzLnBvcnQgJiYgb3B0cy5wb3J0ICE9PSA4MCAmJiBvcHRzLnBvcnQgIT09IDQ0Mykge1xuICAgIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIH1cbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXG4gIH1cbiAgaWYgKCFvcHRzLnBhdGgpIHtcbiAgICBvcHRzLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcbiAgICBvcHRzLndzT3B0aW9ucyA9IHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0IChjbGllbnQsIG9wdHMpIHtcbiAgdmFyIHdlYnNvY2tldFN1YlByb3RvY29sID1cbiAgICAob3B0cy5wcm90b2NvbElkID09PSAnTVFJc2RwJykgJiYgKG9wdHMucHJvdG9jb2xWZXJzaW9uID09PSAzKVxuICAgICAgPyAnbXF0dHYzLjEnXG4gICAgICA6ICdtcXR0J1xuXG4gIHNldERlZmF1bHRPcHRzKG9wdHMpXG4gIHZhciB1cmwgPSBidWlsZFVybChvcHRzLCBjbGllbnQpXG4gIHJldHVybiB3ZWJzb2NrZXQoV2ViU29ja2V0KHVybCwgW3dlYnNvY2tldFN1YlByb3RvY29sXSkpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRlciAoY2xpZW50LCBvcHRzKSB7XG4gIG9wdHMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBob3N0LiBTcGVjaWZ5IGhvc3QgbWFudWFsbHkuJylcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVXZWJTb2NrZXQoY2xpZW50LCBvcHRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlJlYWRhYmxlXG52YXIgc3RyZWFtc09wdHMgPSB7IG9iamVjdE1vZGU6IHRydWUgfVxudmFyIGRlZmF1bHRTdG9yZU9wdGlvbnMgPSB7XG4gIGNsZWFuOiB0cnVlXG59XG5cbi8qKlxuICogZXM2LW1hcCBjYW4gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyIGV2ZW4gaWYgRVMgdmVyc2lvbiBpcyBvbGRlci5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjRGVzY3JpcHRpb25cbiAqIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IGEgTWFwIHdoaWNoIGlzIGEgbWFwIG9mIGFuIG9iamVjdCwgZXNwZWNpYWxseVxuICogYSBkaWN0aW9uYXJ5IG9mIGRpY3Rpb25hcmllcywgd2lsbCBvbmx5IG1hcCB0byB0aGUgb2JqZWN0J3MgaW5zZXJ0aW9uXG4gKiBvcmRlci4gSW4gRVMyMDE1IHRoaXMgaXMgb3JkZXJlZCBmb3Igb2JqZWN0cyBidXQgZm9yIG9sZGVyIHZlcnNpb25zIG9mXG4gKiBFUywgdGhpcyBtYXkgYmUgcmFuZG9tIGFuZCBub3Qgb3JkZXJlZC5cbiAqXG4gKi9cbnZhciBNYXAgPSByZXF1aXJlKCdlczYtbWFwJylcblxuLyoqXG4gKiBJbi1tZW1vcnkgaW1wbGVtZW50YXRpb24gb2YgdGhlIG1lc3NhZ2Ugc3RvcmVcbiAqIFRoaXMgY2FuIGFjdHVhbGx5IGJlIHNhdmVkIGludG8gZmlsZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHN0b3JlIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3RvcmUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0b3JlKSkge1xuICAgIHJldHVybiBuZXcgU3RvcmUob3B0aW9ucylcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICAvLyBEZWZhdWx0c1xuICB0aGlzLm9wdGlvbnMgPSB4dGVuZChkZWZhdWx0U3RvcmVPcHRpb25zLCBvcHRpb25zKVxuXG4gIHRoaXMuX2luZmxpZ2h0cyA9IG5ldyBNYXAoKVxufVxuXG4vKipcbiAqIEFkZHMgYSBwYWNrZXQgdG8gdGhlIHN0b3JlLCBhIHBhY2tldCBpc1xuICogYW55dGhpbmcgdGhhdCBoYXMgYSBtZXNzYWdlSWQgcHJvcGVydHkuXG4gKlxuICovXG5TdG9yZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2IpIHtcbiAgdGhpcy5faW5mbGlnaHRzLnNldChwYWNrZXQubWVzc2FnZUlkLCBwYWNrZXQpXG5cbiAgaWYgKGNiKSB7XG4gICAgY2IoKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyZWFtIHdpdGggYWxsIHRoZSBwYWNrZXRzIGluIHRoZSBzdG9yZVxuICpcbiAqL1xuU3RvcmUucHJvdG90eXBlLmNyZWF0ZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBSZWFkYWJsZShzdHJlYW1zT3B0cylcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHZhciB2YWx1ZXMgPSBbXVxuICB2YXIgaSA9IDBcblxuICB0aGlzLl9pbmZsaWdodHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICB9KVxuXG4gIHN0cmVhbS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWRlc3Ryb3llZCAmJiBpIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5wdXNoKHZhbHVlc1tpKytdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2gobnVsbClcbiAgICB9XG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGRlc3Ryb3llZCA9IHRydWVcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxuLyoqXG4gKiBkZWxldGVzIGEgcGFja2V0IGZyb20gdGhlIHN0b3JlLlxuICovXG5TdG9yZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKHBhY2tldCwgY2IpIHtcbiAgcGFja2V0ID0gdGhpcy5faW5mbGlnaHRzLmdldChwYWNrZXQubWVzc2FnZUlkKVxuICBpZiAocGFja2V0KSB7XG4gICAgdGhpcy5faW5mbGlnaHRzLmRlbGV0ZShwYWNrZXQubWVzc2FnZUlkKVxuICAgIGNiKG51bGwsIHBhY2tldClcbiAgfSBlbHNlIGlmIChjYikge1xuICAgIGNiKG5ldyBFcnJvcignbWlzc2luZyBwYWNrZXQnKSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogZ2V0IGEgcGFja2V0IGZyb20gdGhlIHN0b3JlLlxuICovXG5TdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgY2IpIHtcbiAgcGFja2V0ID0gdGhpcy5faW5mbGlnaHRzLmdldChwYWNrZXQubWVzc2FnZUlkKVxuICBpZiAocGFja2V0KSB7XG4gICAgY2IobnVsbCwgcGFja2V0KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdtaXNzaW5nIHBhY2tldCcpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgc3RvcmVcbiAqL1xuU3RvcmUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuY2xlYW4pIHtcbiAgICB0aGlzLl9pbmZsaWdodHMgPSBudWxsXG4gIH1cbiAgaWYgKGNiKSB7XG4gICAgY2IoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmVcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFZhbGlkYXRlIGEgdG9waWMgdG8gc2VlIGlmIGl0J3MgdmFsaWQgb3Igbm90LlxuICogQSB0b3BpYyBpcyB2YWxpZCBpZiBpdCBmb2xsb3cgYmVsb3cgcnVsZXM6XG4gKiAtIFJ1bGUgIzE6IElmIGFueSBwYXJ0IG9mIHRoZSB0b3BpYyBpcyBub3QgYCtgIG9yIGAjYCwgdGhlbiBpdCBtdXN0IG5vdCBjb250YWluIGArYCBhbmQgJyMnXG4gKiAtIFJ1bGUgIzI6IFBhcnQgYCNgIG11c3QgYmUgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBtYWlsYm94XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIC0gQSB0b3BpY1xuICogQHJldHVybnMge0Jvb2xlYW59IElmIHRoZSB0b3BpYyBpcyB2YWxpZCwgcmV0dXJucyB0cnVlLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9waWMgKHRvcGljKSB7XG4gIHZhciBwYXJ0cyA9IHRvcGljLnNwbGl0KCcvJylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnRzW2ldID09PSAnKycpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHBhcnRzW2ldID09PSAnIycpIHtcbiAgICAgIC8vIGZvciBSdWxlICMyXG4gICAgICByZXR1cm4gaSA9PT0gcGFydHMubGVuZ3RoIC0gMVxuICAgIH1cblxuICAgIGlmIChwYXJ0c1tpXS5pbmRleE9mKCcrJykgIT09IC0xIHx8IHBhcnRzW2ldLmluZGV4T2YoJyMnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gYXJyYXkgb2YgdG9waWNzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBpcyB2YWxpZCBvciBub3RcbiAgKiBAcGFyYW0ge0FycmF5fSB0b3BpY3MgLSBBcnJheSBvZiB0b3BpY3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IElmIHRoZSB0b3BpY3MgaXMgdmFsaWQsIHJldHVybnMgbnVsbC4gT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSBpbnZhbGlkIG9uZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVRvcGljcyAodG9waWNzKSB7XG4gIGlmICh0b3BpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdlbXB0eV90b3BpY19saXN0J1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9waWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVRvcGljKHRvcGljc1tpXSkpIHtcbiAgICAgIHJldHVybiB0b3BpY3NbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRlVG9waWNzOiB2YWxpZGF0ZVRvcGljc1xufVxuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG5cbmV4cG9ydHMuaG9tZWRpciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICcvJ1xufTtcbiIsIi8vICdwYXRoJyBtb2R1bGUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xIChvbmx5IHRoZSBwb3NpeCBwYXJ0KVxuLy8gdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbFxuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXRoKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KHBhdGgpKTtcbiAgfVxufVxuXG4vLyBSZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggd2l0aCBkaXJlY3RvcnkgbmFtZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsIGFsbG93QWJvdmVSb290KSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgdmFyIGxhc3RTbGFzaCA9IC0xO1xuICB2YXIgZG90cyA9IDA7XG4gIHZhciBjb2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBwYXRoLmxlbmd0aClcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgZWxzZSBpZiAoY29kZSA9PT0gNDcgLyovKi8pXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBjb2RlID0gNDcgLyovKi87XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNsYXNoICE9PSBpIC0gMSAmJiBkb3RzID09PSAyKSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IDQ2IC8qLiovIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gNDYgLyouKi8pIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ICE9PSByZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPT09IDIgfHwgcmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmVzICs9ICcvLi4nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA9ICcuLic7XG4gICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmVzICs9ICcvJyArIHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXMgPSBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IGkgLSBsYXN0U2xhc2ggLSAxO1xuICAgICAgfVxuICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgIGRvdHMgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNDYgLyouKi8gJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICsrZG90cztcbiAgICB9IGVsc2Uge1xuICAgICAgZG90cyA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBfZm9ybWF0KHNlcCwgcGF0aE9iamVjdCkge1xuICB2YXIgZGlyID0gcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5yb290O1xuICB2YXIgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCAocGF0aE9iamVjdC5uYW1lIHx8ICcnKSArIChwYXRoT2JqZWN0LmV4dCB8fCAnJyk7XG4gIGlmICghZGlyKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGRpciA9PT0gcGF0aE9iamVjdC5yb290KSB7XG4gICAgcmV0dXJuIGRpciArIGJhc2U7XG4gIH1cbiAgcmV0dXJuIGRpciArIHNlcCArIGJhc2U7XG59XG5cbnZhciBwb3NpeCA9IHtcbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJztcbiAgICB2YXIgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgIHZhciBjd2Q7XG5cbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGg7XG4gICAgICBpZiAoaSA+PSAwKVxuICAgICAgICBwYXRoID0gYXJndW1lbnRzW2ldO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjd2QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBwYXRoID0gY3dkO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHJlc29sdmVkUGF0aCwgIXJlc29sdmVkQWJzb2x1dGUpO1xuXG4gICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMClcbiAgICAgICAgcmV0dXJuICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJy4nO1xuICAgIH1cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcblxuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB2YXIgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcgLyovKi87XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICBwYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgIWlzQWJzb2x1dGUpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwICYmICFpc0Fic29sdXRlKSBwYXRoID0gJy4nO1xuICAgIGlmIChwYXRoLmxlbmd0aCA+IDAgJiYgdHJhaWxpbmdTZXBhcmF0b3IpIHBhdGggKz0gJy8nO1xuXG4gICAgaWYgKGlzQWJzb2x1dGUpIHJldHVybiAnLycgKyBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHZhciBqb2luZWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICBhc3NlcnRQYXRoKGFyZyk7XG4gICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGpvaW5lZCA9IGFyZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGpvaW5lZCArPSAnLycgKyBhcmc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnLic7XG4gICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICB9LFxuXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgIGFzc2VydFBhdGgoZnJvbSk7XG4gICAgYXNzZXJ0UGF0aCh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIGZyb20gPSBwb3NpeC5yZXNvbHZlKGZyb20pO1xuICAgIHRvID0gcG9zaXgucmVzb2x2ZSh0byk7XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHJldHVybiAnJztcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgZnJvbVN0YXJ0ID0gMTtcbiAgICBmb3IgKDsgZnJvbVN0YXJ0IDwgZnJvbS5sZW5ndGg7ICsrZnJvbVN0YXJ0KSB7XG4gICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICB2YXIgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIHRvU3RhcnQgPSAxO1xuICAgIGZvciAoOyB0b1N0YXJ0IDwgdG8ubGVuZ3RoOyArK3RvU3RhcnQpIHtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICB2YXIgdG9MZW4gPSB0b0VuZCAtIHRvU3RhcnQ7XG5cbiAgICAvLyBDb21wYXJlIHBhdGhzIHRvIGZpbmQgdGhlIGxvbmdlc3QgY29tbW9uIHBhdGggZnJvbSByb290XG4gICAgdmFyIGxlbmd0aCA9IGZyb21MZW4gPCB0b0xlbiA/IGZyb21MZW4gOiB0b0xlbjtcbiAgICB2YXIgbGFzdENvbW1vblNlcCA9IC0xO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8PSBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGxlbmd0aCkge1xuICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvZm9vL2Jhci9iYXonXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy8nOyB0bz0nL2ZvbydcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXIvYmF6JzsgdG89Jy9mb28vYmFyJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSByb290LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28nOyB0bz0nLydcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgIHZhciB0b0NvZGUgPSB0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKTtcbiAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG9Db2RlKVxuICAgICAgICBicmVhaztcbiAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSA0NyAvKi8qLylcbiAgICAgICAgbGFzdENvbW1vblNlcCA9IGk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gXG4gICAgLy8gYW5kIGBmcm9tYFxuICAgIGZvciAoaSA9IGZyb21TdGFydCArIGxhc3RDb21tb25TZXAgKyAxOyBpIDw9IGZyb21FbmQ7ICsraSkge1xuICAgICAgaWYgKGkgPT09IGZyb21FbmQgfHwgZnJvbS5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBvdXQgKz0gJy4uJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG91dCArPSAnLy4uJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXN0bHksIGFwcGVuZCB0aGUgcmVzdCBvZiB0aGUgZGVzdGluYXRpb24gKGB0b2ApIHBhdGggdGhhdCBjb21lcyBhZnRlclxuICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgIGlmIChvdXQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvdXQgKyB0by5zbGljZSh0b1N0YXJ0ICsgbGFzdENvbW1vblNlcCk7XG4gICAgZWxzZSB7XG4gICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gNDcgLyovKi8pXG4gICAgICAgICsrdG9TdGFydDtcbiAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0KTtcbiAgICB9XG4gIH0sXG5cbiAgX21ha2VMb25nOiBmdW5jdGlvbiBfbWFrZUxvbmcocGF0aCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIGRpcm5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHJldHVybiAnLy8nO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG4gIH0sXG5cbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXh0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciBzdGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIGV4dC5sZW5ndGggPiAwICYmIGV4dC5sZW5ndGggPD0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChleHQubGVuZ3RoID09PSBwYXRoLmxlbmd0aCAmJiBleHQgPT09IHBhdGgpIHJldHVybiAnJztcbiAgICAgIHZhciBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0SWR4ID49IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZXhwbGljaXQgZXh0ZW5zaW9uXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gZXh0LmNoYXJDb2RlQXQoZXh0SWR4KSkge1xuICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgZXh0ZW5zaW9uLCBzbyBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXIgcGF0aFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtlbHNlIGlmIChlbmQgPT09IC0xKSBlbmQgPSBwYXRoLmxlbmd0aDtcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICB9LFxuXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIGV4dG5hbWUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICB9LFxuXG4gIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHBhdGhPYmplY3QpIHtcbiAgICBpZiAocGF0aE9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2YgcGF0aE9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgcGF0aE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBfZm9ybWF0KCcvJywgcGF0aE9iamVjdCk7XG4gIH0sXG5cbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJldDtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaXNBYnNvbHV0ZSA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBzdGFydDtcbiAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgcmV0LnJvb3QgPSAnLyc7XG4gICAgICBzdGFydCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gICAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gICAgdmFyIGVuZCA9IC0xO1xuICAgIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuXG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcblxuICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICBmb3IgKDsgaSA+PSBzdGFydDsgLS1pKSB7XG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHN0YXJ0RG90ID0gaTtlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtlbHNlIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZSgxLCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0UGFydCA+IDApIHJldC5kaXIgPSBwYXRoLnNsaWNlKDAsIHN0YXJ0UGFydCAtIDEpO2Vsc2UgaWYgKGlzQWJzb2x1dGUpIHJldC5kaXIgPSAnLyc7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNlcDogJy8nLFxuICBkZWxpbWl0ZXI6ICc6JyxcbiAgd2luMzI6IG51bGwsXG4gIHBvc2l4OiBudWxsXG59O1xuXG5wb3NpeC5wb3NpeCA9IHBvc2l4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBSZUludGVydmFsIChjYWxsYmFjaywgaW50ZXJ2YWwsIGFyZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX2FyZ3MgPSBhcmdzO1xuXG4gIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIGludGVydmFsLCB0aGlzLl9hcmdzKTtcblxuICB0aGlzLnJlc2NoZWR1bGUgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAvLyBpZiBubyBpbnRlcnZhbCBlbnRlcmVkLCB1c2UgdGhlIGludGVydmFsIHBhc3NlZCBpbiBvbiBjcmVhdGlvblxuICAgIGlmICghaW50ZXJ2YWwpXG4gICAgICBpbnRlcnZhbCA9IHNlbGYuX2ludGVydmFsO1xuXG4gICAgaWYgKHNlbGYuX2ludGVydmFsKVxuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgc2VsZi5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChzZWxmLl9jYWxsYmFjaywgaW50ZXJ2YWwsIHNlbGYuX2FyZ3MpO1xuICB9O1xuXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICAgIHNlbGYuX2ludGVydmFsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgIH1cbiAgICBzZWxmLl9jYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9pbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9hcmdzID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZUludGVydmFsICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBuZWVkZWQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignaW50ZXJ2YWwgbmVlZGVkJyk7XG5cbiAgdmFyIGFyZ3M7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVJbnRlcnZhbChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVJbnRlcnZhbDtcbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJ2YXIgQ2xpZW50UmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKVxudmFyIHJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvcmVzcG9uc2UnKVxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBzdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2J1aWx0aW4tc3RhdHVzLWNvZGVzJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG52YXIgaHR0cCA9IGV4cG9ydHNcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG5cdFx0b3B0cyA9IHVybC5wYXJzZShvcHRzKVxuXHRlbHNlXG5cdFx0b3B0cyA9IGV4dGVuZChvcHRzKVxuXG5cdC8vIE5vcm1hbGx5LCB0aGUgcGFnZSBpcyBsb2FkZWQgZnJvbSBodHRwIG9yIGh0dHBzLCBzbyBub3Qgc3BlY2lmeWluZyBhIHByb3RvY29sXG5cdC8vIHdpbGwgcmVzdWx0IGluIGEgKHZhbGlkKSBwcm90b2NvbC1yZWxhdGl2ZSB1cmwuIEhvd2V2ZXIsIHRoaXMgd29uJ3Qgd29yayBpZlxuXHQvLyB0aGUgcHJvdG9jb2wgaXMgc29tZXRoaW5nIGVsc2UsIGxpa2UgJ2ZpbGU6J1xuXHR2YXIgZGVmYXVsdFByb3RvY29sID0gZ2xvYmFsLmxvY2F0aW9uLnByb3RvY29sLnNlYXJjaCgvXmh0dHBzPzokLykgPT09IC0xID8gJ2h0dHA6JyA6ICcnXG5cblx0dmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCB8fCBkZWZhdWx0UHJvdG9jb2xcblx0dmFyIGhvc3QgPSBvcHRzLmhvc3RuYW1lIHx8IG9wdHMuaG9zdFxuXHR2YXIgcG9ydCA9IG9wdHMucG9ydFxuXHR2YXIgcGF0aCA9IG9wdHMucGF0aCB8fCAnLydcblxuXHQvLyBOZWNlc3NhcnkgZm9yIElQdjYgYWRkcmVzc2VzXG5cdGlmIChob3N0ICYmIGhvc3QuaW5kZXhPZignOicpICE9PSAtMSlcblx0XHRob3N0ID0gJ1snICsgaG9zdCArICddJ1xuXG5cdC8vIFRoaXMgbWF5IGJlIGEgcmVsYXRpdmUgdXJsLiBUaGUgYnJvd3NlciBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gaW50ZXJwcmV0IGl0IGNvcnJlY3RseS5cblx0b3B0cy51cmwgPSAoaG9zdCA/IChwcm90b2NvbCArICcvLycgKyBob3N0KSA6ICcnKSArIChwb3J0ID8gJzonICsgcG9ydCA6ICcnKSArIHBhdGhcblx0b3B0cy5tZXRob2QgPSAob3B0cy5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKClcblx0b3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9XG5cblx0Ly8gQWxzbyB2YWxpZCBvcHRzLmF1dGgsIG9wdHMubW9kZVxuXG5cdHZhciByZXEgPSBuZXcgQ2xpZW50UmVxdWVzdChvcHRzKVxuXHRpZiAoY2IpXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGNiKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvcHRzLCBjYikge1xuXHR2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KG9wdHMsIGNiKVxuXHRyZXEuZW5kKClcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLkNsaWVudFJlcXVlc3QgPSBDbGllbnRSZXF1ZXN0XG5odHRwLkluY29taW5nTWVzc2FnZSA9IHJlc3BvbnNlLkluY29taW5nTWVzc2FnZVxuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge31cbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0XG5cbmh0dHAuZ2xvYmFsQWdlbnQgPSBuZXcgaHR0cC5BZ2VudCgpXG5cbmh0dHAuU1RBVFVTX0NPREVTID0gc3RhdHVzQ29kZXNcblxuaHR0cC5NRVRIT0RTID0gW1xuXHQnQ0hFQ0tPVVQnLFxuXHQnQ09OTkVDVCcsXG5cdCdDT1BZJyxcblx0J0RFTEVURScsXG5cdCdHRVQnLFxuXHQnSEVBRCcsXG5cdCdMT0NLJyxcblx0J00tU0VBUkNIJyxcblx0J01FUkdFJyxcblx0J01LQUNUSVZJVFknLFxuXHQnTUtDT0wnLFxuXHQnTU9WRScsXG5cdCdOT1RJRlknLFxuXHQnT1BUSU9OUycsXG5cdCdQQVRDSCcsXG5cdCdQT1NUJyxcblx0J1BST1BGSU5EJyxcblx0J1BST1BQQVRDSCcsXG5cdCdQVVJHRScsXG5cdCdQVVQnLFxuXHQnUkVQT1JUJyxcblx0J1NFQVJDSCcsXG5cdCdTVUJTQ1JJQkUnLFxuXHQnVFJBQ0UnLFxuXHQnVU5MT0NLJyxcblx0J1VOU1VCU0NSSUJFJ1xuXSIsImV4cG9ydHMuZmV0Y2ggPSBpc0Z1bmN0aW9uKGdsb2JhbC5mZXRjaCkgJiYgaXNGdW5jdGlvbihnbG9iYWwuUmVhZGFibGVTdHJlYW0pXG5cbmV4cG9ydHMud3JpdGFibGVTdHJlYW0gPSBpc0Z1bmN0aW9uKGdsb2JhbC5Xcml0YWJsZVN0cmVhbSlcblxuZXhwb3J0cy5hYm9ydENvbnRyb2xsZXIgPSBpc0Z1bmN0aW9uKGdsb2JhbC5BYm9ydENvbnRyb2xsZXIpXG5cbi8vIFRoZSB4aHIgcmVxdWVzdCB0byBleGFtcGxlLmNvbSBtYXkgdmlvbGF0ZSBzb21lIHJlc3RyaWN0aXZlIENTUCBjb25maWd1cmF0aW9ucyxcbi8vIHNvIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgYGZldGNoYCwgYXZvaWQgY2FsbGluZyBnZXRYSFIoKVxuLy8gYW5kIGFzc3VtZSBzdXBwb3J0IGZvciBjZXJ0YWluIGZlYXR1cmVzIGJlbG93LlxudmFyIHhoclxuZnVuY3Rpb24gZ2V0WEhSICgpIHtcblx0Ly8gQ2FjaGUgdGhlIHhociB2YWx1ZVxuXHRpZiAoeGhyICE9PSB1bmRlZmluZWQpIHJldHVybiB4aHJcblxuXHRpZiAoZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0eGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0Ly8gSWYgWERvbWFpblJlcXVlc3QgaXMgYXZhaWxhYmxlIChpZSBvbmx5LCB3aGVyZSB4aHIgbWlnaHQgbm90IHdvcmtcblx0XHQvLyBjcm9zcyBkb21haW4pLCB1c2UgdGhlIHBhZ2UgbG9jYXRpb24uIE90aGVyd2lzZSB1c2UgZXhhbXBsZS5jb21cblx0XHQvLyBOb3RlOiB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgbWFrZSBhbiBodHRwIHJlcXVlc3QuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKCdHRVQnLCBnbG9iYWwuWERvbWFpblJlcXVlc3QgPyAnLycgOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScpXG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHR4aHIgPSBudWxsXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIFNlcnZpY2Ugd29ya2VycyBkb24ndCBoYXZlIFhIUlxuXHRcdHhociA9IG51bGxcblx0fVxuXHRyZXR1cm4geGhyXG59XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZVN1cHBvcnQgKHR5cGUpIHtcblx0dmFyIHhociA9IGdldFhIUigpXG5cdGlmICgheGhyKSByZXR1cm4gZmFsc2Vcblx0dHJ5IHtcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gdHlwZVxuXHRcdHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSB0eXBlXG5cdH0gY2F0Y2ggKGUpIHt9XG5cdHJldHVybiBmYWxzZVxufVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gYXJyYXlidWZmZXIgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGNoZWNrVHlwZVN1cHBvcnQoKSwgc2luY2UgdGhhdCBjYWxscyBnZXRYSFIoKS5cbmV4cG9ydHMuYXJyYXlidWZmZXIgPSBleHBvcnRzLmZldGNoIHx8IGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJylcblxuLy8gVGhlc2UgbmV4dCB0d28gdGVzdHMgdW5hdm9pZGFibHkgc2hvdyB3YXJuaW5ncyBpbiBDaHJvbWUuIFNpbmNlIGZldGNoIHdpbGwgYWx3YXlzXG4vLyBiZSB1c2VkIGlmIGl0J3MgYXZhaWxhYmxlLCBqdXN0IHJldHVybiBmYWxzZSBmb3IgdGhlc2UgdG8gYXZvaWQgdGhlIHdhcm5pbmdzLlxuZXhwb3J0cy5tc3N0cmVhbSA9ICFleHBvcnRzLmZldGNoICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21zLXN0cmVhbScpXG5leHBvcnRzLm1vemNodW5rZWRhcnJheWJ1ZmZlciA9ICFleHBvcnRzLmZldGNoICYmIGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIG92ZXJyaWRlTWltZVR5cGUgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGdldFhIUigpLlxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gZXhwb3J0cy5mZXRjaCB8fCAoZ2V0WEhSKCkgPyBpc0Z1bmN0aW9uKGdldFhIUigpLm92ZXJyaWRlTWltZVR5cGUpIDogZmFsc2UpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG52YXIgclN0YXRlcyA9IHJlc3BvbnNlLnJlYWR5U3RhdGVzXG5cbmZ1bmN0aW9uIGRlY2lkZU1vZGUgKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpIHtcblx0aWYgKGNhcGFiaWxpdHkuZmV0Y2ggJiYgdXNlRmV0Y2gpIHtcblx0XHRyZXR1cm4gJ2ZldGNoJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubW96Y2h1bmtlZGFycmF5YnVmZmVyKSB7XG5cdFx0cmV0dXJuICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcidcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5Lm1zc3RyZWFtKSB7XG5cdFx0cmV0dXJuICdtcy1zdHJlYW0nXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlciAmJiBwcmVmZXJCaW5hcnkpIHtcblx0XHRyZXR1cm4gJ2FycmF5YnVmZmVyJ1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAndGV4dCdcblx0fVxufVxuXG52YXIgQ2xpZW50UmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fb3B0cyA9IG9wdHNcblx0c2VsZi5fYm9keSA9IFtdXG5cdHNlbGYuX2hlYWRlcnMgPSB7fVxuXHRpZiAob3B0cy5hdXRoKVxuXHRcdHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSlcblx0T2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0c2VsZi5zZXRIZWFkZXIobmFtZSwgb3B0cy5oZWFkZXJzW25hbWVdKVxuXHR9KVxuXG5cdHZhciBwcmVmZXJCaW5hcnlcblx0dmFyIHVzZUZldGNoID0gdHJ1ZVxuXHRpZiAob3B0cy5tb2RlID09PSAnZGlzYWJsZS1mZXRjaCcgfHwgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cyAmJiAhY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpKSB7XG5cdFx0Ly8gSWYgdGhlIHVzZSBvZiBYSFIgc2hvdWxkIGJlIHByZWZlcnJlZC4gTm90IHR5cGljYWxseSBuZWVkZWQuXG5cdFx0dXNlRmV0Y2ggPSBmYWxzZVxuXHRcdHByZWZlckJpbmFyeSA9IHRydWVcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdwcmVmZXItc3RyZWFtaW5nJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBhIGhpZ2ggcHJpb3JpdHkgYnV0IGJpbmFyeSBjb21wYXRpYmlsaXR5IGFuZFxuXHRcdC8vIHRoZSBhY2N1cmFjeSBvZiB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyIGFyZW4ndFxuXHRcdHByZWZlckJpbmFyeSA9IGZhbHNlXG5cdH0gZWxzZSBpZiAob3B0cy5tb2RlID09PSAnYWxsb3ctd3JvbmctY29udGVudC10eXBlJykge1xuXHRcdC8vIElmIHN0cmVhbWluZyBpcyBtb3JlIGltcG9ydGFudCB0aGFuIHByZXNlcnZpbmcgdGhlICdjb250ZW50LXR5cGUnIGhlYWRlclxuXHRcdHByZWZlckJpbmFyeSA9ICFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGVcblx0fSBlbHNlIGlmICghb3B0cy5tb2RlIHx8IG9wdHMubW9kZSA9PT0gJ2RlZmF1bHQnIHx8IG9wdHMubW9kZSA9PT0gJ3ByZWZlci1mYXN0Jykge1xuXHRcdC8vIFVzZSBiaW5hcnkgaWYgdGV4dCBzdHJlYW1pbmcgbWF5IGNvcnJ1cHQgZGF0YSBvciB0aGUgY29udGVudC10eXBlIGhlYWRlciwgb3IgZm9yIHNwZWVkXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igb3B0cy5tb2RlJylcblx0fVxuXHRzZWxmLl9tb2RlID0gZGVjaWRlTW9kZShwcmVmZXJCaW5hcnksIHVzZUZldGNoKVxuXHRzZWxmLl9mZXRjaFRpbWVyID0gbnVsbFxuXHRzZWxmLl9zb2NrZXRUaW1lb3V0ID0gbnVsbFxuXHRzZWxmLl9zb2NrZXRUaW1lciA9IG51bGxcblxuXHRzZWxmLm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5fb25GaW5pc2goKVxuXHR9KVxufVxuXG5pbmhlcml0cyhDbGllbnRSZXF1ZXN0LCBzdHJlYW0uV3JpdGFibGUpXG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0dmFyIGxvd2VyTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuXHQvLyBUaGlzIGNoZWNrIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBwcmV2ZW50cyB3YXJuaW5ncyBmcm9tIGJyb3dzZXJzIGFib3V0IHNldHRpbmcgdW5zYWZlXG5cdC8vIGhlYWRlcnMuIFRvIGJlIGhvbmVzdCBJJ20gbm90IGVudGlyZWx5IHN1cmUgaGlkaW5nIHRoZXNlIHdhcm5pbmdzIGlzIGEgZ29vZCB0aGluZywgYnV0XG5cdC8vIGh0dHAtYnJvd3NlcmlmeSBkaWQgaXQsIHNvIEkgd2lsbCB0b28uXG5cdGlmICh1bnNhZmVIZWFkZXJzLmluZGV4T2YobG93ZXJOYW1lKSAhPT0gLTEpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5faGVhZGVyc1tsb3dlck5hbWVdID0ge1xuXHRcdG5hbWU6IG5hbWUsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIGhlYWRlciA9IHRoaXMuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXVxuXHRpZiAoaGVhZGVyKVxuXHRcdHJldHVybiBoZWFkZXIudmFsdWVcblx0cmV0dXJuIG51bGxcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGRlbGV0ZSBzZWxmLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXHR2YXIgb3B0cyA9IHNlbGYuX29wdHNcblxuXHRpZiAoJ3RpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy50aW1lb3V0ICE9PSAwKSB7XG5cdFx0c2VsZi5zZXRUaW1lb3V0KG9wdHMudGltZW91dClcblx0fVxuXG5cdHZhciBoZWFkZXJzT2JqID0gc2VsZi5faGVhZGVyc1xuXHR2YXIgYm9keSA9IG51bGxcblx0aWYgKG9wdHMubWV0aG9kICE9PSAnR0VUJyAmJiBvcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgIGJvZHkgPSBuZXcgQmxvYihzZWxmLl9ib2R5LCB7XG4gICAgICAgICAgICB0eXBlOiAoaGVhZGVyc09ialsnY29udGVudC10eXBlJ10gfHwge30pLnZhbHVlIHx8ICcnXG4gICAgICAgIH0pO1xuICAgIH1cblxuXHQvLyBjcmVhdGUgZmxhdHRlbmVkIGxpc3Qgb2YgaGVhZGVyc1xuXHR2YXIgaGVhZGVyc0xpc3QgPSBbXVxuXHRPYmplY3Qua2V5cyhoZWFkZXJzT2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXlOYW1lKSB7XG5cdFx0dmFyIG5hbWUgPSBoZWFkZXJzT2JqW2tleU5hbWVdLm5hbWVcblx0XHR2YXIgdmFsdWUgPSBoZWFkZXJzT2JqW2tleU5hbWVdLnZhbHVlXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHZdKVxuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdmFsdWVdKVxuXHRcdH1cblx0fSlcblxuXHRpZiAoc2VsZi5fbW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHZhciBzaWduYWwgPSBudWxsXG5cdFx0aWYgKGNhcGFiaWxpdHkuYWJvcnRDb250cm9sbGVyKSB7XG5cdFx0XHR2YXIgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXHRcdFx0c2lnbmFsID0gY29udHJvbGxlci5zaWduYWxcblx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyID0gY29udHJvbGxlclxuXG5cdFx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmIG9wdHMucmVxdWVzdFRpbWVvdXQgIT09IDApIHtcblx0XHRcdFx0c2VsZi5fZmV0Y2hUaW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdFx0XHRpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0XHRcdFx0XHRzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlci5hYm9ydCgpXG5cdFx0XHRcdH0sIG9wdHMucmVxdWVzdFRpbWVvdXQpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z2xvYmFsLmZldGNoKHNlbGYuX29wdHMudXJsLCB7XG5cdFx0XHRtZXRob2Q6IHNlbGYuX29wdHMubWV0aG9kLFxuXHRcdFx0aGVhZGVyczogaGVhZGVyc0xpc3QsXG5cdFx0XHRib2R5OiBib2R5IHx8IHVuZGVmaW5lZCxcblx0XHRcdG1vZGU6ICdjb3JzJyxcblx0XHRcdGNyZWRlbnRpYWxzOiBvcHRzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbicsXG5cdFx0XHRzaWduYWw6IHNpZ25hbFxuXHRcdH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRzZWxmLl9mZXRjaFJlc3BvbnNlID0gcmVzcG9uc2Vcblx0XHRcdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxuXHRcdFx0c2VsZi5fY29ubmVjdCgpXG5cdFx0fSwgZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0c2VsZi5fcmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgcmVhc29uKVxuXHRcdH0pXG5cdH0gZWxzZSB7XG5cdFx0dmFyIHhociA9IHNlbGYuX3hociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbihzZWxmLl9vcHRzLm1ldGhvZCwgc2VsZi5fb3B0cy51cmwsIHRydWUpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBDYW4ndCBzZXQgcmVzcG9uc2VUeXBlIG9uIHJlYWxseSBvbGQgYnJvd3NlcnNcblx0XHRpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHNlbGYuX21vZGVcblxuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuXG5cdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cykge1xuXHRcdFx0eGhyLnRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0XG5cdFx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWFkZXJzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLl9yZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWEhSIGVycm9yJykpXG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5zZW5kKGJvZHkpXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgeGhyLnN0YXR1cyBpcyByZWFkYWJsZSBhbmQgbm9uLXplcm8sIGluZGljYXRpbmcgbm8gZXJyb3IuXG4gKiBFdmVuIHRob3VnaCB0aGUgc3BlYyBzYXlzIGl0IHNob3VsZCBiZSBhdmFpbGFibGUgaW4gcmVhZHlTdGF0ZSAzLFxuICogYWNjZXNzaW5nIGl0IHRocm93cyBhbiBleGNlcHRpb24gaW4gSUU4XG4gKi9cbmZ1bmN0aW9uIHN0YXR1c1ZhbGlkICh4aHIpIHtcblx0dHJ5IHtcblx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1c1xuXHRcdHJldHVybiAoc3RhdHVzICE9PSBudWxsICYmIHN0YXR1cyAhPT0gMClcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9yZXNldFRpbWVycyhmYWxzZSlcblxuXHRpZiAoIXN0YXR1c1ZhbGlkKHNlbGYuX3hocikgfHwgc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdGlmICghc2VsZi5fcmVzcG9uc2UpXG5cdFx0c2VsZi5fY29ubmVjdCgpXG5cblx0c2VsZi5fcmVzcG9uc2UuX29uWEhSUHJvZ3Jlc3Moc2VsZi5fcmVzZXRUaW1lcnMuYmluZChzZWxmKSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0c2VsZi5fcmVzcG9uc2UgPSBuZXcgSW5jb21pbmdNZXNzYWdlKHNlbGYuX3hociwgc2VsZi5fZmV0Y2hSZXNwb25zZSwgc2VsZi5fbW9kZSwgc2VsZi5fcmVzZXRUaW1lcnMuYmluZChzZWxmKSlcblx0c2VsZi5fcmVzcG9uc2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0fSlcblxuXHRzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgc2VsZi5fcmVzcG9uc2UpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX2JvZHkucHVzaChjaHVuaylcblx0Y2IoKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fcmVzZXRUaW1lcnMgPSBmdW5jdGlvbiAoZG9uZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX3NvY2tldFRpbWVyKVxuXHRzZWxmLl9zb2NrZXRUaW1lciA9IG51bGxcblxuXHRpZiAoZG9uZSkge1xuXHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fZmV0Y2hUaW1lcilcblx0XHRzZWxmLl9mZXRjaFRpbWVyID0gbnVsbFxuXHR9IGVsc2UgaWYgKHNlbGYuX3NvY2tldFRpbWVvdXQpIHtcblx0XHRzZWxmLl9zb2NrZXRUaW1lciA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuZW1pdCgndGltZW91dCcpXG5cdFx0fSwgc2VsZi5fc29ja2V0VGltZW91dClcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IENsaWVudFJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRzZWxmLl9kZXN0cm95ZWQgPSB0cnVlXG5cdHNlbGYuX3Jlc2V0VGltZXJzKHRydWUpXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdGVsc2UgaWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblxuXHRpZiAoZXJyKVxuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gZGF0YVxuXHRcdGRhdGEgPSB1bmRlZmluZWRcblx0fVxuXG5cdHN0cmVhbS5Xcml0YWJsZS5wcm90b3R5cGUuZW5kLmNhbGwoc2VsZiwgZGF0YSwgZW5jb2RpbmcsIGNiKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQsIGNiKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChjYilcblx0XHRzZWxmLm9uY2UoJ3RpbWVvdXQnLCBjYilcblxuXHRzZWxmLl9zb2NrZXRUaW1lb3V0ID0gdGltZW91dFxuXHRzZWxmLl9yZXNldFRpbWVycyhmYWxzZSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZmx1c2hIZWFkZXJzID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIHJTdGF0ZXMgPSBleHBvcnRzLnJlYWR5U3RhdGVzID0ge1xuXHRVTlNFTlQ6IDAsXG5cdE9QRU5FRDogMSxcblx0SEVBREVSU19SRUNFSVZFRDogMixcblx0TE9BRElORzogMyxcblx0RE9ORTogNFxufVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gZXhwb3J0cy5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbiAoeGhyLCByZXNwb25zZSwgbW9kZSwgcmVzZXRUaW1lcnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5SZWFkYWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fbW9kZSA9IG1vZGVcblx0c2VsZi5oZWFkZXJzID0ge31cblx0c2VsZi5yYXdIZWFkZXJzID0gW11cblx0c2VsZi50cmFpbGVycyA9IHt9XG5cdHNlbGYucmF3VHJhaWxlcnMgPSBbXVxuXG5cdC8vIEZha2UgdGhlICdjbG9zZScgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgJ2VuZCcgZmlyZXNcblx0c2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZSBuZXh0VGljayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCB0aGUgJ3JlcXVlc3QnIG1vZHVsZSBmcm9tIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcFxuXHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCdjbG9zZScpXG5cdFx0fSlcblx0fSlcblxuXHRpZiAobW9kZSA9PT0gJ2ZldGNoJykge1xuXHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXG5cdFx0c2VsZi51cmwgPSByZXNwb25zZS51cmxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSByZXNwb25zZS5zdGF0dXNUZXh0XG5cdFx0XG5cdFx0cmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIsIGtleSl7XG5cdFx0XHRzZWxmLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gaGVhZGVyXG5cdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChrZXksIGhlYWRlcilcblx0XHR9KVxuXG5cdFx0aWYgKGNhcGFiaWxpdHkud3JpdGFibGVTdHJlYW0pIHtcblx0XHRcdHZhciB3cml0YWJsZSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG5cdFx0XHRcdHdyaXRlOiBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyhmYWxzZSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKHNlbGYucHVzaChCdWZmZXIuZnJvbShjaHVuaykpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSByZXNvbHZlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc3BvbnNlLmJvZHkucGlwZVRvKHdyaXRhYmxlKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBjYXRjaCAoZSkge30gLy8gcGlwZVRvIG1ldGhvZCBpc24ndCBkZWZpbmVkLiBDYW4ndCBmaW5kIGEgYmV0dGVyIHdheSB0byBmZWF0dXJlIHRlc3QgdGhpc1xuXHRcdH1cblx0XHQvLyBmYWxsYmFjayBmb3Igd2hlbiB3cml0YWJsZVN0cmVhbSBvciBwaXBlVG8gYXJlbid0IGF2YWlsYWJsZVxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRyZXNldFRpbWVycyhyZXN1bHQuZG9uZSlcblx0XHRcdFx0aWYgKHJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKHJlc3VsdC52YWx1ZSkpXG5cdFx0XHRcdHJlYWQoKVxuXHRcdFx0fSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0cmVhZCgpXG5cdH0gZWxzZSB7XG5cdFx0c2VsZi5feGhyID0geGhyXG5cdFx0c2VsZi5fcG9zID0gMFxuXG5cdFx0c2VsZi51cmwgPSB4aHIucmVzcG9uc2VVUkxcblx0XHRzZWxmLnN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzXG5cdFx0c2VsZi5zdGF0dXNNZXNzYWdlID0geGhyLnN0YXR1c1RleHRcblx0XHR2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pXG5cdFx0aGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHZhciBtYXRjaGVzID0gaGVhZGVyLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pXG5cdFx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0XHR2YXIga2V5ID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuXHRcdFx0XHRcdGlmIChzZWxmLmhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IFtdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldLnB1c2gobWF0Y2hlc1syXSlcblx0XHRcdFx0fSBlbHNlIGlmIChzZWxmLmhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gKz0gJywgJyArIG1hdGNoZXNbMl1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSA9IG1hdGNoZXNbMl1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnJhd0hlYWRlcnMucHVzaChtYXRjaGVzWzFdLCBtYXRjaGVzWzJdKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzZWxmLl9jaGFyc2V0ID0gJ3gtdXNlci1kZWZpbmVkJ1xuXHRcdGlmICghY2FwYWJpbGl0eS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHR2YXIgbWltZVR5cGUgPSBzZWxmLnJhd0hlYWRlcnNbJ21pbWUtdHlwZSddXG5cdFx0XHRpZiAobWltZVR5cGUpIHtcblx0XHRcdFx0dmFyIGNoYXJzZXRNYXRjaCA9IG1pbWVUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9KFteO10pKDt8JCkvKVxuXHRcdFx0XHRpZiAoY2hhcnNldE1hdGNoKSB7XG5cdFx0XHRcdFx0c2VsZi5fY2hhcnNldCA9IGNoYXJzZXRNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghc2VsZi5fY2hhcnNldClcblx0XHRcdFx0c2VsZi5fY2hhcnNldCA9ICd1dGYtOCcgLy8gYmVzdCBndWVzc1xuXHRcdH1cblx0fVxufVxuXG5pbmhlcml0cyhJbmNvbWluZ01lc3NhZ2UsIHN0cmVhbS5SZWFkYWJsZSlcblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHJlc29sdmUgPSBzZWxmLl9yZXN1bWVGZXRjaFxuXHRpZiAocmVzb2x2ZSkge1xuXHRcdHNlbGYuX3Jlc3VtZUZldGNoID0gbnVsbFxuXHRcdHJlc29sdmUoKVxuXHR9XG59XG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAocmVzZXRUaW1lcnMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0dmFyIHhociA9IHNlbGYuX3hoclxuXG5cdHZhciByZXNwb25zZSA9IG51bGxcblx0c3dpdGNoIChzZWxmLl9tb2RlKSB7XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVRleHRcblx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0dmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKVxuXHRcdFx0XHRpZiAoc2VsZi5fY2hhcnNldCA9PT0gJ3gtdXNlci1kZWZpbmVkJykge1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MobmV3RGF0YS5sZW5ndGgpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEYXRhLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdFx0YnVmZmVyW2ldID0gbmV3RGF0YS5jaGFyQ29kZUF0KGkpICYgMHhmZlxuXG5cdFx0XHRcdFx0c2VsZi5wdXNoKGJ1ZmZlcilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobmV3RGF0YSwgc2VsZi5fY2hhcnNldClcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9wb3MgPSByZXNwb25zZS5sZW5ndGhcblx0XHRcdH1cblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkRPTkUgfHwgIXhoci5yZXNwb25zZSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSkpXG5cdFx0XHRicmVha1xuXHRcdGNhc2UgJ21zLXN0cmVhbSc6XG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR2YXIgcmVhZGVyID0gbmV3IGdsb2JhbC5NU1N0cmVhbVJlYWRlcigpXG5cdFx0XHRyZWFkZXIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0LnNsaWNlKHNlbGYuX3BvcykpKSlcblx0XHRcdFx0XHRzZWxmLl9wb3MgPSByZWFkZXIucmVzdWx0LmJ5dGVMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHR9XG5cdFx0XHQvLyByZWFkZXIub25lcnJvciA9ID8/PyAvLyBUT0RPOiB0aGlzXG5cdFx0XHRyZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIocmVzcG9uc2UpXG5cdFx0XHRicmVha1xuXHR9XG5cblx0Ly8gVGhlIG1zLXN0cmVhbSBjYXNlIGhhbmRsZXMgZW5kIHNlcGFyYXRlbHkgaW4gcmVhZGVyLm9ubG9hZCgpXG5cdGlmIChzZWxmLl94aHIucmVhZHlTdGF0ZSA9PT0gclN0YXRlcy5ET05FICYmIHNlbGYuX21vZGUgIT09ICdtcy1zdHJlYW0nKSB7XG5cdFx0cmVzZXRUaW1lcnModHJ1ZSlcblx0XHRzZWxmLnB1c2gobnVsbClcblx0fVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBzaGlmdFxuXG5mdW5jdGlvbiBzaGlmdCAoc3RyZWFtKSB7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJzKSByZXR1cm4gbnVsbFxuICByZXR1cm4gKHJzLm9iamVjdE1vZGUgfHwgdHlwZW9mIHN0cmVhbS5fZHVwbGV4U3RhdGUgPT09ICdudW1iZXInKSA/IHN0cmVhbS5yZWFkKCkgOiBzdHJlYW0ucmVhZChnZXRTdGF0ZUxlbmd0aChycykpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlTGVuZ3RoIChzdGF0ZSkge1xuICBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCkge1xuICAgIC8vIFNpbmNlIG5vZGUgNi4zLjAgc3RhdGUuYnVmZmVyIGlzIGEgQnVmZmVyTGlzdCBub3QgYW4gYXJyYXlcbiAgICBpZiAoc3RhdGUuYnVmZmVyLmhlYWQpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoXG59XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZShcIi4uL3Byb3RvdHlwZS9pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImxlbmd0aFwiKSkgcmV0dXJuIGZhbHNlO1xuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHJldHVybiBmYWxzZTtcblx0XHRpZiAodHlwZW9mIHZhbHVlLmNhbGwgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUuYXBwbHkgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiAhaXNQcm90b3R5cGUodmFsdWUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgICAgICA9IHJlcXVpcmUoXCIuLi92YWx1ZS9pc1wiKVxuICAsIGlzT2JqZWN0ICAgICAgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpXG4gICwgc3RyaW5nQ29lcmNlICA9IHJlcXVpcmUoXCIuLi9zdHJpbmcvY29lcmNlXCIpXG4gICwgdG9TaG9ydFN0cmluZyA9IHJlcXVpcmUoXCIuL3RvLXNob3J0LXN0cmluZ1wiKTtcblxudmFyIHJlc29sdmVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHZhbHVlKSB7XG5cdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoXCIldlwiLCB0b1Nob3J0U3RyaW5nKHZhbHVlKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdE1lc3NhZ2UsIGlucHV0T3B0aW9ucykge1xuXHRpZiAoIWlzT2JqZWN0KGlucHV0T3B0aW9ucykpIHRocm93IG5ldyBUeXBlRXJyb3IocmVzb2x2ZU1lc3NhZ2UoZGVmYXVsdE1lc3NhZ2UsIHZhbHVlKSk7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHtcblx0XHRpZiAoXCJkZWZhdWx0XCIgaW4gaW5wdXRPcHRpb25zKSByZXR1cm4gaW5wdXRPcHRpb25zW1wiZGVmYXVsdFwiXTtcblx0XHRpZiAoaW5wdXRPcHRpb25zLmlzT3B0aW9uYWwpIHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBlcnJvck1lc3NhZ2UgPSBzdHJpbmdDb2VyY2UoaW5wdXRPcHRpb25zLmVycm9yTWVzc2FnZSk7XG5cdGlmICghaXNWYWx1ZShlcnJvck1lc3NhZ2UpKSBlcnJvck1lc3NhZ2UgPSBkZWZhdWx0TWVzc2FnZTtcblx0dGhyb3cgbmV3IFR5cGVFcnJvcihyZXNvbHZlTWVzc2FnZShlcnJvck1lc3NhZ2UsIHZhbHVlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0dHJ5IHsgcmV0dXJuIFN0cmluZyh2YWx1ZSk7IH1cblx0XHRjYXRjaCAoZXJyb3IyKSB7IHJldHVybiBudWxsOyB9XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHNhZmVUb1N0cmluZyA9IHJlcXVpcmUoXCIuL3NhZmUtdG8tc3RyaW5nXCIpO1xuXG52YXIgcmVOZXdMaW5lID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0dmFyIHN0cmluZyA9IHNhZmVUb1N0cmluZyh2YWx1ZSk7XG5cdGlmIChzdHJpbmcgPT09IG51bGwpIHJldHVybiBcIjxOb24tY29lcmNpYmxlIHRvIHN0cmluZyB2YWx1ZT5cIjtcblx0Ly8gVHJpbSBpZiB0b28gbG9uZ1xuXHRpZiAoc3RyaW5nLmxlbmd0aCA+IDEwMCkgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIDk5KSArIFwi4oCmXCI7XG5cdC8vIFJlcGxhY2UgZXZlbnR1YWwgbmV3IGxpbmVzXG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlTmV3TGluZSwgZnVuY3Rpb24gKGNoYXIpIHtcblx0XHRzd2l0Y2ggKGNoYXIpIHtcblx0XHRcdGNhc2UgXCJcXG5cIjpcblx0XHRcdFx0cmV0dXJuIFwiXFxcXG5cIjtcblx0XHRcdGNhc2UgXCJcXHJcIjpcblx0XHRcdFx0cmV0dXJuIFwiXFxcXHJcIjtcblx0XHRcdGNhc2UgXCJcXHUyMDI4XCI6XG5cdFx0XHRcdHJldHVybiBcIlxcXFx1MjAyOFwiO1xuXHRcdFx0Y2FzZSBcIlxcdTIwMjlcIjpcblx0XHRcdFx0cmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXJcIik7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHN0cmluZztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi4vdmFsdWUvaXNcIik7XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIHBvc3NpYmxlVHlwZXMgPSB7IFwib2JqZWN0XCI6IHRydWUsIFwiZnVuY3Rpb25cIjogdHJ1ZSwgXCJ1bmRlZmluZWRcIjogdHJ1ZSAvKiBkb2N1bWVudC5hbGwgKi8gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChwb3NzaWJsZVR5cGVzLCB0eXBlb2YgdmFsdWUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVzb2x2ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuLi9saWIvcmVzb2x2ZS1leGNlcHRpb25cIilcbiAgLCBpcyAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHRpZiAoaXModmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiByZXNvbHZlRXhjZXB0aW9uKHZhbHVlLCBcIiV2IGlzIG5vdCBhIHBsYWluIGZ1bmN0aW9uXCIsIGFyZ3VtZW50c1sxXSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uL2lzXCIpO1xuXG52YXIgY2xhc3NSZSA9IC9eXFxzKmNsYXNzW1xcc3svfV0vLCBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChjbGFzc1JlLnRlc3QoZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoXCIuLi9vYmplY3QvaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNPYmplY3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0aWYgKCF2YWx1ZS5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgPSByZXF1aXJlKFwiLi4vdmFsdWUvaXNcIilcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoXCIuLi9vYmplY3QvaXNcIik7XG5cbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHJldHVybiBudWxsO1xuXHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0Ly8gUmVqZWN0IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgY29lcmNpb25cblx0XHR2YXIgdmFsdWVUb1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nO1xuXHRcdGlmICh0eXBlb2YgdmFsdWVUb1N0cmluZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcblx0XHRpZiAodmFsdWVUb1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcpIHJldHVybiBudWxsO1xuXHRcdC8vIE5vdGU6IEl0IGNhbiBiZSBvYmplY3QgY29taW5nIGZyb20gb3RoZXIgcmVhbG0sIHN0aWxsIGFzIHRoZXJlJ3Mgbm8gRVMzIGFuZCBDU1AgY29tcGxpYW50XG5cdFx0Ly8gd2F5IHRvIHJlc29sdmUgaXRzIHJlYWxtJ3MgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBpdCdzIGxlZnQgYXMgbm90IGFkZHJlc3NlZCBlZGdlIGNhc2Vcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBcIlwiICsgdmFsdWU7IC8vIEVuc3VyZSBpbXBsaWNpdCBjb2VyY2lvblxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZXNvbHZlRXhjZXB0aW9uID0gcmVxdWlyZShcIi4uL2xpYi9yZXNvbHZlLWV4Y2VwdGlvblwiKVxuICAsIGlzICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9pc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUvKiwgb3B0aW9ucyovKSB7XG5cdGlmIChpcyh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHJlc29sdmVFeGNlcHRpb24odmFsdWUsIFwiQ2Fubm90IHVzZSAldlwiLCBhcmd1bWVudHNbMV0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzMgc2FmZVxudmFyIF91bmRlZmluZWQgPSB2b2lkIDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gX3VuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbDsgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIndXNlIHN0cmljdCdcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxudmFyIGR1cGxleGlmeSA9IHJlcXVpcmUoJ2R1cGxleGlmeScpXG52YXIgV1MgPSByZXF1aXJlKCd3cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTdHJlYW1cblxuZnVuY3Rpb24gYnVpbGRQcm94eSAob3B0aW9ucywgc29ja2V0V3JpdGUsIHNvY2tldEVuZCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKHtcbiAgICBvYmplY3RNb2RlOiBvcHRpb25zLm9iamVjdE1vZGVcbiAgfSlcblxuICBwcm94eS5fd3JpdGUgPSBzb2NrZXRXcml0ZVxuICBwcm94eS5fZmx1c2ggPSBzb2NrZXRFbmRcblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0U3RyZWFtKHRhcmdldCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIHZhciBzdHJlYW0sIHNvY2tldFxuXG4gIHZhciBpc0Jyb3dzZXIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcbiAgdmFyIGlzTmF0aXZlID0gISFnbG9iYWwuV2ViU29ja2V0XG4gIHZhciBzb2NrZXRXcml0ZSA9IGlzQnJvd3NlciA/IHNvY2tldFdyaXRlQnJvd3NlciA6IHNvY2tldFdyaXRlTm9kZVxuXG4gIGlmIChwcm90b2NvbHMgJiYgIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHByb3RvY29scykge1xuICAgIC8vIGFjY2VwdCB0aGUgXCJvcHRpb25zXCIgT2JqZWN0IGFzIHRoZSAybmQgYXJndW1lbnRcbiAgICBvcHRpb25zID0gcHJvdG9jb2xzXG4gICAgcHJvdG9jb2xzID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvdG9jb2wpKSB7XG4gICAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5vYmplY3RNb2RlID0gIShvcHRpb25zLmJpbmFyeSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmJpbmFyeSA9PT0gdW5kZWZpbmVkKVxuICB9XG5cbiAgdmFyIHByb3h5ID0gYnVpbGRQcm94eShvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKVxuXG4gIGlmICghb3B0aW9ucy5vYmplY3RNb2RlKSB7XG4gICAgcHJveHkuX3dyaXRldiA9IHdyaXRldlxuICB9XG5cbiAgLy8gYnJvd3NlciBvbmx5OiBzZXRzIHRoZSBtYXhpbXVtIHNvY2tldCBidWZmZXIgc2l6ZSBiZWZvcmUgdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyU2l6ZSA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclNpemUgfHwgMTAyNCAqIDUxMlxuXG4gIC8vIGJyb3dzZXIgb25seTogaG93IGxvbmcgdG8gd2FpdCB3aGVuIHRocm90dGxpbmdcbiAgdmFyIGJ1ZmZlclRpbWVvdXQgPSBvcHRpb25zLmJyb3dzZXJCdWZmZXJUaW1lb3V0IHx8IDEwMDBcblxuICAvLyB1c2UgZXhpc3RpbmcgV2ViU29ja2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgc29ja2V0ID0gdGFyZ2V0XG4gIC8vIG90aGVyd2lzZSBtYWtlIGEgbmV3IG9uZVxuICB9IGVsc2Uge1xuICAgIC8vIHNwZWNpYWwgY29uc3RydWN0b3IgdHJlYXRtZW50IGZvciBuYXRpdmUgd2Vic29ja2V0cyBpbiBicm93c2Vycywgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL3dlYnNvY2tldC1zdHJlYW0vaXNzdWVzLzgyXG4gICAgaWYgKGlzTmF0aXZlICYmIGlzQnJvd3Nlcikge1xuICAgICAgc29ja2V0ID0gbmV3IFdTKHRhcmdldCwgcHJvdG9jb2xzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgc29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIH1cblxuICAvLyB3YXMgYWxyZWFkeSBvcGVuIHdoZW4gcGFzc2VkIGluXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0Lk9QRU4pIHtcbiAgICBzdHJlYW0gPSBwcm94eVxuICB9IGVsc2UgaWYgKGlzQnJvd3Nlcikge1xuICAgIHN0cmVhbSA9IHByb3h5XG4gICAgc3RyZWFtLmNvcmsoKVxuICAgIHNvY2tldC5vbm9wZW4gPSBvbm9wZW5Ccm93c2VyXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gZHVwbGV4aWZ5Lm9iaigpXG4gICAgc29ja2V0Lm9ub3BlbiA9IG9ub3BlblxuICB9XG5cbiAgc3RyZWFtLnNvY2tldCA9IHNvY2tldFxuXG4gIHNvY2tldC5vbmNsb3NlID0gb25jbG9zZVxuICBzb2NrZXQub25lcnJvciA9IG9uZXJyb3JcbiAgc29ja2V0Lm9ubWVzc2FnZSA9IG9ubWVzc2FnZVxuXG4gIHByb3h5Lm9uKCdjbG9zZScsIGRlc3Ryb3kpXG5cbiAgdmFyIGNvZXJjZVRvQnVmZmVyID0gIW9wdGlvbnMub2JqZWN0TW9kZVxuXG4gIGZ1bmN0aW9uIHNvY2tldFdyaXRlTm9kZShjaHVuaywgZW5jLCBuZXh0KSB7XG4gICAgLy8gYXZvaWQgZXJyb3JzLCB0aGlzIG5ldmVyIGhhcHBlbnMgdW5sZXNzXG4gICAgLy8gZGVzdHJveSgpIGlzIGNhbGxlZFxuICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gc29ja2V0Lk9QRU4pIHtcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvZXJjZVRvQnVmZmVyICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICd1dGY4JylcbiAgICB9XG4gICAgc29ja2V0LnNlbmQoY2h1bmssIG5leHQpXG4gIH1cblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZUJyb3dzZXIoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIGlmIChzb2NrZXQuYnVmZmVyZWRBbW91bnQgPiBidWZmZXJTaXplKSB7XG4gICAgICBzZXRUaW1lb3V0KHNvY2tldFdyaXRlQnJvd3NlciwgYnVmZmVyVGltZW91dCwgY2h1bmssIGVuYywgbmV4dClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAndXRmOCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNvY2tldC5zZW5kKGNodW5rKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICByZXR1cm4gbmV4dChlcnIpXG4gICAgfVxuXG4gICAgbmV4dCgpXG4gIH1cblxuICBmdW5jdGlvbiBzb2NrZXRFbmQoZG9uZSkge1xuICAgIHNvY2tldC5jbG9zZSgpXG4gICAgZG9uZSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbm9wZW4oKSB7XG4gICAgc3RyZWFtLnNldFJlYWRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5zZXRXcml0YWJsZShwcm94eSlcbiAgICBzdHJlYW0uZW1pdCgnY29ubmVjdCcpXG4gIH1cblxuICBmdW5jdGlvbiBvbm9wZW5Ccm93c2VyICgpIHtcbiAgICBzdHJlYW0udW5jb3JrKClcbiAgICBzdHJlYW0uZW1pdCgnY29ubmVjdCcpXG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHN0cmVhbS5lbmQoKVxuICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG5cbiAgZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgIHByb3h5LnB1c2goZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgc29ja2V0LmNsb3NlKClcbiAgfVxuXG4gIC8vIHRoaXMgaXMgdG8gYmUgZW5hYmxlZCBvbmx5IGlmIG9iamVjdE1vZGUgaXMgZmFsc2VcbiAgZnVuY3Rpb24gd3JpdGV2IChjaHVua3MsIGNiKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBuZXcgQXJyYXkoY2h1bmtzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBjaHVua3NbaV0uY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBCdWZmZXIuZnJvbShjaHVua3NbaV0sICd1dGY4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnNbaV0gPSBjaHVua3NbaV0uY2h1bmtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl93cml0ZShCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLCAnYmluYXJ5JywgY2IpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG4iLCJcbnZhciB3cyA9IG51bGxcblxuaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gV2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiBNb3pXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gTW96V2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3NcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdGlmICh0eXBlb2YgZ1t0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kTmFtZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghZm91bmROYW1lKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKG5hbWUgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZE5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZE5hbWU7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCFpc1R5cGVkQXJyYXkodmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkgeyByZXR1cm4gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gYXVkaW8uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxNi4gYXVkaW9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBwYXJzZUF1ZGlvVHlwZShzdHIsIGlucHV0LCBvdXRwdXQpIHtcbiAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIGxldCByZXN1bHQgPSAnJztcblxuICBpZiAoc3RyLmluZGV4T2YoJ2lucHV0JykgPj0gMCkgeyByZXN1bHQgPSAnTWljcm9waG9uZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdkaXNwbGF5IGF1ZGlvJykgPj0gMCkgeyByZXN1bHQgPSAnU3BlYWtlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdzcGVhaycpID49IDApIHsgcmVzdWx0ID0gJ1NwZWFrZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbGF1dCcpID49IDApIHsgcmVzdWx0ID0gJ1NwZWFrZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbG91ZCcpID49IDApIHsgcmVzdWx0ID0gJ1NwZWFrZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaGVhZCcpID49IDApIHsgcmVzdWx0ID0gJ0hlYWRzZXQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbWljJykgPj0gMCkgeyByZXN1bHQgPSAnTWljcm9waG9uZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtaWtyJykgPj0gMCkgeyByZXN1bHQgPSAnTWljcm9waG9uZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdwaG9uZScpID49IDApIHsgcmVzdWx0ID0gJ1Bob25lJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2NvbnRyb2xsJykgPj0gMCkgeyByZXN1bHQgPSAnQ29udHJvbGxlcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdsaW5lIG8nKSA+PSAwKSB7IHJlc3VsdCA9ICdMaW5lIE91dCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdkaWdpdGFsIG8nKSA+PSAwKSB7IHJlc3VsdCA9ICdEaWdpdGFsIE91dCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdzbWFydCBzb3VuZCB0ZWNobm9sb2d5JykgPj0gMCkgeyByZXN1bHQgPSAnRGlnaXRhbCBTaWduYWwgUHJvY2Vzc29yJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2hpZ2ggZGVmaW5pdGlvbiBhdWRpbycpID49IDApIHsgcmVzdWx0ID0gJ1NvdW5kIERyaXZlcic7IH1cblxuICBpZiAoIXJlc3VsdCAmJiBvdXRwdXQpIHtcbiAgICByZXN1bHQgPSAnU3BlYWtlcic7XG4gIH0gZWxzZSBpZiAoIXJlc3VsdCAmJiBpbnB1dCkge1xuICAgIHJlc3VsdCA9ICdNaWNyb3Bob25lJztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGdldExpbnV4QXVkaW9QY2koKSB7XG4gIGxldCBjbWQgPSAnbHNwY2kgLXYgMj4vZGV2L251bGwnO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHRyeSB7XG4gICAgY29uc3QgcGFydHMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxcbicpO1xuICAgIHBhcnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBsaW5lcyA9IGVsZW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgaWYgKGxpbmVzICYmIGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2F1ZGlvJykgPj0gMCkge1xuICAgICAgICBjb25zdCBhdWRpbyA9IHt9O1xuICAgICAgICBhdWRpby5zbG90SWQgPSBsaW5lc1swXS5zcGxpdCgnICcpWzBdO1xuICAgICAgICBhdWRpby5kcml2ZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnS2VybmVsIGRyaXZlciBpbiB1c2UnLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdLZXJuZWwgbW9kdWxlcycsICc6JywgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGF1ZGlvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4QXVkaW9QY2lNTShsaW5lcywgYXVkaW9QQ0kpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHNsb3RJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTbG90Jyk7XG5cbiAgY29uc3QgcGNpTWF0Y2ggPSBhdWRpb1BDSS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xvdElkID09PSBzbG90SWQ7IH0pO1xuXG4gIHJlc3VsdC5pZCA9IHNsb3RJZDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU0RldmljZScpO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NWZW5kb3InKTtcbiAgcmVzdWx0LnJldmlzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JldicpO1xuICByZXN1bHQuZHJpdmVyID0gcGNpTWF0Y2ggJiYgcGNpTWF0Y2gubGVuZ3RoID09PSAxICYmIHBjaU1hdGNoWzBdLmRyaXZlciA/IHBjaU1hdGNoWzBdLmRyaXZlciA6ICcnO1xuICByZXN1bHQuZGVmYXVsdCA9IG51bGw7XG4gIHJlc3VsdC5jaGFubmVsID0gJ1BDSWUnO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQXVkaW9UeXBlKHJlc3VsdC5uYW1lLCBudWxsLCBudWxsKTtcbiAgcmVzdWx0LmluID0gbnVsbDtcbiAgcmVzdWx0Lm91dCA9IG51bGw7XG4gIHJlc3VsdC5zdGF0dXMgPSAnb25saW5lJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhcndpbkNoYW5uZWwoc3RyKSB7XG4gIGxldCByZXN1bHQgPSAnJztcblxuICBpZiAoc3RyLmluZGV4T2YoJ2J1aWx0aW4nKSA+PSAwKSB7IHJlc3VsdCA9ICdCdWlsdC1Jbic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdleHRlcm4nKSA+PSAwKSB7IHJlc3VsdCA9ICdBdWRpby1KYWNrJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2hkbWknKSA+PSAwKSB7IHJlc3VsdCA9ICdIRE1JJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2Rpc3BsYXlwb3J0JykgPj0gMCkgeyByZXN1bHQgPSAnRGlzcGxheS1Qb3J0JzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3VzYicpID49IDApIHsgcmVzdWx0ID0gJ1VTQic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdwY2knKSA+PSAwKSB7IHJlc3VsdCA9ICdQQ0llJzsgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGFyd2luQXVkaW8oYXVkaW9PYmplY3QsIGlkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjaGFubmVsU3RyID0gKChhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX3RyYW5zcG9ydCB8fCAnJykgKyAnICcgKyAoYXVkaW9PYmplY3QuX25hbWUgfHwgJycpKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJlc3VsdC5pZCA9IGlkO1xuICByZXN1bHQubmFtZSA9IGF1ZGlvT2JqZWN0Ll9uYW1lO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV9tYW51ZmFjdHVyZXI7XG4gIHJlc3VsdC5yZXZpc2lvbiA9IG51bGw7XG4gIHJlc3VsdC5kcml2ZXIgPSBudWxsO1xuICByZXN1bHQuZGVmYXVsdCA9ICEhKGF1ZGlvT2JqZWN0LmNvcmVhdWRpb19kZWZhdWx0X2F1ZGlvX2lucHV0X2RldmljZSB8fCAnJykgfHwgISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RlZmF1bHRfYXVkaW9fb3V0cHV0X2RldmljZSB8fCAnJyk7XG4gIHJlc3VsdC5jaGFubmVsID0gcGFyc2VEYXJ3aW5DaGFubmVsKGNoYW5uZWxTdHIpO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQXVkaW9UeXBlKHJlc3VsdC5uYW1lLCAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX2lucHV0IHx8ICcnKSwgISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV9vdXRwdXQgfHwgJycpKTtcbiAgcmVzdWx0LmluID0gISEoYXVkaW9PYmplY3QuY29yZWF1ZGlvX2RldmljZV9pbnB1dCB8fCAnJyk7XG4gIHJlc3VsdC5vdXQgPSAhIShhdWRpb09iamVjdC5jb3JlYXVkaW9fZGV2aWNlX291dHB1dCB8fCAnJyk7XG4gIHJlc3VsdC5zdGF0dXMgPSAnb25saW5lJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NBdWRpbyhsaW5lcykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qgc3RhdHVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXR1c0luZm8nLCAnOicpO1xuXG4gIHJlc3VsdC5pZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXZpY2VJRCcsICc6Jyk7IC8vIFBOUERldmljZUlEPz9cbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6Jyk7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgcmVzdWx0LnJldmlzaW9uID0gbnVsbDtcbiAgcmVzdWx0LmRyaXZlciA9IG51bGw7XG4gIHJlc3VsdC5kZWZhdWx0ID0gbnVsbDtcbiAgcmVzdWx0LmNoYW5uZWwgPSBudWxsO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQXVkaW9UeXBlKHJlc3VsdC5uYW1lLCBudWxsLCBudWxsKTtcbiAgcmVzdWx0LmluID0gbnVsbDtcbiAgcmVzdWx0Lm91dCA9IG51bGw7XG4gIHJlc3VsdC5zdGF0dXMgPSBzdGF0dXM7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXVkaW8oY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBsZXQgY21kID0gJ2xzcGNpIC12bW0gMj4vZGV2L251bGwnO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAvLyBQQ0lcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1BDSSA9IGdldExpbnV4QXVkaW9QY2koKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxcbicpO1xuICAgICAgICAgICAgcGFydHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBlbGVtZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgaWYgKHV0aWwuZ2V0VmFsdWUobGluZXMsICdjbGFzcycsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhdWRpbycpID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IHBhcnNlTGludXhBdWRpb1BjaU1NKGxpbmVzLCBhdWRpb1BDSSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXVkaW8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgU1BBdWRpb0RhdGFUeXBlIC1qc29uJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2JqID0gSlNPTi5wYXJzZShzdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGlmIChvdXRPYmouU1BBdWRpb0RhdGFUeXBlICYmIG91dE9iai5TUEF1ZGlvRGF0YVR5cGUubGVuZ3RoICYmIG91dE9iai5TUEF1ZGlvRGF0YVR5cGVbMF0gJiYgb3V0T2JqLlNQQXVkaW9EYXRhVHlwZVswXVsnX2l0ZW1zJ10gJiYgb3V0T2JqLlNQQXVkaW9EYXRhVHlwZVswXVsnX2l0ZW1zJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRPYmouU1BBdWRpb0RhdGFUeXBlWzBdWydfaXRlbXMnXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBwYXJzZURhcndpbkF1ZGlvKG91dE9iai5TUEF1ZGlvRGF0YVR5cGVbMF1bJ19pdGVtcyddW2ldLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGF1ZGlvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Tb3VuZERldmljZSB8IHNlbGVjdCBEZXZpY2VJRCxTdGF0dXNJbmZvLE5hbWUsTWFudWZhY3R1cmVyIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgcGFydHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBlbGVtZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgaWYgKHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlV2luZG93c0F1ZGlvKGxpbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmF1ZGlvID0gYXVkaW87XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2s7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBiYXR0ZXJ5LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gNi4gQmF0dGVyeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBwYXJzZVdpbkJhdHRlcnlQYXJ0KGxpbmVzLCBkZXNpZ25lZENhcGFjaXR5LCBmdWxsQ2hhcmdlQ2FwYWNpdHkpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGxldCBzdGF0dXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQmF0dGVyeVN0YXR1cycsICc6JykudHJpbSgpO1xuICAvLyAxID0gXCJEaXNjaGFyZ2luZ1wiXG4gIC8vIDIgPSBcIk9uIEEvQ1wiXG4gIC8vIDMgPSBcIkZ1bGx5IENoYXJnZWRcIlxuICAvLyA0ID0gXCJMb3dcIlxuICAvLyA1ID0gXCJDcml0aWNhbFwiXG4gIC8vIDYgPSBcIkNoYXJnaW5nXCJcbiAgLy8gNyA9IFwiQ2hhcmdpbmcgSGlnaFwiXG4gIC8vIDggPSBcIkNoYXJnaW5nIExvd1wiXG4gIC8vIDkgPSBcIkNoYXJnaW5nIENyaXRpY2FsXCJcbiAgLy8gMTAgPSBcIlVuZGVmaW5lZFwiXG4gIC8vIDExID0gXCJQYXJ0aWFsbHkgQ2hhcmdlZFwiXG4gIGlmIChzdGF0dXMgPj0gMCkge1xuICAgIGNvbnN0IHN0YXR1c1ZhbHVlID0gc3RhdHVzID8gcGFyc2VJbnQoc3RhdHVzKSA6IDA7XG4gICAgcmVzdWx0LnN0YXR1cyA9IHN0YXR1c1ZhbHVlO1xuICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gdHJ1ZTtcbiAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBmdWxsQ2hhcmdlQ2FwYWNpdHkgfHwgcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Rlc2lnbkNhcGFjaXR5JywgJzonKSB8fCAwKTtcbiAgICByZXN1bHQuZGVzaWduZWRDYXBhY2l0eSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXNpZ25DYXBhY2l0eScsICc6JykgfHwgZGVzaWduZWRDYXBhY2l0eSk7XG4gICAgcmVzdWx0LnZvbHRhZ2UgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVzaWduVm9sdGFnZScsICc6JykgfHwgMCkgLyAxMDAwLjA7XG4gICAgcmVzdWx0LmNhcGFjaXR5VW5pdCA9ICdtV2gnO1xuICAgIHJlc3VsdC5wZXJjZW50ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0VzdGltYXRlZENoYXJnZVJlbWFpbmluZycsICc6JykgfHwgMCk7XG4gICAgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSA9IHBhcnNlSW50KHJlc3VsdC5tYXhDYXBhY2l0eSAqIHJlc3VsdC5wZXJjZW50IC8gMTAwKTtcbiAgICByZXN1bHQuaXNDaGFyZ2luZyA9IChzdGF0dXNWYWx1ZSA+PSA2ICYmIHN0YXR1c1ZhbHVlIDw9IDkpIHx8IHN0YXR1c1ZhbHVlID09PSAxMSB8fCAoKHN0YXR1c1ZhbHVlICE9PSAzKSAmJiAoc3RhdHVzVmFsdWUgIT09IDEpICYmIHJlc3VsdC5wZXJjZW50IDwgMTAwKTtcbiAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSByZXN1bHQuaXNDaGFyZ2luZyB8fCBzdGF0dXNWYWx1ZSA9PT0gMjtcbiAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGV2aWNlSUQnLCAnOicpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5zdGF0dXMgPSAtMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBoYXNCYXR0ZXJ5OiBmYWxzZSxcbiAgICAgICAgY3ljbGVDb3VudDogMCxcbiAgICAgICAgaXNDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgIGRlc2lnbmVkQ2FwYWNpdHk6IDAsXG4gICAgICAgIG1heENhcGFjaXR5OiAwLFxuICAgICAgICBjdXJyZW50Q2FwYWNpdHk6IDAsXG4gICAgICAgIHZvbHRhZ2U6IDAsXG4gICAgICAgIGNhcGFjaXR5VW5pdDogJycsXG4gICAgICAgIHBlcmNlbnQ6IDAsXG4gICAgICAgIHRpbWVSZW1haW5pbmc6IG51bGwsXG4gICAgICAgIGFjQ29ubmVjdGVkOiB0cnVlLFxuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICBzZXJpYWw6ICcnXG4gICAgICB9O1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGxldCBiYXR0ZXJ5X3BhdGggPSAnJztcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0JBVDEvdWV2ZW50JykpIHtcbiAgICAgICAgICBiYXR0ZXJ5X3BhdGggPSAnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQkFUMS8nO1xuICAgICAgICB9IGVsc2UgaWYgKGZzLmV4aXN0c1N5bmMoJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0JBVDAvdWV2ZW50JykpIHtcbiAgICAgICAgICBiYXR0ZXJ5X3BhdGggPSAnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQkFUMC8nO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFjQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBhY1BhdGggPSAnJztcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0FDL29ubGluZScpKSB7XG4gICAgICAgICAgYWNQYXRoID0gJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0FDL29ubGluZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYygnL3N5cy9jbGFzcy9wb3dlcl9zdXBwbHkvQUMwL29ubGluZScpKSB7XG4gICAgICAgICAgYWNQYXRoID0gJy9zeXMvY2xhc3MvcG93ZXJfc3VwcGx5L0FDMC9vbmxpbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjUGF0aCkge1xuICAgICAgICAgIGNvbnN0IGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMoYWNQYXRoKTtcbiAgICAgICAgICBhY0Nvbm5lY3RlZCA9IGZpbGUudG9TdHJpbmcoKS50cmltKCkgPT09ICcxJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXR0ZXJ5X3BhdGgpIHtcbiAgICAgICAgICBmcy5yZWFkRmlsZShiYXR0ZXJ5X3BhdGggKyAndWV2ZW50JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gKHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfU1RBVFVTJywgJz0nKS50b0xvd2VyQ2FzZSgpID09PSAnY2hhcmdpbmcnKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gYWNDb25uZWN0ZWQgfHwgcmVzdWx0LmlzQ2hhcmdpbmc7XG4gICAgICAgICAgICAgIHJlc3VsdC52b2x0YWdlID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9WT0xUQUdFX05PVycsICc9JyksIDEwKSAvIDEwMDAwMDAuMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhcGFjaXR5VW5pdCA9IHJlc3VsdC52b2x0YWdlID8gJ21XaCcgOiAnbUFoJztcbiAgICAgICAgICAgICAgcmVzdWx0LmN5Y2xlQ291bnQgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NZQ0xFX0NPVU5UJywgJz0nKSwgMTApO1xuICAgICAgICAgICAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ0hBUkdFX0ZVTEwnLCAnPScsIHRydWUsIHRydWUpLCAxMCkgLyAxMDAwLjAgKiAocmVzdWx0LnZvbHRhZ2UgfHwgMSkpO1xuICAgICAgICAgICAgICBjb25zdCBkZXNpbmdlZE1pblZvbHRhZ2UgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX1ZPTFRBR0VfTUlOX0RFU0lHTicsICc9JyksIDEwKSAvIDEwMDAwMDAuMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmRlc2lnbmVkQ2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ0hBUkdFX0ZVTExfREVTSUdOJywgJz0nLCB0cnVlLCB0cnVlKSwgMTApIC8gMTAwMC4wICogKGRlc2luZ2VkTWluVm9sdGFnZSB8fCByZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ0hBUkdFX05PVycsICc9JyksIDEwKSAvIDEwMDAuMCAqIChyZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0Lm1heENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9FTkVSR1lfRlVMTCcsICc9JywgdHJ1ZSwgdHJ1ZSksIDEwKSAvIDEwMDAuMDtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGVzaWduZWRDYXBhY2l0eSA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfRU5FUkdZX0ZVTExfREVTSUdOJywgJz0nLCB0cnVlLCB0cnVlKSwgMTApIC8gMTAwMC4wIHwgcmVzdWx0Lm1heENhcGFjaXR5O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0VORVJHWV9OT1cnLCAnPScpLCAxMCkgLyAxMDAwLjA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfQ0FQQUNJVFknLCAnPScpO1xuICAgICAgICAgICAgICBjb25zdCBlbmVyZ3kgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0VORVJHWV9OT1cnLCAnPScpLCAxMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvd2VyID0gcGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9QT1dFUl9OT1cnLCAnPScpLCAxMCk7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE9XRVJfU1VQUExZX0NVUlJFTlRfTk9XJywgJz0nKSwgMTApO1xuXG4gICAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50ID0gcGFyc2VJbnQoJzAnICsgcGVyY2VudCwgMTApO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1heENhcGFjaXR5ICYmIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGFzQmF0dGVyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucGVyY2VudCA9IDEwMC4wICogcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSAvIHJlc3VsdC5tYXhDYXBhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0NoYXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhhc0JhdHRlcnkgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlbmVyZ3kgJiYgcG93ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGltZVJlbWFpbmluZyA9IE1hdGguZmxvb3IoZW5lcmd5IC8gcG93ZXIgKiA2MCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudCAmJiByZXN1bHQuY3VycmVudENhcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRpbWVSZW1haW5pbmcgPSBNYXRoLmZsb29yKHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgLyBjdXJyZW50ICogNjApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC50eXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9URUNITk9MT0dZJywgJz0nKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BPV0VSX1NVUFBMWV9NT0RFTF9OQU1FJywgJz0nKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfTUFOVUZBQ1RVUkVSJywgJz0nKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQT1dFUl9TVVBQTFlfU0VSSUFMX05VTUJFUicsICc9Jyk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnc3lzY3RsIC1pIGh3LmFjcGkuYmF0dGVyeSBody5hY3BpLmFjbGluZScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGNvbnN0IGJhdHRlcmllcyA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5hY3BpLmJhdHRlcnkudW5pdHMnKSwgMTApO1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuYWNwaS5iYXR0ZXJ5LmxpZmUnKSwgMTApO1xuICAgICAgICAgIHJlc3VsdC5oYXNCYXR0ZXJ5ID0gKGJhdHRlcmllcyA+IDApO1xuICAgICAgICAgIHJlc3VsdC5jeWNsZUNvdW50ID0gbnVsbDtcbiAgICAgICAgICByZXN1bHQuaXNDaGFyZ2luZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5hY3BpLmFjbGluZScpICE9PSAnMSc7XG4gICAgICAgICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gcmVzdWx0LmlzQ2hhcmdpbmc7XG4gICAgICAgICAgcmVzdWx0Lm1heENhcGFjaXR5ID0gbnVsbDtcbiAgICAgICAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gbnVsbDtcbiAgICAgICAgICByZXN1bHQuY2FwYWNpdHlVbml0ID0gJ3Vua25vd24nO1xuICAgICAgICAgIHJlc3VsdC5wZXJjZW50ID0gYmF0dGVyaWVzID8gcGVyY2VudCA6IG51bGw7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdpb3JlZyAtbiBBcHBsZVNtYXJ0QmF0dGVyeSAtciB8IGVncmVwIFwiQ3ljbGVDb3VudHxJc0NoYXJnaW5nfERlc2lnbkNhcGFjaXR5fE1heENhcGFjaXR5fEN1cnJlbnRDYXBhY2l0eXxCYXR0ZXJ5U2VyaWFsTnVtYmVyfFRpbWVSZW1haW5pbmd8Vm9sdGFnZVwiOyBwbXNldCAtZyBiYXR0IHwgZ3JlcCAlJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5yZXBsYWNlKC8gKy9nLCAnJykucmVwbGFjZSgvXCIrL2csICcnKS5yZXBsYWNlKC8tL2csICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQuY3ljbGVDb3VudCA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdjeWNsZWNvdW50JywgJz0nKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LnZvbHRhZ2UgPSBwYXJzZUludCgnMCcgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdGFnZScsICc9JyksIDEwKSAvIDEwMDAuMDtcbiAgICAgICAgICAgIHJlc3VsdC5jYXBhY2l0eVVuaXQgPSByZXN1bHQudm9sdGFnZSA/ICdtV2gnIDogJ21BaCc7XG4gICAgICAgICAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdhcHBsZXJhd21heGNhcGFjaXR5JywgJz0nKSwgMTApICogKHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgIHJlc3VsdC5jdXJyZW50Q2FwYWNpdHkgPSBNYXRoLnJvdW5kKHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdhcHBsZXJhd2N1cnJlbnRjYXBhY2l0eScsICc9JyksIDEwKSAqIChyZXN1bHQudm9sdGFnZSB8fCAxKSk7XG4gICAgICAgICAgICByZXN1bHQuZGVzaWduZWRDYXBhY2l0eSA9IE1hdGgucm91bmQocGFyc2VJbnQoJzAnICsgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Rlc2lnbkNhcGFjaXR5JywgJz0nKSwgMTApICogKHJlc3VsdC52b2x0YWdlIHx8IDEpKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnQXBwbGUnO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCYXR0ZXJ5U2VyaWFsTnVtYmVyJywgJz0nKTtcbiAgICAgICAgICAgIGxldCBwZXJjZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaW50ZXJuYWwnLCAnQmF0dGVyeScpO1xuICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzWzBdKSB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0czIgPSBwYXJ0c1swXS5zcGxpdCgnXFx0Jyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0czIgJiYgcGFydHMyWzFdKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHBhcnNlRmxvYXQocGFydHMyWzFdLnRyaW0oKS5yZXBsYWNlKC8lL2csICcnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICByZXN1bHQuaXNDaGFyZ2luZyA9IChwYXJ0c1sxXS50cmltKCkgPT09ICdjaGFyZ2luZycpO1xuICAgICAgICAgICAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSAocGFydHNbMV0udHJpbSgpICE9PSAnZGlzY2hhcmdpbmcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5pc0NoYXJnaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lzY2hhcmdpbmcnLCAnPScpLnRvTG93ZXJDYXNlKCkgPT09ICd5ZXMnO1xuICAgICAgICAgICAgICByZXN1bHQuYWNDb25uZWN0ZWQgPSByZXN1bHQuaXNDaGFyZ2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubWF4Q2FwYWNpdHkgJiYgcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSkge1xuICAgICAgICAgICAgICByZXN1bHQuaGFzQmF0dGVyeSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc3VsdC50eXBlID0gJ0xpLWlvbic7XG4gICAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50ID0gcGVyY2VudCAhPT0gbnVsbCA/IHBlcmNlbnQgOiBNYXRoLnJvdW5kKDEwMC4wICogcmVzdWx0LmN1cnJlbnRDYXBhY2l0eSAvIHJlc3VsdC5tYXhDYXBhY2l0eSk7XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0LmlzQ2hhcmdpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGltZVJlbWFpbmluZyA9IHBhcnNlSW50KCcwJyArIHV0aWwuZ2V0VmFsdWUobGluZXMsICdUaW1lUmVtYWluaW5nJywgJz0nKSwgMTApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0JhdHRlcnkgfCBzZWxlY3QgQmF0dGVyeVN0YXR1cywgRGVzaWduQ2FwYWNpdHksIERlc2lnblZvbHRhZ2UsIEVzdGltYXRlZENoYXJnZVJlbWFpbmluZywgRGV2aWNlSUQgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnKEdldC1DaW1JbnN0YW5jZSAtQ2xhc3MgQmF0dGVyeVN0YXRpY0RhdGEgLU5hbWVzcGFjZSBST09UL1dNSSkuRGVzaWduZWRDYXBhY2l0eScpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnKEdldC1DaW1JbnN0YW5jZSAtQ2xhc3MgQmF0dGVyeUZ1bGxDaGFyZ2VkQ2FwYWNpdHkgLU5hbWVzcGFjZSBST09UL1dNSSkuRnVsbENoYXJnZWRDYXBhY2l0eScpKTtcbiAgICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgbGV0IHBhcnRzID0gZGF0YS5yZXN1bHRzWzBdLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgIGxldCBiYXR0ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgY29uc3QgaGFzVmFsdWUgPSB2YWx1ZSA9PiAvXFxTLy50ZXN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZShwYXJ0c1tpXSkgJiYgKCFiYXR0ZXJpZXMubGVuZ3RoIHx8ICFoYXNWYWx1ZShwYXJ0c1tpIC0gMV0pKSkge1xuICAgICAgICAgICAgICAgICAgYmF0dGVyaWVzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzVmFsdWUocGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBiYXR0ZXJpZXNbYmF0dGVyaWVzLmxlbmd0aCAtIDFdLnB1c2gocGFydHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZGVzaWduQ2FwYWNpdGllcyA9IGRhdGEucmVzdWx0c1sxXS5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGUgPT4gZSk7XG4gICAgICAgICAgICAgIGxldCBmdWxsQ2hhcmdlQ2FwYWNpdGllcyA9IGRhdGEucmVzdWx0c1syXS5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGUgPT4gZSk7XG4gICAgICAgICAgICAgIGlmIChiYXR0ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxCYXR0ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdHRlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gYmF0dGVyaWVzW2ldWzBdLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lnbmVkQ2FwYWNpdHkgPSBkZXNpZ25DYXBhY2l0aWVzICYmIGRlc2lnbkNhcGFjaXRpZXMubGVuZ3RoID49IChpICsgMSkgJiYgZGVzaWduQ2FwYWNpdGllc1tpXSA/IHV0aWwudG9JbnQoZGVzaWduQ2FwYWNpdGllc1tpXSkgOiAwO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZnVsbENoYXJnZUNhcGFjaXR5ID0gZnVsbENoYXJnZUNhcGFjaXRpZXMgJiYgZnVsbENoYXJnZUNhcGFjaXRpZXMubGVuZ3RoID49IChpICsgMSkgJiYgZnVsbENoYXJnZUNhcGFjaXRpZXNbaV0gPyB1dGlsLnRvSW50KGZ1bGxDaGFyZ2VDYXBhY2l0aWVzW2ldKSA6IDA7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVdpbkJhdHRlcnlQYXJ0KGxpbmVzLCBkZXNpZ25lZENhcGFjaXR5LCBmdWxsQ2hhcmdlQ2FwYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCAmJiBwYXJzZWQuc3RhdHVzID4gMCAmJiBwYXJzZWQuc3RhdHVzICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaGFzQmF0dGVyeSA9IHBhcnNlZC5oYXNCYXR0ZXJ5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWF4Q2FwYWNpdHkgPSBwYXJzZWQubWF4Q2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZXNpZ25lZENhcGFjaXR5ID0gcGFyc2VkLmRlc2lnbmVkQ2FwYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52b2x0YWdlID0gcGFyc2VkLnZvbHRhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYXBhY2l0eVVuaXQgPSBwYXJzZWQuY2FwYWNpdHlVbml0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucGVyY2VudCA9IHBhcnNlZC5wZXJjZW50O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3VycmVudENhcGFjaXR5ID0gcGFyc2VkLmN1cnJlbnRDYXBhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmlzQ2hhcmdpbmcgPSBwYXJzZWQuaXNDaGFyZ2luZztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFjQ29ubmVjdGVkID0gcGFyc2VkLmFjQ29ubmVjdGVkO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSBwYXJzZWQubW9kZWw7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VkLnN0YXR1cyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEJhdHRlcmllcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JhdHRlcnk6IHBhcnNlZC5oYXNCYXR0ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q2FwYWNpdHk6IHBhcnNlZC5tYXhDYXBhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2lnbmVkQ2FwYWNpdHk6IHBhcnNlZC5kZXNpZ25lZENhcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdGFnZTogcGFyc2VkLnZvbHRhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eVVuaXQ6IHBhcnNlZC5jYXBhY2l0eVVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiBwYXJzZWQucGVyY2VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYXBhY2l0eTogcGFyc2VkLmN1cnJlbnRDYXBhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhcmdpbmc6IHBhcnNlZC5pc0NoYXJnaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZVJlbWFpbmluZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjQ29ubmVjdGVkOiBwYXJzZWQuYWNDb25uZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogcGFyc2VkLm1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCAmJiBhZGRpdGlvbmFsQmF0dGVyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYWRkaXRpb25hbEJhdHRlcmllc1swXTtcbiAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxCYXR0ZXJpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxCYXR0ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuYWRkaXRpb25hbEJhdHRlcmllcyA9IGFkZGl0aW9uYWxCYXR0ZXJpZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBhdWRpby5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDE3LiBibHVldG9vdGhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gcGFyc2VCbHVldG9vdGhUeXBlKHN0cikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHN0ci5pbmRleE9mKCdrZXlib2FyZCcpID49IDApIHsgcmVzdWx0ID0gJ0tleWJvYXJkJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21vdXNlJykgPj0gMCkgeyByZXN1bHQgPSAnTW91c2UnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignc3BlYWtlcicpID49IDApIHsgcmVzdWx0ID0gJ1NwZWFrZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaGVhZHNldCcpID49IDApIHsgcmVzdWx0ID0gJ0hlYWRzZXQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZigncGhvbmUnKSA+PSAwKSB7IHJlc3VsdCA9ICdQaG9uZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdtYWNib29rJykgPj0gMCkgeyByZXN1bHQgPSAnQ29tcHV0ZXInOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaW1hYycpID49IDApIHsgcmVzdWx0ID0gJ0NvbXB1dGVyJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2lwYWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdUYWJsZXQnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignd2F0Y2gnKSA+PSAwKSB7IHJlc3VsdCA9ICdXYXRjaCc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdoZWFkcGhvbmUnKSA+PSAwKSB7IHJlc3VsdCA9ICdIZWFkc2V0JzsgfVxuICAvLyB0byBiZSBjb250aW51ZWQgLi4uXG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VCbHVldG9vdGhNYW51ZmFjdHVyZXIoc3RyKSB7XG4gIGxldCByZXN1bHQgPSBzdHIuc3BsaXQoJyAnKVswXTtcbiAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChzdHIuaW5kZXhPZignYXBwbGUnKSA+PSAwKSB7IHJlc3VsdCA9ICdBcHBsZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdpcGFkJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignaW1hYycpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2lwaG9uZScpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ21hZ2ljIG1vdXNlJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignbWFjYm9vaycpID49IDApIHsgcmVzdWx0ID0gJ0FwcGxlJzsgfVxuICAvLyB0byBiZSBjb250aW51ZWQgLi4uXG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eEJsdWV0b290aEluZm8obGluZXMsIG1hY0FkZHIxLCBtYWNBZGRyMikge1xuICBjb25zdCByZXN1bHQgPSB7fTtcblxuICByZXN1bHQuZGV2aWNlID0gbnVsbDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc9Jyk7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSBudWxsO1xuICByZXN1bHQubWFjRGV2aWNlID0gbWFjQWRkcjE7XG4gIHJlc3VsdC5tYWNIb3N0ID0gbWFjQWRkcjI7XG4gIHJlc3VsdC5iYXR0ZXJ5UGVyY2VudCA9IG51bGw7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VCbHVldG9vdGhUeXBlKHJlc3VsdC5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuICByZXN1bHQuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXJ3aW5CbHVldG9vdGhEZXZpY2VzKGJsdWV0b290aE9iamVjdCwgbWFjQWRkcjIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHR5cGVTdHIgPSAoKGJsdWV0b290aE9iamVjdC5kZXZpY2VfbWlub3JDbGFzc09mRGV2aWNlX3N0cmluZyB8fCBibHVldG9vdGhPYmplY3QuZGV2aWNlX21ham9yQ2xhc3NPZkRldmljZV9zdHJpbmcgfHwgYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9taW5vclR5cGUgfHwgJycpICsgKGJsdWV0b290aE9iamVjdC5kZXZpY2VfbmFtZSB8fCAnJykpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmVzdWx0LmRldmljZSA9IGJsdWV0b290aE9iamVjdC5kZXZpY2Vfc2VydmljZXMgfHwgJyc7XG4gIHJlc3VsdC5uYW1lID0gYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9uYW1lIHx8ICcnO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9tYW51ZmFjdHVyZXIgfHwgcGFyc2VCbHVldG9vdGhNYW51ZmFjdHVyZXIoYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9uYW1lIHx8ICcnKSB8fCAnJztcbiAgcmVzdWx0Lm1hY0RldmljZSA9IChibHVldG9vdGhPYmplY3QuZGV2aWNlX2FkZHIgfHwgYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9hZGRyZXNzIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJzonKTtcbiAgcmVzdWx0Lm1hY0hvc3QgPSBtYWNBZGRyMjtcbiAgcmVzdWx0LmJhdHRlcnlQZXJjZW50ID0gYmx1ZXRvb3RoT2JqZWN0LmRldmljZV9iYXR0ZXJ5UGVyY2VudCB8fCBudWxsO1xuICByZXN1bHQudHlwZSA9IHBhcnNlQmx1ZXRvb3RoVHlwZSh0eXBlU3RyKTtcbiAgcmVzdWx0LmNvbm5lY3RlZCA9IGJsdWV0b290aE9iamVjdC5kZXZpY2VfaXNjb25uZWN0ZWQgPT09ICdhdHRyaWJfWWVzJyB8fCBmYWxzZTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NCbHVldG9vdGgobGluZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgcmVzdWx0LmRldmljZSA9IG51bGw7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpO1xuICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gIHJlc3VsdC5tYWNEZXZpY2UgPSBudWxsO1xuICByZXN1bHQubWFjSG9zdCA9IG51bGw7XG4gIHJlc3VsdC5iYXR0ZXJ5UGVyY2VudCA9IG51bGw7XG4gIHJlc3VsdC50eXBlID0gcGFyc2VCbHVldG9vdGhUeXBlKHJlc3VsdC5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuICByZXN1bHQuY29ubmVjdGVkID0gbnVsbDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBibHVldG9vdGhEZXZpY2VzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIC8vIGdldCBmaWxlcyBpbiAvdmFyL2xpYi9ibHVldG9vdGgvIHJlY3Vyc2l2ZVxuICAgICAgICBjb25zdCBidEZpbGVzID0gdXRpbC5nZXRGaWxlc0luUGF0aCgnL3Zhci9saWIvYmx1ZXRvb3RoLycpO1xuICAgICAgICBidEZpbGVzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZWxlbWVudCk7XG4gICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gZWxlbWVudC5zcGxpdCgnLycpO1xuICAgICAgICAgIGNvbnN0IG1hY0FkZHIxID0gcGF0aFBhcnRzLmxlbmd0aCA+PSA2ID8gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAyXSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgbWFjQWRkcjIgPSBwYXRoUGFydHMubGVuZ3RoID49IDcgPyBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDNdIDogbnVsbDtcbiAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09ICdpbmZvJykge1xuICAgICAgICAgICAgY29uc3QgaW5mb0ZpbGUgPSBmcy5yZWFkRmlsZVN5bmMoZWxlbWVudCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlTGludXhCbHVldG9vdGhJbmZvKGluZm9GaWxlLCBtYWNBZGRyMSwgbWFjQWRkcjIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZXRlcm1pbmUgXCJjb25uZWN0ZWRcIiB3aXRoIGhjaXRvb2wgY29uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaGRpY29uID0gZXhlY1N5bmMoJ2hjaXRvb2wgY29uJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0W2ldLm1hY0RldmljZSAmJiByZXN1bHRbaV0ubWFjRGV2aWNlLmxlbmd0aCA+IDEwICYmIGhkaWNvbi5pbmRleE9mKHJlc3VsdFtpXS5tYWNEZXZpY2UudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXN1bHRbaV0uY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgU1BCbHVldG9vdGhEYXRhVHlwZSAtanNvbic7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dE9iaiA9IEpTT04ucGFyc2Uoc3Rkb3V0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAob3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUgJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGUubGVuZ3RoICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2VfdGl0bGUnXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX3RpdGxlJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gbWlzc2luZzogaG9zdCBCVCBBZGFwdGVyIG1hY0FkZHIgKClcbiAgICAgICAgICAgICAgICBsZXQgbWFjQWRkcjIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnbG9jYWxfZGV2aWNlX3RpdGxlJ10gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0ubG9jYWxfZGV2aWNlX3RpdGxlLmdlbmVyYWxfYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgbWFjQWRkcjIgPSBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5sb2NhbF9kZXZpY2VfdGl0bGUuZ2VuZXJhbF9hZGRyZXNzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnOicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX3RpdGxlJ10uZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaktleSA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqS2V5ICYmIG9iaktleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJPYmplY3QgPSBvYmpbb2JqS2V5WzBdXTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPYmplY3QuZGV2aWNlX25hbWUgPSBvYmpLZXlbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsdWV0b290aERldmljZSA9IHBhcnNlRGFyd2luQmx1ZXRvb3RoRGV2aWNlcyhpbm5lck9iamVjdCwgbWFjQWRkcjIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChibHVldG9vdGhEZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZS5sZW5ndGggJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9jb25uZWN0ZWQnXSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX2Nvbm5lY3RlZCddLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hY0FkZHIyID0gb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzICYmIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcy5jb250cm9sbGVyX2FkZHJlc3MgPyBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMuY29udHJvbGxlcl9hZGRyZXNzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnOicpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXVsnZGV2aWNlX2Nvbm5lY3RlZCddLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmpLZXkgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgICAgICAgaWYgKG9iaktleSAmJiBvYmpLZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyT2JqZWN0ID0gb2JqW29iaktleVswXV07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqZWN0LmRldmljZV9uYW1lID0gb2JqS2V5WzBdO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iamVjdC5kZXZpY2VfaXNjb25uZWN0ZWQgPSAnYXR0cmliX1llcyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsdWV0b290aERldmljZSA9IHBhcnNlRGFyd2luQmx1ZXRvb3RoRGV2aWNlcyhpbm5lck9iamVjdCwgbWFjQWRkcjIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChibHVldG9vdGhEZXZpY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZSAmJiBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZS5sZW5ndGggJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9ub3RfY29ubmVjdGVkJ10gJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF1bJ2RldmljZV9ub3RfY29ubmVjdGVkJ10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFjQWRkcjIgPSBvdXRPYmouU1BCbHVldG9vdGhEYXRhVHlwZVswXS5jb250cm9sbGVyX3Byb3BlcnRpZXMgJiYgb3V0T2JqLlNQQmx1ZXRvb3RoRGF0YVR5cGVbMF0uY29udHJvbGxlcl9wcm9wZXJ0aWVzLmNvbnRyb2xsZXJfYWRkcmVzcyA/IG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdLmNvbnRyb2xsZXJfcHJvcGVydGllcy5jb250cm9sbGVyX2FkZHJlc3MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICc6JykgOiBudWxsO1xuICAgICAgICAgICAgICAgIG91dE9iai5TUEJsdWV0b290aERhdGFUeXBlWzBdWydkZXZpY2Vfbm90X2Nvbm5lY3RlZCddLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvYmpLZXkgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgICAgICAgaWYgKG9iaktleSAmJiBvYmpLZXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyT2JqZWN0ID0gb2JqW29iaktleVswXV07XG4gICAgICAgICAgICAgICAgICAgIGlubmVyT2JqZWN0LmRldmljZV9uYW1lID0gb2JqS2V5WzBdO1xuICAgICAgICAgICAgICAgICAgICBpbm5lck9iamVjdC5kZXZpY2VfaXNjb25uZWN0ZWQgPSAnYXR0cmliX05vJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmx1ZXRvb3RoRGV2aWNlID0gcGFyc2VEYXJ3aW5CbHVldG9vdGhEZXZpY2VzKGlubmVyT2JqZWN0LCBtYWNBZGRyMik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsdWV0b290aERldmljZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9QTlBFbnRpdHkgfCBzZWxlY3QgUE5QQ2xhc3MsIE5hbWUsIE1hbnVmYWN0dXJlciB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHV0aWwuZ2V0VmFsdWUocGFydC5zcGxpdCgnXFxuJyksICdQTlBDbGFzcycsICc6JykgPT09ICdCbHVldG9vdGgnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VXaW5kb3dzQmx1ZXRvb3RoKHBhcnQuc3BsaXQoJ1xcbicpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX25ldGJzZCB8fCBfb3BlbmJzZCB8fCBfc3Vub3MpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuYmx1ZXRvb3RoRGV2aWNlcyA9IGJsdWV0b290aERldmljZXM7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIGNwdS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDQuIENQVVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmxldCBfY3B1X3NwZWVkID0gMDtcbmxldCBfY3VycmVudF9jcHUgPSB7XG4gIHVzZXI6IDAsXG4gIG5pY2U6IDAsXG4gIHN5c3RlbTogMCxcbiAgaWRsZTogMCxcbiAgaXJxOiAwLFxuICBsb2FkOiAwLFxuICB0aWNrOiAwLFxuICBtczogMCxcbiAgY3VycmVudExvYWQ6IDAsXG4gIGN1cnJlbnRMb2FkVXNlcjogMCxcbiAgY3VycmVudExvYWRTeXN0ZW06IDAsXG4gIGN1cnJlbnRMb2FkTmljZTogMCxcbiAgY3VycmVudExvYWRJZGxlOiAwLFxuICBjdXJyZW50TG9hZElycTogMCxcbiAgcmF3Q3VycmVudExvYWQ6IDAsXG4gIHJhd0N1cnJlbnRMb2FkVXNlcjogMCxcbiAgcmF3Q3VycmVudExvYWRTeXN0ZW06IDAsXG4gIHJhd0N1cnJlbnRMb2FkTmljZTogMCxcbiAgcmF3Q3VycmVudExvYWRJZGxlOiAwLFxuICByYXdDdXJyZW50TG9hZElycTogMFxufTtcbmxldCBfY3B1cyA9IFtdO1xubGV0IF9jb3JlY291bnQgPSAwO1xuXG5jb25zdCBBTURCYXNlRnJlcXVlbmNpZXMgPSB7XG4gICc4MzQ2JzogJzEuOCcsXG4gICc4MzQ3JzogJzEuOScsXG4gICc4MzUwJzogJzIuMCcsXG4gICc4MzU0JzogJzIuMicsXG4gICc4MzU2fFNFJzogJzIuNCcsXG4gICc4MzU2JzogJzIuMycsXG4gICc4MzYwJzogJzIuNScsXG4gICcyMzcyJzogJzIuMScsXG4gICcyMzczJzogJzIuMScsXG4gICcyMzc0JzogJzIuMicsXG4gICcyMzc2JzogJzIuMycsXG4gICcyMzc3JzogJzIuMycsXG4gICcyMzc4JzogJzIuNCcsXG4gICcyMzc5JzogJzIuNCcsXG4gICcyMzgwJzogJzIuNScsXG4gICcyMzgxJzogJzIuNScsXG4gICcyMzgyJzogJzIuNicsXG4gICcyMzg0JzogJzIuNycsXG4gICcyMzg2JzogJzIuOCcsXG4gICcyMzg3JzogJzIuOCcsXG4gICcyMzg5JzogJzIuOScsXG4gICcyMzkzJzogJzMuMScsXG4gICc4Mzc0JzogJzIuMicsXG4gICc4Mzc2JzogJzIuMycsXG4gICc4Mzc4JzogJzIuNCcsXG4gICc4Mzc5JzogJzIuNCcsXG4gICc4MzgwJzogJzIuNScsXG4gICc4MzgxJzogJzIuNScsXG4gICc4MzgyJzogJzIuNicsXG4gICc4Mzg0JzogJzIuNycsXG4gICc4Mzg2JzogJzIuOCcsXG4gICc4Mzg3JzogJzIuOCcsXG4gICc4Mzg5JzogJzIuOScsXG4gICc4MzkzJzogJzMuMScsXG4gICcyNDE5RUUnOiAnMS44JyxcbiAgJzI0MjNIRSc6ICcyLjAnLFxuICAnMjQyNUhFJzogJzIuMScsXG4gICcyNDI3JzogJzIuMicsXG4gICcyNDMxJzogJzIuNCcsXG4gICcyNDM1JzogJzIuNicsXG4gICcyNDM5U0UnOiAnMi44JyxcbiAgJzg0MjVIRSc6ICcyLjEnLFxuICAnODQzMSc6ICcyLjQnLFxuICAnODQzNSc6ICcyLjYnLFxuICAnODQzOVNFJzogJzIuOCcsXG4gICc0MTIyJzogJzIuMicsXG4gICc0MTMwJzogJzIuNicsXG4gICc0MTYyRUUnOiAnMS43JyxcbiAgJzQxNjRFRSc6ICcxLjgnLFxuICAnNDE3MEhFJzogJzIuMScsXG4gICc0MTc0SEUnOiAnMi4zJyxcbiAgJzQxNzZIRSc6ICcyLjQnLFxuICAnNDE4MCc6ICcyLjYnLFxuICAnNDE4NCc6ICcyLjgnLFxuICAnNjEyNEhFJzogJzEuOCcsXG4gICc2MTI4SEUnOiAnMi4wJyxcbiAgJzYxMzJIRSc6ICcyLjInLFxuICAnNjEyOCc6ICcyLjAnLFxuICAnNjEzNCc6ICcyLjMnLFxuICAnNjEzNic6ICcyLjQnLFxuICAnNjE0MCc6ICcyLjYnLFxuICAnNjE2NEhFJzogJzEuNycsXG4gICc2MTY2SEUnOiAnMS44JyxcbiAgJzYxNjgnOiAnMS45JyxcbiAgJzYxNzInOiAnMi4xJyxcbiAgJzYxNzQnOiAnMi4yJyxcbiAgJzYxNzYnOiAnMi4zJyxcbiAgJzYxNzZTRSc6ICcyLjMnLFxuICAnNjE4MFNFJzogJzIuNScsXG4gICczMjUwJzogJzIuNScsXG4gICczMjYwJzogJzIuNycsXG4gICczMjgwJzogJzIuNCcsXG4gICc0MjI2JzogJzIuNycsXG4gICc0MjI4JzogJzIuOCcsXG4gICc0MjMwJzogJzIuOScsXG4gICc0MjM0JzogJzMuMScsXG4gICc0MjM4JzogJzMuMycsXG4gICc0MjQwJzogJzMuNCcsXG4gICc0MjU2JzogJzEuNicsXG4gICc0Mjc0JzogJzIuNScsXG4gICc0Mjc2JzogJzIuNicsXG4gICc0MjgwJzogJzIuOCcsXG4gICc0Mjg0JzogJzMuMCcsXG4gICc2MjA0JzogJzMuMycsXG4gICc2MjEyJzogJzIuNicsXG4gICc2MjIwJzogJzMuMCcsXG4gICc2MjM0JzogJzIuNCcsXG4gICc2MjM4JzogJzIuNicsXG4gICc2MjYySEUnOiAnMS42JyxcbiAgJzYyNzInOiAnMi4xJyxcbiAgJzYyNzQnOiAnMi4yJyxcbiAgJzYyNzYnOiAnMi4zJyxcbiAgJzYyNzgnOiAnMi40JyxcbiAgJzYyODJTRSc6ICcyLjYnLFxuICAnNjI4NFNFJzogJzIuNycsXG4gICc2MzA4JzogJzMuNScsXG4gICc2MzIwJzogJzIuOCcsXG4gICc2MzI4JzogJzMuMicsXG4gICc2MzM4UCc6ICcyLjMnLFxuICAnNjM0NCc6ICcyLjYnLFxuICAnNjM0OCc6ICcyLjgnLFxuICAnNjM2Nic6ICcxLjgnLFxuICAnNjM3MFAnOiAnMi4wJyxcbiAgJzYzNzYnOiAnMi4zJyxcbiAgJzYzNzgnOiAnMi40JyxcbiAgJzYzODAnOiAnMi41JyxcbiAgJzYzODYnOiAnMi44JyxcbiAgJ0ZYfDQxMDAnOiAnMy42JyxcbiAgJ0ZYfDQxMjAnOiAnMy45JyxcbiAgJ0ZYfDQxMzAnOiAnMy44JyxcbiAgJ0ZYfDQxNTAnOiAnMy44JyxcbiAgJ0ZYfDQxNzAnOiAnNC4yJyxcbiAgJ0ZYfDYxMDAnOiAnMy4zJyxcbiAgJ0ZYfDYxMjAnOiAnMy42JyxcbiAgJ0ZYfDYxMzAnOiAnMy42JyxcbiAgJ0ZYfDYyMDAnOiAnMy44JyxcbiAgJ0ZYfDgxMDAnOiAnMi44JyxcbiAgJ0ZYfDgxMjAnOiAnMy4xJyxcbiAgJ0ZYfDgxNDAnOiAnMy4yJyxcbiAgJ0ZYfDgxNTAnOiAnMy42JyxcbiAgJ0ZYfDgxNzAnOiAnMy45JyxcbiAgJ0ZYfDQzMDAnOiAnMy44JyxcbiAgJ0ZYfDQzMjAnOiAnNC4wJyxcbiAgJ0ZYfDQzNTAnOiAnNC4yJyxcbiAgJ0ZYfDYzMDAnOiAnMy41JyxcbiAgJ0ZYfDYzNTAnOiAnMy45JyxcbiAgJ0ZYfDgzMDAnOiAnMy4zJyxcbiAgJ0ZYfDgzMTAnOiAnMy40JyxcbiAgJ0ZYfDgzMjAnOiAnMy41JyxcbiAgJ0ZYfDgzNTAnOiAnNC4wJyxcbiAgJ0ZYfDgzNzAnOiAnNC4wJyxcbiAgJ0ZYfDkzNzAnOiAnNC40JyxcbiAgJ0ZYfDk1OTAnOiAnNC43JyxcbiAgJ0ZYfDgzMjBFJzogJzMuMicsXG4gICdGWHw4MzcwRSc6ICczLjMnLFxuXG4gIC8vIFpFTiBEZXNrdG9wIENQVXNcbiAgJzEyMDAnOiAnMy4xJyxcbiAgJ1BybyAxMjAwJzogJzMuMScsXG4gICcxMzAwWCc6ICczLjUnLFxuICAnUHJvIDEzMDAnOiAnMy41JyxcbiAgJzE0MDAnOiAnMy4yJyxcbiAgJzE1MDBYJzogJzMuNScsXG4gICdQcm8gMTUwMCc6ICczLjUnLFxuICAnMTYwMCc6ICczLjInLFxuICAnMTYwMFgnOiAnMy42JyxcbiAgJ1BybyAxNjAwJzogJzMuMicsXG4gICcxNzAwJzogJzMuMCcsXG4gICdQcm8gMTcwMCc6ICczLjAnLFxuICAnMTcwMFgnOiAnMy40JyxcbiAgJ1BybyAxNzAwWCc6ICczLjQnLFxuICAnMTgwMFgnOiAnMy42JyxcbiAgJzE5MDBYJzogJzMuOCcsXG4gICcxOTIwJzogJzMuMicsXG4gICcxOTIwWCc6ICczLjUnLFxuICAnMTk1MFgnOiAnMy40JyxcblxuICAvLyBaRU4gRGVza3RvcCBBUFVzXG4gICcyMDBHRSc6ICczLjInLFxuICAnUHJvIDIwMEdFJzogJzMuMicsXG4gICcyMjBHRSc6ICczLjQnLFxuICAnMjQwR0UnOiAnMy41JyxcbiAgJzMwMDBHJzogJzMuNScsXG4gICczMDBHRSc6ICczLjQnLFxuICAnMzA1MEdFJzogJzMuNCcsXG4gICcyMjAwRyc6ICczLjUnLFxuICAnUHJvIDIyMDBHJzogJzMuNScsXG4gICcyMjAwR0UnOiAnMy4yJyxcbiAgJ1BybyAyMjAwR0UnOiAnMy4yJyxcbiAgJzI0MDBHJzogJzMuNicsXG4gICdQcm8gMjQwMEcnOiAnMy42JyxcbiAgJzI0MDBHRSc6ICczLjInLFxuICAnUHJvIDI0MDBHRSc6ICczLjInLFxuXG4gIC8vIFpFTiBNb2JpbGUgQVBVc1xuICAnUHJvIDIwMFUnOiAnMi4zJyxcbiAgJzMwMFUnOiAnMi40JyxcbiAgJzIyMDBVJzogJzIuNScsXG4gICczMjAwVSc6ICcyLjYnLFxuICAnMjMwMFUnOiAnMi4wJyxcbiAgJ1BybyAyMzAwVSc6ICcyLjAnLFxuICAnMjUwMFUnOiAnMi4wJyxcbiAgJ1BybyAyNTAwVSc6ICcyLjInLFxuICAnMjYwMEgnOiAnMy4yJyxcbiAgJzI3MDBVJzogJzIuMCcsXG4gICdQcm8gMjcwMFUnOiAnMi4yJyxcbiAgJzI4MDBIJzogJzMuMycsXG5cbiAgLy8gWkVOIFNlcnZlciBQcm9jZXNzb3JzXG4gICc3MzUxJzogJzIuNCcsXG4gICc3MzUxUCc6ICcyLjQnLFxuICAnNzQwMSc6ICcyLjAnLFxuICAnNzQwMVAnOiAnMi4wJyxcbiAgJzc1NTFQJzogJzIuMCcsXG4gICc3NTUxJzogJzIuMCcsXG4gICc3MjUxJzogJzIuMScsXG4gICc3MjYxJzogJzIuNScsXG4gICc3MjgxJzogJzIuMScsXG4gICc3MzAxJzogJzIuMicsXG4gICc3MzcxJzogJzMuMScsXG4gICc3NDUxJzogJzIuMycsXG4gICc3NTAxJzogJzIuMCcsXG4gICc3NTcxJzogJzIuMicsXG4gICc3NjAxJzogJzIuMicsXG5cbiAgLy8gWkVOIEVtYmVkZGVkIFByb2Nlc3NvcnNcbiAgJ1YxNTAwQic6ICcyLjInLFxuICAnVjE3ODBCJzogJzMuMzUnLFxuICAnVjEyMDJCJzogJzIuMycsXG4gICdWMTQwNEknOiAnMi4wJyxcbiAgJ1YxNjA1Qic6ICcyLjAnLFxuICAnVjE3NTZCJzogJzMuMjUnLFxuICAnVjE4MDdCJzogJzMuMzUnLFxuXG4gICczMTAxJzogJzIuMScsXG4gICczMTUxJzogJzIuNycsXG4gICczMjAxJzogJzEuNScsXG4gICczMjUxJzogJzIuNScsXG4gICczMjU1JzogJzIuNScsXG4gICczMzAxJzogJzIuMCcsXG4gICczMzUxJzogJzEuOScsXG4gICczNDAxJzogJzEuODUnLFxuICAnMzQ1MSc6ICcyLjE1JyxcblxuICAvLyBaRU4rIERlc2t0b3BcbiAgJzEyMDB8QUYnOiAnMy4xJyxcbiAgJzIzMDBYJzogJzMuNScsXG4gICcyNTAwWCc6ICczLjYnLFxuICAnMjYwMCc6ICczLjQnLFxuICAnMjYwMEUnOiAnMy4xJyxcbiAgJzE2MDB8QUYnOiAnMy4yJyxcbiAgJzI2MDBYJzogJzMuNicsXG4gICcyNzAwJzogJzMuMicsXG4gICcyNzAwRSc6ICcyLjgnLFxuICAnUHJvIDI3MDAnOiAnMy4yJyxcbiAgJzI3MDBYJzogJzMuNycsXG4gICdQcm8gMjcwMFgnOiAnMy42JyxcbiAgJzI5MjBYJzogJzMuNScsXG4gICcyOTUwWCc6ICczLjUnLFxuICAnMjk3MFdYJzogJzMuMCcsXG4gICcyOTkwV1gnOiAnMy4wJyxcblxuICAvLyBaRU4rIERlc2t0b3AgQVBVXG4gICdQcm8gMzAwR0UnOiAnMy40JyxcbiAgJ1BybyAzMTI1R0UnOiAnMy40JyxcbiAgJzMxNTBHJzogJzMuNScsXG4gICdQcm8gMzE1MEcnOiAnMy41JyxcbiAgJzMxNTBHRSc6ICczLjMnLFxuICAnUHJvIDMxNTBHRSc6ICczLjMnLFxuICAnMzIwMEcnOiAnMy42JyxcbiAgJ1BybyAzMjAwRyc6ICczLjYnLFxuICAnMzIwMEdFJzogJzMuMycsXG4gICdQcm8gMzIwMEdFJzogJzMuMycsXG4gICczMzUwRyc6ICczLjYnLFxuICAnUHJvIDMzNTBHJzogJzMuNicsXG4gICczMzUwR0UnOiAnMy4zJyxcbiAgJ1BybyAzMzUwR0UnOiAnMy4zJyxcbiAgJzM0MDBHJzogJzMuNycsXG4gICdQcm8gMzQwMEcnOiAnMy43JyxcbiAgJzM0MDBHRSc6ICczLjMnLFxuICAnUHJvIDM0MDBHRSc6ICczLjMnLFxuXG4gIC8vIFpFTisgTW9iaWxlXG4gICczMzAwVSc6ICcyLjEnLFxuICAnUFJPIDMzMDBVJzogJzIuMScsXG4gICczNDUwVSc6ICcyLjEnLFxuICAnMzUwMFUnOiAnMi4xJyxcbiAgJ1BSTyAzNTAwVSc6ICcyLjEnLFxuICAnMzUwMEMnOiAnMi4xJyxcbiAgJzM1NTBIJzogJzIuMScsXG4gICczNTgwVSc6ICcyLjEnLFxuICAnMzcwMFUnOiAnMi4zJyxcbiAgJ1BSTyAzNzAwVSc6ICcyLjMnLFxuICAnMzcwMEMnOiAnMi4zJyxcbiAgJzM3NTBIJzogJzIuMycsXG4gICczNzgwVSc6ICcyLjMnLFxuXG4gIC8vIFpFTjIgRGVza3RvcCBDUFVTXG4gICczMTAwJzogJzMuNicsXG4gICczMzAwWCc6ICczLjgnLFxuICAnMzUwMCc6ICczLjYnLFxuICAnMzUwMFgnOiAnMy42JyxcbiAgJzM2MDAnOiAnMy42JyxcbiAgJ1BybyAzNjAwJzogJzMuNicsXG4gICczNjAwWCc6ICczLjgnLFxuICAnMzYwMFhUJzogJzMuOCcsXG4gICdQcm8gMzcwMCc6ICczLjYnLFxuICAnMzcwMFgnOiAnMy42JyxcbiAgJzM4MDBYJzogJzMuOScsXG4gICczODAwWFQnOiAnMy45JyxcbiAgJzM5MDAnOiAnMy4xJyxcbiAgJ1BybyAzOTAwJzogJzMuMScsXG4gICczOTAwWCc6ICczLjgnLFxuICAnMzkwMFhUJzogJzMuOCcsXG4gICczOTUwWCc6ICczLjUnLFxuICAnMzk2MFgnOiAnMy44JyxcbiAgJzM5NzBYJzogJzMuNycsXG4gICczOTkwWCc6ICcyLjknLFxuICAnMzk0NVdYJzogJzQuMCcsXG4gICczOTU1V1gnOiAnMy45JyxcbiAgJzM5NzVXWCc6ICczLjUnLFxuICAnMzk5NVdYJzogJzIuNycsXG5cbiAgLy8gWkVOMiBEZXNrdG9wIEFQVXNcbiAgJzQzMDBHRSc6ICczLjUnLFxuICAnUHJvIDQzMDBHRSc6ICczLjUnLFxuICAnNDMwMEcnOiAnMy44JyxcbiAgJ1BybyA0MzAwRyc6ICczLjgnLFxuICAnNDYwMEdFJzogJzMuMycsXG4gICdQcm8gNDY1MEdFJzogJzMuMycsXG4gICc0NjAwRyc6ICczLjcnLFxuICAnUHJvIDQ2NTBHJzogJzMuNycsXG4gICc0NzAwR0UnOiAnMy4xJyxcbiAgJ1BybyA0NzUwR0UnOiAnMy4xJyxcbiAgJzQ3MDBHJzogJzMuNicsXG4gICdQcm8gNDc1MEcnOiAnMy42JyxcbiAgJzQzMDBVJzogJzIuNycsXG4gICc0NDUwVSc6ICcyLjUnLFxuICAnUHJvIDQ0NTBVJzogJzIuNScsXG4gICc0NTAwVSc6ICcyLjMnLFxuICAnNDYwMFUnOiAnMi4xJyxcbiAgJ1BSTyA0NjUwVSc6ICcyLjEnLFxuICAnNDY4MFUnOiAnMi4xJyxcbiAgJzQ2MDBIUyc6ICczLjAnLFxuICAnNDYwMEgnOiAnMy4wJyxcbiAgJzQ3MDBVJzogJzIuMCcsXG4gICdQUk8gNDc1MFUnOiAnMS43JyxcbiAgJzQ4MDBVJzogJzEuOCcsXG4gICc0ODAwSFMnOiAnMi45JyxcbiAgJzQ4MDBIJzogJzIuOScsXG4gICc0OTAwSFMnOiAnMy4wJyxcbiAgJzQ5MDBIJzogJzMuMycsXG4gICc1MzAwVSc6ICcyLjYnLFxuICAnNTUwMFUnOiAnMi4xJyxcbiAgJzU3MDBVJzogJzEuOCcsXG5cbiAgLy8gWkVOMiAtIEVQWUNcbiAgJzcyMzJQJzogJzMuMScsXG4gICc3MzAyUCc6ICczLjAnLFxuICAnNzQwMlAnOiAnMi44JyxcbiAgJzc1MDJQJzogJzIuNScsXG4gICc3NzAyUCc6ICcyLjAnLFxuICAnNzI1Mic6ICczLjEnLFxuICAnNzI2Mic6ICczLjInLFxuICAnNzI3Mic6ICcyLjknLFxuICAnNzI4Mic6ICcyLjgnLFxuICAnNzMwMic6ICczLjAnLFxuICAnNzM1Mic6ICcyLjMnLFxuICAnNzQwMic6ICcyLjgnLFxuICAnNzQ1Mic6ICcyLjM1JyxcbiAgJzc1MDInOiAnMi41JyxcbiAgJzc1MzInOiAnMi40JyxcbiAgJzc1NDInOiAnMi45JyxcbiAgJzc1NTInOiAnMi4yJyxcbiAgJzc2NDInOiAnMi4zJyxcbiAgJzc2NjInOiAnMi4wJyxcbiAgJzc3MDInOiAnMi4wJyxcbiAgJzc3NDInOiAnMi4yNScsXG4gICc3SDEyJzogJzIuNicsXG4gICc3RjMyJzogJzMuNycsXG4gICc3RjUyJzogJzMuNScsXG4gICc3RjcyJzogJzMuMicsXG5cbiAgLy8gRXB5YyAoTWlsYW4pXG5cbiAgJzc3NjMnOiAnMi40NScsXG4gICc3NzEzJzogJzIuMCcsXG4gICc3NzEzUCc6ICcyLjAnLFxuICAnNzY2Myc6ICcyLjAnLFxuICAnNzY0Myc6ICcyLjMnLFxuICAnNzVGMyc6ICcyLjk1JyxcbiAgJzc1NDMnOiAnMi44JyxcbiAgJzc1NDNQJzogJzIuOCcsXG4gICc3NTEzJzogJzIuNicsXG4gICc3NDUzJzogJzIuNzUnLFxuICAnNzRGMyc6ICczLjInLFxuICAnNzQ0Myc6ICcyLjg1JyxcbiAgJzc0NDNQJzogJzIuODUnLFxuICAnNzQxMyc6ICcyLjY1JyxcbiAgJzczRjMnOiAnMy41JyxcbiAgJzczNDMnOiAnMy4yJyxcbiAgJzczMTMnOiAnMy4wJyxcbiAgJzczMTNQJzogJzMuMCcsXG4gICc3MkYzJzogJzMuNycsXG5cbiAgLy8gWkVOM1xuICAnNTYwMFgnOiAnMy43JyxcbiAgJzU4MDBYJzogJzMuOCcsXG4gICc1OTAwWCc6ICczLjcnLFxuICAnNTk1MFgnOiAnMy40J1xufTtcblxuXG5jb25zdCBzb2NrZXRUeXBlcyA9IHtcbiAgMTogJ090aGVyJyxcbiAgMjogJ1Vua25vd24nLFxuICAzOiAnRGF1Z2h0ZXIgQm9hcmQnLFxuICA0OiAnWklGIFNvY2tldCcsXG4gIDU6ICdSZXBsYWNlbWVudC9QaWdneSBCYWNrJyxcbiAgNjogJ05vbmUnLFxuICA3OiAnTElGIFNvY2tldCcsXG4gIDg6ICdTbG90IDEnLFxuICA5OiAnU2xvdCAyJyxcbiAgMTA6ICczNzAgUGluIFNvY2tldCcsXG4gIDExOiAnU2xvdCBBJyxcbiAgMTI6ICdTbG90IE0nLFxuICAxMzogJzQyMycsXG4gIDE0OiAnQSAoU29ja2V0IDQ2MiknLFxuICAxNTogJzQ3OCcsXG4gIDE2OiAnNzU0JyxcbiAgMTc6ICc5NDAnLFxuICAxODogJzkzOScsXG4gIDE5OiAnbVBHQTYwNCcsXG4gIDIwOiAnTEdBNzcxJyxcbiAgMjE6ICdMR0E3NzUnLFxuICAyMjogJ1MxJyxcbiAgMjM6ICdBTTInLFxuICAyNDogJ0YgKDEyMDcpJyxcbiAgMjU6ICdMR0ExMzY2JyxcbiAgMjY6ICdHMzQnLFxuICAyNzogJ0FNMycsXG4gIDI4OiAnQzMyJyxcbiAgMjk6ICdMR0ExMTU2JyxcbiAgMzA6ICdMR0ExNTY3JyxcbiAgMzE6ICdQR0E5ODhBJyxcbiAgMzI6ICdCR0ExMjg4JyxcbiAgMzM6ICdyUEdBOTg4QicsXG4gIDM0OiAnQkdBMTAyMycsXG4gIDM1OiAnQkdBMTIyNCcsXG4gIDM2OiAnTEdBMTE1NScsXG4gIDM3OiAnTEdBMTM1NicsXG4gIDM4OiAnTEdBMjAxMScsXG4gIDM5OiAnRlMxJyxcbiAgNDA6ICdGUzInLFxuICA0MTogJ0ZNMScsXG4gIDQyOiAnRk0yJyxcbiAgNDM6ICdMR0EyMDExLTMnLFxuICA0NDogJ0xHQTEzNTYtMycsXG4gIDQ1OiAnTEdBMTE1MCcsXG4gIDQ2OiAnQkdBMTE2OCcsXG4gIDQ3OiAnQkdBMTIzNCcsXG4gIDQ4OiAnQkdBMTM2NCcsXG4gIDQ5OiAnQU00JyxcbiAgNTA6ICdMR0ExMTUxJyxcbiAgNTE6ICdCR0ExMzU2JyxcbiAgNTI6ICdCR0ExNDQwJyxcbiAgNTM6ICdCR0ExNTE1JyxcbiAgNTQ6ICdMR0EzNjQ3LTEnLFxuICA1NTogJ1NQMycsXG4gIDU2OiAnU1AzcjInLFxuICA1NzogJ0xHQTIwNjYnLFxuICA1ODogJ0JHQTEzOTInLFxuICA1OTogJ0JHQTE1MTAnLFxuICA2MDogJ0JHQTE1MjgnLFxuICA2MTogJ0xHQTQxODknLFxuICA2MjogJ0xHQTEyMDAnLFxuICA2MzogJ0xHQTQ2NzcnLFxufTtcblxuY29uc3Qgc29ja2V0VHlwZXNCeU5hbWUgPSB7XG4gICdMR0ExMTUwJzogJ2k3LTU3NzVDIGkzLTQzNDAgaTMtNDE3MCBHMzI1MCBpMy00MTYwVCBpMy00MTYwIEUzLTEyMzEgRzMyNTggRzMyNDAgaTctNDc5MFMgaTctNDc5MEsgaTctNDc5MCBpNS00NjkwSyBpNS00NjkwIGk1LTQ1OTBUIGk1LTQ1OTBTIGk1LTQ1OTAgaTUtNDQ2MCBpMy00MzYwIGkzLTQxNTAgRzE4MjAgRzM0MjAgRzMyMjAgaTctNDc3MSBpNS00NDQwIGkzLTQzMzAgaTMtNDEzMFQgaTMtNDEzMCBFMy0xMjMwIGk3LTQ3NzBTIGk3LTQ3NzBLIGk3LTQ3NzAgaTUtNDY3MEsgaTUtNDY3MCBpNS00NTcwVCBpNS00NTcwUyBpNS00NTcwIGk1LTQ0MzAnLFxuICAnTEdBMTE1MSc6ICdpOS05OTAwS1MgRS0yMjg4RyBFLTIyMjQgRzU0MjAgaTktOTkwMFQgaTktOTkwMCBpNy05NzAwVCBpNy05NzAwRiBpNy05NzAwRSBpNy05NzAwIGk1LTk2MDAgaTUtOTUwMFQgaTUtOTUwMEYgaTUtOTUwMCBpNS05NDAwVCBpMy05MzUwSyBpMy05MzAwIGkzLTkxMDBUIGkzLTkxMDBGIGkzLTkxMDAgRzQ5MzAgaTktOTkwMEtGIGk3LTk3MDBLRiBpNS05NjAwS0YgaTUtOTQwMEYgaTUtOTQwMCBpMy05MzUwS0YgaTktOTkwMEsgaTctOTcwMEsgaTUtOTYwMEsgRzU1MDAgRzU0MDAgaTctODcwMFQgaTctODA4NksgaTUtODYwMCBpNS04NTAwVCBpNS04NTAwIGk1LTg0MDBUIGkzLTgzMDAgaTMtODEwMFQgRzQ5MDAgaTctODcwMEsgaTctODcwMCBpNS04NjAwSyBpNS04NDAwIGkzLTgzNTBLIGkzLTgxMDAgRTMtMTI3MCBHNDYwMCBHNDU2MCBpNy03NzAwVCBpNy03NzAwSyBpNy03NzAwIGk1LTc2MDBLIGk1LTc2MDAgaTUtNzUwMFQgaTUtNzUwMCBpNS03NDAwIGkzLTczNTBLIGkzLTczMDAgaTMtNzEwMFQgaTMtNzEwMCBHMzkzMCBHMzkwMCBHNDQwMCBpNy02NzAwVCBpNy02NzAwSyBpNy02NzAwIGk1LTY2MDBLIGk1LTY2MDAgaTUtNjUwMFQgaTUtNjUwMCBpNS02NDAwVCBpNS02NDAwIGkzLTYzMDAgaTMtNjEwMFQgaTMtNjEwMCBFMy0xMjcwIEUzLTEyNzAgVDQ1MDAgVDQ0MDAnLFxuICAnMTE1NSc6ICdHNDQwIEc0NjAgRzQ2NSBHNDcwIEc1MzBUIEc1NDBUIEc1NTBUIEcxNjEwVCBHMTYyMFQgRzUzMCBHNTQwIEcxNjEwIEc1NTAgRzE2MjAgRzU1NSBHMTYzMCBpMy0yMTAwVCBpMy0yMTIwVCBpMy0zMjIwVCBpMy0zMjQwVCBpMy0zMjUwVCBpMy0yMTAwIGkzLTIxMDUgaTMtMjEwMiBpMy0zMjEwIGkzLTMyMjAgaTMtMjEyNSBpMy0yMTIwIGkzLTMyMjUgaTMtMjEzMCBpMy0zMjQ1IGkzLTMyNDAgaTMtMzI1MCBpNS0zNTcwVCBpNS0yNTAwVCBpNS0yNDAwUyBpNS0yNDA1UyBpNS0yMzkwVCBpNS0zMzMwUyBpNS0yNTAwUyBpNS0zMzM1UyBpNS0yMzAwIGk1LTM0NTBTIGk1LTMzNDBTIGk1LTM0NzBTIGk1LTM0NzVTIGk1LTM0NzBUIGk1LTIzMTAgaTUtMzU1MFMgaTUtMjMyMCBpNS0zMzMwIGk1LTMzNTBQIGk1LTM0NTAgaTUtMjQwMCBpNS0zMzQwIGk1LTM1NzBTIGk1LTIzODBQIGk1LTI0NTBQIGk1LTM0NzAgaTUtMjUwMEsgaTUtMzU1MCBpNS0yNTAwIGk1LTM1NzAgaTUtMzU3MEsgaTUtMjU1MEsgaTctMzc3MFQgaTctMjYwMFMgaTctMzc3MFMgaTctMjYwMEsgaTctMjYwMCBpNy0zNzcwIGk3LTM3NzBLIGk3LTI3MDBLIEc2MjBUIEc2MzBUIEc2NDBUIEcyMDIwVCBHNjQ1VCBHMjEwMFQgRzIwMzBUIEc2MjIgRzg2MFQgRzYyMCBHNjMyIEcyMTIwVCBHNjMwIEc2NDAgRzIwMTAgRzg0MCBHMjAyMCBHODUwIEc2NDUgRzIwMzAgRzg2MCBHMjEyMCBHODcwIEcyMTMwIEcyMTQwIEUzLTEyMjBMIEUzLTEyMjBMIEUzLTEyNjBMIEUzLTEyNjVMIEUzLTEyMjAgRTMtMTIyNSBFMy0xMjIwIEUzLTEyMzUgRTMtMTIyNSBFMy0xMjMwIEUzLTEyMzAgRTMtMTI0MCBFMy0xMjQ1IEUzLTEyNzAgRTMtMTI3NSBFMy0xMjQwIEUzLTEyNDUgRTMtMTI3MCBFMy0xMjgwIEUzLTEyNzUgRTMtMTI5MCBFMy0xMjgwIEUzLTEyOTAnXG59O1xuXG5mdW5jdGlvbiBnZXRTb2NrZXRUeXBlc0J5TmFtZShzdHIpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb2NrZXRUeXBlc0J5TmFtZSkge1xuICAgIGNvbnN0IG5hbWVzID0gc29ja2V0VHlwZXNCeU5hbWVba2V5XS5zcGxpdCgnICcpO1xuICAgIG5hbWVzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoc3RyLmluZGV4T2YoZWxlbWVudCkgPj0gMCkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY3B1TWFudWZhY3R1cmVyKHN0cikge1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoc3RyLmluZGV4T2YoJ2ludGVsJykgPj0gMCkgeyByZXN1bHQgPSAnSW50ZWwnOyB9XG4gIGlmIChzdHIuaW5kZXhPZignYW1kJykgPj0gMCkgeyByZXN1bHQgPSAnQU1EJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3FlbXUnKSA+PSAwKSB7IHJlc3VsdCA9ICdRRU1VJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2h5Z29uJykgPj0gMCkgeyByZXN1bHQgPSAnSHlnb24nOyB9XG4gIGlmIChzdHIuaW5kZXhPZignY2VudGF1cicpID49IDApIHsgcmVzdWx0ID0gJ1dpbkNoaXAvVmlhJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ3Ztd2FyZScpID49IDApIHsgcmVzdWx0ID0gJ1ZNd2FyZSc7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCdYZW4nKSA+PSAwKSB7IHJlc3VsdCA9ICdYZW4gSHlwZXJ2aXNvcic7IH1cbiAgaWYgKHN0ci5pbmRleE9mKCd0Y2cnKSA+PSAwKSB7IHJlc3VsdCA9ICdRRU1VJzsgfVxuICBpZiAoc3RyLmluZGV4T2YoJ2FwcGxlJykgPj0gMCkgeyByZXN1bHQgPSAnQXBwbGUnOyB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY3B1QnJhbmRNYW51ZmFjdHVyZXIocmVzKSB7XG4gIHJlcy5icmFuZCA9IHJlcy5icmFuZC5yZXBsYWNlKC9cXChSXFwpKy9nLCAnwq4nKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICByZXMuYnJhbmQgPSByZXMuYnJhbmQucmVwbGFjZSgvXFwoVE1cXCkrL2csICfihKInKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICByZXMuYnJhbmQgPSByZXMuYnJhbmQucmVwbGFjZSgvXFwoQ1xcKSsvZywgJ8KpJykucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgcmVzLmJyYW5kID0gcmVzLmJyYW5kLnJlcGxhY2UoL0NQVSsvZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gIHJlcy5tYW51ZmFjdHVyZXIgPSBjcHVNYW51ZmFjdHVyZXIocmVzLmJyYW5kKTtcblxuICBsZXQgcGFydHMgPSByZXMuYnJhbmQuc3BsaXQoJyAnKTtcbiAgcGFydHMuc2hpZnQoKTtcbiAgcmVzLmJyYW5kID0gcGFydHMuam9pbignICcpO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRBTURTcGVlZChicmFuZCkge1xuICBsZXQgcmVzdWx0ID0gJzAnO1xuICBmb3IgKGxldCBrZXkgaW4gQU1EQmFzZUZyZXF1ZW5jaWVzKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoQU1EQmFzZUZyZXF1ZW5jaWVzLCBrZXkpKSB7XG4gICAgICBsZXQgcGFydHMgPSBrZXkuc3BsaXQoJ3wnKTtcbiAgICAgIGxldCBmb3VuZCA9IDA7XG4gICAgICBwYXJ0cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoYnJhbmQuaW5kZXhPZihpdGVtKSA+IC0xKSB7XG4gICAgICAgICAgZm91bmQrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZm91bmQgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBBTURCYXNlRnJlcXVlbmNpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQocmVzdWx0KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSAtIGJyYW5kLCBzcGVlZFxuXG5mdW5jdGlvbiBnZXRDcHUoKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBjb25zdCBVTktOT1dOID0gJ3Vua25vd24nO1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbWFudWZhY3R1cmVyOiBVTktOT1dOLFxuICAgICAgICBicmFuZDogVU5LTk9XTixcbiAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgZmFtaWx5OiAnJyxcbiAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICBzdGVwcGluZzogJycsXG4gICAgICAgIHJldmlzaW9uOiAnJyxcbiAgICAgICAgdm9sdGFnZTogJycsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICBzcGVlZE1pbjogMCxcbiAgICAgICAgc3BlZWRNYXg6IDAsXG4gICAgICAgIGdvdmVybm9yOiAnJyxcbiAgICAgICAgY29yZXM6IHV0aWwuY29yZXMoKSxcbiAgICAgICAgcGh5c2ljYWxDb3JlczogdXRpbC5jb3JlcygpLFxuICAgICAgICBwZXJmb3JtYW5jZUNvcmVzOiB1dGlsLmNvcmVzKCksXG4gICAgICAgIGVmZmljaWVuY3lDb3JlczogMCxcbiAgICAgICAgcHJvY2Vzc29yczogMSxcbiAgICAgICAgc29ja2V0OiAnJyxcbiAgICAgICAgZmxhZ3M6ICcnLFxuICAgICAgICB2aXJ0dWFsaXphdGlvbjogZmFsc2UsXG4gICAgICAgIGNhY2hlOiB7fVxuICAgICAgfTtcbiAgICAgIGNwdUZsYWdzKCkudGhlbihmbGFncyA9PiB7XG4gICAgICAgIHJlc3VsdC5mbGFncyA9IGZsYWdzO1xuICAgICAgICByZXN1bHQudmlydHVhbGl6YXRpb24gPSBmbGFncy5pbmRleE9mKCd2bXgnKSA+IC0xIHx8IGZsYWdzLmluZGV4T2YoJ3N2bScpID4gLTE7XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgZXhlYygnc3lzY3RsIG1hY2hkZXAuY3B1IGh3LmNwdWZyZXF1ZW5jeV9tYXggaHcuY3B1ZnJlcXVlbmN5X21pbiBody5wYWNrYWdlcyBody5waHlzaWNhbGNwdV9tYXggaHcubmNwdSBody50YmZyZXF1ZW5jeSBody5jcHVmYW1pbHkgaHcuY3B1c3ViZmFtaWx5JywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsbGluZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmNwdS5icmFuZF9zdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsbGluZVBhcnRzID0gbW9kZWxsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICByZXN1bHQuYnJhbmQgPSBtb2RlbGxpbmVQYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBzcGVlZCA9IG1vZGVsbGluZVBhcnRzWzFdID8gbW9kZWxsaW5lUGFydHNbMV0udHJpbSgpIDogJzAnO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gcGFyc2VGbG9hdChzcGVlZC5yZXBsYWNlKC9HSHorL2csICcnKSk7XG4gICAgICAgICAgICBsZXQgdGJGcmVxdWVuY3kgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcudGJmcmVxdWVuY3knKSAvIDEwMDAwMDAwMDAuMDtcbiAgICAgICAgICAgIHRiRnJlcXVlbmN5ID0gdGJGcmVxdWVuY3kgPCAwLjEgPyB0YkZyZXF1ZW5jeSAqIDEwMCA6IHRiRnJlcXVlbmN5O1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gcmVzdWx0LnNwZWVkID09PSAwID8gdGJGcmVxdWVuY3kgOiByZXN1bHQuc3BlZWQ7XG5cbiAgICAgICAgICAgIF9jcHVfc3BlZWQgPSByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQgPSBjcHVCcmFuZE1hbnVmYWN0dXJlcihyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkTWluID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdWZyZXF1ZW5jeV9taW4nKSA/ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcuY3B1ZnJlcXVlbmN5X21pbicpIC8gMTAwMDAwMDAwMC4wKSA6IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1heCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVmcmVxdWVuY3lfbWF4JykgPyAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdWZyZXF1ZW5jeV9tYXgnKSAvIDEwMDAwMDAwMDAuMCkgOiByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQudmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuY3B1LnZlbmRvcicpIHx8ICdBcHBsZSc7XG4gICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuY3B1LmZhbWlseScpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5jcHVmYW1pbHknKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmNwdS5tb2RlbCcpO1xuICAgICAgICAgICAgcmVzdWx0LnN0ZXBwaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hY2hkZXAuY3B1LnN0ZXBwaW5nJykgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2h3LmNwdXN1YmZhbWlseScpO1xuICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxpemF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50UHJvY2Vzc29ycyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5wYWNrYWdlcycpO1xuICAgICAgICAgICAgY29uc3QgY291bnRDb3JlcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5waHlzaWNhbGNwdV9tYXgnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50VGhyZWFkcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdody5uY3B1Jyk7XG4gICAgICAgICAgICBpZiAob3MuYXJjaCgpID09PSAnYXJtNjQnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gZXhlY1N5bmMoJ2lvcmVnIC1jIElPUGxhdGZvcm1EZXZpY2UgLWQgMyAtciB8IGdyZXAgY2x1c3Rlci10eXBlJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGVmZmljaWVuY3lDb3JlcyA9IGNsdXN0ZXJzLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZignXCJFXCInKSA+PSAwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1hbmNlQ29yZXMgPSBjbHVzdGVycy5maWx0ZXIobGluZSA9PiBsaW5lLmluZGV4T2YoJ1wiUFwiJykgPj0gMCkubGVuZ3RoO1xuICAgICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gJ1NPQyc7XG4gICAgICAgICAgICAgIHJlc3VsdC5lZmZpY2llbmN5Q29yZXMgPSBlZmZpY2llbmN5Q29yZXM7XG4gICAgICAgICAgICAgIHJlc3VsdC5wZXJmb3JtYW5jZUNvcmVzID0gcGVyZm9ybWFuY2VDb3JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudFByb2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnByb2Nlc3NvcnMgPSBwYXJzZUludChjb3VudFByb2Nlc3NvcnMpIHx8IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRDb3JlcyAmJiBjb3VudFRocmVhZHMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzID0gcGFyc2VJbnQoY291bnRUaHJlYWRzKSB8fCB1dGlsLmNvcmVzKCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbENvcmVzID0gcGFyc2VJbnQoY291bnRDb3JlcykgfHwgdXRpbC5jb3JlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3B1Q2FjaGUoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlID0gcmVzO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgbGV0IG1vZGVsbGluZSA9ICcnO1xuICAgICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChvcy5jcHVzKClbMF0gJiYgb3MuY3B1cygpWzBdLm1vZGVsKSB7IG1vZGVsbGluZSA9IG9zLmNwdXMoKVswXS5tb2RlbDsgfVxuICAgICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgbHNjcHU7IGVjaG8gLW4gXCJHb3Zlcm5vcjogXCI7IGNhdCAvc3lzL2RldmljZXMvc3lzdGVtL2NwdS9jcHUwL2NwdWZyZXEvc2NhbGluZ19nb3Zlcm5vciAyPi9kZXYvbnVsbDsgZWNobzsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RlbGxpbmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwgbmFtZScpIHx8IG1vZGVsbGluZTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsbGluZVBhcnRzID0gbW9kZWxsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICByZXN1bHQuYnJhbmQgPSBtb2RlbGxpbmVQYXJ0c1swXS50cmltKCk7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBtb2RlbGxpbmVQYXJ0c1sxXSA/IHBhcnNlRmxvYXQobW9kZWxsaW5lUGFydHNbMV0udHJpbSgpKSA6IDA7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwICYmIChyZXN1bHQuYnJhbmQuaW5kZXhPZignQU1EJykgPiAtMSB8fCByZXN1bHQuYnJhbmQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyeXplbicpID4gLTEpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IGdldEFNRFNwZWVkKHJlc3VsdC5icmFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnNwZWVkID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRDcHVDdXJyZW50U3BlZWRTeW5jKCk7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50LmF2ZyAhPT0gMCkgeyByZXN1bHQuc3BlZWQgPSBjdXJyZW50LmF2ZzsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NwdV9zcGVlZCA9IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgIHJlc3VsdC5zcGVlZE1pbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY3B1IG1pbiBtaHonKS5yZXBsYWNlKC8sL2csICcuJykpIC8gMTAuMCkgLyAxMDA7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNYXggPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NwdSBtYXggbWh6JykucmVwbGFjZSgvLC9nLCAnLicpKSAvIDEwLjApIC8gMTAwO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBjcHVCcmFuZE1hbnVmYWN0dXJlcihyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IGNwdU1hbnVmYWN0dXJlcih1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVuZG9yIGlkJykpO1xuXG4gICAgICAgICAgICByZXN1bHQuZmFtaWx5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NwdSBmYW1pbHknKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbDonKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGVwcGluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzdGVwcGluZycpO1xuICAgICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NwdSByZXZpc2lvbicpO1xuICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMWQgY2FjaGUnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDFkKSB7IHJlc3VsdC5jYWNoZS5sMWQgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDFkKSAqIChyZXN1bHQuY2FjaGUubDFkLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChyZXN1bHQuY2FjaGUubDFkLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpOyB9XG4gICAgICAgICAgICByZXN1bHQuY2FjaGUubDFpID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wxaSBjYWNoZScpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMWkpIHsgcmVzdWx0LmNhY2hlLmwxaSA9IHBhcnNlSW50KHJlc3VsdC5jYWNoZS5sMWkpICogKHJlc3VsdC5jYWNoZS5sMWkuaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHJlc3VsdC5jYWNoZS5sMWkuaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7IH1cbiAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdsMiBjYWNoZScpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMikgeyByZXN1bHQuY2FjaGUubDIgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDIpICogKHJlc3VsdC5jYWNoZS5sMi5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocmVzdWx0LmNhY2hlLmwyLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpOyB9XG4gICAgICAgICAgICByZXN1bHQuY2FjaGUubDMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbDMgY2FjaGUnKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGUubDMpIHsgcmVzdWx0LmNhY2hlLmwzID0gcGFyc2VJbnQocmVzdWx0LmNhY2hlLmwzKSAqIChyZXN1bHQuY2FjaGUubDMuaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHJlc3VsdC5jYWNoZS5sMy5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTsgfVxuXG4gICAgICAgICAgICBjb25zdCB0aHJlYWRzUGVyQ29yZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd0aHJlYWQocykgcGVyIGNvcmUnKSB8fCAnMSc7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3JzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NvY2tldChzKScpIHx8ICcxJztcbiAgICAgICAgICAgIGxldCB0aHJlYWRzUGVyQ29yZUludCA9IHBhcnNlSW50KHRocmVhZHNQZXJDb3JlLCAxMCk7IC8vIHRocmVhZHMgcGVyIGNvZGUgKG5vcm1hbGx5IG9ubHkgZm9yIHBlcmZvcm1hbmNlIGNvcmVzKVxuICAgICAgICAgICAgbGV0IHByb2Nlc3NvcnNJbnQgPSBwYXJzZUludChwcm9jZXNzb3JzLCAxMCkgfHwgMTsgIC8vIG51bWJlciBvZiBzb2NrZXRzIC8gIHByb2Nlc3NvciB1bml0cyBpbiBtYWNoaW5lIChub3JtYWxseSAxKVxuICAgICAgICAgICAgY29uc3QgY29yZXNQZXJTb2NrZXQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY29yZShzKSBwZXIgc29ja2V0JyksIDEwKTsgLy8gbnVtYmVyIG9mIGNvcmVzIChlLmcuIDE2IG9uIGkxMjkwMClcbiAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbENvcmVzID0gY29yZXNQZXJTb2NrZXQgPyBjb3Jlc1BlclNvY2tldCAqIHByb2Nlc3NvcnNJbnQgOiByZXN1bHQuY29yZXMgLyB0aHJlYWRzUGVyQ29yZUludDtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJmb3JtYW5jZUNvcmVzID0gdGhyZWFkc1BlckNvcmVJbnQgPiAxID8gcmVzdWx0LmNvcmVzIC0gcmVzdWx0LnBoeXNpY2FsQ29yZXMgOiByZXN1bHQuY29yZXM7XG4gICAgICAgICAgICByZXN1bHQuZWZmaWNpZW5jeUNvcmVzID0gdGhyZWFkc1BlckNvcmVJbnQgPiAxID8gcmVzdWx0LmNvcmVzIC0gKHRocmVhZHNQZXJDb3JlSW50ICogcmVzdWx0LnBlcmZvcm1hbmNlQ29yZXMpIDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5wcm9jZXNzb3JzID0gcHJvY2Vzc29yc0ludDtcbiAgICAgICAgICAgIHJlc3VsdC5nb3Zlcm5vciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdnb3Zlcm5vcicpIHx8ICcnO1xuXG4gICAgICAgICAgICAvLyBUZXN0IFJhc3BiZXJyeVxuICAgICAgICAgICAgaWYgKHJlc3VsdC52ZW5kb3IgPT09ICdBUk0nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzUnBpID0gZnMucmVhZEZpbGVTeW5jKCcvcHJvYy9jcHVpbmZvJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHJQSVJldmlzaW9uID0gdXRpbC5kZWNvZGVQaUNwdWluZm8obGluZXNScGkpO1xuICAgICAgICAgICAgICBpZiAoclBJUmV2aXNpb24ubW9kZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyYXNwYmVycnknKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IHJlc3VsdC5tYW51ZmFjdHVyZXI7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHJQSVJldmlzaW9uLm1hbnVmYWN0dXJlcjtcbiAgICAgICAgICAgICAgICByZXN1bHQuYnJhbmQgPSByUElSZXZpc2lvbi5wcm9jZXNzb3I7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gclBJUmV2aXNpb24ucmV2aXNpb25Db2RlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSAnU09DJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzb2NrZXQgdHlwZVxuICAgICAgICAgICAgbGV0IGxpbmVzMiA9IFtdO1xuICAgICAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUg4oCTdCA0IDI+L2Rldi9udWxsIHwgZ3JlcCBcIlVwZ3JhZGU6IFNvY2tldFwiOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IyLCBzdGRvdXQyKSB7XG4gICAgICAgICAgICAgIGxpbmVzMiA9IHN0ZG91dDIudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGlmIChsaW5lczIgJiYgbGluZXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ1VwZ3JhZGUnKS5yZXBsYWNlKCdTb2NrZXQnLCAnJykudHJpbSgpIHx8IHJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICBsZXQgbW9kZWxsaW5lID0gJyc7XG4gICAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgICAgaWYgKG9zLmNwdXMoKVswXSAmJiBvcy5jcHVzKClbMF0ubW9kZWwpIHsgbW9kZWxsaW5lID0gb3MuY3B1cygpWzBdLm1vZGVsOyB9XG4gICAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgNDsgZG1pZGVjb2RlIC10IDcgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGxldCBjYWNoZSA9IFtdO1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJyMgZG1pZGVjb2RlJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGRhdGEubGVuZ3RoID4gMSA/IGRhdGFbMV0gOiAnJztcbiAgICAgICAgICAgICAgY2FjaGUgPSBkYXRhLmxlbmd0aCA+IDIgPyBkYXRhWzJdLnNwbGl0KCdDYWNoZSBJbmZvcm1hdGlvbicpIDogW107XG5cbiAgICAgICAgICAgICAgbGluZXMgPSBwcm9jZXNzb3Iuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmJyYW5kID0gbW9kZWxsaW5lLnNwbGl0KCdAJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gbW9kZWxsaW5lLnNwbGl0KCdAJylbMV0gPyBwYXJzZUZsb2F0KG1vZGVsbGluZS5zcGxpdCgnQCcpWzFdLnRyaW0oKSkgOiAwO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCAmJiAocmVzdWx0LmJyYW5kLmluZGV4T2YoJ0FNRCcpID4gLTEgfHwgcmVzdWx0LmJyYW5kLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncnl6ZW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSBnZXRBTURTcGVlZChyZXN1bHQuYnJhbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gZ2V0Q3B1Q3VycmVudFNwZWVkU3luYygpO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudC5hdmcgIT09IDApIHsgcmVzdWx0LnNwZWVkID0gY3VycmVudC5hdmc7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jcHVfc3BlZWQgPSByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNaW4gPSByZXN1bHQuc3BlZWQ7XG4gICAgICAgICAgICByZXN1bHQuc3BlZWRNYXggPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21heCBzcGVlZCcpLnJlcGxhY2UoL01oei9nLCAnJykpIC8gMTAuMCkgLyAxMDA7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGNwdUJyYW5kTWFudWZhY3R1cmVyKHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQudmVuZG9yID0gY3B1TWFudWZhY3R1cmVyKHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInKSk7XG4gICAgICAgICAgICBsZXQgc2lnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NpZ25hdHVyZScpO1xuICAgICAgICAgICAgc2lnID0gc2lnLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzaWdbaV0gPSBzaWdbaV0udHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IHV0aWwuZ2V0VmFsdWUoc2lnLCAnRmFtaWx5JywgJyAnLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUoc2lnLCAnTW9kZWwnLCAnICcsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0LnN0ZXBwaW5nID0gdXRpbC5nZXRWYWx1ZShzaWcsICdTdGVwcGluZycsICcgJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQucmV2aXNpb24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IHZvbHRhZ2UgPSBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2b2x0YWdlJykpO1xuICAgICAgICAgICAgcmVzdWx0LnZvbHRhZ2UgPSBpc05hTih2b2x0YWdlKSA/ICcnIDogdm9sdGFnZS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsaW5lcyA9IGNhY2hlW2ldLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IGNhY2hlVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTb2NrZXQgRGVzaWduYXRpb24nKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJyAnLCAnLScpLnNwbGl0KCctJyk7XG4gICAgICAgICAgICAgIGNhY2hlVHlwZSA9IGNhY2hlVHlwZS5sZW5ndGggPyBjYWNoZVR5cGVbMF0gOiAnJztcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZVBhcnRzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0luc3RhbGxlZCBTaXplJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChzaXplUGFydHNbMF0sIDEwKTtcbiAgICAgICAgICAgICAgY29uc3QgdW5pdCA9IHNpemVQYXJ0cy5sZW5ndGggPiAxID8gc2l6ZVBhcnRzWzFdIDogJ2tiJztcbiAgICAgICAgICAgICAgc2l6ZSA9IHNpemUgKiAodW5pdCA9PT0gJ2tiJyA/IDEwMjQgOiAodW5pdCA9PT0gJ21iJyA/IDEwMjQgKiAxMDI0IDogKHVuaXQgPT09ICdnYicgPyAxMDI0ICogMTAyNCAqIDEwMjQgOiAxKSkpO1xuICAgICAgICAgICAgICBpZiAoY2FjaGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlVHlwZSA9PT0gJ2wxJykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZSArICdkJ10gPSBzaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGUgKyAnaSddID0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGVdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvY2tldCB0eXBlXG4gICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VwZ3JhZGUnKS5yZXBsYWNlKCdTb2NrZXQnLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgLy8gIyB0aHJlYWRzIC8gIyBjb3Jlc1xuICAgICAgICAgICAgY29uc3QgdGhyZWFkQ291bnQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndGhyZWFkIGNvdW50JykudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgY29yZUNvdW50ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NvcmUgY291bnQnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoY29yZUNvdW50ICYmIHRocmVhZENvdW50KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5jb3JlcyA9IHBhcnNlSW50KHRocmVhZENvdW50LCAxMCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5waHlzaWNhbENvcmVzID0gcGFyc2VJbnQoY29yZUNvdW50LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfcHJvY2Vzc29yIHwgc2VsZWN0IE5hbWUsIFJldmlzaW9uLCBMMkNhY2hlU2l6ZSwgTDNDYWNoZVNpemUsIE1hbnVmYWN0dXJlciwgTWF4Q2xvY2tTcGVlZCwgRGVzY3JpcHRpb24sIFVwZ3JhZGVNZXRob2QsIENhcHRpb24sIE51bWJlck9mTG9naWNhbFByb2Nlc3NvcnMsIE51bWJlck9mQ29yZXMgfCBmbCcpKTtcbiAgICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ2FjaGVNZW1vcnkgfCBzZWxlY3QgQ2FjaGVUeXBlLEluc3RhbGxlZFNpemUsTGV2ZWwgfCBmbCcpKTtcbiAgICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCcoR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NvbXB1dGVyU3lzdGVtKS5IeXBlcnZpc29yUHJlc2VudCcpKTtcblxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGF0YVswXS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpIHx8ICcnO1xuICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdAJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5icmFuZCA9IG5hbWUuc3BsaXQoJ0AnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNwZWVkID0gbmFtZS5zcGxpdCgnQCcpWzFdID8gcGFyc2VGbG9hdChuYW1lLnNwbGl0KCdAJylbMV0udHJpbSgpKSA6IDA7XG4gICAgICAgICAgICAgICAgX2NwdV9zcGVlZCA9IHJlc3VsdC5zcGVlZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYnJhbmQgPSBuYW1lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3BlZWQgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNwdUJyYW5kTWFudWZhY3R1cmVyKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5yZXZpc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdyZXZpc2lvbicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWNoZS5sMWQgPSAwO1xuICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFpID0gMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wyY2FjaGVzaXplJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wzY2FjaGVzaXplJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMikgeyByZXN1bHQuY2FjaGUubDIgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDIsIDEwKSAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jYWNoZS5sMykgeyByZXN1bHQuY2FjaGUubDMgPSBwYXJzZUludChyZXN1bHQuY2FjaGUubDMsIDEwKSAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuc3BlZWRNYXggPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21heGNsb2Nrc3BlZWQnLCAnOicpLnJlcGxhY2UoLywvZywgJy4nKSkgLyAxMC4wKSAvIDEwMDtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCAmJiAocmVzdWx0LmJyYW5kLmluZGV4T2YoJ0FNRCcpID4gLTEgfHwgcmVzdWx0LmJyYW5kLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncnl6ZW4nKSA+IC0xKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IGdldEFNRFNwZWVkKHJlc3VsdC5icmFuZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zcGVlZCA9IHJlc3VsdC5zcGVlZE1heDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc3BlZWRNaW4gPSByZXN1bHQuc3BlZWQ7XG5cbiAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Rlc2NyaXB0aW9uJywgJzonKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uW2ldLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZmFtaWx5JykgJiYgKGkgKyAxKSA8IGRlc2NyaXB0aW9uLmxlbmd0aCAmJiBkZXNjcmlwdGlvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5mYW1pbHkgPSBkZXNjcmlwdGlvbltpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbltpXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ21vZGVsJykgJiYgKGkgKyAxKSA8IGRlc2NyaXB0aW9uLmxlbmd0aCAmJiBkZXNjcmlwdGlvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IGRlc2NyaXB0aW9uW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uW2ldLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnc3RlcHBpbmcnKSAmJiAoaSArIDEpIDwgZGVzY3JpcHRpb24ubGVuZ3RoICYmIGRlc2NyaXB0aW9uW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBwaW5nID0gZGVzY3JpcHRpb25baSArIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBzb2NrZXQgdHlwZVxuICAgICAgICAgICAgICBjb25zdCBzb2NrZXRJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdVcGdyYWRlTWV0aG9kJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKHNvY2tldFR5cGVzW3NvY2tldElkXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQgPSBzb2NrZXRUeXBlc1tzb2NrZXRJZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc29ja2V0QnlOYW1lID0gZ2V0U29ja2V0VHlwZXNCeU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgIGlmIChzb2NrZXRCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc29ja2V0ID0gc29ja2V0QnlOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICMgdGhyZWFkcyAvICMgY29yZXNcbiAgICAgICAgICAgICAgY29uc3QgY291bnRQcm9jZXNzb3JzID0gdXRpbC5jb3VudExpbmVzKGxpbmVzLCAnQ2FwdGlvbicpO1xuICAgICAgICAgICAgICBjb25zdCBjb3VudFRocmVhZHMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTnVtYmVyT2ZMb2dpY2FsUHJvY2Vzc29ycycsICc6Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvdW50Q29yZXMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTnVtYmVyT2ZDb3JlcycsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChjb3VudFByb2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHJvY2Vzc29ycyA9IHBhcnNlSW50KGNvdW50UHJvY2Vzc29ycykgfHwgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY291bnRDb3JlcyAmJiBjb3VudFRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMgPSBwYXJzZUludChjb3VudFRocmVhZHMpIHx8IHV0aWwuY29yZXMoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucGh5c2ljYWxDb3JlcyA9IHBhcnNlSW50KGNvdW50Q29yZXMpIHx8IHV0aWwuY29yZXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY291bnRQcm9jZXNzb3JzID4gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3JlcyA9IHJlc3VsdC5jb3JlcyAqIGNvdW50UHJvY2Vzc29ycztcbiAgICAgICAgICAgICAgICByZXN1bHQucGh5c2ljYWxDb3JlcyA9IHJlc3VsdC5waHlzaWNhbENvcmVzICogY291bnRQcm9jZXNzb3JzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZGF0YVsxXS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBwYXJ0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FjaGVUeXBlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTGV2ZWwnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YWxsZWRTaXplID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0luc3RhbGxlZFNpemUnKTtcbiAgICAgICAgICAgICAgICAvLyBMMSBJbnN0cnVjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICczJykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxaSA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTDEgRGF0YVxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzQnKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFkID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMMSBhbGxcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICc1JyAmJiAhcmVzdWx0LmNhY2hlLmwxaSAmJiAhcmVzdWx0LmNhY2hlLmwxZCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlLmwxaSA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKSAvIDI7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGUubDFkID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBoeXBlcnYgPSBkYXRhWzJdID8gZGF0YVsyXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxpemF0aW9uID0gaHlwZXJ2LmluZGV4T2YoJ3RydWUnKSAhPT0gLTE7XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIC0gUHJvY2Vzc29yIERhdGFcblxuZnVuY3Rpb24gY3B1KGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBnZXRDcHUoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jcHUgPSBjcHU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgLSBjdXJyZW50IHNwZWVkIC0gaW4gR0h6XG5cbmZ1bmN0aW9uIGdldENwdUN1cnJlbnRTcGVlZFN5bmMoKSB7XG5cbiAgbGV0IGNwdXMgPSBvcy5jcHVzKCk7XG4gIGxldCBtaW5GcmVxID0gOTk5OTk5OTk5O1xuICBsZXQgbWF4RnJlcSA9IDA7XG4gIGxldCBhdmdGcmVxID0gMDtcbiAgbGV0IGNvcmVzID0gW107XG5cbiAgaWYgKGNwdXMgJiYgY3B1cy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpIGluIGNwdXMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNwdXMsIGkpKSB7XG4gICAgICAgIGxldCBmcmVxID0gY3B1c1tpXS5zcGVlZCA+IDEwMCA/IChjcHVzW2ldLnNwZWVkICsgMSkgLyAxMDAwIDogY3B1c1tpXS5zcGVlZCAvIDEwO1xuICAgICAgICBhdmdGcmVxID0gYXZnRnJlcSArIGZyZXE7XG4gICAgICAgIGlmIChmcmVxID4gbWF4RnJlcSkgeyBtYXhGcmVxID0gZnJlcTsgfVxuICAgICAgICBpZiAoZnJlcSA8IG1pbkZyZXEpIHsgbWluRnJlcSA9IGZyZXE7IH1cbiAgICAgICAgY29yZXMucHVzaChwYXJzZUZsb2F0KGZyZXEudG9GaXhlZCgyKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhdmdGcmVxID0gYXZnRnJlcSAvIGNwdXMubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IHBhcnNlRmxvYXQobWluRnJlcS50b0ZpeGVkKDIpKSxcbiAgICAgIG1heDogcGFyc2VGbG9hdChtYXhGcmVxLnRvRml4ZWQoMikpLFxuICAgICAgYXZnOiBwYXJzZUZsb2F0KChhdmdGcmVxKS50b0ZpeGVkKDIpKSxcbiAgICAgIGNvcmVzOiBjb3Jlc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMCxcbiAgICAgIGF2ZzogMCxcbiAgICAgIGNvcmVzOiBjb3Jlc1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY3B1Q3VycmVudFNwZWVkKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gZ2V0Q3B1Q3VycmVudFNwZWVkU3luYygpO1xuICAgICAgaWYgKHJlc3VsdC5hdmcgPT09IDAgJiYgX2NwdV9zcGVlZCAhPT0gMCkge1xuICAgICAgICBjb25zdCBjdXJyQ3B1U3BlZWQgPSBwYXJzZUZsb2F0KF9jcHVfc3BlZWQpO1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgbWluOiBjdXJyQ3B1U3BlZWQsXG4gICAgICAgICAgbWF4OiBjdXJyQ3B1U3BlZWQsXG4gICAgICAgICAgYXZnOiBjdXJyQ3B1U3BlZWQsXG4gICAgICAgICAgY29yZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jcHVDdXJyZW50U3BlZWQgPSBjcHVDdXJyZW50U3BlZWQ7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDUFUgLSB0ZW1wZXJhdHVyZVxuLy8gaWYgc2Vuc29ycyBhcmUgaW5zdGFsbGVkXG5cbmZ1bmN0aW9uIGNwdVRlbXBlcmF0dXJlKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBtYWluOiBudWxsLFxuICAgICAgICBjb3JlczogW10sXG4gICAgICAgIG1heDogbnVsbCxcbiAgICAgICAgc29ja2V0OiBbXSxcbiAgICAgICAgY2hpcHNldDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgLy8gQ1BVIENoaXBzZXQsIFNvY2tldFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNtZCA9ICdjYXQgL3N5cy9jbGFzcy90aGVybWFsL3RoZXJtYWxfem9uZSovdHlwZSAgMj4vZGV2L251bGw7IGVjaG8gXCItLS0tLVwiOyBjYXQgL3N5cy9jbGFzcy90aGVybWFsL3RoZXJtYWxfem9uZSovdGVtcCAyPi9kZXYvbnVsbDsnO1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCctLS0tLVxcbicpO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydHNbMF0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMyID0gcGFydHNbMV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdhY3BpJykgJiYgbGluZXMyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNvY2tldC5wdXNoKE1hdGgucm91bmQocGFyc2VJbnQobGluZXMyW2ldLCAxMCkgLyAxMDApIC8gMTApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ3BjaCcpICYmIGxpbmVzMltpXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jaGlwc2V0ID0gTWF0aC5yb3VuZChwYXJzZUludChsaW5lczJbaV0sIDEwKSAvIDEwMCkgLyAxMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY21kID0gJ2ZvciBtb24gaW4gL3N5cy9jbGFzcy9od21vbi9od21vbio7IGRvIGZvciBsYWJlbCBpbiBcIiRtb25cIi90ZW1wKl9sYWJlbDsgZG8gaWYgWyAtZiAkbGFiZWwgXTsgdGhlbiB2YWx1ZT0ke2xhYmVsJV8qfV9pbnB1dDsgZWNobyAkKGNhdCBcIiRsYWJlbFwiKV9fXyQoY2F0IFwiJHZhbHVlXCIpOyBmaTsgZG9uZTsgZG9uZTsnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB0ZGllUG9zID0gc3Rkb3V0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndGRpZScpO1xuICAgICAgICAgICAgaWYgKHRkaWVQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHN0ZG91dCA9IHN0ZG91dC5zdWJzdHJpbmcodGRpZVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCdfX18nKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzWzFdID8gcGFydHNbMV0gOiAnMCc7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAobGFiZWwgPT09IHVuZGVmaW5lZCB8fCAobGFiZWwgJiYgbGFiZWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjb3JlJykpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3Jlcy5wdXNoKE1hdGgucm91bmQocGFyc2VJbnQodmFsdWUsIDEwKSAvIDEwMCkgLyAxMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgbGFiZWwgJiYgcmVzdWx0Lm1haW4gPT09IG51bGwgJiYgKGxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncGFja2FnZScpID49IDAgfHwgbGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwaHlzaWNhbCcpID49IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBNYXRoLnJvdW5kKHBhcnNlSW50KHZhbHVlLCAxMCkgLyAxMDApIC8gMTA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmNvcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYWluID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1haW4gPSBNYXRoLnJvdW5kKHJlc3VsdC5jb3Jlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHJlc3VsdC5jb3Jlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBtYXh0bXAgPSBNYXRoLm1heC5hcHBseShNYXRoLCByZXN1bHQuY29yZXMpO1xuICAgICAgICAgICAgICByZXN1bHQubWF4ID0gKG1heHRtcCA+IHJlc3VsdC5tYWluKSA/IG1heHRtcCA6IHJlc3VsdC5tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5tYWluICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubWF4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHJlc3VsdC5tYWluO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlYygnc2Vuc29ycycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgbGV0IHRkaWVUZW1wID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U2VjdGlvblN0YXJ0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSAnJztcbiAgICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZWN0aW9uU3RhcnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3U2VjdGlvblN0YXJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdhY3BpJykpIHsgc2VjdGlvbiA9ICdhY3BpJzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdwY2gnKSkgeyBzZWN0aW9uID0gJ3BjaCc7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnY29yZScpKSB7IHNlY3Rpb24gPSAnY29yZSc7IH1cbiAgICAgICAgICAgICAgICAgICAgbmV3U2VjdGlvblN0YXJ0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gL1srLV0oW17CsF0qKS9nO1xuICAgICAgICAgICAgICAgICAgbGV0IHRlbXBzID0gbGluZS5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3RQYXJ0ID0gbGluZS5zcGxpdCgnOicpWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbiA9PT0gJ2FjcGknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvY2tldCB0ZW1wXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuaW5kZXhPZignVEVNUCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zb2NrZXQucHVzaChwYXJzZUZsb2F0KHRlbXBzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VjdGlvbiA9PT0gJ3BjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hpcHNldCB0ZW1wXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFBhcnQuaW5kZXhPZignVEVNUCcpICE9PSAtMSAmJiAhcmVzdWx0LmNoaXBzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2hpcHNldCA9IHBhcnNlRmxvYXQodGVtcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBjcHUgdGVtcFxuICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydC5pbmRleE9mKCdQSFlTSUNBTCcpICE9PSAtMSB8fCBmaXJzdFBhcnQuaW5kZXhPZignUEFDS0FHRScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IHBhcnNlRmxvYXQodGVtcHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydC5pbmRleE9mKCdDT1JFICcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMucHVzaChwYXJzZUZsb2F0KHRlbXBzKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQYXJ0LmluZGV4T2YoJ1RESUUnKSAhPT0gLTEgJiYgdGRpZVRlbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGRpZVRlbXAgPSBwYXJzZUZsb2F0KHRlbXBzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gTWF0aC5yb3VuZChyZXN1bHQuY29yZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyByZXN1bHQuY29yZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgIGxldCBtYXh0bXAgPSBNYXRoLm1heC5hcHBseShNYXRoLCByZXN1bHQuY29yZXMpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IChtYXh0bXAgPiByZXN1bHQubWFpbikgPyBtYXh0bXAgOiByZXN1bHQubWFpbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYWluID09PSBudWxsICYmIHRkaWVUZW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gdGRpZVRlbXA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSB0ZGllVGVtcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tYWluICE9PSBudWxsIHx8IHJlc3VsdC5tYXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZzLnN0YXQoJy9zeXMvY2xhc3MvdGhlcm1hbC90aGVybWFsX3pvbmUwL3RlbXAnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGUoJy9zeXMvY2xhc3MvdGhlcm1hbC90aGVybWFsX3pvbmUwL3RlbXAnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IHBhcnNlRmxvYXQobGluZXNbMF0pIC8gMTAwMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHJlc3VsdC5tYWluO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXhlYygnL29wdC92Yy9iaW4vdmNnZW5jbWQgbWVhc3VyZV90ZW1wJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1swXS5pbmRleE9mKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gcGFyc2VGbG9hdChsaW5lc1swXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSByZXN1bHQubWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdzeXNjdGwgZGV2LmNwdSB8IGdyZXAgdGVtcCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBwYXJzZUZsb2F0KHBhcnRzWzFdLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcCA+IHJlc3VsdC5tYXgpIHsgcmVzdWx0Lm1heCA9IHRlbXA7IH1cbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyB0ZW1wO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3Jlcy5wdXNoKHRlbXApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY29yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYWluID0gTWF0aC5yb3VuZChzdW0gLyByZXN1bHQuY29yZXMubGVuZ3RoICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgLypcbiAgICAgICAgbGV0IG9zeFRlbXAgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vb3N4VGVtcCA9IHJlcXVpcmUoJ29zeC10ZW1wZXJhdHVyZS1zZW5zb3InKTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBvc3hUZW1wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3N4VGVtcCkge1xuICAgICAgICAgIC8vcmVzdWx0ID0gb3N4VGVtcC5jcHVUZW1wZXJhdHVyZSgpO1xuICAgICAgICAgIC8vIHJvdW5kIHRvIDIgZGlnaXRzXG4gICAgICAgICAgaWYgKHJlc3VsdC5tYWluKSB7XG4gICAgICAgICAgICByZXN1bHQubWFpbiA9IE1hdGgucm91bmQocmVzdWx0Lm1haW4gKiAxMDApIC8gMTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0Lm1heCkge1xuICAgICAgICAgICAgcmVzdWx0Lm1heCA9IE1hdGgucm91bmQocmVzdWx0Lm1heCAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuY29yZXMgJiYgcmVzdWx0LmNvcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQuY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmNvcmVzW2ldID0gTWF0aC5yb3VuZChyZXN1bHQuY29yZXNbaV0gKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgKi9cbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgTVNBY3BpX1RoZXJtYWxab25lVGVtcGVyYXR1cmUgLU5hbWVzcGFjZSBcInJvb3Qvd21pXCIgfCBTZWxlY3QgQ3VycmVudFRlbXBlcmF0dXJlJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpLmZpbHRlcigobGluZSwgaWR4KSA9PiBpZHggPiAwKTtcbiAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IChwYXJzZUludChsaW5lLCAxMCkgLSAyNzMyKSAvIDEwO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdC5tYXgpIHsgcmVzdWx0Lm1heCA9IHZhbHVlOyB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQuY29yZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jb3Jlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWFpbiA9IHN1bSAvIHJlc3VsdC5jb3Jlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jcHVUZW1wZXJhdHVyZSA9IGNwdVRlbXBlcmF0dXJlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIEZsYWdzXG5cbmZ1bmN0aW9uIGNwdUZsYWdzKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKCdyZWcgcXVlcnkgXCJIS0VZX0xPQ0FMX01BQ0hJTkVcXFxcSEFSRFdBUkVcXFxcREVTQ1JJUFRJT05cXFxcU3lzdGVtXFxcXENlbnRyYWxQcm9jZXNzb3JcXFxcMFwiIC92IEZlYXR1cmVTZXQnLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgZmxhZ19oZXggPSBzdGRvdXQuc3BsaXQoJzB4JykucG9wKCkudHJpbSgpO1xuICAgICAgICAgICAgICBsZXQgZmxhZ19iaW5fdW5wYWRkZWQgPSBwYXJzZUludChmbGFnX2hleCwgMTYpLnRvU3RyaW5nKDIpO1xuICAgICAgICAgICAgICBsZXQgZmxhZ19iaW4gPSAnMCcucmVwZWF0KDMyIC0gZmxhZ19iaW5fdW5wYWRkZWQubGVuZ3RoKSArIGZsYWdfYmluX3VucGFkZGVkO1xuICAgICAgICAgICAgICAvLyBlbXB0eSBmbGFncyBhcmUgdGhlIHJlc2VydmVkIGZpZWxkcyBpbiB0aGUgQ1BVSUQgZmVhdHVyZSBiaXQgbGlzdFxuICAgICAgICAgICAgICAvLyBhcyBmb3VuZCBvbiB3aWtpcGVkaWE6XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NQVUlEXG4gICAgICAgICAgICAgIGxldCBhbGxfZmxhZ3MgPSBbXG4gICAgICAgICAgICAgICAgJ2ZwdScsICd2bWUnLCAnZGUnLCAncHNlJywgJ3RzYycsICdtc3InLCAncGFlJywgJ21jZScsICdjeDgnLCAnYXBpYycsXG4gICAgICAgICAgICAgICAgJycsICdzZXAnLCAnbXRycicsICdwZ2UnLCAnbWNhJywgJ2Ntb3YnLCAncGF0JywgJ3BzZS0zNicsICdwc24nLCAnY2xmc2gnLFxuICAgICAgICAgICAgICAgICcnLCAnZHMnLCAnYWNwaScsICdtbXgnLCAnZnhzcicsICdzc2UnLCAnc3NlMicsICdzcycsICdodHQnLCAndG0nLCAnaWE2NCcsICdwYmUnXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgYWxsX2ZsYWdzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdfYmluW2ZdID09PSAnMScgJiYgYWxsX2ZsYWdzW2ZdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIGFsbF9mbGFnc1tmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGxzY3B1OyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zcGxpdCgnOicpWzBdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignRkxBR1MnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxpbmUuc3BsaXQoJzonKVsxXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgZnMucmVhZEZpbGUoJy9wcm9jL2NwdWluZm8nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdmZWF0dXJlcycsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IDQgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGZsYWdzID0gW107XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgbGV0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcdEZsYWdzOicpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0uc3BsaXQoJ1xcdFZlcnNpb246JylbMF0uc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIGxldCBmbGFnID0gKGxpbmUuaW5kZXhPZignKCcpID8gbGluZS5zcGxpdCgnKCcpWzBdLnRvTG93ZXJDYXNlKCkgOiAnJykudHJpbSgpLnJlcGxhY2UoL1xcdC9nLCAnJyk7XG4gICAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZsYWdzLmpvaW4oJyAnKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdzeXNjdGwgbWFjaGRlcC5jcHUuZmVhdHVyZXMnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzWzBdLmluZGV4T2YoJ21hY2hkZXAuY3B1LmZlYXR1cmVzOicpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBsaW5lc1swXS5zcGxpdCgnOicpWzFdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuY3B1RmxhZ3MgPSBjcHVGbGFncztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENQVSBDYWNoZVxuXG5mdW5jdGlvbiBjcHVDYWNoZShjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBsMWQ6IG51bGwsXG4gICAgICAgIGwxaTogbnVsbCxcbiAgICAgICAgbDI6IG51bGwsXG4gICAgICAgIGwzOiBudWxsLFxuICAgICAgfTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGxzY3B1OyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTDFEIENBQ0hFJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubDFkID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0wxSSBDQUNIRScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxaSA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignTScpICE9PSAtMSA/IDEwMjQgKiAxMDI0IDogKHBhcnRzWzFdLmluZGV4T2YoJ0snKSAhPT0gLTEgPyAxMDI0IDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9VcHBlckNhc2UoKS5pbmRleE9mKCdMMiBDQUNIRScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmwyID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdNJykgIT09IC0xID8gMTAyNCAqIDEwMjQgOiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0wzIENBQ0hFJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubDMgPSBwYXJzZUludChwYXJ0c1sxXS50cmltKCkpICogKHBhcnRzWzFdLmluZGV4T2YoJ00nKSAhPT0gLTEgPyAxMDI0ICogMTAyNCA6IChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCA3IDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBjYWNoZSA9IFtdO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhY2hlID0gZGF0YS5zcGxpdCgnQ2FjaGUgSW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIGNhY2hlLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gY2FjaGVbaV0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgbGV0IGNhY2hlVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTb2NrZXQgRGVzaWduYXRpb24nKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJyAnLCAnLScpLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBjYWNoZVR5cGUgPSBjYWNoZVR5cGUubGVuZ3RoID8gY2FjaGVUeXBlWzBdIDogJyc7XG4gICAgICAgICAgICBjb25zdCBzaXplUGFydHMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSW5zdGFsbGVkIFNpemUnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChzaXplUGFydHNbMF0sIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXQgPSBzaXplUGFydHMubGVuZ3RoID4gMSA/IHNpemVQYXJ0c1sxXSA6ICdrYic7XG4gICAgICAgICAgICBzaXplID0gc2l6ZSAqICh1bml0ID09PSAna2InID8gMTAyNCA6ICh1bml0ID09PSAnbWInID8gMTAyNCAqIDEwMjQgOiAodW5pdCA9PT0gJ2diJyA/IDEwMjQgKiAxMDI0ICogMTAyNCA6IDEpKSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChjYWNoZVR5cGUgPT09ICdsMScpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FjaGVbY2FjaGVUeXBlICsgJ2QnXSA9IHNpemUgLyAyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWNoZVtjYWNoZVR5cGUgKyAnaSddID0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNhY2hlW2NhY2hlVHlwZV0gPSBzaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N5c2N0bCBody5sMWljYWNoZXNpemUgaHcubDFkY2FjaGVzaXplIGh3LmwyY2FjaGVzaXplIGh3LmwzY2FjaGVzaXplJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaHcubDFpY2FjaGVzaXplJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmwxZCA9IHBhcnNlSW50KHBhcnRzWzFdLnRyaW0oKSkgKiAocGFydHNbMV0uaW5kZXhPZignSycpICE9PSAtMSA/IDEwMjQgOiAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdody5sMWRjYWNoZXNpemUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubDFpID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h3LmwyY2FjaGVzaXplJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmwyID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h3LmwzY2FjaGVzaXplJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmwzID0gcGFyc2VJbnQocGFydHNbMV0udHJpbSgpKSAqIChwYXJ0c1sxXS5pbmRleE9mKCdLJykgIT09IC0xID8gMTAyNCA6IDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9wcm9jZXNzb3IgfCBzZWxlY3QgTDJDYWNoZVNpemUsIEwzQ2FjaGVTaXplIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5sMWQgPSAwO1xuICAgICAgICAgICAgICByZXN1bHQubDFpID0gMDtcbiAgICAgICAgICAgICAgcmVzdWx0LmwyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wyY2FjaGVzaXplJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmwzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2wzY2FjaGVzaXplJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sMikgeyByZXN1bHQubDIgPSBwYXJzZUludChyZXN1bHQubDIsIDEwKSAqIDEwMjQ7IH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sMykgeyByZXN1bHQubDMgPSBwYXJzZUludChyZXN1bHQubDMsIDEwKSAqIDEwMjQ7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NhY2hlTWVtb3J5IHwgc2VsZWN0IENhY2hlVHlwZSxJbnN0YWxsZWRTaXplLExldmVsIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FjaGVUeXBlJyk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMZXZlbCcpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFsbGVkU2l6ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnN0YWxsZWRTaXplJyk7XG4gICAgICAgICAgICAgICAgICAvLyBMMSBJbnN0cnVjdGlvbnNcbiAgICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PT0gJzMnICYmIGNhY2hlVHlwZSA9PT0gJzMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sMWkgPSBwYXJzZUludChpbnN0YWxsZWRTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBMMSBEYXRhXG4gICAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICc0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubDFkID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gTDEgYWxsXG4gICAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPT09ICczJyAmJiBjYWNoZVR5cGUgPT09ICc1JyAmJiAhcmVzdWx0LmwxaSAmJiAhcmVzdWx0LmwxZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubDFpID0gcGFyc2VJbnQoaW5zdGFsbGVkU2l6ZSwgMTApIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmwxZCA9IHBhcnNlSW50KGluc3RhbGxlZFNpemUsIDEwKSAvIDI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jcHVDYWNoZSA9IGNwdUNhY2hlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ1BVIC0gY3VycmVudCBsb2FkIC0gaW4gJVxuXG5mdW5jdGlvbiBnZXRMb2FkKCkge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGxvYWRzID0gb3MubG9hZGF2ZygpLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAvIHV0aWwuY29yZXMoKTsgfSk7XG4gICAgICBsZXQgYXZnTG9hZCA9IHBhcnNlRmxvYXQoKE1hdGgubWF4LmFwcGx5KE1hdGgsIGxvYWRzKSkudG9GaXhlZCgyKSk7XG4gICAgICBsZXQgcmVzdWx0ID0ge307XG5cbiAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpIC0gX2N1cnJlbnRfY3B1Lm1zO1xuICAgICAgaWYgKG5vdyA+PSAyMDApIHtcbiAgICAgICAgX2N1cnJlbnRfY3B1Lm1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgY3B1cyA9IG9zLmNwdXMoKTtcbiAgICAgICAgbGV0IHRvdGFsVXNlciA9IDA7XG4gICAgICAgIGxldCB0b3RhbFN5c3RlbSA9IDA7XG4gICAgICAgIGxldCB0b3RhbE5pY2UgPSAwO1xuICAgICAgICBsZXQgdG90YWxJcnEgPSAwO1xuICAgICAgICBsZXQgdG90YWxJZGxlID0gMDtcbiAgICAgICAgbGV0IGNvcmVzID0gW107XG4gICAgICAgIF9jb3JlY291bnQgPSAoY3B1cyAmJiBjcHVzLmxlbmd0aCkgPyBjcHVzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfY29yZWNvdW50OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjcHUgPSBjcHVzW2ldLnRpbWVzO1xuICAgICAgICAgIHRvdGFsVXNlciArPSBjcHUudXNlcjtcbiAgICAgICAgICB0b3RhbFN5c3RlbSArPSBjcHUuc3lzO1xuICAgICAgICAgIHRvdGFsTmljZSArPSBjcHUubmljZTtcbiAgICAgICAgICB0b3RhbElkbGUgKz0gY3B1LmlkbGU7XG4gICAgICAgICAgdG90YWxJcnEgKz0gY3B1LmlycTtcbiAgICAgICAgICBsZXQgdG1wVGljayA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS50b3RhbFRpY2sgPyBfY3B1c1tpXS50b3RhbFRpY2sgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wTG9hZCA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS50b3RhbExvYWQgPyBfY3B1c1tpXS50b3RhbExvYWQgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wVXNlciA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS51c2VyID8gX2NwdXNbaV0udXNlciA6IDApO1xuICAgICAgICAgIGxldCB0bXBTeXN0ZW0gPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0uc3lzID8gX2NwdXNbaV0uc3lzIDogMCk7XG4gICAgICAgICAgbGV0IHRtcE5pY2UgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0ubmljZSA/IF9jcHVzW2ldLm5pY2UgOiAwKTtcbiAgICAgICAgICBsZXQgdG1wSWRsZSA9IChfY3B1cyAmJiBfY3B1c1tpXSAmJiBfY3B1c1tpXS5pZGxlID8gX2NwdXNbaV0uaWRsZSA6IDApO1xuICAgICAgICAgIGxldCB0bXBJcnEgPSAoX2NwdXMgJiYgX2NwdXNbaV0gJiYgX2NwdXNbaV0uaXJxID8gX2NwdXNbaV0uaXJxIDogMCk7XG4gICAgICAgICAgX2NwdXNbaV0gPSBjcHU7XG4gICAgICAgICAgX2NwdXNbaV0udG90YWxUaWNrID0gX2NwdXNbaV0udXNlciArIF9jcHVzW2ldLnN5cyArIF9jcHVzW2ldLm5pY2UgKyBfY3B1c1tpXS5pcnEgKyBfY3B1c1tpXS5pZGxlO1xuICAgICAgICAgIF9jcHVzW2ldLnRvdGFsTG9hZCA9IF9jcHVzW2ldLnVzZXIgKyBfY3B1c1tpXS5zeXMgKyBfY3B1c1tpXS5uaWNlICsgX2NwdXNbaV0uaXJxO1xuICAgICAgICAgIF9jcHVzW2ldLmN1cnJlbnRUaWNrID0gX2NwdXNbaV0udG90YWxUaWNrIC0gdG1wVGljaztcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkID0gKF9jcHVzW2ldLnRvdGFsTG9hZCAtIHRtcExvYWQpO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWRVc2VyID0gKF9jcHVzW2ldLnVzZXIgLSB0bXBVc2VyKTtcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkU3lzdGVtID0gKF9jcHVzW2ldLnN5cyAtIHRtcFN5c3RlbSk7XG4gICAgICAgICAgX2NwdXNbaV0ubG9hZE5pY2UgPSAoX2NwdXNbaV0ubmljZSAtIHRtcE5pY2UpO1xuICAgICAgICAgIF9jcHVzW2ldLmxvYWRJZGxlID0gKF9jcHVzW2ldLmlkbGUgLSB0bXBJZGxlKTtcbiAgICAgICAgICBfY3B1c1tpXS5sb2FkSXJxID0gKF9jcHVzW2ldLmlycSAtIHRtcElycSk7XG4gICAgICAgICAgY29yZXNbaV0gPSB7fTtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkID0gX2NwdXNbaV0ubG9hZCAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRVc2VyID0gX2NwdXNbaV0ubG9hZFVzZXIgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkU3lzdGVtID0gX2NwdXNbaV0ubG9hZFN5c3RlbSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWROaWNlID0gX2NwdXNbaV0ubG9hZE5pY2UgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkSWRsZSA9IF9jcHVzW2ldLmxvYWRJZGxlIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZElycSA9IF9jcHVzW2ldLmxvYWRJcnEgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkID0gX2NwdXNbaV0ubG9hZDtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkVXNlciA9IF9jcHVzW2ldLmxvYWRVc2VyO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRTeXN0ZW0gPSBfY3B1c1tpXS5sb2FkU3lzdGVtO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWROaWNlID0gX2NwdXNbaV0ubG9hZE5pY2U7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZElkbGUgPSBfY3B1c1tpXS5sb2FkSWRsZTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkSXJxID0gX2NwdXNbaV0ubG9hZElycTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWxUaWNrID0gdG90YWxVc2VyICsgdG90YWxTeXN0ZW0gKyB0b3RhbE5pY2UgKyB0b3RhbElycSArIHRvdGFsSWRsZTtcbiAgICAgICAgbGV0IHRvdGFsTG9hZCA9IHRvdGFsVXNlciArIHRvdGFsU3lzdGVtICsgdG90YWxOaWNlICsgdG90YWxJcnE7XG4gICAgICAgIGxldCBjdXJyZW50VGljayA9IHRvdGFsVGljayAtIF9jdXJyZW50X2NwdS50aWNrO1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgYXZnTG9hZDogYXZnTG9hZCxcbiAgICAgICAgICBjdXJyZW50TG9hZDogKHRvdGFsTG9hZCAtIF9jdXJyZW50X2NwdS5sb2FkKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIGN1cnJlbnRMb2FkVXNlcjogKHRvdGFsVXNlciAtIF9jdXJyZW50X2NwdS51c2VyKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIGN1cnJlbnRMb2FkU3lzdGVtOiAodG90YWxTeXN0ZW0gLSBfY3VycmVudF9jcHUuc3lzdGVtKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIGN1cnJlbnRMb2FkTmljZTogKHRvdGFsTmljZSAtIF9jdXJyZW50X2NwdS5uaWNlKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSWRsZTogKHRvdGFsSWRsZSAtIF9jdXJyZW50X2NwdS5pZGxlKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSXJxOiAodG90YWxJcnEgLSBfY3VycmVudF9jcHUuaXJxKSAvIGN1cnJlbnRUaWNrICogMTAwLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkOiAodG90YWxMb2FkIC0gX2N1cnJlbnRfY3B1LmxvYWQpLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkVXNlcjogKHRvdGFsVXNlciAtIF9jdXJyZW50X2NwdS51c2VyKSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFN5c3RlbTogKHRvdGFsU3lzdGVtIC0gX2N1cnJlbnRfY3B1LnN5c3RlbSksXG4gICAgICAgICAgcmF3Q3VycmVudExvYWROaWNlOiAodG90YWxOaWNlIC0gX2N1cnJlbnRfY3B1Lm5pY2UpLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSWRsZTogKHRvdGFsSWRsZSAtIF9jdXJyZW50X2NwdS5pZGxlKSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElycTogKHRvdGFsSXJxIC0gX2N1cnJlbnRfY3B1LmlycSksXG4gICAgICAgICAgY3B1czogY29yZXNcbiAgICAgICAgfTtcbiAgICAgICAgX2N1cnJlbnRfY3B1ID0ge1xuICAgICAgICAgIHVzZXI6IHRvdGFsVXNlcixcbiAgICAgICAgICBuaWNlOiB0b3RhbE5pY2UsXG4gICAgICAgICAgc3lzdGVtOiB0b3RhbFN5c3RlbSxcbiAgICAgICAgICBpZGxlOiB0b3RhbElkbGUsXG4gICAgICAgICAgaXJxOiB0b3RhbElycSxcbiAgICAgICAgICB0aWNrOiB0b3RhbFRpY2ssXG4gICAgICAgICAgbG9hZDogdG90YWxMb2FkLFxuICAgICAgICAgIG1zOiBfY3VycmVudF9jcHUubXMsXG4gICAgICAgICAgY3VycmVudExvYWQ6IHJlc3VsdC5jdXJyZW50TG9hZCxcbiAgICAgICAgICBjdXJyZW50TG9hZFVzZXI6IHJlc3VsdC5jdXJyZW50TG9hZFVzZXIsXG4gICAgICAgICAgY3VycmVudExvYWRTeXN0ZW06IHJlc3VsdC5jdXJyZW50TG9hZFN5c3RlbSxcbiAgICAgICAgICBjdXJyZW50TG9hZE5pY2U6IHJlc3VsdC5jdXJyZW50TG9hZE5pY2UsXG4gICAgICAgICAgY3VycmVudExvYWRJZGxlOiByZXN1bHQuY3VycmVudExvYWRJZGxlLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSXJxOiByZXN1bHQuY3VycmVudExvYWRJcnEsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWQ6IHJlc3VsdC5yYXdDdXJyZW50TG9hZCxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZFVzZXI6IHJlc3VsdC5yYXdDdXJyZW50TG9hZFVzZXIsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRTeXN0ZW06IHJlc3VsdC5yYXdDdXJyZW50TG9hZFN5c3RlbSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZE5pY2U6IHJlc3VsdC5yYXdDdXJyZW50TG9hZE5pY2UsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRJZGxlOiByZXN1bHQucmF3Q3VycmVudExvYWRJZGxlLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSXJxOiByZXN1bHQucmF3Q3VycmVudExvYWRJcnEsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29yZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfY29yZWNvdW50OyBpKyspIHtcbiAgICAgICAgICBjb3Jlc1tpXSA9IHt9O1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWQgPSBfY3B1c1tpXS5sb2FkIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZFVzZXIgPSBfY3B1c1tpXS5sb2FkVXNlciAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRTeXN0ZW0gPSBfY3B1c1tpXS5sb2FkU3lzdGVtIC8gX2NwdXNbaV0uY3VycmVudFRpY2sgKiAxMDA7XG4gICAgICAgICAgY29yZXNbaV0ubG9hZE5pY2UgPSBfY3B1c1tpXS5sb2FkTmljZSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLmxvYWRJZGxlID0gX2NwdXNbaV0ubG9hZElkbGUgLyBfY3B1c1tpXS5jdXJyZW50VGljayAqIDEwMDtcbiAgICAgICAgICBjb3Jlc1tpXS5sb2FkSXJxID0gX2NwdXNbaV0ubG9hZElycSAvIF9jcHVzW2ldLmN1cnJlbnRUaWNrICogMTAwO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWQgPSBfY3B1c1tpXS5sb2FkO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRVc2VyID0gX2NwdXNbaV0ubG9hZFVzZXI7XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZFN5c3RlbSA9IF9jcHVzW2ldLmxvYWRTeXN0ZW07XG4gICAgICAgICAgY29yZXNbaV0ucmF3TG9hZE5pY2UgPSBfY3B1c1tpXS5sb2FkTmljZTtcbiAgICAgICAgICBjb3Jlc1tpXS5yYXdMb2FkSWRsZSA9IF9jcHVzW2ldLmxvYWRJZGxlO1xuICAgICAgICAgIGNvcmVzW2ldLnJhd0xvYWRJcnEgPSBfY3B1c1tpXS5sb2FkSXJxO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBhdmdMb2FkOiBhdmdMb2FkLFxuICAgICAgICAgIGN1cnJlbnRMb2FkOiBfY3VycmVudF9jcHUuY3VycmVudExvYWQsXG4gICAgICAgICAgY3VycmVudExvYWRVc2VyOiBfY3VycmVudF9jcHUuY3VycmVudExvYWRVc2VyLFxuICAgICAgICAgIGN1cnJlbnRMb2FkU3lzdGVtOiBfY3VycmVudF9jcHUuY3VycmVudExvYWRTeXN0ZW0sXG4gICAgICAgICAgY3VycmVudExvYWROaWNlOiBfY3VycmVudF9jcHUuY3VycmVudExvYWROaWNlLFxuICAgICAgICAgIGN1cnJlbnRMb2FkSWRsZTogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkSWRsZSxcbiAgICAgICAgICBjdXJyZW50TG9hZElycTogX2N1cnJlbnRfY3B1LmN1cnJlbnRMb2FkSXJxLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWQsXG4gICAgICAgICAgcmF3Q3VycmVudExvYWRVc2VyOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWRVc2VyLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkU3lzdGVtOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWRTeXN0ZW0sXG4gICAgICAgICAgcmF3Q3VycmVudExvYWROaWNlOiBfY3VycmVudF9jcHUucmF3Q3VycmVudExvYWROaWNlLFxuICAgICAgICAgIHJhd0N1cnJlbnRMb2FkSWRsZTogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkSWRsZSxcbiAgICAgICAgICByYXdDdXJyZW50TG9hZElycTogX2N1cnJlbnRfY3B1LnJhd0N1cnJlbnRMb2FkSXJxLFxuICAgICAgICAgIGNwdXM6IGNvcmVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50TG9hZChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgZ2V0TG9hZCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmN1cnJlbnRMb2FkID0gY3VycmVudExvYWQ7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQUyAtIGZ1bGwgbG9hZFxuLy8gc2luY2UgYm9vdHVwXG5cbmZ1bmN0aW9uIGdldEZ1bGxMb2FkKCkge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBjb25zdCBjcHVzID0gb3MuY3B1cygpO1xuICAgICAgbGV0IHRvdGFsVXNlciA9IDA7XG4gICAgICBsZXQgdG90YWxTeXN0ZW0gPSAwO1xuICAgICAgbGV0IHRvdGFsTmljZSA9IDA7XG4gICAgICBsZXQgdG90YWxJcnEgPSAwO1xuICAgICAgbGV0IHRvdGFsSWRsZSA9IDA7XG5cbiAgICAgIGxldCByZXN1bHQgPSAwO1xuXG4gICAgICBpZiAoY3B1cyAmJiBjcHVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3B1cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNwdSA9IGNwdXNbaV0udGltZXM7XG4gICAgICAgICAgdG90YWxVc2VyICs9IGNwdS51c2VyO1xuICAgICAgICAgIHRvdGFsU3lzdGVtICs9IGNwdS5zeXM7XG4gICAgICAgICAgdG90YWxOaWNlICs9IGNwdS5uaWNlO1xuICAgICAgICAgIHRvdGFsSXJxICs9IGNwdS5pcnE7XG4gICAgICAgICAgdG90YWxJZGxlICs9IGNwdS5pZGxlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbFRpY2tzID0gdG90YWxJZGxlICsgdG90YWxJcnEgKyB0b3RhbE5pY2UgKyB0b3RhbFN5c3RlbSArIHRvdGFsVXNlcjtcbiAgICAgICAgcmVzdWx0ID0gKHRvdGFsVGlja3MgLSB0b3RhbElkbGUpIC8gdG90YWxUaWNrcyAqIDEwMC4wO1xuXG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmdWxsTG9hZChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgZ2V0RnVsbExvYWQoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5mdWxsTG9hZCA9IGZ1bGxMb2FkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBkb2NrZXIuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxMy4gRG9ja2VyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IERvY2tlclNvY2tldCA9IHJlcXVpcmUoJy4vZG9ja2VyU29ja2V0Jyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcblxubGV0IF9kb2NrZXJfY29udGFpbmVyX3N0YXRzID0ge307XG5sZXQgX2RvY2tlcl9zb2NrZXQ7XG5sZXQgX2RvY2tlcl9sYXN0X3JlYWQgPSAwO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBnZXQgY29udGFpbmVycyAocGFyYW1ldGVyIGFsbDogZ2V0IGFsc28gaW5hY3RpdmUvZXhpdGVkIGNvbnRhaW5lcnMpXG5cbmZ1bmN0aW9uIGRvY2tlckluZm8oY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICAgIF9kb2NrZXJfc29ja2V0LmdldEluZm8oKGRhdGEpID0+IHtcbiAgICAgICAgcmVzdWx0LmlkID0gZGF0YS5JRDtcbiAgICAgICAgcmVzdWx0LmNvbnRhaW5lcnMgPSBkYXRhLkNvbnRhaW5lcnM7XG4gICAgICAgIHJlc3VsdC5jb250YWluZXJzUnVubmluZyA9IGRhdGEuQ29udGFpbmVyc1J1bm5pbmc7XG4gICAgICAgIHJlc3VsdC5jb250YWluZXJzUGF1c2VkID0gZGF0YS5Db250YWluZXJzUGF1c2VkO1xuICAgICAgICByZXN1bHQuY29udGFpbmVyc1N0b3BwZWQgPSBkYXRhLkNvbnRhaW5lcnNTdG9wcGVkO1xuICAgICAgICByZXN1bHQuaW1hZ2VzID0gZGF0YS5JbWFnZXM7XG4gICAgICAgIHJlc3VsdC5kcml2ZXIgPSBkYXRhLkRyaXZlcjtcbiAgICAgICAgcmVzdWx0Lm1lbW9yeUxpbWl0ID0gZGF0YS5NZW1vcnlMaW1pdDtcbiAgICAgICAgcmVzdWx0LnN3YXBMaW1pdCA9IGRhdGEuU3dhcExpbWl0O1xuICAgICAgICByZXN1bHQua2VybmVsTWVtb3J5ID0gZGF0YS5LZXJuZWxNZW1vcnk7XG4gICAgICAgIHJlc3VsdC5jcHVDZnNQZXJpb2QgPSBkYXRhLkNwdUNmc1BlcmlvZDtcbiAgICAgICAgcmVzdWx0LmNwdUNmc1F1b3RhID0gZGF0YS5DcHVDZnNRdW90YTtcbiAgICAgICAgcmVzdWx0LmNwdVNoYXJlcyA9IGRhdGEuQ1BVU2hhcmVzO1xuICAgICAgICByZXN1bHQuY3B1U2V0ID0gZGF0YS5DUFVTZXQ7XG4gICAgICAgIHJlc3VsdC5pcHY0Rm9yd2FyZGluZyA9IGRhdGEuSVB2NEZvcndhcmRpbmc7XG4gICAgICAgIHJlc3VsdC5icmlkZ2VOZklwdGFibGVzID0gZGF0YS5CcmlkZ2VOZklwdGFibGVzO1xuICAgICAgICByZXN1bHQuYnJpZGdlTmZJcDZ0YWJsZXMgPSBkYXRhLkJyaWRnZU5mSXA2dGFibGVzO1xuICAgICAgICByZXN1bHQuZGVidWcgPSBkYXRhLkRlYnVnO1xuICAgICAgICByZXN1bHQubmZkID0gZGF0YS5ORmQ7XG4gICAgICAgIHJlc3VsdC5vb21LaWxsRGlzYWJsZSA9IGRhdGEuT29tS2lsbERpc2FibGU7XG4gICAgICAgIHJlc3VsdC5uZ29yb3V0aW5lcyA9IGRhdGEuTkdvcm91dGluZXM7XG4gICAgICAgIHJlc3VsdC5zeXN0ZW1UaW1lID0gZGF0YS5TeXN0ZW1UaW1lO1xuICAgICAgICByZXN1bHQubG9nZ2luZ0RyaXZlciA9IGRhdGEuTG9nZ2luZ0RyaXZlcjtcbiAgICAgICAgcmVzdWx0LmNncm91cERyaXZlciA9IGRhdGEuQ2dyb3VwRHJpdmVyO1xuICAgICAgICByZXN1bHQubkV2ZW50c0xpc3RlbmVyID0gZGF0YS5ORXZlbnRzTGlzdGVuZXI7XG4gICAgICAgIHJlc3VsdC5rZXJuZWxWZXJzaW9uID0gZGF0YS5LZXJuZWxWZXJzaW9uO1xuICAgICAgICByZXN1bHQub3BlcmF0aW5nU3lzdGVtID0gZGF0YS5PcGVyYXRpbmdTeXN0ZW07XG4gICAgICAgIHJlc3VsdC5vc1R5cGUgPSBkYXRhLk9TVHlwZTtcbiAgICAgICAgcmVzdWx0LmFyY2hpdGVjdHVyZSA9IGRhdGEuQXJjaGl0ZWN0dXJlO1xuICAgICAgICByZXN1bHQubmNwdSA9IGRhdGEuTkNQVTtcbiAgICAgICAgcmVzdWx0Lm1lbVRvdGFsID0gZGF0YS5NZW1Ub3RhbDtcbiAgICAgICAgcmVzdWx0LmRvY2tlclJvb3REaXIgPSBkYXRhLkRvY2tlclJvb3REaXI7XG4gICAgICAgIHJlc3VsdC5odHRwUHJveHkgPSBkYXRhLkh0dHBQcm94eTtcbiAgICAgICAgcmVzdWx0Lmh0dHBzUHJveHkgPSBkYXRhLkh0dHBzUHJveHk7XG4gICAgICAgIHJlc3VsdC5ub1Byb3h5ID0gZGF0YS5Ob1Byb3h5O1xuICAgICAgICByZXN1bHQubmFtZSA9IGRhdGEuTmFtZTtcbiAgICAgICAgcmVzdWx0LmxhYmVscyA9IGRhdGEuTGFiZWxzO1xuICAgICAgICByZXN1bHQuZXhwZXJpbWVudGFsQnVpbGQgPSBkYXRhLkV4cGVyaW1lbnRhbEJ1aWxkO1xuICAgICAgICByZXN1bHQuc2VydmVyVmVyc2lvbiA9IGRhdGEuU2VydmVyVmVyc2lvbjtcbiAgICAgICAgcmVzdWx0LmNsdXN0ZXJTdG9yZSA9IGRhdGEuQ2x1c3RlclN0b3JlO1xuICAgICAgICByZXN1bHQuY2x1c3RlckFkdmVydGlzZSA9IGRhdGEuQ2x1c3RlckFkdmVydGlzZTtcbiAgICAgICAgcmVzdWx0LmRlZmF1bHRSdW50aW1lID0gZGF0YS5EZWZhdWx0UnVudGltZTtcbiAgICAgICAgcmVzdWx0LmxpdmVSZXN0b3JlRW5hYmxlZCA9IGRhdGEuTGl2ZVJlc3RvcmVFbmFibGVkO1xuICAgICAgICByZXN1bHQuaXNvbGF0aW9uID0gZGF0YS5Jc29sYXRpb247XG4gICAgICAgIHJlc3VsdC5pbml0QmluYXJ5ID0gZGF0YS5Jbml0QmluYXJ5O1xuICAgICAgICByZXN1bHQucHJvZHVjdExpY2Vuc2UgPSBkYXRhLlByb2R1Y3RMaWNlbnNlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VySW5mbyA9IGRvY2tlckluZm87XG5cbmZ1bmN0aW9uIGRvY2tlckltYWdlcyhhbGwsIGNhbGxiYWNrKSB7XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oYWxsKSAmJiAhY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGFsbDtcbiAgICBhbGwgPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGFsbCA9PT0gJ3N0cmluZycgJiYgYWxsID09PSAndHJ1ZScpIHtcbiAgICBhbGwgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgYWxsICE9PSAnYm9vbGVhbicgJiYgYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbGwgPSBmYWxzZTtcbiAgfVxuXG4gIGFsbCA9IGFsbCB8fCBmYWxzZTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghX2RvY2tlcl9zb2NrZXQpIHtcbiAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuXG4gICAgICBfZG9ja2VyX3NvY2tldC5saXN0SW1hZ2VzKGFsbCwgZGF0YSA9PiB7XG4gICAgICAgIGxldCBkb2NrZXJJbWFnZXMgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2NrZXJJbWFnZXMgPSBkYXRhO1xuICAgICAgICAgIGlmIChkb2NrZXJJbWFnZXMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY2tlckltYWdlcykgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgZG9ja2VySW1hZ2VzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgZG9ja2VySW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5OYW1lcyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudC5OYW1lcykgPT09ICdbb2JqZWN0IEFycmF5XScgJiYgZWxlbWVudC5OYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5OYW1lID0gZWxlbWVudC5OYW1lc1swXS5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtsb2FkLnB1c2goZG9ja2VySW1hZ2VzSW5zcGVjdChlbGVtZW50LklkLnRyaW0oKSwgZWxlbWVudCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod29ya2xvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnRhaW5lciBpbnNwZWN0IChmb3Igb25lIGNvbnRhaW5lcilcblxuZnVuY3Rpb24gZG9ja2VySW1hZ2VzSW5zcGVjdChpbWFnZUlELCBwYXlsb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaW1hZ2VJRCA9IGltYWdlSUQgfHwgJyc7XG4gICAgICBpZiAodHlwZW9mIGltYWdlSUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbWFnZUlEU2FuaXRpemVkID0gKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJycgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoaW1hZ2VJRCwgdHJ1ZSkpLnRyaW0oKTtcbiAgICAgIGlmIChpbWFnZUlEU2FuaXRpemVkKSB7XG5cbiAgICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2RvY2tlcl9zb2NrZXQuaW5zcGVjdEltYWdlKGltYWdlSURTYW5pdGl6ZWQudHJpbSgpLCBkYXRhID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGlkOiBwYXlsb2FkLklkLFxuICAgICAgICAgICAgICBjb250YWluZXI6IGRhdGEuQ29udGFpbmVyLFxuICAgICAgICAgICAgICBjb21tZW50OiBkYXRhLkNvbW1lbnQsXG4gICAgICAgICAgICAgIG9zOiBkYXRhLk9zLFxuICAgICAgICAgICAgICBhcmNoaXRlY3R1cmU6IGRhdGEuQXJjaGl0ZWN0dXJlLFxuICAgICAgICAgICAgICBwYXJlbnQ6IGRhdGEuUGFyZW50LFxuICAgICAgICAgICAgICBkb2NrZXJWZXJzaW9uOiBkYXRhLkRvY2tlclZlcnNpb24sXG4gICAgICAgICAgICAgIHNpemU6IGRhdGEuU2l6ZSxcbiAgICAgICAgICAgICAgc2hhcmVkU2l6ZTogcGF5bG9hZC5TaGFyZWRTaXplLFxuICAgICAgICAgICAgICB2aXJ0dWFsU2l6ZTogZGF0YS5WaXJ0dWFsU2l6ZSxcbiAgICAgICAgICAgICAgYXV0aG9yOiBkYXRhLkF1dGhvcixcbiAgICAgICAgICAgICAgY3JlYXRlZDogZGF0YS5DcmVhdGVkID8gTWF0aC5yb3VuZChuZXcgRGF0ZShkYXRhLkNyZWF0ZWQpLmdldFRpbWUoKSAvIDEwMDApIDogMCxcbiAgICAgICAgICAgICAgY29udGFpbmVyQ29uZmlnOiBkYXRhLkNvbnRhaW5lckNvbmZpZyA/IGRhdGEuQ29udGFpbmVyQ29uZmlnIDoge30sXG4gICAgICAgICAgICAgIGdyYXBoRHJpdmVyOiBkYXRhLkdyYXBoRHJpdmVyID8gZGF0YS5HcmFwaERyaXZlciA6IHt9LFxuICAgICAgICAgICAgICByZXBvRGlnZXN0czogZGF0YS5SZXBvRGlnZXN0cyA/IGRhdGEuUmVwb0RpZ2VzdHMgOiB7fSxcbiAgICAgICAgICAgICAgcmVwb1RhZ3M6IGRhdGEuUmVwb1RhZ3MgPyBkYXRhLlJlcG9UYWdzIDoge30sXG4gICAgICAgICAgICAgIGNvbmZpZzogZGF0YS5Db25maWcgPyBkYXRhLkNvbmZpZyA6IHt9LFxuICAgICAgICAgICAgICByb290RlM6IGRhdGEuUm9vdEZTID8gZGF0YS5Sb290RlMgOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckltYWdlcyA9IGRvY2tlckltYWdlcztcblxuZnVuY3Rpb24gZG9ja2VyQ29udGFpbmVycyhhbGwsIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gaW5Db250YWluZXJzKGNvbnRhaW5lcnMsIGlkKSB7XG4gICAgbGV0IGZpbHRlcmVkID0gY29udGFpbmVycy5maWx0ZXIob2JqID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBJZFxuICAgICAgICovXG4gICAgICByZXR1cm4gKG9iai5JZCAmJiAob2JqLklkID09PSBpZCkpO1xuICAgIH0pO1xuICAgIHJldHVybiAoZmlsdGVyZWQubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihhbGwpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gYWxsO1xuICAgIGFsbCA9IGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYWxsID09PSAnc3RyaW5nJyAmJiBhbGwgPT09ICd0cnVlJykge1xuICAgIGFsbCA9IHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhbGwgIT09ICdib29sZWFuJyAmJiBhbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFsbCA9IGZhbHNlO1xuICB9XG5cbiAgYWxsID0gYWxsIHx8IGZhbHNlO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG5cbiAgICAgIF9kb2NrZXJfc29ja2V0Lmxpc3RDb250YWluZXJzKGFsbCwgZGF0YSA9PiB7XG4gICAgICAgIGxldCBkb2NrZXJfY29udGFpbmVycyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY2tlcl9jb250YWluZXJzID0gZGF0YTtcbiAgICAgICAgICBpZiAoZG9ja2VyX2NvbnRhaW5lcnMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY2tlcl9jb250YWluZXJzKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBkb2NrZXJfY29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBHQyBpbiBfZG9ja2VyX2NvbnRhaW5lcl9zdGF0c1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzKSB7XG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9kb2NrZXJfY29udGFpbmVyX3N0YXRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbkNvbnRhaW5lcnMoZG9ja2VyX2NvbnRhaW5lcnMsIGtleSkpIHsgZGVsZXRlIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzW2tleV07IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2NrZXJfY29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuTmFtZXMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQuTmFtZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGVsZW1lbnQuTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuTmFtZSA9IGVsZW1lbnQuTmFtZXNbMF0ucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3b3JrbG9hZC5wdXNoKGRvY2tlckNvbnRhaW5lckluc3BlY3QoZWxlbWVudC5JZC50cmltKCksIGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdvcmtsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIEdDIGluIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzXG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIF9kb2NrZXJfY29udGFpbmVyX3N0YXRzKSB7XG4gICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChfZG9ja2VyX2NvbnRhaW5lcl9zdGF0cywga2V5KSkge1xuICAgICAgICAgICAgICBpZiAoIWluQ29udGFpbmVycyhkb2NrZXJfY29udGFpbmVycywga2V5KSkgeyBkZWxldGUgX2RvY2tlcl9jb250YWluZXJfc3RhdHNba2V5XTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29udGFpbmVyIGluc3BlY3QgKGZvciBvbmUgY29udGFpbmVyKVxuXG5mdW5jdGlvbiBkb2NrZXJDb250YWluZXJJbnNwZWN0KGNvbnRhaW5lcklELCBwYXlsb2FkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29udGFpbmVySUQgPSBjb250YWluZXJJRCB8fCAnJztcbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVySUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250YWluZXJJZFNhbml0aXplZCA9ICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICcnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGNvbnRhaW5lcklELCB0cnVlKSkudHJpbSgpO1xuICAgICAgaWYgKGNvbnRhaW5lcklkU2FuaXRpemVkKSB7XG5cbiAgICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICAgIF9kb2NrZXJfc29ja2V0ID0gbmV3IERvY2tlclNvY2tldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2RvY2tlcl9zb2NrZXQuZ2V0SW5zcGVjdChjb250YWluZXJJZFNhbml0aXplZC50cmltKCksIGRhdGEgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgaWQ6IHBheWxvYWQuSWQsXG4gICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuTmFtZSxcbiAgICAgICAgICAgICAgaW1hZ2U6IHBheWxvYWQuSW1hZ2UsXG4gICAgICAgICAgICAgIGltYWdlSUQ6IHBheWxvYWQuSW1hZ2VJRCxcbiAgICAgICAgICAgICAgY29tbWFuZDogcGF5bG9hZC5Db21tYW5kLFxuICAgICAgICAgICAgICBjcmVhdGVkOiBwYXlsb2FkLkNyZWF0ZWQsXG4gICAgICAgICAgICAgIHN0YXJ0ZWQ6IGRhdGEuU3RhdGUgJiYgZGF0YS5TdGF0ZS5TdGFydGVkQXQgPyBNYXRoLnJvdW5kKG5ldyBEYXRlKGRhdGEuU3RhdGUuU3RhcnRlZEF0KS5nZXRUaW1lKCkgLyAxMDAwKSA6IDAsXG4gICAgICAgICAgICAgIGZpbmlzaGVkOiBkYXRhLlN0YXRlICYmIGRhdGEuU3RhdGUuRmluaXNoZWRBdCAmJiAhZGF0YS5TdGF0ZS5GaW5pc2hlZEF0LnN0YXJ0c1dpdGgoJzAwMDEtMDEtMDEnKSA/IE1hdGgucm91bmQobmV3IERhdGUoZGF0YS5TdGF0ZS5GaW5pc2hlZEF0KS5nZXRUaW1lKCkgLyAxMDAwKSA6IDAsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogZGF0YS5DcmVhdGVkID8gZGF0YS5DcmVhdGVkIDogJycsXG4gICAgICAgICAgICAgIHN0YXJ0ZWRBdDogZGF0YS5TdGF0ZSAmJiBkYXRhLlN0YXRlLlN0YXJ0ZWRBdCA/IGRhdGEuU3RhdGUuU3RhcnRlZEF0IDogJycsXG4gICAgICAgICAgICAgIGZpbmlzaGVkQXQ6IGRhdGEuU3RhdGUgJiYgZGF0YS5TdGF0ZS5GaW5pc2hlZEF0ICYmICFkYXRhLlN0YXRlLkZpbmlzaGVkQXQuc3RhcnRzV2l0aCgnMDAwMS0wMS0wMScpID8gZGF0YS5TdGF0ZS5GaW5pc2hlZEF0IDogJycsXG4gICAgICAgICAgICAgIHN0YXRlOiBwYXlsb2FkLlN0YXRlLFxuICAgICAgICAgICAgICByZXN0YXJ0Q291bnQ6IGRhdGEuUmVzdGFydENvdW50IHx8IDAsXG4gICAgICAgICAgICAgIHBsYXRmb3JtOiBkYXRhLlBsYXRmb3JtIHx8ICcnLFxuICAgICAgICAgICAgICBkcml2ZXI6IGRhdGEuRHJpdmVyIHx8ICcnLFxuICAgICAgICAgICAgICBwb3J0czogcGF5bG9hZC5Qb3J0cyxcbiAgICAgICAgICAgICAgbW91bnRzOiBwYXlsb2FkLk1vdW50cyxcbiAgICAgICAgICAgICAgLy8gaG9zdGNvbmZpZzogcGF5bG9hZC5Ib3N0Q29uZmlnLFxuICAgICAgICAgICAgICAvLyBuZXR3b3JrOiBwYXlsb2FkLk5ldHdvcmtTZXR0aW5nc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVycyA9IGRvY2tlckNvbnRhaW5lcnM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBoZWxwZXIgZnVuY3Rpb25zIGZvciBjYWxjdWxhdGlvbiBvZiBkb2NrZXIgc3RhdHNcblxuZnVuY3Rpb24gZG9ja2VyX2NhbGNDUFVQZXJjZW50KGNwdV9zdGF0cywgcHJlY3B1X3N0YXRzKSB7XG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgY3B1X3VzYWdlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgY3B1X3VzYWdlLnRvdGFsX3VzYWdlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgc3lzdGVtX2NwdV91c2FnZVxuICAgKiBAcHJvcGVydHkge29iamVjdH0gIGNwdV91c2FnZVxuICAgKiBAcHJvcGVydHkge0FycmF5fSAgY3B1X3VzYWdlLnBlcmNwdV91c2FnZVxuICAgKi9cblxuICBpZiAoIV93aW5kb3dzKSB7XG4gICAgbGV0IGNwdVBlcmNlbnQgPSAwLjA7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBjaGFuZ2UgZm9yIHRoZSBjcHUgdXNhZ2Ugb2YgdGhlIGNvbnRhaW5lciBpbiBiZXR3ZWVuIHJlYWRpbmdzXG4gICAgbGV0IGNwdURlbHRhID0gY3B1X3N0YXRzLmNwdV91c2FnZS50b3RhbF91c2FnZSAtIHByZWNwdV9zdGF0cy5jcHVfdXNhZ2UudG90YWxfdXNhZ2U7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBjaGFuZ2UgZm9yIHRoZSBlbnRpcmUgc3lzdGVtIGJldHdlZW4gcmVhZGluZ3NcbiAgICBsZXQgc3lzdGVtRGVsdGEgPSBjcHVfc3RhdHMuc3lzdGVtX2NwdV91c2FnZSAtIHByZWNwdV9zdGF0cy5zeXN0ZW1fY3B1X3VzYWdlO1xuXG4gICAgaWYgKHN5c3RlbURlbHRhID4gMC4wICYmIGNwdURlbHRhID4gMC4wKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIGNoYW5nZSBmb3IgdGhlIGNwdSB1c2FnZSBvZiB0aGUgY29udGFpbmVyIGluIGJldHdlZW4gcmVhZGluZ3NcbiAgICAgIGlmIChwcmVjcHVfc3RhdHMub25saW5lX2NwdXMpIHtcbiAgICAgICAgY3B1UGVyY2VudCA9IChjcHVEZWx0YSAvIHN5c3RlbURlbHRhKSAqIHByZWNwdV9zdGF0cy5vbmxpbmVfY3B1cyAqIDEwMC4wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNwdVBlcmNlbnQgPSAoY3B1RGVsdGEgLyBzeXN0ZW1EZWx0YSkgKiBjcHVfc3RhdHMuY3B1X3VzYWdlLnBlcmNwdV91c2FnZS5sZW5ndGggKiAxMDAuMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3B1UGVyY2VudDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbmFub1NlY05vdyA9IHV0aWwubmFub1NlY29uZHMoKTtcbiAgICBsZXQgY3B1UGVyY2VudCA9IDAuMDtcbiAgICBpZiAoX2RvY2tlcl9sYXN0X3JlYWQgPiAwKSB7XG4gICAgICBsZXQgcG9zc0ludGVydmFscyA9IChuYW5vU2VjTm93IC0gX2RvY2tlcl9sYXN0X3JlYWQpOyAvLyAgLyAxMDAgKiBvcy5jcHVzKCkubGVuZ3RoO1xuICAgICAgbGV0IGludGVydmFsc1VzZWQgPSBjcHVfc3RhdHMuY3B1X3VzYWdlLnRvdGFsX3VzYWdlIC0gcHJlY3B1X3N0YXRzLmNwdV91c2FnZS50b3RhbF91c2FnZTtcbiAgICAgIGlmIChwb3NzSW50ZXJ2YWxzID4gMCkge1xuICAgICAgICBjcHVQZXJjZW50ID0gMTAwLjAgKiBpbnRlcnZhbHNVc2VkIC8gcG9zc0ludGVydmFscztcbiAgICAgIH1cbiAgICB9XG4gICAgX2RvY2tlcl9sYXN0X3JlYWQgPSBuYW5vU2VjTm93O1xuICAgIHJldHVybiBjcHVQZXJjZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvY2tlcl9jYWxjTmV0d29ya0lPKG5ldHdvcmtzKSB7XG4gIGxldCByeDtcbiAgbGV0IHd4O1xuICBmb3IgKGxldCBrZXkgaW4gbmV0d29ya3MpIHtcbiAgICAvLyBza2lwIGxvb3AgaWYgdGhlIHByb3BlcnR5IGlzIGZyb20gcHJvdG90eXBlXG4gICAgaWYgKCF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5ldHdvcmtzLCBrZXkpKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICByeF9ieXRlc1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgdHhfYnl0ZXNcbiAgICAgKi9cbiAgICBsZXQgb2JqID0gbmV0d29ya3Nba2V5XTtcbiAgICByeCA9ICtvYmoucnhfYnl0ZXM7XG4gICAgd3ggPSArb2JqLnR4X2J5dGVzO1xuICB9XG4gIHJldHVybiB7XG4gICAgcngsXG4gICAgd3hcbiAgfTtcbn1cblxuZnVuY3Rpb24gZG9ja2VyX2NhbGNCbG9ja0lPKGJsa2lvX3N0YXRzKSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgcjogMCxcbiAgICB3OiAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQHByb3BlcnR5IHtBcnJheX0gIGlvX3NlcnZpY2VfYnl0ZXNfcmVjdXJzaXZlXG4gICAqL1xuICBpZiAoYmxraW9fc3RhdHMgJiYgYmxraW9fc3RhdHMuaW9fc2VydmljZV9ieXRlc19yZWN1cnNpdmUgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJsa2lvX3N0YXRzLmlvX3NlcnZpY2VfYnl0ZXNfcmVjdXJzaXZlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiBibGtpb19zdGF0cy5pb19zZXJ2aWNlX2J5dGVzX3JlY3Vyc2l2ZS5sZW5ndGggPiAwKSB7XG4gICAgYmxraW9fc3RhdHMuaW9fc2VydmljZV9ieXRlc19yZWN1cnNpdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIG9wXG4gICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gIHZhbHVlXG4gICAgICAgKi9cblxuICAgICAgaWYgKGVsZW1lbnQub3AgJiYgZWxlbWVudC5vcC50b0xvd2VyQ2FzZSgpID09PSAncmVhZCcgJiYgZWxlbWVudC52YWx1ZSkge1xuICAgICAgICByZXN1bHQuciArPSBlbGVtZW50LnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQub3AgJiYgZWxlbWVudC5vcC50b0xvd2VyQ2FzZSgpID09PSAnd3JpdGUnICYmIGVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LncgKz0gZWxlbWVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkb2NrZXJDb250YWluZXJTdGF0cyhjb250YWluZXJJRHMsIGNhbGxiYWNrKSB7XG5cbiAgbGV0IGNvbnRhaW5lckFycmF5ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oY29udGFpbmVySURzKSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjb250YWluZXJJRHM7XG4gICAgICAgIGNvbnRhaW5lckFycmF5ID0gWycqJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXJJRHMgPSBjb250YWluZXJJRHMgfHwgJyonO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRhaW5lcklEcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soW10pOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSAnJztcbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkLl9fcHJvdG9fXy5yZXBsYWNlID0gdXRpbC5zdHJpbmdSZXBsYWNlO1xuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQuX19wcm90b19fLnRyaW0gPSB1dGlsLnN0cmluZ1RyaW07XG5cbiAgICAgICAgY29udGFpbmVySURzU2FuaXRpemVkID0gY29udGFpbmVySURzO1xuICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSBjb250YWluZXJJRHNTYW5pdGl6ZWQudHJpbSgpO1xuICAgICAgICBpZiAoY29udGFpbmVySURzU2FuaXRpemVkICE9PSAnKicpIHtcbiAgICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSAnJztcbiAgICAgICAgICBjb25zdCBzID0gKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJycgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoY29udGFpbmVySURzLCB0cnVlKSkudHJpbSgpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzW2ldLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHV0aWwuc3RyaW5nVG9Mb3dlcjtcbiAgICAgICAgICAgICAgY29uc3Qgc2wgPSBzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChzbCAmJiBzbFswXSAmJiAhc2xbMV0pIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJJRHNTYW5pdGl6ZWQgPSBjb250YWluZXJJRHNTYW5pdGl6ZWQgKyBzbFswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lcklEc1Nhbml0aXplZCA9IGNvbnRhaW5lcklEc1Nhbml0aXplZC50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8sKy9nLCAnfCcpO1xuICAgICAgICBjb250YWluZXJBcnJheSA9IGNvbnRhaW5lcklEc1Nhbml0aXplZC5zcGxpdCgnfCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgIGlmIChjb250YWluZXJBcnJheS5sZW5ndGggJiYgY29udGFpbmVyQXJyYXlbMF0udHJpbSgpID09PSAnKicpIHtcbiAgICAgICAgY29udGFpbmVyQXJyYXkgPSBbXTtcbiAgICAgICAgZG9ja2VyQ29udGFpbmVycygpLnRoZW4oYWxsQ29udGFpbmVycyA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIGFsbENvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckFycmF5LnB1c2goY29udGFpbmVyLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnRhaW5lckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgZG9ja2VyQ29udGFpbmVyU3RhdHMoY29udGFpbmVyQXJyYXkuam9pbignLCcpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBjb250YWluZXJJRCBvZiBjb250YWluZXJBcnJheSkge1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2goZG9ja2VyQ29udGFpbmVyU3RhdHNTaW5nbGUoY29udGFpbmVySUQudHJpbSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtsb2FkLmxlbmd0aCkge1xuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNvbnRhaW5lciBzdGF0cyAoZm9yIG9uZSBjb250YWluZXIpXG5cbmZ1bmN0aW9uIGRvY2tlckNvbnRhaW5lclN0YXRzU2luZ2xlKGNvbnRhaW5lcklEKSB7XG4gIGNvbnRhaW5lcklEID0gY29udGFpbmVySUQgfHwgJyc7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgaWQ6IGNvbnRhaW5lcklELFxuICAgIG1lbVVzYWdlOiAwLFxuICAgIG1lbUxpbWl0OiAwLFxuICAgIG1lbVBlcmNlbnQ6IDAsXG4gICAgY3B1UGVyY2VudDogMCxcbiAgICBwaWRzOiAwLFxuICAgIG5ldElPOiB7XG4gICAgICByeDogMCxcbiAgICAgIHd4OiAwXG4gICAgfSxcbiAgICBibG9ja0lPOiB7XG4gICAgICByOiAwLFxuICAgICAgdzogMFxuICAgIH0sXG4gICAgcmVzdGFydENvdW50OiAwLFxuICAgIGNwdVN0YXRzOiB7fSxcbiAgICBwcmVjcHVTdGF0czoge30sXG4gICAgbWVtb3J5U3RhdHM6IHt9LFxuICAgIG5ldHdvcmtzOiB7fSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVySUQpIHtcblxuICAgICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZG9ja2VyX3NvY2tldC5nZXRJbnNwZWN0KGNvbnRhaW5lcklELCBkYXRhSW5zcGVjdCA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9kb2NrZXJfc29ja2V0LmdldFN0YXRzKGNvbnRhaW5lcklELCBkYXRhID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhdHMgPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0cy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWVtVXNhZ2UgPSAoc3RhdHMubWVtb3J5X3N0YXRzICYmIHN0YXRzLm1lbW9yeV9zdGF0cy51c2FnZSA/IHN0YXRzLm1lbW9yeV9zdGF0cy51c2FnZSA6IDApO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lbUxpbWl0ID0gKHN0YXRzLm1lbW9yeV9zdGF0cyAmJiBzdGF0cy5tZW1vcnlfc3RhdHMubGltaXQgPyBzdGF0cy5tZW1vcnlfc3RhdHMubGltaXQgOiAwKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tZW1QZXJjZW50ID0gKHN0YXRzLm1lbW9yeV9zdGF0cyAmJiBzdGF0cy5tZW1vcnlfc3RhdHMudXNhZ2UgJiYgc3RhdHMubWVtb3J5X3N0YXRzLmxpbWl0ID8gc3RhdHMubWVtb3J5X3N0YXRzLnVzYWdlIC8gc3RhdHMubWVtb3J5X3N0YXRzLmxpbWl0ICogMTAwLjAgOiAwKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jcHVQZXJjZW50ID0gKHN0YXRzLmNwdV9zdGF0cyAmJiBzdGF0cy5wcmVjcHVfc3RhdHMgPyBkb2NrZXJfY2FsY0NQVVBlcmNlbnQoc3RhdHMuY3B1X3N0YXRzLCBzdGF0cy5wcmVjcHVfc3RhdHMpIDogMCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucGlkcyA9IChzdGF0cy5waWRzX3N0YXRzICYmIHN0YXRzLnBpZHNfc3RhdHMuY3VycmVudCA/IHN0YXRzLnBpZHNfc3RhdHMuY3VycmVudCA6IDApO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlc3RhcnRDb3VudCA9IChkYXRhSW5zcGVjdC5SZXN0YXJ0Q291bnQgPyBkYXRhSW5zcGVjdC5SZXN0YXJ0Q291bnQgOiAwKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5uZXR3b3JrcykgeyByZXN1bHQubmV0SU8gPSBkb2NrZXJfY2FsY05ldHdvcmtJTyhzdGF0cy5uZXR3b3Jrcyk7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5ibGtpb19zdGF0cykgeyByZXN1bHQuYmxvY2tJTyA9IGRvY2tlcl9jYWxjQmxvY2tJTyhzdGF0cy5ibGtpb19zdGF0cyk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5jcHVTdGF0cyA9IChzdGF0cy5jcHVfc3RhdHMgPyBzdGF0cy5jcHVfc3RhdHMgOiB7fSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHJlY3B1U3RhdHMgPSAoc3RhdHMucHJlY3B1X3N0YXRzID8gc3RhdHMucHJlY3B1X3N0YXRzIDoge30pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lbW9yeVN0YXRzID0gKHN0YXRzLm1lbW9yeV9zdGF0cyA/IHN0YXRzLm1lbW9yeV9zdGF0cyA6IHt9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrcyA9IChzdGF0cy5uZXR3b3JrcyA/IHN0YXRzLm5ldHdvcmtzIDoge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckNvbnRhaW5lclN0YXRzID0gZG9ja2VyQ29udGFpbmVyU3RhdHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb250YWluZXIgcHJvY2Vzc2VzIChmb3Igb25lIGNvbnRhaW5lcilcblxuZnVuY3Rpb24gZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzKGNvbnRhaW5lcklELCBjYWxsYmFjaykge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29udGFpbmVySUQgPSBjb250YWluZXJJRCB8fCAnJztcbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVySUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250YWluZXJJZFNhbml0aXplZCA9ICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICcnIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKGNvbnRhaW5lcklELCB0cnVlKSkudHJpbSgpO1xuXG4gICAgICBpZiAoY29udGFpbmVySWRTYW5pdGl6ZWQpIHtcblxuICAgICAgICBpZiAoIV9kb2NrZXJfc29ja2V0KSB7XG4gICAgICAgICAgX2RvY2tlcl9zb2NrZXQgPSBuZXcgRG9ja2VyU29ja2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZG9ja2VyX3NvY2tldC5nZXRQcm9jZXNzZXMoY29udGFpbmVySWRTYW5pdGl6ZWQsIGRhdGEgPT4ge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5fSAgVGl0bGVzXG4gICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gIFByb2Nlc3Nlc1xuICAgICAgICAgICAqKi9cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5UaXRsZXMgJiYgZGF0YS5Qcm9jZXNzZXMpIHtcbiAgICAgICAgICAgICAgbGV0IHRpdGxlcyA9IGRhdGEuVGl0bGVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxldCBwb3NfcGlkID0gdGl0bGVzLmluZGV4T2YoJ1BJRCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3BwaWQgPSB0aXRsZXMuaW5kZXhPZignUFBJRCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3BnaWQgPSB0aXRsZXMuaW5kZXhPZignUEdJRCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3ZzeiA9IHRpdGxlcy5pbmRleE9mKCdWU1onKTtcbiAgICAgICAgICAgICAgbGV0IHBvc190aW1lID0gdGl0bGVzLmluZGV4T2YoJ1RJTUUnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19lbGFwc2VkID0gdGl0bGVzLmluZGV4T2YoJ0VMQVBTRUQnKTtcbiAgICAgICAgICAgICAgbGV0IHBvc19uaSA9IHRpdGxlcy5pbmRleE9mKCdOSScpO1xuICAgICAgICAgICAgICBsZXQgcG9zX3J1c2VyID0gdGl0bGVzLmluZGV4T2YoJ1JVU0VSJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfdXNlciA9IHRpdGxlcy5pbmRleE9mKCdVU0VSJyk7XG4gICAgICAgICAgICAgIGxldCBwb3Nfcmdyb3VwID0gdGl0bGVzLmluZGV4T2YoJ1JHUk9VUCcpO1xuICAgICAgICAgICAgICBsZXQgcG9zX2dyb3VwID0gdGl0bGVzLmluZGV4T2YoJ0dST1VQJyk7XG4gICAgICAgICAgICAgIGxldCBwb3Nfc3RhdCA9IHRpdGxlcy5pbmRleE9mKCdTVEFUJyk7XG4gICAgICAgICAgICAgIGxldCBwb3NfcnNzID0gdGl0bGVzLmluZGV4T2YoJ1JTUycpO1xuICAgICAgICAgICAgICBsZXQgcG9zX2NvbW1hbmQgPSB0aXRsZXMuaW5kZXhPZignQ09NTUFORCcpO1xuXG4gICAgICAgICAgICAgIGRhdGEuUHJvY2Vzc2VzLmZvckVhY2gocHJvY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgcGlkSG9zdDogKHBvc19waWQgPj0gMCA/IHByb2Nlc3NbcG9zX3BpZF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBwcGlkOiAocG9zX3BwaWQgPj0gMCA/IHByb2Nlc3NbcG9zX3BwaWRdIDogJycpLFxuICAgICAgICAgICAgICAgICAgcGdpZDogKHBvc19wZ2lkID49IDAgPyBwcm9jZXNzW3Bvc19wZ2lkXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHVzZXI6IChwb3NfdXNlciA+PSAwID8gcHJvY2Vzc1twb3NfdXNlcl0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBydXNlcjogKHBvc19ydXNlciA+PSAwID8gcHJvY2Vzc1twb3NfcnVzZXJdIDogJycpLFxuICAgICAgICAgICAgICAgICAgZ3JvdXA6IChwb3NfZ3JvdXAgPj0gMCA/IHByb2Nlc3NbcG9zX2dyb3VwXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHJncm91cDogKHBvc19yZ3JvdXAgPj0gMCA/IHByb2Nlc3NbcG9zX3Jncm91cF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBzdGF0OiAocG9zX3N0YXQgPj0gMCA/IHByb2Nlc3NbcG9zX3N0YXRdIDogJycpLFxuICAgICAgICAgICAgICAgICAgdGltZTogKHBvc190aW1lID49IDAgPyBwcm9jZXNzW3Bvc190aW1lXSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIGVsYXBzZWQ6IChwb3NfZWxhcHNlZCA+PSAwID8gcHJvY2Vzc1twb3NfZWxhcHNlZF0gOiAnJyksXG4gICAgICAgICAgICAgICAgICBuaWNlOiAocG9zX25pID49IDAgPyBwcm9jZXNzW3Bvc19uaV0gOiAnJyksXG4gICAgICAgICAgICAgICAgICByc3M6IChwb3NfcnNzID49IDAgPyBwcm9jZXNzW3Bvc19yc3NdIDogJycpLFxuICAgICAgICAgICAgICAgICAgdnN6OiAocG9zX3ZzeiA+PSAwID8gcHJvY2Vzc1twb3NfdnN6XSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IChwb3NfY29tbWFuZCA+PSAwID8gcHJvY2Vzc1twb3NfY29tbWFuZF0gOiAnJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kb2NrZXJDb250YWluZXJQcm9jZXNzZXMgPSBkb2NrZXJDb250YWluZXJQcm9jZXNzZXM7XG5cbmZ1bmN0aW9uIGRvY2tlclZvbHVtZXMoY2FsbGJhY2spIHtcblxuICBsZXQgcmVzdWx0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKCFfZG9ja2VyX3NvY2tldCkge1xuICAgICAgICBfZG9ja2VyX3NvY2tldCA9IG5ldyBEb2NrZXJTb2NrZXQoKTtcbiAgICAgIH1cbiAgICAgIF9kb2NrZXJfc29ja2V0Lmxpc3RWb2x1bWVzKChkYXRhKSA9PiB7XG4gICAgICAgIGxldCBkb2NrZXJWb2x1bWVzID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9ja2VyVm9sdW1lcyA9IGRhdGE7XG4gICAgICAgICAgaWYgKGRvY2tlclZvbHVtZXMgJiYgZG9ja2VyVm9sdW1lcy5Wb2x1bWVzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2NrZXJWb2x1bWVzLlZvbHVtZXMpID09PSAnW29iamVjdCBBcnJheV0nICYmIGRvY2tlclZvbHVtZXMuVm9sdW1lcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGRvY2tlclZvbHVtZXMuVm9sdW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQuTmFtZSxcbiAgICAgICAgICAgICAgICBkcml2ZXI6IGVsZW1lbnQuRHJpdmVyLFxuICAgICAgICAgICAgICAgIGxhYmVsczogZWxlbWVudC5MYWJlbHMsXG4gICAgICAgICAgICAgICAgbW91bnRwb2ludDogZWxlbWVudC5Nb3VudHBvaW50LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGVsZW1lbnQuT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzY29wZTogZWxlbWVudC5TY29wZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBlbGVtZW50LkNyZWF0ZWRBdCA/IE1hdGgucm91bmQobmV3IERhdGUoZWxlbWVudC5DcmVhdGVkQXQpLmdldFRpbWUoKSAvIDEwMDApIDogMCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlclZvbHVtZXMgPSBkb2NrZXJWb2x1bWVzO1xuXG5mdW5jdGlvbiBkb2NrZXJBbGwoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBkb2NrZXJDb250YWluZXJzKHRydWUpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVzdWx0KSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBsID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgZG9ja2VyQ29udGFpbmVyU3RhdHMoZWxlbWVudC5pZCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGluY2x1ZGUgc3RhdHMgaW4gYXJyYXlcbiAgICAgICAgICAgICAgZWxlbWVudC5tZW1Vc2FnZSA9IHJlc1swXS5tZW1Vc2FnZTtcbiAgICAgICAgICAgICAgZWxlbWVudC5tZW1MaW1pdCA9IHJlc1swXS5tZW1MaW1pdDtcbiAgICAgICAgICAgICAgZWxlbWVudC5tZW1QZXJjZW50ID0gcmVzWzBdLm1lbVBlcmNlbnQ7XG4gICAgICAgICAgICAgIGVsZW1lbnQuY3B1UGVyY2VudCA9IHJlc1swXS5jcHVQZXJjZW50O1xuICAgICAgICAgICAgICBlbGVtZW50LnBpZHMgPSByZXNbMF0ucGlkcztcbiAgICAgICAgICAgICAgZWxlbWVudC5uZXRJTyA9IHJlc1swXS5uZXRJTztcbiAgICAgICAgICAgICAgZWxlbWVudC5ibG9ja0lPID0gcmVzWzBdLmJsb2NrSU87XG4gICAgICAgICAgICAgIGVsZW1lbnQuY3B1U3RhdHMgPSByZXNbMF0uY3B1U3RhdHM7XG4gICAgICAgICAgICAgIGVsZW1lbnQucHJlY3B1U3RhdHMgPSByZXNbMF0ucHJlY3B1U3RhdHM7XG4gICAgICAgICAgICAgIGVsZW1lbnQubWVtb3J5U3RhdHMgPSByZXNbMF0ubWVtb3J5U3RhdHM7XG4gICAgICAgICAgICAgIGVsZW1lbnQubmV0d29ya3MgPSByZXNbMF0ubmV0d29ya3M7XG5cbiAgICAgICAgICAgICAgZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzKGVsZW1lbnQuaWQpLnRoZW4ocHJvY2Vzc2VzID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnByb2Nlc3NlcyA9IHByb2Nlc3NlcztcblxuICAgICAgICAgICAgICAgIGwgLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvLyBhbGwgZG9uZT8/XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmRvY2tlckFsbCA9IGRvY2tlckFsbDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gZG9ja2VyU29ja2V0cy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDEzLiBEb2NrZXJTb2NrZXRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgaXNXaW4gPSByZXF1aXJlKCdvcycpLnR5cGUoKSA9PT0gJ1dpbmRvd3NfTlQnO1xuY29uc3Qgc29ja2V0UGF0aCA9IGlzV2luID8gJy8vLi9waXBlL2RvY2tlcl9lbmdpbmUnIDogJy92YXIvcnVuL2RvY2tlci5zb2NrJztcblxuY2xhc3MgRG9ja2VyU29ja2V0IHtcblxuICBnZXRJbmZvKGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcblxuICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9pbmZvIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGxpc3RJbWFnZXMoYWxsLCBjYWxsYmFjaykge1xuICAgIHRyeSB7XG5cbiAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovaW1hZ2VzL2pzb24nICsgKGFsbCA/ICc/YWxsPTEnIDogJycpICsgJyBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBpbnNwZWN0SW1hZ2UoaWQsIGNhbGxiYWNrKSB7XG4gICAgaWQgPSBpZCB8fCAnJztcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9pbWFnZXMvJyArIGlkICsgJy9qc29uP3N0cmVhbT0wIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEuc3Vic3RyaW5nKHN0YXJ0Ym9keSArIDQpO1xuICAgICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShhbGxkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgbGlzdENvbnRhaW5lcnMoYWxsLCBjYWxsYmFjaykge1xuICAgIHRyeSB7XG5cbiAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovY29udGFpbmVycy9qc29uJyArIChhbGwgPyAnP2FsbD0xJyA6ICcnKSArICcgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH0pO1xuXG4gICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0Ym9keSA9IGFsbGRhdGEuaW5kZXhPZignXFxyXFxuXFxyXFxuJyk7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayh7fSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdHMoaWQsIGNhbGxiYWNrKSB7XG4gICAgaWQgPSBpZCB8fCAnJztcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9jb250YWluZXJzLycgKyBpZCArICcvc3RhdHM/c3RyZWFtPTAgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBnZXRJbnNwZWN0KGlkLCBjYWxsYmFjaykge1xuICAgIGlkID0gaWQgfHwgJyc7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc29ja2V0ID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb24oeyBwYXRoOiBzb2NrZXRQYXRoIH0pO1xuICAgICAgICBsZXQgYWxsZGF0YSA9ICcnO1xuICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0LndyaXRlKCdHRVQgaHR0cDovY29udGFpbmVycy8nICsgaWQgKyAnL2pzb24/c3RyZWFtPTAgSFRUUC8xLjBcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgICAgYWxsZGF0YSA9IGFsbGRhdGEgKyBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2soe30pO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBsZXQgc3RhcnRib2R5ID0gYWxsZGF0YS5pbmRleE9mKCdcXHJcXG5cXHJcXG4nKTtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgICAgc29ja2V0ID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gIH1cblxuICBnZXRQcm9jZXNzZXMoaWQsIGNhbGxiYWNrKSB7XG4gICAgaWQgPSBpZCB8fCAnJztcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBuZXQuY3JlYXRlQ29ubmVjdGlvbih7IHBhdGg6IHNvY2tldFBhdGggfSk7XG4gICAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi9jb250YWluZXJzLycgKyBpZCArICcvdG9wP3BzX2FyZ3M9LW9waWQscHBpZCxwZ2lkLHZzeix0aW1lLGV0aW1lLG5pY2UscnVzZXIsdXNlcixyZ3JvdXAsZ3JvdXAsc3RhdCxyc3MsYXJncyBIVFRQLzEuMFxcclxcblxcclxcbicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgICAgICBhbGxkYXRhID0gYWxsZGF0YSArIGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhLnN1YnN0cmluZyhzdGFydGJvZHkgKyA0KTtcbiAgICAgICAgICBzb2NrZXQgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYWxsZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKHt9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxuXG4gIGxpc3RWb2x1bWVzKGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcblxuICAgICAgbGV0IHNvY2tldCA9IG5ldC5jcmVhdGVDb25uZWN0aW9uKHsgcGF0aDogc29ja2V0UGF0aCB9KTtcbiAgICAgIGxldCBhbGxkYXRhID0gJyc7XG4gICAgICBsZXQgZGF0YTtcblxuICAgICAgc29ja2V0Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICBzb2NrZXQud3JpdGUoJ0dFVCBodHRwOi92b2x1bWVzIEhUVFAvMS4wXFxyXFxuXFxyXFxuJyk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gICAgICAgIGFsbGRhdGEgPSBhbGxkYXRhICsgZGF0YS50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIHNvY2tldC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICB9KTtcblxuICAgICAgc29ja2V0Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGxldCBzdGFydGJvZHkgPSBhbGxkYXRhLmluZGV4T2YoJ1xcclxcblxcclxcbicpO1xuICAgICAgICBhbGxkYXRhID0gYWxsZGF0YS5zdWJzdHJpbmcoc3RhcnRib2R5ICsgNCk7XG4gICAgICAgIHNvY2tldCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGFsbGRhdGEpO1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soe30pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvY2tlclNvY2tldDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gZmlsZXN5c3RlbS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDguIEZpbGUgU3lzdGVtXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCBleGVjUHJvbWlzZVNhdmUgPSB1dGlsLnByb21pc2lmeVNhdmUocmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxubGV0IF9mc19zcGVlZCA9IHt9O1xubGV0IF9kaXNrX2lvID0ge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGUyAtIG1vdW50ZWQgZmlsZSBzeXN0ZW1zXG5cbmZ1bmN0aW9uIGZzU2l6ZShjYWxsYmFjaykge1xuXG4gIGxldCBtYWNPc0Rpc2tzID0gW107XG4gIGxldCBvc01vdW50cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGdldG1hY09zRnNUeXBlKGZzKSB7XG4gICAgaWYgKCFmcy5zdGFydHNXaXRoKCcvJykpIHsgcmV0dXJuICdORlMnOyB9XG4gICAgY29uc3QgcGFydHMgPSBmcy5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGZzU2hvcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBtYWNPc0Rpc2tzU2luZ2xlID0gbWFjT3NEaXNrcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmluZGV4T2YoZnNTaG9ydCkgPj0gMCk7XG4gICAgaWYgKG1hY09zRGlza3NTaW5nbGUubGVuZ3RoID09PSAxICYmIG1hY09zRGlza3NTaW5nbGVbMF0uaW5kZXhPZignQVBGUycpID49IDApIHsgcmV0dXJuICdBUEZTJzsgfVxuICAgIHJldHVybiAnSEZTJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGludXhUbXBGcyhmcykge1xuICAgIGNvbnN0IGxpbnV4VG1wRmlsZVN5c3RlbXMgPSBbJ3Jvb3RmcycsICd1bmlvbmZzJywgJ3NxdWFzaGZzJywgJ2NyYW1mcycsICdpbml0cmQnLCAnaW5pdHJhbWZzJywgJ2RldnRtcGZzJywgJ3RtcGZzJywgJ3VkZXYnLCAnZGV2ZnMnLCAnc3BlY2ZzJywgJ3R5cGUnLCAnYXBwaW1hZ2VkJ107XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIGxpbnV4VG1wRmlsZVN5c3RlbXMuZm9yRWFjaChsaW51eEZzID0+IHtcbiAgICAgIGlmIChmcy50b0xvd2VyQ2FzZSgpLmluZGV4T2YobGludXhGcykgPj0gMCkgeyByZXN1bHQgPSB0cnVlOyB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckxpbmVzKHN0ZG91dCkge1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBpZiAoc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaWxlc3lzdGVtJykpIHtcbiAgICAgIGxldCByZW1vdmVMaW5lcyA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lc1tpXSAmJiBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZpbGVzeXN0ZW0nKSkge1xuICAgICAgICAgIHJlbW92ZUxpbmVzID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVMaW5lczsgaSsrKSB7XG4gICAgICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGYobGluZXMpIHtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgIGlmIChsaW5lICYmICgobGluZVswXS5zdGFydHNXaXRoKCcvJykpIHx8IChsaW5lWzZdICYmIGxpbmVbNl0gPT09ICcvJykgfHwgKGxpbmVbMF0uaW5kZXhPZignLycpID4gMCkgfHwgKGxpbmVbMF0uaW5kZXhPZignOicpID09PSAxKSB8fCAhX2RhcndpbiAmJiAhaXNMaW51eFRtcEZzKGxpbmVbMV0pKSkge1xuICAgICAgICAgIGNvbnN0IGZzID0gbGluZVswXTtcbiAgICAgICAgICBjb25zdCBmc1R5cGUgPSAoKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSA/IGxpbmVbMV0gOiBnZXRtYWNPc0ZzVHlwZShsaW5lWzBdKSk7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KCgoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpID8gbGluZVsyXSA6IGxpbmVbMV0pKSAqIDEwMjQ7XG4gICAgICAgICAgY29uc3QgdXNlZCA9IHBhcnNlSW50KCgoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpID8gbGluZVszXSA6IGxpbmVbMl0pKSAqIDEwMjQ7XG4gICAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gcGFyc2VJbnQoKChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgPyBsaW5lWzRdIDogbGluZVszXSkpICogMTAyNDtcbiAgICAgICAgICBjb25zdCB1c2UgPSBwYXJzZUZsb2F0KCgxMDAuMCAqICh1c2VkIC8gKHVzZWQgKyBhdmFpbGFibGUpKSkudG9GaXhlZCgyKSk7XG4gICAgICAgICAgbGV0IHJ3ID0gb3NNb3VudHMgJiYgT2JqZWN0LmtleXMob3NNb3VudHMpLmxlbmd0aCA+IDAgPyBvc01vdW50c1tmc10gfHwgZmFsc2UgOiBudWxsO1xuICAgICAgICAgIGxpbmUuc3BsaWNlKDAsIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgPyA2IDogNSk7XG4gICAgICAgICAgY29uc3QgbW91bnQgPSBsaW5lLmpvaW4oJyAnKTtcbiAgICAgICAgICBpZiAoIWRhdGEuZmluZChlbCA9PiAoZWwuZnMgPT09IGZzICYmIGVsLnR5cGUgPT09IGZzVHlwZSkpKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICBmcyxcbiAgICAgICAgICAgICAgdHlwZTogZnNUeXBlLFxuICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICB1c2VkLFxuICAgICAgICAgICAgICBhdmFpbGFibGUsXG4gICAgICAgICAgICAgIHVzZSxcbiAgICAgICAgICAgICAgbW91bnQsXG4gICAgICAgICAgICAgIHJ3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGRhdGEgPSBbXTtcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnJztcbiAgICAgICAgbWFjT3NEaXNrcyA9IFtdO1xuICAgICAgICBvc01vdW50cyA9IHt9O1xuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIGNtZCA9ICdkZiAta1AnO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYWNPc0Rpc2tzID0gZXhlY1N5bmMoJ2Rpc2t1dGlsIGxpc3QnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAhbGluZS5zdGFydHNXaXRoKCcvJykgJiYgbGluZS5pbmRleE9mKCc6JykgPiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleGVjU3luYygnbW91bnQnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBsaW5lLnN0YXJ0c1dpdGgoJy8nKTtcbiAgICAgICAgICAgIH0pLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgb3NNb3VudHNbbGluZS5zcGxpdCgnICcpWzBdXSA9IGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyZWFkLW9ubHknKSA9PT0gLTE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgIGNtZCA9ICdkZiAtbGtQVHggc3F1YXNoZnMnO1xuICAgICAgICAgIGV4ZWNTeW5jKCdjYXQgL3Byb2MvbW91bnRzIDI+L2Rldi9udWxsJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3RhcnRzV2l0aCgnLycpO1xuICAgICAgICAgIH0pLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgIG9zTW91bnRzW2xpbmUuc3BsaXQoJyAnKVswXV0gPSBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncncnKSA+PSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgY21kID0gJ2RmIC1sa1BUJztcbiAgICAgICAgICBleGVjU3luYygnbW91bnQnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBvc01vdW50c1tsaW5lLnNwbGl0KCcgJylbMF1dID0gbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3JlYWQtb25seScpID09PSAtMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gZmlsdGVyTGluZXMoc3Rkb3V0KTtcbiAgICAgICAgICBkYXRhID0gcGFyc2VEZihsaW5lcyk7XG4gICAgICAgICAgaWYgKCFlcnJvciB8fCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygnZGYgLWtQVCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZmlsdGVyTGluZXMoc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGFyc2VEZihsaW5lcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdXRpbC53bWljKCdsb2dpY2FsZGlzayBnZXQgQ2FwdGlvbixGaWxlU3lzdGVtLEZyZWVTcGFjZSxTaXplJykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfbG9naWNhbGRpc2sgfCBzZWxlY3QgQWNjZXNzLENhcHRpb24sRmlsZVN5c3RlbSxGcmVlU3BhY2UsU2l6ZSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaChmdW5jdGlvbiAoZGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2l6ZScsICc6JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyZWUgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdmcmVlc3BhY2UnLCAnOicpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0aW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcHRpb24nLCAnOicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ3VmFsdWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYWNjZXNzJywgJzonKTtcbiAgICAgICAgICAgICAgICBjb25zdCBydyA9IHJ3VmFsdWUgPyAodXRpbC50b0ludChyd1ZhbHVlKSAhPT0gMSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBmczogY2FwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZpbGVzeXN0ZW0nLCAnOicpLFxuICAgICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgICB1c2VkOiBzaXplIC0gZnJlZSxcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlOiBmcmVlLFxuICAgICAgICAgICAgICAgICAgICB1c2U6IHBhcnNlRmxvYXQoKCgxMDAuMCAqIChzaXplIC0gZnJlZSkpIC8gc2l6ZSkudG9GaXhlZCgyKSksXG4gICAgICAgICAgICAgICAgICAgIG1vdW50OiBjYXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICByd1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmZzU2l6ZSA9IGZzU2l6ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZTIC0gb3BlbiBmaWxlcyBjb3VudFxuXG5mdW5jdGlvbiBmc09wZW5GaWxlcyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBtYXg6IG51bGwsXG4gICAgICAgIGFsbG9jYXRlZDogbnVsbCxcbiAgICAgICAgYXZhaWxhYmxlOiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c2N0bCAtaSBrZXJuLm1heGZpbGVzIGtlcm4ubnVtX2ZpbGVzIGtlcm4ub3Blbl9maWxlcyc7XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQubWF4ID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ubWF4ZmlsZXMnLCAnOicpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuYWxsb2NhdGVkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ubnVtX2ZpbGVzJywgJzonKSwgMTApIHx8IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLm9wZW5fZmlsZXMnLCAnOicpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuYXZhaWxhYmxlID0gcmVzdWx0Lm1heCAtIHJlc3VsdC5hbGxvY2F0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgZnMucmVhZEZpbGUoJy9wcm9jL3N5cy9mcy9maWxlLW5yJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBpZiAobGluZXNbMF0pIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5yZXBsYWNlKC9cXHMrL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hbGxvY2F0ZWQgPSBwYXJzZUludChwYXJ0c1swXSwgMTApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hdmFpbGFibGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tYXggPSBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmF2YWlsYWJsZSkgeyByZXN1bHQuYXZhaWxhYmxlID0gcmVzdWx0Lm1heCAtIHJlc3VsdC5hbGxvY2F0ZWQ7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLnJlYWRGaWxlKCcvcHJvYy9zeXMvZnMvZmlsZS1tYXgnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lc1swXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1heCA9IHBhcnNlSW50KGxpbmVzWzBdLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmZzT3BlbkZpbGVzID0gZnNPcGVuRmlsZXM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkaXNrc1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKHMpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHMuc3Vic3RyKHMuaW5kZXhPZignICgnKSArIDIsIHMuaW5kZXhPZignIEJ5dGVzKScpIC0gMTApKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEZXZpY2VzKGxpbmVzKSB7XG4gIGxldCBkZXZpY2VzID0gW107XG4gIGxldCBpID0gMDtcbiAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGluZVswXSA9PT0gJyonKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBpZiAoIWRldmljZXNbaV0pIHtcbiAgICAgICAgICAgIGRldmljZXNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6ICcnLFxuICAgICAgICAgICAgICBpZGVudGlmaWVyOiAnJyxcbiAgICAgICAgICAgICAgdHlwZTogJ2Rpc2snLFxuICAgICAgICAgICAgICBmc1R5cGU6ICcnLFxuICAgICAgICAgICAgICBtb3VudDogJycsXG4gICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgIHBoeXNpY2FsOiAnSEREJyxcbiAgICAgICAgICAgICAgdXVpZDogJycsXG4gICAgICAgICAgICAgIGxhYmVsOiAnJyxcbiAgICAgICAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICAgICAgICBzZXJpYWw6ICcnLFxuICAgICAgICAgICAgICByZW1vdmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBwcm90b2NvbDogJycsXG4gICAgICAgICAgICAgIGdyb3VwOiAnJyxcbiAgICAgICAgICAgICAgZGV2aWNlOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS50cmltKCkudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8gKy9nLCAnJyk7XG4gICAgICAgICAgcGFydHNbMV0gPSBwYXJ0c1sxXS50cmltKCk7XG4gICAgICAgICAgaWYgKCdERVZJQ0VJREVOVElGSUVSJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5pZGVudGlmaWVyID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ0RFVklDRU5PREUnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLm5hbWUgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnVk9MVU1FTkFNRScgPT09IHBhcnRzWzBdKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbMV0uaW5kZXhPZignTm90IGFwcGxpY2FibGUnKSA9PT0gLTEpIHsgZGV2aWNlc1tpXS5sYWJlbCA9IHBhcnRzWzFdOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnUFJPVE9DT0wnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnByb3RvY29sID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ0RJU0tTSVpFJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5zaXplID0gcGFyc2VCeXRlcyhwYXJ0c1sxXSk7IH1cbiAgICAgICAgICBpZiAoJ0ZJTEVTWVNURU1QRVJTT05BTElUWScgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0uZnNUeXBlID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ01PVU5UUE9JTlQnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLm1vdW50ID0gcGFydHNbMV07IH1cbiAgICAgICAgICBpZiAoJ1ZPTFVNRVVVSUQnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnV1aWQgPSBwYXJ0c1sxXTsgfVxuICAgICAgICAgIGlmICgnUkVBRC1PTkxZTUVESUEnID09PSBwYXJ0c1swXSAmJiBwYXJ0c1sxXSA9PT0gJ1llcycpIHsgZGV2aWNlc1tpXS5waHlzaWNhbCA9ICdDRC9EVkQnOyB9XG4gICAgICAgICAgaWYgKCdTT0xJRFNUQVRFJyA9PT0gcGFydHNbMF0gJiYgcGFydHNbMV0gPT09ICdZZXMnKSB7IGRldmljZXNbaV0ucGh5c2ljYWwgPSAnU1NEJzsgfVxuICAgICAgICAgIGlmICgnVklSVFVBTCcgPT09IHBhcnRzWzBdKSB7IGRldmljZXNbaV0udHlwZSA9ICd2aXJ0dWFsJzsgfVxuICAgICAgICAgIGlmICgnUkVNT1ZBQkxFTUVESUEnID09PSBwYXJ0c1swXSkgeyBkZXZpY2VzW2ldLnJlbW92YWJsZSA9IChwYXJ0c1sxXSA9PT0gJ1JlbW92YWJsZScpOyB9XG4gICAgICAgICAgaWYgKCdQQVJUSVRJT05UWVBFJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS50eXBlID0gJ3BhcnQnOyB9XG4gICAgICAgICAgaWYgKCdERVZJQ0UvTUVESUFOQU1FJyA9PT0gcGFydHNbMF0pIHsgZGV2aWNlc1tpXS5tb2RlbCA9IHBhcnRzWzFdOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGV2aWNlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCbGsobGluZXMpIHtcbiAgbGV0IGRhdGEgPSBbXTtcblxuICBsaW5lcy5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJykuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBsaW5lID0gZGVjb2RlVVJJQ29tcG9uZW50KGxpbmUucmVwbGFjZSgvXFxcXHgvZywgJyUnKSk7XG4gICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xuICAgICAgbGV0IGRpc2sgPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgJ25hbWUnOiBkaXNrLm5hbWUsXG4gICAgICAgICd0eXBlJzogZGlzay50eXBlLFxuICAgICAgICAnZnNUeXBlJzogZGlzay5mc1R5cGUsXG4gICAgICAgICdtb3VudCc6IGRpc2subW91bnRwb2ludCxcbiAgICAgICAgJ3NpemUnOiBwYXJzZUludChkaXNrLnNpemUpLFxuICAgICAgICAncGh5c2ljYWwnOiAoZGlzay50eXBlID09PSAnZGlzaycgPyAoZGlzay5yb3RhID09PSAnMCcgPyAnU1NEJyA6ICdIREQnKSA6IChkaXNrLnR5cGUgPT09ICdyb20nID8gJ0NEL0RWRCcgOiAnJykpLFxuICAgICAgICAndXVpZCc6IGRpc2sudXVpZCxcbiAgICAgICAgJ2xhYmVsJzogZGlzay5sYWJlbCxcbiAgICAgICAgJ21vZGVsJzogKGRpc2subW9kZWwgfHwgJycpLnRyaW0oKSxcbiAgICAgICAgJ3NlcmlhbCc6IGRpc2suc2VyaWFsLFxuICAgICAgICAncmVtb3ZhYmxlJzogZGlzay5ybSA9PT0gJzEnLFxuICAgICAgICAncHJvdG9jb2wnOiBkaXNrLnRyYW4sXG4gICAgICAgICdncm91cCc6IGRpc2suZ3JvdXAgfHwgJycsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1dGlsLm5vb3AoKTtcbiAgICB9XG4gIH0pO1xuICBkYXRhID0gdXRpbC51bmlxdWUoZGF0YSk7XG4gIGRhdGEgPSB1dGlsLnNvcnRCeUtleShkYXRhLCBbJ3R5cGUnLCAnbmFtZSddKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRlY29kZU1kYWJtRGF0YShsaW5lcykge1xuICBjb25zdCByYWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21kX2xldmVsJywgJz0nKTtcbiAgY29uc3QgbGFiZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWRfbmFtZScsICc9Jyk7IC8vIDwtIGdldCBsYWJlbCBpbmZvXG4gIGNvbnN0IHV1aWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWRfdXVpZCcsICc9Jyk7IC8vIDwtIGdldCB1dWlkIGluZm9cbiAgY29uc3QgbWVtYmVycyA9IFtdO1xuICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbWRfZGV2aWNlX2RldicpICYmIGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcvZGV2LycpID4gMCkge1xuICAgICAgbWVtYmVycy5wdXNoKGxpbmUuc3BsaXQoJy9kZXYvJylbMV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmFpZCxcbiAgICBsYWJlbCxcbiAgICB1dWlkLFxuICAgIG1lbWJlcnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmFpZE1hdGNoTGludXgoZGF0YSkge1xuICAvLyBmb3IgYWxsIGJsb2NrIGRldmljZXMgb2YgdHlwZSBcInJhaWQlXCJcbiAgbGV0IHJlc3VsdCA9IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKCdyYWlkJykpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhgbWRhZG0gLS1leHBvcnQgLS1kZXRhaWwgL2Rldi8ke2VsZW1lbnQubmFtZX1gKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgbWREYXRhID0gZGVjb2RlTWRhYm1EYXRhKGxpbmVzKTtcblxuICAgICAgICBlbGVtZW50LmxhYmVsID0gbWREYXRhLmxhYmVsOyAvLyA8LSBhc3NpZ24gbGFiZWwgaW5mb1xuICAgICAgICBlbGVtZW50LnV1aWQgPSBtZERhdGEudXVpZDsgLy8gPC0gYXNzaWduIHV1aWQgaW5mb1xuXG4gICAgICAgIGlmIChtZERhdGEubWVtYmVycyAmJiBtZERhdGEubWVtYmVycy5sZW5ndGggJiYgbWREYXRhLnJhaWQgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoYmxvY2tkZXZpY2UgPT4ge1xuICAgICAgICAgICAgaWYgKGJsb2NrZGV2aWNlLmZzVHlwZSA9PT0gJ2xpbnV4X3JhaWRfbWVtYmVyJyAmJiBtZERhdGEubWVtYmVycy5pbmRleE9mKGJsb2NrZGV2aWNlLm5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgYmxvY2tkZXZpY2UuZ3JvdXAgPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tkZXZpY2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldERldmljZXNMaW51eChkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBkYXRhLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKCdkaXNrJykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQubmFtZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hEZXZpY2VzTGludXgoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0gZGF0YTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZXZpY2VzID0gZ2V0RGV2aWNlc0xpbnV4KGRhdGEpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoYmxvY2tkZXZpY2UgPT4ge1xuICAgICAgaWYgKGJsb2NrZGV2aWNlLnR5cGUuc3RhcnRzV2l0aCgncGFydCcpIHx8IGJsb2NrZGV2aWNlLnR5cGUuc3RhcnRzV2l0aCgnZGlzaycpKSB7XG4gICAgICAgIGRldmljZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBpZiAoYmxvY2tkZXZpY2UubmFtZS5zdGFydHNXaXRoKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBibG9ja2RldmljZS5kZXZpY2UgPSAnL2Rldi8nICsgZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJsb2NrZGV2aWNlO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2aWNlc01hYyhkYXRhKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBkYXRhLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnQudHlwZS5zdGFydHNXaXRoKCdkaXNrJykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogZWxlbWVudC5uYW1lLCBtb2RlbDogZWxlbWVudC5tb2RlbCwgZGV2aWNlOiBlbGVtZW50Lm5hbWUgfSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnR5cGUuc3RhcnRzV2l0aCgndmlydHVhbCcpKSB7XG4gICAgICBsZXQgZGV2aWNlID0gJyc7XG4gICAgICByZXN1bHQuZm9yRWFjaChlID0+IHtcbiAgICAgICAgaWYgKGUubW9kZWwgPT09IGVsZW1lbnQubW9kZWwpIHtcbiAgICAgICAgICBkZXZpY2UgPSBlLmRldmljZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGV2aWNlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogZWxlbWVudC5uYW1lLCBtb2RlbDogZWxlbWVudC5tb2RlbCwgZGV2aWNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1hdGNoRGV2aWNlc01hYyhkYXRhKSB7XG4gIGxldCByZXN1bHQgPSBkYXRhO1xuICB0cnkge1xuICAgIGNvbnN0IGRldmljZXMgPSBnZXREZXZpY2VzTWFjKGRhdGEpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoYmxvY2tkZXZpY2UgPT4ge1xuICAgICAgaWYgKGJsb2NrZGV2aWNlLnR5cGUuc3RhcnRzV2l0aCgncGFydCcpIHx8IGJsb2NrZGV2aWNlLnR5cGUuc3RhcnRzV2l0aCgnZGlzaycpIHx8IGJsb2NrZGV2aWNlLnR5cGUuc3RhcnRzV2l0aCgndmlydHVhbCcpKSB7XG4gICAgICAgIGRldmljZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICBpZiAoYmxvY2tkZXZpY2UubmFtZS5zdGFydHNXaXRoKGVsZW1lbnQubmFtZSkpIHtcbiAgICAgICAgICAgIGJsb2NrZGV2aWNlLmRldmljZSA9IGVsZW1lbnQuZGV2aWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmxvY2tkZXZpY2U7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXREZXZpY2VzV2luKGRpc2tEcml2ZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGRpc2tEcml2ZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBjb25zdCBsaW5lcyA9IGVsZW1lbnQuc3BsaXQoJ1xcclxcbicpO1xuICAgIGNvbnN0IGRldmljZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdEZXZpY2VJRCcsICc6Jyk7XG4gICAgbGV0IHBhcnRpdGlvbnMgPSBlbGVtZW50LnNwbGl0KCdAe0RldmljZUlEPScpO1xuICAgIGlmIChwYXJ0aXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHBhcnRpdGlvbnMgPSBwYXJ0aXRpb25zLnNsaWNlKDEpO1xuICAgICAgcGFydGl0aW9ucy5mb3JFYWNoKHBhcnRpdGlvbiA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgbmFtZTogcGFydGl0aW9uLnNwbGl0KCc7JylbMF0udG9VcHBlckNhc2UoKSwgZGV2aWNlIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWF0Y2hEZXZpY2VzV2luKGRhdGEsIGRpc2tEcml2ZXMpIHtcbiAgY29uc3QgZGV2aWNlcyA9IGdldERldmljZXNXaW4oZGlza0RyaXZlcyk7XG4gIGRhdGEubWFwKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVzRGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKChlKSA9PiB7IHJldHVybiBlLm5hbWUgPT09IGVsZW1lbnQubmFtZS50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgICBpZiAoZmlsdGVyZXNEZXZpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQuZGV2aWNlID0gZmlsdGVyZXNEZXZpY2VzWzBdLmRldmljZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gYmxrU3Rkb3V0VG9PYmplY3Qoc3Rkb3V0KSB7XG4gIHJldHVybiBzdGRvdXQudG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKC9OQU1FPS9nLCAne1wibmFtZVwiOicpXG4gICAgLnJlcGxhY2UoL0ZTVFlQRT0vZywgJyxcImZzVHlwZVwiOicpXG4gICAgLnJlcGxhY2UoL1RZUEU9L2csICcsXCJ0eXBlXCI6JylcbiAgICAucmVwbGFjZSgvU0laRT0vZywgJyxcInNpemVcIjonKVxuICAgIC5yZXBsYWNlKC9NT1VOVFBPSU5UPS9nLCAnLFwibW91bnRwb2ludFwiOicpXG4gICAgLnJlcGxhY2UoL1VVSUQ9L2csICcsXCJ1dWlkXCI6JylcbiAgICAucmVwbGFjZSgvUk9UQT0vZywgJyxcInJvdGFcIjonKVxuICAgIC5yZXBsYWNlKC9STz0vZywgJyxcInJvXCI6JylcbiAgICAucmVwbGFjZSgvUk09L2csICcsXCJybVwiOicpXG4gICAgLnJlcGxhY2UoL1RSQU49L2csICcsXCJ0cmFuXCI6JylcbiAgICAucmVwbGFjZSgvU0VSSUFMPS9nLCAnLFwic2VyaWFsXCI6JylcbiAgICAucmVwbGFjZSgvTEFCRUw9L2csICcsXCJsYWJlbFwiOicpXG4gICAgLnJlcGxhY2UoL01PREVMPS9nLCAnLFwibW9kZWxcIjonKVxuICAgIC5yZXBsYWNlKC9PV05FUj0vZywgJyxcIm93bmVyXCI6JylcbiAgICAucmVwbGFjZSgvR1JPVVA9L2csICcsXCJncm91cFwiOicpXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnfVxcbicpO1xufVxuXG5mdW5jdGlvbiBibG9ja0RldmljZXMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBkYXRhID0gW107XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL3dpa2kudWJ1bnR1dXNlcnMuZGUvbHNibGsvXG4gICAgICAgIC8vIGV4ZWMoXCJsc2JsayAtYm8gTkFNRSxUWVBFLFNJWkUsRlNUWVBFLE1PVU5UUE9JTlQsVVVJRCxST1RBLFJPLFRSQU4sU0VSSUFMLExBQkVMLE1PREVMLE9XTkVSLEdST1VQLE1PREUsQUxJR05NRU5ULE1JTi1JTyxPUFQtSU8sUEhZLVNFQyxMT0ctU0VDLFNDSEVELFJRLVNJWkUsUkEsV1NBTUVcIiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgZXhlYygnbHNibGsgLWJQbyBOQU1FLFRZUEUsU0laRSxGU1RZUEUsTU9VTlRQT0lOVCxVVUlELFJPVEEsUk8sUk0sVFJBTixTRVJJQUwsTEFCRUwsTU9ERUwsT1dORVIgMj4vZGV2L251bGwnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBibGtTdGRvdXRUb09iamVjdChzdGRvdXQpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGRhdGEgPSBwYXJzZUJsayhsaW5lcyk7XG4gICAgICAgICAgICBkYXRhID0gcmFpZE1hdGNoTGludXgoZGF0YSk7XG4gICAgICAgICAgICBkYXRhID0gbWF0Y2hEZXZpY2VzTGludXgoZGF0YSk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdsc2JsayAtYlBvIE5BTUUsVFlQRSxTSVpFLEZTVFlQRSxNT1VOVFBPSU5ULFVVSUQsUk9UQSxSTyxSTSxMQUJFTCxNT0RFTCxPV05FUiAyPi9kZXYvbnVsbCcsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gYmxrU3Rkb3V0VG9PYmplY3Qoc3Rkb3V0KS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBhcnNlQmxrKGxpbmVzKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcmFpZE1hdGNoTGludXgoZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCdkaXNrdXRpbCBpbmZvIC1hbGwnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAvLyBwYXJzZSBsaW5lcyBpbnRvIHRlbXAgYXJyYXkgb2YgZGV2aWNlc1xuICAgICAgICAgICAgZGF0YSA9IHBhcnNlRGV2aWNlcyhsaW5lcyk7XG4gICAgICAgICAgICBkYXRhID0gbWF0Y2hEZXZpY2VzTWFjKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGRhdGEpOyB9XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IGRyaXZldHlwZXMgPSBbJ1Vua25vd24nLCAnTm9Sb290JywgJ1JlbW92YWJsZScsICdMb2NhbCcsICdOZXR3b3JrJywgJ0NEL0RWRCcsICdSQU0nXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB1dGlsLndtaWMoJ2xvZ2ljYWxkaXNrIGdldCBDYXB0aW9uLERlc2NyaXB0aW9uLERldmljZUlELERyaXZlVHlwZSxGaWxlU3lzdGVtLEZyZWVTcGFjZSxOYW1lLFNpemUsVm9sdW1lTmFtZSxWb2x1bWVTZXJpYWxOdW1iZXIgL3ZhbHVlJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIC8vIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX2xvZ2ljYWxkaXNrIHwgc2VsZWN0IENhcHRpb24sRHJpdmVUeXBlLE5hbWUsRmlsZVN5c3RlbSxTaXplLFZvbHVtZVNlcmlhbE51bWJlcixWb2x1bWVOYW1lIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIC1DbGFzc05hbWUgV2luMzJfTG9naWNhbERpc2sgfCBzZWxlY3QgQ2FwdGlvbixEcml2ZVR5cGUsTmFtZSxGaWxlU3lzdGVtLFNpemUsVm9sdW1lU2VyaWFsTnVtYmVyLFZvbHVtZU5hbWUgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LVdtaU9iamVjdCAtQ2xhc3MgV2luMzJfZGlza2RyaXZlIHwgU2VsZWN0LU9iamVjdCAtUHJvcGVydHkgUE5QRGV2aWNlSWQsRGV2aWNlSUQsIE1vZGVsLCBTaXplLCBAe0w9XFwnUGFydGl0aW9uc1xcJzsgRT17JF8uR2V0UmVsYXRlZChcXCdXaW4zMl9EaXNrUGFydGl0aW9uXFwnKS5HZXRSZWxhdGVkKFxcJ1dpbjMyX0xvZ2ljYWxEaXNrXFwnKSB8IFNlbGVjdC1PYmplY3QgLVByb3BlcnR5IERldmljZUlELCBWb2x1bWVOYW1lLCBTaXplLCBGcmVlU3BhY2V9fSB8IGZsJykpO1xuICAgICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBsb2dpY2FsRGlza3MgPSByZXMucmVzdWx0c1swXS50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBsZXQgZGlza0RyaXZlcyA9IHJlcy5yZXN1bHRzWzFdLnRvU3RyaW5nKCkuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIGxvZ2ljYWxEaXNrcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IGRyaXZldHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkcml2ZXR5cGUnLCAnOicpO1xuICAgICAgICAgICAgICBpZiAoZHJpdmV0eXBlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXB0aW9uJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaXNrJyxcbiAgICAgICAgICAgICAgICAgIGZzVHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZpbGVzeXN0ZW0nLCAnOicpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICBtb3VudDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcHRpb24nLCAnOicpLFxuICAgICAgICAgICAgICAgICAgc2l6ZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NpemUnLCAnOicpLFxuICAgICAgICAgICAgICAgICAgcGh5c2ljYWw6IChkcml2ZXR5cGUgPj0gMCAmJiBkcml2ZXR5cGUgPD0gNikgPyBkcml2ZXR5cGVzW2RyaXZldHlwZV0gOiBkcml2ZXR5cGVzWzBdLFxuICAgICAgICAgICAgICAgICAgdXVpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHVtZXNlcmlhbG51bWJlcicsICc6JyksXG4gICAgICAgICAgICAgICAgICBsYWJlbDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHVtZW5hbWUnLCAnOicpLFxuICAgICAgICAgICAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAndm9sdW1lc2VyaWFsbnVtYmVyJywgJzonKSxcbiAgICAgICAgICAgICAgICAgIHJlbW92YWJsZTogZHJpdmV0eXBlID09PSAnMicsXG4gICAgICAgICAgICAgICAgICBwcm90b2NvbDogJycsXG4gICAgICAgICAgICAgICAgICBncm91cDogJycsXG4gICAgICAgICAgICAgICAgICBkZXZpY2U6ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gbWF0Y2ggZGV2aWNlc1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGV2aWNlc1dpbihkYXRhLCBkaXNrRHJpdmVzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZGF0YSk7IH1cbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAvLyB3aWxsIGZvbGxvd1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ibG9ja0RldmljZXMgPSBibG9ja0RldmljZXM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGUyAtIHNwZWVkXG5cbmZ1bmN0aW9uIGNhbGNGc1NwZWVkKHJ4LCB3eCkge1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIHJ4OiAwLFxuICAgIHd4OiAwLFxuICAgIHR4OiAwLFxuICAgIHJ4X3NlYzogbnVsbCxcbiAgICB3eF9zZWM6IG51bGwsXG4gICAgdHhfc2VjOiBudWxsLFxuICAgIG1zOiAwXG4gIH07XG5cbiAgaWYgKF9mc19zcGVlZCAmJiBfZnNfc3BlZWQubXMpIHtcbiAgICByZXN1bHQucnggPSByeDtcbiAgICByZXN1bHQud3ggPSB3eDtcbiAgICByZXN1bHQudHggPSByZXN1bHQucnggKyByZXN1bHQud3g7XG4gICAgcmVzdWx0Lm1zID0gRGF0ZS5ub3coKSAtIF9mc19zcGVlZC5tcztcbiAgICByZXN1bHQucnhfc2VjID0gKHJlc3VsdC5yeCAtIF9mc19zcGVlZC5ieXRlc19yZWFkKSAvIChyZXN1bHQubXMgLyAxMDAwKTtcbiAgICByZXN1bHQud3hfc2VjID0gKHJlc3VsdC53eCAtIF9mc19zcGVlZC5ieXRlc193cml0ZSkgLyAocmVzdWx0Lm1zIC8gMTAwMCk7XG4gICAgcmVzdWx0LnR4X3NlYyA9IHJlc3VsdC5yeF9zZWMgKyByZXN1bHQud3hfc2VjO1xuICAgIF9mc19zcGVlZC5yeF9zZWMgPSByZXN1bHQucnhfc2VjO1xuICAgIF9mc19zcGVlZC53eF9zZWMgPSByZXN1bHQud3hfc2VjO1xuICAgIF9mc19zcGVlZC50eF9zZWMgPSByZXN1bHQudHhfc2VjO1xuICAgIF9mc19zcGVlZC5ieXRlc19yZWFkID0gcmVzdWx0LnJ4O1xuICAgIF9mc19zcGVlZC5ieXRlc193cml0ZSA9IHJlc3VsdC53eDtcbiAgICBfZnNfc3BlZWQuYnl0ZXNfb3ZlcmFsbCA9IHJlc3VsdC5yeCArIHJlc3VsdC53eDtcbiAgICBfZnNfc3BlZWQubXMgPSBEYXRlLm5vdygpO1xuICAgIF9mc19zcGVlZC5sYXN0X21zID0gcmVzdWx0Lm1zO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5yeCA9IHJ4O1xuICAgIHJlc3VsdC53eCA9IHd4O1xuICAgIHJlc3VsdC50eCA9IHJlc3VsdC5yeCArIHJlc3VsdC53eDtcbiAgICBfZnNfc3BlZWQucnhfc2VjID0gbnVsbDtcbiAgICBfZnNfc3BlZWQud3hfc2VjID0gbnVsbDtcbiAgICBfZnNfc3BlZWQudHhfc2VjID0gbnVsbDtcbiAgICBfZnNfc3BlZWQuYnl0ZXNfcmVhZCA9IHJlc3VsdC5yeDtcbiAgICBfZnNfc3BlZWQuYnl0ZXNfd3JpdGUgPSByZXN1bHQud3g7XG4gICAgX2ZzX3NwZWVkLmJ5dGVzX292ZXJhbGwgPSByZXN1bHQucnggKyByZXN1bHQud3g7XG4gICAgX2ZzX3NwZWVkLm1zID0gRGF0ZS5ub3coKTtcbiAgICBfZnNfc3BlZWQubGFzdF9tcyA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZnNTdGF0cyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKF93aW5kb3dzIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QgfHwgX3N1bm9zKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICByeDogMCxcbiAgICAgICAgd3g6IDAsXG4gICAgICAgIHR4OiAwLFxuICAgICAgICByeF9zZWM6IG51bGwsXG4gICAgICAgIHd4X3NlYzogbnVsbCxcbiAgICAgICAgdHhfc2VjOiBudWxsLFxuICAgICAgICBtczogMFxuICAgICAgfTtcblxuICAgICAgbGV0IHJ4ID0gMDtcbiAgICAgIGxldCB3eCA9IDA7XG4gICAgICBpZiAoKF9mc19zcGVlZCAmJiAhX2ZzX3NwZWVkLm1zKSB8fCAoX2ZzX3NwZWVkICYmIF9mc19zcGVlZC5tcyAmJiBEYXRlLm5vdygpIC0gX2ZzX3NwZWVkLm1zID49IDUwMCkpIHtcbiAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgIC8vIGV4ZWMoXCJkZiAtayB8IGdyZXAgL2Rldi9cIiwgZnVuY3Rpb24oZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGV4ZWMoJ2xzYmxrIC1yIDI+L2Rldi9udWxsIHwgZ3JlcCAvJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IGZzX2ZpbHRlciA9IFtdO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChmc19maWx0ZXIuaW5kZXhPZihsaW5lWzBdKSA9PT0gLTEpIHsgZnNfZmlsdGVyLnB1c2gobGluZVswXSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBmc19maWx0ZXIuam9pbignfCcpO1xuICAgICAgICAgICAgICBleGVjKCdjYXQgL3Byb2MvZGlza3N0YXRzIHwgZWdyZXAgXCInICsgb3V0cHV0ICsgJ1wiJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHJ4ICs9IHBhcnNlSW50KGxpbmVbNV0pICogNTEyO1xuICAgICAgICAgICAgICAgICAgICAgIHd4ICs9IHBhcnNlSW50KGxpbmVbOV0pICogNTEyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNGc1NwZWVkKHJ4LCB3eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgZXhlYygnaW9yZWcgLWMgSU9CbG9ja1N0b3JhZ2VEcml2ZXIgLWsgU3RhdGlzdGljcyAtciAtdzAgfCBzZWQgLW4gXCIvSU9CbG9ja1N0b3JhZ2VEcml2ZXIvLC9TdGF0aXN0aWNzL3BcIiB8IGdyZXAgXCJTdGF0aXN0aWNzXCIgfCB0ciAtY2QgXCIwMTIzNDU2Nzg5MCxcXG5cIicsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zcGxpdCgnLCcpO1xuXG4gICAgICAgICAgICAgICAgICByeCArPSBwYXJzZUludChsaW5lWzJdKTtcbiAgICAgICAgICAgICAgICAgIHd4ICs9IHBhcnNlSW50KGxpbmVbOV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNGc1NwZWVkKHJ4LCB3eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0Lm1zID0gX2ZzX3NwZWVkLmxhc3RfbXM7XG4gICAgICAgIHJlc3VsdC5yeCA9IF9mc19zcGVlZC5ieXRlc19yZWFkO1xuICAgICAgICByZXN1bHQud3ggPSBfZnNfc3BlZWQuYnl0ZXNfd3JpdGU7XG4gICAgICAgIHJlc3VsdC50eCA9IF9mc19zcGVlZC5ieXRlc19yZWFkICsgX2ZzX3NwZWVkLmJ5dGVzX3dyaXRlO1xuICAgICAgICByZXN1bHQucnhfc2VjID0gX2ZzX3NwZWVkLnJ4X3NlYztcbiAgICAgICAgcmVzdWx0Lnd4X3NlYyA9IF9mc19zcGVlZC53eF9zZWM7XG4gICAgICAgIHJlc3VsdC50eF9zZWMgPSBfZnNfc3BlZWQudHhfc2VjO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZnNTdGF0cyA9IGZzU3RhdHM7XG5cbmZ1bmN0aW9uIGNhbGNEaXNrSU8ocklPLCB3SU8sIHJXYWl0VGltZSwgd1dhaXRUaW1lLCB0V2FpdFRpbWUpIHtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICBySU86IDAsXG4gICAgd0lPOiAwLFxuICAgIHRJTzogMCxcbiAgICBySU9fc2VjOiBudWxsLFxuICAgIHdJT19zZWM6IG51bGwsXG4gICAgdElPX3NlYzogbnVsbCxcbiAgICByV2FpdFRpbWU6IDAsXG4gICAgd1dhaXRUaW1lOiAwLFxuICAgIHRXYWl0VGltZTogMCxcbiAgICByV2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgd1dhaXRQZXJjZW50OiBudWxsLFxuICAgIHRXYWl0UGVyY2VudDogbnVsbCxcbiAgICBtczogMFxuICB9O1xuICBpZiAoX2Rpc2tfaW8gJiYgX2Rpc2tfaW8ubXMpIHtcbiAgICByZXN1bHQucklPID0gcklPO1xuICAgIHJlc3VsdC53SU8gPSB3SU87XG4gICAgcmVzdWx0LnRJTyA9IHJJTyArIHdJTztcbiAgICByZXN1bHQubXMgPSBEYXRlLm5vdygpIC0gX2Rpc2tfaW8ubXM7XG4gICAgcmVzdWx0LnJJT19zZWMgPSAocmVzdWx0LnJJTyAtIF9kaXNrX2lvLnJJTykgLyAocmVzdWx0Lm1zIC8gMTAwMCk7XG4gICAgcmVzdWx0LndJT19zZWMgPSAocmVzdWx0LndJTyAtIF9kaXNrX2lvLndJTykgLyAocmVzdWx0Lm1zIC8gMTAwMCk7XG4gICAgcmVzdWx0LnRJT19zZWMgPSByZXN1bHQucklPX3NlYyArIHJlc3VsdC53SU9fc2VjO1xuICAgIHJlc3VsdC5yV2FpdFRpbWUgPSByV2FpdFRpbWU7XG4gICAgcmVzdWx0LndXYWl0VGltZSA9IHdXYWl0VGltZTtcbiAgICByZXN1bHQudFdhaXRUaW1lID0gdFdhaXRUaW1lO1xuICAgIHJlc3VsdC5yV2FpdFBlcmNlbnQgPSAocmVzdWx0LnJXYWl0VGltZSAtIF9kaXNrX2lvLnJXYWl0VGltZSkgKiAxMDAgLyAocmVzdWx0Lm1zKTtcbiAgICByZXN1bHQud1dhaXRQZXJjZW50ID0gKHJlc3VsdC53V2FpdFRpbWUgLSBfZGlza19pby53V2FpdFRpbWUpICogMTAwIC8gKHJlc3VsdC5tcyk7XG4gICAgcmVzdWx0LnRXYWl0UGVyY2VudCA9IChyZXN1bHQudFdhaXRUaW1lIC0gX2Rpc2tfaW8udFdhaXRUaW1lKSAqIDEwMCAvIChyZXN1bHQubXMpO1xuICAgIF9kaXNrX2lvLnJJTyA9IHJJTztcbiAgICBfZGlza19pby53SU8gPSB3SU87XG4gICAgX2Rpc2tfaW8ucklPX3NlYyA9IHJlc3VsdC5ySU9fc2VjO1xuICAgIF9kaXNrX2lvLndJT19zZWMgPSByZXN1bHQud0lPX3NlYztcbiAgICBfZGlza19pby50SU9fc2VjID0gcmVzdWx0LnRJT19zZWM7XG4gICAgX2Rpc2tfaW8ucldhaXRUaW1lID0gcldhaXRUaW1lO1xuICAgIF9kaXNrX2lvLndXYWl0VGltZSA9IHdXYWl0VGltZTtcbiAgICBfZGlza19pby50V2FpdFRpbWUgPSB0V2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8ucldhaXRQZXJjZW50ID0gcmVzdWx0LnJXYWl0UGVyY2VudDtcbiAgICBfZGlza19pby53V2FpdFBlcmNlbnQgPSByZXN1bHQud1dhaXRQZXJjZW50O1xuICAgIF9kaXNrX2lvLnRXYWl0UGVyY2VudCA9IHJlc3VsdC50V2FpdFBlcmNlbnQ7XG4gICAgX2Rpc2tfaW8ubGFzdF9tcyA9IHJlc3VsdC5tcztcbiAgICBfZGlza19pby5tcyA9IERhdGUubm93KCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnJJTyA9IHJJTztcbiAgICByZXN1bHQud0lPID0gd0lPO1xuICAgIHJlc3VsdC50SU8gPSBySU8gKyB3SU87XG4gICAgcmVzdWx0LnJXYWl0VGltZSA9IHJXYWl0VGltZTtcbiAgICByZXN1bHQud1dhaXRUaW1lID0gd1dhaXRUaW1lO1xuICAgIHJlc3VsdC50V2FpdFRpbWUgPSB0V2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8ucklPID0gcklPO1xuICAgIF9kaXNrX2lvLndJTyA9IHdJTztcbiAgICBfZGlza19pby5ySU9fc2VjID0gbnVsbDtcbiAgICBfZGlza19pby53SU9fc2VjID0gbnVsbDtcbiAgICBfZGlza19pby50SU9fc2VjID0gbnVsbDtcbiAgICBfZGlza19pby5yV2FpdFRpbWUgPSByV2FpdFRpbWU7XG4gICAgX2Rpc2tfaW8ud1dhaXRUaW1lID0gd1dhaXRUaW1lO1xuICAgIF9kaXNrX2lvLnRXYWl0VGltZSA9IHRXYWl0VGltZTtcbiAgICBfZGlza19pby5yV2FpdFBlcmNlbnQgPSBudWxsO1xuICAgIF9kaXNrX2lvLndXYWl0UGVyY2VudCA9IG51bGw7XG4gICAgX2Rpc2tfaW8udFdhaXRQZXJjZW50ID0gbnVsbDtcbiAgICBfZGlza19pby5sYXN0X21zID0gMDtcbiAgICBfZGlza19pby5tcyA9IERhdGUubm93KCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGlza3NJTyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgcklPOiAwLFxuICAgICAgICB3SU86IDAsXG4gICAgICAgIHRJTzogMCxcbiAgICAgICAgcklPX3NlYzogbnVsbCxcbiAgICAgICAgd0lPX3NlYzogbnVsbCxcbiAgICAgICAgdElPX3NlYzogbnVsbCxcbiAgICAgICAgcldhaXRUaW1lOiAwLFxuICAgICAgICB3V2FpdFRpbWU6IDAsXG4gICAgICAgIHRXYWl0VGltZTogMCxcbiAgICAgICAgcldhaXRQZXJjZW50OiBudWxsLFxuICAgICAgICB3V2FpdFBlcmNlbnQ6IG51bGwsXG4gICAgICAgIHRXYWl0UGVyY2VudDogbnVsbCxcbiAgICAgICAgbXM6IDBcbiAgICAgIH07XG4gICAgICBsZXQgcklPID0gMDtcbiAgICAgIGxldCB3SU8gPSAwO1xuICAgICAgbGV0IHJXYWl0VGltZSA9IDA7XG4gICAgICBsZXQgd1dhaXRUaW1lID0gMDtcbiAgICAgIGxldCB0V2FpdFRpbWUgPSAwO1xuXG4gICAgICBpZiAoKF9kaXNrX2lvICYmICFfZGlza19pby5tcykgfHwgKF9kaXNrX2lvICYmIF9kaXNrX2lvLm1zICYmIERhdGUubm93KCkgLSBfZGlza19pby5tcyA+PSA1MDApKSB7XG4gICAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICAgIC8vIHByaW50cyBCbG9jayBsYXllciBzdGF0aXN0aWNzIGZvciBhbGwgbW91bnRlZCB2b2x1bWVzXG4gICAgICAgICAgLy8gdmFyIGNtZCA9IFwiZm9yIG1vdW50IGluIGBsc2JsayB8IGdyZXAgLyB8IHNlZCAtciAncy/ilIIg4pSU4pSALy8nIHwgY3V0IC1kICcgJyAtZiAxYDsgZG8gY2F0IC9zeXMvYmxvY2svJG1vdW50L3N0YXQgfCBzZWQgLXIgJ3MvICsvOy9nJyB8IHNlZCAtciAncy9eOy8vJzsgZG9uZVwiO1xuICAgICAgICAgIC8vIHZhciBjbWQgPSBcImZvciBtb3VudCBpbiBgbHNibGsgfCBncmVwIC8gfCBzZWQgJ3MvW+KUguKUlOKUgOKUnF0vL2cnIHwgYXdrICd7JDE9JDF9OzEnIHwgY3V0IC1kICcgJyAtZiAxIHwgc29ydCAtdWA7IGRvIGNhdCAvc3lzL2Jsb2NrLyRtb3VudC9zdGF0IHwgc2VkIC1yICdzLyArLzsvZycgfCBzZWQgLXIgJ3MvXjsvLyc7IGRvbmVcIjtcbiAgICAgICAgICBsZXQgY21kID0gJ2ZvciBtb3VudCBpbiBgbHNibGsgMj4vZGV2L251bGwgfCBncmVwIFwiIGRpc2sgXCIgfCBzZWQgXCJzL1vilILilJTilIDilJxdLy9nXCIgfCBhd2sgXFwneyQxPSQxfTsxXFwnIHwgY3V0IC1kIFwiIFwiIC1mIDEgfCBzb3J0IC11YDsgZG8gY2F0IC9zeXMvYmxvY2svJG1vdW50L3N0YXQgfCBzZWQgLXIgXCJzLyArLzsvZ1wiIHwgc2VkIC1yIFwicy9eOy8vXCI7IGRvbmUnO1xuXG4gICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3VtIHIvd0lPIG9mIGFsbCBkaXNrcyB0byBjb21wdXRlIGFsbCBkaXNrcyBJT1xuICAgICAgICAgICAgICAgIGxldCBzdGF0cyA9IGxpbmUuc3BsaXQoJzsnKTtcbiAgICAgICAgICAgICAgICBySU8gKz0gcGFyc2VJbnQoc3RhdHNbMF0pO1xuICAgICAgICAgICAgICAgIHdJTyArPSBwYXJzZUludChzdGF0c1s0XSk7XG4gICAgICAgICAgICAgICAgcldhaXRUaW1lICs9IHBhcnNlSW50KHN0YXRzWzNdKTtcbiAgICAgICAgICAgICAgICB3V2FpdFRpbWUgKz0gcGFyc2VJbnQoc3RhdHNbN10pO1xuICAgICAgICAgICAgICAgIHRXYWl0VGltZSArPSBwYXJzZUludChzdGF0c1sxMF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY0Rpc2tJTyhySU8sIHdJTywgcldhaXRUaW1lLCB3V2FpdFRpbWUsIHRXYWl0VGltZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgIGV4ZWMoJ2lvcmVnIC1jIElPQmxvY2tTdG9yYWdlRHJpdmVyIC1rIFN0YXRpc3RpY3MgLXIgLXcwIHwgc2VkIC1uIFwiL0lPQmxvY2tTdG9yYWdlRHJpdmVyLywvU3RhdGlzdGljcy9wXCIgfCBncmVwIFwiU3RhdGlzdGljc1wiIHwgdHIgLWNkIFwiMDEyMzQ1Njc4OTAsXFxuXCInLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgICAgcklPICs9IHBhcnNlSW50KGxpbmVbMTBdKTtcbiAgICAgICAgICAgICAgICAgIHdJTyArPSBwYXJzZUludChsaW5lWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjRGlza0lPKHJJTywgd0lPLCByV2FpdFRpbWUsIHdXYWl0VGltZSwgdFdhaXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucklPID0gX2Rpc2tfaW8ucklPO1xuICAgICAgICByZXN1bHQud0lPID0gX2Rpc2tfaW8ud0lPO1xuICAgICAgICByZXN1bHQudElPID0gX2Rpc2tfaW8ucklPICsgX2Rpc2tfaW8ud0lPO1xuICAgICAgICByZXN1bHQubXMgPSBfZGlza19pby5sYXN0X21zO1xuICAgICAgICByZXN1bHQucklPX3NlYyA9IF9kaXNrX2lvLnJJT19zZWM7XG4gICAgICAgIHJlc3VsdC53SU9fc2VjID0gX2Rpc2tfaW8ud0lPX3NlYztcbiAgICAgICAgcmVzdWx0LnRJT19zZWMgPSBfZGlza19pby50SU9fc2VjO1xuICAgICAgICByZXN1bHQucldhaXRUaW1lID0gX2Rpc2tfaW8ucldhaXRUaW1lO1xuICAgICAgICByZXN1bHQud1dhaXRUaW1lID0gX2Rpc2tfaW8ud1dhaXRUaW1lO1xuICAgICAgICByZXN1bHQudFdhaXRUaW1lID0gX2Rpc2tfaW8udFdhaXRUaW1lO1xuICAgICAgICByZXN1bHQucldhaXRQZXJjZW50ID0gX2Rpc2tfaW8ucldhaXRQZXJjZW50O1xuICAgICAgICByZXN1bHQud1dhaXRQZXJjZW50ID0gX2Rpc2tfaW8ud1dhaXRQZXJjZW50O1xuICAgICAgICByZXN1bHQudFdhaXRQZXJjZW50ID0gX2Rpc2tfaW8udFdhaXRQZXJjZW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGlza3NJTyA9IGRpc2tzSU87XG5cbmZ1bmN0aW9uIGRpc2tMYXlvdXQoY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiBnZXRWZW5kb3JGcm9tTW9kZWwobW9kZWwpIHtcbiAgICBjb25zdCBkaXNrTWFudWZhY3R1cmVycyA9IFtcbiAgICAgIHsgcGF0dGVybjogJ1dFU1RFUk4uKicsIG1hbnVmYWN0dXJlcjogJ1dlc3Rlcm4gRGlnaXRhbCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ15XREMuKicsIG1hbnVmYWN0dXJlcjogJ1dlc3Rlcm4gRGlnaXRhbCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ1dELionLCBtYW51ZmFjdHVyZXI6ICdXZXN0ZXJuIERpZ2l0YWwnIH0sXG4gICAgICB7IHBhdHRlcm46ICdUT1NISUJBLionLCBtYW51ZmFjdHVyZXI6ICdUb3NoaWJhJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnSElUQUNISS4qJywgbWFudWZhY3R1cmVyOiAnSGl0YWNoaScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15JQy4qJywgbWFudWZhY3R1cmVyOiAnSGl0YWNoaScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15IVFMuKicsIG1hbnVmYWN0dXJlcjogJ0hpdGFjaGknIH0sXG4gICAgICB7IHBhdHRlcm46ICdTQU5ESVNLLionLCBtYW51ZmFjdHVyZXI6ICdTYW5EaXNrJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnS0lOR1NUT04uKicsIG1hbnVmYWN0dXJlcjogJ0tpbmdzdG9uIFRlY2hub2xvZ3knIH0sXG4gICAgICB7IHBhdHRlcm46ICdeU09OWS4qJywgbWFudWZhY3R1cmVyOiAnU29ueScgfSxcbiAgICAgIHsgcGF0dGVybjogJ1RSQU5TQ0VORC4qJywgbWFudWZhY3R1cmVyOiAnVHJhbnNjZW5kJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnU0FNU1VORy4qJywgbWFudWZhY3R1cmVyOiAnU2Ftc3VuZycgfSxcbiAgICAgIHsgcGF0dGVybjogJ15TVCg/IUlcXFxcICkuKicsIG1hbnVmYWN0dXJlcjogJ1NlYWdhdGUnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeU1RJXFxcXCAuKicsIG1hbnVmYWN0dXJlcjogJ1NpbXBsZVRlY2gnIH0sXG4gICAgICB7IHBhdHRlcm46ICdeRC4uLi0uKicsIG1hbnVmYWN0dXJlcjogJ0lCTScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15JQk0uKicsIG1hbnVmYWN0dXJlcjogJ0lCTScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15GVUpJVFNVLionLCBtYW51ZmFjdHVyZXI6ICdGdWppdHN1JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXk1QLionLCBtYW51ZmFjdHVyZXI6ICdGdWppdHN1JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnXk1LLionLCBtYW51ZmFjdHVyZXI6ICdUb3NoaWJhJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnTUFYVE8uKicsIG1hbnVmYWN0dXJlcjogJ01heHRvcicgfSxcbiAgICAgIHsgcGF0dGVybjogJ1BJT05FRVIuKicsIG1hbnVmYWN0dXJlcjogJ1Bpb25lZXInIH0sXG4gICAgICB7IHBhdHRlcm46ICdQSElMSVBTLionLCBtYW51ZmFjdHVyZXI6ICdQaGlsaXBzJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnUVVBTlRVTS4qJywgbWFudWZhY3R1cmVyOiAnUXVhbnR1bSBUZWNobm9sb2d5JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnRklSRUJBTEwuKicsIG1hbnVmYWN0dXJlcjogJ1F1YW50dW0gVGVjaG5vbG9neScgfSxcbiAgICAgIHsgcGF0dGVybjogJ15WQk9YLionLCBtYW51ZmFjdHVyZXI6ICdWaXJ0dWFsQm94JyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnQ09SU0FJUi4qJywgbWFudWZhY3R1cmVyOiAnQ29yc2FpciBDb21wb25lbnRzJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnQ1JVQ0lBTC4qJywgbWFudWZhY3R1cmVyOiAnQ3J1Y2lhbCcgfSxcbiAgICAgIHsgcGF0dGVybjogJ0VDTS4qJywgbWFudWZhY3R1cmVyOiAnRUNNJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnSU5URUwuKicsIG1hbnVmYWN0dXJlcjogJ0lOVEVMJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnRVZPLionLCBtYW51ZmFjdHVyZXI6ICdTYW1zdW5nJyB9LFxuICAgICAgeyBwYXR0ZXJuOiAnQVBQTEUuKicsIG1hbnVmYWN0dXJlcjogJ0FwcGxlJyB9LFxuICAgIF07XG5cbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBtb2RlbCA9IG1vZGVsLnRvVXBwZXJDYXNlKCk7XG4gICAgICBkaXNrTWFudWZhY3R1cmVycy5mb3JFYWNoKChtYW51ZmFjdHVyZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmUgPSBSZWdFeHAobWFudWZhY3R1cmVyLnBhdHRlcm4pO1xuICAgICAgICBpZiAocmUudGVzdChtb2RlbCkpIHsgcmVzdWx0ID0gbWFudWZhY3R1cmVyLm1hbnVmYWN0dXJlcjsgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgY29uc3QgY29tbWl0UmVzdWx0ID0gcmVzID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZWxldGUgcmVzW2ldLkJTRE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBsZXQgY21kID0gJyc7XG5cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgbGV0IGNtZEZ1bGxTbWFydCA9ICcnO1xuXG4gICAgICAgIGV4ZWMoJ2V4cG9ydCBMQ19BTEw9QzsgbHNibGsgLWFibEpPIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvdXQgPSBzdGRvdXQudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0SlNPTiA9IEpTT04ucGFyc2Uob3V0KTtcbiAgICAgICAgICAgICAgICBpZiAob3V0SlNPTiAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dEpTT04sICdibG9ja2RldmljZXMnKSkge1xuICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IG91dEpTT04uYmxvY2tkZXZpY2VzLmZpbHRlcihpdGVtID0+IHsgcmV0dXJuIChpdGVtLnR5cGUgPT09ICdkaXNrJykgJiYgaXRlbS5zaXplID4gMCAmJiAoaXRlbS5tb2RlbCAhPT0gbnVsbCB8fCAoaXRlbS5tb3VudHBvaW50ID09PSBudWxsICYmIGl0ZW0ubGFiZWwgPT09IG51bGwgJiYgaXRlbS5mc3R5cGUgPT09IG51bGwgJiYgaXRlbS5wYXJ0dHlwZSA9PT0gbnVsbCAmJiBpdGVtLnBhdGggJiYgaXRlbS5wYXRoLmluZGV4T2YoJy9yYW0nKSAhPT0gMCAmJiBpdGVtLnBhdGguaW5kZXhPZignL2xvb3AnKSAhPT0gMCAmJiBpdGVtWydkaXNjLW1heCddICYmIGl0ZW1bJ2Rpc2MtbWF4J10gIT09IDApKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb2xkZXIgdmVyc2lvbiBvZiBsc2Jsa1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dDIgPSBleGVjU3luYygnZXhwb3J0IExDX0FMTD1DOyBsc2JsayAtYlBvIE5BTUUsVFlQRSxTSVpFLEZTVFlQRSxNT1VOVFBPSU5ULFVVSUQsUk9UQSxSTyxSTSxMQUJFTCxNT0RFTCxPV05FUixHUk9VUCAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBibGtTdGRvdXRUb09iamVjdChvdXQyKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHBhcnNlQmxrKGxpbmVzKTtcbiAgICAgICAgICAgICAgICBkZXZpY2VzID0gZGF0YS5maWx0ZXIoaXRlbSA9PiB7IHJldHVybiAoaXRlbS50eXBlID09PSAnZGlzaycpICYmIGl0ZW0uc2l6ZSA+IDAgJiYgKChpdGVtLm1vZGVsICE9PSBudWxsICYmIGl0ZW0ubW9kZWwgIT09ICcnKSB8fCAoaXRlbS5tb3VudCA9PT0gJycgJiYgaXRlbS5sYWJlbCA9PT0gJycgJiYgaXRlbS5mc1R5cGUgPT09ICcnKSk7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRldmljZXMuZm9yRWFjaCgoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lZGl1bVR5cGUgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBCU0ROYW1lID0gJy9kZXYvJyArIGRldmljZS5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2ljYWwgPSBkZXZpY2UubmFtZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbWVkaXVtVHlwZSA9IGV4ZWNTeW5jKCdjYXQgL3N5cy9ibG9jay8nICsgbG9naWNhbCArICcvcXVldWUvcm90YXRpb25hbCAyPi9kZXYvbnVsbCcpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJmYWNlVHlwZSA9IGRldmljZS50cmFuID8gZGV2aWNlLnRyYW4udG9VcHBlckNhc2UoKS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJmYWNlVHlwZSA9PT0gJ05WTUUnKSB7XG4gICAgICAgICAgICAgICAgICBtZWRpdW1UeXBlID0gJzInO1xuICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZSA9ICdQQ0llJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgZGV2aWNlOiBCU0ROYW1lLFxuICAgICAgICAgICAgICAgICAgdHlwZTogKG1lZGl1bVR5cGUgPT09ICcwJyA/ICdTU0QnIDogKG1lZGl1bVR5cGUgPT09ICcxJyA/ICdIRCcgOiAobWVkaXVtVHlwZSA9PT0gJzInID8gJ05WTWUnIDogKGRldmljZS5tb2RlbCAmJiBkZXZpY2UubW9kZWwuaW5kZXhPZignU1NEJykgPiAtMSA/ICdTU0QnIDogKGRldmljZS5tb2RlbCAmJiBkZXZpY2UubW9kZWwuaW5kZXhPZignTlZNJykgPiAtMSA/ICdOVk1lJyA6ICdIRCcpKSkpKSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGRldmljZS5tb2RlbCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgIHZlbmRvcjogZ2V0VmVuZG9yRnJvbU1vZGVsKGRldmljZS5tb2RlbCkgfHwgKGRldmljZS52ZW5kb3IgPyBkZXZpY2UudmVuZG9yLnRyaW0oKSA6ICcnKSxcbiAgICAgICAgICAgICAgICAgIHNpemU6IGRldmljZS5zaXplIHx8IDAsXG4gICAgICAgICAgICAgICAgICBieXRlc1BlclNlY3RvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsQ3lsaW5kZXJzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdG90YWxIZWFkczogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2VjdG9yczogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsVHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdHJhY2tzUGVyQ3lsaW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzZWN0b3JzUGVyVHJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICBmaXJtd2FyZVJldmlzaW9uOiBkZXZpY2UucmV2ID8gZGV2aWNlLnJldi50cmltKCkgOiAnJyxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogZGV2aWNlLnNlcmlhbCA/IGRldmljZS5zZXJpYWwudHJpbSgpIDogJycsXG4gICAgICAgICAgICAgICAgICBpbnRlcmZhY2VUeXBlOiBpbnRlcmZhY2VUeXBlLFxuICAgICAgICAgICAgICAgICAgc21hcnRTdGF0dXM6ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgIHRlbXBlcmF0dXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgQlNETmFtZTogQlNETmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNtZCArPSBgcHJpbnRmIFwiXFxuJHtCU0ROYW1lfXxcIjsgc21hcnRjdGwgLUggJHtCU0ROYW1lfSB8IGdyZXAgb3ZlcmFsbDtgO1xuICAgICAgICAgICAgICAgIGNtZEZ1bGxTbWFydCArPSBgJHtjbWRGdWxsU21hcnQgPyAncHJpbnRmIFwiLFwiOycgOiAnJ31zbWFydGN0bCAtYSAtaiAke0JTRE5hbWV9O2A7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgUy5NLkEuUi5ULiBzdGF0dXNcbiAgICAgICAgICBpZiAoY21kRnVsbFNtYXJ0KSB7XG4gICAgICAgICAgICBleGVjKGNtZEZ1bGxTbWFydCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoYFske3N0ZG91dH1dYCk7XG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGRpc2sgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGlza0JTRE5hbWUgPSBkaXNrLnNtYXJ0Y3RsLmFyZ3ZbZGlzay5zbWFydGN0bC5hcmd2Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W2ldLkJTRE5hbWUgPT09IGRpc2tCU0ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0U3RhdHVzID0gKGRpc2suc21hcnRfc3RhdHVzLnBhc3NlZCA/ICdPaycgOiAoZGlzay5zbWFydF9zdGF0dXMucGFzc2VkID09PSBmYWxzZSA/ICdQcmVkaWN0ZWQgRmFpbHVyZScgOiAndW5rbm93bicpKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzay50ZW1wZXJhdHVyZSAmJiBkaXNrLnRlbXBlcmF0dXJlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS50ZW1wZXJhdHVyZSA9IGRpc2sudGVtcGVyYXR1cmUuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0RGF0YSA9IGRpc2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21taXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgIGNtZCA9IGNtZCArICdwcmludGYgXCJcXG5cIic7XG4gICAgICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQlNETmFtZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzMiA9IHBhcnRzWzFdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0czIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMyWzFdID0gcGFydHMyWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzID0gcGFydHMyWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0uQlNETmFtZSA9PT0gQlNETmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnRTdGF0dXMgPSAoc3RhdHVzID09PSAncGFzc2VkJyA/ICdPaycgOiAoc3RhdHVzID09PSAnZmFpbGVkIScgPyAnUHJlZGljdGVkIEZhaWx1cmUnIDogJ3Vua25vd24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWl0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29tbWl0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbWl0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnc3lzdGVtX3Byb2ZpbGVyIFNQU2VyaWFsQVRBRGF0YVR5cGUgU1BOVk1lRGF0YVR5cGUgU1BVU0JEYXRhVHlwZScsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IGJ5IHR5cGU6XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgbGluZXNTQVRBID0gW107XG4gICAgICAgICAgICBsZXQgbGluZXNOVk1lID0gW107XG4gICAgICAgICAgICBsZXQgbGluZXNVU0IgPSBbXTtcbiAgICAgICAgICAgIGxldCBkYXRhVHlwZSA9ICdTQVRBJztcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChsaW5lID09PSAnTlZNRXhwcmVzczonKSB7IGRhdGFUeXBlID0gJ05WTWUnOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPT09ICdVU0I6JykgeyBkYXRhVHlwZSA9ICdVU0InOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPT09ICdTQVRBL1NBVEEgRXhwcmVzczonKSB7IGRhdGFUeXBlID0gJ1NBVEEnOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09PSAnU0FUQScpIHsgbGluZXNTQVRBLnB1c2gobGluZSk7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09ICdOVk1lJykgeyBsaW5lc05WTWUucHVzaChsaW5lKTsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PT0gJ1VTQicpIHsgbGluZXNVU0IucHVzaChsaW5lKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBTZXJpYWwgQVRBIERyaXZlc1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGxpbmVzU0FUQS5qb2luKCdcXG4nKS5zcGxpdCgnIFBoeXNpY2FsIEludGVyY29ubmVjdDogJyk7XG4gICAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2UgPSAnSW50ZXJmYWNlVHlwZTogJyArIGRldmljZTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lZGl1bVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWVkaXVtIFR5cGUnLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplU3RyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcGFjaXR5JywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlNETmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU0QgTmFtZScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplU3RyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc2l6ZVZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmIChzaXplU3RyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIubWF0Y2goL1xcKChbXildKylcXCkvKVsxXS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoLywvZywgJycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0cik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNtYXJ0U3RhdHVzU3RyaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1MuTS5BLlIuVC4gc3RhdHVzJywgJzonLCB0cnVlKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGRldmljZTogQlNETmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZWRpdW1UeXBlLnN0YXJ0c1dpdGgoJ1NvbGlkJykgPyAnU1NEJyA6ICdIRCcsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCkpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYW51ZmFjdHVyZXInLCAnOicsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBieXRlc1BlclNlY3RvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEN5bGluZGVyczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEhlYWRzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2VjdG9yczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRyYWNrczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja3NQZXJDeWxpbmRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBzZWN0b3JzUGVyVHJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgZmlybXdhcmVSZXZpc2lvbjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JldmlzaW9uJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsIE51bWJlcicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJbnRlcmZhY2VUeXBlJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgc21hcnRTdGF0dXM6IHNtYXJ0U3RhdHVzU3RyaW5nID09PSAndmVyaWZpZWQnID8gJ09LJyA6IHNtYXJ0U3RhdHVzU3RyaW5nIHx8ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBCU0ROYW1lOiBCU0ROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjbWQgPSBjbWQgKyAncHJpbnRmIFwiXFxuJyArIEJTRE5hbWUgKyAnfFwiOyBkaXNrdXRpbCBpbmZvIC9kZXYvJyArIEJTRE5hbWUgKyAnIHwgZ3JlcCBTTUFSVDsnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOVk1FIERyaXZlc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBsaW5lc05WTWUuam9pbignXFxuJykuc3BsaXQoJ1xcblxcbiAgICAgICAgICBDYXBhY2l0eTonKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGRldmljZSA9ICchQ2FwYWNpdHk6ICcgKyBkZXZpY2U7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rV2lkdGggPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbGluayB3aWR0aCcsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVTdHIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnIWNhcGFjaXR5JywgJzonLCB0cnVlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlNETmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU0QgTmFtZScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplU3RyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgc2l6ZVZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmIChzaXplU3RyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIubWF0Y2goL1xcKChbXildKylcXCkvKVsxXS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoLywvZywgJycpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFzaXplVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVZhbHVlID0gcGFyc2VJbnQoc2l6ZVN0cik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNtYXJ0U3RhdHVzU3RyaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1MuTS5BLlIuVC4gc3RhdHVzJywgJzonLCB0cnVlKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIGRldmljZTogQlNETmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTlZNZScsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCkpLFxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemVWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBieXRlc1BlclNlY3RvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEN5bGluZGVyczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbEhlYWRzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2VjdG9yczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRyYWNrczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFja3NQZXJDeWxpbmRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBzZWN0b3JzUGVyVHJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgZmlybXdhcmVSZXZpc2lvbjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JldmlzaW9uJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsIE51bWJlcicsICc6JywgdHJ1ZSkudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGludGVyZmFjZVR5cGU6ICgnUENJZSAnICsgbGlua1dpZHRoKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgc21hcnRTdGF0dXM6IHNtYXJ0U3RhdHVzU3RyaW5nID09PSAndmVyaWZpZWQnID8gJ09LJyA6IHNtYXJ0U3RhdHVzU3RyaW5nIHx8ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBCU0ROYW1lOiBCU0ROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjbWQgPSBjbWQgKyAncHJpbnRmIFwiXFxuJyArIEJTRE5hbWUgKyAnfFwiOyBkaXNrdXRpbCBpbmZvIC9kZXYvJyArIEJTRE5hbWUgKyAnIHwgZ3JlcCBTTUFSVDsnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVVNCIERyaXZlc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IGRldmljZXMgPSBsaW5lc1VTQi5qb2luKCdcXG4nKS5yZXBsYWNlQWxsKCdNZWRpYTpcXG4gJywgJ01vZGVsOicpLnNwbGl0KCdcXG5cXG4gICAgICAgICAgUHJvZHVjdCBJRDonKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRldmljZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVN0ciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXBhY2l0eScsICc6JywgdHJ1ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJTRE5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNEIE5hbWUnLCAnOicsIHRydWUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0cikge1xuICAgICAgICAgICAgICAgICAgbGV0IHNpemVWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAoc2l6ZVN0ci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplVmFsdWUgPSBwYXJzZUludChzaXplU3RyLm1hdGNoKC9cXCgoW14pXSspXFwpLylbMV0ucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKC8sL2csICcnKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghc2l6ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemVWYWx1ZSA9IHBhcnNlSW50KHNpemVTdHIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHNpemVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbWFydFN0YXR1c1N0cmluZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTLk0uQS5SLlQuIHN0YXR1cycsICc6JywgdHJ1ZSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXZpY2U6IEJTRE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1VTQicsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01vZGVsJywgJzonLCB0cnVlKS50cmltKCkucmVwbGFjZUFsbCgnOicsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICB2ZW5kb3I6IGdldFZlbmRvckZyb21Nb2RlbCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicsIHRydWUpLnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2VjdG9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ3lsaW5kZXJzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsSGVhZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgdG90YWxTZWN0b3JzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVHJhY2tzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1BlckN5bGluZGVyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHNlY3RvcnNQZXJUcmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBmaXJtd2FyZVJldmlzaW9uOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmV2aXNpb24nLCAnOicsIHRydWUpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxOdW06IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWwgTnVtYmVyJywgJzonLCB0cnVlKS50cmltKCksXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZTogJ1VTQicsXG4gICAgICAgICAgICAgICAgICAgICAgc21hcnRTdGF0dXM6IHNtYXJ0U3RhdHVzU3RyaW5nID09PSAndmVyaWZpZWQnID8gJ09LJyA6IHNtYXJ0U3RhdHVzU3RyaW5nIHx8ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBCU0ROYW1lOiBCU0ROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjbWQgPSBjbWQgKyAncHJpbnRmIFwiXFxuJyArIEJTRE5hbWUgKyAnfFwiOyBkaXNrdXRpbCBpbmZvIC9kZXYvJyArIEJTRE5hbWUgKyAnIHwgZ3JlcCBTTUFSVDsnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtZCkge1xuICAgICAgICAgICAgICBjbWQgPSBjbWQgKyAncHJpbnRmIFwiXFxuXCInO1xuICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAxMDI0IH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgQlNETmFtZSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzFdID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0czIgPSBwYXJ0c1sxXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0czIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czJbMV0gPSBwYXJ0czJbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHBhcnRzMlsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5CU0ROYW1lID09PSBCU0ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnNtYXJ0U3RhdHVzID0gKHN0YXR1cyA9PT0gJ25vdCBzdXBwb3J0ZWQnID8gJ25vdCBzdXBwb3J0ZWQnIDogKHN0YXR1cyA9PT0gJ3ZlcmlmaWVkJyA/ICdPaycgOiAoc3RhdHVzID09PSAnZmFpbGluZycgPyAnUHJlZGljdGVkIEZhaWx1cmUnIDogJ3Vua25vd24nKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbaV0uQlNETmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2ldLkJTRE5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9EaXNrRHJpdmUgfCBzZWxlY3QgQ2FwdGlvbixTaXplLFN0YXR1cyxQTlBEZXZpY2VJZCxEZXZpY2VJZCxCeXRlc1BlclNlY3RvcixUb3RhbEN5bGluZGVycyxUb3RhbEhlYWRzLFRvdGFsU2VjdG9ycyxUb3RhbFRyYWNrcyxUcmFja3NQZXJDeWxpbmRlcixTZWN0b3JzUGVyVHJhY2ssRmlybXdhcmVSZXZpc2lvbixTZXJpYWxOdW1iZXIsSW50ZXJmYWNlVHlwZSB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtUGh5c2ljYWxEaXNrIHwgc2VsZWN0IEJ1c1R5cGUsTWVkaWFUeXBlLEZyaWVuZGx5TmFtZSxNb2RlbCxTZXJpYWxOdW1iZXIsU2l6ZSB8IGZsJykpO1xuICAgICAgICAgIGlmICh1dGlsLnNtYXJ0TW9uVG9vbHNJbnN0YWxsZWQoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgc21hcnREZXYgPSBKU09OLnBhcnNlKGV4ZWNTeW5jKCdzbWFydGN0bCAtLXNjYW4gLWonKSk7XG4gICAgICAgICAgICAgIGlmIChzbWFydERldiAmJiBzbWFydERldi5kZXZpY2VzICYmIHNtYXJ0RGV2LmRldmljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNtYXJ0RGV2LmRldmljZXMuZm9yRWFjaCgoZGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgICB3b3JrbG9hZC5wdXNoKGV4ZWNQcm9taXNlU2F2ZShgc21hcnRjdGwgLWogLWEgJHtkZXYubmFtZX1gLCB1dGlsLmV4ZWNPcHRzV2luKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGRhdGEucmVzdWx0c1swXS50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICBjb25zdCBzaXplID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NpemUnLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXR1cycsICc6JykudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgZGV2aWNlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGV2aWNlSWQnLCAnOicpLCAgLy8gY2hhbmdlZCBmcm9tIFBOUERldmljZUlkIHRvIERldmljZUlEIChiZSBiZSBhYmxlIHRvIG1hdGNoIGRldmljZXMpXG4gICAgICAgICAgICAgICAgICB0eXBlOiBkZXZpY2UuaW5kZXhPZignU1NEJykgPiAtMSA/ICdTU0QnIDogJ0hEJywgIC8vIGp1c3QgYSBzdGFydGluZyBwb2ludCAuLi4gYmV0dGVyOiBNU0ZUX1BoeXNpY2FsRGlzayAtIE1lZGlhIFR5cGUgLi4uIHNlZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicpLFxuICAgICAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicsIHRydWUpLnRyaW0oKSksXG4gICAgICAgICAgICAgICAgICBzaXplOiBwYXJzZUludChzaXplKSxcbiAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2VjdG9yOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnl0ZXNQZXJTZWN0b3InLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsQ3lsaW5kZXJzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWxDeWxpbmRlcnMnLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsSGVhZHM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbEhlYWRzJywgJzonKSksXG4gICAgICAgICAgICAgICAgICB0b3RhbFNlY3RvcnM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbFNlY3RvcnMnLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsVHJhY2tzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWxUcmFja3MnLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHRyYWNrc1BlckN5bGluZGVyOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHJhY2tzUGVyQ3lsaW5kZXInLCAnOicpKSxcbiAgICAgICAgICAgICAgICAgIHNlY3RvcnNQZXJUcmFjazogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlY3RvcnNQZXJUcmFjaycsICc6JykpLFxuICAgICAgICAgICAgICAgICAgZmlybXdhcmVSZXZpc2lvbjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Zpcm13YXJlUmV2aXNpb24nLCAnOicpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbE51bWJlcicsICc6JykudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlVHlwZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0ludGVyZmFjZVR5cGUnLCAnOicpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgIHNtYXJ0U3RhdHVzOiAoc3RhdHVzID09PSAnb2snID8gJ09rJyA6IChzdGF0dXMgPT09ICdkZWdyYWRlZCcgPyAnRGVncmFkZWQnIDogKHN0YXR1cyA9PT0gJ3ByZWQgZmFpbCcgPyAnUHJlZGljdGVkIEZhaWx1cmUnIDogJ1Vua25vd24nKSkpLFxuICAgICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRhdGEucmVzdWx0c1sxXS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsTnVtID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbE51bWJlcicsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0ZyaWVuZGx5TmFtZScsICc6JykudHJpbSgpLnJlcGxhY2UoJ01zZnQgJywgJ01pY3Jvc29mdCcpO1xuICAgICAgICAgICAgICBjb25zdCBzaXplID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NpemUnLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTW9kZWwnLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJmYWNlVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCdXNUeXBlJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGxldCBtZWRpYVR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWVkaWFUeXBlJywgJzonKS50cmltKCk7XG4gICAgICAgICAgICAgIGlmIChtZWRpYVR5cGUgPT09ICczJyB8fCBtZWRpYVR5cGUgPT09ICdIREQnKSB7IG1lZGlhVHlwZSA9ICdIRCc7IH1cbiAgICAgICAgICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gJzQnKSB7IG1lZGlhVHlwZSA9ICdTU0QnOyB9XG4gICAgICAgICAgICAgIGlmIChtZWRpYVR5cGUgPT09ICc1JykgeyBtZWRpYVR5cGUgPSAnU0NNJzsgfVxuICAgICAgICAgICAgICBpZiAobWVkaWFUeXBlID09PSAnVW5zcGVjaWZpZWQnICYmIChtb2RlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3ZpcnR1YWwnKSA+IC0xIHx8IG1vZGVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndmJveCcpID4gLTEpKSB7IG1lZGlhVHlwZSA9ICdWaXJ0dWFsJzsgfVxuICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdXRpbC5maW5kT2JqZWN0QnlLZXkocmVzdWx0LCAnc2VyaWFsTnVtJywgc2VyaWFsTnVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEgfHwgc2VyaWFsTnVtID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgaSA9IHV0aWwuZmluZE9iamVjdEJ5S2V5KHJlc3VsdCwgJ25hbWUnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS50eXBlID0gbWVkaWFUeXBlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLmludGVyZmFjZVR5cGUgPSBpbnRlcmZhY2VUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTLk0uQS5SLlRcbiAgICAgICAgICAgIGRhdGEucmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICAgICAgZGF0YS5yZXN1bHRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkYXRhLnJlc3VsdHMuZm9yRWFjaCgoc21hcnRTdHIpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc21hcnREYXRhID0gSlNPTi5wYXJzZShzbWFydFN0cik7XG4gICAgICAgICAgICAgICAgICBpZiAoc21hcnREYXRhLnNlcmlhbF9udW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsTnVtID0gc21hcnREYXRhLnNlcmlhbF9udW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gdXRpbC5maW5kT2JqZWN0QnlLZXkocmVzdWx0LCAnc2VyaWFsTnVtJywgc2VyaWFsTnVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0uc21hcnRTdGF0dXMgPSAoc21hcnREYXRhLnNtYXJ0X3N0YXR1cyAmJiBzbWFydERhdGEuc21hcnRfc3RhdHVzLnBhc3NlZCA/ICdPaycgOiAoc21hcnREYXRhLnNtYXJ0X3N0YXR1cyAmJiBzbWFydERhdGEuc21hcnRfc3RhdHVzLnBhc3NlZCA9PT0gZmFsc2UgPyAnUHJlZGljdGVkIEZhaWx1cmUnIDogJ3Vua25vd24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNtYXJ0RGF0YS50ZW1wZXJhdHVyZSAmJiBzbWFydERhdGEudGVtcGVyYXR1cmUuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldLnRlbXBlcmF0dXJlID0gc21hcnREYXRhLnRlbXBlcmF0dXJlLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS5zbWFydERhdGEgPSBzbWFydERhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kaXNrTGF5b3V0ID0gZGlza0xheW91dDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gZ3JhcGhpY3MuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA3LiBHcmFwaGljcyAoY29udHJvbGxlciwgZGlzcGxheSlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xubGV0IF9udmlkaWFTbWlQYXRoID0gJyc7XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmxldCBfcmVzb2x1dGlvblggPSAwO1xubGV0IF9yZXNvbHV0aW9uWSA9IDA7XG5sZXQgX3BpeGVsRGVwdGggPSAwO1xubGV0IF9yZWZyZXNoUmF0ZSA9IDA7XG5cbmNvbnN0IHZpZGVvVHlwZXMgPSB7XG4gICctMic6ICdVTklOSVRJQUxJWkVEJyxcbiAgJy0xJzogJ09USEVSJyxcbiAgJzAnOiAnSEQxNScsXG4gICcxJzogJ1NWSURFTycsXG4gICcyJzogJ0NvbXBvc2l0ZSB2aWRlbycsXG4gICczJzogJ0NvbXBvbmVudCB2aWRlbycsXG4gICc0JzogJ0RWSScsXG4gICc1JzogJ0hETUknLFxuICAnNic6ICdMVkRTJyxcbiAgJzgnOiAnRF9KUE4nLFxuICAnOSc6ICdTREknLFxuICAnMTAnOiAnRFAnLFxuICAnMTEnOiAnRFAgZW1iZWRkZWQnLFxuICAnMTInOiAnVURJJyxcbiAgJzEzJzogJ1VESSBlbWJlZGRlZCcsXG4gICcxNCc6ICdTRFRWRE9OR0xFJyxcbiAgJzE1JzogJ01JUkFDQVNUJyxcbiAgJzIxNDc0ODM2NDgnOiAnSU5URVJOQUwnXG59O1xuXG5mdW5jdGlvbiBnZXRWZW5kb3JGcm9tTW9kZWwobW9kZWwpIHtcbiAgY29uc3QgbWFudWZhY3R1cmVycyA9IFtcbiAgICB7IHBhdHRlcm46ICdeTEcuKycsIG1hbnVmYWN0dXJlcjogJ0xHJyB9LFxuICAgIHsgcGF0dGVybjogJ15CRU5RLisnLCBtYW51ZmFjdHVyZXI6ICdCZW5RJyB9LFxuICAgIHsgcGF0dGVybjogJ15BU1VTLisnLCBtYW51ZmFjdHVyZXI6ICdBc3VzJyB9LFxuICAgIHsgcGF0dGVybjogJ15ERUxMLisnLCBtYW51ZmFjdHVyZXI6ICdEZWxsJyB9LFxuICAgIHsgcGF0dGVybjogJ15TQU1TVU5HLisnLCBtYW51ZmFjdHVyZXI6ICdTYW1zdW5nJyB9LFxuICAgIHsgcGF0dGVybjogJ15WSUVXU09OLisnLCBtYW51ZmFjdHVyZXI6ICdWaWV3U29uaWMnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXlNPTlkuKycsIG1hbnVmYWN0dXJlcjogJ1NvbnknIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkFDRVIuKycsIG1hbnVmYWN0dXJlcjogJ0FjZXInIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkFPQy4rJywgbWFudWZhY3R1cmVyOiAnQU9DIE1vbml0b3JzJyB9LFxuICAgIHsgcGF0dGVybjogJ15IUC4rJywgbWFudWZhY3R1cmVyOiAnSFAnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXkVJWk8uPycsIG1hbnVmYWN0dXJlcjogJ0Vpem8nIH0sXG4gICAgeyBwYXR0ZXJuOiAnXlBISUxJUFMuPycsIG1hbnVmYWN0dXJlcjogJ1BoaWxpcHMnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXklJWUFNQS4/JywgbWFudWZhY3R1cmVyOiAnSWl5YW1hJyB9LFxuICAgIHsgcGF0dGVybjogJ15TSEFSUC4/JywgbWFudWZhY3R1cmVyOiAnU2hhcnAnIH0sXG4gICAgeyBwYXR0ZXJuOiAnXk5FQy4/JywgbWFudWZhY3R1cmVyOiAnTkVDJyB9LFxuICAgIHsgcGF0dGVybjogJ15MRU5PVk8uPycsIG1hbnVmYWN0dXJlcjogJ0xlbm92bycgfSxcbiAgICB7IHBhdHRlcm46ICdDT01QQVEuPycsIG1hbnVmYWN0dXJlcjogJ0NvbXBhcScgfSxcbiAgICB7IHBhdHRlcm46ICdBUFBMRS4/JywgbWFudWZhY3R1cmVyOiAnQXBwbGUnIH0sXG4gICAgeyBwYXR0ZXJuOiAnSU5URUwuPycsIG1hbnVmYWN0dXJlcjogJ0ludGVsJyB9LFxuICAgIHsgcGF0dGVybjogJ0FNRC4/JywgbWFudWZhY3R1cmVyOiAnQU1EJyB9LFxuICAgIHsgcGF0dGVybjogJ05WSURJQS4/JywgbWFudWZhY3R1cmVyOiAnTlZESUEnIH0sXG4gIF07XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAobW9kZWwpIHtcbiAgICBtb2RlbCA9IG1vZGVsLnRvVXBwZXJDYXNlKCk7XG4gICAgbWFudWZhY3R1cmVycy5mb3JFYWNoKChtYW51ZmFjdHVyZXIpID0+IHtcbiAgICAgIGNvbnN0IHJlID0gUmVnRXhwKG1hbnVmYWN0dXJlci5wYXR0ZXJuKTtcbiAgICAgIGlmIChyZS50ZXN0KG1vZGVsKSkgeyByZXN1bHQgPSBtYW51ZmFjdHVyZXIubWFudWZhY3R1cmVyOyB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0VmVuZG9yRnJvbUlkKGlkKSB7XG4gIGNvbnN0IHZlbmRvcnMgPSB7XG4gICAgJzYxMCc6ICdBcHBsZScsXG4gICAgJzFlNmQnOiAnTEcnLFxuICAgICcxMGFjJzogJ0RFTEwnLFxuICAgICc0ZGQ5JzogJ1NvbnknLFxuICAgICczOGEzJzogJ05FQycsXG4gIH07XG4gIHJldHVybiB2ZW5kb3JzW2lkXSB8fCAnJztcbn1cblxuZnVuY3Rpb24gdmVuZG9yVG9JZChzdHIpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBzdHIgPSAoc3RyIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoc3RyLmluZGV4T2YoJ2FwcGxlJykgPj0gMCkgeyByZXN1bHQgPSAnMHgwNWFjJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignbnZpZGlhJykgPj0gMCkgeyByZXN1bHQgPSAnMHgxMGRlJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignaW50ZWwnKSA+PSAwKSB7IHJlc3VsdCA9ICcweDgwODYnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdhdGknKSA+PSAwIHx8IHN0ci5pbmRleE9mKCdhbWQnKSA+PSAwKSB7IHJlc3VsdCA9ICcweDEwMDInOyB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0TWV0YWxWZXJzaW9uKGlkKSB7XG4gIGNvbnN0IGZhbWlsaWVzID0ge1xuICAgICdzcGRpc3BsYXlzX210bGdwdWZhbWlseW1hYzEnOiAnbWFjMScsXG4gICAgJ3NwZGlzcGxheXNfbXRsZ3B1ZmFtaWx5bWFjMic6ICdtYWMyJyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTEnOiAnYXBwbGUxJyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTInOiAnYXBwbGUyJyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTMnOiAnYXBwbGUzJyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTQnOiAnYXBwbGU0JyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTUnOiAnYXBwbGU1JyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTYnOiAnYXBwbGU2JyxcbiAgICAnc3BkaXNwbGF5c19tdGxncHVmYW1pbHlhcHBsZTcnOiAnYXBwbGU3JyxcbiAgICAnc3BkaXNwbGF5c19tZXRhbGZlYXR1cmVzZXRmYW1pbHkxMSc6ICdmYW1pbHkxX3YxJyxcbiAgICAnc3BkaXNwbGF5c19tZXRhbGZlYXR1cmVzZXRmYW1pbHkxMic6ICdmYW1pbHkxX3YyJyxcbiAgICAnc3BkaXNwbGF5c19tZXRhbGZlYXR1cmVzZXRmYW1pbHkxMyc6ICdmYW1pbHkxX3YzJyxcbiAgICAnc3BkaXNwbGF5c19tZXRhbGZlYXR1cmVzZXRmYW1pbHkxNCc6ICdmYW1pbHkxX3Y0JyxcbiAgICAnc3BkaXNwbGF5c19tZXRhbGZlYXR1cmVzZXRmYW1pbHkyMSc6ICdmYW1pbHkyX3YxJ1xuICB9O1xuICByZXR1cm4gZmFtaWxpZXNbaWRdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBncmFwaGljcyhjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNEYXJ3aW4oZ3JhcGhpY3NBcnIpIHtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBjb250cm9sbGVyczogW10sXG4gICAgICBkaXNwbGF5czogW11cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBncmFwaGljc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIC8vIGNvbnRyb2xsZXJzXG4gICAgICAgIGNvbnN0IGJ1cyA9ICgoaXRlbS5zcHBjaV9idXMgfHwgJycpLmluZGV4T2YoJ2J1aWx0aW4nKSA+IC0xID8gJ0J1aWx0LUluJyA6ICgoaXRlbS5zcHBjaV9idXMgfHwgJycpLmluZGV4T2YoJ3BjaWUnKSA+IC0xID8gJ1BDSWUnIDogJycpKTtcbiAgICAgICAgY29uc3QgdnJhbSA9IChwYXJzZUludCgoaXRlbS5zcGRpc3BsYXlzX3ZyYW0gfHwgJycpLCAxMCkgfHwgMCkgKiAoKChpdGVtLnNwZGlzcGxheXNfdnJhbSB8fCAnJykuaW5kZXhPZignR0InKSA+IC0xKSA/IDEwMjQgOiAxKTtcbiAgICAgICAgY29uc3QgdnJhbUR5biA9IChwYXJzZUludCgoaXRlbS5zcGRpc3BsYXlzX3ZyYW1fc2hhcmVkIHx8ICcnKSwgMTApIHx8IDApICogKCgoaXRlbS5zcGRpc3BsYXlzX3ZyYW1fc2hhcmVkIHx8ICcnKS5pbmRleE9mKCdHQicpID4gLTEpID8gMTAyNCA6IDEpO1xuICAgICAgICBsZXQgbWV0YWxWZXJzaW9uID0gZ2V0TWV0YWxWZXJzaW9uKGl0ZW0uc3BkaXNwbGF5c19tZXRhbCB8fCBpdGVtLnNwZGlzcGxheXNfbWV0YWxmYW1pbHkgfHwgJycpO1xuICAgICAgICByZXMuY29udHJvbGxlcnMucHVzaCh7XG4gICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tTW9kZWwoaXRlbS5zcGRpc3BsYXlzX3ZlbmRvciB8fCAnJykgfHwgaXRlbS5zcGRpc3BsYXlzX3ZlbmRvciB8fCAnJyxcbiAgICAgICAgICBtb2RlbDogaXRlbS5zcHBjaV9tb2RlbCB8fCAnJyxcbiAgICAgICAgICBidXMsXG4gICAgICAgICAgdnJhbUR5bmFtaWM6IGJ1cyA9PT0gJ0J1aWx0LUluJyxcbiAgICAgICAgICB2cmFtOiB2cmFtIHx8IHZyYW1EeW4gfHwgbnVsbCxcbiAgICAgICAgICBkZXZpY2VJZDogaXRlbVsnc3BkaXNwbGF5c19kZXZpY2UtaWQnXSB8fCAnJyxcbiAgICAgICAgICB2ZW5kb3JJZDogaXRlbVsnc3BkaXNwbGF5c192ZW5kb3ItaWQnXSB8fCB2ZW5kb3JUb0lkKChpdGVtWydzcGRpc3BsYXlzX3ZlbmRvciddIHx8ICcnKSArIChpdGVtLnNwcGNpX21vZGVsIHx8ICcnKSksXG4gICAgICAgICAgZXh0ZXJuYWw6IChpdGVtLnNwcGNpX2RldmljZV90eXBlID09PSAnc3BkaXNwbGF5c19lZ3B1JyksXG4gICAgICAgICAgY29yZXM6IGl0ZW1bJ3NwcGNpX2NvcmVzJ10gfHwgbnVsbCxcbiAgICAgICAgICBtZXRhbFZlcnNpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZGlzcGxheXNcbiAgICAgICAgaWYgKGl0ZW0uc3BkaXNwbGF5c19uZHJ2cyAmJiBpdGVtLnNwZGlzcGxheXNfbmRydnMubGVuZ3RoKSB7XG4gICAgICAgICAgaXRlbS5zcGRpc3BsYXlzX25kcnZzLmZvckVhY2goZnVuY3Rpb24gKGRpc3BsYXlJdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uVHlwZSA9IGRpc3BsYXlJdGVtWydzcGRpc3BsYXlzX2Nvbm5lY3Rpb25fdHlwZSddIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFJlc29sdXRpb25QYXJ0cyA9IChkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfcmVzb2x1dGlvbiddIHx8ICcnKS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFJlc29sdXRpb24gPSBjdXJyZW50UmVzb2x1dGlvblBhcnRzWzBdLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgICBjb25zdCBwaXhlbFBhcnRzID0gKGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19waXhlbHMnXSB8fCAnJykuc3BsaXQoJ3gnKTtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsRGVwdGhTdHJpbmcgPSBkaXNwbGF5SXRlbVsnc3BkaXNwbGF5c19kZXB0aCddIHx8ICcnO1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsID0gZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXktc2VyaWFsLW51bWJlciddIHx8IGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5LXNlcmlhbC1udW1iZXIyJ10gfHwgbnVsbDtcbiAgICAgICAgICAgIHJlcy5kaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgICAgICAgdmVuZG9yOiBnZXRWZW5kb3JGcm9tSWQoZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXktdmVuZG9yLWlkJ10gfHwgJycpIHx8IGdldFZlbmRvckZyb21Nb2RlbChkaXNwbGF5SXRlbVsnX25hbWUnXSB8fCAnJyksXG4gICAgICAgICAgICAgIHZlbmRvcklkOiBkaXNwbGF5SXRlbVsnX3NwZGlzcGxheXNfZGlzcGxheS12ZW5kb3ItaWQnXSB8fCAnJyxcbiAgICAgICAgICAgICAgbW9kZWw6IGRpc3BsYXlJdGVtWydfbmFtZSddIHx8ICcnLFxuICAgICAgICAgICAgICBwcm9kdWN0aW9uWWVhcjogZGlzcGxheUl0ZW1bJ19zcGRpc3BsYXlzX2Rpc3BsYXkteWVhciddIHx8IG51bGwsXG4gICAgICAgICAgICAgIHNlcmlhbDogc2VyaWFsICE9PSAnMCcgPyBzZXJpYWwgOiBudWxsLFxuICAgICAgICAgICAgICBkaXNwbGF5SWQ6IGRpc3BsYXlJdGVtWydfc3BkaXNwbGF5c19kaXNwbGF5SUQnXSB8fCBudWxsLFxuICAgICAgICAgICAgICBtYWluOiBkaXNwbGF5SXRlbVsnc3BkaXNwbGF5c19tYWluJ10gPyBkaXNwbGF5SXRlbVsnc3BkaXNwbGF5c19tYWluJ10gPT09ICdzcGRpc3BsYXlzX3llcycgOiBmYWxzZSxcbiAgICAgICAgICAgICAgYnVpbHRpbjogKGRpc3BsYXlJdGVtWydzcGRpc3BsYXlzX2Rpc3BsYXlfdHlwZSddIHx8ICcnKS5pbmRleE9mKCdidWlsdC1pbicpID4gLTEsXG4gICAgICAgICAgICAgIGNvbm5lY3Rpb246ICgoY29ubmVjdGlvblR5cGUuaW5kZXhPZignX2ludGVybmFsJykgPiAtMSkgPyAnSW50ZXJuYWwnIDogKChjb25uZWN0aW9uVHlwZS5pbmRleE9mKCdfZGlzcGxheXBvcnQnKSA+IC0xKSA/ICdEaXNwbGF5IFBvcnQnIDogKChjb25uZWN0aW9uVHlwZS5pbmRleE9mKCdfaGRtaScpID4gLTEpID8gJ0hETUknIDogbnVsbCkpKSxcbiAgICAgICAgICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICAgICAgICAgIHNpemVZOiBudWxsLFxuICAgICAgICAgICAgICBwaXhlbERlcHRoOiAocGl4ZWxEZXB0aFN0cmluZyA9PT0gJ0NHU1RoaXJ0eUJpdENvbG9yJyA/IDMwIDogKHBpeGVsRGVwdGhTdHJpbmcgPT09ICdDR1NUaGlydHl0d29CaXRDb2xvcicgPyAzMiA6IChwaXhlbERlcHRoU3RyaW5nID09PSAnQ0dTVHdlbnR5Zm91ckJpdENvbG9yJyA/IDI0IDogbnVsbCkpKSxcbiAgICAgICAgICAgICAgcmVzb2x1dGlvblg6IHBpeGVsUGFydHMubGVuZ3RoID4gMSA/IHBhcnNlSW50KHBpeGVsUGFydHNbMF0sIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgIHJlc29sdXRpb25ZOiBwaXhlbFBhcnRzLmxlbmd0aCA+IDEgPyBwYXJzZUludChwaXhlbFBhcnRzWzFdLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICBjdXJyZW50UmVzWDogY3VycmVudFJlc29sdXRpb24ubGVuZ3RoID4gMSA/IHBhcnNlSW50KGN1cnJlbnRSZXNvbHV0aW9uWzBdLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICBjdXJyZW50UmVzWTogY3VycmVudFJlc29sdXRpb24ubGVuZ3RoID4gMSA/IHBhcnNlSW50KGN1cnJlbnRSZXNvbHV0aW9uWzFdLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICBwb3NpdGlvblg6IDAsXG4gICAgICAgICAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgICAgICAgICAgY3VycmVudFJlZnJlc2hSYXRlOiBjdXJyZW50UmVzb2x1dGlvblBhcnRzLmxlbmd0aCA+IDEgPyBwYXJzZUludChjdXJyZW50UmVzb2x1dGlvblBhcnRzWzFdLCAxMCkgOiBudWxsLFxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc0xpbnV4Q29udHJvbGxlcnMobGluZXMpIHtcbiAgICBsZXQgY29udHJvbGxlcnMgPSBbXTtcbiAgICBsZXQgY3VycmVudENvbnRyb2xsZXIgPSB7XG4gICAgICB2ZW5kb3I6ICcnLFxuICAgICAgbW9kZWw6ICcnLFxuICAgICAgYnVzOiAnJyxcbiAgICAgIGJ1c0FkZHJlc3M6ICcnLFxuICAgICAgdnJhbTogbnVsbCxcbiAgICAgIHZyYW1EeW5hbWljOiBmYWxzZSxcbiAgICAgIHBjaUlEOiAnJ1xuICAgIH07XG4gICAgbGV0IGlzR3JhcGhpY3NDb250cm9sbGVyID0gZmFsc2U7XG4gICAgLy8gUENJIGJ1cyBJRHNcbiAgICBsZXQgcGNpSURzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIHBjaUlEcyA9IGV4ZWNTeW5jKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCA5IDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwgfCBncmVwIFwiQnVzIEFkZHJlc3M6IFwiJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBjaUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwY2lJRHNbaV0gPSBwY2lJRHNbaV0ucmVwbGFjZSgnQnVzIEFkZHJlc3M6JywgJycpLnJlcGxhY2UoJzAwMDA6JywgJycpLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHBjaUlEcyA9IHBjaUlEcy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCAhPSBudWxsICYmIGVsO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGlmICgnJyAhPT0gbGluZS50cmltKCkpIHtcbiAgICAgICAgaWYgKCcgJyAhPT0gbGluZVswXSAmJiAnXFx0JyAhPT0gbGluZVswXSkgeyAgICAgICAgLy8gZmlyc3QgbGluZSBvZiBuZXcgZW50cnlcbiAgICAgICAgICBsZXQgaXNFeHRlcm5hbCA9IChwY2lJRHMuaW5kZXhPZihsaW5lLnNwbGl0KCcgJylbMF0pID49IDApO1xuICAgICAgICAgIGxldCB2Z2Fwb3MgPSBsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIHZnYSAnKTtcbiAgICAgICAgICBsZXQgXzNkY29udHJvbGxlcnBvcyA9IGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCczZCBjb250cm9sbGVyJyk7XG4gICAgICAgICAgaWYgKHZnYXBvcyAhPT0gLTEgfHwgXzNkY29udHJvbGxlcnBvcyAhPT0gLTEpIHsgICAgICAgICAvLyBWR0FcbiAgICAgICAgICAgIGlmIChfM2Rjb250cm9sbGVycG9zICE9PSAtMSAmJiB2Z2Fwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHZnYXBvcyA9IF8zZGNvbnRyb2xsZXJwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbnRyb2xsZXIudmVuZG9yIHx8IGN1cnJlbnRDb250cm9sbGVyLm1vZGVsIHx8IGN1cnJlbnRDb250cm9sbGVyLmJ1cyB8fCBjdXJyZW50Q29udHJvbGxlci52cmFtICE9PSBudWxsIHx8IGN1cnJlbnRDb250cm9sbGVyLnZyYW1EeW5hbWljKSB7IC8vIGFscmVhZHkgYSBjb250cm9sbGVyIGZvdW5kXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJzLnB1c2goY3VycmVudENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlciA9IHtcbiAgICAgICAgICAgICAgICB2ZW5kb3I6ICcnLFxuICAgICAgICAgICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgICAgICAgICBidXM6ICcnLFxuICAgICAgICAgICAgICAgIGJ1c0FkZHJlc3M6ICcnLFxuICAgICAgICAgICAgICAgIHZyYW06IG51bGwsXG4gICAgICAgICAgICAgICAgdnJhbUR5bmFtaWM6IGZhbHNlLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwY2lJRENhbmRpZGF0ZSA9IGxpbmUuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIGlmICgvW1xcZGEtZkEtRl17Mn06W1xcZGEtZkEtRl17Mn1cXC5bXFxkYS1mQS1GXS8udGVzdChwY2lJRENhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIuYnVzQWRkcmVzcyA9IHBjaUlEQ2FuZGlkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNHcmFwaGljc0NvbnRyb2xsZXIgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGVuZHBvcyA9IGxpbmUuc2VhcmNoKC9cXFtbMC05YS1mXXs0fTpbMC05YS1mXXs0fV18JC8pO1xuICAgICAgICAgICAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHIodmdhcG9zLCBlbmRwb3MgLSB2Z2Fwb3MpLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5idXNBZGRyZXNzID0gbGluZS5zdWJzdHIoMCwgdmdhcG9zKS50cmltKCk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBwYXJ0c1sxXSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY29ycG9yYXRpb24nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudmVuZG9yID0gcGFydHNbMV0uc3Vic3RyKDAsIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY29ycG9yYXRpb24nKSArIDExKS50cmltKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIubW9kZWwgPSBwYXJ0c1sxXS5zdWJzdHIocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjb3Jwb3JhdGlvbicpICsgMTEsIDIwMCkudHJpbSgpLnNwbGl0KCcoJylbMF07XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIuYnVzID0gKHBjaUlEcy5sZW5ndGggPiAwICYmIGlzRXh0ZXJuYWwpID8gJ1BDSWUnIDogJ09uYm9hcmQnO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLnZyYW1EeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgaW5jLicpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcnRzWzFdLm1hdGNoKC9dL2cpIHx8IFtdKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgPSBwYXJ0c1sxXS5zdWJzdHIoMCwgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCddJykgKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci5tb2RlbCA9IHBhcnRzWzFdLnN1YnN0cihwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ10nKSArIDEsIDIwMCkudHJpbSgpLnNwbGl0KCcoJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgPSBwYXJ0c1sxXS5zdWJzdHIoMCwgcGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgaW5jLicpICsgNSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIubW9kZWwgPSBwYXJ0c1sxXS5zdWJzdHIocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgaW5jLicpICsgNSwgMjAwKS50cmltKCkuc3BsaXQoJygnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLmJ1cyA9IChwY2lJRHMubGVuZ3RoID4gMCAmJiBpc0V4dGVybmFsKSA/ICdQQ0llJyA6ICdPbmJvYXJkJztcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52cmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udHJvbGxlci52cmFtRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGx0ZC4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwYXJ0c1sxXS5tYXRjaCgvXS9nKSB8fCBbXSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudmVuZG9yID0gcGFydHNbMV0uc3Vic3RyKDAsIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignXScpICsgMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIubW9kZWwgPSBwYXJ0c1sxXS5zdWJzdHIocGFydHNbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCddJykgKyAxLCAyMDApLnRyaW0oKS5zcGxpdCgnKCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudmVuZG9yID0gcGFydHNbMV0uc3Vic3RyKDAsIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGx0ZC4nKSArIDUpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyLm1vZGVsID0gcGFydHNbMV0uc3Vic3RyKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGx0ZC4nKSArIDUsIDIwMCkudHJpbSgpLnNwbGl0KCcoJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzR3JhcGhpY3NDb250cm9sbGVyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0dyYXBoaWNzQ29udHJvbGxlcikgeyAvLyB3aXRoaW4gVkdBIGRldGFpbHNcbiAgICAgICAgICBsZXQgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgcGFydHNbMF0ucmVwbGFjZSgvICsvZywgJycpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGV2aWNlbmFtZScpICE9PSAtMSAmJiBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ29uYm9hcmQnKSAhPT0gLTEpIHsgY3VycmVudENvbnRyb2xsZXIuYnVzID0gJ09uYm9hcmQnOyB9XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgcGFydHNbMF0ucmVwbGFjZSgvICsvZywgJycpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncmVnaW9uJykgIT09IC0xICYmIHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbWVtb3J5JykgIT09IC0xKSB7XG4gICAgICAgICAgICBsZXQgbWVtcGFydHMgPSBwYXJ0c1sxXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKG1lbXBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXIudnJhbSA9IHBhcnNlSW50KG1lbXBhcnRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50Q29udHJvbGxlci52ZW5kb3IgfHwgY3VycmVudENvbnRyb2xsZXIubW9kZWwgfHwgY3VycmVudENvbnRyb2xsZXIuYnVzIHx8IGN1cnJlbnRDb250cm9sbGVyLmJ1c0FkZHJlc3MgfHwgY3VycmVudENvbnRyb2xsZXIudnJhbSAhPT0gbnVsbCB8fCBjdXJyZW50Q29udHJvbGxlci52cmFtRHluYW1pYykgeyAvLyBhbHJlYWR5IGEgY29udHJvbGxlciBmb3VuZFxuICAgICAgY29udHJvbGxlcnMucHVzaChjdXJyZW50Q29udHJvbGxlcik7XG4gICAgfVxuICAgIHJldHVybiAoY29udHJvbGxlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc0xpbnV4Q2xpbmZvKGNvbnRyb2xsZXJzLCBsaW5lcykge1xuICAgIGNvbnN0IGZpZWxkUGF0dGVybiA9IC9cXFsoW15cXF1dKylcXF1cXHMrKFxcdyspXFxzKyguKikvO1xuICAgIGNvbnN0IGRldmljZXMgPSBsaW5lcy5yZWR1Y2UoKGRldmljZXMsIGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRQYXR0ZXJuLmV4ZWMobGluZS50cmltKCkpO1xuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIGlmICghZGV2aWNlc1tmaWVsZFsxXV0pIHtcbiAgICAgICAgICBkZXZpY2VzW2ZpZWxkWzFdXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRldmljZXNbZmllbGRbMV1dW2ZpZWxkWzJdXSA9IGZpZWxkWzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSwge30pO1xuICAgIGZvciAobGV0IGRldmljZUlkIGluIGRldmljZXMpIHtcbiAgICAgIGNvbnN0IGRldmljZSA9IGRldmljZXNbZGV2aWNlSWRdO1xuICAgICAgaWYgKGRldmljZVsnQ0xfREVWSUNFX1RZUEUnXSA9PT0gJ0NMX0RFVklDRV9UWVBFX0dQVScpIHtcbiAgICAgICAgbGV0IGJ1c0FkZHJlc3M7XG4gICAgICAgIGlmIChkZXZpY2VbJ0NMX0RFVklDRV9UT1BPTE9HWV9BTUQnXSkge1xuICAgICAgICAgIGNvbnN0IGJkZiA9IGRldmljZVsnQ0xfREVWSUNFX1RPUE9MT0dZX0FNRCddLm1hdGNoKC9bYS16QS1aMC05XSs6XFxkK1xcLlxcZCsvKTtcbiAgICAgICAgICBpZiAoYmRmKSB7XG4gICAgICAgICAgICBidXNBZGRyZXNzID0gYmRmWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXZpY2VbJ0NMX0RFVklDRV9QQ0lfQlVTX0lEX05WJ10gJiYgZGV2aWNlWydDTF9ERVZJQ0VfUENJX1NMT1RfSURfTlYnXSkge1xuICAgICAgICAgIGNvbnN0IGJ1cyA9IHBhcnNlSW50KGRldmljZVsnQ0xfREVWSUNFX1BDSV9CVVNfSURfTlYnXSk7XG4gICAgICAgICAgY29uc3Qgc2xvdCA9IHBhcnNlSW50KGRldmljZVsnQ0xfREVWSUNFX1BDSV9TTE9UX0lEX05WJ10pO1xuICAgICAgICAgIGlmICghaXNOYU4oYnVzKSAmJiAhaXNOYU4oc2xvdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidXMgJiAweGZmO1xuICAgICAgICAgICAgY29uc3QgZCA9IChzbG90ID4+IDMpICYgMHhmZjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzbG90ICYgMHgwNztcbiAgICAgICAgICAgIGJ1c0FkZHJlc3MgPSBgJHtiLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0uJHtmfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChidXNBZGRyZXNzKSB7XG4gICAgICAgICAgbGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVycy5maW5kKGNvbnRyb2xsZXIgPT4gY29udHJvbGxlci5idXNBZGRyZXNzID09PSBidXNBZGRyZXNzKTtcbiAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSB7XG4gICAgICAgICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgICAgICAgYnVzOiAnJyxcbiAgICAgICAgICAgICAgYnVzQWRkcmVzcyxcbiAgICAgICAgICAgICAgdnJhbTogbnVsbCxcbiAgICAgICAgICAgICAgdnJhbUR5bmFtaWM6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci52ZW5kb3IgPSBkZXZpY2VbJ0NMX0RFVklDRV9WRU5ET1InXTtcbiAgICAgICAgICBpZiAoZGV2aWNlWydDTF9ERVZJQ0VfQk9BUkRfTkFNRV9BTUQnXSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5tb2RlbCA9IGRldmljZVsnQ0xfREVWSUNFX0JPQVJEX05BTUVfQU1EJ107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIubW9kZWwgPSBkZXZpY2VbJ0NMX0RFVklDRV9OQU1FJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbW9yeSA9IHBhcnNlSW50KGRldmljZVsnQ0xfREVWSUNFX0dMT0JBTF9NRU1fU0laRSddKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG1lbW9yeSkpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudnJhbSA9IE1hdGgucm91bmQobWVtb3J5IC8gMTAyNCAvIDEwMjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udHJvbGxlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROdmlkaWFTbWkoKSB7XG4gICAgaWYgKF9udmlkaWFTbWlQYXRoKSB7XG4gICAgICByZXR1cm4gX252aWRpYVNtaVBhdGg7XG4gICAgfVxuXG4gICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiYXNlUGF0aCA9IHV0aWwuV0lORElSICsgJ1xcXFxTeXN0ZW0zMlxcXFxEcml2ZXJTdG9yZVxcXFxGaWxlUmVwb3NpdG9yeSc7XG4gICAgICAgIC8vIGZpbmQgYWxsIGRpcmVjdG9yaWVzIHRoYXQgaGF2ZSBhbiBudmlkaWEtc21pLmV4ZSBmaWxlXG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZURpcnMgPSBmcy5yZWFkZGlyU3luYyhiYXNlUGF0aCkuZmlsdGVyKGRpciA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKFtiYXNlUGF0aCwgZGlyXS5qb2luKCcvJykpLmluY2x1ZGVzKCdudmlkaWEtc21pLmV4ZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXNlIHRoZSBkaXJlY3Rvcnkgd2l0aCB0aGUgbW9zdCByZWNlbnRseSBjcmVhdGVkIG52aWRpYS1zbWkuZXhlIGZpbGVcbiAgICAgICAgY29uc3QgdGFyZ2V0RGlyID0gY2FuZGlkYXRlRGlycy5yZWR1Y2UoKHByZXZEaXIsIGN1cnJlbnREaXIpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c052aWRpYVNtaSA9IGZzLnN0YXRTeW5jKFtiYXNlUGF0aCwgcHJldkRpciwgJ252aWRpYS1zbWkuZXhlJ10uam9pbignLycpKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50TnZpZGlhU21pID0gZnMuc3RhdFN5bmMoW2Jhc2VQYXRoLCBjdXJyZW50RGlyLCAnbnZpZGlhLXNtaS5leGUnXS5qb2luKCcvJykpO1xuICAgICAgICAgIHJldHVybiAocHJldmlvdXNOdmlkaWFTbWkuY3RpbWVNcyA+IGN1cnJlbnROdmlkaWFTbWkuY3RpbWVNcykgPyBwcmV2RGlyIDogY3VycmVudERpcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRhcmdldERpcikge1xuICAgICAgICAgIF9udmlkaWFTbWlQYXRoID0gW2Jhc2VQYXRoLCB0YXJnZXREaXIsICdudmlkaWEtc21pLmV4ZSddLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9saW51eCkge1xuICAgICAgX252aWRpYVNtaVBhdGggPSAnbnZpZGlhLXNtaSc7XG4gICAgfVxuICAgIHJldHVybiBfbnZpZGlhU21pUGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG52aWRpYVNtaShvcHRpb25zKSB7XG4gICAgY29uc3QgbnZpZGlhU21pRXhlID0gZ2V0TnZpZGlhU21pKCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdXRpbC5leGVjT3B0c1dpbjtcbiAgICBpZiAobnZpZGlhU21pRXhlKSB7XG4gICAgICBjb25zdCBudmlkaWFTbWlPcHRzID0gJy0tcXVlcnktZ3B1PWRyaXZlcl92ZXJzaW9uLHBjaS5zdWJfZGV2aWNlX2lkLG5hbWUscGNpLmJ1c19pZCxmYW4uc3BlZWQsbWVtb3J5LnRvdGFsLG1lbW9yeS51c2VkLG1lbW9yeS5mcmVlLHV0aWxpemF0aW9uLmdwdSx1dGlsaXphdGlvbi5tZW1vcnksdGVtcGVyYXR1cmUuZ3B1LHRlbXBlcmF0dXJlLm1lbW9yeSxwb3dlci5kcmF3LHBvd2VyLmxpbWl0LGNsb2Nrcy5ncixjbG9ja3MubWVtIC0tZm9ybWF0PWNzdixub2hlYWRlcixub3VuaXRzJztcbiAgICAgIGNvbnN0IGNtZCA9IG52aWRpYVNtaUV4ZSArICcgJyArIG52aWRpYVNtaU9wdHMgKyAoX2xpbnV4ID8gJyAgMj4vZGV2L251bGwnIDogJycpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gZXhlY1N5bmMoY21kLCBvcHRpb25zKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gbnZpZGlhRGV2aWNlcygpIHtcblxuICAgIGZ1bmN0aW9uIHNhZmVQYXJzZU51bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKFtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3Rkb3V0ID0gbnZpZGlhU21pKCk7XG4gICAgaWYgKCFzdGRvdXQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBncHVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgbGV0IHJlc3VsdHMgPSBncHVzLm1hcChncHUgPT4ge1xuICAgICAgY29uc3Qgc3BsaXR0ZWREYXRhID0gZ3B1LnNwbGl0KCcsICcpLm1hcCh2YWx1ZSA9PiB2YWx1ZS5pbmNsdWRlcygnTi9BJykgPyB1bmRlZmluZWQgOiB2YWx1ZSk7XG4gICAgICBpZiAoc3BsaXR0ZWREYXRhLmxlbmd0aCA9PT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkcml2ZXJWZXJzaW9uOiBzcGxpdHRlZERhdGFbMF0sXG4gICAgICAgICAgc3ViRGV2aWNlSWQ6IHNwbGl0dGVkRGF0YVsxXSxcbiAgICAgICAgICBuYW1lOiBzcGxpdHRlZERhdGFbMl0sXG4gICAgICAgICAgcGNpQnVzOiBzcGxpdHRlZERhdGFbM10sXG4gICAgICAgICAgZmFuU3BlZWQ6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbNF0pLFxuICAgICAgICAgIG1lbW9yeVRvdGFsOiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzVdKSxcbiAgICAgICAgICBtZW1vcnlVc2VkOiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzZdKSxcbiAgICAgICAgICBtZW1vcnlGcmVlOiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzddKSxcbiAgICAgICAgICB1dGlsaXphdGlvbkdwdTogc2FmZVBhcnNlTnVtYmVyKHNwbGl0dGVkRGF0YVs4XSksXG4gICAgICAgICAgdXRpbGl6YXRpb25NZW1vcnk6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbOV0pLFxuICAgICAgICAgIHRlbXBlcmF0dXJlR3B1OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzEwXSksXG4gICAgICAgICAgdGVtcGVyYXR1cmVNZW1vcnk6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTFdKSxcbiAgICAgICAgICBwb3dlckRyYXc6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTJdKSxcbiAgICAgICAgICBwb3dlckxpbWl0OiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzEzXSksXG4gICAgICAgICAgY2xvY2tDb3JlOiBzYWZlUGFyc2VOdW1iZXIoc3BsaXR0ZWREYXRhWzE0XSksXG4gICAgICAgICAgY2xvY2tNZW1vcnk6IHNhZmVQYXJzZU51bWJlcihzcGxpdHRlZERhdGFbMTVdKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgIHJldHVybiAoJ3BjaUJ1cycgaW4gaXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUNvbnRyb2xsZXJOdmlkaWEoY29udHJvbGxlciwgbnZpZGlhKSB7XG4gICAgaWYgKG52aWRpYS5kcml2ZXJWZXJzaW9uKSB7IGNvbnRyb2xsZXIuZHJpdmVyVmVyc2lvbiA9IG52aWRpYS5kcml2ZXJWZXJzaW9uOyB9XG4gICAgaWYgKG52aWRpYS5zdWJEZXZpY2VJZCkgeyBjb250cm9sbGVyLnN1YkRldmljZUlkID0gbnZpZGlhLnN1YkRldmljZUlkOyB9XG4gICAgaWYgKG52aWRpYS5uYW1lKSB7IGNvbnRyb2xsZXIubmFtZSA9IG52aWRpYS5uYW1lOyB9XG4gICAgaWYgKG52aWRpYS5wY2lCdXMpIHsgY29udHJvbGxlci5wY2lCdXMgPSBudmlkaWEucGNpQnVzOyB9XG4gICAgaWYgKG52aWRpYS5mYW5TcGVlZCkgeyBjb250cm9sbGVyLmZhblNwZWVkID0gbnZpZGlhLmZhblNwZWVkOyB9XG4gICAgaWYgKG52aWRpYS5tZW1vcnlUb3RhbCkge1xuICAgICAgY29udHJvbGxlci5tZW1vcnlUb3RhbCA9IG52aWRpYS5tZW1vcnlUb3RhbDtcbiAgICAgIGNvbnRyb2xsZXIudnJhbSA9IG52aWRpYS5tZW1vcnlUb3RhbDtcbiAgICAgIGNvbnRyb2xsZXIudnJhbUR5bmFtaWMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG52aWRpYS5tZW1vcnlVc2VkKSB7IGNvbnRyb2xsZXIubWVtb3J5VXNlZCA9IG52aWRpYS5tZW1vcnlVc2VkOyB9XG4gICAgaWYgKG52aWRpYS5tZW1vcnlGcmVlKSB7IGNvbnRyb2xsZXIubWVtb3J5RnJlZSA9IG52aWRpYS5tZW1vcnlGcmVlOyB9XG4gICAgaWYgKG52aWRpYS51dGlsaXphdGlvbkdwdSkgeyBjb250cm9sbGVyLnV0aWxpemF0aW9uR3B1ID0gbnZpZGlhLnV0aWxpemF0aW9uR3B1OyB9XG4gICAgaWYgKG52aWRpYS51dGlsaXphdGlvbk1lbW9yeSkgeyBjb250cm9sbGVyLnV0aWxpemF0aW9uTWVtb3J5ID0gbnZpZGlhLnV0aWxpemF0aW9uTWVtb3J5OyB9XG4gICAgaWYgKG52aWRpYS50ZW1wZXJhdHVyZUdwdSkgeyBjb250cm9sbGVyLnRlbXBlcmF0dXJlR3B1ID0gbnZpZGlhLnRlbXBlcmF0dXJlR3B1OyB9XG4gICAgaWYgKG52aWRpYS50ZW1wZXJhdHVyZU1lbW9yeSkgeyBjb250cm9sbGVyLnRlbXBlcmF0dXJlTWVtb3J5ID0gbnZpZGlhLnRlbXBlcmF0dXJlTWVtb3J5OyB9XG4gICAgaWYgKG52aWRpYS5wb3dlckRyYXcpIHsgY29udHJvbGxlci5wb3dlckRyYXcgPSBudmlkaWEucG93ZXJEcmF3OyB9XG4gICAgaWYgKG52aWRpYS5wb3dlckxpbWl0KSB7IGNvbnRyb2xsZXIucG93ZXJMaW1pdCA9IG52aWRpYS5wb3dlckxpbWl0OyB9XG4gICAgaWYgKG52aWRpYS5jbG9ja0NvcmUpIHsgY29udHJvbGxlci5jbG9ja0NvcmUgPSBudmlkaWEuY2xvY2tDb3JlOyB9XG4gICAgaWYgKG52aWRpYS5jbG9ja01lbW9yeSkgeyBjb250cm9sbGVyLmNsb2NrTWVtb3J5ID0gbnZpZGlhLmNsb2NrTWVtb3J5OyB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxpbmVzTGludXhFZGlkKGVkaWQpIHtcbiAgICAvLyBwYXJzZW4gRURJRFxuICAgIC8vIC0tPiBtb2RlbFxuICAgIC8vIC0tPiByZXNvbHV0aW9ueFxuICAgIC8vIC0tPiByZXNvbHV0aW9ueVxuICAgIC8vIC0tPiBidWlsdGluID0gZmFsc2VcbiAgICAvLyAtLT4gcGl4ZWxkZXB0aCAoPylcbiAgICAvLyAtLT4gc2l6ZXhcbiAgICAvLyAtLT4gc2l6ZXlcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgdmVuZG9yOiAnJyxcbiAgICAgIG1vZGVsOiAnJyxcbiAgICAgIGRldmljZU5hbWU6ICcnLFxuICAgICAgbWFpbjogZmFsc2UsXG4gICAgICBidWlsdGluOiBmYWxzZSxcbiAgICAgIGNvbm5lY3Rpb246ICcnLFxuICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICBzaXplWTogbnVsbCxcbiAgICAgIHBpeGVsRGVwdGg6IG51bGwsXG4gICAgICByZXNvbHV0aW9uWDogbnVsbCxcbiAgICAgIHJlc29sdXRpb25ZOiBudWxsLFxuICAgICAgY3VycmVudFJlc1g6IG51bGwsXG4gICAgICBjdXJyZW50UmVzWTogbnVsbCxcbiAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgIGN1cnJlbnRSZWZyZXNoUmF0ZTogbnVsbFxuICAgIH07XG4gICAgLy8gZmluZCBmaXJzdCBcIkRldGFpbGVkIFRpbWluZyBEZXNjcmlwdGlvblwiXG4gICAgbGV0IHN0YXJ0ID0gMTA4O1xuICAgIGlmIChlZGlkLnN1YnN0cihzdGFydCwgNikgPT09ICcwMDAwMDAnKSB7XG4gICAgICBzdGFydCArPSAzNjtcbiAgICB9XG4gICAgaWYgKGVkaWQuc3Vic3RyKHN0YXJ0LCA2KSA9PT0gJzAwMDAwMCcpIHtcbiAgICAgIHN0YXJ0ICs9IDM2O1xuICAgIH1cbiAgICBpZiAoZWRpZC5zdWJzdHIoc3RhcnQsIDYpID09PSAnMDAwMDAwJykge1xuICAgICAgc3RhcnQgKz0gMzY7XG4gICAgfVxuICAgIGlmIChlZGlkLnN1YnN0cihzdGFydCwgNikgPT09ICcwMDAwMDAnKSB7XG4gICAgICBzdGFydCArPSAzNjtcbiAgICB9XG4gICAgcmVzdWx0LnJlc29sdXRpb25YID0gcGFyc2VJbnQoJzB4MCcgKyBlZGlkLnN1YnN0cihzdGFydCArIDgsIDEpICsgZWRpZC5zdWJzdHIoc3RhcnQgKyA0LCAyKSk7XG4gICAgcmVzdWx0LnJlc29sdXRpb25ZID0gcGFyc2VJbnQoJzB4MCcgKyBlZGlkLnN1YnN0cihzdGFydCArIDE0LCAxKSArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMTAsIDIpKTtcbiAgICByZXN1bHQuc2l6ZVggPSBwYXJzZUludCgnMHgwJyArIGVkaWQuc3Vic3RyKHN0YXJ0ICsgMjgsIDEpICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAyNCwgMikpO1xuICAgIHJlc3VsdC5zaXplWSA9IHBhcnNlSW50KCcweDAnICsgZWRpZC5zdWJzdHIoc3RhcnQgKyAyOSwgMSkgKyBlZGlkLnN1YnN0cihzdGFydCArIDI2LCAyKSk7XG4gICAgLy8gbW9uaXRvciBuYW1lXG4gICAgc3RhcnQgPSBlZGlkLmluZGV4T2YoJzAwMDAwMGZjMDAnKTsgLy8gZmluZCBmaXJzdCBcIk1vbml0b3IgRGVzY3JpcHRpb24gRGF0YVwiXG4gICAgaWYgKHN0YXJ0ID49IDApIHtcbiAgICAgIGxldCBtb2RlbF9yYXcgPSBlZGlkLnN1YnN0cihzdGFydCArIDEwLCAyNik7XG4gICAgICBpZiAobW9kZWxfcmF3LmluZGV4T2YoJzBhJykgIT09IC0xKSB7XG4gICAgICAgIG1vZGVsX3JhdyA9IG1vZGVsX3Jhdy5zdWJzdHIoMCwgbW9kZWxfcmF3LmluZGV4T2YoJzBhJykpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG1vZGVsX3Jhdy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgcmVzdWx0Lm1vZGVsID0gbW9kZWxfcmF3Lm1hdGNoKC8uezEsMn0vZykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2LCAxNikpO1xuICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQubW9kZWwgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNMaW51eERpc3BsYXlzKGxpbmVzLCBkZXB0aCkge1xuICAgIGxldCBkaXNwbGF5cyA9IFtdO1xuICAgIGxldCBjdXJyZW50RGlzcGxheSA9IHtcbiAgICAgIHZlbmRvcjogJycsXG4gICAgICBtb2RlbDogJycsXG4gICAgICBkZXZpY2VOYW1lOiAnJyxcbiAgICAgIG1haW46IGZhbHNlLFxuICAgICAgYnVpbHRpbjogZmFsc2UsXG4gICAgICBjb25uZWN0aW9uOiAnJyxcbiAgICAgIHNpemVYOiBudWxsLFxuICAgICAgc2l6ZVk6IG51bGwsXG4gICAgICBwaXhlbERlcHRoOiBudWxsLFxuICAgICAgcmVzb2x1dGlvblg6IG51bGwsXG4gICAgICByZXNvbHV0aW9uWTogbnVsbCxcbiAgICAgIGN1cnJlbnRSZXNYOiBudWxsLFxuICAgICAgY3VycmVudFJlc1k6IG51bGwsXG4gICAgICBwb3NpdGlvblg6IDAsXG4gICAgICBwb3NpdGlvblk6IDAsXG4gICAgICBjdXJyZW50UmVmcmVzaFJhdGU6IG51bGxcbiAgICB9O1xuICAgIGxldCBpc19lZGlkID0gZmFsc2U7XG4gICAgbGV0IGlzX2N1cnJlbnQgPSBmYWxzZTtcbiAgICBsZXQgZWRpZF9yYXcgPSAnJztcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHsgICAgICAgIC8vIHN0YXJ0IHdpdGggc2Vjb25kIGxpbmVcbiAgICAgIGlmICgnJyAhPT0gbGluZXNbaV0udHJpbSgpKSB7XG4gICAgICAgIGlmICgnICcgIT09IGxpbmVzW2ldWzBdICYmICdcXHQnICE9PSBsaW5lc1tpXVswXSAmJiBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBjb25uZWN0ZWQgJykgIT09IC0xKSB7ICAgICAgICAvLyBmaXJzdCBsaW5lIG9mIG5ldyBlbnRyeVxuICAgICAgICAgIGlmIChjdXJyZW50RGlzcGxheS5tb2RlbCB8fCBjdXJyZW50RGlzcGxheS5tYWluIHx8IGN1cnJlbnREaXNwbGF5LmJ1aWx0aW4gfHwgY3VycmVudERpc3BsYXkuY29ubmVjdGlvbiB8fCBjdXJyZW50RGlzcGxheS5zaXplWCAhPT0gbnVsbCB8fCBjdXJyZW50RGlzcGxheS5waXhlbERlcHRoICE9PSBudWxsIHx8IGN1cnJlbnREaXNwbGF5LnJlc29sdXRpb25YICE9PSBudWxsKSB7ICAgICAgICAgLy8gcHVzaCBsYXN0IGRpc3BsYXkgdG8gYXJyYXlcbiAgICAgICAgICAgIGRpc3BsYXlzLnB1c2goY3VycmVudERpc3BsYXkpO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkgPSB7XG4gICAgICAgICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgICAgICAgIG1vZGVsOiAnJyxcbiAgICAgICAgICAgICAgbWFpbjogZmFsc2UsXG4gICAgICAgICAgICAgIGJ1aWx0aW46IGZhbHNlLFxuICAgICAgICAgICAgICBjb25uZWN0aW9uOiAnJyxcbiAgICAgICAgICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICAgICAgICAgIHNpemVZOiBudWxsLFxuICAgICAgICAgICAgICBwaXhlbERlcHRoOiBudWxsLFxuICAgICAgICAgICAgICByZXNvbHV0aW9uWDogbnVsbCxcbiAgICAgICAgICAgICAgcmVzb2x1dGlvblk6IG51bGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZXNYOiBudWxsLFxuICAgICAgICAgICAgICBjdXJyZW50UmVzWTogbnVsbCxcbiAgICAgICAgICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgICAgICAgICBwb3NpdGlvblk6IDAsXG4gICAgICAgICAgICAgIGN1cnJlbnRSZWZyZXNoUmF0ZTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHBhcnRzID0gbGluZXNbaV0uc3BsaXQoJyAnKTtcbiAgICAgICAgICBjdXJyZW50RGlzcGxheS5jb25uZWN0aW9uID0gcGFydHNbMF07XG4gICAgICAgICAgY3VycmVudERpc3BsYXkubWFpbiA9IGxpbmVzW2ldLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIHByaW1hcnkgJykgPj0gMDtcbiAgICAgICAgICBjdXJyZW50RGlzcGxheS5idWlsdGluID0gKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZWRwJykgPj0gMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gcmVhZCBFRElEIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChpc19lZGlkKSB7XG4gICAgICAgICAgaWYgKGxpbmVzW2ldLnNlYXJjaCgvXFxTfCQvKSA+IHN0YXJ0KSB7XG4gICAgICAgICAgICBlZGlkX3JhdyArPSBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyc2VuIEVESURcbiAgICAgICAgICAgIGxldCBlZGlkX2RlY29kZWQgPSBwYXJzZUxpbmVzTGludXhFZGlkKGVkaWRfcmF3KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnZlbmRvciA9IGVkaWRfZGVjb2RlZC52ZW5kb3I7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5tb2RlbCA9IGVkaWRfZGVjb2RlZC5tb2RlbDtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnJlc29sdXRpb25YID0gZWRpZF9kZWNvZGVkLnJlc29sdXRpb25YO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkucmVzb2x1dGlvblkgPSBlZGlkX2RlY29kZWQucmVzb2x1dGlvblk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5zaXplWCA9IGVkaWRfZGVjb2RlZC5zaXplWDtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LnNpemVZID0gZWRpZF9kZWNvZGVkLnNpemVZO1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkucGl4ZWxEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgaXNfZWRpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdlZGlkOicpID49IDApIHtcbiAgICAgICAgICBpc19lZGlkID0gdHJ1ZTtcbiAgICAgICAgICBzdGFydCA9IGxpbmVzW2ldLnNlYXJjaCgvXFxTfCQvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZXNbaV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCcqY3VycmVudCcpID49IDApIHtcbiAgICAgICAgICBjb25zdCBwYXJ0czEgPSBsaW5lc1tpXS5zcGxpdCgnKCcpO1xuICAgICAgICAgIGlmIChwYXJ0czEgJiYgcGFydHMxLmxlbmd0aCA+IDEgJiYgcGFydHMxWzBdLmluZGV4T2YoJ3gnKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXNQYXJ0cyA9IHBhcnRzMVswXS50cmltKCkuc3BsaXQoJ3gnKTtcbiAgICAgICAgICAgIGN1cnJlbnREaXNwbGF5LmN1cnJlbnRSZXNYID0gdXRpbC50b0ludChyZXNQYXJ0c1swXSk7XG4gICAgICAgICAgICBjdXJyZW50RGlzcGxheS5jdXJyZW50UmVzWSA9IHV0aWwudG9JbnQocmVzUGFydHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc19jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfY3VycmVudCAmJiBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nsb2NrJykgPj0gMCAmJiBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h6JykgPj0gMCAmJiBsaW5lc1tpXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3Y6IGhlaWdodCcpID49IDApIHtcbiAgICAgICAgICBjb25zdCBwYXJ0czEgPSBsaW5lc1tpXS5zcGxpdCgnY2xvY2snKTtcbiAgICAgICAgICBpZiAocGFydHMxICYmIHBhcnRzMS5sZW5ndGggPiAxICYmIHBhcnRzMVsxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2h6JykgPj0gMCkge1xuICAgICAgICAgICAgY3VycmVudERpc3BsYXkuY3VycmVudFJlZnJlc2hSYXRlID0gdXRpbC50b0ludChwYXJ0czFbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc19jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwdXNoZW4gZGlzcGxheXNcbiAgICBpZiAoY3VycmVudERpc3BsYXkubW9kZWwgfHwgY3VycmVudERpc3BsYXkubWFpbiB8fCBjdXJyZW50RGlzcGxheS5idWlsdGluIHx8IGN1cnJlbnREaXNwbGF5LmNvbm5lY3Rpb24gfHwgY3VycmVudERpc3BsYXkuc2l6ZVggIT09IG51bGwgfHwgY3VycmVudERpc3BsYXkucGl4ZWxEZXB0aCAhPT0gbnVsbCB8fCBjdXJyZW50RGlzcGxheS5yZXNvbHV0aW9uWCAhPT0gbnVsbCkgeyAgLy8gc3RpbGwgaW5mb3JtYXRpb24gdGhlcmVcbiAgICAgIGRpc3BsYXlzLnB1c2goY3VycmVudERpc3BsYXkpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzcGxheXM7XG4gIH1cblxuICAvLyBmdW5jdGlvbiBzdGFydHMgaGVyZVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGNvbnRyb2xsZXJzOiBbXSxcbiAgICAgICAgZGlzcGxheXM6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgLXhtbCAtZGV0YWlsTGV2ZWwgZnVsbCBTUERpc3BsYXlzRGF0YVR5cGUnO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VMaW5lc0Rhcndpbih1dGlsLnBsaXN0UGFyc2VyKG91dHB1dClbMF0uX2l0ZW1zKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGRvdXQgPSBleGVjU3luYygnZGVmYXVsdHMgcmVhZCAvTGlicmFyeS9QcmVmZXJlbmNlcy9jb20uYXBwbGUud2luZG93c2VydmVyLnBsaXN0IDI+L2Rldi9udWxsO2RlZmF1bHRzIHJlYWQgL0xpYnJhcnkvUHJlZmVyZW5jZXMvY29tLmFwcGxlLndpbmRvd3NlcnZlci5kaXNwbGF5cy5wbGlzdCAyPi9kZXYvbnVsbDsgZWNobyBcIlwiJyk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSAoc3Rkb3V0IHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdXRpbC5wbGlzdFJlYWRlcihvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ10gJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVsnQ29uZmlncyddICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bJ0NvbmZpZ3MnXVswXSAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWydDb25maWdzJ11bMF1bJ0Rpc3BsYXlDb25maWcnXSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVsnQ29uZmlncyddWzBdWydEaXNwbGF5Q29uZmlnJ107XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY3VycmVudC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9bJ0N1cnJlbnRJbmZvJ10gJiYgJ09yaWdpblgnIGluIG9bJ0N1cnJlbnRJbmZvJ10gJiYgcmVzdWx0LmRpc3BsYXlzICYmIHJlc3VsdC5kaXNwbGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzW2ldLnBvc2l0aW9uWCA9IG9bJ0N1cnJlbnRJbmZvJ11bJ09yaWdpblgnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9bJ0N1cnJlbnRJbmZvJ10gJiYgJ09yaWdpblknIGluIG9bJ0N1cnJlbnRJbmZvJ10gJiYgcmVzdWx0LmRpc3BsYXlzICYmIHJlc3VsdC5kaXNwbGF5c1tpXSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzW2ldLnBvc2l0aW9uWSA9IG9bJ0N1cnJlbnRJbmZvJ11bJ09yaWdpblknXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddICYmIG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ10ubGVuZ3RoID4gMCAmJiBvYmpbJ0Rpc3BsYXlBbnlVc2VyU2V0cyddWzBdLmxlbmd0aCA+IDAgJiYgb2JqWydEaXNwbGF5QW55VXNlclNldHMnXVswXVswXVsnRGlzcGxheUlEJ10pIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IG9ialsnRGlzcGxheUFueVVzZXJTZXRzJ11bMF07XG4gICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgY3VycmVudC5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCdPcmlnaW5YJyBpbiBvICYmIHJlc3VsdC5kaXNwbGF5cyAmJiByZXN1bHQuZGlzcGxheXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1tpXS5wb3NpdGlvblggPSBvWydPcmlnaW5YJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnT3JpZ2luWScgaW4gbyAmJiByZXN1bHQuZGlzcGxheXMgJiYgcmVzdWx0LmRpc3BsYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbaV0ucG9zaXRpb25ZID0gb1snT3JpZ2luWSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob1snTW9kZSddICYmICdCaXRzUGVyUGl4ZWwnIGluIG9bJ01vZGUnXSAmJiByZXN1bHQuZGlzcGxheXMgJiYgcmVzdWx0LmRpc3BsYXlzW2ldKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuZGlzcGxheXNbaV0ucGl4ZWxEZXB0aCA9IG9bJ01vZGUnXVsnQml0c1BlclBpeGVsJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAvLyBSYXNwYmVycnk6IGh0dHBzOi8vZWxpbnV4Lm9yZy9SUElfdmNnZW5jbWRfdXNhZ2VcbiAgICAgICAgaWYgKHV0aWwuaXNSYXNwYmVycnkoKSAmJiB1dGlsLmlzUmFzcGJpYW4oKSkge1xuICAgICAgICAgIGxldCBjbWQgPSAnZmJzZXQgLXMgfCBncmVwIFxcJ21vZGUgXCJcXCc7IHZjZ2VuY21kIGdldF9tZW0gZ3B1OyB0dnNlcnZpY2UgLXM7IHR2c2VydmljZSAtbjsnO1xuICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDMgJiYgbGluZXNbMF0uaW5kZXhPZignbW9kZSBcIicpID49IC0xICYmIGxpbmVzWzJdLmluZGV4T2YoJzB4MTIwMDBhJykgPiAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnJlcGxhY2UoJ21vZGUnLCAnJykucmVwbGFjZSgvXCIvZywgJycpLnRyaW0oKS5zcGxpdCgneCcpO1xuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdmVuZG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgIG1vZGVsOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZGV2aWNlX25hbWUnLCAnPScpLFxuICAgICAgICAgICAgICAgICAgbWFpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGJ1aWx0aW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogJ0hETUknLFxuICAgICAgICAgICAgICAgICAgc2l6ZVg6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzaXplWTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHBpeGVsRGVwdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgICByZXNvbHV0aW9uWDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgICAgICAgICAgIHJlc29sdXRpb25ZOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFJlc1g6IG51bGwsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UmVzWTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogMCxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uWTogMCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZWZyZXNoUmF0ZTogbnVsbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSAmJiBzdGRvdXQudG9TdHJpbmcoKS5pbmRleE9mKCdncHU9JykgPj0gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZlbmRvcjogJ0Jyb2FkY29tJyxcbiAgICAgICAgICAgICAgICBtb2RlbDogJ1ZpZGVvQ29yZSBJVicsXG4gICAgICAgICAgICAgICAgYnVzOiAnJyxcbiAgICAgICAgICAgICAgICB2cmFtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZ3B1JywgJz0nKS5yZXBsYWNlKCdNJywgJycpLFxuICAgICAgICAgICAgICAgIHZyYW1EeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGNtZCA9ICdsc3BjaSAtdnZ2ICAyPi9kZXYvbnVsbCc7XG4gICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzID0gcGFyc2VMaW5lc0xpbnV4Q29udHJvbGxlcnMobGluZXMpO1xuICAgICAgICAgICAgICBjb25zdCBudmlkaWFEYXRhID0gbnZpZGlhRGV2aWNlcygpO1xuICAgICAgICAgICAgICAvLyBuZWVkcyB0byBiZSByZXdyaXR0ZW4gLi4uIHVzaW5nIG5vIHNwcmVhZCBvcGVyYXRvcnNcbiAgICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzID0gcmVzdWx0LmNvbnRyb2xsZXJzLm1hcCgoY29udHJvbGxlcikgPT4geyAvLyBtYXRjaCBieSBidXNBZGRyZXNzXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlQ29udHJvbGxlck52aWRpYShjb250cm9sbGVyLCBudmlkaWFEYXRhLmZpbmQoKGNvbnRyKSA9PiBjb250ci5wY2lCdXMudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChjb250cm9sbGVyLmJ1c0FkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHx8IHt9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY21kID0gJ2NsaW5mbyAtLXJhdyc7XG4gICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMgPSBwYXJzZUxpbmVzTGludXhDbGluZm8ocmVzdWx0LmNvbnRyb2xsZXJzLCBsaW5lcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGNtZCA9ICd4ZHB5aW5mbyAyPi9kZXYvbnVsbCB8IGdyZXAgXFwnZGVwdGggb2Ygcm9vdCB3aW5kb3dcXCcgfCBhd2sgXFwneyBwcmludCAkNSB9XFwnJztcbiAgICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICBkZXB0aCA9IHBhcnNlSW50KGxpbmVzWzBdKSB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY21kID0gJ3hyYW5kciAtLXZlcmJvc2UgMj4vZGV2L251bGwnO1xuICAgICAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5cyA9IHBhcnNlTGluZXNMaW51eERpc3BsYXlzKGxpbmVzLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsKTsgfVxuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9ibG9ncy50ZWNobmV0Lm1pY3Jvc29mdC5jb20vaGV5c2NyaXB0aW5nZ3V5LzIwMTMvMTAvMDMvdXNlLXBvd2Vyc2hlbGwtdG8tZGlzY292ZXItbXVsdGktbW9uaXRvci1pbmZvcm1hdGlvbi9cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL3NjcmlwdGluZy91c2UtcG93ZXJzaGVsbC10by1kaXNjb3Zlci1tdWx0aS1tb25pdG9yLWluZm9ybWF0aW9uL1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSB3aW4zMl9WaWRlb0NvbnRyb2xsZXIgfCBmbCAqJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdncCBcIkhLTE06XFxcXFNZU1RFTVxcXFxDb250cm9sU2V0MDAxXFxcXENvbnRyb2xcXFxcQ2xhc3NcXFxcezRkMzZlOTY4LWUzMjUtMTFjZS1iZmMxLTA4MDAyYmUxMDMxOH1cXFxcKlwiIC1FcnJvckFjdGlvbiBTaWxlbnRseUNvbnRpbnVlIHwgd2hlcmUgTWF0Y2hpbmdEZXZpY2VJZCAkbnVsbCAtTkUgfCBzZWxlY3QgTWF0Y2hpbmdEZXZpY2VJZCxIYXJkd2FyZUluZm9ybWF0aW9uLnF3TWVtb3J5U2l6ZSB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2Ugd2luMzJfZGVza3RvcG1vbml0b3IgfCBmbCAqJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgLU5hbWVzcGFjZSByb290XFxcXHdtaSAtQ2xhc3NOYW1lIFdtaU1vbml0b3JCYXNpY0Rpc3BsYXlQYXJhbXMgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnQWRkLVR5cGUgLUFzc2VtYmx5TmFtZSBTeXN0ZW0uV2luZG93cy5Gb3JtczsgW1N5c3RlbS5XaW5kb3dzLkZvcm1zLlNjcmVlbl06OkFsbFNjcmVlbnMnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSAtTmFtZXNwYWNlIHJvb3RcXFxcd21pIC1DbGFzc05hbWUgV21pTW9uaXRvckNvbm5lY3Rpb25QYXJhbXMgfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnZ3dtaSBXbWlNb25pdG9ySUQgLU5hbWVzcGFjZSByb290XFxcXHdtaSB8IEZvckVhY2gtT2JqZWN0IHsoKCRfLk1hbnVmYWN0dXJlck5hbWUgLW5vdG1hdGNoIDAgfCBmb3JlYWNoIHtbY2hhcl0kX30pIC1qb2luIFwiXCIpICsgXCJ8XCIgKyAoKCRfLlByb2R1Y3RDb2RlSUQgLW5vdG1hdGNoIDAgfCBmb3JlYWNoIHtbY2hhcl0kX30pIC1qb2luIFwiXCIpICsgXCJ8XCIgKyAoKCRfLlVzZXJGcmllbmRseU5hbWUgLW5vdG1hdGNoIDAgfCBmb3JlYWNoIHtbY2hhcl0kX30pIC1qb2luIFwiXCIpICsgXCJ8XCIgKyAoKCRfLlNlcmlhbE51bWJlcklEIC1ub3RtYXRjaCAwIHwgZm9yZWFjaCB7W2NoYXJdJF99KSAtam9pbiBcIlwiKSArIFwifFwiICsgJF8uSW5zdGFuY2VOYW1lfScpKTtcblxuICAgICAgICAgIGNvbnN0IG52aWRpYURhdGEgPSBudmlkaWFEZXZpY2VzKCk7XG5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBjb250cm9sbGVyICsgdnJhbVxuICAgICAgICAgICAgbGV0IGNzZWN0aW9ucyA9IGRhdGFbMF0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgbGV0IHZzZWN0aW9ucyA9IGRhdGFbMV0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXJzID0gcGFyc2VMaW5lc1dpbmRvd3NDb250cm9sbGVycyhjc2VjdGlvbnMsIHZzZWN0aW9ucyk7XG4gICAgICAgICAgICByZXN1bHQuY29udHJvbGxlcnMgPSByZXN1bHQuY29udHJvbGxlcnMubWFwKChjb250cm9sbGVyKSA9PiB7IC8vIG1hdGNoIGJ5IHN1YkRldmljZUlkXG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnZlbmRvci50b0xvd2VyQ2FzZSgpID09PSAnbnZpZGlhJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUNvbnRyb2xsZXJOdmlkaWEoY29udHJvbGxlciwgbnZpZGlhRGF0YS5maW5kKGRldmljZSA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgd2luZG93c1N1YkRldmljZUlkID0gKGNvbnRyb2xsZXIuc3ViRGV2aWNlSWQgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBudmlkaWFTdWJEZXZpY2VJZFBhcnRzID0gZGV2aWNlLnN1YkRldmljZUlkLnNwbGl0KCd4Jyk7XG4gICAgICAgICAgICAgICAgICBsZXQgbnZpZGlhU3ViRGV2aWNlSWQgPSBudmlkaWFTdWJEZXZpY2VJZFBhcnRzLmxlbmd0aCA+IDEgPyBudmlkaWFTdWJEZXZpY2VJZFBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgOiBudmlkaWFTdWJEZXZpY2VJZFBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhEaWZmZXJlbmNlID0gTWF0aC5hYnMod2luZG93c1N1YkRldmljZUlkLmxlbmd0aCAtIG52aWRpYVN1YkRldmljZUlkLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICBpZiAod2luZG93c1N1YkRldmljZUlkLmxlbmd0aCA+IG52aWRpYVN1YkRldmljZUlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aERpZmZlcmVuY2U7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIG52aWRpYVN1YkRldmljZUlkID0gJzAnICsgbnZpZGlhU3ViRGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93c1N1YkRldmljZUlkLmxlbmd0aCA8IG52aWRpYVN1YkRldmljZUlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aERpZmZlcmVuY2U7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd3NTdWJEZXZpY2VJZCA9ICcwJyArIHdpbmRvd3NTdWJEZXZpY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NTdWJEZXZpY2VJZCA9PT0gbnZpZGlhU3ViRGV2aWNlSWQ7XG4gICAgICAgICAgICAgICAgfSkgfHwge30pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZGlzcGxheXNcbiAgICAgICAgICAgIGxldCBkc2VjdGlvbnMgPSBkYXRhWzJdLnJlcGxhY2UoL1xcci9nLCAnJykuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgIC8vIHJlc3VsdC5kaXNwbGF5cyA9IHBhcnNlTGluZXNXaW5kb3dzRGlzcGxheXMoZHNlY3Rpb25zKTtcbiAgICAgICAgICAgIGlmIChkc2VjdGlvbnNbMF0udHJpbSgpID09PSAnJykgeyBkc2VjdGlvbnMuc2hpZnQoKTsgfVxuICAgICAgICAgICAgaWYgKGRzZWN0aW9ucy5sZW5ndGggJiYgZHNlY3Rpb25zW2RzZWN0aW9ucy5sZW5ndGggLSAxXS50cmltKCkgPT09ICcnKSB7IGRzZWN0aW9ucy5wb3AoKTsgfVxuXG4gICAgICAgICAgICAvLyBtb25pdG9yIChwb3dlcnNoZWxsKVxuICAgICAgICAgICAgbGV0IG1zZWN0aW9ucyA9IGRhdGFbM10ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgnQWN0aXZlICcpO1xuICAgICAgICAgICAgbXNlY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIGZvcm1zLnNjcmVlbnMgKHBvd2Vyc2hlbGwpXG4gICAgICAgICAgICBsZXQgc3NlY3Rpb25zID0gZGF0YVs0XS5yZXBsYWNlKC9cXHIvZywgJycpLnNwbGl0KCdCaXRzUGVyUGl4ZWwgJyk7XG4gICAgICAgICAgICBzc2VjdGlvbnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBwYXJhbXMgKHBvd2Vyc2hlbGwpIC0gdmlkZW8gdHlwZVxuICAgICAgICAgICAgbGV0IHRzZWN0aW9ucyA9IGRhdGFbNV0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgdHNlY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIG1vbml0b3IgSUQgKHBvd2Vyc2hlbGwpIC0gbW9kZWwgLyB2ZW5kb3JcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGRhdGFbNl0ucmVwbGFjZSgvXFxyL2csICcnKS5zcGxpdCgvXFxuLyk7XG4gICAgICAgICAgICBsZXQgaXNlY3Rpb25zID0gW107XG4gICAgICAgICAgICByZXMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBlbGVtZW50LnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICBpc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICB2ZW5kb3I6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgY29kZTogcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICBtb2RlbDogcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICBzZXJpYWw6IHBhcnRzWzNdLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZDogcGFydHNbNF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5cyA9IHBhcnNlTGluZXNXaW5kb3dzRGlzcGxheXNQb3dlcnNoZWxsKHNzZWN0aW9ucywgbXNlY3Rpb25zLCBkc2VjdGlvbnMsIHRzZWN0aW9ucywgaXNlY3Rpb25zKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kaXNwbGF5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKF9yZXNvbHV0aW9uWCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1swXS5yZXNvbHV0aW9uWCA9IF9yZXNvbHV0aW9uWDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kaXNwbGF5c1swXS5jdXJyZW50UmVzWCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzWzBdLmN1cnJlbnRSZXNYID0gX3Jlc29sdXRpb25YO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3Jlc29sdXRpb25ZKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzWzBdLnJlc29sdXRpb25ZID0gX3Jlc29sdXRpb25ZO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGlzcGxheXNbMF0uY3VycmVudFJlc1kgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwbGF5c1swXS5jdXJyZW50UmVzWSA9IF9yZXNvbHV0aW9uWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKF9waXhlbERlcHRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzWzBdLnBpeGVsRGVwdGggPSBfcGl4ZWxEZXB0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmRpc3BsYXlzID0gcmVzdWx0LmRpc3BsYXlzLm1hcChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKF9yZWZyZXNoUmF0ZSAmJiAhZWxlbWVudC5jdXJyZW50UmVmcmVzaFJhdGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmN1cnJlbnRSZWZyZXNoUmF0ZSA9IF9yZWZyZXNoUmF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNXaW5kb3dzQ29udHJvbGxlcnMoc2VjdGlvbnMsIHZlY3Rpb25zKSB7XG4gICAgY29uc3QgbWVtb3J5U2l6ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdmVjdGlvbnMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlY3Rpb25zLCBpKSkge1xuICAgICAgICBpZiAodmVjdGlvbnNbaV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gdmVjdGlvbnNbaV0udHJpbSgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBjb25zdCBtYXRjaGluZ0RldmljZUlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01hdGNoaW5nRGV2aWNlSWQnKS5tYXRjaCgvUENJXFxcXChWRU5fWzAtOUEtRl17NH0pJihERVZfWzAtOUEtRl17NH0pKD86JihTVUJTWVNfWzAtOUEtRl17OH0pKT8oPzomKFJFVl9bMC05QS1GXXsyfSkpPy9pKTtcbiAgICAgICAgICBpZiAobWF0Y2hpbmdEZXZpY2VJZCkge1xuICAgICAgICAgICAgY29uc3QgcXVhZFdvcmRtZW1vcnlTaXplID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0hhcmR3YXJlSW5mb3JtYXRpb24ucXdNZW1vcnlTaXplJykpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihxdWFkV29yZG1lbW9yeVNpemUpKSB7XG4gICAgICAgICAgICAgIGxldCBkZXZpY2VJZCA9IG1hdGNoaW5nRGV2aWNlSWRbMV0udG9VcHBlckNhc2UoKSArICcmJyArIG1hdGNoaW5nRGV2aWNlSWRbMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nRGV2aWNlSWRbM10pIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCArPSAnJicgKyBtYXRjaGluZ0RldmljZUlkWzNdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nRGV2aWNlSWRbNF0pIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZCArPSAnJicgKyBtYXRjaGluZ0RldmljZUlkWzRdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWVtb3J5U2l6ZXNbZGV2aWNlSWRdID0gcXVhZFdvcmRtZW1vcnlTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjb250cm9sbGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gc2VjdGlvbnMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlY3Rpb25zLCBpKSkge1xuICAgICAgICBpZiAoc2VjdGlvbnNbaV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHNlY3Rpb25zW2ldLnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgbGV0IHBucERldmljZUlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BOUERldmljZUlEJywgJzonKS5tYXRjaCgvUENJXFxcXChWRU5fWzAtOUEtRl17NH0pJihERVZfWzAtOUEtRl17NH0pKD86JihTVUJTWVNfWzAtOUEtRl17OH0pKT8oPzomKFJFVl9bMC05QS1GXXsyfSkpPy9pKTtcbiAgICAgICAgICBsZXQgc3ViRGV2aWNlSWQgPSBudWxsO1xuICAgICAgICAgIGxldCBtZW1vcnlTaXplID0gbnVsbDtcbiAgICAgICAgICBpZiAocG5wRGV2aWNlSWQpIHtcbiAgICAgICAgICAgIHN1YkRldmljZUlkID0gcG5wRGV2aWNlSWRbM10gfHwgJyc7XG4gICAgICAgICAgICBpZiAoc3ViRGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgc3ViRGV2aWNlSWQgPSBzdWJEZXZpY2VJZC5zcGxpdCgnXycpWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaCBQQ0kgZGV2aWNlIGlkZW50aWZpZXIgKHRoZXJlJ3MgYW4gb3JkZXIgb2YgaW5jcmVhc2luZyBnZW5lcmFsaXR5KTpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3MtaGFyZHdhcmUvZHJpdmVycy9pbnN0YWxsL2lkZW50aWZpZXJzLWZvci1wY2ktZGV2aWNlc1xuXG4gICAgICAgICAgICAvLyBQQ0lcXFZFTl92KDQpJkRFVl9kKDQpJlNVQlNZU19zKDQpbig0KSZSRVZfcigyKVxuICAgICAgICAgICAgaWYgKG1lbW9yeVNpemUgPT0gbnVsbCAmJiBwbnBEZXZpY2VJZFszXSAmJiBwbnBEZXZpY2VJZFs0XSkge1xuICAgICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IHBucERldmljZUlkWzFdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFsyXS50b1VwcGVyQ2FzZSgpICsgJyYnICsgcG5wRGV2aWNlSWRbM10udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzRdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW9yeVNpemVzLCBkZXZpY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gbWVtb3J5U2l6ZXNbZGV2aWNlSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBDSVxcVkVOX3YoNCkmREVWX2QoNCkmU1VCU1lTX3MoNCluKDQpXG4gICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA9PSBudWxsICYmIHBucERldmljZUlkWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcG5wRGV2aWNlSWRbMV0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzJdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFszXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChtZW1vcnlTaXplcywgZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5U2l6ZSA9IG1lbW9yeVNpemVzW2RldmljZUlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQQ0lcXFZFTl92KDQpJkRFVl9kKDQpJlJFVl9yKDIpXG4gICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA9PSBudWxsICYmIHBucERldmljZUlkWzRdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcG5wRGV2aWNlSWRbMV0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzJdLnRvVXBwZXJDYXNlKCkgKyAnJicgKyBwbnBEZXZpY2VJZFs0XS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChtZW1vcnlTaXplcywgZGV2aWNlSWQpKSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5U2l6ZSA9IG1lbW9yeVNpemVzW2RldmljZUlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQQ0lcXFZFTl92KDQpJkRFVl9kKDQpXG4gICAgICAgICAgICBpZiAobWVtb3J5U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gcG5wRGV2aWNlSWRbMV0udG9VcHBlckNhc2UoKSArICcmJyArIHBucERldmljZUlkWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW9yeVNpemVzLCBkZXZpY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBtZW1vcnlTaXplID0gbWVtb3J5U2l6ZXNbZGV2aWNlSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udHJvbGxlcnMucHVzaCh7XG4gICAgICAgICAgICB2ZW5kb3I6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBZGFwdGVyQ29tcGF0aWJpbGl0eScsICc6JyksXG4gICAgICAgICAgICBtb2RlbDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ25hbWUnLCAnOicpLFxuICAgICAgICAgICAgYnVzOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUE5QRGV2aWNlSUQnLCAnOicpLnN0YXJ0c1dpdGgoJ1BDSScpID8gJ1BDSScgOiAnJyxcbiAgICAgICAgICAgIHZyYW06IChtZW1vcnlTaXplID09IG51bGwgPyB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdBZGFwdGVyUkFNJywgJzonKSkgOiBtZW1vcnlTaXplKSAvIDEwMjQgLyAxMDI0LFxuICAgICAgICAgICAgdnJhbUR5bmFtaWM6ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVmlkZW9NZW1vcnlUeXBlJywgJzonKSA9PT0gJzInKSxcbiAgICAgICAgICAgIHN1YkRldmljZUlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3Jlc29sdXRpb25YID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3VycmVudEhvcml6b250YWxSZXNvbHV0aW9uJywgJzonKSkgfHwgX3Jlc29sdXRpb25YO1xuICAgICAgICAgIF9yZXNvbHV0aW9uWSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0N1cnJlbnRWZXJ0aWNhbFJlc29sdXRpb24nLCAnOicpKSB8fCBfcmVzb2x1dGlvblk7XG4gICAgICAgICAgX3JlZnJlc2hSYXRlID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3VycmVudFJlZnJlc2hSYXRlJywgJzonKSkgfHwgX3JlZnJlc2hSYXRlO1xuICAgICAgICAgIF9waXhlbERlcHRoID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3VycmVudEJpdHNQZXJQaXhlbCcsICc6JykpIHx8IF9waXhlbERlcHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGluZXNXaW5kb3dzRGlzcGxheXNQb3dlcnNoZWxsKHNzZWN0aW9ucywgbXNlY3Rpb25zLCBkc2VjdGlvbnMsIHRzZWN0aW9ucywgaXNlY3Rpb25zKSB7XG4gICAgbGV0IGRpc3BsYXlzID0gW107XG4gICAgbGV0IHZlbmRvciA9ICcnO1xuICAgIGxldCBtb2RlbCA9ICcnO1xuICAgIGxldCBkZXZpY2VJRCA9ICcnO1xuICAgIGxldCByZXNvbHV0aW9uWCA9IDA7XG4gICAgbGV0IHJlc29sdXRpb25ZID0gMDtcbiAgICBpZiAoZHNlY3Rpb25zICYmIGRzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGxldCBsaW5lc0Rpc3BsYXkgPSBkc2VjdGlvbnNbMF0uc3BsaXQoJ1xcbicpO1xuICAgICAgdmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lc0Rpc3BsYXksICdNb25pdG9yTWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgIG1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lc0Rpc3BsYXksICdOYW1lJywgJzonKTtcbiAgICAgIGRldmljZUlEID0gdXRpbC5nZXRWYWx1ZShsaW5lc0Rpc3BsYXksICdQTlBEZXZpY2VJRCcsICc6JykucmVwbGFjZSgvJmFtcDsvZywgJyYnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmVzb2x1dGlvblggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXNEaXNwbGF5LCAnU2NyZWVuV2lkdGgnLCAnOicpKTtcbiAgICAgIHJlc29sdXRpb25ZID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzRGlzcGxheSwgJ1NjcmVlbkhlaWdodCcsICc6JykpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNzZWN0aW9uc1tpXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgIHNzZWN0aW9uc1tpXSA9ICdCaXRzUGVyUGl4ZWwgJyArIHNzZWN0aW9uc1tpXTtcbiAgICAgICAgbXNlY3Rpb25zW2ldID0gJ0FjdGl2ZSAnICsgbXNlY3Rpb25zW2ldO1xuICAgICAgICAvLyB0c2VjdGlvbnMgY2FuIGJlIGVtcHR5IE9SIHVuZGVmaW5lZCBvbiBlYXJsaWVyIHZlcnNpb25zIG9mIHBvd2Vyc2hlbGwgKDw9Mi4wKVxuICAgICAgICAvLyBUYWcgY29ubmVjdGlvbiB0eXBlIGFzIFVOS05PV04gYnkgZGVmYXVsdCBpZiB0aGlzIGluZm9ybWF0aW9uIGlzIG1pc3NpbmdcbiAgICAgICAgaWYgKHRzZWN0aW9ucy5sZW5ndGggPT09IDAgfHwgdHNlY3Rpb25zW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0c2VjdGlvbnNbaV0gPSAnVW5rbm93bic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVzU2NyZWVuID0gc3NlY3Rpb25zW2ldLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgbGV0IGxpbmVzTW9uaXRvciA9IG1zZWN0aW9uc1tpXS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgbGV0IGxpbmVzQ29ubmVjdGlvbiA9IHRzZWN0aW9uc1tpXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGJpdHNQZXJQaXhlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXNTY3JlZW4sICdCaXRzUGVyUGl4ZWwnKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdXRpbC5nZXRWYWx1ZShsaW5lc1NjcmVlbiwgJ0JvdW5kcycpLnJlcGxhY2UoJ3snLCAnJykucmVwbGFjZSgnfScsICcnKS5yZXBsYWNlKC89L2csICc6Jykuc3BsaXQoJywnKTtcbiAgICAgICAgY29uc3QgcHJpbWFyeSA9IHV0aWwuZ2V0VmFsdWUobGluZXNTY3JlZW4sICdQcmltYXJ5Jyk7XG4gICAgICAgIGNvbnN0IHNpemVYID0gdXRpbC5nZXRWYWx1ZShsaW5lc01vbml0b3IsICdNYXhIb3Jpem9udGFsSW1hZ2VTaXplJyk7XG4gICAgICAgIGNvbnN0IHNpemVZID0gdXRpbC5nZXRWYWx1ZShsaW5lc01vbml0b3IsICdNYXhWZXJ0aWNhbEltYWdlU2l6ZScpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZU5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzTW9uaXRvciwgJ0luc3RhbmNlTmFtZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHZpZGVvT3V0cHV0VGVjaG5vbG9neSA9IHV0aWwuZ2V0VmFsdWUobGluZXNDb25uZWN0aW9uLCAnVmlkZW9PdXRwdXRUZWNobm9sb2d5Jyk7XG4gICAgICAgIGNvbnN0IGRldmljZU5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzU2NyZWVuLCAnRGV2aWNlTmFtZScpO1xuICAgICAgICBsZXQgZGlzcGxheVZlbmRvciA9ICcnO1xuICAgICAgICBsZXQgZGlzcGxheU1vZGVsID0gJyc7XG4gICAgICAgIGlzZWN0aW9ucy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50Lmluc3RhbmNlSWQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGluc3RhbmNlTmFtZSkgJiYgdmVuZG9yLnN0YXJ0c1dpdGgoJygnKSAmJiBtb2RlbC5zdGFydHNXaXRoKCdQblAnKSkge1xuICAgICAgICAgICAgZGlzcGxheVZlbmRvciA9IGVsZW1lbnQudmVuZG9yO1xuICAgICAgICAgICAgZGlzcGxheU1vZGVsID0gZWxlbWVudC5tb2RlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwbGF5cy5wdXNoKHtcbiAgICAgICAgICB2ZW5kb3I6IGluc3RhbmNlTmFtZS5zdGFydHNXaXRoKGRldmljZUlEKSAmJiBkaXNwbGF5VmVuZG9yID09PSAnJyA/IHZlbmRvciA6IGRpc3BsYXlWZW5kb3IsXG4gICAgICAgICAgbW9kZWw6IGluc3RhbmNlTmFtZS5zdGFydHNXaXRoKGRldmljZUlEKSAmJiBkaXNwbGF5TW9kZWwgPT09ICcnID8gbW9kZWwgOiBkaXNwbGF5TW9kZWwsXG4gICAgICAgICAgZGV2aWNlTmFtZSxcbiAgICAgICAgICBtYWluOiBwcmltYXJ5LnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyxcbiAgICAgICAgICBidWlsdGluOiB2aWRlb091dHB1dFRlY2hub2xvZ3kgPT09ICcyMTQ3NDgzNjQ4JyxcbiAgICAgICAgICBjb25uZWN0aW9uOiB2aWRlb091dHB1dFRlY2hub2xvZ3kgJiYgdmlkZW9UeXBlc1t2aWRlb091dHB1dFRlY2hub2xvZ3ldID8gdmlkZW9UeXBlc1t2aWRlb091dHB1dFRlY2hub2xvZ3ldIDogJycsXG4gICAgICAgICAgcmVzb2x1dGlvblg6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdXaWR0aCcsICc6JykpLFxuICAgICAgICAgIHJlc29sdXRpb25ZOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnSGVpZ2h0JywgJzonKSksXG4gICAgICAgICAgc2l6ZVg6IHNpemVYID8gcGFyc2VJbnQoc2l6ZVgsIDEwKSA6IG51bGwsXG4gICAgICAgICAgc2l6ZVk6IHNpemVZID8gcGFyc2VJbnQoc2l6ZVksIDEwKSA6IG51bGwsXG4gICAgICAgICAgcGl4ZWxEZXB0aDogYml0c1BlclBpeGVsLFxuICAgICAgICAgIGN1cnJlbnRSZXNYOiB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUoYm91bmRzLCAnV2lkdGgnLCAnOicpKSxcbiAgICAgICAgICBjdXJyZW50UmVzWTogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ0hlaWdodCcsICc6JykpLFxuICAgICAgICAgIHBvc2l0aW9uWDogdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGJvdW5kcywgJ1gnLCAnOicpKSxcbiAgICAgICAgICBwb3NpdGlvblk6IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShib3VuZHMsICdZJywgJzonKSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3NlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGlzcGxheXMucHVzaCh7XG4gICAgICAgIHZlbmRvcixcbiAgICAgICAgbW9kZWwsXG4gICAgICAgIG1haW46IHRydWUsXG4gICAgICAgIHNpemVYOiBudWxsLFxuICAgICAgICBzaXplWTogbnVsbCxcbiAgICAgICAgcmVzb2x1dGlvblgsXG4gICAgICAgIHJlc29sdXRpb25ZLFxuICAgICAgICBwaXhlbERlcHRoOiBudWxsLFxuICAgICAgICBjdXJyZW50UmVzWDogcmVzb2x1dGlvblgsXG4gICAgICAgIGN1cnJlbnRSZXNZOiByZXNvbHV0aW9uWSxcbiAgICAgICAgcG9zaXRpb25YOiAwLFxuICAgICAgICBwb3NpdGlvblk6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGlzcGxheXM7XG4gIH1cbn1cblxuZXhwb3J0cy5ncmFwaGljcyA9IGdyYXBoaWNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBpbmRleC5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb250cmlidXRvcnM6ICBHdWlsbGF1bWUgTGVncmFpbiAoaHR0cHM6Ly9naXRodWIuY29tL2dsZWdyYWluKVxuLy8gICAgICAgICAgICAgICAgUmljY2FyZG8gTm92YWdsaWEgKGh0dHBzOi8vZ2l0aHViLmNvbS9yaWNoeTI0KVxuLy8gICAgICAgICAgICAgICAgUXVlbnRpbiBCdXN1dHRpbCAoaHR0cHM6Ly9naXRodWIuY29tL0J1enV0KVxuLy8gICAgICAgICAgICAgICAgTGFwc2lvIChodHRwczovL2dpdGh1Yi5jb20vbGFwc2lvKVxuLy8gICAgICAgICAgICAgICAgY3N5IChodHRwczovL2dpdGh1Yi5jb20vY3N5MTk4Mylcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXBlbmRlbmNpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgbGliX3ZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3Qgc3lzdGVtID0gcmVxdWlyZSgnLi9zeXN0ZW0nKTtcbmNvbnN0IG9zSW5mbyA9IHJlcXVpcmUoJy4vb3NpbmZvJyk7XG5jb25zdCBjcHUgPSByZXF1aXJlKCcuL2NwdScpO1xuY29uc3QgbWVtb3J5ID0gcmVxdWlyZSgnLi9tZW1vcnknKTtcbmNvbnN0IGJhdHRlcnkgPSByZXF1aXJlKCcuL2JhdHRlcnknKTtcbmNvbnN0IGdyYXBoaWNzID0gcmVxdWlyZSgnLi9ncmFwaGljcycpO1xuY29uc3QgZmlsZXN5c3RlbSA9IHJlcXVpcmUoJy4vZmlsZXN5c3RlbScpO1xuY29uc3QgbmV0d29yayA9IHJlcXVpcmUoJy4vbmV0d29yaycpO1xuY29uc3Qgd2lmaSA9IHJlcXVpcmUoJy4vd2lmaScpO1xuY29uc3QgcHJvY2Vzc2VzID0gcmVxdWlyZSgnLi9wcm9jZXNzZXMnKTtcbmNvbnN0IHVzZXJzID0gcmVxdWlyZSgnLi91c2VycycpO1xuY29uc3QgaW50ZXJuZXQgPSByZXF1aXJlKCcuL2ludGVybmV0Jyk7XG5jb25zdCBkb2NrZXIgPSByZXF1aXJlKCcuL2RvY2tlcicpO1xuY29uc3QgdmJveCA9IHJlcXVpcmUoJy4vdmlydHVhbGJveCcpO1xuY29uc3QgcHJpbnRlciA9IHJlcXVpcmUoJy4vcHJpbnRlcicpO1xuY29uc3QgdXNiID0gcmVxdWlyZSgnLi91c2InKTtcbmNvbnN0IGF1ZGlvID0gcmVxdWlyZSgnLi9hdWRpbycpO1xuY29uc3QgYmx1ZXRvb3RoID0gcmVxdWlyZSgnLi9ibHVldG9vdGgnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpbml0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmlmIChfd2luZG93cykge1xuICB1dGlsLmdldENvZGVwYWdlKCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdlbmVyYWxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgcmV0dXJuIGxpYl92ZXJzaW9uO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHZXQgc3RhdGljIGFuZCBkeW5hbWljIGRhdGEgKGFsbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdldCBzdGF0aWMgZGF0YSAtIHRoZXkgc2hvdWxkIG5vdCBjaGFuZ2UgdW50aWwgcmVzdGFydGVkXG5cbmZ1bmN0aW9uIGdldFN0YXRpY0RhdGEoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IGRhdGEgPSB7fTtcblxuICAgICAgZGF0YS52ZXJzaW9uID0gdmVyc2lvbigpO1xuXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHN5c3RlbS5zeXN0ZW0oKSxcbiAgICAgICAgc3lzdGVtLmJpb3MoKSxcbiAgICAgICAgc3lzdGVtLmJhc2Vib2FyZCgpLFxuICAgICAgICBzeXN0ZW0uY2hhc3NpcygpLFxuICAgICAgICBvc0luZm8ub3NJbmZvKCksXG4gICAgICAgIG9zSW5mby51dWlkKCksXG4gICAgICAgIG9zSW5mby52ZXJzaW9ucygpLFxuICAgICAgICBjcHUuY3B1KCksXG4gICAgICAgIGNwdS5jcHVGbGFncygpLFxuICAgICAgICBncmFwaGljcy5ncmFwaGljcygpLFxuICAgICAgICBuZXR3b3JrLm5ldHdvcmtJbnRlcmZhY2VzKCksXG4gICAgICAgIG1lbW9yeS5tZW1MYXlvdXQoKSxcbiAgICAgICAgZmlsZXN5c3RlbS5kaXNrTGF5b3V0KClcbiAgICAgIF0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLnN5c3RlbSA9IHJlc1swXTtcbiAgICAgICAgZGF0YS5iaW9zID0gcmVzWzFdO1xuICAgICAgICBkYXRhLmJhc2Vib2FyZCA9IHJlc1syXTtcbiAgICAgICAgZGF0YS5jaGFzc2lzID0gcmVzWzNdO1xuICAgICAgICBkYXRhLm9zID0gcmVzWzRdO1xuICAgICAgICBkYXRhLnV1aWQgPSByZXNbNV07XG4gICAgICAgIGRhdGEudmVyc2lvbnMgPSByZXNbNl07XG4gICAgICAgIGRhdGEuY3B1ID0gcmVzWzddO1xuICAgICAgICBkYXRhLmNwdS5mbGFncyA9IHJlc1s4XTtcbiAgICAgICAgZGF0YS5ncmFwaGljcyA9IHJlc1s5XTtcbiAgICAgICAgZGF0YS5uZXQgPSByZXNbMTBdO1xuICAgICAgICBkYXRhLm1lbUxheW91dCA9IHJlc1sxMV07XG4gICAgICAgIGRhdGEuZGlza0xheW91dCA9IHJlc1sxMl07XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBnZXQgYWxsIGR5bmFtaWMgZGF0YSAtIGUuZy4gZm9yIG1vbml0b3JpbmcgYWdlbnRzXG4vLyBtYXkgdGFrZSBzb21lIHNlY29uZHMgdG8gZ2V0IGFsbCBkYXRhXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gMiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgbmVlZGVkXG4vLyAtIHNydjogXHRcdGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHNlcnZpY2VzIHRvIG1vbml0b3IgZS5nLiBcIm15c3FsLCBhcGFjaGUsIHBvc3RncmVzcWxcIlxuLy8gLSBpZmFjZTpcdGRlZmluZSBuZXR3b3JrIGludGVyZmFjZSBmb3Igd2hpY2ggeW91IGxpa2UgdG8gbW9uaXRvciBuZXR3b3JrIHNwZWVkIGUuZy4gXCJldGgwXCJcblxuZnVuY3Rpb24gZ2V0RHluYW1pY0RhdGEoc3J2LCBpZmFjZSwgY2FsbGJhY2spIHtcblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGlmYWNlKSkge1xuICAgIGNhbGxiYWNrID0gaWZhY2U7XG4gICAgaWZhY2UgPSAnJztcbiAgfVxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHNydikpIHtcbiAgICBjYWxsYmFjayA9IHNydjtcbiAgICBzcnYgPSAnJztcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBpZmFjZSA9IGlmYWNlIHx8IG5ldHdvcmsuZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcbiAgICAgIHNydiA9IHNydiB8fCAnJztcblxuICAgICAgLy8gdXNlIGNsb3N1cmUgdG8gdHJhY2sgxpIgY29tcGxldGlvblxuICAgICAgbGV0IGZ1bmN0aW9uUHJvY2Vzc2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHRvdGFsRnVuY3Rpb25zID0gMTU7XG4gICAgICAgIGlmIChfd2luZG93cykgeyB0b3RhbEZ1bmN0aW9ucyA9IDEzOyB9XG4gICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7IHRvdGFsRnVuY3Rpb25zID0gMTE7IH1cbiAgICAgICAgaWYgKF9zdW5vcykgeyB0b3RhbEZ1bmN0aW9ucyA9IDY7IH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICgtLXRvdGFsRnVuY3Rpb25zID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKCk7XG5cbiAgICAgIGxldCBkYXRhID0ge307XG5cbiAgICAgIC8vIGdldCB0aW1lXG4gICAgICBkYXRhLnRpbWUgPSBvc0luZm8udGltZSgpO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAgdmVyc2lvbnNcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgdmVyc2lvbnMubm9kZVxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICB2ZXJzaW9ucy52OFxuICAgICAgICovXG4gICAgICBkYXRhLm5vZGUgPSBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gICAgICBkYXRhLnY4ID0gcHJvY2Vzcy52ZXJzaW9ucy52ODtcblxuICAgICAgY3B1LmNwdUN1cnJlbnRTcGVlZCgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLmNwdUN1cnJlbnRTcGVlZCA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB1c2Vycy51c2VycygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLnVzZXJzID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHByb2Nlc3Nlcy5wcm9jZXNzZXMoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgZGF0YS5wcm9jZXNzZXMgPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcblxuICAgICAgY3B1LmN1cnJlbnRMb2FkKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGRhdGEuY3VycmVudExvYWQgPSByZXM7XG4gICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFfc3Vub3MpIHtcbiAgICAgICAgY3B1LmNwdVRlbXBlcmF0dXJlKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS50ZW1wID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9vcGVuYnNkICYmICFfZnJlZWJzZCAmJiAhX25ldGJzZCAmJiAhX3N1bm9zKSB7XG4gICAgICAgIG5ldHdvcmsubmV0d29ya1N0YXRzKGlmYWNlKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLm5ldHdvcmtTdGF0cyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfc3Vub3MpIHtcbiAgICAgICAgbmV0d29yay5uZXR3b3JrQ29ubmVjdGlvbnMoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLm5ldHdvcmtDb25uZWN0aW9ucyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbWVtb3J5Lm1lbSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLm1lbSA9IHJlcztcbiAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIV9zdW5vcykge1xuICAgICAgICBiYXR0ZXJ5KCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgZGF0YS5iYXR0ZXJ5ID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9zdW5vcykge1xuICAgICAgICBwcm9jZXNzZXMuc2VydmljZXMoc3J2KS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLnNlcnZpY2VzID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9zdW5vcykge1xuICAgICAgICBmaWxlc3lzdGVtLmZzU2l6ZSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEuZnNTaXplID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV93aW5kb3dzICYmICFfb3BlbmJzZCAmJiAhX2ZyZWVic2QgJiYgIV9uZXRic2QgJiYgIV9zdW5vcykge1xuICAgICAgICBmaWxlc3lzdGVtLmZzU3RhdHMoKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBkYXRhLmZzU3RhdHMgPSByZXM7XG4gICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghX3dpbmRvd3MgJiYgIV9vcGVuYnNkICYmICFfZnJlZWJzZCAmJiAhX25ldGJzZCAmJiAhX3N1bm9zKSB7XG4gICAgICAgIGZpbGVzeXN0ZW0uZGlza3NJTygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEuZGlza3NJTyA9IHJlcztcbiAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfb3BlbmJzZCAmJiAhX2ZyZWVic2QgJiYgIV9uZXRic2QgJiYgIV9zdW5vcykge1xuICAgICAgICB3aWZpLndpZmlOZXR3b3JrcygpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGRhdGEud2lmaU5ldHdvcmtzID0gcmVzO1xuICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbnRlcm5ldC5pbmV0TGF0ZW5jeSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhLmluZXRMYXRlbmN5ID0gcmVzO1xuICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZ2V0IGFsbCBkYXRhIGF0IG9uY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAyIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBuZWVkZWRcbi8vIC0gc3J2OiBcdFx0Y29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc2VydmljZXMgdG8gbW9uaXRvciBlLmcuIFwibXlzcWwsIGFwYWNoZSwgcG9zdGdyZXNxbFwiXG4vLyAtIGlmYWNlOlx0ZGVmaW5lIG5ldHdvcmsgaW50ZXJmYWNlIGZvciB3aGljaCB5b3UgbGlrZSB0byBtb25pdG9yIG5ldHdvcmsgc3BlZWQgZS5nLiBcImV0aDBcIlxuXG5mdW5jdGlvbiBnZXRBbGxEYXRhKHNydiwgaWZhY2UsIGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgZGF0YSA9IHt9O1xuXG4gICAgICBpZiAoaWZhY2UgJiYgdXRpbC5pc0Z1bmN0aW9uKGlmYWNlKSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBpZmFjZTtcbiAgICAgICAgaWZhY2UgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHNydiAmJiB1dGlsLmlzRnVuY3Rpb24oc3J2KSAmJiAhaWZhY2UgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc3J2O1xuICAgICAgICBzcnYgPSAnJztcbiAgICAgICAgaWZhY2UgPSAnJztcbiAgICAgIH1cblxuICAgICAgZ2V0U3RhdGljRGF0YSgpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBkYXRhID0gcmVzO1xuICAgICAgICBnZXREeW5hbWljRGF0YShzcnYsIGlmYWNlKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcmVzKSB7XG4gICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgZGF0YVtrZXldID0gcmVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXQodmFsdWVPYmplY3QsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3QgYWxsUHJvbWlzZXMgPSBPYmplY3Qua2V5cyh2YWx1ZU9iamVjdClcbiAgICAgICAgLmZpbHRlcihmdW5jID0+ICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIGZ1bmMpKSlcbiAgICAgICAgLm1hcChmdW5jID0+IHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZU9iamVjdFtmdW5jXS5zdWJzdHJpbmcodmFsdWVPYmplY3RbZnVuY10ubGFzdEluZGV4T2YoJygnKSArIDEsIHZhbHVlT2JqZWN0W2Z1bmNdLmxhc3RJbmRleE9mKCcpJykpO1xuICAgICAgICAgIGxldCBmdW5jV2l0aG91dFBhcmFtcyA9IGZ1bmMuaW5kZXhPZignKScpID49IDAgPyBmdW5jLnNwbGl0KCcpJylbMV0udHJpbSgpIDogZnVuYztcbiAgICAgICAgICBmdW5jV2l0aG91dFBhcmFtcyA9IGZ1bmMuaW5kZXhPZignfCcpID49IDAgPyBmdW5jLnNwbGl0KCd8JylbMF0udHJpbSgpIDogZnVuY1dpdGhvdXRQYXJhbXM7XG4gICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHNbZnVuY1dpdGhvdXRQYXJhbXNdKHBhcmFtcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzW2Z1bmNXaXRob3V0UGFyYW1zXSgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgUHJvbWlzZS5hbGwoYWxsUHJvbWlzZXMpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHZhbHVlT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWVPYmplY3QsIGtleSkgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBrZXkpICYmIGRhdGEubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlT2JqZWN0W2tleV0gPT09ICcqJyB8fCB2YWx1ZU9iamVjdFtrZXldID09PSAnYWxsJykge1xuICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGRhdGFbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQga2V5cyA9IHZhbHVlT2JqZWN0W2tleV07XG4gICAgICAgICAgICAgIGxldCBmaWx0ZXIgPSAnJztcbiAgICAgICAgICAgICAgbGV0IGZpbHRlclBhcnRzID0gW107XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBwYXJhbXNcbiAgICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZignKScpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXlzID0ga2V5cy5zcGxpdCgnKScpWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBleHRyYWN0IGZpbHRlciBhbmQgcmVtb3ZlIGl0IGZyb20ga2V5c1xuICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCd8JykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IGtleXMuc3BsaXQoJ3wnKVsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgZmlsdGVyUGFydHMgPSBmaWx0ZXIuc3BsaXQoJzonKTtcblxuICAgICAgICAgICAgICAgIGtleXMgPSBrZXlzLnNwbGl0KCd8JylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleXMgPSBrZXlzLnJlcGxhY2UoLywvZywgJyAnKS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGlmIChkYXRhW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBpcyBpbiBhbiBhcnJheSwgZ28gdGhyb3VnaCBhbGwgZWxlbWVudHMgb2YgYXJyYXkgYW5kIHBpY2sgb25seSB0aGUgcmlnaHQgb25lc1xuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbEFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgICBkYXRhW2ldLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0aWFsUmVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAoa2V5c1swXSA9PT0gJyonIHx8IGtleXNbMF0gPT09ICdhbGwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxSZXMgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnQsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxSZXNba10gPSBlbGVtZW50W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgZmlsdGVyLCB0aGVuIGp1c3QgdGFrZSB0aG9zZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmIGZpbHRlclBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcnRpYWxSZXMsIGZpbHRlclBhcnRzWzBdLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHBhcnRpYWxSZXNbZmlsdGVyUGFydHNbMF0udHJpbSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHBhcnNlRmxvYXQoZmlsdGVyUGFydHNbMV0udHJpbSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxBcnJheS5wdXNoKHBhcnRpYWxSZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC50b0xvd2VyQ2FzZSgpID09PSBmaWx0ZXJQYXJ0c1sxXS50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxBcnJheS5wdXNoKHBhcnRpYWxSZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxBcnJheS5wdXNoKHBhcnRpYWxSZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwYXJ0aWFsQXJyYXk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxSZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YVtpXSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUmVzW2tdID0gZGF0YVtpXVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHBhcnRpYWxSZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlT2JqZWN0LCBpbnRlcnZhbCwgY2FsbGJhY2spIHtcbiAgbGV0IF9kYXRhID0gbnVsbDtcblxuICBjb25zdCByZXN1bHQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgZ2V0KHZhbHVlT2JqZWN0KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoX2RhdGEpICE9PSBKU09OLnN0cmluZ2lmeShkYXRhKSkge1xuICAgICAgICBfZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgaW50ZXJ2YWwpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBleHBvcnQgYWxsIGxpYnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuc3lzdGVtID0gc3lzdGVtLnN5c3RlbTtcbmV4cG9ydHMuYmlvcyA9IHN5c3RlbS5iaW9zO1xuZXhwb3J0cy5iYXNlYm9hcmQgPSBzeXN0ZW0uYmFzZWJvYXJkO1xuZXhwb3J0cy5jaGFzc2lzID0gc3lzdGVtLmNoYXNzaXM7XG5cbmV4cG9ydHMudGltZSA9IG9zSW5mby50aW1lO1xuZXhwb3J0cy5vc0luZm8gPSBvc0luZm8ub3NJbmZvO1xuZXhwb3J0cy52ZXJzaW9ucyA9IG9zSW5mby52ZXJzaW9ucztcbmV4cG9ydHMuc2hlbGwgPSBvc0luZm8uc2hlbGw7XG5leHBvcnRzLnV1aWQgPSBvc0luZm8udXVpZDtcblxuZXhwb3J0cy5jcHUgPSBjcHUuY3B1O1xuZXhwb3J0cy5jcHVGbGFncyA9IGNwdS5jcHVGbGFncztcbmV4cG9ydHMuY3B1Q2FjaGUgPSBjcHUuY3B1Q2FjaGU7XG5leHBvcnRzLmNwdUN1cnJlbnRTcGVlZCA9IGNwdS5jcHVDdXJyZW50U3BlZWQ7XG5leHBvcnRzLmNwdVRlbXBlcmF0dXJlID0gY3B1LmNwdVRlbXBlcmF0dXJlO1xuZXhwb3J0cy5jdXJyZW50TG9hZCA9IGNwdS5jdXJyZW50TG9hZDtcbmV4cG9ydHMuZnVsbExvYWQgPSBjcHUuZnVsbExvYWQ7XG5cbmV4cG9ydHMubWVtID0gbWVtb3J5Lm1lbTtcbmV4cG9ydHMubWVtTGF5b3V0ID0gbWVtb3J5Lm1lbUxheW91dDtcblxuZXhwb3J0cy5iYXR0ZXJ5ID0gYmF0dGVyeTtcblxuZXhwb3J0cy5ncmFwaGljcyA9IGdyYXBoaWNzLmdyYXBoaWNzO1xuXG5leHBvcnRzLmZzU2l6ZSA9IGZpbGVzeXN0ZW0uZnNTaXplO1xuZXhwb3J0cy5mc09wZW5GaWxlcyA9IGZpbGVzeXN0ZW0uZnNPcGVuRmlsZXM7XG5leHBvcnRzLmJsb2NrRGV2aWNlcyA9IGZpbGVzeXN0ZW0uYmxvY2tEZXZpY2VzO1xuZXhwb3J0cy5mc1N0YXRzID0gZmlsZXN5c3RlbS5mc1N0YXRzO1xuZXhwb3J0cy5kaXNrc0lPID0gZmlsZXN5c3RlbS5kaXNrc0lPO1xuZXhwb3J0cy5kaXNrTGF5b3V0ID0gZmlsZXN5c3RlbS5kaXNrTGF5b3V0O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VEZWZhdWx0ID0gbmV0d29yay5uZXR3b3JrSW50ZXJmYWNlRGVmYXVsdDtcbmV4cG9ydHMubmV0d29ya0dhdGV3YXlEZWZhdWx0ID0gbmV0d29yay5uZXR3b3JrR2F0ZXdheURlZmF1bHQ7XG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzID0gbmV0d29yay5uZXR3b3JrSW50ZXJmYWNlcztcbmV4cG9ydHMubmV0d29ya1N0YXRzID0gbmV0d29yay5uZXR3b3JrU3RhdHM7XG5leHBvcnRzLm5ldHdvcmtDb25uZWN0aW9ucyA9IG5ldHdvcmsubmV0d29ya0Nvbm5lY3Rpb25zO1xuXG5leHBvcnRzLndpZmlOZXR3b3JrcyA9IHdpZmkud2lmaU5ldHdvcmtzO1xuZXhwb3J0cy53aWZpSW50ZXJmYWNlcyA9IHdpZmkud2lmaUludGVyZmFjZXM7XG5leHBvcnRzLndpZmlDb25uZWN0aW9ucyA9IHdpZmkud2lmaUNvbm5lY3Rpb25zO1xuXG5leHBvcnRzLnNlcnZpY2VzID0gcHJvY2Vzc2VzLnNlcnZpY2VzO1xuZXhwb3J0cy5wcm9jZXNzZXMgPSBwcm9jZXNzZXMucHJvY2Vzc2VzO1xuZXhwb3J0cy5wcm9jZXNzTG9hZCA9IHByb2Nlc3Nlcy5wcm9jZXNzTG9hZDtcblxuZXhwb3J0cy51c2VycyA9IHVzZXJzLnVzZXJzO1xuXG5leHBvcnRzLmluZXRDaGVja3NpdGUgPSBpbnRlcm5ldC5pbmV0Q2hlY2tzaXRlO1xuZXhwb3J0cy5pbmV0TGF0ZW5jeSA9IGludGVybmV0LmluZXRMYXRlbmN5O1xuXG5leHBvcnRzLmRvY2tlckluZm8gPSBkb2NrZXIuZG9ja2VySW5mbztcbmV4cG9ydHMuZG9ja2VySW1hZ2VzID0gZG9ja2VyLmRvY2tlckltYWdlcztcbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVycyA9IGRvY2tlci5kb2NrZXJDb250YWluZXJzO1xuZXhwb3J0cy5kb2NrZXJDb250YWluZXJTdGF0cyA9IGRvY2tlci5kb2NrZXJDb250YWluZXJTdGF0cztcbmV4cG9ydHMuZG9ja2VyQ29udGFpbmVyUHJvY2Vzc2VzID0gZG9ja2VyLmRvY2tlckNvbnRhaW5lclByb2Nlc3NlcztcbmV4cG9ydHMuZG9ja2VyVm9sdW1lcyA9IGRvY2tlci5kb2NrZXJWb2x1bWVzO1xuZXhwb3J0cy5kb2NrZXJBbGwgPSBkb2NrZXIuZG9ja2VyQWxsO1xuXG5leHBvcnRzLnZib3hJbmZvID0gdmJveC52Ym94SW5mbztcblxuZXhwb3J0cy5wcmludGVyID0gcHJpbnRlci5wcmludGVyO1xuXG5leHBvcnRzLnVzYiA9IHVzYi51c2I7XG5cbmV4cG9ydHMuYXVkaW8gPSBhdWRpby5hdWRpbztcbmV4cG9ydHMuYmx1ZXRvb3RoRGV2aWNlcyA9IGJsdWV0b290aC5ibHVldG9vdGhEZXZpY2VzO1xuXG5leHBvcnRzLmdldFN0YXRpY0RhdGEgPSBnZXRTdGF0aWNEYXRhO1xuZXhwb3J0cy5nZXREeW5hbWljRGF0YSA9IGdldER5bmFtaWNEYXRhO1xuZXhwb3J0cy5nZXRBbGxEYXRhID0gZ2V0QWxsRGF0YTtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcblxuZXhwb3J0cy5wb3dlclNoZWxsU3RhcnQgPSB1dGlsLnBvd2VyU2hlbGxTdGFydDtcbmV4cG9ydHMucG93ZXJTaGVsbFJlbGVhc2UgPSB1dGlsLnBvd2VyU2hlbGxSZWxlYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBpbnRlcm5ldC5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDEyLiBJbnRlcm5ldFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBjb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY2hlY2sgaWYgZXh0ZXJuYWwgc2l0ZSBpcyBhdmFpbGFibGVcblxuZnVuY3Rpb24gaW5ldENoZWNrc2l0ZSh1cmwsIGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgbXM6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGxldCB1cmxTYW5pdGl6ZWQgPSAnJztcbiAgICAgIGNvbnN0IHMgPSB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcodXJsLCB0cnVlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICBpZiAoc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc1tpXS5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgICAgY29uc3Qgc2wgPSBzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHNsICYmIHNsWzBdICYmICFzbFsxXSAmJiBzbFswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHVybFNhbml0aXplZCA9IHVybFNhbml0aXplZCArIHNsWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnVybCA9IHVybFNhbml0aXplZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh1cmxTYW5pdGl6ZWQgJiYgIXV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpKSB7XG4gICAgICAgICAgdXJsU2FuaXRpemVkLl9fcHJvdG9fXy5zdGFydHNXaXRoID0gdXRpbC5zdHJpbmdTdGFydFdpdGg7XG4gICAgICAgICAgaWYgKHVybFNhbml0aXplZC5zdGFydHNXaXRoKCdmaWxlOicpIHx8IHVybFNhbml0aXplZC5zdGFydHNXaXRoKCdnb3BoZXI6JykgfHwgdXJsU2FuaXRpemVkLnN0YXJ0c1dpdGgoJ3RlbG5ldDonKSB8fCB1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbWFpbHRvOicpIHx8IHVybFNhbml0aXplZC5zdGFydHNXaXRoKCduZXdzOicpIHx8IHVybFNhbml0aXplZC5zdGFydHNXaXRoKCdubnRwOicpKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luIHx8IF9zdW5vcykge1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSBbJy1JJywgJy0tY29ubmVjdC10aW1lb3V0JywgJzUnLCAnLW0nLCAnNSddO1xuICAgICAgICAgICAgYXJncy5wdXNoKHVybFNhbml0aXplZCk7XG4gICAgICAgICAgICBsZXQgY21kID0gJ2N1cmwnO1xuICAgICAgICAgICAgdXRpbC5leGVjU2FmZShjbWQsIGFyZ3MpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBzdGF0dXNDb2RlID0gbGluZXNbMF0gJiYgbGluZXNbMF0uaW5kZXhPZignICcpID49IDAgPyBwYXJzZUludChsaW5lc1swXS5zcGxpdCgnICcpWzFdLCAxMCkgOiA0MDQ7XG4gICAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPSBzdGF0dXNDb2RlIHx8IDQwNDtcbiAgICAgICAgICAgICAgcmVzdWx0Lm9rID0gKHN0YXR1c0NvZGUgPT09IDIwMCB8fCBzdGF0dXNDb2RlID09PSAzMDEgfHwgc3RhdHVzQ29kZSA9PT0gMzAyIHx8IHN0YXR1c0NvZGUgPT09IDMwNCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tcyA9IChyZXN1bHQub2sgPyBEYXRlLm5vdygpIC0gdCA6IG51bGwpO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF93aW5kb3dzKSB7ICAgLy8gaWYgdGhpcyBpcyBzdGFibGUsIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGFsbCBPUyB0eXBlc1xuICAgICAgICAgICAgY29uc3QgaHR0cCA9ICh1cmxTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyByZXF1aXJlKCdodHRwcycpIDogcmVxdWlyZSgnaHR0cCcpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGh0dHAuZ2V0KHVybFNhbml0aXplZCwgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGF0dXMgPSBzdGF0dXNDb2RlIHx8IDQwNDtcbiAgICAgICAgICAgICAgICByZXN1bHQub2sgPSAoc3RhdHVzQ29kZSA9PT0gMjAwIHx8IHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIgfHwgc3RhdHVzQ29kZSA9PT0gMzA0KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgIHJlcy5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tcyA9IChyZXN1bHQub2sgPyBEYXRlLm5vdygpIC0gdCA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAgIHJlcy5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubXMgPSAocmVzdWx0Lm9rID8gRGF0ZS5ub3coKSAtIHQgOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KS5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmluZXRDaGVja3NpdGUgPSBpbmV0Q2hlY2tzaXRlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY2hlY2sgaW5ldCBsYXRlbmN5XG5cbmZ1bmN0aW9uIGluZXRMYXRlbmN5KGhvc3QsIGNhbGxiYWNrKSB7XG5cbiAgLy8gZmFsbGJhY2sgLSBpZiBvbmx5IGNhbGxiYWNrIGlzIGdpdmVuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oaG9zdCkgJiYgIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBob3N0O1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGhvc3QgPSBob3N0IHx8ICc4LjguOC44JztcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwpOyB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgICAgbGV0IGhvc3RTYW5pdGl6ZWQgPSAnJztcbiAgICAgIGNvbnN0IHMgPSAodXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnOC44LjguOCcgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoaG9zdCwgdHJ1ZSkpLnRyaW0oKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICBpZiAoIShzW2ldID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgc1tpXS5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgICAgY29uc3Qgc2wgPSBzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHNsICYmIHNsWzBdICYmICFzbFsxXSkge1xuICAgICAgICAgICAgaG9zdFNhbml0aXplZCA9IGhvc3RTYW5pdGl6ZWQgKyBzbFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvc3RTYW5pdGl6ZWQuX19wcm90b19fLnN0YXJ0c1dpdGggPSB1dGlsLnN0cmluZ1N0YXJ0V2l0aDtcbiAgICAgIGlmIChob3N0U2FuaXRpemVkLnN0YXJ0c1dpdGgoJ2ZpbGU6JykgfHwgaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCdnb3BoZXI6JykgfHwgaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCd0ZWxuZXQ6JykgfHwgaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCdtYWlsdG86JykgfHwgaG9zdFNhbml0aXplZC5zdGFydHNXaXRoKCduZXdzOicpIHx8IGhvc3RTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnbm50cDonKSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCk7IH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBsZXQgcGFyYW1zO1xuICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4pIHtcbiAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgIHBhcmFtcyA9IFsnLWMnLCAnMicsICctdycsICczJywgaG9zdFNhbml0aXplZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICBwYXJhbXMgPSBbJy1jJywgJzInLCAnLXQnLCAnMycsIGhvc3RTYW5pdGl6ZWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgcGFyYW1zID0gWyctYzInLCAnLXQzJywgaG9zdFNhbml0aXplZF07XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5leGVjU2FmZSgncGluZycsIHBhcmFtcykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpLmZpbHRlcigobGluZSkgPT4gKGxpbmUuaW5kZXhPZigncnR0JykgPj0gMCB8fCBsaW5lLmluZGV4T2YoJ3JvdW5kLXRyaXAnKSA+PSAwIHx8IGxpbmUuaW5kZXhPZignYXZnJykgPj0gMCkpLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lWzFdLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbJy1zJywgJy1hJywgaG9zdFNhbml0aXplZCwgJzU2JywgJzInXTtcbiAgICAgICAgY29uc3QgZmlsdCA9ICdhdmcnO1xuICAgICAgICB1dGlsLmV4ZWNTYWZlKCdwaW5nJywgcGFyYW1zLCB7IHRpbWVvdXQ6IDMwMDAgfSkudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihmaWx0KSA+PSAwKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lcy5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmVbMV0uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUZsb2F0KHBhcnRzWzFdLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gW2hvc3RTYW5pdGl6ZWQsICctbicsICcxJ107XG4gICAgICAgICAgdXRpbC5leGVjU2FmZSgncGluZycsIHBhcmFtcywgdXRpbC5leGVjT3B0c1dpbikudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxpbmUudG9Mb3dlckNhc2UoKS5tYXRjaCgvbXMvZykgfHwgW10pLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgbGV0IGwgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VGbG9hdChsW2wubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuaW5ldExhdGVuY3kgPSBpbmV0TGF0ZW5jeTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gbWVtb3J5LmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gNS4gTWVtb3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuY29uc3QgT1NYX1JBTV9tYW51ZmFjdHVyZXJzID0ge1xuICAnMHgwMTRGJzogJ1RyYW5zY2VuZCBJbmZvcm1hdGlvbicsXG4gICcweDJDMDAnOiAnTWljcm9uIFRlY2hub2xvZ3kgSW5jLicsXG4gICcweDgwMkMnOiAnTWljcm9uIFRlY2hub2xvZ3kgSW5jLicsXG4gICcweDgwQUQnOiAnSHluaXggU2VtaWNvbmR1Y3RvciBJbmMuJyxcbiAgJzB4ODBDRSc6ICdTYW1zdW5nIEVsZWN0cm9uaWNzIEluYy4nLFxuICAnMHhBRDAwJzogJ0h5bml4IFNlbWljb25kdWN0b3IgSW5jLicsXG4gICcweENFMDAnOiAnU2Ftc3VuZyBFbGVjdHJvbmljcyBJbmMuJyxcbiAgJzB4MDJGRSc6ICdFbHBpZGEnLFxuICAnMHg1MTA1JzogJ1FpbW9uZGEgQUcgaS4gSW4uJyxcbiAgJzB4ODU1MSc6ICdRaW1vbmRhIEFHIGkuIEluLicsXG4gICcweDg1OUInOiAnQ3J1Y2lhbCcsXG4gICcweDA0Q0QnOiAnRy1Ta2lsbCdcbn07XG5cbmNvbnN0IExJTlVYX1JBTV9tYW51ZmFjdHVyZXJzID0ge1xuICAnMDE3QSc6ICdBcGFjZXInLFxuICAnMDE5OCc6ICdIeXBlclgnLFxuICAnMDI5RSc6ICdDb3JzYWlyJyxcbiAgJzA0Q0InOiAnQS1EQVRBJyxcbiAgJzA0Q0QnOiAnRy1Ta2lsbCcsXG4gICcwNTlCJzogJ0NydWNpYWwnLFxuICAnMDBDRSc6ICdTYW1zdW5nJyxcbiAgJzEzMTUnOiAnQ3J1dGlhbCcsXG4gICcwMTRGJzogJ1RyYW5zY2VuZCBJbmZvcm1hdGlvbicsXG4gICcyQzAwJzogJ01pY3JvbiBUZWNobm9sb2d5IEluYy4nLFxuICAnODAyQyc6ICdNaWNyb24gVGVjaG5vbG9neSBJbmMuJyxcbiAgJzgwQUQnOiAnSHluaXggU2VtaWNvbmR1Y3RvciBJbmMuJyxcbiAgJzgwQ0UnOiAnU2Ftc3VuZyBFbGVjdHJvbmljcyBJbmMuJyxcbiAgJ0FEMDAnOiAnSHluaXggU2VtaWNvbmR1Y3RvciBJbmMuJyxcbiAgJ0NFMDAnOiAnU2Ftc3VuZyBFbGVjdHJvbmljcyBJbmMuJyxcbiAgJzAyRkUnOiAnRWxwaWRhJyxcbiAgJzUxMDUnOiAnUWltb25kYSBBRyBpLiBJbi4nLFxuICAnODU1MSc6ICdRaW1vbmRhIEFHIGkuIEluLicsXG4gICc4NTlCJzogJ0NydWNpYWwnXG59O1xuXG4vLyBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICAgUiBBIE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIEggRCAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19fX3wgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8XG4vLyB8ICAgICAgICBhY3RpdmUgICAgICAgICAgICAgYnVmZmVycy9jYWNoZSAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX198X19fX19fX19ffF9fX19fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICAgIHVzZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJlZSAgIHwgICB1c2VkICAgICAgIGZyZWUgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHN3YXAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX198XG5cbi8vIGZyZWUgKG9sZGVyIHZlcnNpb25zKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIyBmcmVlXG4vLyAgICAgICAgICAgICAgdG90YWwgICAgICAgdXNlZCAgICAgICAgZnJlZSAgICAgc2hhcmVkICAgIGJ1ZmZlcnMgICAgIGNhY2hlZFxuLy8gTWVtOiAgICAgICAgIDE2MDM4ICgxKSAgIDE1NjUzICgyKSAgIDM4NCAoMykgIDAgKDQpICAgICAyMzYgKDUpICAgICAxNDc4OCAoNilcbi8vIC0vKyBidWZmZXJzL2NhY2hlOiAgICAgICA2MjggKDcpICAgICAxNTQwOSAoOClcbi8vIFN3YXA6ICAgICAgICAxNjM3MSAgICAgICAgIDgzICAgICAgMTYyODhcbi8vXG4vLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuLy8gfCAgICAgICAgICAgICAgICAgICAgICAgICAgIFIgQSBNICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4vLyB8IGFjdGl2ZSAoMi0oNSs2KSA9IDcpIHwgIGF2YWlsYWJsZSAoMys1KzYgPSA4KSAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX3xcbi8vIHwgICAgICAgIGFjdGl2ZSAgICAgICAgfCAgYnVmZmVycy9jYWNoZSAoNSs2KSAgICB8ICAgICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19ffFxuLy8gfCAgICAgICAgICAgICAgICAgICB1c2VkICgyKSAgICAgICAgICAgICAgICAgICAgIHwgZnJlZSAoMykgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCAoMSkgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcblxuLy9cbi8vIGZyZWUgKHNpbmNlIGZyZWUgdm9uIHByb2Nwcy1uZyAzLjMuMTApXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAjIGZyZWVcbi8vICAgICAgICAgICAgICB0b3RhbCAgICAgICB1c2VkICAgICAgICBmcmVlICAgICBzaGFyZWQgICAgYnVmZmVycy9jYWNoZSAgIGF2YWlsYWJsZVxuLy8gTWVtOiAgICAgICAgIDE2MDM4ICgxKSAgIDYyOCAoMikgICAgIDM4NiAoMykgIDAgKDQpICAgICAxNTAyNCAoNSkgICAgIDE0Nzg4ICg2KVxuLy8gU3dhcDogICAgICAgIDE2MzcxICAgICAgICAgODMgICAgICAxNjI4OFxuLy9cbi8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgUiBBIE0gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbi8vIHwgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIGF2YWlsYWJsZSAoNikgZXN0aW1hdGVkICAgICAgICB8XG4vLyB8X19fX19fX19fX19fX19fX19fX19fX3xfX19fX19fX19fX19fX19fX19fX19fX19ffF9fX19fX19fX19ffFxuLy8gfCAgICAgYWN0aXZlICgyKSAgICAgICB8ICAgYnVmZmVycy9jYWNoZSAoNSkgICAgIHwgZnJlZSAoMykgIHxcbi8vIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX198X19fX19fX19fX198XG4vLyB8ICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCAoMSkgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gfF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbi8vXG4vLyBSZWZlcmVuY2U6IGh0dHA6Ly93d3cuc29mdHdhcmUtYXJjaGl0ZWN0Lm5ldC9ibG9nL2FydGljbGUvZGF0ZS8yMDE1LzA2LzEyLy04MjZjNmU1MDUyLmh0bWxcblxuLy8gL3Byb2NzL21lbWluZm8gLSBzYW1wbGUgKGFsbCBpbiBrQilcbi8vXG4vLyBNZW1Ub3RhbDogMzI4MDYzODAga0Jcbi8vIE1lbUZyZWU6IDE3OTc3NzQ0IGtCXG4vLyBNZW1BdmFpbGFibGU6IDE5NzY4OTcyIGtCXG4vLyBCdWZmZXJzOiA1MTcwMjgga0Jcbi8vIENhY2hlZDogMjE2MTg3NiBrQlxuLy8gU3dhcENhY2hlZDogNDU2IGtCXG4vLyBBY3RpdmU6IDEyMDgxMTc2IGtCXG4vLyBJbmFjdGl2ZTogMjE2NDYxNiBrQlxuLy8gQWN0aXZlKGFub24pOiAxMDgzMjg4NCBrQlxuLy8gSW5hY3RpdmUoYW5vbik6IDE0NzcyNzIga0Jcbi8vIEFjdGl2ZShmaWxlKTogMTI0ODI5MiBrQlxuLy8gSW5hY3RpdmUoZmlsZSk6IDY4NzM0NCBrQlxuLy8gVW5ldmljdGFibGU6IDAga0Jcbi8vIE1sb2NrZWQ6IDAga0Jcbi8vIFN3YXBUb3RhbDogMTY3Njg4OTIga0Jcbi8vIFN3YXBGcmVlOiAxNjc2ODMwNCBrQlxuLy8gRGlydHk6IDI2OCBrQlxuLy8gV3JpdGViYWNrOiAwIGtCXG4vLyBBbm9uUGFnZXM6IDExNTY4ODMyIGtCXG4vLyBNYXBwZWQ6IDcxOTk5MiBrQlxuLy8gU2htZW06IDc0MzI3MiBrQlxuLy8gU2xhYjogMzM1NzE2IGtCXG4vLyBTUmVjbGFpbWFibGU6IDI1NjM2NCBrQlxuLy8gU1VucmVjbGFpbTogNzkzNTIga0JcblxuZnVuY3Rpb24gbWVtKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHRvdGFsOiBvcy50b3RhbG1lbSgpLFxuICAgICAgICBmcmVlOiBvcy5mcmVlbWVtKCksXG4gICAgICAgIHVzZWQ6IG9zLnRvdGFsbWVtKCkgLSBvcy5mcmVlbWVtKCksXG5cbiAgICAgICAgYWN0aXZlOiBvcy50b3RhbG1lbSgpIC0gb3MuZnJlZW1lbSgpLCAgICAgLy8gdGVtcG9yYXJpbHkgKGZhbGxiYWNrKVxuICAgICAgICBhdmFpbGFibGU6IG9zLmZyZWVtZW0oKSwgICAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSAoZmFsbGJhY2spXG4gICAgICAgIGJ1ZmZlcnM6IDAsXG4gICAgICAgIGNhY2hlZDogMCxcbiAgICAgICAgc2xhYjogMCxcbiAgICAgICAgYnVmZmNhY2hlOiAwLFxuXG4gICAgICAgIHN3YXB0b3RhbDogMCxcbiAgICAgICAgc3dhcHVzZWQ6IDAsXG4gICAgICAgIHN3YXBmcmVlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGZzLnJlYWRGaWxlKCcvcHJvYy9tZW1pbmZvJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC50b3RhbCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdtZW10b3RhbCcpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQudG90YWwgPSByZXN1bHQudG90YWwgPyByZXN1bHQudG90YWwgKiAxMDI0IDogb3MudG90YWxtZW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5mcmVlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ21lbWZyZWUnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmZyZWUgPSByZXN1bHQuZnJlZSA/IHJlc3VsdC5mcmVlICogMTAyNCA6IG9zLmZyZWVtZW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC51c2VkID0gcmVzdWx0LnRvdGFsIC0gcmVzdWx0LmZyZWU7XG5cbiAgICAgICAgICAgIHJlc3VsdC5idWZmZXJzID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2J1ZmZlcnMnKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LmJ1ZmZlcnMgPSByZXN1bHQuYnVmZmVycyA/IHJlc3VsdC5idWZmZXJzICogMTAyNCA6IDA7XG4gICAgICAgICAgICByZXN1bHQuY2FjaGVkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhY2hlZCcpLCAxMCk7XG4gICAgICAgICAgICByZXN1bHQuY2FjaGVkID0gcmVzdWx0LmNhY2hlZCA/IHJlc3VsdC5jYWNoZWQgKiAxMDI0IDogMDtcbiAgICAgICAgICAgIHJlc3VsdC5zbGFiID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NsYWInKSwgMTApO1xuICAgICAgICAgICAgcmVzdWx0LnNsYWIgPSByZXN1bHQuc2xhYiA/IHJlc3VsdC5zbGFiICogMTAyNCA6IDA7XG4gICAgICAgICAgICByZXN1bHQuYnVmZmNhY2hlID0gcmVzdWx0LmJ1ZmZlcnMgKyByZXN1bHQuY2FjaGVkICsgcmVzdWx0LnNsYWI7XG5cbiAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWVtYXZhaWxhYmxlJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5hdmFpbGFibGUgPSBhdmFpbGFibGUgPyBhdmFpbGFibGUgKiAxMDI0IDogcmVzdWx0LmZyZWUgKyByZXN1bHQuYnVmZmNhY2hlO1xuICAgICAgICAgICAgcmVzdWx0LmFjdGl2ZSA9IHJlc3VsdC50b3RhbCAtIHJlc3VsdC5hdmFpbGFibGU7XG5cbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdG90YWwgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3dhcHRvdGFsJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdG90YWwgPSByZXN1bHQuc3dhcHRvdGFsID8gcmVzdWx0LnN3YXB0b3RhbCAqIDEwMjQgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXBmcmVlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N3YXBmcmVlJyksIDEwKTtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwZnJlZSA9IHJlc3VsdC5zd2FwZnJlZSA/IHJlc3VsdC5zd2FwZnJlZSAqIDEwMjQgOiAwO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXB1c2VkID0gcmVzdWx0LnN3YXB0b3RhbCAtIHJlc3VsdC5zd2FwZnJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnL3NiaW4vc3lzY3RsIGh3LnJlYWxtZW0gaHcucGh5c21lbSB2bS5zdGF0cy52bS52X3BhZ2VfY291bnQgdm0uc3RhdHMudm0udl93aXJlX2NvdW50IHZtLnN0YXRzLnZtLnZfYWN0aXZlX2NvdW50IHZtLnN0YXRzLnZtLnZfaW5hY3RpdmVfY291bnQgdm0uc3RhdHMudm0udl9jYWNoZV9jb3VudCB2bS5zdGF0cy52bS52X2ZyZWVfY291bnQgdm0uc3RhdHMudm0udl9wYWdlX3NpemUnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzaXplID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZtLnN0YXRzLnZtLnZfcGFnZV9zaXplJyksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGluYWN0aXZlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZtLnN0YXRzLnZtLnZfaW5hY3RpdmVfY291bnQnKSwgMTApICogcGFnZXNpemU7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICd2bS5zdGF0cy52bS52X2NhY2hlX2NvdW50JyksIDEwKSAqIHBhZ2VzaXplO1xuXG4gICAgICAgICAgICByZXN1bHQudG90YWwgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcucmVhbG1lbScpLCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocmVzdWx0LnRvdGFsKSkgeyByZXN1bHQudG90YWwgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnaHcucGh5c21lbScpLCAxMCk7IH1cbiAgICAgICAgICAgIHJlc3VsdC5mcmVlID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZtLnN0YXRzLnZtLnZfZnJlZV9jb3VudCcpLCAxMCkgKiBwYWdlc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5idWZmY2FjaGUgPSBpbmFjdGl2ZSArIGNhY2hlO1xuICAgICAgICAgICAgcmVzdWx0LmF2YWlsYWJsZSA9IHJlc3VsdC5idWZmY2FjaGUgKyByZXN1bHQuZnJlZTtcbiAgICAgICAgICAgIHJlc3VsdC5hY3RpdmUgPSByZXN1bHQudG90YWwgLSByZXN1bHQuZnJlZSAtIHJlc3VsdC5idWZmY2FjaGU7XG5cbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdG90YWwgPSAwO1xuICAgICAgICAgICAgcmVzdWx0LnN3YXBmcmVlID0gMDtcbiAgICAgICAgICAgIHJlc3VsdC5zd2FwdXNlZCA9IDA7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgcGFnZVNpemUgPSA0MDk2O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzeXNQcGFnZVNpemUgPSB1dGlsLnRvSW50KGV4ZWNTeW5jKCdzeXNjdGwgLW4gdm0ucGFnZXNpemUnKS50b1N0cmluZygpKTtcbiAgICAgICAgICBwYWdlU2l6ZSA9IHN5c1BwYWdlU2l6ZSB8fCBwYWdlU2l6ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWMoJ3ZtX3N0YXQgMj4vZGV2L251bGwgfCBncmVwIFwiUGFnZXMgYWN0aXZlXCInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgcmVzdWx0LmFjdGl2ZSA9IHBhcnNlSW50KGxpbmVzWzBdLnNwbGl0KCc6JylbMV0sIDEwKSAqIHBhZ2VTaXplO1xuICAgICAgICAgICAgcmVzdWx0LmJ1ZmZjYWNoZSA9IHJlc3VsdC51c2VkIC0gcmVzdWx0LmFjdGl2ZTtcbiAgICAgICAgICAgIHJlc3VsdC5hdmFpbGFibGUgPSByZXN1bHQuZnJlZSArIHJlc3VsdC5idWZmY2FjaGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMoJ3N5c2N0bCAtbiB2bS5zd2FwdXNhZ2UgMj4vZGV2L251bGwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0bGluZSA9IGxpbmVzWzBdLnJlcGxhY2UoLywvZywgJy4nKS5yZXBsYWNlKC9NL2csICcnKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZUFycmF5ID0gZmlyc3RsaW5lLnRyaW0oKS5zcGxpdCgnICAnKTtcbiAgICAgICAgICAgICAgICBsaW5lQXJyYXkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigndG90YWwnKSAhPT0gLTEpIHsgcmVzdWx0LnN3YXB0b3RhbCA9IHBhcnNlRmxvYXQobGluZS5zcGxpdCgnPScpWzFdLnRyaW0oKSkgKiAxMDI0ICogMTAyNDsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd1c2VkJykgIT09IC0xKSB7IHJlc3VsdC5zd2FwdXNlZCA9IHBhcnNlRmxvYXQobGluZS5zcGxpdCgnPScpWzFdLnRyaW0oKSkgKiAxMDI0ICogMTAyNDsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmcmVlJykgIT09IC0xKSB7IHJlc3VsdC5zd2FwZnJlZSA9IHBhcnNlRmxvYXQobGluZS5zcGxpdCgnPScpWzFdLnRyaW0oKSkgKiAxMDI0ICogMTAyNDsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgc3dhcHRvdGFsID0gMDtcbiAgICAgICAgbGV0IHN3YXB1c2VkID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9QYWdlRmlsZVVzYWdlIHwgU2VsZWN0IEFsbG9jYXRlZEJhc2VTaXplLCBDdXJyZW50VXNhZ2UnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKS5maWx0ZXIoKGxpbmUsIGlkeCkgPT4gaWR4ID4gMCk7XG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKS5zcGxpdCgvXFxzXFxzKy8pO1xuICAgICAgICAgICAgICAgICAgc3dhcHRvdGFsID0gc3dhcHRvdGFsICsgKHBhcnNlSW50KGxpbmVbMF0sIDEwKSB8fCAwKTtcbiAgICAgICAgICAgICAgICAgIHN3YXB1c2VkID0gc3dhcHVzZWQgKyAocGFyc2VJbnQobGluZVsxXSwgMTApIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc3dhcHRvdGFsID0gc3dhcHRvdGFsICogMTAyNCAqIDEwMjQ7XG4gICAgICAgICAgICByZXN1bHQuc3dhcHVzZWQgPSBzd2FwdXNlZCAqIDEwMjQgKiAxMDI0O1xuICAgICAgICAgICAgcmVzdWx0LnN3YXBmcmVlID0gcmVzdWx0LnN3YXB0b3RhbCAtIHJlc3VsdC5zd2FwdXNlZDtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm1lbSA9IG1lbTtcblxuZnVuY3Rpb24gbWVtTGF5b3V0KGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gZ2V0TWFudWZhY3R1cmVyRGFyd2luKG1hbklkKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoT1NYX1JBTV9tYW51ZmFjdHVyZXJzLCBtYW5JZCkpIHtcbiAgICAgIHJldHVybiAoT1NYX1JBTV9tYW51ZmFjdHVyZXJzW21hbklkXSk7XG4gICAgfVxuICAgIHJldHVybiBtYW5JZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1hbnVmYWN0dXJlckxpbnV4KG1hbklkKSB7XG4gICAgY29uc3QgbWFuSWRTZWFyY2ggPSBtYW5JZC5yZXBsYWNlKCcweCcsICcnKS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChtYW5JZFNlYXJjaC5sZW5ndGggPT09IDQgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChMSU5VWF9SQU1fbWFudWZhY3R1cmVycywgbWFuSWRTZWFyY2gpKSB7XG4gICAgICByZXR1cm4gKExJTlVYX1JBTV9tYW51ZmFjdHVyZXJzW21hbklkU2VhcmNoXSk7XG4gICAgfVxuICAgIHJldHVybiBtYW5JZDtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCBtZW1vcnkgMj4vZGV2L251bGwgfCBncmVwIC1pRSBcIlNpemU6fFR5cGV8U3BlZWR8TWFudWZhY3R1cmVyfEZvcm0gRmFjdG9yfExvY2F0b3J8TWVtb3J5IERldmljZXxTZXJpYWwgTnVtYmVyfFZvbHRhZ2V8UGFydCBOdW1iZXJcIjsgdW5zZXQgTENfQUxMJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdNZW1vcnkgRGV2aWNlJyk7XG4gICAgICAgICAgICBkZXZpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZnVuY3Rpb24gKGRldmljZSkge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBjb25zdCBzaXplU3RyaW5nID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NpemUnKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNpemVTdHJpbmcuaW5kZXhPZignR0InKSA+PSAwID8gcGFyc2VJbnQoc2l6ZVN0cmluZywgMTApICogMTAyNCAqIDEwMjQgKiAxMDI0IDogcGFyc2VJbnQoc2l6ZVN0cmluZywgMTApICogMTAyNCAqIDEwMjQ7XG4gICAgICAgICAgICAgIGxldCBiYW5rID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JhbmsgTG9jYXRvcicpO1xuICAgICAgICAgICAgICBpZiAoYmFuay50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2JhZCcpID49IDApIHtcbiAgICAgICAgICAgICAgICBiYW5rID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaXplJyksIDEwKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVG90YWwgV2lkdGgnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVdpZHRoID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGF0YSBXaWR0aCcpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgYmFuayxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdUeXBlOicpLFxuICAgICAgICAgICAgICAgICAgZWNjOiBkYXRhV2lkdGggJiYgdG90YWxXaWR0aCA/IHRvdGFsV2lkdGggPiBkYXRhV2lkdGggOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6ICh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlndXJlZCBDbG9jayBTcGVlZDonKSA/IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWd1cmVkIENsb2NrIFNwZWVkOicpLCAxMCkgOiAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NwZWVkOicpID8gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NwZWVkOicpLCAxMCkgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRm9ybSBGYWN0b3I6JyksXG4gICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IGdldE1hbnVmYWN0dXJlckxpbnV4KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYW51ZmFjdHVyZXI6JykpLFxuICAgICAgICAgICAgICAgICAgcGFydE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhcnQgTnVtYmVyOicpLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsIE51bWJlcjonKSxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDb25maWd1cmVkIFZvbHRhZ2U6JykpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNaW5pbXVtIFZvbHRhZ2U6JykpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBwYXJzZUZsb2F0KHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYXhpbXVtIFZvbHRhZ2U6JykpIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgICAgICAgIGJhbmssXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnRW1wdHknLFxuICAgICAgICAgICAgICAgICAgZWNjOiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogMCxcbiAgICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGb3JtIEZhY3RvcjonKSxcbiAgICAgICAgICAgICAgICAgIHBhcnROdW06ICcnLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiAnJyxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdm9sdGFnZU1pbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgc2l6ZTogb3MudG90YWxtZW0oKSxcbiAgICAgICAgICAgICAgYmFuazogJycsXG4gICAgICAgICAgICAgIHR5cGU6ICcnLFxuICAgICAgICAgICAgICBlY2M6IG51bGwsXG4gICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IDAsXG4gICAgICAgICAgICAgIGZvcm1GYWN0b3I6ICcnLFxuICAgICAgICAgICAgICBwYXJ0TnVtOiAnJyxcbiAgICAgICAgICAgICAgc2VyaWFsTnVtOiAnJyxcbiAgICAgICAgICAgICAgdm9sdGFnZUNvbmZpZ3VyZWQ6IG51bGwsXG4gICAgICAgICAgICAgIHZvbHRhZ2VNaW46IG51bGwsXG4gICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IG51bGwsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVHJ5IFJhc3BiZXJyeSBQSVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IHN0ZG91dCA9IGV4ZWNTeW5jKCdjYXQgL3Byb2MvY3B1aW5mbyAyPi9kZXYvbnVsbCcpO1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGxldCBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdoYXJkd2FyZScsICc6JywgdHJ1ZSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncmV2aXNpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKG1vZGVsID09PSAnQkNNMjgzNScgfHwgbW9kZWwgPT09ICdCQ00yNzA4JyB8fCBtb2RlbCA9PT0gJ0JDTTI3MDknIHx8IG1vZGVsID09PSAnQkNNMjgzNScgfHwgbW9kZWwgPT09ICdCQ00yODM3Jykge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvY2tTcGVlZCA9IHtcbiAgICAgICAgICAgICAgICAgICcwJzogNDAwLFxuICAgICAgICAgICAgICAgICAgJzEnOiA0NTAsXG4gICAgICAgICAgICAgICAgICAnMic6IDQ1MCxcbiAgICAgICAgICAgICAgICAgICczJzogMzIwMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdLnR5cGUgPSAnTFBERFIyJztcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0udHlwZSA9IHZlcnNpb24gJiYgdmVyc2lvblsyXSAmJiB2ZXJzaW9uWzJdID09PSAnMycgPyAnTFBERFI0JyA6IHJlc3VsdFswXS50eXBlO1xuICAgICAgICAgICAgICAgIHJlc3VsdFswXS5lY2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0uY2xvY2tTcGVlZCA9IHZlcnNpb24gJiYgdmVyc2lvblsyXSAmJiBjbG9ja1NwZWVkW3ZlcnNpb25bMl1dIHx8IDQwMDtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0uY2xvY2tTcGVlZCA9IHZlcnNpb24gJiYgdmVyc2lvbls0XSAmJiB2ZXJzaW9uWzRdID09PSAnZCcgPyA1MDAgOiByZXN1bHRbMF0uY2xvY2tTcGVlZDtcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0uZm9ybUZhY3RvciA9ICdTb0MnO1xuXG4gICAgICAgICAgICAgICAgc3Rkb3V0ID0gZXhlY1N5bmMoJ3ZjZ2VuY21kIGdldF9jb25maWcgc2RyYW1fZnJlcSAyPi9kZXYvbnVsbCcpO1xuICAgICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxldCBmcmVxID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NkcmFtX2ZyZXEnLCAnPScsIHRydWUpLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoZnJlcSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdLmNsb2NrU3BlZWQgPSBmcmVxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0ZG91dCA9IGV4ZWNTeW5jKCd2Y2dlbmNtZCBtZWFzdXJlX3ZvbHRzIHNkcmFtX3AgMj4vZGV2L251bGwnKTtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBsZXQgdm9sdGFnZSA9IHBhcnNlRmxvYXQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZvbHQnLCAnPScsIHRydWUpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICh2b2x0YWdlKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbMF0udm9sdGFnZUNvbmZpZ3VyZWQgPSB2b2x0YWdlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdLnZvbHRhZ2VNaW4gPSB2b2x0YWdlO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WzBdLnZvbHRhZ2VNYXggPSB2b2x0YWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N5c3RlbV9wcm9maWxlciBTUE1lbW9yeURhdGFUeXBlJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxMaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGVjY1N0YXR1cyA9IHV0aWwuZ2V0VmFsdWUoYWxsTGluZXMsICdlY2MnLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCcgICAgICAgIEJBTksgJyk7XG4gICAgICAgICAgICBsZXQgaGFzQmFuayA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGV2aWNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgZGV2aWNlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCcgICAgICAgIERJTU0nKTtcbiAgICAgICAgICAgICAgaGFzQmFuayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZGV2aWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgY29uc3QgYmFuayA9IChoYXNCYW5rID8gJ0JBTksgJyA6ICdESU1NJykgKyBsaW5lc1swXS50cmltKCkuc3BsaXQoJy8nKVswXTtcbiAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgU2l6ZScpKTtcbiAgICAgICAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICBzaXplOiBzaXplICogMTAyNCAqIDEwMjQgKiAxMDI0LFxuICAgICAgICAgICAgICAgICAgYmFuazogYmFuayxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICcgICAgICAgICAgVHlwZTonKSxcbiAgICAgICAgICAgICAgICAgIGVjYzogZWNjU3RhdHVzID8gZWNjU3RhdHVzID09PSAnZW5hYmxlZCcgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgY2xvY2tTcGVlZDogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJyAgICAgICAgICBTcGVlZDonKSwgMTApLFxuICAgICAgICAgICAgICAgICAgZm9ybUZhY3RvcjogJycsXG4gICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IGdldE1hbnVmYWN0dXJlckRhcndpbih1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIE1hbnVmYWN0dXJlcjonKSksXG4gICAgICAgICAgICAgICAgICBwYXJ0TnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIFBhcnQgTnVtYmVyOicpLFxuICAgICAgICAgICAgICAgICAgc2VyaWFsTnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgICAgIFNlcmlhbCBOdW1iZXI6JyksXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgICAgICBiYW5rOiBiYW5rLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ0VtcHR5JyxcbiAgICAgICAgICAgICAgICAgIGVjYzogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGNsb2NrU3BlZWQ6IDAsXG4gICAgICAgICAgICAgICAgICBmb3JtRmFjdG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgICAgICAgICAgICBwYXJ0TnVtOiAnJyxcbiAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogJycsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlQ29uZmlndXJlZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICB2b2x0YWdlTWF4OiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgTWVtb3J5OicpKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnICAgICAgVHlwZTonKTtcbiAgICAgICAgICAgIGlmIChzaXplICYmIHR5cGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgKiAxMDI0ICogMTAyNCAqIDEwMjQsXG4gICAgICAgICAgICAgICAgYmFuazogJzAnLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZWNjOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6ICcnLFxuICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogJ0FwcGxlJyxcbiAgICAgICAgICAgICAgICBwYXJ0TnVtOiAnJyxcbiAgICAgICAgICAgICAgICBzZXJpYWxOdW06ICcnLFxuICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiBudWxsLFxuICAgICAgICAgICAgICAgIHZvbHRhZ2VNaW46IG51bGwsXG4gICAgICAgICAgICAgICAgdm9sdGFnZU1heDogbnVsbCxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgY29uc3QgbWVtb3J5VHlwZXMgPSAnVW5rbm93bnxPdGhlcnxEUkFNfFN5bmNocm9ub3VzIERSQU18Q2FjaGUgRFJBTXxFRE98RURSQU18VlJBTXxTUkFNfFJBTXxST018RkxBU0h8RUVQUk9NfEZFUFJPTXxFUFJPTXxDRFJBTXwzRFJBTXxTRFJBTXxTR1JBTXxSRFJBTXxERFJ8RERSMnxERFIyIEZCLURJTU18UmVzZXJ2ZWR8RERSM3xGQkQyfEREUjR8TFBERFJ8TFBERFIyfExQRERSM3xMUEREUjQnLnNwbGl0KCd8Jyk7XG4gICAgICAgIGNvbnN0IEZvcm1GYWN0b3JzID0gJ1Vua25vd258T3RoZXJ8U0lQfERJUHxaSVB8U09KfFByb3ByaWV0YXJ5fFNJTU18RElNTXxUU09QfFBHQXxSSU1NfFNPRElNTXxTUklNTXxTTUR8U1NNUHxRRlB8VFFGUHxTT0lDfExDQ3xQTENDfEJHQXxGUEJHQXxMR0EnLnNwbGl0KCd8Jyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9QaHlzaWNhbE1lbW9yeSB8IHNlbGVjdCBEYXRhV2lkdGgsVG90YWxXaWR0aCxDYXBhY2l0eSxCYW5rTGFiZWwsTWVtb3J5VHlwZSxTTUJJT1NNZW1vcnlUeXBlLENvbmZpZ3VyZWRDbG9ja1NwZWVkLEZvcm1GYWN0b3IsTWFudWZhY3R1cmVyLFBhcnROdW1iZXIsU2VyaWFsTnVtYmVyLENvbmZpZ3VyZWRWb2x0YWdlLE1pblZvbHRhZ2UsTWF4Vm9sdGFnZSB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgZGV2aWNlcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgIGRldmljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBkZXZpY2Uuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFXaWR0aCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RhdGFXaWR0aCcsICc6JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsV2lkdGggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdUb3RhbFdpZHRoJywgJzonKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdDYXBhY2l0eScsICc6JyksIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGJhbms6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCYW5rTGFiZWwnLCAnOicpLCAvLyBCYW5rTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWVtb3J5VHlwZXNbcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01lbW9yeVR5cGUnLCAnOicpLCAxMCkgfHwgcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NNQklPU01lbW9yeVR5cGUnLCAnOicpLCAxMCldLFxuICAgICAgICAgICAgICAgICAgICBlY2M6IGRhdGFXaWR0aCAmJiB0b3RhbFdpZHRoID8gdG90YWxXaWR0aCA+IGRhdGFXaWR0aCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbG9ja1NwZWVkOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlndXJlZENsb2NrU3BlZWQnLCAnOicpLCAxMCkgfHwgcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NwZWVkJywgJzonKSwgMTApIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1GYWN0b3I6IEZvcm1GYWN0b3JzW3BhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdGb3JtRmFjdG9yJywgJzonKSwgMTApIHx8IDBdLFxuICAgICAgICAgICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYW51ZmFjdHVyZXInLCAnOicpLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0TnVtOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFydE51bWJlcicsICc6JyksXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbE51bTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbE51bWJlcicsICc6JyksXG4gICAgICAgICAgICAgICAgICAgIHZvbHRhZ2VDb25maWd1cmVkOiAocGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NvbmZpZ3VyZWRWb2x0YWdlJywgJzonKSwgMTApIHx8IDApIC8gMTAwMC4wLFxuICAgICAgICAgICAgICAgICAgICB2b2x0YWdlTWluOiAocGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01pblZvbHRhZ2UnLCAnOicpLCAxMCkgfHwgMCkgLyAxMDAwLjAsXG4gICAgICAgICAgICAgICAgICAgIHZvbHRhZ2VNYXg6IChwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWF4Vm9sdGFnZScsICc6JyksIDEwKSB8fCAwKSAvIDEwMDAuMCxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubWVtTGF5b3V0ID0gbWVtTGF5b3V0O1xuXG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIG5ldHdvcmsuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA5LiBOZXR3b3JrXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IGV4ZWNTeW5jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxubGV0IF9uZXR3b3JrID0ge307XG5sZXQgX2RlZmF1bHRfaWZhY2UgPSAnJztcbmxldCBfaWZhY2VzID0ge307XG5sZXQgX2RoY3BOaWNzID0gW107XG5sZXQgX25ldHdvcmtJbnRlcmZhY2VzID0gW107XG5sZXQgX21hYyA9IHt9O1xubGV0IHBhdGhUb0lwO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpIHtcblxuICBsZXQgaWZhY2VuYW1lID0gJyc7XG4gIGxldCBpZmFjZW5hbWVGaXJzdCA9ICcnO1xuICB0cnkge1xuICAgIGxldCBpZmFjZXMgPSBvcy5uZXR3b3JrSW50ZXJmYWNlcygpO1xuXG4gICAgbGV0IHNjb3BlaWQgPSA5OTk5O1xuXG4gICAgLy8gZmFsbGJhY2sgLSBcImZpcnN0XCIgZXh0ZXJuYWwgaW50ZXJmYWNlIChzb3J0ZWQgYnkgc2NvcGVpZClcbiAgICBmb3IgKGxldCBkZXYgaW4gaWZhY2VzKSB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIGRldikpIHtcbiAgICAgICAgaWZhY2VzW2Rldl0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuaW50ZXJuYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZmFjZW5hbWVGaXJzdCA9IGlmYWNlbmFtZUZpcnN0IHx8IGRldjsgLy8gZmFsbGJhY2sgaWYgbm8gc2NvcGVpZFxuICAgICAgICAgICAgaWYgKGRldGFpbHMuc2NvcGVpZCAmJiBkZXRhaWxzLnNjb3BlaWQgPCBzY29wZWlkKSB7XG4gICAgICAgICAgICAgIGlmYWNlbmFtZSA9IGRldjtcbiAgICAgICAgICAgICAgc2NvcGVpZCA9IGRldGFpbHMuc2NvcGVpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZmFjZW5hbWUgPSBpZmFjZW5hbWUgfHwgaWZhY2VuYW1lRmlyc3QgfHwgJyc7XG5cbiAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmluZXRkYWVtb24uY29tL3R1dG9yaWFscy9pbnRlcm5ldC9pcC9yb3V0aW5nL2RlZmF1bHRfcm91dGUuc2h0bWxcbiAgICAgIGxldCBkZWZhdWx0SXAgPSAnJztcbiAgICAgIGNvbnN0IGNtZCA9ICduZXRzdGF0IC1yJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCwgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgICBjb25zdCBsaW5lcyA9IHJlc3VsdC50b1N0cmluZygpLnNwbGl0KG9zLkVPTCk7XG4gICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICBpZiAobGluZS5pbmRleE9mKCcwLjAuMC4wIDAuMC4wLjAnKSA+IC0xICYmICEoL1thLXpBLVpdLy50ZXN0KGxpbmUpKSkge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgZGVmYXVsdElwID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChkZWZhdWx0SXApIHtcbiAgICAgICAgZm9yIChsZXQgZGV2IGluIGlmYWNlcykge1xuICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGlmYWNlcywgZGV2KSkge1xuICAgICAgICAgICAgaWZhY2VzW2Rldl0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLmFkZHJlc3MgJiYgZGV0YWlscy5hZGRyZXNzID09PSBkZWZhdWx0SXApIHtcbiAgICAgICAgICAgICAgICBpZmFjZW5hbWUgPSBkZXY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2xpbnV4KSB7XG4gICAgICBsZXQgY21kID0gJ2lwIHJvdXRlIDI+IC9kZXYvbnVsbCB8IGdyZXAgZGVmYXVsdCc7XG4gICAgICBsZXQgcmVzdWx0ID0gZXhlY1N5bmMoY21kKTtcbiAgICAgIGxldCBwYXJ0cyA9IHJlc3VsdC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS5zcGxpdCgvXFxzKy8pO1xuICAgICAgaWYgKHBhcnRzWzBdID09PSAnbm9uZScgJiYgcGFydHNbNV0pIHtcbiAgICAgICAgaWZhY2VuYW1lID0gcGFydHNbNV07XG4gICAgICB9IGVsc2UgaWYgKHBhcnRzWzRdKSB7XG4gICAgICAgIGlmYWNlbmFtZSA9IHBhcnRzWzRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZhY2VuYW1lLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgIGlmYWNlbmFtZSA9IGlmYWNlbmFtZS5zcGxpdCgnOicpWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9kYXJ3aW4gfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfc3Vub3MpIHtcbiAgICAgIGxldCBjbWQgPSAnJztcbiAgICAgIGlmIChfbGludXgpIHsgY21kID0gJ2lwIHJvdXRlIDI+IC9kZXYvbnVsbCB8IGdyZXAgZGVmYXVsdCB8IGF3ayBcXCd7cHJpbnQgJDV9XFwnJzsgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHsgY21kID0gJ3JvdXRlIC1uIGdldCBkZWZhdWx0IDI+L2Rldi9udWxsIHwgZ3JlcCBpbnRlcmZhY2U6IHwgYXdrIFxcJ3twcmludCAkMn1cXCcnOyB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfc3Vub3MpIHsgY21kID0gJ3JvdXRlIGdldCAwLjAuMC4wIHwgZ3JlcCBpbnRlcmZhY2U6JzsgfVxuICAgICAgbGV0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCk7XG4gICAgICBpZmFjZW5hbWUgPSByZXN1bHQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICBpZiAoaWZhY2VuYW1lLmluZGV4T2YoJzonKSA+IC0xKSB7XG4gICAgICAgIGlmYWNlbmFtZSA9IGlmYWNlbmFtZS5zcGxpdCgnOicpWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICBpZiAoaWZhY2VuYW1lKSB7IF9kZWZhdWx0X2lmYWNlID0gaWZhY2VuYW1lOyB9XG4gIHJldHVybiBfZGVmYXVsdF9pZmFjZTtcbn1cblxuZXhwb3J0cy5nZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSA9IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlO1xuXG5mdW5jdGlvbiBnZXRNYWNBZGRyZXNzZXMoKSB7XG4gIGxldCBpZmFjZSA9ICcnO1xuICBsZXQgbWFjID0gJyc7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoVG9JcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoJ3doaWNoIGlwJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0uaW5kZXhPZignOicpID09PSAtMSAmJiBsaW5lc1swXS5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgICBwYXRoVG9JcCA9IGxpbmVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhUb0lwID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcGF0aFRvSXAgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7ICcgKyAoKHBhdGhUb0lwKSA/IHBhdGhUb0lwICsgJyBsaW5rIHNob3cgdXAnIDogJy9zYmluL2lmY29uZmlnJykgKyAnOyB1bnNldCBMQ19BTEwnO1xuICAgICAgbGV0IHJlcyA9IGV4ZWNTeW5jKGNtZCk7XG4gICAgICBjb25zdCBsaW5lcyA9IHJlcy50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldICYmIGxpbmVzW2ldWzBdICE9PSAnICcpIHtcbiAgICAgICAgICBpZiAocGF0aFRvSXApIHtcbiAgICAgICAgICAgIGxldCBuZXh0bGluZSA9IGxpbmVzW2kgKyAxXS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGlmIChuZXh0bGluZVswXSA9PT0gJ2xpbmsvZXRoZXInKSB7XG4gICAgICAgICAgICAgIGlmYWNlID0gbGluZXNbaV0uc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgICAgICAgaWZhY2UgPSBpZmFjZS5zbGljZSgwLCBpZmFjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgbWFjID0gbmV4dGxpbmVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmYWNlID0gbGluZXNbaV0uc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIG1hYyA9IGxpbmVzW2ldLnNwbGl0KCdIV2FkZHIgJylbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlmYWNlICYmIG1hYykge1xuICAgICAgICAgICAgcmVzdWx0W2lmYWNlXSA9IG1hYy50cmltKCk7XG4gICAgICAgICAgICBpZmFjZSA9ICcnO1xuICAgICAgICAgICAgbWFjID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9XG4gIGlmIChfZGFyd2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNtZCA9ICcvc2Jpbi9pZmNvbmZpZyc7XG4gICAgICBsZXQgcmVzID0gZXhlY1N5bmMoY21kKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gcmVzLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZXNbaV0gJiYgbGluZXNbaV1bMF0gIT09ICdcXHQnICYmIGxpbmVzW2ldLmluZGV4T2YoJzonKSA+IDApIHtcbiAgICAgICAgICBpZmFjZSA9IGxpbmVzW2ldLnNwbGl0KCc6JylbMF07XG4gICAgICAgIH0gZWxzZSBpZiAobGluZXNbaV0uaW5kZXhPZignXFx0ZXRoZXIgJykgPT09IDApIHtcbiAgICAgICAgICBtYWMgPSBsaW5lc1tpXS5zcGxpdCgnXFx0ZXRoZXIgJylbMV07XG4gICAgICAgICAgaWYgKGlmYWNlICYmIG1hYykge1xuICAgICAgICAgICAgcmVzdWx0W2lmYWNlXSA9IG1hYy50cmltKCk7XG4gICAgICAgICAgICBpZmFjZSA9ICcnO1xuICAgICAgICAgICAgbWFjID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtJbnRlcmZhY2VEZWZhdWx0KGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VEZWZhdWx0ID0gbmV0d29ya0ludGVyZmFjZURlZmF1bHQ7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBORVQgLSBpbnRlcmZhY2VzXG5cbmZ1bmN0aW9uIHBhcnNlTGluZXNXaW5kb3dzTmljcyhzZWN0aW9ucywgbmNvbmZpZ3NlY3Rpb25zKSB7XG4gIGxldCBuaWNzID0gW107XG4gIGZvciAobGV0IGkgaW4gc2VjdGlvbnMpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChzZWN0aW9ucywgaSkpIHtcblxuICAgICAgaWYgKHNlY3Rpb25zW2ldLnRyaW0oKSAhPT0gJycpIHtcblxuICAgICAgICBsZXQgbGluZXMgPSBzZWN0aW9uc1tpXS50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICBsZXQgbGluZXNOaWNDb25maWcgPSBuY29uZmlnc2VjdGlvbnMgJiYgbmNvbmZpZ3NlY3Rpb25zW2ldID8gbmNvbmZpZ3NlY3Rpb25zW2ldLnRyaW0oKS5zcGxpdCgnXFxyXFxuJykgOiBbXTtcbiAgICAgICAgbGV0IG5ldEVuYWJsZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmV0RW5hYmxlZCcsICc6Jyk7XG4gICAgICAgIGxldCBhZGFwdGVyVHlwZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBZGFwdGVyVHlwZUlEJywgJzonKSA9PT0gJzknID8gJ3dpcmVsZXNzJyA6ICd3aXJlZCc7XG4gICAgICAgIGxldCBpZmFjZW5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmFtZScsICc6JykucmVwbGFjZSgvXFxdL2csICcpJykucmVwbGFjZSgvXFxbL2csICcoJyk7XG4gICAgICAgIGxldCBpZmFjZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOZXRDb25uZWN0aW9uSUQnLCAnOicpLnJlcGxhY2UoL1xcXS9nLCAnKScpLnJlcGxhY2UoL1xcWy9nLCAnKCcpO1xuICAgICAgICBpZiAoaWZhY2VuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2ktZmknKSA+PSAwIHx8IGlmYWNlbmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpcmVsZXNzJykgPj0gMCkge1xuICAgICAgICAgIGFkYXB0ZXJUeXBlID0gJ3dpcmVsZXNzJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV0RW5hYmxlZCAhPT0gJycpIHtcbiAgICAgICAgICBjb25zdCBzcGVlZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdzcGVlZCcsICc6JykudHJpbSgpLCAxMCkgLyAxMDAwMDAwO1xuICAgICAgICAgIG5pY3MucHVzaCh7XG4gICAgICAgICAgICBtYWM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNQUNBZGRyZXNzJywgJzonKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZGhjcDogdXRpbC5nZXRWYWx1ZShsaW5lc05pY0NvbmZpZywgJ2RoY3BFbmFibGVkJywgJzonKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScsXG4gICAgICAgICAgICBuYW1lOiBpZmFjZW5hbWUsXG4gICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgIG5ldEVuYWJsZWQ6IG5ldEVuYWJsZWQgPT09ICdUUlVFJyxcbiAgICAgICAgICAgIHNwZWVkOiBpc05hTihzcGVlZCkgPyBudWxsIDogc3BlZWQsXG4gICAgICAgICAgICBvcGVyc3RhdGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOZXRDb25uZWN0aW9uU3RhdHVzJywgJzonKSA9PT0gJzInID8gJ3VwJyA6ICdkb3duJyxcbiAgICAgICAgICAgIHR5cGU6IGFkYXB0ZXJUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5pY3M7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NOaWNzKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCBjbWQgPSAnR2V0LUNpbUluc3RhbmNlIFdpbjMyX05ldHdvcmtBZGFwdGVyIHwgZmwgKicgKyAnOyBlY2hvIFxcJyMtIy0jLSNcXCc7JztcbiAgICAgIGNtZCArPSAnR2V0LUNpbUluc3RhbmNlIFdpbjMyX05ldHdvcmtBZGFwdGVyQ29uZmlndXJhdGlvbiB8IGZsIERIQ1BFbmFibGVkJyArICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKGNtZCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcjLSMtIy0jJyk7XG4gICAgICAgICAgY29uc3QgbnNlY3Rpb25zID0gKGRhdGFbMF0gfHwgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgY29uc3QgbmNvbmZpZ3NlY3Rpb25zID0gKGRhdGFbMV0gfHwgJycpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJzZUxpbmVzV2luZG93c05pY3MobnNlY3Rpb25zLCBuY29uZmlnc2VjdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c0ROU3N1ZmZpeGVzKCkge1xuXG4gIGxldCBpZmFjZSA9IHt9O1xuXG4gIGxldCBkbnNTdWZmaXhlcyA9IHtcbiAgICBwcmltYXJ5RE5TOiAnJyxcbiAgICBleGl0Q29kZTogMCxcbiAgICBpZmFjZXM6IFtdLFxuICB9O1xuXG4gIHRyeSB7XG4gICAgY29uc3QgaXBjb25maWcgPSBleGVjU3luYygnaXBjb25maWcgL2FsbCcsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgIGNvbnN0IGlwY29uZmlnQXJyYXkgPSBpcGNvbmZpZy5zcGxpdCgnXFxyXFxuXFxyXFxuJyk7XG5cbiAgICBpcGNvbmZpZ0FycmF5LmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG5cbiAgICAgIGlmIChpbmRleCA9PSAxKSB7XG4gICAgICAgIGNvbnN0IGxvbmdQcmltYXJ5RE5TID0gZWxlbWVudC5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9VcHBlckNhc2UoKS5pbmNsdWRlcygnRE5TJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmltYXJ5RE5TID0gbG9uZ1ByaW1hcnlETlNbMF0uc3Vic3RyaW5nKGxvbmdQcmltYXJ5RE5TWzBdLmxhc3RJbmRleE9mKCc6JykgKyAxKTtcbiAgICAgICAgZG5zU3VmZml4ZXMucHJpbWFyeUROUyA9IHByaW1hcnlETlMudHJpbSgpO1xuICAgICAgICBpZiAoIWRuc1N1ZmZpeGVzLnByaW1hcnlETlMpIHsgZG5zU3VmZml4ZXMucHJpbWFyeUROUyA9ICdOb3QgZGVmaW5lZCc7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA+IDEpIHtcbiAgICAgICAgaWYgKGluZGV4ICUgMiA9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsZW1lbnQuc3Vic3RyaW5nKGVsZW1lbnQubGFzdEluZGV4T2YoJyAnKSArIDEpLnJlcGxhY2UoJzonLCAnJyk7XG4gICAgICAgICAgaWZhY2UubmFtZSA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvblNwZWNpZmljRE5TID0gZWxlbWVudC5zcGxpdCgnXFxyXFxuJykuZmlsdGVyKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdETlMnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBkbnNTdWZmaXggPSBjb25uZWN0aW9uU3BlY2lmaWNETlNbMF0uc3Vic3RyaW5nKGNvbm5lY3Rpb25TcGVjaWZpY0ROU1swXS5sYXN0SW5kZXhPZignOicpICsgMSk7XG4gICAgICAgICAgaWZhY2UuZG5zU3VmZml4ID0gZG5zU3VmZml4LnRyaW0oKTtcbiAgICAgICAgICBkbnNTdWZmaXhlcy5pZmFjZXMucHVzaChpZmFjZSk7XG4gICAgICAgICAgaWZhY2UgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRuc1N1ZmZpeGVzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBwcmltYXJ5RE5TOiAnJyxcbiAgICAgIGV4aXRDb2RlOiAwLFxuICAgICAgaWZhY2VzOiBbXSxcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd3NJZmFjZUROU3N1ZmZpeChpZmFjZXMsIGlmYWNlbmFtZSkge1xuICBsZXQgZG5zU3VmZml4ID0gJyc7XG4gIC8vIEFkZGluZyAoLikgdG8gZW5zdXJlIGlmYWNlbmFtZSBjb21wYXRpYmlsaXR5IHdoZW4gZHVwbGljYXRlZCBpZmFjZS1uYW1lc1xuICBjb25zdCBpbnRlcmZhY2VOYW1lID0gaWZhY2VuYW1lICsgJy4nO1xuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25EbnNTdWZmaXggPSBpZmFjZXMuZmlsdGVyKChpZmFjZSkgPT4ge1xuICAgICAgcmV0dXJuIGludGVyZmFjZU5hbWUuaW5jbHVkZXMoaWZhY2UubmFtZSArICcuJyk7XG4gICAgfSkubWFwKChpZmFjZSkgPT4gaWZhY2UuZG5zU3VmZml4KTtcbiAgICBpZiAoY29ubmVjdGlvbkRuc1N1ZmZpeFswXSkge1xuICAgICAgZG5zU3VmZml4ID0gY29ubmVjdGlvbkRuc1N1ZmZpeFswXTtcbiAgICB9XG4gICAgaWYgKCFkbnNTdWZmaXgpIHsgZG5zU3VmZml4ID0gJyc7IH1cbiAgICByZXR1cm4gZG5zU3VmZml4O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93c1dpcmVkUHJvZmlsZXNJbmZvcm1hdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYygnbmV0c2ggbGFuIHNob3cgcHJvZmlsZXMnLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICBjb25zdCBwcm9maWxlTGlzdCA9IHJlc3VsdC5zcGxpdCgnXFxyXFxuUHJvZmlsZSBvbiBpbnRlcmZhY2UnKTtcbiAgICByZXR1cm4gcHJvZmlsZUxpc3Q7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gMSAmJiBlcnJvci5zdGRvdXQuaW5jbHVkZXMoJ0F1dG9Db25maWcnKSkge1xuICAgICAgcmV0dXJuICdEaXNhYmxlZCc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzV2lyZWxlc3NJZmFjZVNTSUQoaW50ZXJmYWNlTmFtZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGBuZXRzaCB3bGFuIHNob3cgIGludGVyZmFjZSBuYW1lPVwiJHtpbnRlcmZhY2VOYW1lfVwiIHwgZmluZHN0ciBcIlNTSURcImAsIHV0aWwuZXhlY09wdHNXaW4pO1xuICAgIGNvbnN0IFNTSUQgPSByZXN1bHQuc3BsaXQoJ1xcclxcbicpLnNoaWZ0KCk7XG4gICAgY29uc3QgcGFyc2VTU0lEID0gU1NJRC5zcGxpdCgnOicpLnBvcCgpO1xuICAgIHJldHVybiBwYXJzZVNTSUQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0V2luZG93c0lFRUU4MDIxeChjb25uZWN0aW9uVHlwZSwgaWZhY2UsIGlmYWNlcykge1xuICBsZXQgaTgwMjF4ID0ge1xuICAgIHN0YXRlOiAnVW5rbm93bicsXG4gICAgcHJvdG9jb2w6ICdVbmtub3duJyxcbiAgfTtcblxuICBpZiAoaWZhY2VzID09PSAnRGlzYWJsZWQnKSB7XG4gICAgaTgwMjF4LnN0YXRlID0gJ0Rpc2FibGVkJztcbiAgICBpODAyMXgucHJvdG9jb2wgPSAnTm90IGRlZmluZWQnO1xuICAgIHJldHVybiBpODAyMXg7XG4gIH1cblxuICBpZiAoY29ubmVjdGlvblR5cGUgPT0gJ3dpcmVkJyAmJiBpZmFjZXMubGVuZ3RoID4gMCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgODAyLjF4IGluZm9ybWF0aW9uIGJ5IGludGVyZmFjZSBuYW1lXG4gICAgICBjb25zdCBpZmFjZTgwMjF4SW5mbyA9IGlmYWNlcy5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmluY2x1ZGVzKGlmYWNlICsgJ1xcclxcbicpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBhcnJheUlmYWNlODAyMXhJbmZvID0gaWZhY2U4MDIxeEluZm8uc3BsaXQoJ1xcclxcbicpO1xuICAgICAgY29uc3Qgc3RhdGU4MDIxeCA9IGFycmF5SWZhY2U4MDIxeEluZm8uZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pbmNsdWRlcygnODAyLjF4Jyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0YXRlODAyMXguaW5jbHVkZXMoJ0Rpc2FibGVkJykpIHtcbiAgICAgICAgaTgwMjF4LnN0YXRlID0gJ0Rpc2FibGVkJztcbiAgICAgICAgaTgwMjF4LnByb3RvY29sID0gJ05vdCBkZWZpbmVkJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGU4MDIxeC5pbmNsdWRlcygnRW5hYmxlZCcpKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sODAyMXggPSBhcnJheUlmYWNlODAyMXhJbmZvLmZpbmQoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5pbmNsdWRlcygnRUFQJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpODAyMXgucHJvdG9jb2wgPSBwcm90b2NvbDgwMjF4LnNwbGl0KCc6JykucG9wKCk7XG4gICAgICAgIGk4MDIxeC5zdGF0ZSA9ICdFbmFibGVkJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGk4MDIxeDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29ubmVjdGlvblR5cGUgPT0gJ3dpcmVsZXNzJykge1xuXG4gICAgbGV0IGk4MDIxeFN0YXRlID0gJyc7XG4gICAgbGV0IGk4MDIxeFByb3RvY29sID0gJyc7XG5cblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFNTSUQgPSBnZXRXaW5kb3dzV2lyZWxlc3NJZmFjZVNTSUQoaWZhY2UpO1xuICAgICAgaWYgKFNTSUQgIT09ICdVbmtub3duJykge1xuICAgICAgICBpODAyMXhTdGF0ZSA9IGV4ZWNTeW5jKGBuZXRzaCB3bGFuIHNob3cgcHJvZmlsZXMgXCIke1NTSUR9XCIgfCBmaW5kc3RyIFwiODAyLjFYXCJgLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICAgICAgaTgwMjF4UHJvdG9jb2wgPSBleGVjU3luYyhgbmV0c2ggd2xhbiBzaG93IHByb2ZpbGVzIFwiJHtTU0lEfVwiIHwgZmluZHN0ciBcIkVBUFwiYCwgdXRpbC5leGVjT3B0c1dpbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpODAyMXhTdGF0ZS5pbmNsdWRlcygnOicpICYmIGk4MDIxeFByb3RvY29sLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgaTgwMjF4LnN0YXRlID0gaTgwMjF4U3RhdGUuc3BsaXQoJzonKS5wb3AoKTtcbiAgICAgICAgaTgwMjF4LnByb3RvY29sID0gaTgwMjF4UHJvdG9jb2wuc3BsaXQoJzonKS5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gMSAmJiBlcnJvci5zdGRvdXQuaW5jbHVkZXMoJ0F1dG9Db25maWcnKSkge1xuICAgICAgICBpODAyMXguc3RhdGUgPSAnRGlzYWJsZWQnO1xuICAgICAgICBpODAyMXgucHJvdG9jb2wgPSAnTm90IGRlZmluZWQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk4MDIxeDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTgwMjF4O1xufVxuXG5mdW5jdGlvbiBzcGxpdFNlY3Rpb25zTmljcyhsaW5lcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHNlY3Rpb24gPSBbXTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICghbGluZS5zdGFydHNXaXRoKCdcXHQnKSAmJiAhbGluZS5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgIGlmIChzZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChzZWN0aW9uKTtcbiAgICAgICAgc2VjdGlvbiA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWN0aW9uLnB1c2gobGluZSk7XG4gIH0pO1xuICBpZiAoc2VjdGlvbi5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbmVzRGFyd2luTmljcyhzZWN0aW9ucykge1xuICBsZXQgbmljcyA9IFtdO1xuICBzZWN0aW9ucy5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuICAgIGxldCBuaWMgPSB7XG4gICAgICBpZmFjZTogJycsXG4gICAgICBtdHU6IG51bGwsXG4gICAgICBtYWM6ICcnLFxuICAgICAgaXA2OiAnJyxcbiAgICAgIGlwNDogJycsXG4gICAgICBzcGVlZDogbnVsbCxcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgb3BlcnN0YXRlOiAnJyxcbiAgICAgIGR1cGxleDogJycsXG4gICAgICBpbnRlcm5hbDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGZpcnN0ID0gc2VjdGlvblswXTtcbiAgICBuaWMuaWZhY2UgPSBmaXJzdC5zcGxpdCgnOicpWzBdLnRyaW0oKTtcbiAgICBsZXQgcGFydHMgPSBmaXJzdC5zcGxpdCgnPiBtdHUnKTtcbiAgICBuaWMubXR1ID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnNlSW50KHBhcnRzWzFdLCAxMCkgOiBudWxsO1xuICAgIGlmIChpc05hTihuaWMubXR1KSkge1xuICAgICAgbmljLm10dSA9IG51bGw7XG4gICAgfVxuICAgIG5pYy5pbnRlcm5hbCA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbG9vcGJhY2snKSA+IC0xO1xuICAgIHNlY3Rpb24uZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdldGhlciAnKSkge1xuICAgICAgICBuaWMubWFjID0gbGluZS5zcGxpdCgnZXRoZXIgJylbMV0udG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnaW5ldDYgJykgJiYgIW5pYy5pcDYpIHtcbiAgICAgICAgbmljLmlwNiA9IGxpbmUuc3BsaXQoJ2luZXQ2ICcpWzFdLnRvTG93ZXJDYXNlKCkuc3BsaXQoJyUnKVswXS5zcGxpdCgnICcpWzBdO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2luZXQgJykgJiYgIW5pYy5pcDQpIHtcbiAgICAgICAgbmljLmlwNCA9IGxpbmUuc3BsaXQoJ2luZXQgJylbMV0udG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpWzBdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBzcGVlZCA9IHV0aWwuZ2V0VmFsdWUoc2VjdGlvbiwgJ2xpbmsgcmF0ZScpO1xuICAgIG5pYy5zcGVlZCA9IHNwZWVkID8gcGFyc2VGbG9hdChzcGVlZCkgOiBudWxsO1xuICAgIGlmIChuaWMuc3BlZWQgPT09IG51bGwpIHtcbiAgICAgIHNwZWVkID0gdXRpbC5nZXRWYWx1ZShzZWN0aW9uLCAndXBsaW5rIHJhdGUnKTtcbiAgICAgIG5pYy5zcGVlZCA9IHNwZWVkID8gcGFyc2VGbG9hdChzcGVlZCkgOiBudWxsO1xuICAgICAgaWYgKG5pYy5zcGVlZCAhPT0gbnVsbCAmJiBzcGVlZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2dicHMnKSA+PSAwKSB7XG4gICAgICAgIG5pYy5zcGVlZCA9IG5pYy5zcGVlZCAqIDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzcGVlZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2dicHMnKSA+PSAwKSB7XG4gICAgICAgIG5pYy5zcGVlZCA9IG5pYy5zcGVlZCAqIDEwMDA7XG4gICAgICB9XG4gICAgfVxuICAgIG5pYy50eXBlID0gdXRpbC5nZXRWYWx1ZShzZWN0aW9uLCAndHlwZScpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2ktZmknKSA+IC0xID8gJ3dpcmVsZXNzJyA6ICd3aXJlZCc7XG4gICAgY29uc3Qgb3BlcnN0YXRlID0gdXRpbC5nZXRWYWx1ZShzZWN0aW9uLCAnc3RhdHVzJykudG9Mb3dlckNhc2UoKTtcbiAgICBuaWMub3BlcnN0YXRlID0gKG9wZXJzdGF0ZSA9PT0gJ2FjdGl2ZScgPyAndXAnIDogKG9wZXJzdGF0ZSA9PT0gJ2luYWN0aXZlJyA/ICdkb3duJyA6ICd1bmtub3duJykpO1xuICAgIG5pYy5kdXBsZXggPSB1dGlsLmdldFZhbHVlKHNlY3Rpb24sICdtZWRpYScpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaGFsZi1kdXBsZXgnKSA+IC0xID8gJ2hhbGYnIDogJ2Z1bGwnO1xuICAgIGlmIChuaWMuaXA2IHx8IG5pYy5pcDQgfHwgbmljLm1hYykge1xuICAgICAgbmljcy5wdXNoKG5pYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5pY3M7XG59XG5cbmZ1bmN0aW9uIGdldERhcndpbk5pY3MoKSB7XG4gIGNvbnN0IGNtZCA9ICcvc2Jpbi9pZmNvbmZpZyAtdic7XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgbnNlY3Rpb25zID0gc3BsaXRTZWN0aW9uc05pY3MobGluZXMpO1xuICAgIHJldHVybiAocGFyc2VMaW5lc0Rhcndpbk5pY3MobnNlY3Rpb25zKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGludXhJZmFjZUNvbm5lY3Rpb25OYW1lKGludGVyZmFjZU5hbWUpIHtcbiAgY29uc3QgY21kID0gYG5tY2xpIGRldmljZSBzdGF0dXMgMj4vZGV2L251bGwgfCBncmVwICR7aW50ZXJmYWNlTmFtZX1gO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpO1xuICAgIGNvbnN0IHJlc3VsdEZvcm1hdCA9IHJlc3VsdC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25OYW1lTGluZXMgPSByZXN1bHRGb3JtYXQuc3BsaXQoJyAnKS5zbGljZSgzKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTmFtZSA9IGNvbm5lY3Rpb25OYW1lTGluZXMuam9pbignICcpO1xuICAgIHJldHVybiBjb25uZWN0aW9uTmFtZSAhPSAnLS0nID8gY29ubmVjdGlvbk5hbWUgOiAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0xpbnV4RENIUEludGVyZmFjZXMoZmlsZSkge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIHRyeSB7XG4gICAgbGV0IGNtZCA9IGBjYXQgJHtmaWxlfSAyPiAvZGV2L251bGwgfCBncmVwICdpZmFjZVxcXFx8c291cmNlJ2A7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBpbmV0ICcpID49IDAgJiYgbGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RoY3AnKSA+PSAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFydHNbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdzb3VyY2UnKSkge1xuICAgICAgICBsZXQgZmlsZSA9IGxpbmUuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjaGVja0xpbnV4RENIUEludGVyZmFjZXMoZmlsZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0TGludXhESENQTmljcygpIHtcbiAgLy8gYWx0ZXJuYXRlIG1ldGhvZHMgZ2V0dGluZyBpbnRlcmZhY2VzIHVzaW5nIERIQ1BcbiAgbGV0IGNtZCA9ICdpcCBhIDI+IC9kZXYvbnVsbCc7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBuc2VjdGlvbnMgPSBzcGxpdFNlY3Rpb25zTmljcyhsaW5lcyk7XG4gICAgcmVzdWx0ID0gKHBhcnNlTGludXhESENQTmljcyhuc2VjdGlvbnMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHV0aWwubm9vcCgpO1xuICB9XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gY2hlY2tMaW51eERDSFBJbnRlcmZhY2VzKCcvZXRjL25ldHdvcmsvaW50ZXJmYWNlcycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eERIQ1BOaWNzKHNlY3Rpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBpZiAoc2VjdGlvbnMgJiYgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgc2VjdGlvbnMuZm9yRWFjaChsaW5lcyA9PiB7XG4gICAgICBpZiAobGluZXMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3BsaXQoJzonKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcgaW5ldCAnKSA+PSAwICYmIGxpbmUuaW5kZXhPZignIGR5bmFtaWMgJykgPj0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0czIgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGNvbnN0IG5pYyA9IHBhcnRzMltwYXJ0czIubGVuZ3RoIC0gMV0udHJpbSgpO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChuaWMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRMaW51eElmYWNlREhDUHN0YXR1cyhpZmFjZSwgY29ubmVjdGlvbk5hbWUsIERIQ1BOaWNzKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGNvbm5lY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgY21kID0gYG5tY2xpIGNvbm5lY3Rpb24gc2hvdyBcIiR7Y29ubmVjdGlvbk5hbWV9XCIgMj4vZGV2L251bGwgfCBncmVwIGlwdjQubWV0aG9kO2A7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVzdWx0Rm9ybWF0ID0gbGluZXMucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgbGV0IGRoY1N0YXR1cyA9IHJlc3VsdEZvcm1hdC5zcGxpdCgnICcpLnNsaWNlKDEpLnRvU3RyaW5nKCk7XG4gICAgICBzd2l0Y2ggKGRoY1N0YXR1cykge1xuICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAoREhDUE5pY3MuaW5kZXhPZihpZmFjZSkgPj0gMCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoREhDUE5pY3MuaW5kZXhPZihpZmFjZSkgPj0gMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGFyd2luSWZhY2VESENQc3RhdHVzKGlmYWNlKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgY29uc3QgY21kID0gYGlwY29uZmlnIGdldHBhY2tldCBcIiR7aWZhY2V9XCIgMj4vZGV2L251bGwgfCBncmVwIGxlYXNlX3RpbWU7YDtcbiAgdHJ5IHtcbiAgICBjb25zdCBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5zdGFydHNXaXRoKCdsZWFzZV90aW1lJykpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdXRpbC5ub29wKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0TGludXhJZmFjZUROU3N1ZmZpeChjb25uZWN0aW9uTmFtZSkge1xuICBpZiAoY29ubmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCBjbWQgPSBgbm1jbGkgY29ubmVjdGlvbiBzaG93IFwiJHtjb25uZWN0aW9uTmFtZX1cIiAyPi9kZXYvbnVsbCB8IGdyZXAgaXB2NC5kbnMtc2VhcmNoO2A7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHJlc3VsdEZvcm1hdCA9IHJlc3VsdC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgY29uc3QgZG5zU3VmZml4ID0gcmVzdWx0Rm9ybWF0LnNwbGl0KCcgJykuc2xpY2UoMSkudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBkbnNTdWZmaXggPT0gJy0tJyA/ICdOb3QgZGVmaW5lZCcgOiBkbnNTdWZmaXg7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRMaW51eElmYWNlSUVFRTgwMjF4QXV0aChjb25uZWN0aW9uTmFtZSkge1xuICBpZiAoY29ubmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCBjbWQgPSBgbm1jbGkgY29ubmVjdGlvbiBzaG93IFwiJHtjb25uZWN0aW9uTmFtZX1cIiAyPi9kZXYvbnVsbCB8IGdyZXAgODAyLTF4LmVhcDtgO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCByZXN1bHRGb3JtYXQgPSByZXN1bHQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uUHJvdG9jb2wgPSByZXN1bHRGb3JtYXQuc3BsaXQoJyAnKS5zbGljZSgxKS50b1N0cmluZygpO1xuXG5cbiAgICAgIHJldHVybiBhdXRoZW50aWNhdGlvblByb3RvY29sID09ICctLScgPyAnJyA6IGF1dGhlbnRpY2F0aW9uUHJvdG9jb2w7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICdOb3QgZGVmaW5lZCc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnTm90IGRlZmluZWQnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldExpbnV4SWZhY2VJRUVFODAyMXhTdGF0ZShhdXRoZW50aWNhdGlvblByb3RvY29sKSB7XG4gIGlmIChhdXRoZW50aWNhdGlvblByb3RvY29sKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uUHJvdG9jb2wgPT0gJ05vdCBkZWZpbmVkJykge1xuICAgICAgcmV0dXJuICdEaXNhYmxlZCc7XG4gICAgfVxuICAgIHJldHVybiAnRW5hYmxlZCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0VmlydHVhbE5pYyhpZmFjZSwgaWZhY2VOYW1lLCBtYWMpIHtcbiAgY29uc3QgdmlydHVhbE1hY3MgPSBbJzAwOjAwOjAwOjAwOjAwOjAwJywgJzAwOjAzOkZGJywgJzAwOjA1OjY5JywgJzAwOjBDOjI5JywgJzAwOjBGOjRCJywgJzAwOjBGOjRCJywgJzAwOjEzOjA3JywgJzAwOjEzOkJFJywgJzAwOjE1OjVkJywgJzAwOjE2OjNFJywgJzAwOjFDOjQyJywgJzAwOjIxOkY2JywgJzAwOjIxOkY2JywgJzAwOjI0OjBCJywgJzAwOjI0OjBCJywgJzAwOjUwOjU2JywgJzAwOkEwOkIxJywgJzAwOkUwOkM4JywgJzA4OjAwOjI3JywgJzBBOjAwOjI3JywgJzE4OjkyOjJDJywgJzE2OkRGOjQ5JywgJzNDOkYzOjkyJywgJzU0OjUyOjAwJywgJ0ZDOjE1Ojk3J107XG4gIGlmIChtYWMpIHtcbiAgICByZXR1cm4gdmlydHVhbE1hY3MuZmlsdGVyKGl0ZW0gPT4geyByZXR1cm4gbWFjLnRvVXBwZXJDYXNlKCkudG9VcHBlckNhc2UoKS5zdGFydHNXaXRoKGl0ZW0uc3Vic3RyKDAsIG1hYy5sZW5ndGgpKTsgfSkubGVuZ3RoID4gMCB8fFxuICAgICAgaWZhY2UudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgdmlydHVhbCAnKSA+IC0xIHx8XG4gICAgICBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcgdmlydHVhbCAnKSA+IC0xIHx8XG4gICAgICBpZmFjZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3ZldGhlcm5ldCAnKSA+IC0xIHx8XG4gICAgICBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd2ZXRoZXJuZXQgJykgPiAtMSB8fFxuICAgICAgaWZhY2UudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2ZXRoJykgfHxcbiAgICAgIGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3ZldGgnKSB8fFxuICAgICAgaWZhY2UudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd2Ym94bmV0JykgfHxcbiAgICAgIGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Zib3huZXQnKTtcbiAgfSBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtJbnRlcmZhY2VzKGNhbGxiYWNrLCByZXNjYW4sIGRlZmF1bHRTdHJpbmcpIHtcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgIGRlZmF1bHRTdHJpbmcgPSBjYWxsYmFjaztcbiAgICByZXNjYW4gPSB0cnVlO1xuICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdib29sZWFuJykge1xuICAgIHJlc2NhbiA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICBkZWZhdWx0U3RyaW5nID0gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNjYW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVzY2FuID0gdHJ1ZTtcbiAgfVxuICBkZWZhdWx0U3RyaW5nID0gZGVmYXVsdFN0cmluZyB8fCAnJztcbiAgZGVmYXVsdFN0cmluZyA9ICcnICsgZGVmYXVsdFN0cmluZztcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IGlmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG5cbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGxldCBuaWNzID0gW107XG4gICAgICBsZXQgZG5zU3VmZml4ZXMgPSBbXTtcbiAgICAgIGxldCBuaWNzODAyMXhJbmZvID0gW107XG4gICAgICAvLyBzZXBlcmF0ZSBoYW5kbGluZyBpbiBPU1hcbiAgICAgIGlmIChfZGFyd2luIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgaWYgKChKU09OLnN0cmluZ2lmeShpZmFjZXMpID09PSBKU09OLnN0cmluZ2lmeShfaWZhY2VzKSkgJiYgIXJlc2Nhbikge1xuICAgICAgICAgIC8vIG5vIGNoYW5nZXMgLSBqdXN0IHJldHVybiBvYmplY3RcbiAgICAgICAgICByZXN1bHQgPSBfbmV0d29ya0ludGVyZmFjZXM7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0SW50ZXJmYWNlID0gZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKTtcbiAgICAgICAgICBfaWZhY2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpZmFjZXMpKTtcblxuICAgICAgICAgIG5pY3MgPSBnZXREYXJ3aW5OaWNzKCk7XG5cblxuICAgICAgICAgIG5pY3MuZm9yRWFjaChuaWMgPT4ge1xuXG4gICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChpZmFjZXMsIG5pYy5pZmFjZSkpIHtcbiAgICAgICAgICAgICAgaWZhY2VzW25pYy5pZmFjZV0uZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjQnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICBuaWMuaXA0c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY2JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgbmljLmlwNnN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaWZhY2VTYW5pdGl6ZWQgPSAnJztcbiAgICAgICAgICAgIGNvbnN0IHMgPSB1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSA/ICctLS0nIDogdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKG5pYy5pZmFjZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmYWNlU2FuaXRpemVkID0gaWZhY2VTYW5pdGl6ZWQgKyBzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgaWZhY2U6IG5pYy5pZmFjZSxcbiAgICAgICAgICAgICAgaWZhY2VOYW1lOiBuaWMuaWZhY2UsXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IG5pYy5pZmFjZSA9PT0gZGVmYXVsdEludGVyZmFjZSxcbiAgICAgICAgICAgICAgaXA0OiBuaWMuaXA0LFxuICAgICAgICAgICAgICBpcDRzdWJuZXQ6IG5pYy5pcDRzdWJuZXQgfHwgJycsXG4gICAgICAgICAgICAgIGlwNjogbmljLmlwNixcbiAgICAgICAgICAgICAgaXA2c3VibmV0OiBuaWMuaXA2c3VibmV0IHx8ICcnLFxuICAgICAgICAgICAgICBtYWM6IG5pYy5tYWMsXG4gICAgICAgICAgICAgIGludGVybmFsOiBuaWMuaW50ZXJuYWwsXG4gICAgICAgICAgICAgIHZpcnR1YWw6IG5pYy5pbnRlcm5hbCA/IGZhbHNlIDogdGVzdFZpcnR1YWxOaWMobmljLmlmYWNlLCBuaWMuaWZhY2UsIG5pYy5tYWMpLFxuICAgICAgICAgICAgICBvcGVyc3RhdGU6IG5pYy5vcGVyc3RhdGUsXG4gICAgICAgICAgICAgIHR5cGU6IG5pYy50eXBlLFxuICAgICAgICAgICAgICBkdXBsZXg6IG5pYy5kdXBsZXgsXG4gICAgICAgICAgICAgIG10dTogbmljLm10dSxcbiAgICAgICAgICAgICAgc3BlZWQ6IG5pYy5zcGVlZCxcbiAgICAgICAgICAgICAgZGhjcDogZ2V0RGFyd2luSWZhY2VESENQc3RhdHVzKGlmYWNlU2FuaXRpemVkKSxcbiAgICAgICAgICAgICAgZG5zU3VmZml4OiAnJyxcbiAgICAgICAgICAgICAgaWVlZTgwMjF4QXV0aDogJycsXG4gICAgICAgICAgICAgIGllZWU4MDIxeFN0YXRlOiAnJyxcbiAgICAgICAgICAgICAgY2FycmllckNoYW5nZXM6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9uZXR3b3JrSW50ZXJmYWNlcyA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAoZGVmYXVsdFN0cmluZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RlZmF1bHQnKSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgaWYgKChKU09OLnN0cmluZ2lmeShpZmFjZXMpID09PSBKU09OLnN0cmluZ2lmeShfaWZhY2VzKSkgJiYgIXJlc2Nhbikge1xuICAgICAgICAgIC8vIG5vIGNoYW5nZXMgLSBqdXN0IHJldHVybiBvYmplY3RcbiAgICAgICAgICByZXN1bHQgPSBfbmV0d29ya0ludGVyZmFjZXM7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaWZhY2VzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpZmFjZXMpKTtcbiAgICAgICAgICBfZGhjcE5pY3MgPSBnZXRMaW51eERIQ1BOaWNzKCk7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEludGVyZmFjZSA9IGdldERlZmF1bHROZXR3b3JrSW50ZXJmYWNlKCk7XG4gICAgICAgICAgZm9yIChsZXQgZGV2IGluIGlmYWNlcykge1xuICAgICAgICAgICAgbGV0IGlwNCA9ICcnO1xuICAgICAgICAgICAgbGV0IGlwNHN1Ym5ldCA9ICcnO1xuICAgICAgICAgICAgbGV0IGlwNiA9ICcnO1xuICAgICAgICAgICAgbGV0IGlwNnN1Ym5ldCA9ICcnO1xuICAgICAgICAgICAgbGV0IG1hYyA9ICcnO1xuICAgICAgICAgICAgbGV0IGR1cGxleCA9ICcnO1xuICAgICAgICAgICAgbGV0IG10dSA9ICcnO1xuICAgICAgICAgICAgbGV0IHNwZWVkID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjYXJyaWVyQ2hhbmdlcyA9IDA7XG4gICAgICAgICAgICBsZXQgZGhjcCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRuc1N1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgbGV0IGllZWU4MDIxeEF1dGggPSAnJztcbiAgICAgICAgICAgIGxldCBpZWVlODAyMXhTdGF0ZSA9ICcnO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSAnJztcblxuICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBkZXYpKSB7XG4gICAgICAgICAgICAgIGxldCBpZmFjZU5hbWUgPSBkZXY7XG4gICAgICAgICAgICAgIGlmYWNlc1tkZXZdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY0JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgaXA0ID0gZGV0YWlscy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgaXA0c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY2JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpcDYgfHwgaXA2Lm1hdGNoKC9eZmU4MDo6L2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlwNiA9IGRldGFpbHMuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgaXA2c3VibmV0ID0gZGV0YWlscy5uZXRtYXNrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYWMgPSBkZXRhaWxzLm1hYztcbiAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8xMzU4MSAobm9kZSA4LjEgLSBub2RlIDguMilcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFpblZlcnNpb24gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChtYWMuaW5kZXhPZignMDA6MDA6MCcpID4gLTEgJiYgKF9saW51eCB8fCBfZGFyd2luKSAmJiAoIWRldGFpbHMuaW50ZXJuYWwpICYmIG5vZGVNYWluVmVyc2lvbiA+PSA4ICYmIG5vZGVNYWluVmVyc2lvbiA8PSAxMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKF9tYWMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfbWFjID0gZ2V0TWFjQWRkcmVzc2VzKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtYWMgPSBfbWFjW2Rldl0gfHwgJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbGV0IGlmYWNlID0gZGV2LnNwbGl0KCc6JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGxldCBpZmFjZVNhbml0aXplZCA9ICcnO1xuICAgICAgICAgICAgICBjb25zdCBzID0gdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnLS0tJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhpZmFjZSk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmYWNlU2FuaXRpemVkID0gaWZhY2VTYW5pdGl6ZWQgKyBzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcImFkZHJfYXNzaWduX3R5cGU6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vYWRkcl9hc3NpZ25fdHlwZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJhZGRyZXNzOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2FkZHJlc3MgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYWRkcl9sZW46IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vYWRkcl9sZW4gMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYnJvYWRjYXN0OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2Jyb2FkY2FzdCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjYXJyaWVyOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2NhcnJpZXIgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2Fycmllcl9jaGFuZ2VzOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2NhcnJpZXJfY2hhbmdlcyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJkZXZfaWQ6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZGV2X2lkIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImRldl9wb3J0OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2Rldl9wb3J0IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImRvcm1hbnQ6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZG9ybWFudCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJkdXBsZXg6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vZHVwbGV4IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImZsYWdzOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2ZsYWdzIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImdyb19mbHVzaF90aW1lb3V0OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2dyb19mbHVzaF90aW1lb3V0IDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImlmYWxpYXM6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vaWZhbGlhcyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJpZmluZGV4OiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2lmaW5kZXggMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiaWZsaW5rOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L2lmbGluayAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJsaW5rX21vZGU6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vbGlua19tb2RlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcIm10dTogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9tdHUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwibmV0ZGV2X2dyb3VwOiBcIjsgY2F0IC9zeXMvY2xhc3MvbmV0LyR7aWZhY2VTYW5pdGl6ZWR9L25ldGRldl9ncm91cCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJvcGVyc3RhdGU6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vb3BlcnN0YXRlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInByb3RvX2Rvd246IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vcHJvdG9fZG93biAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJzcGVlZDogXCI7IGNhdCAvc3lzL2NsYXNzL25ldC8ke2lmYWNlU2FuaXRpemVkfS9zcGVlZCAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJ0eF9xdWV1ZV9sZW46IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vdHhfcXVldWVfbGVuIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcInR5cGU6IFwiOyBjYXQgL3N5cy9jbGFzcy9uZXQvJHtpZmFjZVNhbml0aXplZH0vdHlwZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJ3aXJlbGVzczogXCI7IGNhdCAvcHJvYy9uZXQvd2lyZWxlc3MgMj4vZGV2L251bGwgfCBncmVwICR7aWZhY2VTYW5pdGl6ZWR9OyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcIndpcmVsZXNzc3BlZWQ6IFwiOyBpdyBkZXYgJHtpZmFjZVNhbml0aXplZH0gbGluayAyPiYxIHwgZ3JlcCBiaXRyYXRlOyBlY2hvO2A7XG5cbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25OYW1lID0gZ2V0TGludXhJZmFjZUNvbm5lY3Rpb25OYW1lKGlmYWNlU2FuaXRpemVkKTtcbiAgICAgICAgICAgICAgICBkaGNwID0gZ2V0TGludXhJZmFjZURIQ1BzdGF0dXMoaWZhY2VTYW5pdGl6ZWQsIGNvbm5lY3Rpb25OYW1lLCBfZGhjcE5pY3MpO1xuICAgICAgICAgICAgICAgIGRuc1N1ZmZpeCA9IGdldExpbnV4SWZhY2VETlNzdWZmaXgoY29ubmVjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGllZWU4MDIxeEF1dGggPSBnZXRMaW51eElmYWNlSUVFRTgwMjF4QXV0aChjb25uZWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4U3RhdGUgPSBnZXRMaW51eElmYWNlSUVFRTgwMjF4U3RhdGUoaWVlZTgwMjF4QXV0aCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkdXBsZXggPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnZHVwbGV4Jyk7XG4gICAgICAgICAgICAgIGR1cGxleCA9IGR1cGxleC5zdGFydHNXaXRoKCdjYXQnKSA/ICcnIDogZHVwbGV4O1xuICAgICAgICAgICAgICBtdHUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnbXR1JyksIDEwKTtcbiAgICAgICAgICAgICAgbGV0IG15c3BlZWQgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3BlZWQnKSwgMTApO1xuICAgICAgICAgICAgICBzcGVlZCA9IGlzTmFOKG15c3BlZWQpID8gbnVsbCA6IG15c3BlZWQ7XG4gICAgICAgICAgICAgIGxldCB3aXJlbGVzc3NwZWVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3dpcmVsZXNzc3BlZWQnKS5zcGxpdCgndHggYml0cmF0ZTogJyk7XG4gICAgICAgICAgICAgIGlmIChzcGVlZCA9PT0gbnVsbCAmJiB3aXJlbGVzc3NwZWVkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIG15c3BlZWQgPSBwYXJzZUZsb2F0KHdpcmVsZXNzc3BlZWRbMV0pO1xuICAgICAgICAgICAgICAgIHNwZWVkID0gaXNOYU4obXlzcGVlZCkgPyBudWxsIDogbXlzcGVlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXJyaWVyQ2hhbmdlcyA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjYXJyaWVyX2NoYW5nZXMnKSwgMTApO1xuICAgICAgICAgICAgICBjb25zdCBvcGVyc3RhdGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnb3BlcnN0YXRlJyk7XG4gICAgICAgICAgICAgIHR5cGUgPSBvcGVyc3RhdGUgPT09ICd1cCcgPyAodXRpbC5nZXRWYWx1ZShsaW5lcywgJ3dpcmVsZXNzJykudHJpbSgpID8gJ3dpcmVsZXNzJyA6ICd3aXJlZCcpIDogJ3Vua25vd24nO1xuICAgICAgICAgICAgICBpZiAoaWZhY2VTYW5pdGl6ZWQgPT09ICdsbycgfHwgaWZhY2VTYW5pdGl6ZWQuc3RhcnRzV2l0aCgnYm9uZCcpKSB7IHR5cGUgPSAndmlydHVhbCc7IH1cblxuICAgICAgICAgICAgICBsZXQgaW50ZXJuYWwgPSAoaWZhY2VzW2Rldl0gJiYgaWZhY2VzW2Rldl1bMF0pID8gaWZhY2VzW2Rldl1bMF0uaW50ZXJuYWwgOiBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGRldi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2xvb3BiYWNrJykgPiAtMSB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdsb29wYmFjaycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgdmlydHVhbCA9IGludGVybmFsID8gZmFsc2UgOiB0ZXN0VmlydHVhbE5pYyhkZXYsIGlmYWNlTmFtZSwgbWFjKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGlmYWNlOiBpZmFjZVNhbml0aXplZCxcbiAgICAgICAgICAgICAgICBpZmFjZU5hbWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogaWZhY2UgPT09IGRlZmF1bHRJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgaXA0LFxuICAgICAgICAgICAgICAgIGlwNHN1Ym5ldCxcbiAgICAgICAgICAgICAgICBpcDYsXG4gICAgICAgICAgICAgICAgaXA2c3VibmV0LFxuICAgICAgICAgICAgICAgIG1hYyxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbCxcbiAgICAgICAgICAgICAgICB2aXJ0dWFsLFxuICAgICAgICAgICAgICAgIG9wZXJzdGF0ZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGR1cGxleCxcbiAgICAgICAgICAgICAgICBtdHUsXG4gICAgICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICAgICAgZGhjcCxcbiAgICAgICAgICAgICAgICBkbnNTdWZmaXgsXG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4QXV0aCxcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhTdGF0ZSxcbiAgICAgICAgICAgICAgICBjYXJyaWVyQ2hhbmdlcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9uZXR3b3JrSW50ZXJmYWNlcyA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAoZGVmYXVsdFN0cmluZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2RlZmF1bHQnKSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5kZWZhdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBpZiAoKEpTT04uc3RyaW5naWZ5KGlmYWNlcykgPT09IEpTT04uc3RyaW5naWZ5KF9pZmFjZXMpKSAmJiAhcmVzY2FuKSB7XG4gICAgICAgICAgLy8gbm8gY2hhbmdlcyAtIGp1c3QgcmV0dXJuIG9iamVjdFxuICAgICAgICAgIHJlc3VsdCA9IF9uZXR3b3JrSW50ZXJmYWNlcztcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pZmFjZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlmYWNlcykpO1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRJbnRlcmZhY2UgPSBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuXG4gICAgICAgICAgZ2V0V2luZG93c05pY3MoKS50aGVuKGZ1bmN0aW9uIChuaWNzKSB7XG4gICAgICAgICAgICBuaWNzLmZvckVhY2gobmljID0+IHtcbiAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGlmYWNlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIGlmYWNlc1trZXldLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmluZGV4T2YoJ21hYycpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlWydtYWMnXSA9PT0gbmljLm1hYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWZhY2VzW25pYy5uYW1lXSA9IFt7IG1hYzogbmljLm1hYyB9XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuaWNzODAyMXhJbmZvID0gZ2V0V2luZG93c1dpcmVkUHJvZmlsZXNJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgZG5zU3VmZml4ZXMgPSBnZXRXaW5kb3dzRE5Tc3VmZml4ZXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRldiBpbiBpZmFjZXMpIHtcblxuICAgICAgICAgICAgICBsZXQgaWZhY2VTYW5pdGl6ZWQgPSAnJztcbiAgICAgICAgICAgICAgY29uc3QgcyA9IHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJy0tLScgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcoZGV2KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdXRpbC5tYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWZhY2VTYW5pdGl6ZWQgPSBpZmFjZVNhbml0aXplZCArIHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IGlmYWNlID0gZGV2O1xuICAgICAgICAgICAgICBsZXQgaXA0ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBpcDRzdWJuZXQgPSAnJztcbiAgICAgICAgICAgICAgbGV0IGlwNiA9ICcnO1xuICAgICAgICAgICAgICBsZXQgaXA2c3VibmV0ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBtYWMgPSAnJztcbiAgICAgICAgICAgICAgbGV0IGR1cGxleCA9ICcnO1xuICAgICAgICAgICAgICBsZXQgbXR1ID0gJyc7XG4gICAgICAgICAgICAgIGxldCBzcGVlZCA9IG51bGw7XG4gICAgICAgICAgICAgIGxldCBjYXJyaWVyQ2hhbmdlcyA9IDA7XG4gICAgICAgICAgICAgIGxldCBvcGVyc3RhdGUgPSAnZG93bic7XG4gICAgICAgICAgICAgIGxldCBkaGNwID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBkbnNTdWZmaXggPSAnJztcbiAgICAgICAgICAgICAgbGV0IGllZWU4MDIxeEF1dGggPSAnJztcbiAgICAgICAgICAgICAgbGV0IGllZWU4MDIxeFN0YXRlID0gJyc7XG4gICAgICAgICAgICAgIGxldCB0eXBlID0gJyc7XG5cbiAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBkZXYpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlmYWNlTmFtZSA9IGRldjtcbiAgICAgICAgICAgICAgICBpZmFjZXNbZGV2XS5mb3JFYWNoKGZ1bmN0aW9uIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5mYW1pbHkgPT09ICdJUHY0JyB8fCBkZXRhaWxzLmZhbWlseSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpcDQgPSBkZXRhaWxzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlwNHN1Ym5ldCA9IGRldGFpbHMubmV0bWFzaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmZhbWlseSA9PT0gJ0lQdjYnIHx8IGRldGFpbHMuZmFtaWx5ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXA2IHx8IGlwNi5tYXRjaCgvXmZlODA6Oi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlwNiA9IGRldGFpbHMuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICBpcDZzdWJuZXQgPSBkZXRhaWxzLm5ldG1hc2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG1hYyA9IGRldGFpbHMubWFjO1xuICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMTM1ODEgKG5vZGUgOC4xIC0gbm9kZSA4LjIpXG4gICAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFpblZlcnNpb24gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hYy5pbmRleE9mKCcwMDowMDowJykgPiAtMSAmJiAoX2xpbnV4IHx8IF9kYXJ3aW4pICYmICghZGV0YWlscy5pbnRlcm5hbCkgJiYgbm9kZU1haW5WZXJzaW9uID49IDggJiYgbm9kZU1haW5WZXJzaW9uIDw9IDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhfbWFjKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBfbWFjID0gZ2V0TWFjQWRkcmVzc2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFjID0gX21hY1tkZXZdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG5cblxuICAgICAgICAgICAgICAgIGRuc1N1ZmZpeCA9IGdldFdpbmRvd3NJZmFjZUROU3N1ZmZpeChkbnNTdWZmaXhlcy5pZmFjZXMsIGlmYWNlU2FuaXRpemVkKTtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5pY3MuZm9yRWFjaChkZXRhaWwgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbC5tYWMgPT09IG1hYyAmJiAhZm91bmRGaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBpZmFjZSA9IGRldGFpbC5pZmFjZSB8fCBpZmFjZTtcbiAgICAgICAgICAgICAgICAgICAgaWZhY2VOYW1lID0gZGV0YWlsLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGRoY3AgPSBkZXRhaWwuZGhjcDtcbiAgICAgICAgICAgICAgICAgICAgb3BlcnN0YXRlID0gZGV0YWlsLm9wZXJzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgPSBkZXRhaWwuc3BlZWQ7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkZXRhaWwudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRGaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGV2LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2xhbicpID49IDAgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2xhbicpID49IDAgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignODAyLjExbicpID49IDAgfHwgaWZhY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2lyZWxlc3MnKSA+PSAwIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dpLWZpJykgPj0gMCB8fCBpZmFjZU5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd3aWZpJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgdHlwZSA9ICd3aXJlbGVzcyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgSUVFRTgwMjF4ID0gZ2V0V2luZG93c0lFRUU4MDIxeCh0eXBlLCBpZmFjZVNhbml0aXplZCwgbmljczgwMjF4SW5mbyk7XG4gICAgICAgICAgICAgICAgaWVlZTgwMjF4QXV0aCA9IElFRUU4MDIxeC5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICBpZWVlODAyMXhTdGF0ZSA9IElFRUU4MDIxeC5zdGF0ZTtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJuYWwgPSAoaWZhY2VzW2Rldl0gJiYgaWZhY2VzW2Rldl1bMF0pID8gaWZhY2VzW2Rldl1bMF0uaW50ZXJuYWwgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZGV2LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbG9vcGJhY2snKSA+IC0xIHx8IGlmYWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2xvb3BiYWNrJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgaW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsID0gaW50ZXJuYWwgPyBmYWxzZSA6IHRlc3RWaXJ0dWFsTmljKGRldiwgaWZhY2VOYW1lLCBtYWMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgICAgICAgaWZhY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogaWZhY2UgPT09IGRlZmF1bHRJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgICBpcDQsXG4gICAgICAgICAgICAgICAgICBpcDRzdWJuZXQsXG4gICAgICAgICAgICAgICAgICBpcDYsXG4gICAgICAgICAgICAgICAgICBpcDZzdWJuZXQsXG4gICAgICAgICAgICAgICAgICBtYWMsXG4gICAgICAgICAgICAgICAgICBpbnRlcm5hbCxcbiAgICAgICAgICAgICAgICAgIHZpcnR1YWwsXG4gICAgICAgICAgICAgICAgICBvcGVyc3RhdGUsXG4gICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgZHVwbGV4LFxuICAgICAgICAgICAgICAgICAgbXR1LFxuICAgICAgICAgICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgICAgICAgICBkaGNwLFxuICAgICAgICAgICAgICAgICAgZG5zU3VmZml4LFxuICAgICAgICAgICAgICAgICAgaWVlZTgwMjF4QXV0aCxcbiAgICAgICAgICAgICAgICAgIGllZWU4MDIxeFN0YXRlLFxuICAgICAgICAgICAgICAgICAgY2FycmllckNoYW5nZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXR3b3JrSW50ZXJmYWNlcyA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0U3RyaW5nLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZGVmYXVsdCcpID49IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihpdGVtID0+IGl0ZW0uZGVmYXVsdCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlcyA9IG5ldHdvcmtJbnRlcmZhY2VzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTkVUIC0gU3BlZWRcblxuZnVuY3Rpb24gY2FsY05ldHdvcmtTcGVlZChpZmFjZSwgcnhfYnl0ZXMsIHR4X2J5dGVzLCBvcGVyc3RhdGUsIHJ4X2Ryb3BwZWQsIHJ4X2Vycm9ycywgdHhfZHJvcHBlZCwgdHhfZXJyb3JzKSB7XG4gIGxldCByZXN1bHQgPSB7XG4gICAgaWZhY2UsXG4gICAgb3BlcnN0YXRlLFxuICAgIHJ4X2J5dGVzLFxuICAgIHJ4X2Ryb3BwZWQsXG4gICAgcnhfZXJyb3JzLFxuICAgIHR4X2J5dGVzLFxuICAgIHR4X2Ryb3BwZWQsXG4gICAgdHhfZXJyb3JzLFxuICAgIHJ4X3NlYzogbnVsbCxcbiAgICB0eF9zZWM6IG51bGwsXG4gICAgbXM6IDBcbiAgfTtcblxuICBpZiAoX25ldHdvcmtbaWZhY2VdICYmIF9uZXR3b3JrW2lmYWNlXS5tcykge1xuICAgIHJlc3VsdC5tcyA9IERhdGUubm93KCkgLSBfbmV0d29ya1tpZmFjZV0ubXM7XG4gICAgcmVzdWx0LnJ4X3NlYyA9IChyeF9ieXRlcyAtIF9uZXR3b3JrW2lmYWNlXS5yeF9ieXRlcykgPj0gMCA/IChyeF9ieXRlcyAtIF9uZXR3b3JrW2lmYWNlXS5yeF9ieXRlcykgLyAocmVzdWx0Lm1zIC8gMTAwMCkgOiAwO1xuICAgIHJlc3VsdC50eF9zZWMgPSAodHhfYnl0ZXMgLSBfbmV0d29ya1tpZmFjZV0udHhfYnl0ZXMpID49IDAgPyAodHhfYnl0ZXMgLSBfbmV0d29ya1tpZmFjZV0udHhfYnl0ZXMpIC8gKHJlc3VsdC5tcyAvIDEwMDApIDogMDtcbiAgICBfbmV0d29ya1tpZmFjZV0ucnhfYnl0ZXMgPSByeF9ieXRlcztcbiAgICBfbmV0d29ya1tpZmFjZV0udHhfYnl0ZXMgPSB0eF9ieXRlcztcbiAgICBfbmV0d29ya1tpZmFjZV0ucnhfc2VjID0gcmVzdWx0LnJ4X3NlYztcbiAgICBfbmV0d29ya1tpZmFjZV0udHhfc2VjID0gcmVzdWx0LnR4X3NlYztcbiAgICBfbmV0d29ya1tpZmFjZV0ubXMgPSBEYXRlLm5vdygpO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5sYXN0X21zID0gcmVzdWx0Lm1zO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5vcGVyc3RhdGUgPSBvcGVyc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFfbmV0d29ya1tpZmFjZV0pIHsgX25ldHdvcmtbaWZhY2VdID0ge307IH1cbiAgICBfbmV0d29ya1tpZmFjZV0ucnhfYnl0ZXMgPSByeF9ieXRlcztcbiAgICBfbmV0d29ya1tpZmFjZV0udHhfYnl0ZXMgPSB0eF9ieXRlcztcbiAgICBfbmV0d29ya1tpZmFjZV0ucnhfc2VjID0gbnVsbDtcbiAgICBfbmV0d29ya1tpZmFjZV0udHhfc2VjID0gbnVsbDtcbiAgICBfbmV0d29ya1tpZmFjZV0ubXMgPSBEYXRlLm5vdygpO1xuICAgIF9uZXR3b3JrW2lmYWNlXS5sYXN0X21zID0gMDtcbiAgICBfbmV0d29ya1tpZmFjZV0ub3BlcnN0YXRlID0gb3BlcnN0YXRlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtTdGF0cyhpZmFjZXMsIGNhbGxiYWNrKSB7XG5cbiAgbGV0IGlmYWNlc0FycmF5ID0gW107XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICAgICAgaWYgKHV0aWwuaXNGdW5jdGlvbihpZmFjZXMpICYmICFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGlmYWNlcztcbiAgICAgICAgaWZhY2VzQXJyYXkgPSBbZ2V0RGVmYXVsdE5ldHdvcmtJbnRlcmZhY2UoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGlmYWNlcyAhPT0gJ3N0cmluZycgJiYgaWZhY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soW10pOyB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmYWNlcyA9IGlmYWNlcyB8fCBnZXREZWZhdWx0TmV0d29ya0ludGVyZmFjZSgpO1xuXG4gICAgICAgIGlmYWNlcy5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICAgIGlmYWNlcy5fX3Byb3RvX18ucmVwbGFjZSA9IHV0aWwuc3RyaW5nUmVwbGFjZTtcbiAgICAgICAgaWZhY2VzLl9fcHJvdG9fXy50cmltID0gdXRpbC5zdHJpbmdUcmltO1xuXG4gICAgICAgIGlmYWNlcyA9IGlmYWNlcy50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8sKy9nLCAnfCcpO1xuICAgICAgICBpZmFjZXNBcnJheSA9IGlmYWNlcy5zcGxpdCgnfCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgIGlmIChpZmFjZXNBcnJheS5sZW5ndGggJiYgaWZhY2VzQXJyYXlbMF0udHJpbSgpID09PSAnKicpIHtcbiAgICAgICAgaWZhY2VzQXJyYXkgPSBbXTtcbiAgICAgICAgbmV0d29ya0ludGVyZmFjZXMoZmFsc2UpLnRoZW4oYWxsSUZhY2VzID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBpZmFjZSBvZiBhbGxJRmFjZXMpIHtcbiAgICAgICAgICAgIGlmYWNlc0FycmF5LnB1c2goaWZhY2UuaWZhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXR3b3JrU3RhdHMoaWZhY2VzQXJyYXkuam9pbignLCcpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGlmYWNlIG9mIGlmYWNlc0FycmF5KSB7XG4gICAgICAgICAgd29ya2xvYWQucHVzaChuZXR3b3JrU3RhdHNTaW5nbGUoaWZhY2UudHJpbSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtsb2FkLmxlbmd0aCkge1xuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgICApLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhkYXRhKTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbmV0d29ya1N0YXRzU2luZ2xlKGlmYWNlKSB7XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lc1dpbmRvd3NQZXJmRGF0YShzZWN0aW9ucykge1xuICAgIGxldCBwZXJmRGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gc2VjdGlvbnMpIHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlY3Rpb25zLCBpKSkge1xuICAgICAgICBpZiAoc2VjdGlvbnNbaV0udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHNlY3Rpb25zW2ldLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgcGVyZkRhdGEucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmFtZScsICc6JykucmVwbGFjZSgvWygpW1xcXSBdKy9nLCAnJykucmVwbGFjZSgvI3xcXC8vZywgJ18nKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgcnhfYnl0ZXM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdCeXRlc1JlY2VpdmVkUGVyc2VjJywgJzonKSwgMTApLFxuICAgICAgICAgICAgcnhfZXJyb3JzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFja2V0c1JlY2VpdmVkRXJyb3JzJywgJzonKSwgMTApLFxuICAgICAgICAgICAgcnhfZHJvcHBlZDogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhY2tldHNSZWNlaXZlZERpc2NhcmRlZCcsICc6JyksIDEwKSxcbiAgICAgICAgICAgIHR4X2J5dGVzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnl0ZXNTZW50UGVyc2VjJywgJzonKSwgMTApLFxuICAgICAgICAgICAgdHhfZXJyb3JzOiBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFja2V0c091dGJvdW5kRXJyb3JzJywgJzonKSwgMTApLFxuICAgICAgICAgICAgdHhfZHJvcHBlZDogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BhY2tldHNPdXRib3VuZERpc2NhcmRlZCcsICc6JyksIDEwKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwZXJmRGF0YTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IGlmYWNlU2FuaXRpemVkID0gJyc7XG4gICAgICBjb25zdCBzID0gdXRpbC5pc1Byb3RvdHlwZVBvbGx1dGVkKCkgPyAnLS0tJyA6IHV0aWwuc2FuaXRpemVTaGVsbFN0cmluZyhpZmFjZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmYWNlU2FuaXRpemVkID0gaWZhY2VTYW5pdGl6ZWQgKyBzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGlmYWNlOiBpZmFjZVNhbml0aXplZCxcbiAgICAgICAgb3BlcnN0YXRlOiAndW5rbm93bicsXG4gICAgICAgIHJ4X2J5dGVzOiAwLFxuICAgICAgICByeF9kcm9wcGVkOiAwLFxuICAgICAgICByeF9lcnJvcnM6IDAsXG4gICAgICAgIHR4X2J5dGVzOiAwLFxuICAgICAgICB0eF9kcm9wcGVkOiAwLFxuICAgICAgICB0eF9lcnJvcnM6IDAsXG4gICAgICAgIHJ4X3NlYzogbnVsbCxcbiAgICAgICAgdHhfc2VjOiBudWxsLFxuICAgICAgICBtczogMFxuICAgICAgfTtcblxuICAgICAgbGV0IG9wZXJzdGF0ZSA9ICd1bmtub3duJztcbiAgICAgIGxldCByeF9ieXRlcyA9IDA7XG4gICAgICBsZXQgdHhfYnl0ZXMgPSAwO1xuICAgICAgbGV0IHJ4X2Ryb3BwZWQgPSAwO1xuICAgICAgbGV0IHJ4X2Vycm9ycyA9IDA7XG4gICAgICBsZXQgdHhfZHJvcHBlZCA9IDA7XG4gICAgICBsZXQgdHhfZXJyb3JzID0gMDtcblxuICAgICAgbGV0IGNtZCwgbGluZXMsIHN0YXRzO1xuICAgICAgaWYgKCFfbmV0d29ya1tpZmFjZVNhbml0aXplZF0gfHwgKF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXSAmJiAhX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLm1zKSB8fCAoX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdICYmIF9uZXR3b3JrW2lmYWNlU2FuaXRpemVkXS5tcyAmJiBEYXRlLm5vdygpIC0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLm1zID49IDUwMCkpIHtcbiAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKCcvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQpKSB7XG4gICAgICAgICAgICBjbWQgPVxuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvb3BlcnN0YXRlOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvcnhfYnl0ZXM7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy90eF9ieXRlczsgJyArXG4gICAgICAgICAgICAgICdjYXQgL3N5cy9jbGFzcy9uZXQvJyArIGlmYWNlU2FuaXRpemVkICsgJy9zdGF0aXN0aWNzL3J4X2Ryb3BwZWQ7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy9yeF9lcnJvcnM7ICcgK1xuICAgICAgICAgICAgICAnY2F0IC9zeXMvY2xhc3MvbmV0LycgKyBpZmFjZVNhbml0aXplZCArICcvc3RhdGlzdGljcy90eF9kcm9wcGVkOyAnICtcbiAgICAgICAgICAgICAgJ2NhdCAvc3lzL2NsYXNzL25ldC8nICsgaWZhY2VTYW5pdGl6ZWQgKyAnL3N0YXRpc3RpY3MvdHhfZXJyb3JzOyAnO1xuICAgICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBvcGVyc3RhdGUgPSBsaW5lc1swXS50cmltKCk7XG4gICAgICAgICAgICAgICAgcnhfYnl0ZXMgPSBwYXJzZUludChsaW5lc1sxXSwgMTApO1xuICAgICAgICAgICAgICAgIHR4X2J5dGVzID0gcGFyc2VJbnQobGluZXNbMl0sIDEwKTtcbiAgICAgICAgICAgICAgICByeF9kcm9wcGVkID0gcGFyc2VJbnQobGluZXNbM10sIDEwKTtcbiAgICAgICAgICAgICAgICByeF9lcnJvcnMgPSBwYXJzZUludChsaW5lc1s0XSwgMTApO1xuICAgICAgICAgICAgICAgIHR4X2Ryb3BwZWQgPSBwYXJzZUludChsaW5lc1s1XSwgMTApO1xuICAgICAgICAgICAgICAgIHR4X2Vycm9ycyA9IHBhcnNlSW50KGxpbmVzWzZdLCAxMCk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjTmV0d29ya1NwZWVkKGlmYWNlU2FuaXRpemVkLCByeF9ieXRlcywgdHhfYnl0ZXMsIG9wZXJzdGF0ZSwgcnhfZHJvcHBlZCwgcnhfZXJyb3JzLCB0eF9kcm9wcGVkLCB0eF9lcnJvcnMpO1xuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgICBjbWQgPSAnbmV0c3RhdCAtaWJuZEkgJyArIGlmYWNlU2FuaXRpemVkOyAgIC8vIGxndG0gW2pzL3NoZWxsLWNvbW1hbmQtY29uc3RydWN0ZWQtZnJvbS1pbnB1dF1cbiAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0ucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lICYmIGxpbmVbMF0gJiYgbGluZVs3XSAmJiBsaW5lWzEwXSkge1xuICAgICAgICAgICAgICAgICAgcnhfYnl0ZXMgPSByeF9ieXRlcyArIHBhcnNlSW50KGxpbmVbN10pO1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbNl0udHJpbSgpICE9PSAnLScpIHsgcnhfZHJvcHBlZCA9IHJ4X2Ryb3BwZWQgKyBwYXJzZUludChsaW5lWzZdKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbNV0udHJpbSgpICE9PSAnLScpIHsgcnhfZXJyb3JzID0gcnhfZXJyb3JzICsgcGFyc2VJbnQobGluZVs1XSk7IH1cbiAgICAgICAgICAgICAgICAgIHR4X2J5dGVzID0gdHhfYnl0ZXMgKyBwYXJzZUludChsaW5lWzEwXSk7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZVsxMl0udHJpbSgpICE9PSAnLScpIHsgdHhfZHJvcHBlZCA9IHR4X2Ryb3BwZWQgKyBwYXJzZUludChsaW5lWzEyXSk7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lWzldLnRyaW0oKSAhPT0gJy0nKSB7IHR4X2Vycm9ycyA9IHR4X2Vycm9ycyArIHBhcnNlSW50KGxpbmVbOV0pOyB9XG4gICAgICAgICAgICAgICAgICBvcGVyc3RhdGUgPSAndXAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxjTmV0d29ya1NwZWVkKGlmYWNlU2FuaXRpemVkLCByeF9ieXRlcywgdHhfYnl0ZXMsIG9wZXJzdGF0ZSwgcnhfZHJvcHBlZCwgcnhfZXJyb3JzLCB0eF9kcm9wcGVkLCB0eF9lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgICAgY21kID0gJ2lmY29uZmlnICcgKyBpZmFjZVNhbml0aXplZCArICcgfCBncmVwIFwic3RhdHVzXCInOyAgICAvLyBsZ3RtIFtqcy9zaGVsbC1jb21tYW5kLWNvbnN0cnVjdGVkLWZyb20taW5wdXRdXG4gICAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICByZXN1bHQub3BlcnN0YXRlID0gKHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCc6JylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5vcGVyc3RhdGUgPSAocmVzdWx0Lm9wZXJzdGF0ZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5vcGVyc3RhdGUgPSAocmVzdWx0Lm9wZXJzdGF0ZSA9PT0gJ2FjdGl2ZScgPyAndXAnIDogKHJlc3VsdC5vcGVyc3RhdGUgPT09ICdpbmFjdGl2ZScgPyAnZG93bicgOiAndW5rbm93bicpKTtcbiAgICAgICAgICAgIGNtZCA9ICduZXRzdGF0IC1iZEkgJyArIGlmYWNlU2FuaXRpemVkOyAgIC8vIGxndG0gW2pzL3NoZWxsLWNvbW1hbmQtY29uc3RydWN0ZWQtZnJvbS1pbnB1dF1cbiAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbGVzcyB0aGFuIDIgbGluZXMsIG5vIGluZm9ybWF0aW9uIGZvciB0aGlzIGludGVyZmFjZSB3YXMgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSAmJiBsaW5lc1sxXS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBza2lwIGhlYWRlciBsaW5lXG4gICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNlY29uZCBsaW5lIGJlY2F1c2UgaXQgaXMgdGllZCB0byB0aGUgTklDIGluc3RlYWQgb2YgdGhlIGlwdjQgb3IgaXB2NiBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICBzdGF0cyA9IGxpbmVzWzFdLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRzLmxlbmd0aCA+IDExID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICByeF9ieXRlcyA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDVdKTtcbiAgICAgICAgICAgICAgICAgIHJ4X2Ryb3BwZWQgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyAxMF0pO1xuICAgICAgICAgICAgICAgICAgcnhfZXJyb3JzID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgNF0pO1xuICAgICAgICAgICAgICAgICAgdHhfYnl0ZXMgPSBwYXJzZUludChzdGF0c1tvZmZzZXQgKyA4XSk7XG4gICAgICAgICAgICAgICAgICB0eF9kcm9wcGVkID0gcGFyc2VJbnQoc3RhdHNbb2Zmc2V0ICsgMTBdKTtcbiAgICAgICAgICAgICAgICAgIHR4X2Vycm9ycyA9IHBhcnNlSW50KHN0YXRzW29mZnNldCArIDddKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGNOZXR3b3JrU3BlZWQoaWZhY2VTYW5pdGl6ZWQsIHJ4X2J5dGVzLCB0eF9ieXRlcywgcmVzdWx0Lm9wZXJzdGF0ZSwgcnhfZHJvcHBlZCwgcnhfZXJyb3JzLCB0eF9kcm9wcGVkLCB0eF9lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICBsZXQgcGVyZkRhdGEgPSBbXTtcbiAgICAgICAgICBsZXQgaWZhY2VOYW1lID0gaWZhY2VTYW5pdGl6ZWQ7XG5cbiAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBEYXRhXG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUGVyZlJhd0RhdGFfVGNwaXBfTmV0d29ya0ludGVyZmFjZSB8IHNlbGVjdCBOYW1lLEJ5dGVzUmVjZWl2ZWRQZXJzZWMsUGFja2V0c1JlY2VpdmVkRXJyb3JzLFBhY2tldHNSZWNlaXZlZERpc2NhcmRlZCxCeXRlc1NlbnRQZXJzZWMsUGFja2V0c091dGJvdW5kRXJyb3JzLFBhY2tldHNPdXRib3VuZERpc2NhcmRlZCB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBwc2VjdGlvbnMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICBwZXJmRGF0YSA9IHBhcnNlTGluZXNXaW5kb3dzUGVyZkRhdGEocHNlY3Rpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTmV0d29yayBJbnRlcmZhY2VzXG4gICAgICAgICAgICBuZXR3b3JrSW50ZXJmYWNlcyhmYWxzZSkudGhlbihpbnRlcmZhY2VzID0+IHtcbiAgICAgICAgICAgICAgLy8gZ2V0IGJ5dGVzIHNlbnQsIHJlY2VpdmVkIGZyb20gcGVyZkRhdGEgYnkgbmFtZVxuICAgICAgICAgICAgICByeF9ieXRlcyA9IDA7XG4gICAgICAgICAgICAgIHR4X2J5dGVzID0gMDtcbiAgICAgICAgICAgICAgcGVyZkRhdGEuZm9yRWFjaChkZXRhaWwgPT4ge1xuICAgICAgICAgICAgICAgIGludGVyZmFjZXMuZm9yRWFjaChkZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKChkZXQuaWZhY2UudG9Mb3dlckNhc2UoKSA9PT0gaWZhY2VTYW5pdGl6ZWQudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXQubWFjLnRvTG93ZXJDYXNlKCkgPT09IGlmYWNlU2FuaXRpemVkLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGV0LmlwNC50b0xvd2VyQ2FzZSgpID09PSBpZmFjZVNhbml0aXplZC50b0xvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRldC5pcDYudG9Mb3dlckNhc2UoKSA9PT0gaWZhY2VTYW5pdGl6ZWQudG9Mb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZXQuaWZhY2VOYW1lLnJlcGxhY2UoL1soKVtcXF0gXSsvZywgJycpLnJlcGxhY2UoLyN8XFwvL2csICdfJykudG9Mb3dlckNhc2UoKSA9PT0gaWZhY2VTYW5pdGl6ZWQucmVwbGFjZSgvWygpW1xcXSBdKy9nLCAnJykucmVwbGFjZSgnIycsICdfJykudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGRldC5pZmFjZU5hbWUucmVwbGFjZSgvWygpW1xcXSBdKy9nLCAnJykucmVwbGFjZSgvI3xcXC8vZywgJ18nKS50b0xvd2VyQ2FzZSgpID09PSBkZXRhaWwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWZhY2VOYW1lID0gZGV0LmlmYWNlO1xuICAgICAgICAgICAgICAgICAgICByeF9ieXRlcyA9IGRldGFpbC5yeF9ieXRlcztcbiAgICAgICAgICAgICAgICAgICAgcnhfZHJvcHBlZCA9IGRldGFpbC5yeF9kcm9wcGVkO1xuICAgICAgICAgICAgICAgICAgICByeF9lcnJvcnMgPSBkZXRhaWwucnhfZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICB0eF9ieXRlcyA9IGRldGFpbC50eF9ieXRlcztcbiAgICAgICAgICAgICAgICAgICAgdHhfZHJvcHBlZCA9IGRldGFpbC50eF9kcm9wcGVkO1xuICAgICAgICAgICAgICAgICAgICB0eF9lcnJvcnMgPSBkZXRhaWwudHhfZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBvcGVyc3RhdGUgPSBkZXQub3BlcnN0YXRlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHJ4X2J5dGVzICYmIHR4X2J5dGVzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsY05ldHdvcmtTcGVlZChpZmFjZU5hbWUsIHBhcnNlSW50KHJ4X2J5dGVzKSwgcGFyc2VJbnQodHhfYnl0ZXMpLCBvcGVyc3RhdGUsIHJ4X2Ryb3BwZWQsIHJ4X2Vycm9ycywgdHhfZHJvcHBlZCwgdHhfZXJyb3JzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnJ4X2J5dGVzID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLnJ4X2J5dGVzO1xuICAgICAgICByZXN1bHQudHhfYnl0ZXMgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0udHhfYnl0ZXM7XG4gICAgICAgIHJlc3VsdC5yeF9zZWMgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ucnhfc2VjO1xuICAgICAgICByZXN1bHQudHhfc2VjID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLnR4X3NlYztcbiAgICAgICAgcmVzdWx0Lm1zID0gX25ldHdvcmtbaWZhY2VTYW5pdGl6ZWRdLmxhc3RfbXM7XG4gICAgICAgIHJlc3VsdC5vcGVyc3RhdGUgPSBfbmV0d29ya1tpZmFjZVNhbml0aXplZF0ub3BlcnN0YXRlO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm5ldHdvcmtTdGF0cyA9IG5ldHdvcmtTdGF0cztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE5FVCAtIGNvbm5lY3Rpb25zIChzb2NrZXRzKVxuXG5mdW5jdGlvbiBnZXRQcm9jZXNzTmFtZShwcm9jZXNzZXMsIHBpZCkge1xuICBsZXQgY21kID0gJyc7XG4gIHByb2Nlc3Nlcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGlkID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKSB8fCAtMTtcbiAgICBpZiAoaWQgPT09IHBpZCkge1xuICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgIGNtZCA9IHBhcnRzLmpvaW4oJyAnKS5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgfSk7XG4gIGNtZCA9IGNtZC5zcGxpdCgnIC0nKVswXTtcbiAgLy8gcmV0dXJuIGNtZDtcbiAgY29uc3QgY21kUGFydHMgPSBjbWQuc3BsaXQoJy8nKTtcbiAgcmV0dXJuIGNtZFBhcnRzW2NtZFBhcnRzLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrQ29ubmVjdGlvbnMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBsZXQgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgbmV0c3RhdCAtdHVuYXAgfCBncmVwIFwiRVNUQUJMSVNIRURcXFxcfFNZTl9TRU5UXFxcXHxTWU5fUkVDVlxcXFx8RklOX1dBSVQxXFxcXHxGSU5fV0FJVDJcXFxcfFRJTUVfV0FJVFxcXFx8Q0xPU0VcXFxcfENMT1NFX1dBSVRcXFxcfExBU1RfQUNLXFxcXHxMSVNURU5cXFxcfENMT1NJTkdcXFxcfFVOS05PV05cIjsgdW5zZXQgTENfQUxMJztcbiAgICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHsgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgbmV0c3RhdCAtbmEgfCBncmVwIFwiRVNUQUJMSVNIRURcXFxcfFNZTl9TRU5UXFxcXHxTWU5fUkVDVlxcXFx8RklOX1dBSVQxXFxcXHxGSU5fV0FJVDJcXFxcfFRJTUVfV0FJVFxcXFx8Q0xPU0VcXFxcfENMT1NFX1dBSVRcXFxcfExBU1RfQUNLXFxcXHxMSVNURU5cXFxcfENMT1NJTkdcXFxcfFVOS05PV05cIjsgdW5zZXQgTENfQUxMJzsgfVxuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBpZiAoIWVycm9yICYmIChsaW5lcy5sZW5ndGggPiAxIHx8IGxpbmVzWzBdICE9ICcnKSkge1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gKy9nLCAnICcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSA3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsaXAgPSBsaW5lWzNdO1xuICAgICAgICAgICAgICAgIGxldCBsb2NhbHBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxhZGRyZXNzID0gbGluZVszXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGFkZHJlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgbG9jYWxwb3J0ID0gbG9jYWxhZGRyZXNzW2xvY2FsYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgIGxvY2FsYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGxvY2FsaXAgPSBsb2NhbGFkZHJlc3Muam9pbignOicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGVlcmlwID0gbGluZVs0XTtcbiAgICAgICAgICAgICAgICBsZXQgcGVlcnBvcnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgcGVlcmFkZHJlc3MgPSBsaW5lWzRdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHBlZXJhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIHBlZXJwb3J0ID0gcGVlcmFkZHJlc3NbcGVlcmFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICBwZWVyYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIHBlZXJpcCA9IHBlZXJhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvbm5zdGF0ZSA9IGxpbmVbNV07XG4gICAgICAgICAgICAgICAgbGV0IHByb2MgPSBsaW5lWzZdLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBsaW5lWzBdLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsaXAsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUG9ydDogbG9jYWxwb3J0LFxuICAgICAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogcGVlcmlwLFxuICAgICAgICAgICAgICAgICAgICBwZWVyUG9ydDogcGVlcnBvcnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBjb25uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHBpZDogcHJvY1swXSAmJiBwcm9jWzBdICE9PSAnLScgPyBwYXJzZUludChwcm9jWzBdLCAxMCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzOiBwcm9jWzFdID8gcHJvY1sxXS5zcGxpdCgnICcpWzBdLnNwbGl0KCc6JylbMF0gOiAnJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbWQgPSAnc3MgLXR1bmFwIHwgZ3JlcCBcIkVTVEFCXFxcXHxTWU4tU0VOVFxcXFx8U1lOLVJFQ1ZcXFxcfEZJTi1XQUlUMVxcXFx8RklOLVdBSVQyXFxcXHxUSU1FLVdBSVRcXFxcfENMT1NFXFxcXHxDTE9TRS1XQUlUXFxcXHxMQVNULUFDS1xcXFx8TElTVEVOXFxcXHxDTE9TSU5HXCInO1xuICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcblxuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb2NhbGlwID0gbGluZVs0XTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FscG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbG9jYWxhZGRyZXNzID0gbGluZVs0XS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbHBvcnQgPSBsb2NhbGFkZHJlc3NbbG9jYWxhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbGlwID0gbG9jYWxhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcGVlcmlwID0gbGluZVs1XTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlZXJwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZWVyYWRkcmVzcyA9IGxpbmVbNV0uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZXJhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWVycG9ydCA9IHBlZXJhZGRyZXNzW3BlZXJhZGRyZXNzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJhZGRyZXNzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHBlZXJpcCA9IHBlZXJhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29ubnN0YXRlID0gbGluZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ0VTVEFCJykgeyBjb25uc3RhdGUgPSAnRVNUQUJMSVNIRUQnOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdUSU1FLVdBSVQnKSB7IGNvbm5zdGF0ZSA9ICdUSU1FX1dBSVQnOyB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvY2VzcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPj0gNyAmJiBsaW5lWzZdLmluZGV4T2YoJ3VzZXJzOicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvYyA9IGxpbmVbNl0ucmVwbGFjZSgndXNlcnM6KChcIicsICcnKS5yZXBsYWNlKC9cIi9nLCAnJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvYy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzID0gcHJvY1swXS5zcGxpdCgnICcpWzBdLnNwbGl0KCc6JylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwaWQgPSBwYXJzZUludChwcm9jWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogbGluZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxpcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUG9ydDogbG9jYWxwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlckFkZHJlc3M6IHBlZXJpcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJQb3J0OiBwZWVycG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBjb25uc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAvLyBsZXQgY21kID0gJ25ldHN0YXQgLW5hdHYgfCBncmVwIFwiRVNUQUJMSVNIRURcXFxcfFNZTl9TRU5UXFxcXHxTWU5fUkVDVlxcXFx8RklOX1dBSVQxXFxcXHxGSU5fV0FJVDJcXFxcfFRJTUVfV0FJVFxcXFx8Q0xPU0VcXFxcfENMT1NFX1dBSVRcXFxcfExBU1RfQUNLXFxcXHxMSVNURU5cXFxcfENMT1NJTkdcXFxcfFVOS05PV05cIic7XG4gICAgICAgIGxldCBjbWQgPSAnbmV0c3RhdCAtbmF0diB8IGdyZXAgXCJ0Y3A0XFxcXHx0Y3A2XFxcXHx1ZHA0XFxcXHx1ZHA2XCInO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSAnRVNUQUJMSVNIRUR8U1lOX1NFTlR8U1lOX1JFQ1Z8RklOX1dBSVQxfEZJTl9XQUlUMnxUSU1FX1dBSVR8Q0xPU0V8Q0xPU0VfV0FJVHxMQVNUX0FDS3xMSVNURU58Q0xPU0lOR3xVTktOT1dOJztcbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBleGVjKCdwcyAtYXhvIHBpZCxjb21tYW5kJywgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyMiwgc3Rkb3V0Mikge1xuICAgICAgICAgICAgICBsZXQgcHJvY2Vzc2VzID0gc3Rkb3V0Mi50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgcHJvY2Vzc2VzID0gcHJvY2Vzc2VzLm1hcCgobGluZSA9PiB7IHJldHVybiBsaW5lLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnICcpOyB9KSk7XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxpcCA9IGxpbmVbM107XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxhZGRyZXNzID0gbGluZVszXS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FscG9ydCA9IGxvY2FsYWRkcmVzc1tsb2NhbGFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxpcCA9IGxvY2FsYWRkcmVzcy5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcmlwID0gbGluZVs0XTtcbiAgICAgICAgICAgICAgICAgIGxldCBwZWVycG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJhZGRyZXNzID0gbGluZVs0XS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZXJhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVlcnBvcnQgPSBwZWVyYWRkcmVzc1twZWVyYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcGVlcmFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJpcCA9IHBlZXJhZGRyZXNzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0YXRlID0gc3RhdGVzLmluZGV4T2YobGluZVs1XSkgPj0gMDtcbiAgICAgICAgICAgICAgICAgIGxldCBjb25uc3RhdGUgPSBoYXNTdGF0ZSA/IGxpbmVbNV0gOiAnVU5LTk9XTic7XG4gICAgICAgICAgICAgICAgICBsZXQgcGlkID0gcGFyc2VJbnQobGluZVs4ICsgKGhhc1N0YXRlID8gMCA6IC0xKV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBsaW5lWzBdLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxpcCxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvcnQ6IGxvY2FscG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogcGVlcmlwLFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJQb3J0OiBwZWVycG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY29ubnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6IGdldFByb2Nlc3NOYW1lKHByb2Nlc3NlcywgcGlkKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgY21kID0gJ25ldHN0YXQgLW5hbyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlYyhjbWQsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG5cbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuXG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS50cmltKCkucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxpcCA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxwb3J0ID0gJyc7XG4gICAgICAgICAgICAgICAgICBsZXQgbG9jYWxhZGRyZXNzID0gbGluZVsxXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FscG9ydCA9IGxvY2FsYWRkcmVzc1tsb2NhbGFkZHJlc3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsYWRkcmVzcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxpcCA9IGxvY2FsYWRkcmVzcy5qb2luKCc6Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsb2NhbGlwID0gbG9jYWxpcC5yZXBsYWNlKC9cXFsvZywgJycpLnJlcGxhY2UoL1xcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICBsZXQgcGVlcmlwID0gbGluZVsyXTtcbiAgICAgICAgICAgICAgICAgIGxldCBwZWVycG9ydCA9ICcnO1xuICAgICAgICAgICAgICAgICAgbGV0IHBlZXJhZGRyZXNzID0gbGluZVsyXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZXJhZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVlcnBvcnQgPSBwZWVyYWRkcmVzc1twZWVyYWRkcmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgcGVlcmFkZHJlc3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJpcCA9IHBlZXJhZGRyZXNzLmpvaW4oJzonKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHBlZXJpcCA9IHBlZXJpcC5yZXBsYWNlKC9cXFsvZywgJycpLnJlcGxhY2UoL1xcXS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICBsZXQgcGlkID0gdXRpbC50b0ludChsaW5lWzRdKTtcbiAgICAgICAgICAgICAgICAgIGxldCBjb25uc3RhdGUgPSBsaW5lWzNdO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ0hFUkdFU1RFTExUJykgeyBjb25uc3RhdGUgPSAnRVNUQUJMSVNIRUQnOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlLnN0YXJ0c1dpdGgoJ0FCSCcpKSB7IGNvbm5zdGF0ZSA9ICdMSVNURU4nOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnU0NITElFU1NFTl9XQVJURU4nKSB7IGNvbm5zdGF0ZSA9ICdDTE9TRV9XQUlUJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGNvbm5zdGF0ZSA9PT0gJ1dBUlRFTkQnKSB7IGNvbm5zdGF0ZSA9ICdUSU1FX1dBSVQnOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnU1lOX0dFU0VOREVUJykgeyBjb25uc3RhdGUgPSAnU1lOX1NFTlQnOyB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdMSVNURU5JTkcnKSB7IGNvbm5zdGF0ZSA9ICdMSVNURU4nOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnU1lOX1JFQ0VJVkVEJykgeyBjb25uc3RhdGUgPSAnU1lOX1JFQ1YnOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubnN0YXRlID09PSAnRklOX1dBSVRfMScpIHsgY29ubnN0YXRlID0gJ0ZJTl9XQUlUMSc7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjb25uc3RhdGUgPT09ICdGSU5fV0FJVF8yJykgeyBjb25uc3RhdGUgPSAnRklOX1dBSVQyJzsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGxpbmVbMF0udG9Mb3dlckNhc2UoKSAhPT0gJ3VkcCcgJiYgY29ubnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbDogbGluZVswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxpcCxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBvcnQ6IGxvY2FscG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyQWRkcmVzczogcGVlcmlwLFxuICAgICAgICAgICAgICAgICAgICAgIHBlZXJQb3J0OiBwZWVycG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogY29ubnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZVswXS50b0xvd2VyQ2FzZSgpID09PSAndWRwJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2w6IGxpbmVbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgbG9jYWxQb3J0OiBsb2NhbHBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGVlckFkZHJlc3M6IHBlZXJpcCxcbiAgICAgICAgICAgICAgICAgICAgICBwZWVyUG9ydDogcGVlcnBvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGFyc2VJbnQobGluZVszXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3M6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMubmV0d29ya0Nvbm5lY3Rpb25zID0gbmV0d29ya0Nvbm5lY3Rpb25zO1xuXG5mdW5jdGlvbiBuZXR3b3JrR2F0ZXdheURlZmF1bHQoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBsZXQgY21kID0gJ2lwIHJvdXRlIGdldCAxJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lcyAmJiBsaW5lc1swXSA/IGxpbmVzWzBdIDogJyc7XG4gICAgICAgICAgICAgIGxldCBwYXJ0cyA9IGxpbmUuc3BsaXQoJyB2aWEgJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgIHBhcnRzID0gcGFydHNbMV0uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAncm91dGUgLW4gZ2V0IGRlZmF1bHQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2dhdGV3YXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNtZCA9ICduZXRzdGF0IC1ybiB8IGF3ayBcXCcvZGVmYXVsdC8ge3ByaW50ICQyfVxcJyc7XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxpbmVzLmZpbmQobGluZSA9PiAoL14oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvLnRlc3QobGluZSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjKCduZXRzdGF0IC1yJywgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQob3MuRU9MKTtcbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJzAuMC4wLjAgMC4wLjAuMCcpID4gLTEgJiYgISgvW2EtekEtWl0vLnRlc3QobGluZSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSA1ICYmIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAzXSkuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSAtQ2xhc3NOYW1lIFdpbjMyX0lQNFJvdXRlVGFibGUgfCBXaGVyZS1PYmplY3QgeyAkXy5EZXN0aW5hdGlvbiAtZXEgXFwnMC4wLjAuMFxcJyAtYW5kICRfLk1hc2sgLWVxIFxcJzAuMC4wLjBcXCcgfScpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGEudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSAmJiAhcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdOZXh0SG9wJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyAgIGV4ZWMoJ2lwY29uZmlnJywgdXRpbC5leGVjT3B0c1dpbiwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnJlcGxhY2UoL1xcLiAvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBsaW5lID0gbGluZS50cmltKCkucmVwbGFjZSgvICsvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgaWYgKChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3N0YW5kYXJkZ2F0ZScpIHx8IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZ2F0ZXdheScpID4gLTEgfHwgcGFydHNbMF0udG9Mb3dlckNhc2UoKS5pbmRleE9mKCdlbmxhY2UnKSA+IC0xKSAmJiBwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLm5ldHdvcmtHYXRld2F5RGVmYXVsdCA9IG5ldHdvcmtHYXRld2F5RGVmYXVsdDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gb3NpbmZvLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMy4gT3BlcmF0aW5nIFN5c3RlbVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHZXQgY3VycmVudCB0aW1lIGFuZCBPUyB1cHRpbWVcblxuZnVuY3Rpb24gdGltZSgpIHtcbiAgbGV0IHQgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBEYXRlLm5vdygpLFxuICAgIHVwdGltZTogb3MudXB0aW1lKCksXG4gICAgdGltZXpvbmU6ICh0Lmxlbmd0aCA+PSA3KSA/IHRbNV0gOiAnJyxcbiAgICB0aW1lem9uZU5hbWU6IEludGwgPyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUgOiAodC5sZW5ndGggPj0gNykgPyB0LnNsaWNlKDYpLmpvaW4oJyAnKS5yZXBsYWNlKC9cXCgvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykgOiAnJ1xuICB9O1xufVxuXG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2V0IGxvZ28gZmlsZW5hbWUgb2YgT1MgZGlzdHJpYnV0aW9uXG5cbmZ1bmN0aW9uIGdldExvZ29GaWxlKGRpc3Rybykge1xuICBkaXN0cm8gPSBkaXN0cm8gfHwgJyc7XG4gIGRpc3RybyA9IGRpc3Ryby50b0xvd2VyQ2FzZSgpO1xuICBsZXQgcmVzdWx0ID0gX3BsYXRmb3JtO1xuICBpZiAoX3dpbmRvd3MpIHtcbiAgICByZXN1bHQgPSAnd2luZG93cyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21hYyBvcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdhcHBsZSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2FyY2gnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnYXJjaCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2NlbnRvcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdjZW50b3MnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdjb3Jlb3MnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnY29yZW9zJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZGViaWFuJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2RlYmlhbic7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ2RlZXBpbicpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdkZWVwaW4nO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdlbGVtZW50YXJ5JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2VsZW1lbnRhcnknO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdmZWRvcmEnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnZmVkb3JhJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZ2VudG9vJykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2dlbnRvbyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21hZ2VpYScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdtYWdlaWEnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdtYW5kcml2YScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdtYW5kcml2YSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21hbmphcm8nKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbWFuamFybyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21pbnQnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnbWludCc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ214JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ214JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignb3BlbmJzZCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdvcGVuYnNkJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignZnJlZWJzZCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdmcmVlYnNkJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignb3BlbnN1c2UnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnb3BlbnN1c2UnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdwY2xpbnV4b3MnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncGNsaW51eG9zJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncHVwcHknKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncHVwcHknO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdyYXNwYmlhbicpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdyYXNwYmlhbic7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3JlYWN0b3MnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAncmVhY3Rvcyc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3JlZGhhdCcpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdyZWRoYXQnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdzbGFja3dhcmUnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnc2xhY2t3YXJlJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignc3VnYXInKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnc3VnYXInO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdzdGVhbScpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdzdGVhbSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ3N1c2UnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAnc3VzZSc7XG4gIH1cbiAgZWxzZSBpZiAoZGlzdHJvLmluZGV4T2YoJ21hdGUnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAndWJ1bnR1LW1hdGUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdsdWJ1bnR1JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ2x1YnVudHUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCd4dWJ1bnR1JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3h1YnVudHUnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCd1YnVudHUnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAndWJ1bnR1JztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZignc29sYXJpcycpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdzb2xhcmlzJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigndGFpbHMnKSAhPT0gLTEpIHtcbiAgICByZXN1bHQgPSAndGFpbHMnO1xuICB9XG4gIGVsc2UgaWYgKGRpc3Ryby5pbmRleE9mKCdmZXJlbicpICE9PSAtMSkge1xuICAgIHJlc3VsdCA9ICdmZXJlbm9zJztcbiAgfVxuICBlbHNlIGlmIChkaXN0cm8uaW5kZXhPZigncm9ib2xpbnV4JykgIT09IC0xKSB7XG4gICAgcmVzdWx0ID0gJ3JvYm9saW51eCc7XG4gIH0gZWxzZSBpZiAoX2xpbnV4ICYmIGRpc3Rybykge1xuICAgIHJlc3VsdCA9IGRpc3Ryby50b0xvd2VyQ2FzZSgpLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICctJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEZRRE5cblxuZnVuY3Rpb24gZ2V0RlFETigpIHtcbiAgbGV0IGZxZG4gPSBvcy5ob3N0bmFtZTtcbiAgaWYgKF9saW51eCB8fCBfZGFyd2luKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdob3N0bmFtZSAtZicpO1xuICAgICAgZnFkbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KG9zLkVPTClbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9XG4gIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGV4ZWNTeW5jKCdob3N0bmFtZScpO1xuICAgICAgZnFkbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KG9zLkVPTClbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9XG4gIGlmIChfd2luZG93cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnZWNobyAlQ09NUFVURVJOQU1FJS4lVVNFUkROU0RPTUFJTiUnLCB1dGlsLmV4ZWNPcHRzV2luKTtcbiAgICAgIGZxZG4gPSBzdGRvdXQudG9TdHJpbmcoKS5yZXBsYWNlKCcuJVVTRVJETlNET01BSU4lJywgJycpLnNwbGl0KG9zLkVPTClbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXRpbC5ub29wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmcWRuO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT1MgSW5mb3JtYXRpb25cblxuZnVuY3Rpb24gb3NJbmZvKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuXG4gICAgICAgIHBsYXRmb3JtOiAoX3BsYXRmb3JtID09PSAnd2luMzInID8gJ1dpbmRvd3MnIDogX3BsYXRmb3JtKSxcbiAgICAgICAgZGlzdHJvOiAndW5rbm93bicsXG4gICAgICAgIHJlbGVhc2U6ICd1bmtub3duJyxcbiAgICAgICAgY29kZW5hbWU6ICcnLFxuICAgICAgICBrZXJuZWw6IG9zLnJlbGVhc2UoKSxcbiAgICAgICAgYXJjaDogb3MuYXJjaCgpLFxuICAgICAgICBob3N0bmFtZTogb3MuaG9zdG5hbWUoKSxcbiAgICAgICAgZnFkbjogZ2V0RlFETigpLFxuICAgICAgICBjb2RlcGFnZTogJycsXG4gICAgICAgIGxvZ29maWxlOiAnJyxcbiAgICAgICAgc2VyaWFsOiAnJyxcbiAgICAgICAgYnVpbGQ6ICcnLFxuICAgICAgICBzZXJ2aWNlcGFjazogJycsXG4gICAgICAgIHVlZmk6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG5cbiAgICAgICAgZXhlYygnY2F0IC9ldGMvKi1yZWxlYXNlOyBjYXQgL3Vzci9saWIvb3MtcmVsZWFzZTsgY2F0IC9ldGMvb3BlbndydF9yZWxlYXNlJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBESVNUUklCX0lEXG4gICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBOQU1FXG4gICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICBESVNUUklCX1JFTEVBU0VcbiAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIFZFUlNJT05fSURcbiAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gIERJU1RSSUJfQ09ERU5BTUVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgcmVsZWFzZSA9IHt9O1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCc9JykgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VbbGluZS5zcGxpdCgnPScpWzBdLnRyaW0oKS50b1VwcGVyQ2FzZSgpXSA9IGxpbmUuc3BsaXQoJz0nKVsxXS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IHJlbGVhc2VWZXJzaW9uID0gKHJlbGVhc2UuVkVSU0lPTiB8fCAnJykucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgIGxldCBjb2RlbmFtZSA9IChyZWxlYXNlLkRJU1RSSUJfQ09ERU5BTUUgfHwgcmVsZWFzZS5WRVJTSU9OX0NPREVOQU1FIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgaWYgKHJlbGVhc2VWZXJzaW9uLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICBjb2RlbmFtZSA9IHJlbGVhc2VWZXJzaW9uLnNwbGl0KCcoJylbMV0ucmVwbGFjZSgvWygpXS9nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgcmVsZWFzZVZlcnNpb24gPSByZWxlYXNlVmVyc2lvbi5zcGxpdCgnKCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LmRpc3RybyA9IChyZWxlYXNlLkRJU1RSSUJfSUQgfHwgcmVsZWFzZS5OQU1FIHx8ICd1bmtub3duJykucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICAgIHJlc3VsdC5sb2dvZmlsZSA9IGdldExvZ29GaWxlKHJlc3VsdC5kaXN0cm8pO1xuICAgICAgICAgIHJlc3VsdC5yZWxlYXNlID0gKHJlbGVhc2VWZXJzaW9uIHx8IHJlbGVhc2UuRElTVFJJQl9SRUxFQVNFIHx8IHJlbGVhc2UuVkVSU0lPTl9JRCB8fCAndW5rbm93bicpLnJlcGxhY2UoL1wiL2csICcnKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSBjb2RlbmFtZTtcbiAgICAgICAgICByZXN1bHQuY29kZXBhZ2UgPSB1dGlsLmdldENvZGVwYWdlKCk7XG4gICAgICAgICAgcmVzdWx0LmJ1aWxkID0gKHJlbGVhc2UuQlVJTERfSUQgfHwgJycpLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCk7XG4gICAgICAgICAgaXNVZWZpTGludXgoKS50aGVuKHVlZmkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnVlZmkgPSB1ZWZpO1xuICAgICAgICAgICAgdXVpZCgpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IGRhdGEub3M7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcblxuICAgICAgICBleGVjKCdzeXNjdGwga2Vybi5vc3R5cGUga2Vybi5vc3JlbGVhc2Uga2Vybi5vc3JldmlzaW9uIGtlcm4uaG9zdHV1aWQgbWFjaGRlcC5ib290bWV0aG9kIGtlcm4uZ2VvbS5jb25meG1sJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgY29uc3QgZGlzdHJvID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ub3N0eXBlJyk7XG4gICAgICAgICAgY29uc3QgbG9nb2ZpbGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5vc3R5cGUnKTtcbiAgICAgICAgICBjb25zdCByZWxlYXNlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2tlcm4ub3NyZWxlYXNlJykuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICBjb25zdCBzZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi51dWlkJyk7XG4gICAgICAgICAgY29uc3QgYm9vdG1ldGhvZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYWNoZGVwLmJvb3RtZXRob2QnKTtcbiAgICAgICAgICBjb25zdCB1ZWZpQ29uZiA9IHN0ZG91dC50b1N0cmluZygpLmluZGV4T2YoJzx0eXBlPmVmaTwvdHlwZT4nKSA+PSAwO1xuICAgICAgICAgIGNvbnN0IHVlZmkgPSBib290bWV0aG9kID8gYm9vdG1ldGhvZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3VlZmknKSA+PSAwIDogKHVlZmlDb25mID8gdWVmaUNvbmYgOiBudWxsKTtcbiAgICAgICAgICByZXN1bHQuZGlzdHJvID0gZGlzdHJvIHx8IHJlc3VsdC5kaXN0cm87XG4gICAgICAgICAgcmVzdWx0LmxvZ29maWxlID0gbG9nb2ZpbGUgfHwgcmVzdWx0LmxvZ29maWxlO1xuICAgICAgICAgIHJlc3VsdC5yZWxlYXNlID0gcmVsZWFzZSB8fCByZXN1bHQucmVsZWFzZTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gc2VyaWFsIHx8IHJlc3VsdC5zZXJpYWw7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gJyc7XG4gICAgICAgICAgcmVzdWx0LmNvZGVwYWdlID0gdXRpbC5nZXRDb2RlcGFnZSgpO1xuICAgICAgICAgIHJlc3VsdC51ZWZpID0gdWVmaSB8fCBudWxsO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N3X3ZlcnM7IHN5c2N0bCBrZXJuLm9zdHlwZSBrZXJuLm9zcmVsZWFzZSBrZXJuLm9zcmV2aXNpb24ga2Vybi51dWlkJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLnV1aWQnKTtcbiAgICAgICAgICByZXN1bHQuZGlzdHJvID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2R1Y3ROYW1lJyk7XG4gICAgICAgICAgcmVzdWx0LnJlbGVhc2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvZHVjdFZlcnNpb24nKTtcbiAgICAgICAgICByZXN1bHQuYnVpbGQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQnVpbGRWZXJzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LmxvZ29maWxlID0gZ2V0TG9nb0ZpbGUocmVzdWx0LmRpc3Rybyk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gJ21hY09TJztcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuNCcpID4gLTEgPyAnTWFjIE9TIFggVGlnZXInIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuNScpID4gLTEgPyAnTWFjIE9TIFggTGVvcGFyZCcgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC42JykgPiAtMSA/ICdNYWMgT1MgWCBTbm93IExlb3BhcmQnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuNycpID4gLTEgPyAnTWFjIE9TIFggTGlvbicgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC44JykgPiAtMSA/ICdPUyBYIE1vdW50YWluIExpb24nIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuOScpID4gLTEgPyAnT1MgWCBNYXZlcmlja3MnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTAnKSA+IC0xID8gJ09TIFggWW9zZW1pdGUnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQuY29kZW5hbWUgPSAocmVzdWx0LnJlbGVhc2UuaW5kZXhPZignMTAuMTEnKSA+IC0xID8gJ09TIFggRWwgQ2FwaXRhbicgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xMicpID4gLTEgPyAnbWFjT1MgU2llcnJhJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjEzJykgPiAtMSA/ICdtYWNPUyBIaWdoIFNpZXJyYScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5pbmRleE9mKCcxMC4xNCcpID4gLTEgPyAnbWFjT1MgTW9qYXZlJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLmluZGV4T2YoJzEwLjE1JykgPiAtMSA/ICdtYWNPUyBDYXRhbGluYScgOiByZXN1bHQuY29kZW5hbWUpO1xuICAgICAgICAgIHJlc3VsdC5jb2RlbmFtZSA9IChyZXN1bHQucmVsZWFzZS5zdGFydHNXaXRoKCcxMS4nKSA/ICdtYWNPUyBCaWcgU3VyJyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLnN0YXJ0c1dpdGgoJzEyLicpID8gJ21hY09TIE1vbnRlcmV5JyA6IHJlc3VsdC5jb2RlbmFtZSk7XG4gICAgICAgICAgcmVzdWx0LmNvZGVuYW1lID0gKHJlc3VsdC5yZWxlYXNlLnN0YXJ0c1dpdGgoJzEzLicpID8gJ21hY09TIFZlbnR1cmEnIDogcmVzdWx0LmNvZGVuYW1lKTtcbiAgICAgICAgICByZXN1bHQudWVmaSA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0LmNvZGVwYWdlID0gdXRpbC5nZXRDb2RlcGFnZSgpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgcmVzdWx0LnJlbGVhc2UgPSByZXN1bHQua2VybmVsO1xuICAgICAgICBleGVjKCd1bmFtZSAtbycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5kaXN0cm8gPSBsaW5lc1swXTtcbiAgICAgICAgICByZXN1bHQubG9nb2ZpbGUgPSBnZXRMb2dvRmlsZShyZXN1bHQuZGlzdHJvKTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgcmVzdWx0LmxvZ29maWxlID0gZ2V0TG9nb0ZpbGUoKTtcbiAgICAgICAgcmVzdWx0LnJlbGVhc2UgPSByZXN1bHQua2VybmVsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9PcGVyYXRpbmdTeXN0ZW0gfCBzZWxlY3QgQ2FwdGlvbixTZXJpYWxOdW1iZXIsQnVpbGROdW1iZXIsU2VydmljZVBhY2tNYWpvclZlcnNpb24sU2VydmljZVBhY2tNaW5vclZlcnNpb24gfCBmbCcpKTtcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnKEdldC1DaW1JbnN0YW5jZSBXaW4zMl9Db21wdXRlclN5c3RlbSkuSHlwZXJ2aXNvclByZXNlbnQnKSk7XG4gICAgICAgICAgd29ya2xvYWQucHVzaCh1dGlsLnBvd2VyU2hlbGwoJ0FkZC1UeXBlIC1Bc3NlbWJseU5hbWUgU3lzdGVtLldpbmRvd3MuRm9ybXM7IFtTeXN0ZW0uV2luZG93cy5Gb3Jtcy5TeXN0ZW1JbmZvcm1hdGlvbl06OlRlcm1pbmFsU2VydmVyU2Vzc2lvbicpKTtcbiAgICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgICB3b3JrbG9hZFxuICAgICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gZGF0YS5yZXN1bHRzWzBdID8gZGF0YS5yZXN1bHRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpIDogWycnXTtcbiAgICAgICAgICAgIHJlc3VsdC5kaXN0cm8gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTZXJpYWxOdW1iZXInLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5idWlsZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCdWlsZE51bWJlcicsICc6JykudHJpbSgpO1xuICAgICAgICAgICAgcmVzdWx0LnNlcnZpY2VwYWNrID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcnZpY2VQYWNrTWFqb3JWZXJzaW9uJywgJzonKS50cmltKCkgKyAnLicgKyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VydmljZVBhY2tNaW5vclZlcnNpb24nLCAnOicpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlcGFnZSA9IHV0aWwuZ2V0Q29kZXBhZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGh5cGVydiA9IGRhdGEucmVzdWx0c1sxXSA/IGRhdGEucmVzdWx0c1sxXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgICAgICAgIHJlc3VsdC5oeXBlcnZpc29yID0gaHlwZXJ2LmluZGV4T2YoJ3RydWUnKSAhPT0gLTE7XG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gZGF0YS5yZXN1bHRzWzJdID8gZGF0YS5yZXN1bHRzWzJdLnRvU3RyaW5nKCkgOiAnJztcbiAgICAgICAgICAgIHJlc3VsdC5yZW1vdGVTZXNzaW9uID0gKHRlcm0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3RydWUnKSA+PSAwKTtcbiAgICAgICAgICAgIGlzVWVmaVdpbmRvd3MoKS50aGVuKHVlZmkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHQudWVmaSA9IHVlZmk7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5vc0luZm8gPSBvc0luZm87XG5cbmZ1bmN0aW9uIGlzVWVmaUxpbnV4KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGZzLnN0YXQoJy9zeXMvZmlybXdhcmUvZWZpJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4ZWMoJ2RtZXNnIHwgZ3JlcCAtRSBcIkVGSSB2XCInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGluZXMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNVZWZpV2luZG93cygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBleGVjKCdmaW5kc3RyIC9DOlwiRGV0ZWN0ZWQgYm9vdCBlbnZpcm9ubWVudFwiIFwiJXdpbmRpciVcXFxcUGFudGhlclxcXFxzZXR1cGFjdC5sb2dcIicsIHV0aWwuZXhlY09wdHNXaW4sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG5cXHInKVswXTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdlZmknKSA+PSAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygnZWNobyAlZmlybXdhcmVfdHlwZSUnLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0ZG91dC50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpbmUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdlZmknKSA+PSAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZlcnNpb25zKGFwcHMsIGNhbGxiYWNrKSB7XG4gIGxldCB2ZXJzaW9uT2JqZWN0ID0ge1xuICAgIGtlcm5lbDogb3MucmVsZWFzZSgpLFxuICAgIG9wZW5zc2w6ICcnLFxuICAgIHN5c3RlbU9wZW5zc2w6ICcnLFxuICAgIHN5c3RlbU9wZW5zc2xMaWI6ICcnLFxuICAgIG5vZGU6IHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICB2ODogcHJvY2Vzcy52ZXJzaW9ucy52OCxcbiAgICBucG06ICcnLFxuICAgIHlhcm46ICcnLFxuICAgIHBtMjogJycsXG4gICAgZ3VscDogJycsXG4gICAgZ3J1bnQ6ICcnLFxuICAgIGdpdDogJycsXG4gICAgdHNjOiAnJyxcbiAgICBteXNxbDogJycsXG4gICAgcmVkaXM6ICcnLFxuICAgIG1vbmdvZGI6ICcnLFxuICAgIGFwYWNoZTogJycsXG4gICAgbmdpbng6ICcnLFxuICAgIHBocDogJycsXG4gICAgZG9ja2VyOiAnJyxcbiAgICBwb3N0Zml4OiAnJyxcbiAgICBwb3N0Z3Jlc3FsOiAnJyxcbiAgICBwZXJsOiAnJyxcbiAgICBweXRob246ICcnLFxuICAgIHB5dGhvbjM6ICcnLFxuICAgIHBpcDogJycsXG4gICAgcGlwMzogJycsXG4gICAgamF2YTogJycsXG4gICAgZ2NjOiAnJyxcbiAgICB2aXJ0dWFsYm94OiAnJyxcbiAgICBiYXNoOiAnJyxcbiAgICB6c2g6ICcnLFxuICAgIGZpc2g6ICcnLFxuICAgIHBvd2Vyc2hlbGw6ICcnLFxuICAgIGRvdG5ldDogJydcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1ZlcnNpb25QYXJhbShhcHBzKSB7XG4gICAgaWYgKGFwcHMgPT09ICcqJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbnM6IHZlcnNpb25PYmplY3QsXG4gICAgICAgIGNvdW50ZXI6IDMwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXBwcykpIHtcbiAgICAgIGFwcHMgPSBhcHBzLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLywrL2csICd8JykucmVwbGFjZSgvIC9nLCAnfCcpO1xuICAgICAgYXBwcyA9IGFwcHMuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdmVyc2lvbnM6IHt9LFxuICAgICAgICBjb3VudGVyOiAwXG4gICAgICB9O1xuICAgICAgYXBwcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHZlcnNpb25PYmplY3QpIHtcbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnNpb25PYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleS50b0xvd2VyQ2FzZSgpID09PSBlbC50b0xvd2VyQ2FzZSgpICYmICF7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdC52ZXJzaW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uc1trZXldID0gdmVyc2lvbk9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvcGVuc3NsJykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb25zLnN5c3RlbU9wZW5zc2wgPSAnJztcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9ucy5zeXN0ZW1PcGVuc3NsTGliID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQudmVyc2lvbnNba2V5XSkgeyByZXN1bHQuY291bnRlcisrOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oYXBwcykgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXBwcztcbiAgICAgICAgYXBwcyA9ICcqJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcHMgPSBhcHBzIHx8ICcqJztcbiAgICAgICAgaWYgKHR5cGVvZiBhcHBzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayh7fSk7IH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFwcHNPYmogPSBjaGVja1ZlcnNpb25QYXJhbShhcHBzKTtcbiAgICAgIGxldCB0b3RhbEZ1bmN0aW9ucyA9IGFwcHNPYmouY291bnRlcjtcblxuICAgICAgbGV0IGZ1bmN0aW9uUHJvY2Vzc2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoLS10b3RhbEZ1bmN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGFwcHNPYmoudmVyc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShhcHBzT2JqLnZlcnNpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSgpO1xuXG4gICAgICBsZXQgY21kID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnb3BlbnNzbCcpKSB7XG4gICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5vcGVuc3NsID0gcHJvY2Vzcy52ZXJzaW9ucy5vcGVuc3NsO1xuICAgICAgICAgIGV4ZWMoJ29wZW5zc2wgdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBvcGVuc3NsX3N0cmluZyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS50cmltKCk7XG4gICAgICAgICAgICAgIGxldCBvcGVuc3NsID0gb3BlbnNzbF9zdHJpbmcuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5zeXN0ZW1PcGVuc3NsID0gb3BlbnNzbC5sZW5ndGggPiAwID8gb3BlbnNzbFsxXSA6IG9wZW5zc2xbMF07XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuc3lzdGVtT3BlbnNzbExpYiA9IG9wZW5zc2wubGVuZ3RoID4gMCA/IG9wZW5zc2xbMF0gOiAnb3BlbnNzbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICducG0nKSkge1xuICAgICAgICAgIGV4ZWMoJ25wbSAtdicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMubnBtID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncG0yJykpIHtcbiAgICAgICAgICBjbWQgPSAncG0yJztcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNtZCArPSAnLmNtZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMoYCR7Y21kfSAtdmAsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGxldCBwbTIgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICBpZiAoIXBtMi5zdGFydHNXaXRoKCdbUE0yXScpKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wbTIgPSBwbTI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3lhcm4nKSkge1xuICAgICAgICAgIGV4ZWMoJ3lhcm4gLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy55YXJuID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZ3VscCcpKSB7XG4gICAgICAgICAgY21kID0gJ2d1bHAnO1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgY21kICs9ICcuY21kJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYyhgJHtjbWR9IC0tdmVyc2lvbmAsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGd1bHAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ3VscCA9IChndWxwLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24nKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAndHNjJykpIHtcbiAgICAgICAgICBjbWQgPSAndHNjJztcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNtZCArPSAnLmNtZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4ZWMoYCR7Y21kfSAtLXZlcnNpb25gLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCB0c2MgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMudHNjID0gKHRzYy50b0xvd2VyQ2FzZSgpLnNwbGl0KCd2ZXJzaW9uJylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2dydW50JykpIHtcbiAgICAgICAgICBjbWQgPSAnZ3J1bnQnO1xuICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgY21kICs9ICcuY21kJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhlYyhgJHtjbWR9IC0tdmVyc2lvbmAsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdydW50ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmdydW50ID0gKGdydW50LnRvTG93ZXJDYXNlKCkuc3BsaXQoJ2NsaSB2JylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2dpdCcpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzID0gZnMuZXhpc3RzU3luYygnL3Vzci9sb2NhbC9DZWxsYXIvZ2l0JykgfHwgZnMuZXhpc3RzU3luYygnL29wdC9ob21lYnJldy9iaW4vZ2l0Jyk7XG4gICAgICAgICAgICBpZiAodXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpIHx8IGdpdEhvbWVicmV3RXhpc3RzKSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ2dpdCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBnaXQgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICBnaXQgPSAoZ2l0LnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3ZlcnNpb24nKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5naXQgPSAoZ2l0LnNwbGl0KCcgJylbMF0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjKCdnaXQgLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBnaXQgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgZ2l0ID0gKGdpdC50b0xvd2VyQ2FzZSgpLnNwbGl0KCd2ZXJzaW9uJylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmdpdCA9IChnaXQuc3BsaXQoJyAnKVswXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2FwYWNoZScpKSB7XG4gICAgICAgICAgZXhlYygnYXBhY2hlY3RsIC12IDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBhcGFjaGUgPSAoc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnKS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmFwYWNoZSA9IChhcGFjaGUubGVuZ3RoID4gMSA/IGFwYWNoZVsxXS5yZXBsYWNlKCdBcGFjaGUnLCAnJykucmVwbGFjZSgnLycsICcnKS5zcGxpdCgnKCcpWzBdLnRyaW0oKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ25naW54JykpIHtcbiAgICAgICAgICBleGVjKCduZ2lueCAtdiAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmdpbnggPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMubmdpbnggPSAobmdpbngudG9Mb3dlckNhc2UoKS5zcGxpdCgnLycpWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdteXNxbCcpKSB7XG4gICAgICAgICAgZXhlYygnbXlzcWwgLVYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbXlzcWwgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIG15c3FsID0gbXlzcWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKG15c3FsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbXlzcWwgPSAobXlzcWwuc3BsaXQoJywnKVswXSB8fCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbXlzcWwuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm15c3FsID0gKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG15c3FsLmluZGV4T2YoJyB2ZXIgJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgbXlzcWwgPSBteXNxbC5zcGxpdCgnIHZlciAnKVsxXTtcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMubXlzcWwgPSBteXNxbC5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncGhwJykpIHtcbiAgICAgICAgICBleGVjKCdwaHAgLXYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBwaHAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGxldCBwYXJ0cyA9IHBocC5zcGxpdCgnKCcpO1xuICAgICAgICAgICAgICBpZiAocGFydHNbMF0uaW5kZXhPZignLScpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucGhwID0gcGFydHNbMF0ucmVwbGFjZSgvW14wLTkuXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdyZWRpcycpKSB7XG4gICAgICAgICAgZXhlYygncmVkaXMtc2VydmVyIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlZGlzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHJlZGlzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucmVkaXMgPSB1dGlsLmdldFZhbHVlKHBhcnRzLCAndicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdkb2NrZXInKSkge1xuICAgICAgICAgIGV4ZWMoJ2RvY2tlciAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBkb2NrZXIgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZG9ja2VyLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZG9ja2VyID0gcGFydHMubGVuZ3RoID4gMiAmJiBwYXJ0c1syXS5lbmRzV2l0aCgnLCcpID8gcGFydHNbMl0uc2xpY2UoMCwgLTEpIDogJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwb3N0Zml4JykpIHtcbiAgICAgICAgICBleGVjKCdwb3N0Y29uZiAtZCB8IGdyZXAgbWFpbF92ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9zdGZpeCA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKSB8fCBbXTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Zml4ID0gdXRpbC5nZXRWYWx1ZShwb3N0Zml4LCAnbWFpbF92ZXJzaW9uJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ21vbmdvZGInKSkge1xuICAgICAgICAgIGV4ZWMoJ21vbmdvZCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBtb25nb2RiID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLm1vbmdvZGIgPSAobW9uZ29kYi50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJylbMF0gfHwgJycpLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncG9zdGdyZXNxbCcpKSB7XG4gICAgICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICAgICAgZXhlYygnbG9jYXRlIGJpbi9wb3N0Z3JlcycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3FsQmluID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zdGdyZXNxbEJpbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGV4ZWMocG9zdGdyZXNxbEJpbltwb3N0Z3Jlc3FsQmluLmxlbmd0aCAtIDFdICsgJyAtVicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3FsID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnNwbGl0KCcgJykgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wb3N0Z3Jlc3FsID0gcG9zdGdyZXNxbC5sZW5ndGggPyBwb3N0Z3Jlc3FsW3Bvc3RncmVzcWwubGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4ZWMoJ3BzcWwgLVYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3FsID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnNwbGl0KCcgJykgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbCA9IHBvc3RncmVzcWwubGVuZ3RoID8gcG9zdGdyZXNxbFtwb3N0Z3Jlc3FsLmxlbmd0aCAtIDFdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbCA9IGFwcHNPYmoudmVyc2lvbnMucG9zdGdyZXNxbC5zcGxpdCgnLScpWzBdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9TZXJ2aWNlIHwgc2VsZWN0IGNhcHRpb24gfCBmbCcpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZXJ2aWNlU2VjdGlvbnMgPSBzdGRvdXQuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlU2VjdGlvbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBpdGVtLnRyaW0oKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcnZDYXB0aW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NhcHRpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcnZDYXB0aW9uLmluZGV4T2YoJ3Bvc3RncmVzcWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzcnZDYXB0aW9uLnNwbGl0KCcgc2VydmVyICcpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ3Bvc3RncmVzIC1WJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3FsID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdLnNwbGl0KCcgJykgfHwgW107XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBvc3RncmVzcWwgPSBwb3N0Z3Jlc3FsLmxlbmd0aCA/IHBvc3RncmVzcWxbcG9zdGdyZXNxbC5sZW5ndGggLSAxXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3BlcmwnKSkge1xuICAgICAgICAgIGV4ZWMoJ3BlcmwgLXYnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBwZXJsID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpIHx8ICcnO1xuICAgICAgICAgICAgICB3aGlsZSAocGVybC5sZW5ndGggPiAwICYmIHBlcmxbMF0udHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIHBlcmwuc2hpZnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocGVybC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5wZXJsID0gcGVybFswXS5zcGxpdCgnKCcpLnBvcCgpLnNwbGl0KCcpJylbMF0ucmVwbGFjZSgndicsICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncHl0aG9uJykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ3N3X3ZlcnMnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3Qgb3NWZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2R1Y3RWZXJzaW9uJywgJzonKTtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzMSA9IGZzLmV4aXN0c1N5bmMoJy91c3IvbG9jYWwvQ2VsbGFyL3B5dGhvbicpO1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMyID0gZnMuZXhpc3RzU3luYygnL29wdC9ob21lYnJldy9iaW4vcHl0aG9uJyk7XG4gICAgICAgICAgICBpZiAoKHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSAmJiB1dGlsLnNlbXZlckNvbXBhcmUoJzEyLjAuMScsIG9zVmVyc2lvbikgPCAwKSB8fCBnaXRIb21lYnJld0V4aXN0czEgfHwgZ2l0SG9tZWJyZXdFeGlzdHMyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNtZCA9IGdpdEhvbWVicmV3RXhpc3RzMSA/ICcvdXNyL2xvY2FsL0NlbGxhci9weXRob24gLVYgMj4mMScgOiAoZ2l0SG9tZWJyZXdFeGlzdHMyID8gJy9vcHQvaG9tZWJyZXcvYmluL3B5dGhvbiAtViAyPiYxJyA6ICdweXRob24gLVYgMj4mMScpO1xuICAgICAgICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBweXRob24gPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnB5dGhvbiA9IHB5dGhvbi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3B5dGhvbicsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygncHl0aG9uIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHl0aG9uID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucHl0aG9uID0gcHl0aG9uLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncHl0aG9uJywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdweXRob24zJykpIHtcbiAgICAgICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICAgICAgY29uc3QgZ2l0SG9tZWJyZXdFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvdXNyL2xvY2FsL0NlbGxhci9weXRob24zJykgfHwgZnMuZXhpc3RzU3luYygnL29wdC9ob21lYnJldy9iaW4vcHl0aG9uMycpO1xuICAgICAgICAgICAgaWYgKHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSB8fCBnaXRIb21lYnJld0V4aXN0cykge1xuICAgICAgICAgICAgICBleGVjKCdweXRob24zIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucHl0aG9uMyA9IHB5dGhvbi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3B5dGhvbicsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygncHl0aG9uMyAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB5dGhvbiA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnB5dGhvbjMgPSBweXRob24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdweXRob24nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3BpcCcpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzID0gZnMuZXhpc3RzU3luYygnL3Vzci9sb2NhbC9DZWxsYXIvcGlwJykgfHwgZnMuZXhpc3RzU3luYygnL29wdC9ob21lYnJldy9iaW4vcGlwJyk7XG4gICAgICAgICAgICBpZiAodXRpbC5kYXJ3aW5YY29kZUV4aXN0cygpIHx8IGdpdEhvbWVicmV3RXhpc3RzKSB7XG4gICAgICAgICAgICAgIGV4ZWMoJ3BpcCAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwaXAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBpcC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5waXAgPSBwYXJ0cy5sZW5ndGggPj0gMiA/IHBhcnRzWzFdIDogJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygncGlwIC1WIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGlwID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gcGlwLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5waXAgPSBwYXJ0cy5sZW5ndGggPj0gMiA/IHBhcnRzWzFdIDogJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAncGlwMycpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGdpdEhvbWVicmV3RXhpc3RzID0gZnMuZXhpc3RzU3luYygnL3Vzci9sb2NhbC9DZWxsYXIvcGlwMycpIHx8IGZzLmV4aXN0c1N5bmMoJy9vcHQvaG9tZWJyZXcvYmluL3BpcDMnKTtcbiAgICAgICAgICAgIGlmICh1dGlsLmRhcndpblhjb2RlRXhpc3RzKCkgfHwgZ2l0SG9tZWJyZXdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgZXhlYygncGlwMyAtViAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwaXAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHBpcC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5waXAzID0gcGFydHMubGVuZ3RoID49IDIgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4ZWMoJ3BpcDMgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXAgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBwaXAuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnBpcDMgPSBwYXJ0cy5sZW5ndGggPj0gMiA/IHBhcnRzWzFdIDogJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnamF2YScpKSB7XG4gICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFueSBKVk0gaXMgaW5zdGFsbGVkIGJ1dCBhdm9pZCBkaWFsb2cgYm94IHRoYXQgSmF2YSBuZWVkcyB0byBiZSBpbnN0YWxsZWRcbiAgICAgICAgICAgIGV4ZWMoJy91c3IvbGliZXhlYy9qYXZhX2hvbWUgLVYgMj4mMScsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IgJiYgc3Rkb3V0LnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdubyBqYXZhIHJ1bnRpbWUnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBub3cgdGhpcyBjYW4gYmUgZG9uZSBzYXZlbHlcbiAgICAgICAgICAgICAgICBleGVjKCdqYXZhIC12ZXJzaW9uIDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqYXZhID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGphdmEuc3BsaXQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuamF2YSA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnRzWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlYygnamF2YSAtdmVyc2lvbiAyPiYxJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGphdmEgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBqYXZhLnNwbGl0KCdcIicpO1xuICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuamF2YSA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnRzWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2djYycpKSB7XG4gICAgICAgICAgaWYgKChfZGFyd2luICYmIHV0aWwuZGFyd2luWGNvZGVFeGlzdHMoKSkgfHwgIV9kYXJ3aW4pIHtcbiAgICAgICAgICAgIGV4ZWMoJ2djYyAtZHVtcHZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5nY2MgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF0udHJpbSgpIHx8ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhcHBzT2JqLnZlcnNpb25zLmdjYy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhlYygnZ2NjIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdjYyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnY2MuaW5kZXhPZignZ2NjJykgPiAtMSAmJiBnY2MuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGdjYy5zcGxpdCgnKScpO1xuICAgICAgICAgICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMuZ2NjID0gcGFydHNbMV0udHJpbSgpIHx8IGFwcHNPYmoudmVyc2lvbnMuZ2NjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ3ZpcnR1YWxib3gnKSkge1xuICAgICAgICAgIGV4ZWModXRpbC5nZXRWYm94bWFuYWdlKCkgKyAnIC12IDI+JjEnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCB2Ym94ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHZib3guc3BsaXQoJ3InKTtcbiAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy52aXJ0dWFsYm94ID0gcGFydHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdiYXNoJykpIHtcbiAgICAgICAgICBleGVjKCdiYXNoIC0tdmVyc2lvbicsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnIHZlcnNpb24gJyk7XG4gICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYXBwc09iai52ZXJzaW9ucy5iYXNoID0gcGFydHNbMV0uc3BsaXQoJyAnKVswXS5zcGxpdCgnKCcpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICd6c2gnKSkge1xuICAgICAgICAgIGV4ZWMoJ3pzaCAtLXZlcnNpb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoJ3pzaCAnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLnpzaCA9IHBhcnRzWzFdLnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYXBwc09iai52ZXJzaW9ucywgJ2Zpc2gnKSkge1xuICAgICAgICAgIGV4ZWMoJ2Zpc2ggLS12ZXJzaW9uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKVswXTtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgdmVyc2lvbiAnKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmZpc2ggPSBwYXJ0c1sxXS5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcHNPYmoudmVyc2lvbnMsICdwb3dlcnNoZWxsJykpIHtcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnJFBTVmVyc2lvblRhYmxlJykudGhlbihzdGRvdXQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnJlcGxhY2UoLyArL2csICcgJykucmVwbGFjZSgvICsvZywgJzonKSk7XG4gICAgICAgICAgICAgIGFwcHNPYmoudmVyc2lvbnMucG93ZXJzaGVsbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwc3ZlcnNpb24nKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblByb2Nlc3NlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChhcHBzT2JqLnZlcnNpb25zLCAnZG90bmV0JykpIHtcbiAgICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnZ2NpIFwiSEtMTTpcXFxcU09GVFdBUkVcXFxcTWljcm9zb2Z0XFxcXE5FVCBGcmFtZXdvcmsgU2V0dXBcXFxcTkRQXCIgLXJlY3Vyc2UgfCBncCAtbmFtZSBWZXJzaW9uLFJlbGVhc2UgLUVBIDAgfCB3aGVyZSB7ICRfLlBTQ2hpbGROYW1lIC1tYXRjaCBcIl4oPyFTKVxcXFxwe0x9XCJ9IHwgc2VsZWN0IFBTQ2hpbGROYW1lLCBWZXJzaW9uLCBSZWxlYXNlJykudGhlbihzdGRvdXQgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgbGV0IGRvdG5ldCA9ICcnO1xuICAgICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgZG90bmV0ID0gZG90bmV0IHx8IChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NsaWVudCcpICYmIHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1sxXS50cmltKCkgOiAocGFydHNbMF0udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdmdWxsJykgJiYgcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzFdLnRyaW0oKSA6ICcnKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcHBzT2JqLnZlcnNpb25zLmRvdG5ldCA9IGRvdG5ldC50cmltKCk7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnVuY3Rpb25Qcm9jZXNzZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGFwcHNPYmoudmVyc2lvbnMpOyB9XG4gICAgICAgIHJlc29sdmUoYXBwc09iai52ZXJzaW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnZlcnNpb25zID0gdmVyc2lvbnM7XG5cbmZ1bmN0aW9uIHNoZWxsKGNhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHJlc29sdmUoJ2NtZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBleGVjKCdlY2hvICRTSEVMTCcsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnNoZWxsID0gc2hlbGw7XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZU1hY0FkcmVzc2VzKCkge1xuICBsZXQgbWFjcyA9IFtdO1xuICB0cnkge1xuICAgIGNvbnN0IGlmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG4gICAgZm9yIChsZXQgZGV2IGluIGlmYWNlcykge1xuICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoaWZhY2VzLCBkZXYpKSB7XG4gICAgICAgIGlmYWNlc1tkZXZdLmZvckVhY2goZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLm1hYyAmJiBkZXRhaWxzLm1hYyAhPT0gJzAwOjAwOjAwOjAwOjAwOjAwJykge1xuICAgICAgICAgICAgY29uc3QgbWFjID0gZGV0YWlscy5tYWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChtYWNzLmluZGV4T2YobWFjKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbWFjcy5wdXNoKG1hYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFjcyA9IG1hY3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGEgPCBiKSB7IHJldHVybiAtMTsgfVxuICAgICAgaWYgKGEgPiBiKSB7IHJldHVybiAxOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIG1hY3MucHVzaCgnMDA6MDA6MDA6MDA6MDA6MDAnKTtcbiAgfVxuICByZXR1cm4gbWFjcztcbn1cblxuZnVuY3Rpb24gdXVpZChjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgb3M6ICcnLFxuICAgICAgICBoYXJkd2FyZTogJycsXG4gICAgICAgIG1hY3M6IGdldFVuaXF1ZU1hY0FkcmVzc2VzKClcbiAgICAgIH07XG4gICAgICBsZXQgcGFydHM7XG5cbiAgICAgIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGV4ZWMoJ3N5c3RlbV9wcm9maWxlciBTUEhhcmR3YXJlRGF0YVR5cGUgLWpzb24nLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSBKU09OLnBhcnNlKHN0ZG91dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgaWYgKGpzb25PYmouU1BIYXJkd2FyZURhdGFUeXBlICYmIGpzb25PYmouU1BIYXJkd2FyZURhdGFUeXBlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcEhhcmR3YXJlID0ganNvbk9iai5TUEhhcmR3YXJlRGF0YVR5cGVbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9zID0gc3BIYXJkd2FyZS5wbGF0Zm9ybV9VVUlELnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhhcmR3YXJlID0gc3BIYXJkd2FyZS5zZXJpYWxfbnVtYmVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGBlY2hvIC1uIFwib3M6IFwiOyBjYXQgL3Zhci9saWIvZGJ1cy9tYWNoaW5lLWlkIDI+IC9kZXYvbnVsbDsgZWNobztcbmVjaG8gLW4gXCJvczogXCI7IGNhdCAvZXRjL21hY2hpbmUtaWQgMj4gL2Rldi9udWxsOyBlY2hvO1xuZWNobyAtbiBcImhhcmR3YXJlOiBcIjsgY2F0IC9zeXMvY2xhc3MvZG1pL2lkL3Byb2R1Y3RfdXVpZCAyPiAvZGV2L251bGw7IGVjaG87YDtcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgcmVzdWx0Lm9zID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ29zJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXN1bHQuaGFyZHdhcmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaGFyZHdhcmUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICghcmVzdWx0LmhhcmR3YXJlKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IGZzLnJlYWRGaWxlU3luYygnL3Byb2MvY3B1aW5mbycsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWwnKTtcbiAgICAgICAgICAgIHJlc3VsdC5oYXJkd2FyZSA9IHNlcmlhbCB8fCAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnc3lzY3RsIC1pIGtlcm4uaG9zdGlkIGtlcm4uaG9zdHV1aWQnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC5vcyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdrZXJuLmhvc3RpZCcsICc6JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXN1bHQuaGFyZHdhcmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2Vybi5ob3N0dXVpZCcsICc6JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lm9zLmluZGV4T2YoJ3Vua25vd24nKSA+PSAwKSB7IHJlc3VsdC5vcyA9ICcnOyB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5oYXJkd2FyZS5pbmRleE9mKCd1bmtub3duJykgPj0gMCkgeyByZXN1bHQuaGFyZHdhcmUgPSAnJzsgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICBsZXQgc3lzZGlyID0gJyV3aW5kaXIlXFxcXFN5c3RlbTMyJztcbiAgICAgICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzLmVudiwgJ1BST0NFU1NPUl9BUkNISVRFVzY0MzInKSkge1xuICAgICAgICAgIHN5c2RpciA9ICcld2luZGlyJVxcXFxzeXNuYXRpdmVcXFxcY21kLmV4ZSAvYyAld2luZGlyJVxcXFxTeXN0ZW0zMic7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfQ29tcHV0ZXJTeXN0ZW1Qcm9kdWN0IHwgc2VsZWN0IFVVSUQgfCBmbCcpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgcmVzdWx0LmhhcmR3YXJlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3V1aWQnLCAnOicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgZXhlYyhgJHtzeXNkaXJ9XFxcXHJlZyBxdWVyeSBcIkhLRVlfTE9DQUxfTUFDSElORVxcXFxTT0ZUV0FSRVxcXFxNaWNyb3NvZnRcXFxcQ3J5cHRvZ3JhcGh5XCIgL3YgTWFjaGluZUd1aWRgLCB1dGlsLmV4ZWNPcHRzV2luLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxyJylbMF0uc3BsaXQoJ1JFR19TWicpO1xuICAgICAgICAgICAgcmVzdWx0Lm9zID0gcGFydHMubGVuZ3RoID4gMSA/IHBhcnRzWzFdLnJlcGxhY2UoL1xccit8XFxuK3xcXHMrL2lnLCAnJykudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy51dWlkID0gdXVpZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gcHJpbnRlcnMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxNS4gcHJpbnRlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuY29uc3Qgd2luUHJpbnRlclN0YXR1cyA9IHtcbiAgMTogJ090aGVyJyxcbiAgMjogJ1Vua25vd24nLFxuICAzOiAnSWRsZScsXG4gIDQ6ICdQcmludGluZycsXG4gIDU6ICdXYXJtdXAnLFxuICA2OiAnU3RvcHBlZCBQcmludGluZycsXG4gIDc6ICdPZmZsaW5lJyxcbn07XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhDdXBzSGVhZGVyKGxpbmVzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBpZiAobGluZXMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgaWYgKGxpbmVzWzBdLmluZGV4T2YoJyBDVVBTIHYnKSA+IDApIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3BsaXQoJyBDVVBTIHYnKTtcbiAgICAgIHJlc3VsdC5jdXBzVmVyc2lvbiA9IHBhcnRzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpbnV4Q3Vwc1ByaW50ZXIobGluZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHByaW50ZXJJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcmludGVySWQnLCAnICcpO1xuICByZXN1bHQuaWQgPSBwcmludGVySWQgPyBwYXJzZUludChwcmludGVySWQsIDEwKSA6IG51bGw7XG4gIHJlc3VsdC5uYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0luZm8nLCAnICcpO1xuICByZXN1bHQubW9kZWwgPSBsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzWzBdID8gbGluZXNbMF0uc3BsaXQoJyAnKVswXSA6ICcnO1xuICByZXN1bHQudXJpID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RldmljZVVSSScsICcgJyk7XG4gIHJlc3VsdC51dWlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VVSUQnLCAnICcpO1xuICByZXN1bHQuc3RhdHVzID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXRlJywgJyAnKTtcbiAgcmVzdWx0LmxvY2FsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvY2F0aW9uJywgJyAnKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2xvY2FsJyk7XG4gIHJlc3VsdC5kZWZhdWx0ID0gbnVsbDtcbiAgcmVzdWx0LnNoYXJlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaGFyZWQnLCAnICcpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgneWVzJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaW51eExwc3RhdFByaW50ZXIobGluZXMsIGlkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICByZXN1bHQuaWQgPSBpZDtcbiAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRGVzY3JpcHRpb24nLCAnOicsIHRydWUpO1xuICByZXN1bHQubW9kZWwgPSBsaW5lcy5sZW5ndGggPiAwICYmIGxpbmVzWzBdID8gbGluZXNbMF0uc3BsaXQoJyAnKVswXSA6ICcnO1xuICByZXN1bHQudXJpID0gbnVsbDtcbiAgcmVzdWx0LnV1aWQgPSBudWxsO1xuICByZXN1bHQuc3RhdHVzID0gbGluZXMubGVuZ3RoID4gMCAmJiBsaW5lc1swXSA/IChsaW5lc1swXS5pbmRleE9mKCcgaWRsZScpID4gMCA/ICdpZGxlJyA6IChsaW5lc1swXS5pbmRleE9mKCcgcHJpbnRpbmcnKSA+IDAgPyAncHJpbnRpbmcnIDogJ3Vua25vd24nKSkgOiBudWxsO1xuICByZXN1bHQubG9jYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9jYXRpb24nLCAnOicsIHRydWUpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbG9jYWwnKTtcbiAgcmVzdWx0LmRlZmF1bHQgPSBudWxsO1xuICByZXN1bHQuc2hhcmVkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NoYXJlZCcsICcgJykudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd5ZXMnKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZURhcndpblByaW50ZXJzKHByaW50ZXJPYmplY3QsIGlkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCB1cmlQYXJ0cyA9IHByaW50ZXJPYmplY3QudXJpLnNwbGl0KCcvJyk7XG4gIHJlc3VsdC5pZCA9IGlkO1xuICByZXN1bHQubmFtZSA9IHByaW50ZXJPYmplY3QuX25hbWU7XG4gIHJlc3VsdC5tb2RlbCA9IHVyaVBhcnRzLmxlbmd0aCA/IHVyaVBhcnRzW3VyaVBhcnRzLmxlbmd0aCAtIDFdIDogJyc7XG4gIHJlc3VsdC51cmkgPSBwcmludGVyT2JqZWN0LnVyaTtcbiAgcmVzdWx0LnV1aWQgPSBudWxsO1xuICByZXN1bHQuc3RhdHVzID0gcHJpbnRlck9iamVjdC5zdGF0dXM7XG4gIHJlc3VsdC5sb2NhbCA9IHByaW50ZXJPYmplY3QucHJpbnRzZXJ2ZXIgPT09ICdsb2NhbCc7XG4gIHJlc3VsdC5kZWZhdWx0ID0gcHJpbnRlck9iamVjdC5kZWZhdWx0ID09PSAneWVzJztcbiAgcmVzdWx0LnNoYXJlZCA9IHByaW50ZXJPYmplY3Quc2hhcmVkID09PSAneWVzJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NQcmludGVycyhsaW5lcywgaWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IHN0YXR1cyA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcmludGVyU3RhdHVzJywgJzonKSwgMTApO1xuXG4gIHJlc3VsdC5pZCA9IGlkO1xuICByZXN1bHQubmFtZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKTtcbiAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RyaXZlck5hbWUnLCAnOicpO1xuICByZXN1bHQudXJpID0gbnVsbDtcbiAgcmVzdWx0LnV1aWQgPSBudWxsO1xuICByZXN1bHQuc3RhdHVzID0gd2luUHJpbnRlclN0YXR1c1tzdGF0dXNdID8gd2luUHJpbnRlclN0YXR1c1tzdGF0dXNdIDogbnVsbDtcbiAgcmVzdWx0LmxvY2FsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0xvY2FsJywgJzonKS50b1VwcGVyQ2FzZSgpID09PSAnVFJVRSc7XG4gIHJlc3VsdC5kZWZhdWx0ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0RlZmF1bHQnLCAnOicpLnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJztcbiAgcmVzdWx0LnNoYXJlZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTaGFyZWQnLCAnOicpLnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwcmludGVyKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgbGV0IGNtZCA9ICdjYXQgL2V0Yy9jdXBzL3ByaW50ZXJzLmNvbmYgMj4vZGV2L251bGwnO1xuICAgICAgICBleGVjKGNtZCwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAvLyBwcmludGVycy5jb25mXG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnPFByaW50ZXIgJyk7XG4gICAgICAgICAgICBjb25zdCBwcmludGVySGVhZGVyID0gcGFyc2VMaW51eEN1cHNIZWFkZXIocGFydHNbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBwcmludGVycyA9IHBhcnNlTGludXhDdXBzUHJpbnRlcihwYXJ0c1tpXS5zcGxpdCgnXFxuJykpO1xuICAgICAgICAgICAgICBpZiAocHJpbnRlcnMubmFtZSkge1xuICAgICAgICAgICAgICAgIHByaW50ZXJzLmVuZ2luZSA9ICdDVVBTJztcbiAgICAgICAgICAgICAgICBwcmludGVycy5lbmdpbmVWZXJzaW9uID0gcHJpbnRlckhlYWRlci5jdXBzVmVyc2lvbjtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmludGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAgICAgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgbHBzdGF0IC1scCAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJztcbiAgICAgICAgICAgICAgLy8gbHBzdGF0XG4gICAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gKCdcXG4nICsgc3Rkb3V0LnRvU3RyaW5nKCkpLnNwbGl0KCdcXG5wcmludGVyICcpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW50ZXJzID0gcGFyc2VMaW51eExwc3RhdFByaW50ZXIocGFydHNbaV0uc3BsaXQoJ1xcbicpLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByaW50ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdzeXN0ZW1fcHJvZmlsZXIgU1BQcmludGVyc0RhdGFUeXBlIC1qc29uJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0T2JqID0gSlNPTi5wYXJzZShzdGRvdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgIGlmIChvdXRPYmouU1BQcmludGVyc0RhdGFUeXBlICYmIG91dE9iai5TUFByaW50ZXJzRGF0YVR5cGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRPYmouU1BQcmludGVyc0RhdGFUeXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwcmludGVyID0gcGFyc2VEYXJ3aW5QcmludGVycyhvdXRPYmouU1BQcmludGVyc0RhdGFUeXBlW2ldLCBpKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1ByaW50ZXIgfCBzZWxlY3QgUHJpbnRlclN0YXR1cyxOYW1lLERyaXZlck5hbWUsTG9jYWwsRGVmYXVsdCxTaGFyZWQgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHByaW50ZXIgPSBwYXJzZVdpbmRvd3NQcmludGVycyhwYXJ0c1tpXS5zcGxpdCgnXFxuJyksIGkpO1xuICAgICAgICAgICAgICBpZiAocHJpbnRlci5uYW1lIHx8IHByaW50ZXIubW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwcmludGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnByaW50ZXIgPSBwcmludGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBwcm9jZXNzZXMuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxMC4gUHJvY2Vzc2VzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuY29uc3QgX3Byb2Nlc3Nlc19jcHUgPSB7XG4gIGFsbDogMCxcbiAgYWxsX3V0aW1lOiAwLFxuICBhbGxfc3RpbWU6IDAsXG4gIGxpc3Q6IHt9LFxuICBtczogMCxcbiAgcmVzdWx0OiB7fVxufTtcbmNvbnN0IF9zZXJ2aWNlc19jcHUgPSB7XG4gIGFsbDogMCxcbiAgYWxsX3V0aW1lOiAwLFxuICBhbGxfc3RpbWU6IDAsXG4gIGxpc3Q6IHt9LFxuICBtczogMCxcbiAgcmVzdWx0OiB7fVxufTtcbmNvbnN0IF9wcm9jZXNzX2NwdSA9IHtcbiAgYWxsOiAwLFxuICBhbGxfdXRpbWU6IDAsXG4gIGFsbF9zdGltZTogMCxcbiAgbGlzdDoge30sXG4gIG1zOiAwLFxuICByZXN1bHQ6IHt9XG59O1xuXG5jb25zdCBfd2luU3RhdHVzVmFsdWVzID0ge1xuICAnMCc6ICd1bmtub3duJyxcbiAgJzEnOiAnb3RoZXInLFxuICAnMic6ICdyZWFkeScsXG4gICczJzogJ3J1bm5pbmcnLFxuICAnNCc6ICdibG9ja2VkJyxcbiAgJzUnOiAnc3VzcGVuZGVkIGJsb2NrZWQnLFxuICAnNic6ICdzdXNwZW5kZWQgcmVhZHknLFxuICAnNyc6ICd0ZXJtaW5hdGVkJyxcbiAgJzgnOiAnc3RvcHBlZCcsXG4gICc5JzogJ2dyb3dpbmcnLFxufTtcblxuZnVuY3Rpb24gcGFyc2VUaW1lVW5peCh0aW1lKSB7XG4gIGxldCByZXN1bHQgPSB0aW1lO1xuICBsZXQgcGFydHMgPSB0aW1lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHJlc3VsdCA9IHBhcnRzWzRdICsgJy0nICsgKCcwJyArICgnSkFORkVCTUFSQVBSTUFZSlVOSlVMQVVHU0VQT0NUTk9WREVDJy5pbmRleE9mKHBhcnRzWzFdLnRvVXBwZXJDYXNlKCkpIC8gMyArIDEpKS5zbGljZSgtMikgKyAnLScgKyAoJzAnICsgcGFydHNbMl0pLnNsaWNlKC0yKSArICcgJyArIHBhcnRzWzNdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWxhcHNlZFRpbWUoZXRpbWUpIHtcbiAgbGV0IGN1cnJlbnQgPSBuZXcgRGF0ZSgpO1xuICBjdXJyZW50ID0gbmV3IERhdGUoY3VycmVudC5nZXRUaW1lKCkgLSBjdXJyZW50LmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCk7XG5cbiAgY29uc3QgZWxhcHNlZCA9IGV0aW1lLnNwbGl0KCctJyk7XG5cbiAgY29uc3QgdGltZUluZGV4ID0gZWxhcHNlZC5sZW5ndGggLSAxO1xuICBjb25zdCBkYXlzID0gdGltZUluZGV4ID4gMCA/IHBhcnNlSW50KGVsYXBzZWRbdGltZUluZGV4IC0gMV0pIDogMDtcblxuICBjb25zdCB0aW1lU3RyID0gZWxhcHNlZFt0aW1lSW5kZXhdLnNwbGl0KCc6Jyk7XG4gIGNvbnN0IGhvdXJzID0gdGltZVN0ci5sZW5ndGggPT09IDMgPyBwYXJzZUludCh0aW1lU3RyWzBdIHx8IDApIDogMDtcbiAgY29uc3QgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJbdGltZVN0ci5sZW5ndGggPT09IDMgPyAxIDogMF0gfHwgMCk7XG4gIGNvbnN0IHNlY3MgPSBwYXJzZUludCh0aW1lU3RyW3RpbWVTdHIubGVuZ3RoID09PSAzID8gMiA6IDFdIHx8IDApO1xuICBjb25zdCBtcyA9ICgoKCgoZGF5cyAqIDI0ICsgaG91cnMpICogNjApICsgbWlucykgKiA2MCArIHNlY3MpICogMTAwMCk7XG5cbiAgbGV0IHJlcyA9IG5ldyBEYXRlKGN1cnJlbnQuZ2V0VGltZSgpKTtcbiAgbGV0IHJlc3VsdCA9IHJlcy50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCkgKyAnICcgKyByZXMudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMTEsIDE5KTtcbiAgdHJ5IHtcbiAgICByZXMgPSBuZXcgRGF0ZShjdXJyZW50LmdldFRpbWUoKSAtIG1zKTtcbiAgICByZXN1bHQgPSByZXMudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApICsgJyAnICsgcmVzLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDExLCAxOSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB1dGlsLm5vb3AoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUFMgLSBzZXJ2aWNlc1xuLy8gcGFzcyBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgd2l0aCBzZXJ2aWNlcyB0byBjaGVjayAobXlzcWwsIGFwYWNoZSwgcG9zdGdyZXNxbCwgLi4uKVxuLy8gdGhpcyBmdW5jdGlvbiBnaXZlcyBhbiBhcnJheSBiYWNrLCBpZiB0aGUgc2VydmljZXMgYXJlIHJ1bm5pbmcuXG5cbmZ1bmN0aW9uIHNlcnZpY2VzKHNydiwgY2FsbGJhY2spIHtcblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihzcnYpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gc3J2O1xuICAgIHNydiA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNydiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKFtdKTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcnYpIHtcbiAgICAgICAgbGV0IHNydlN0cmluZyA9ICcnO1xuICAgICAgICBzcnZTdHJpbmcuX19wcm90b19fLnRvTG93ZXJDYXNlID0gdXRpbC5zdHJpbmdUb0xvd2VyO1xuICAgICAgICBzcnZTdHJpbmcuX19wcm90b19fLnJlcGxhY2UgPSB1dGlsLnN0cmluZ1JlcGxhY2U7XG4gICAgICAgIHNydlN0cmluZy5fX3Byb3RvX18udHJpbSA9IHV0aWwuc3RyaW5nVHJpbTtcblxuICAgICAgICBjb25zdCBzID0gdXRpbC5zYW5pdGl6ZVNoZWxsU3RyaW5nKHNydik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHV0aWwubWF0aE1pbihzLmxlbmd0aCwgMjAwMCk7IGkrKykge1xuICAgICAgICAgIGlmIChzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNydlN0cmluZyA9IHNydlN0cmluZyArIHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3J2U3RyaW5nID0gc3J2U3RyaW5nLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLywgL2csICd8JykucmVwbGFjZSgvLCsvZywgJ3wnKTtcbiAgICAgICAgaWYgKHNydlN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgICBzcnZTdHJpbmcgPSAnKic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpICYmIHNydlN0cmluZyAhPT0gJyonKSB7XG4gICAgICAgICAgc3J2U3RyaW5nID0gJy0tLS0tLSc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNydnMgPSBzcnZTdHJpbmcuc3BsaXQoJ3wnKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZGF0YVNydiA9IFtdO1xuXG4gICAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCB8fCBfZGFyd2luKSB7XG4gICAgICAgICAgaWYgKChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgJiYgc3J2U3RyaW5nID09PSAnKicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRtcHNydiA9IGV4ZWNTeW5jKCdzeXN0ZW1jdGwgLS1hbGwgLS10eXBlPXNlcnZpY2UgLS1uby1sZWdlbmQgMj4gL2Rldi9udWxsJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIHNydnMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRtcHNydikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzLnNwbGl0KCcuc2VydmljZScpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHMuaW5kZXhPZignIG5vdC1mb3VuZCAnKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNydnMucHVzaChuYW1lLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNydlN0cmluZyA9IHNydnMuam9pbignfCcpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNydlN0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcHNydiA9IGV4ZWNTeW5jKCdzZXJ2aWNlIC0tc3RhdHVzLWFsbCAyPiAvZGV2L251bGwnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdG1wc3J2KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHMuc3BsaXQoJ10nKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3J2U3RyaW5nICs9IChzcnZTdHJpbmcgIT09ICcnID8gJ3wnIDogJycpICsgcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcnZzID0gc3J2U3RyaW5nLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3J2U3RyID0gZXhlY1N5bmMoJ2xzIC9ldGMvaW5pdC5kLyAtbSAyPiAvZGV2L251bGwnKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgIHNydlN0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgaWYgKHNydlN0cikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXBzcnYgPSBzcnZTdHIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRtcHNydikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3J2U3RyaW5nICs9IChzcnZTdHJpbmcgIT09ICcnID8gJ3wnIDogJycpICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3J2cyA9IHNydlN0cmluZy5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgICAgICAgICAgIHNydlN0cmluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgc3J2cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKF9kYXJ3aW4pICYmIHNydlN0cmluZyA9PT0gJyonKSB7IC8vIHNlcnZpY2UgZW51bWVyYXRpb24gbm90IHlldCBzdXBvcnRlZCBvbiBtYWMgT1NcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBhcmdzID0gKF9kYXJ3aW4pID8gWyctY2F4bycsICdwY3B1LHBtZW0scGlkLGNvbW1hbmQnXSA6IFsnLWF4bycsICdwY3B1LHBtZW0scGlkLGNvbW1hbmQnXTtcbiAgICAgICAgICBpZiAoc3J2U3RyaW5nICE9PSAnJyAmJiBzcnZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BzJywgYXJncykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQucmVwbGFjZSgvICsvZywgJyAnKS5yZXBsYWNlKC8sKy9nLCAnLicpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBzcnZzLmZvckVhY2goZnVuY3Rpb24gKHNydikge1xuICAgICAgICAgICAgICAgICAgbGV0IHBzO1xuICAgICAgICAgICAgICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHMgPSBsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNydikgIT09IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignICcgKyBzcnYgKyAnOicpICE9PSAtMSkgfHwgKGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCcvJyArIHNydikgIT09IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb25zdCBwaWRzID0gW107XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGlkID0gcC50cmltKCkuc3BsaXQoJyAnKVsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBpZHMucHVzaChwYXJzZUludChwaWQsIDEwKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3J2LFxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBwcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGFydG1vZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwaWRzOiBwaWRzLFxuICAgICAgICAgICAgICAgICAgICBjcHU6IHBhcnNlRmxvYXQoKHBzLnJlZHVjZShmdW5jdGlvbiAocHYsIGN2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB2ICsgcGFyc2VGbG9hdChjdi50cmltKCkuc3BsaXQoJyAnKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApKS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICAgICAgICAgICAgbWVtOiBwYXJzZUZsb2F0KChwcy5yZWR1Y2UoZnVuY3Rpb24gKHB2LCBjdikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdiArIHBhcnNlRmxvYXQoY3YudHJpbSgpLnNwbGl0KCcgJylbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKSkudG9GaXhlZCgyKSlcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNhbGMgcHJvY2Vzc19jcHUgLSBwcyBpcyBub3QgYWNjdXJhdGUgaW4gbGludXghXG4gICAgICAgICAgICAgICAgICBsZXQgY21kID0gJ2NhdCAvcHJvYy9zdGF0IHwgZ3JlcCBcImNwdSBcIic7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqIGluIHJlc3VsdFtpXS5waWRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY21kICs9ICgnO2NhdCAvcHJvYy8nICsgcmVzdWx0W2ldLnBpZHNbal0gKyAnL3N0YXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJfcHJvY2Vzc2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgKGFsbCAtIC9wcm9jL3N0YXQpXG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGwgPSBwYXJzZVByb2NTdGF0KGN1cnJfcHJvY2Vzc2VzLnNoaWZ0KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RfbmV3ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRQcm9jZXNzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfcHJvY2Vzc2VzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9jZXNzID0gY2FsY1Byb2NTdGF0TGludXgoZWxlbWVudCwgYWxsLCBfc2VydmljZXNfY3B1KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRQcm9jZXNzLnBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gcmVzdWx0W2ldLnBpZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQocmVzdWx0W2ldLnBpZHNbal0pID09PSBwYXJzZUludChyZXN1bHRQcm9jZXNzLnBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RQb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10uY3B1ICs9IHJlc3VsdFByb2Nlc3MuY3B1dSArIHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0X25ld1tyZXN1bHRQcm9jZXNzLnBpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IHJlc3VsdFByb2Nlc3MuY3B1dSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3B1czogcmVzdWx0UHJvY2Vzcy5jcHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB1dGltZTogcmVzdWx0UHJvY2Vzcy51dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHJlc3VsdFByb2Nlc3Muc3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1dGltZTogcmVzdWx0UHJvY2Vzcy5jdXRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNzdGltZTogcmVzdWx0UHJvY2Vzcy5jc3RpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBvbGQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIF9zZXJ2aWNlc19jcHUuYWxsID0gYWxsO1xuICAgICAgICAgICAgICAgICAgICBfc2VydmljZXNfY3B1Lmxpc3QgPSBPYmplY3QuYXNzaWduKHt9LCBsaXN0X25ldyk7XG4gICAgICAgICAgICAgICAgICAgIF9zZXJ2aWNlc19jcHUubXMgPSBEYXRlLm5vdygpIC0gX3NlcnZpY2VzX2NwdS5tcztcbiAgICAgICAgICAgICAgICAgICAgX3NlcnZpY2VzX2NwdS5yZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFsnLW8nLCAnY29tbSddO1xuICAgICAgICAgICAgICAgIHV0aWwuZXhlY1NhZmUoJ3BzJywgYXJncykudGhlbigoc3Rkb3V0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC5yZXBsYWNlKC8gKy9nLCAnICcpLnJlcGxhY2UoLywrL2csICcuJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBzcnZzLmZvckVhY2goZnVuY3Rpb24gKHNydikge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBwcyA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuaW5kZXhPZihzcnYpICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBwcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbTogMFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3J2cy5mb3JFYWNoKGZ1bmN0aW9uIChzcnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnYsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgd2luY29tbWFuZCA9ICdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfU2VydmljZSc7XG4gICAgICAgICAgICBpZiAoc3J2c1swXSAhPT0gJyonKSB7XG4gICAgICAgICAgICAgIHdpbmNvbW1hbmQgKz0gJyAtRmlsdGVyIFwiJztcbiAgICAgICAgICAgICAgc3J2cy5mb3JFYWNoKChzcnYpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5jb21tYW5kICs9IGBOYW1lPScke3Nydn0nIG9yIGA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3aW5jb21tYW5kID0gYCR7d2luY29tbWFuZC5zbGljZSgwLCAtNCl9XCJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luY29tbWFuZCArPSAnIHwgc2VsZWN0IE5hbWUsQ2FwdGlvbixTdGFydGVkLFN0YXJ0TW9kZSxQcm9jZXNzSWQgfCBmbCc7XG4gICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwod2luY29tbWFuZCkudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcnZpY2VTZWN0aW9ucyA9IHN0ZG91dC5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgICAgIHNlcnZpY2VTZWN0aW9ucy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGVsZW1lbnQudHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNydk5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmFtZScsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNydkNhcHRpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FwdGlvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ZWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhcnRlZCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydE1vZGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU3RhcnRNb2RlJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9jZXNzSWQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3J2U3RyaW5nID09PSAnKicgfHwgc3J2cy5pbmRleE9mKHNydk5hbWUpID49IDAgfHwgc3J2cy5pbmRleE9mKHNydkNhcHRpb24pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnZOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZzogKHN0YXJ0ZWQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0bW9kZTogc3RhcnRNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGlkczogW3BpZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhU3J2LnB1c2goc3J2TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YVNydi5wdXNoKHNydkNhcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChzcnZTdHJpbmcgIT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgbGV0IHNydnNNaXNzaW5nID0gc3J2cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTcnYuaW5kZXhPZihlKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHNydnNNaXNzaW5nLmZvckVhY2goZnVuY3Rpb24gKHNydk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNydk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICBwaWRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNydnMuZm9yRWFjaChmdW5jdGlvbiAoc3J2TmFtZSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzcnZOYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRtb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgY3B1OiAwLFxuICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKFtdKTsgfVxuICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuc2VydmljZXMgPSBzZXJ2aWNlcztcblxuZnVuY3Rpb24gcGFyc2VQcm9jU3RhdChsaW5lKSB7XG4gIGxldCBwYXJ0cyA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnICcpO1xuICBsZXQgdXNlciA9IChwYXJ0cy5sZW5ndGggPj0gMiA/IHBhcnNlSW50KHBhcnRzWzFdKSA6IDApO1xuICBsZXQgbmljZSA9IChwYXJ0cy5sZW5ndGggPj0gMyA/IHBhcnNlSW50KHBhcnRzWzJdKSA6IDApO1xuICBsZXQgc3lzdGVtID0gKHBhcnRzLmxlbmd0aCA+PSA0ID8gcGFyc2VJbnQocGFydHNbM10pIDogMCk7XG4gIGxldCBpZGxlID0gKHBhcnRzLmxlbmd0aCA+PSA1ID8gcGFyc2VJbnQocGFydHNbNF0pIDogMCk7XG4gIGxldCBpb3dhaXQgPSAocGFydHMubGVuZ3RoID49IDYgPyBwYXJzZUludChwYXJ0c1s1XSkgOiAwKTtcbiAgbGV0IGlycSA9IChwYXJ0cy5sZW5ndGggPj0gNyA/IHBhcnNlSW50KHBhcnRzWzZdKSA6IDApO1xuICBsZXQgc29mdGlycSA9IChwYXJ0cy5sZW5ndGggPj0gOCA/IHBhcnNlSW50KHBhcnRzWzddKSA6IDApO1xuICBsZXQgc3RlYWwgPSAocGFydHMubGVuZ3RoID49IDkgPyBwYXJzZUludChwYXJ0c1s4XSkgOiAwKTtcbiAgbGV0IGd1ZXN0ID0gKHBhcnRzLmxlbmd0aCA+PSAxMCA/IHBhcnNlSW50KHBhcnRzWzldKSA6IDApO1xuICBsZXQgZ3Vlc3RfbmljZSA9IChwYXJ0cy5sZW5ndGggPj0gMTEgPyBwYXJzZUludChwYXJ0c1sxMF0pIDogMCk7XG4gIHJldHVybiB1c2VyICsgbmljZSArIHN5c3RlbSArIGlkbGUgKyBpb3dhaXQgKyBpcnEgKyBzb2Z0aXJxICsgc3RlYWwgKyBndWVzdCArIGd1ZXN0X25pY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGNQcm9jU3RhdExpbnV4KGxpbmUsIGFsbCwgX2NwdV9vbGQpIHtcbiAgbGV0IHN0YXRwYXJ0cyA9IGxpbmUucmVwbGFjZSgvICsvZywgJyAnKS5zcGxpdCgnKScpO1xuICBpZiAoc3RhdHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgbGV0IHBhcnRzID0gc3RhdHBhcnRzWzFdLnNwbGl0KCcgJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAxNikge1xuICAgICAgbGV0IHBpZCA9IHBhcnNlSW50KHN0YXRwYXJ0c1swXS5zcGxpdCgnICcpWzBdKTtcbiAgICAgIGxldCB1dGltZSA9IHBhcnNlSW50KHBhcnRzWzEyXSk7XG4gICAgICBsZXQgc3RpbWUgPSBwYXJzZUludChwYXJ0c1sxM10pO1xuICAgICAgbGV0IGN1dGltZSA9IHBhcnNlSW50KHBhcnRzWzE0XSk7XG4gICAgICBsZXQgY3N0aW1lID0gcGFyc2VJbnQocGFydHNbMTVdKTtcblxuICAgICAgLy8gY2FsY1xuICAgICAgbGV0IGNwdXUgPSAwO1xuICAgICAgbGV0IGNwdXMgPSAwO1xuICAgICAgaWYgKF9jcHVfb2xkLmFsbCA+IDAgJiYgX2NwdV9vbGQubGlzdFtwaWRdKSB7XG4gICAgICAgIGNwdXUgPSAodXRpbWUgKyBjdXRpbWUgLSBfY3B1X29sZC5saXN0W3BpZF0udXRpbWUgLSBfY3B1X29sZC5saXN0W3BpZF0uY3V0aW1lKSAvIChhbGwgLSBfY3B1X29sZC5hbGwpICogMTAwOyAvLyB1c2VyXG4gICAgICAgIGNwdXMgPSAoc3RpbWUgKyBjc3RpbWUgLSBfY3B1X29sZC5saXN0W3BpZF0uc3RpbWUgLSBfY3B1X29sZC5saXN0W3BpZF0uY3N0aW1lKSAvIChhbGwgLSBfY3B1X29sZC5hbGwpICogMTAwOyAvLyBzeXN0ZW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNwdXUgPSAodXRpbWUgKyBjdXRpbWUpIC8gKGFsbCkgKiAxMDA7IC8vIHVzZXJcbiAgICAgICAgY3B1cyA9IChzdGltZSArIGNzdGltZSkgLyAoYWxsKSAqIDEwMDsgLy8gc3lzdGVtXG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaWQ6IHBpZCxcbiAgICAgICAgdXRpbWU6IHV0aW1lLFxuICAgICAgICBzdGltZTogc3RpbWUsXG4gICAgICAgIGN1dGltZTogY3V0aW1lLFxuICAgICAgICBjc3RpbWU6IGNzdGltZSxcbiAgICAgICAgY3B1dTogY3B1dSxcbiAgICAgICAgY3B1czogY3B1c1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGlkOiAwLFxuICAgICAgICB1dGltZTogMCxcbiAgICAgICAgc3RpbWU6IDAsXG4gICAgICAgIGN1dGltZTogMCxcbiAgICAgICAgY3N0aW1lOiAwLFxuICAgICAgICBjcHV1OiAwLFxuICAgICAgICBjcHVzOiAwXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGlkOiAwLFxuICAgICAgdXRpbWU6IDAsXG4gICAgICBzdGltZTogMCxcbiAgICAgIGN1dGltZTogMCxcbiAgICAgIGNzdGltZTogMCxcbiAgICAgIGNwdXU6IDAsXG4gICAgICBjcHVzOiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjUHJvY1N0YXRXaW4ocHJvY1N0YXQsIGFsbCwgX2NwdV9vbGQpIHtcbiAgLy8gY2FsY1xuICBsZXQgY3B1dSA9IDA7XG4gIGxldCBjcHVzID0gMDtcbiAgaWYgKF9jcHVfb2xkLmFsbCA+IDAgJiYgX2NwdV9vbGQubGlzdFtwcm9jU3RhdC5waWRdKSB7XG4gICAgY3B1dSA9IChwcm9jU3RhdC51dGltZSAtIF9jcHVfb2xkLmxpc3RbcHJvY1N0YXQucGlkXS51dGltZSkgLyAoYWxsIC0gX2NwdV9vbGQuYWxsKSAqIDEwMDsgLy8gdXNlclxuICAgIGNwdXMgPSAocHJvY1N0YXQuc3RpbWUgLSBfY3B1X29sZC5saXN0W3Byb2NTdGF0LnBpZF0uc3RpbWUpIC8gKGFsbCAtIF9jcHVfb2xkLmFsbCkgKiAxMDA7IC8vIHN5c3RlbVxuICB9IGVsc2Uge1xuICAgIGNwdXUgPSAocHJvY1N0YXQudXRpbWUpIC8gKGFsbCkgKiAxMDA7IC8vIHVzZXJcbiAgICBjcHVzID0gKHByb2NTdGF0LnN0aW1lKSAvIChhbGwpICogMTAwOyAvLyBzeXN0ZW1cbiAgfVxuICByZXR1cm4ge1xuICAgIHBpZDogcHJvY1N0YXQucGlkLFxuICAgIHV0aW1lOiBwcm9jU3RhdC51dGltZSxcbiAgICBzdGltZTogcHJvY1N0YXQuc3RpbWUsXG4gICAgY3B1dTogY3B1dSA+IDAgPyBjcHV1IDogMCxcbiAgICBjcHVzOiBjcHVzID4gMCA/IGNwdXMgOiAwXG4gIH07XG59XG5cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcnVubmluZyBwcm9jZXNzZXNcblxuZnVuY3Rpb24gcHJvY2Vzc2VzKGNhbGxiYWNrKSB7XG5cbiAgbGV0IHBhcnNlZGhlYWQgPSBbXTtcblxuICBmdW5jdGlvbiBnZXROYW1lKGNvbW1hbmQpIHtcbiAgICBjb21tYW5kID0gY29tbWFuZCB8fCAnJztcbiAgICBsZXQgcmVzdWx0ID0gY29tbWFuZC5zcGxpdCgnICcpWzBdO1xuICAgIGlmIChyZXN1bHQuc3Vic3RyKC0xKSA9PT0gJzonKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyKDAsIHJlc3VsdC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5zdWJzdHIoMCwgMSkgIT09ICdbJykge1xuICAgICAgbGV0IHBhcnRzID0gcmVzdWx0LnNwbGl0KCcvJyk7XG4gICAgICBpZiAoaXNOYU4ocGFyc2VJbnQocGFydHNbcGFydHMubGVuZ3RoIC0gMV0pKSkge1xuICAgICAgICByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmUpIHtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBvZmZzZXQyID0gMDtcblxuICAgIGZ1bmN0aW9uIGNoZWNrQ29sdW1uKGkpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldDI7XG4gICAgICBpZiAocGFyc2VkaGVhZFtpXSkge1xuICAgICAgICBvZmZzZXQyID0gbGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFtpXS50byArIG9mZnNldCwgMTAwMDApLmluZGV4T2YoJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldDIgPSAxMDAwMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0NvbHVtbigwKTtcbiAgICBjb25zdCBwaWQgPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzBdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMF0udG8gKyBvZmZzZXQyKSk7XG4gICAgY2hlY2tDb2x1bW4oMSk7XG4gICAgY29uc3QgcHBpZCA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMV0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFsxXS50byArIG9mZnNldDIpKTtcbiAgICBjaGVja0NvbHVtbigyKTtcbiAgICBjb25zdCBjcHUgPSBwYXJzZUZsb2F0KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMl0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFsyXS50byArIG9mZnNldDIpLnJlcGxhY2UoLywvZywgJy4nKSk7XG4gICAgY2hlY2tDb2x1bW4oMyk7XG4gICAgY29uc3QgbWVtID0gcGFyc2VGbG9hdChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzNdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbM10udG8gKyBvZmZzZXQyKS5yZXBsYWNlKC8sL2csICcuJykpO1xuICAgIGNoZWNrQ29sdW1uKDQpO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcGFyc2VJbnQobGluZS5zdWJzdHJpbmcocGFyc2VkaGVhZFs0XS5mcm9tICsgb2Zmc2V0LCBwYXJzZWRoZWFkWzRdLnRvICsgb2Zmc2V0MikpO1xuICAgIGNoZWNrQ29sdW1uKDUpO1xuICAgIGNvbnN0IHZzeiA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbNV0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs1XS50byArIG9mZnNldDIpKTtcbiAgICBjaGVja0NvbHVtbig2KTtcbiAgICBjb25zdCByc3MgPSBwYXJzZUludChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzZdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbNl0udG8gKyBvZmZzZXQyKSk7XG4gICAgY2hlY2tDb2x1bW4oNyk7XG4gICAgY29uc3QgbmljZSA9IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbN10uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs3XS50byArIG9mZnNldDIpKSB8fCAwO1xuICAgIGNoZWNrQ29sdW1uKDgpO1xuICAgIGNvbnN0IHN0YXJ0ZWQgPSAhX3N1bm9zID8gcGFyc2VFbGFwc2VkVGltZShsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzhdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbOF0udG8gKyBvZmZzZXQyKS50cmltKCkpIDogcGFyc2VUaW1lVW5peChsaW5lLnN1YnN0cmluZyhwYXJzZWRoZWFkWzhdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbOF0udG8gKyBvZmZzZXQyKS50cmltKCkpO1xuICAgIGNoZWNrQ29sdW1uKDkpO1xuICAgIGxldCBzdGF0ZSA9IGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbOV0uZnJvbSArIG9mZnNldCwgcGFyc2VkaGVhZFs5XS50byArIG9mZnNldDIpLnRyaW0oKTtcbiAgICBzdGF0ZSA9IChzdGF0ZVswXSA9PT0gJ1InID8gJ3J1bm5pbmcnIDogKHN0YXRlWzBdID09PSAnUycgPyAnc2xlZXBpbmcnIDogKHN0YXRlWzBdID09PSAnVCcgPyAnc3RvcHBlZCcgOiAoc3RhdGVbMF0gPT09ICdXJyA/ICdwYWdpbmcnIDogKHN0YXRlWzBdID09PSAnWCcgPyAnZGVhZCcgOiAoc3RhdGVbMF0gPT09ICdaJyA/ICd6b21iaWUnIDogKChzdGF0ZVswXSA9PT0gJ0QnIHx8IHN0YXRlWzBdID09PSAnVScpID8gJ2Jsb2NrZWQnIDogJ3Vua25vd24nKSkpKSkpKTtcbiAgICBjaGVja0NvbHVtbigxMCk7XG4gICAgbGV0IHR0eSA9IGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMTBdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMTBdLnRvICsgb2Zmc2V0MikudHJpbSgpO1xuICAgIGlmICh0dHkgPT09ICc/JyB8fCB0dHkgPT09ICc/PycpIHsgdHR5ID0gJyc7IH1cbiAgICBjaGVja0NvbHVtbigxMSk7XG4gICAgY29uc3QgdXNlciA9IGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMTFdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMTFdLnRvICsgb2Zmc2V0MikudHJpbSgpO1xuICAgIGNoZWNrQ29sdW1uKDEyKTtcbiAgICBsZXQgY21kUGF0aCA9ICcnO1xuICAgIGxldCBjb21tYW5kID0gJyc7XG4gICAgbGV0IHBhcmFtcyA9ICcnO1xuICAgIGxldCBmdWxsY29tbWFuZCA9IGxpbmUuc3Vic3RyaW5nKHBhcnNlZGhlYWRbMTJdLmZyb20gKyBvZmZzZXQsIHBhcnNlZGhlYWRbMTJdLnRvICsgb2Zmc2V0MikudHJpbSgpO1xuICAgIGlmIChmdWxsY29tbWFuZC5zdWJzdHIoZnVsbGNvbW1hbmQubGVuZ3RoIC0gMSkgPT09ICddJykgeyBmdWxsY29tbWFuZCA9IGZ1bGxjb21tYW5kLnNsaWNlKDAsIC0xKTsgfVxuICAgIGlmIChmdWxsY29tbWFuZC5zdWJzdHIoMCwgMSkgPT09ICdbJykgeyBjb21tYW5kID0gZnVsbGNvbW1hbmQuc3Vic3RyaW5nKDEpOyB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBwMSA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJygnKTtcbiAgICAgIGNvbnN0IHAyID0gZnVsbGNvbW1hbmQuaW5kZXhPZignKScpO1xuICAgICAgY29uc3QgcDMgPSBmdWxsY29tbWFuZC5pbmRleE9mKCcvJyk7XG4gICAgICBjb25zdCBwNCA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJzonKTtcbiAgICAgIGlmIChwMSA8IHAyICYmIHAxIDwgcDMgJiYgcDMgPCBwMikge1xuICAgICAgICBjb21tYW5kID0gZnVsbGNvbW1hbmQuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmQucmVwbGFjZSgvOi9nLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocDQgPiAwICYmIChwMyA9PT0gLTEgfHwgcDMgPiAzKSkge1xuICAgICAgICAgIGNvbW1hbmQgPSBmdWxsY29tbWFuZC5zcGxpdCgnICcpWzBdO1xuICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kLnJlcGxhY2UoLzovZywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyeSB0byBmaWd1cmUgb3V0IHdoZXJlIHBhcmFtZXRlciBzdGFydHNcbiAgICAgICAgICBsZXQgZmlyc3RQYXJhbVBvcyA9IGZ1bGxjb21tYW5kLmluZGV4T2YoJyAtJyk7XG4gICAgICAgICAgbGV0IGZpcnN0UGFyYW1QYXRoUG9zID0gZnVsbGNvbW1hbmQuaW5kZXhPZignIC8nKTtcbiAgICAgICAgICBmaXJzdFBhcmFtUG9zID0gKGZpcnN0UGFyYW1Qb3MgPj0gMCA/IGZpcnN0UGFyYW1Qb3MgOiAxMDAwMCk7XG4gICAgICAgICAgZmlyc3RQYXJhbVBhdGhQb3MgPSAoZmlyc3RQYXJhbVBhdGhQb3MgPj0gMCA/IGZpcnN0UGFyYW1QYXRoUG9zIDogMTAwMDApO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UG9zID0gTWF0aC5taW4oZmlyc3RQYXJhbVBvcywgZmlyc3RQYXJhbVBhdGhQb3MpO1xuICAgICAgICAgIGxldCB0bXBDb21tYW5kID0gZnVsbGNvbW1hbmQuc3Vic3RyKDAsIGZpcnN0UG9zKTtcbiAgICAgICAgICBjb25zdCB0bXBQYXJhbXMgPSBmdWxsY29tbWFuZC5zdWJzdHIoZmlyc3RQb3MpO1xuICAgICAgICAgIGNvbnN0IGxhc3RTbGFzaFBvcyA9IHRtcENvbW1hbmQubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICBpZiAobGFzdFNsYXNoUG9zID49IDApIHtcbiAgICAgICAgICAgIGNtZFBhdGggPSB0bXBDb21tYW5kLnN1YnN0cigwLCBsYXN0U2xhc2hQb3MpO1xuICAgICAgICAgICAgdG1wQ29tbWFuZCA9IHRtcENvbW1hbmQuc3Vic3RyKGxhc3RTbGFzaFBvcyArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFBvcyA9PT0gMTAwMDAgJiYgdG1wQ29tbWFuZC5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0bXBDb21tYW5kLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oY21kUGF0aCwgcGFydHNbMF0pKSkge1xuICAgICAgICAgICAgICBjb21tYW5kID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgcGFyYW1zID0gKHBhcnRzLmpvaW4oJyAnKSArICcgJyArIHRtcFBhcmFtcykudHJpbSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IHRtcENvbW1hbmQudHJpbSgpO1xuICAgICAgICAgICAgICBwYXJhbXMgPSB0bXBQYXJhbXMudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tYW5kID0gdG1wQ29tbWFuZC50cmltKCk7XG4gICAgICAgICAgICBwYXJhbXMgPSB0bXBQYXJhbXMudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICBwaWQ6IHBpZCxcbiAgICAgIHBhcmVudFBpZDogcHBpZCxcbiAgICAgIG5hbWU6IF9saW51eCA/IGdldE5hbWUoY29tbWFuZCkgOiBjb21tYW5kLFxuICAgICAgY3B1OiBjcHUsXG4gICAgICBjcHV1OiAwLFxuICAgICAgY3B1czogMCxcbiAgICAgIG1lbTogbWVtLFxuICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgbWVtVnN6OiB2c3osXG4gICAgICBtZW1Sc3M6IHJzcyxcbiAgICAgIG5pY2U6IG5pY2UsXG4gICAgICBzdGFydGVkOiBzdGFydGVkLFxuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgdHR5OiB0dHksXG4gICAgICB1c2VyOiB1c2VyLFxuICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgcGF0aDogY21kUGF0aFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9jZXNzZXMobGluZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBoZWFkID0gbGluZXNbMF07XG4gICAgICBwYXJzZWRoZWFkID0gdXRpbC5wYXJzZUhlYWQoaGVhZCwgOCk7XG4gICAgICBsaW5lcy5zaGlmdCgpO1xuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VMaW5lKGxpbmUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VQcm9jZXNzZXMyKGxpbmVzKSB7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXREYXRlVGltZSh0aW1lKSB7XG4gICAgICBjb25zdCBtb250aCA9ICgnMCcgKyAodGltZS5nZXRNb250aCgpICsgMSkudG9TdHJpbmcoKSkuc2xpY2UoLTIpO1xuICAgICAgY29uc3QgeWVhciA9IHRpbWUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgY29uc3QgZGF5ID0gKCcwJyArIHRpbWUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgIGNvbnN0IGhvdXJzID0gKCcwJyArIHRpbWUuZ2V0SG91cnMoKS50b1N0cmluZygpKS5zbGljZSgtMik7XG4gICAgICBjb25zdCBtaW5zID0gKCcwJyArIHRpbWUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgIGNvbnN0IHNlY3MgPSAoJzAnICsgdGltZS5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSkuc2xpY2UoLTIpO1xuXG4gICAgICByZXR1cm4gKHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheSArICcgJyArIGhvdXJzICsgJzonICsgbWlucyArICc6JyArIHNlY3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRWxhcHNlZChldGltZSkge1xuICAgICAgbGV0IHN0YXJ0ZWQgPSAnJztcbiAgICAgIGlmIChldGltZS5pbmRleE9mKCdkJykgPj0gMCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkX3BhcnRzID0gZXRpbWUuc3BsaXQoJ2QnKTtcbiAgICAgICAgc3RhcnRlZCA9IGZvcm1hdERhdGVUaW1lKG5ldyBEYXRlKERhdGUubm93KCkgLSAoZWxhcHNlZF9wYXJ0c1swXSAqIDI0ICsgZWxhcHNlZF9wYXJ0c1sxXSAqIDEpICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgIH0gZWxzZSBpZiAoZXRpbWUuaW5kZXhPZignaCcpID49IDApIHtcbiAgICAgICAgY29uc3QgZWxhcHNlZF9wYXJ0cyA9IGV0aW1lLnNwbGl0KCdoJyk7XG4gICAgICAgIHN0YXJ0ZWQgPSBmb3JtYXREYXRlVGltZShuZXcgRGF0ZShEYXRlLm5vdygpIC0gKGVsYXBzZWRfcGFydHNbMF0gKiA2MCArIGVsYXBzZWRfcGFydHNbMV0gKiAxKSAqIDYwICogMTAwMCkpO1xuICAgICAgfSBlbHNlIGlmIChldGltZS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkX3BhcnRzID0gZXRpbWUuc3BsaXQoJzonKTtcbiAgICAgICAgc3RhcnRlZCA9IGZvcm1hdERhdGVUaW1lKG5ldyBEYXRlKERhdGUubm93KCkgLSAoZWxhcHNlZF9wYXJ0cy5sZW5ndGggPiAxID8gKGVsYXBzZWRfcGFydHNbMF0gKiA2MCArIGVsYXBzZWRfcGFydHNbMV0pICogMTAwMCA6IGVsYXBzZWRfcGFydHNbMF0gKiAxMDAwKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0ZWQ7XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpLnJlcGxhY2UoLyArL2csICcgJykucmVwbGFjZSgvLCsvZywgJy4nKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBwYXJ0cy5zbGljZSg5KS5qb2luKCcgJyk7XG4gICAgICAgIGNvbnN0IHBtZW0gPSBwYXJzZUZsb2F0KCgxLjAgKiBwYXJzZUludChwYXJ0c1szXSkgKiAxMDI0IC8gb3MudG90YWxtZW0oKSkudG9GaXhlZCgxKSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBwYXJzZUVsYXBzZWQocGFydHNbNV0pO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBwaWQ6IHBhcnNlSW50KHBhcnRzWzBdKSxcbiAgICAgICAgICBwYXJlbnRQaWQ6IHBhcnNlSW50KHBhcnRzWzFdKSxcbiAgICAgICAgICBuYW1lOiBnZXROYW1lKGNvbW1hbmQpLFxuICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICBjcHV1OiAwLFxuICAgICAgICAgIGNwdXM6IDAsXG4gICAgICAgICAgbWVtOiBwbWVtLFxuICAgICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAgIG1lbVZzejogcGFyc2VJbnQocGFydHNbMl0pLFxuICAgICAgICAgIG1lbVJzczogcGFyc2VJbnQocGFydHNbM10pLFxuICAgICAgICAgIG5pY2U6IHBhcnNlSW50KHBhcnRzWzRdKSxcbiAgICAgICAgICBzdGFydGVkOiBzdGFydGVkLFxuICAgICAgICAgIHN0YXRlOiAocGFydHNbNl0gPT09ICdSJyA/ICdydW5uaW5nJyA6IChwYXJ0c1s2XSA9PT0gJ1MnID8gJ3NsZWVwaW5nJyA6IChwYXJ0c1s2XSA9PT0gJ1QnID8gJ3N0b3BwZWQnIDogKHBhcnRzWzZdID09PSAnVycgPyAncGFnaW5nJyA6IChwYXJ0c1s2XSA9PT0gJ1gnID8gJ2RlYWQnIDogKHBhcnRzWzZdID09PSAnWicgPyAnem9tYmllJyA6ICgocGFydHNbNl0gPT09ICdEJyB8fCBwYXJ0c1s2XSA9PT0gJ1UnKSA/ICdibG9ja2VkJyA6ICd1bmtub3duJykpKSkpKSksXG4gICAgICAgICAgdHR5OiBwYXJ0c1s3XSxcbiAgICAgICAgICB1c2VyOiBwYXJ0c1s4XSxcbiAgICAgICAgICBjb21tYW5kOiBjb21tYW5kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGFsbDogMCxcbiAgICAgICAgcnVubmluZzogMCxcbiAgICAgICAgYmxvY2tlZDogMCxcbiAgICAgICAgc2xlZXBpbmc6IDAsXG4gICAgICAgIHVua25vd246IDAsXG4gICAgICAgIGxpc3Q6IFtdXG4gICAgICB9O1xuXG4gICAgICBsZXQgY21kID0gJyc7XG5cbiAgICAgIGlmICgoX3Byb2Nlc3Nlc19jcHUubXMgJiYgRGF0ZS5ub3coKSAtIF9wcm9jZXNzZXNfY3B1Lm1zID49IDUwMCkgfHwgX3Byb2Nlc3Nlc19jcHUubXMgPT09IDApIHtcbiAgICAgICAgaWYgKF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkIHx8IF9kYXJ3aW4gfHwgX3N1bm9zKSB7XG4gICAgICAgICAgaWYgKF9saW51eCkgeyBjbWQgPSAnZXhwb3J0IExDX0FMTD1DOyBwcyAtYXhvIHBpZDoxMSxwcGlkOjExLHBjcHU6NixwbWVtOjYscHJpOjUsdnN6OjExLHJzczoxMSxuaTo1LGV0aW1lOjMwLHN0YXRlOjUsdHR5OjE1LHVzZXI6MjAsY29tbWFuZDsgdW5zZXQgTENfQUxMJzsgfVxuICAgICAgICAgIGlmIChfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7IGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IHBzIC1heG8gcGlkLHBwaWQscGNwdSxwbWVtLHByaSx2c3oscnNzLG5pLGV0aW1lLHN0YXRlLHR0eSx1c2VyLGNvbW1hbmQ7IHVuc2V0IExDX0FMTCc7IH1cbiAgICAgICAgICBpZiAoX2RhcndpbikgeyBjbWQgPSAncHMgLWF4byBwaWQscHBpZCxwY3B1LHBtZW0scHJpLHZzej10ZW1wX3RpdGxlXzEscnNzPXRlbXBfdGl0bGVfMixuaWNlLGV0aW1lPXRlbXBfdGl0bGVfMyxzdGF0ZSx0dHksdXNlcixjb21tYW5kIC1yJzsgfVxuICAgICAgICAgIGlmIChfc3Vub3MpIHsgY21kID0gJ3BzIC1BbyBwaWQscHBpZCxwY3B1LHBtZW0scHJpLHZzeixyc3MsbmljZSxzdGltZSxzLHR0eSx1c2VyLGNvbW0nOyB9XG4gICAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAgfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIGlmICghZXJyb3IgJiYgc3Rkb3V0LnRvU3RyaW5nKCkudHJpbSgpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5saXN0ID0gKHBhcnNlUHJvY2Vzc2VzKHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKSkpLnNsaWNlKCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5hbGwgPSByZXN1bHQubGlzdC5sZW5ndGg7XG4gICAgICAgICAgICAgIHJlc3VsdC5ydW5uaW5nID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdydW5uaW5nJztcbiAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICByZXN1bHQuYmxvY2tlZCA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAnYmxvY2tlZCc7XG4gICAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmVzdWx0LnNsZWVwaW5nID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RhdGUgPT09ICdzbGVlcGluZyc7XG4gICAgICAgICAgICAgIH0pLmxlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsYyBwcm9jZXNzX2NwdSAtIHBzIGlzIG5vdCBhY2N1cmF0ZSBpbiBsaW51eCFcbiAgICAgICAgICAgICAgICBjbWQgPSAnY2F0IC9wcm9jL3N0YXQgfCBncmVwIFwiY3B1IFwiJztcbiAgICAgICAgICAgICAgICByZXN1bHQubGlzdC5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjbWQgKz0gKCc7Y2F0IC9wcm9jLycgKyBlbGVtZW50LnBpZCArICcvc3RhdCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0sIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgY3Vycl9wcm9jZXNzZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgKGFsbCAtIC9wcm9jL3N0YXQpXG4gICAgICAgICAgICAgICAgICBsZXQgYWxsID0gcGFyc2VQcm9jU3RhdChjdXJyX3Byb2Nlc3Nlcy5zaGlmdCgpKTtcblxuICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgbGV0IGxpc3RfbmV3ID0ge307XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0UHJvY2VzcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgY3Vycl9wcm9jZXNzZXMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9jZXNzID0gY2FsY1Byb2NTdGF0TGludXgoZWxlbWVudCwgYWxsLCBfcHJvY2Vzc2VzX2NwdSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFByb2Nlc3MucGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwY3B1IGluIG91dGVyIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RQb3MgPSByZXN1bHQubGlzdC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucGlkOyB9KS5pbmRleE9mKHJlc3VsdFByb2Nlc3MucGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHUgPSByZXN1bHRQcm9jZXNzLmNwdXUgKyByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHV1ID0gcmVzdWx0UHJvY2Vzcy5jcHV1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1cyA9IHJlc3VsdFByb2Nlc3MuY3B1cztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICBsaXN0X25ld1tyZXN1bHRQcm9jZXNzLnBpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHV1OiByZXN1bHRQcm9jZXNzLmNwdXUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcHVzOiByZXN1bHRQcm9jZXNzLmNwdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGltZTogcmVzdWx0UHJvY2Vzcy51dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0aW1lOiByZXN1bHRQcm9jZXNzLnN0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0aW1lOiByZXN1bHRQcm9jZXNzLmN1dGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdGltZTogcmVzdWx0UHJvY2Vzcy5jc3RpbWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgb2xkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUuYWxsID0gYWxsO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUubGlzdCA9IE9iamVjdC5hc3NpZ24oe30sIGxpc3RfbmV3KTtcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1Lm1zID0gRGF0ZS5ub3coKSAtIF9wcm9jZXNzZXNfY3B1Lm1zO1xuICAgICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUucmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNtZCA9ICdwcyAtbyBwaWQscHBpZCx2c3oscnNzLG5pY2UsZXRpbWUsc3RhdCx0dHksdXNlcixjb21tJztcbiAgICAgICAgICAgICAgaWYgKF9zdW5vcykge1xuICAgICAgICAgICAgICAgIGNtZCA9ICdwcyAtbyBwaWQscHBpZCx2c3oscnNzLG5pY2UsZXRpbWUscyx0dHksdXNlcixjb21tJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgIGxpbmVzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5saXN0ID0gcGFyc2VQcm9jZXNzZXMyKGxpbmVzKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbCA9IHJlc3VsdC5saXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5ydW5uaW5nID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAncnVubmluZyc7XG4gICAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tlZCA9IHJlc3VsdC5saXN0LmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdGF0ZSA9PT0gJ2Jsb2NrZWQnO1xuICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnNsZWVwaW5nID0gcmVzdWx0Lmxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnN0YXRlID09PSAnc2xlZXBpbmcnO1xuICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX1Byb2Nlc3MgfCBzZWxlY3QtT2JqZWN0IFByb2Nlc3NJZCxQYXJlbnRQcm9jZXNzSWQsRXhlY3V0aW9uU3RhdGUsQ2FwdGlvbixDb21tYW5kTGluZSxFeGVjdXRhYmxlUGF0aCxVc2VyTW9kZVRpbWUsS2VybmVsTW9kZVRpbWUsV29ya2luZ1NldFNpemUsUHJpb3JpdHksUGFnZUZpbGVVc2FnZSwgQHtuPVwiQ3JlYXRpb25EYXRlXCI7ZT17JF8uQ3JlYXRpb25EYXRlLlRvU3RyaW5nKFwieXl5eS1NTS1kZCBISDptbTpzc1wiKX19IHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvY2Vzc1NlY3Rpb25zID0gc3Rkb3V0LnNwbGl0KC9cXG5cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgbGV0IHByb2NzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHByb2NTdGF0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0X25ldyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBhbGxjcHV1ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgYWxsY3B1cyA9IDA7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc1NlY3Rpb25zLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gZWxlbWVudC50cmltKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGlkID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1Byb2Nlc3NJZCcsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudFBpZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYXJlbnRQcm9jZXNzSWQnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXNWYWx1ZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdFeGVjdXRpb25TdGF0ZScsICc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZExpbmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29tbWFuZExpbmUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWRkaXRpb25hbCBjb21tYW5kIGxpbmUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaXRpb25hbENvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsQ29tbWFuZCAmJiBsaW5lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kTGluZSArPSAnICcgKyBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdjb21tYW5kbGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsQ29tbWFuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmRQYXRoID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0V4ZWN1dGFibGVQYXRoJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHV0aW1lID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1VzZXJNb2RlVGltZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0aW1lID0gcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ0tlcm5lbE1vZGVUaW1lJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVtdyA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdXb3JraW5nU2V0U2l6ZScsICc6JywgdHJ1ZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsY3B1dSA9IGFsbGNwdXUgKyB1dGltZTtcbiAgICAgICAgICAgICAgICAgICAgYWxsY3B1cyA9IGFsbGNwdXMgKyBzdGltZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFsbCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXR1c1ZhbHVlKSB7IHJlc3VsdC51bmtub3duKys7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c1ZhbHVlID09PSAnMycpIHsgcmVzdWx0LnJ1bm5pbmcrKzsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVmFsdWUgPT09ICc0JyB8fCBzdGF0dXNWYWx1ZSA9PT0gJzUnKSB7IHJlc3VsdC5ibG9ja2VkKys7IH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9jU3RhdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHV0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHN0aW1lOiBzdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1dTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50UGlkOiBwYXJlbnRQaWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1dTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbTogbWVtdyAvIG9zLnRvdGFsbWVtKCkgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcmlvcml0eScsICc6JywgdHJ1ZSksIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1Wc3o6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQYWdlRmlsZVVzYWdlJywgJzonLCB0cnVlKSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbVJzczogTWF0aC5mbG9vcihwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnV29ya2luZ1NldFNpemUnLCAnOicsIHRydWUpLCAxMCkgLyAxMDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICBuaWNlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDcmVhdGlvbkRhdGUnLCAnOicsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAoIXN0YXR1c1ZhbHVlID8gX3dpblN0YXR1c1ZhbHVlc1swXSA6IF93aW5TdGF0dXNWYWx1ZXNbc3RhdHVzVmFsdWVdKSxcbiAgICAgICAgICAgICAgICAgICAgICB0dHk6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgIHVzZXI6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmRMaW5lIHx8IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aDogY29tbWFuZFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5zbGVlcGluZyA9IHJlc3VsdC5hbGwgLSByZXN1bHQucnVubmluZyAtIHJlc3VsdC5ibG9ja2VkIC0gcmVzdWx0LnVua25vd247XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3QgPSBwcm9jcztcbiAgICAgICAgICAgICAgICBwcm9jU3RhdHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFByb2Nlc3MgPSBjYWxjUHJvY1N0YXRXaW4oZWxlbWVudCwgYWxsY3B1dSArIGFsbGNwdXMsIF9wcm9jZXNzZXNfY3B1KTtcblxuICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcGNwdSBpbiBvdXRlciBhcnJheVxuICAgICAgICAgICAgICAgICAgbGV0IGxpc3RQb3MgPSByZXN1bHQubGlzdC5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucGlkOyB9KS5pbmRleE9mKHJlc3VsdFByb2Nlc3MucGlkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsaXN0UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmxpc3RbbGlzdFBvc10uY3B1ID0gcmVzdWx0UHJvY2Vzcy5jcHV1ICsgcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHV1ID0gcmVzdWx0UHJvY2Vzcy5jcHV1O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubGlzdFtsaXN0UG9zXS5jcHVzID0gcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBzYXZlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIGxpc3RfbmV3W3Jlc3VsdFByb2Nlc3MucGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY3B1dTogcmVzdWx0UHJvY2Vzcy5jcHV1LFxuICAgICAgICAgICAgICAgICAgICBjcHVzOiByZXN1bHRQcm9jZXNzLmNwdXMsXG4gICAgICAgICAgICAgICAgICAgIHV0aW1lOiByZXN1bHRQcm9jZXNzLnV0aW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGltZTogcmVzdWx0UHJvY2Vzcy5zdGltZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9sZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5hbGwgPSBhbGxjcHV1ICsgYWxsY3B1cztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5hbGxfdXRpbWUgPSBhbGxjcHV1O1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzZXNfY3B1LmFsbF9zdGltZSA9IGFsbGNwdXM7XG4gICAgICAgICAgICAgICAgX3Byb2Nlc3Nlc19jcHUubGlzdCA9IE9iamVjdC5hc3NpZ24oe30sIGxpc3RfbmV3KTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5tcyA9IERhdGUubm93KCkgLSBfcHJvY2Vzc2VzX2NwdS5tcztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc2VzX2NwdS5yZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhfcHJvY2Vzc2VzX2NwdS5yZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUoX3Byb2Nlc3Nlc19jcHUucmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucHJvY2Vzc2VzID0gcHJvY2Vzc2VzO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUFMgLSBwcm9jZXNzIGxvYWRcbi8vIGdldCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBhIGNlcnRhaW4gcHJvY2Vzc1xuLy8gKFBJRCwgQ1BVLVVzYWdlICUsIE1lbS1Vc2FnZSAlKVxuXG5mdW5jdGlvbiBwcm9jZXNzTG9hZChwcm9jLCBjYWxsYmFjaykge1xuXG4gIC8vIGZhbGxiYWNrIC0gaWYgb25seSBjYWxsYmFjayBpcyBnaXZlblxuICBpZiAodXRpbC5pc0Z1bmN0aW9uKHByb2MpICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gcHJvYztcbiAgICBwcm9jID0gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgcHJvYyA9IHByb2MgfHwgJyc7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKFtdKTsgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcm9jZXNzZXNTdHJpbmcgPSAnJztcbiAgICAgIHByb2Nlc3Nlc1N0cmluZy5fX3Byb3RvX18udG9Mb3dlckNhc2UgPSB1dGlsLnN0cmluZ1RvTG93ZXI7XG4gICAgICBwcm9jZXNzZXNTdHJpbmcuX19wcm90b19fLnJlcGxhY2UgPSB1dGlsLnN0cmluZ1JlcGxhY2U7XG4gICAgICBwcm9jZXNzZXNTdHJpbmcuX19wcm90b19fLnRyaW0gPSB1dGlsLnN0cmluZ1RyaW07XG5cbiAgICAgIGNvbnN0IHMgPSB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcocHJvYyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSB1dGlsLm1hdGhNaW4ocy5sZW5ndGgsIDIwMDApOyBpKyspIHtcbiAgICAgICAgaWYgKHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb2Nlc3Nlc1N0cmluZyA9IHByb2Nlc3Nlc1N0cmluZyArIHNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc2VzU3RyaW5nID0gcHJvY2Vzc2VzU3RyaW5nLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLywgL2csICd8JykucmVwbGFjZSgvLCsvZywgJ3wnKTtcbiAgICAgIGlmIChwcm9jZXNzZXNTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgIHByb2Nlc3Nlc1N0cmluZyA9ICcqJztcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzUHJvdG90eXBlUG9sbHV0ZWQoKSAmJiBwcm9jZXNzZXNTdHJpbmcgIT09ICcqJykge1xuICAgICAgICBwcm9jZXNzZXNTdHJpbmcgPSAnLS0tLS0tJztcbiAgICAgIH1cbiAgICAgIGxldCBwcm9jZXNzZXMgPSBwcm9jZXNzZXNTdHJpbmcuc3BsaXQoJ3wnKTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgICAgY29uc3QgcHJvY1Nhbml0aXplZCA9IHV0aWwuaXNQcm90b3R5cGVQb2xsdXRlZCgpID8gJycgOiB1dGlsLnNhbml0aXplU2hlbGxTdHJpbmcocHJvYyk7XG5cbiAgICAgIC8vIGZyb20gaGVyZSBuZXdcbiAgICAgIC8vIGxldCByZXN1bHQgPSB7XG4gICAgICAvLyAgICdwcm9jJzogcHJvY1Nhbml0aXplZCxcbiAgICAgIC8vICAgJ3BpZCc6IG51bGwsXG4gICAgICAvLyAgICdjcHUnOiAwLFxuICAgICAgLy8gICAnbWVtJzogMFxuICAgICAgLy8gfTtcbiAgICAgIGlmIChwcm9jU2FuaXRpemVkICYmIHByb2Nlc3Nlcy5sZW5ndGggJiYgcHJvY2Vzc2VzWzBdICE9PSAnLS0tLS0tJykge1xuICAgICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUHJvY2VzcyB8IHNlbGVjdCBQcm9jZXNzSWQsQ2FwdGlvbixVc2VyTW9kZVRpbWUsS2VybmVsTW9kZVRpbWUsV29ya2luZ1NldFNpemUgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzU2VjdGlvbnMgPSBzdGRvdXQuc3BsaXQoL1xcblxccypcXG4vKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvY1N0YXRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RfbmV3ID0ge307XG4gICAgICAgICAgICAgICAgbGV0IGFsbGNwdXUgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBhbGxjcHVzID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgIHByb2Nlc3NTZWN0aW9ucy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lcyA9IGVsZW1lbnQudHJpbSgpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZCA9IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdQcm9jZXNzSWQnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NhcHRpb24nLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXRpbWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnVXNlck1vZGVUaW1lJywgJzonLCB0cnVlKSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RpbWUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnS2VybmVsTW9kZVRpbWUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtZW0gPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnV29ya2luZ1NldFNpemUnLCAnOicsIHRydWUpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGFsbGNwdXUgPSBhbGxjcHV1ICsgdXRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGFsbGNwdXMgPSBhbGxjcHVzICsgc3RpbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY1N0YXRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHBpZDogcGlkLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHV0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHN0aW1lOiBzdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY3B1dTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjcHVzOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIG1lbVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VzLmZvckVhY2goZnVuY3Rpb24gKHByb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJvYy50b0xvd2VyQ2FzZSgpKSA+PSAwICYmICFpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbmFtZSA9IHByb2M7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VzU3RyaW5nID09PSAnKicgfHwgaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2Nlc3NGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcm9jLnRvTG93ZXJDYXNlKCkgPT09IHBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5waWRzLnB1c2gocGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5tZW0gKz0gbWVtIC8gb3MudG90YWxtZW0oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jOiBwbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBpZHM6IFtwaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjcHU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lbTogbWVtIC8gb3MudG90YWxtZW0oKSAqIDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbWlzc2luZyBwcm9jZXNzZXNcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VzU3RyaW5nICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzZXNNaXNzaW5nID0gcHJvY2Vzc2VzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY1N0YXRzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihuYW1lKSA+PSAwOyB9KS5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VzTWlzc2luZy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9jTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgcHJvYzogcHJvY05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHBpZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW06IDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcHJvYyBzdGF0cyBmb3IgZWFjaCBwcm9jXG4gICAgICAgICAgICAgICAgcHJvY1N0YXRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRQcm9jZXNzID0gY2FsY1Byb2NTdGF0V2luKGVsZW1lbnQsIGFsbGNwdXUgKyBhbGxjcHVzLCBfcHJvY2Vzc19jcHUpO1xuXG4gICAgICAgICAgICAgICAgICBsZXQgbGlzdFBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtqXS5waWQgPT09IHJlc3VsdFByb2Nlc3MucGlkIHx8IHJlc3VsdFtqXS5waWRzLmluZGV4T2YocmVzdWx0UHJvY2Vzcy5waWQpID49IDApIHsgbGlzdFBvcyA9IGo7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChsaXN0UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLmNwdSArPSByZXN1bHRQcm9jZXNzLmNwdXUgKyByZXN1bHRQcm9jZXNzLmNwdXM7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgbGlzdF9uZXdbcmVzdWx0UHJvY2Vzcy5waWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBjcHV1OiByZXN1bHRQcm9jZXNzLmNwdXUsXG4gICAgICAgICAgICAgICAgICAgIGNwdXM6IHJlc3VsdFByb2Nlc3MuY3B1cyxcbiAgICAgICAgICAgICAgICAgICAgdXRpbWU6IHJlc3VsdFByb2Nlc3MudXRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHN0aW1lOiByZXN1bHRQcm9jZXNzLnN0aW1lXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgb2xkIHZhbHVlc1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5hbGwgPSBhbGxjcHV1ICsgYWxsY3B1cztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUuYWxsX3V0aW1lID0gYWxsY3B1dTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUuYWxsX3N0aW1lID0gYWxsY3B1cztcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUubGlzdCA9IE9iamVjdC5hc3NpZ24oe30sIGxpc3RfbmV3KTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUubXMgPSBEYXRlLm5vdygpIC0gX3Byb2Nlc3NfY3B1Lm1zO1xuICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5yZXN1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfZGFyd2luIHx8IF9saW51eCB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gWyctYXhvJywgJ3BpZCxwcGlkLHBjcHUscG1lbSxjb21tJ107XG4gICAgICAgICAgdXRpbC5leGVjU2FmZSgncHMnLCBwYXJhbXMpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICAgICAgICBsZXQgcHJvY1N0YXRzID0gW107XG4gICAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VzU3RyaW5nID09PSAnKicpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgICAgICBpZiAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2dyZXAnKSAhPT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIHJlbW92ZSB0aGlzPz9cbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgZm91bmQgPSBmb3VuZCB8fCAobGluZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoaXRlbS50b0xvd2VyQ2FzZSgpKSA+PSAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGxpbmUudHJpbSgpLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgICBwcm9jU3RhdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGFbNF0uc3Vic3RyaW5nKGRhdGFbNF0ubGFzdEluZGV4T2YoJy8nKSArIDEpLFxuICAgICAgICAgICAgICAgICAgICBwaWQ6IHBhcnNlSW50KGRhdGFbMF0pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHBwaWQ6IHBhcnNlSW50KGRhdGFbMV0pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGNwdTogcGFyc2VGbG9hdChkYXRhWzJdLnJlcGxhY2UoJywnLCAnLicpKSxcbiAgICAgICAgICAgICAgICAgICAgbWVtOiBwYXJzZUZsb2F0KGRhdGFbM10ucmVwbGFjZSgnLCcsICcuJykpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHByb2NTdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocmVzdWx0W2pdLnByb2MudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0UG9zID0gajtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VzLmZvckVhY2goZnVuY3Rpb24gKHByb2MpIHtcblxuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJvYy50b0xvd2VyQ2FzZSgpKSA+PSAwICYmICFpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHByb2M7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzZXNTdHJpbmcgPT09ICcqJykgfHwgaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGlzdFBvcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHByb2M6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgcGlkOiBpdGVtLnBpZCxcbiAgICAgICAgICAgICAgICAgICAgICBwaWRzOiBbaXRlbS5waWRdLFxuICAgICAgICAgICAgICAgICAgICAgIGNwdTogaXRlbS5jcHUsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtOiBpdGVtLm1lbVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnBwaWQgPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtsaXN0UG9zXS5waWQgPSBpdGVtLnBpZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGlzdFBvc10ucGlkcy5wdXNoKGl0ZW0ucGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLmNwdSArPSBpdGVtLmNwdTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xpc3RQb3NdLm1lbSArPSBpdGVtLm1lbTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzZXNTdHJpbmcgIT09ICcqJykge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBtaXNzaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgIGxldCBwcm9jZXNzZXNNaXNzaW5nID0gcHJvY2Vzc2VzLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2NTdGF0cy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YobmFtZSkgPj0gMDsgfSkubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHByb2Nlc3Nlc01pc3NpbmcuZm9yRWFjaChmdW5jdGlvbiAocHJvY05hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvYzogcHJvY05hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBpZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGlkczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNwdTogMCxcbiAgICAgICAgICAgICAgICAgICAgbWVtOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsYyBwcm9jZXNzX2NwdSAtIHBzIGlzIG5vdCBhY2N1cmF0ZSBpbiBsaW51eCFcbiAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgaXRlbS5jcHUgPSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBjbWQgPSAnY2F0IC9wcm9jL3N0YXQgfCBncmVwIFwiY3B1IFwiJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiBpbiByZXN1bHRbaV0ucGlkcykge1xuICAgICAgICAgICAgICAgICAgICBjbWQgKz0gKCc7Y2F0IC9wcm9jLycgKyByZXN1bHRbaV0ucGlkc1tqXSArICcvc3RhdCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgbGV0IGN1cnJfcHJvY2Vzc2VzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBmaXJzdCBsaW5lIChhbGwgLSAvcHJvYy9zdGF0KVxuICAgICAgICAgICAgICAgICAgbGV0IGFsbCA9IHBhcnNlUHJvY1N0YXQoY3Vycl9wcm9jZXNzZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgIGxldCBsaXN0X25ldyA9IHt9O1xuICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFByb2Nlc3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgIGN1cnJfcHJvY2Vzc2VzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvY2VzcyA9IGNhbGNQcm9jU3RhdExpbnV4KGVsZW1lbnQsIGFsbCwgX3Byb2Nlc3NfY3B1KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0UHJvY2Vzcy5waWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgcmVzdWx0IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0SXRlbUlkID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0ucGlkcy5pbmRleE9mKHJlc3VsdFByb2Nlc3MucGlkKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdEl0ZW1JZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHBjcHUgaW4gb3V0ZXIgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdEl0ZW1JZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0SXRlbUlkXS5jcHUgKz0gcmVzdWx0UHJvY2Vzcy5jcHV1ICsgcmVzdWx0UHJvY2Vzcy5jcHVzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgbmV3IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgIGxpc3RfbmV3W3Jlc3VsdFByb2Nlc3MucGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdXU6IHJlc3VsdFByb2Nlc3MuY3B1dSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwdXM6IHJlc3VsdFByb2Nlc3MuY3B1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aW1lOiByZXN1bHRQcm9jZXNzLnV0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RpbWU6IHJlc3VsdFByb2Nlc3Muc3RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRpbWU6IHJlc3VsdFByb2Nlc3MuY3V0aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3N0aW1lOiByZXN1bHRQcm9jZXNzLmNzdGltZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNwdSA9IE1hdGgucm91bmQoaXRlbS5jcHUgKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5hbGwgPSBhbGw7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUubGlzdCA9IE9iamVjdC5hc3NpZ24oe30sIGxpc3RfbmV3KTtcbiAgICAgICAgICAgICAgICAgIF9wcm9jZXNzX2NwdS5tcyA9IERhdGUubm93KCkgLSBfcHJvY2Vzc19jcHUubXM7XG4gICAgICAgICAgICAgICAgICBfcHJvY2Vzc19jcHUucmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0cy5wcm9jZXNzTG9hZCA9IHByb2Nlc3NMb2FkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBzeXN0ZW0uanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAyLiBTeXN0ZW0gKEhhcmR3YXJlLCBCSU9TLCBCYXNlIEJvYXJkKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IGV4ZWNQcm9taXNlID0gdXRpbC5wcm9taXNpZnkocmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMpO1xuXG5sZXQgX3BsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybTtcblxuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5jb25zdCBfc3Vub3MgPSAoX3BsYXRmb3JtID09PSAnc3Vub3MnKTtcblxuZnVuY3Rpb24gc3lzdGVtKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIG1hbnVmYWN0dXJlcjogJycsXG4gICAgICAgIG1vZGVsOiAnQ29tcHV0ZXInLFxuICAgICAgICB2ZXJzaW9uOiAnJyxcbiAgICAgICAgc2VyaWFsOiAnLScsXG4gICAgICAgIHV1aWQ6ICctJyxcbiAgICAgICAgc2t1OiAnLScsXG4gICAgICAgIHZpcnR1YWw6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgZXhlYygnZXhwb3J0IExDX0FMTD1DOyBkbWlkZWNvZGUgLXQgc3lzdGVtIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicpO1xuICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0IG5hbWUnKTtcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJyk7XG4gICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWwgbnVtYmVyJyk7XG4gICAgICAgICAgcmVzdWx0LnV1aWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndXVpZCcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmVzdWx0LnNrdSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdza3UgbnVtYmVyJyk7XG4gICAgICAgICAgLy8gTm9uLVJvb3QgdmFsdWVzXG4gICAgICAgICAgY29uc3QgY21kID0gYGVjaG8gLW4gXCJwcm9kdWN0X25hbWU6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL3Byb2R1Y3RfbmFtZSAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJwcm9kdWN0X3NlcmlhbDogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvcHJvZHVjdF9zZXJpYWwgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwicHJvZHVjdF91dWlkOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3V1aWQgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwicHJvZHVjdF92ZXJzaW9uOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9wcm9kdWN0X3ZlcnNpb24gMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwic3lzX3ZlbmRvcjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvc3lzX3ZlbmRvciAyPi9kZXYvbnVsbDsgZWNobztgO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gcmVzdWx0Lm1hbnVmYWN0dXJlciA9PT0gJycgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc3lzX3ZlbmRvcicpIDogcmVzdWx0Lm1hbnVmYWN0dXJlcjtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHJlc3VsdC5tb2RlbCA9PT0gJycgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdF9uYW1lJykgOiByZXN1bHQubW9kZWw7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHJlc3VsdC52ZXJzaW9uID09PSAnJyA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdwcm9kdWN0X3ZlcnNpb24nKSA6IHJlc3VsdC52ZXJzaW9uO1xuICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHJlc3VsdC5zZXJpYWwgPT09ICcnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3Rfc2VyaWFsJykgOiByZXN1bHQuc2VyaWFsO1xuICAgICAgICAgICAgcmVzdWx0LnV1aWQgPSByZXN1bHQudXVpZCA9PT0gJycgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAncHJvZHVjdF91dWlkJykudG9Mb3dlckNhc2UoKSA6IHJlc3VsdC51dWlkO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5zZXJpYWwgfHwgcmVzdWx0LnNlcmlhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuc2VyaWFsID0gJy0nOyB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQubWFudWZhY3R1cmVyIHx8IHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICcnOyB9XG4gICAgICAgICAgaWYgKCFyZXN1bHQubW9kZWwgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5tb2RlbCA9ICdDb21wdXRlcic7IH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC52ZXJzaW9uIHx8IHJlc3VsdC52ZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC52ZXJzaW9uID0gJyc7IH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC5za3UgfHwgcmVzdWx0LnNrdS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuc2t1ID0gJy0nOyB9XG5cbiAgICAgICAgICAvLyBkZXRlY3QgdmlydHVhbCAoMSlcbiAgICAgICAgICBpZiAocmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkgPT09ICd2aXJ0dWFsYm94JyB8fCByZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKSA9PT0gJ2t2bScgfHwgcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCkgPT09ICd2aXJ0dWFsIG1hY2hpbmUnIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpID09PSAnYm9jaHMnIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpIHx8IHJlc3VsdC5tb2RlbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2Ryb3BsZXQnKSkge1xuICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubW9kZWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICBjYXNlICd2aXJ0dWFsYm94JzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbEJveCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3Ztd2FyZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2t2bSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2JvY2hzJzpcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnYm9jaHMnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpIHx8IHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKSA9PT0gJ3hlbicpIHtcbiAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0Lm1hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3Ztd2FyZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3hlbic6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1hlbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0LnZpcnR1YWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpc2tzQnlJZCA9IGV4ZWNTeW5jKCdscyAtMSAvZGV2L2Rpc2svYnktaWQvIDI+L2Rldi9udWxsJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgaWYgKGRpc2tzQnlJZC5pbmRleE9mKCdfUUVNVV8nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdRRU1VJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZGlza3NCeUlkLmluZGV4T2YoJ19WQk9YXycpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWxCb3gnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdC52aXJ0dWFsICYmIChvcy5yZWxlYXNlKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdtaWNyb3NvZnQnKSA+PSAwIHx8IG9zLnJlbGVhc2UoKS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCd3c2wyJykpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXJuZWxWZXJzaW9uID0gcGFyc2VGbG9hdChvcy5yZWxlYXNlKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gJ01pY3Jvc29mdCc7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSAnV1NMJztcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0ga2VybmVsVmVyc2lvbiA8IDQuMTkgPyAnMScgOiAnMic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY0luZm8gPSBleGVjU3luYygnZG1pZGVjb2RlIC10IDQnKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvY0xpbmVzID0gcHJvY0luZm8udG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IHByb2NNYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKHByb2NMaW5lcywgJ21hbnVmYWN0dXJlcicsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaCAocHJvY01hbnVmYWN0dXJlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndmlydHVhbGJveCc6XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbEJveCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2bXdhcmUnOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZNd2FyZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdrdm0nOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib2Nocyc6XG4gICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnYm9jaHMnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRldGVjdCBkb2NrZXJcbiAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYygnLy5kb2NrZXJlbnYnKSB8fCBmcy5leGlzdHNTeW5jKCcvLmRvY2tlcmluaXQnKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gJ0RvY2tlciBDb250YWluZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoJ2RtZXNnIDI+L2Rldi9udWxsIHwgZ3JlcCAtaUUgXCJ2aXJ0dWFsfGh5cGVydmlzb3JcIiB8IGdyZXAgLWlFIFwidm13YXJlfHFlbXV8a3ZtfHhlblwiIHwgZ3JlcCAtdmlFIFwiTmVzdGVkIFZpcnR1YWxpemF0aW9ufC92aXJ0dWFsL1wiJyk7XG4gICAgICAgICAgICAvLyBkZXRlY3QgdmlydHVhbCBtYWNoaW5lc1xuICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5tb2RlbCA9PT0gJ0NvbXB1dGVyJykgeyByZXN1bHQubW9kZWwgPSAnVmlydHVhbCBtYWNoaW5lJzsgfVxuICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3Ztd2FyZScpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGRvdXQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3FlbXUnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnUUVNVSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigneGVuJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1hlbic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0ZG91dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigna3ZtJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzdWx0Lm1hbnVmYWN0dXJlciA9PT0gJycgJiYgcmVzdWx0Lm1vZGVsID09PSAnQ29tcHV0ZXInICYmIHJlc3VsdC52ZXJzaW9uID09PSAnJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgUmFzcGJlcnJ5IFBpXG4gICAgICAgICAgICBmcy5yZWFkRmlsZSgnL3Byb2MvY3B1aW5mbycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2hhcmR3YXJlJywgJzonLCB0cnVlKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3JldmlzaW9uJywgJzonLCB0cnVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbDonLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB2YWx1ZXM6IGh0dHBzOi8vZWxpbnV4Lm9yZy9SUGlfSGFyZHdhcmVIaXN0b3J5XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkub3JnL2RvY3VtZW50YXRpb24vaGFyZHdhcmUvcmFzcGJlcnJ5cGkvcmV2aXNpb24tY29kZXMvUkVBRE1FLm1kXG4gICAgICAgICAgICAgICAgaWYgKChyZXN1bHQubW9kZWwgPT09ICdCQ00yODM1JyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yNzA4JyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yNzA5JyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yNzEwJyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yNzExJyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yODM2JyB8fCByZXN1bHQubW9kZWwgPT09ICdCQ00yODM3JykgJiYgbW9kZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdyYXNwYmVycnknKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByUElSZXZpc2lvbiA9IHV0aWwuZGVjb2RlUGlDcHVpbmZvKGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHJQSVJldmlzaW9uLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSByUElSZXZpc2lvbi5yZXZpc2lvbkNvZGU7XG4gICAgICAgICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gJ1Jhc3BiZXJyeSBQaSBGb3VuZGF0aW9uJztcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5yYXNwYmVycnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbnVmYWN0dXJlcjogclBJUmV2aXNpb24ubWFudWZhY3R1cmVyLFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzb3I6IHJQSVJldmlzaW9uLnByb2Nlc3NvcixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogclBJUmV2aXNpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV2aXNpb246IHJQSVJldmlzaW9uLnJldmlzaW9uXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnaW9yZWcgLWMgSU9QbGF0Zm9ybUV4cGVydERldmljZSAtZCAyJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5yZXBsYWNlKC9bPD5cIl0vZywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCcsICc9JywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaW9wbGF0Zm9ybXNlcmlhbG51bWJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQudXVpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpb3BsYXRmb3JtdXVpZCcsICc9JywgdHJ1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJlc3VsdC5za3UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmQtaWQnLCAnPScsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX0NvbXB1dGVyU3lzdGVtUHJvZHVjdCB8IHNlbGVjdCBOYW1lLFZlbmRvcixWZXJzaW9uLElkZW50aWZ5aW5nTnVtYmVyLFVVSUQgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZW5kb3InLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lkZW50aWZ5aW5nbnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnV1aWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndXVpZCcsICc6JykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgLy8gZGV0ZWN0IHZpcnR1YWwgKDEpXG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gcmVzdWx0Lm1vZGVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChtb2RlbCA9PT0gJ3ZpcnR1YWxib3gnIHx8IG1vZGVsID09PSAna3ZtJyB8fCBtb2RlbCA9PT0gJ3ZpcnR1YWwgbWFjaGluZScgfHwgbW9kZWwgPT09ICdib2NocycgfHwgbW9kZWwuc3RhcnRzV2l0aCgndm13YXJlJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgncWVtdScpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ3BhcmFsbGVscycpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCd2aXJ0dWFsYm94JykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1ZpcnR1YWxCb3gnOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ2t2bScpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ2JvY2hzJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ2JvY2hzJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdxZW11JykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0tWTSc7IH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncGFyYWxsZWxzJykpIHsgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1BhcmFsbGVscyc7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBtYW51ZmFjdHVyZXIgPSByZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmIChtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgndm13YXJlJykgfHwgbWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3FlbXUnKSB8fCBtYW51ZmFjdHVyZXIgPT09ICd4ZW4nIHx8IG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCdwYXJhbGxlbHMnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWFudWZhY3R1cmVyLnN0YXJ0c1dpdGgoJ3Ztd2FyZScpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCd4ZW4nKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnWGVuJzsgfVxuICAgICAgICAgICAgICAgIGlmIChtYW51ZmFjdHVyZXIuc3RhcnRzV2l0aCgncWVtdScpKSB7IHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdLVk0nOyB9XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVmYWN0dXJlci5zdGFydHNXaXRoKCdwYXJhbGxlbHMnKSkgeyByZXN1bHQudmlydHVhbEhvc3QgPSAnUGFyYWxsZWxzJzsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIE1TX1N5c3RlbWluZm9ybWF0aW9uIC1OYW1lc3BhY2UgXCJyb290L3dtaVwiIHwgc2VsZWN0IHN5c3RlbXNrdSB8IGZsICcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnNrdSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzeXN0ZW1za3UnLCAnOicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52aXJ0dWFsKSB7XG4gICAgICAgICAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9iaW9zIHwgc2VsZWN0IFZlcnNpb24sIFNlcmlhbE51bWJlciwgU01CSU9TQklPU1ZlcnNpb24nKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignVlJUVUFMJykgPj0gMCB8fCBsaW5lcy5pbmRleE9mKCdBIE0gSSAnKSA+PSAwIHx8IGxpbmVzLmluZGV4T2YoJ1ZpcnR1YWxCb3gnKSA+PSAwIHx8IGxpbmVzLmluZGV4T2YoJ1ZNV2FyZScpID49IDAgfHwgbGluZXMuaW5kZXhPZignWGVuJykgPj0gMCB8fCBsaW5lcy5pbmRleE9mKCdQYXJhbGxlbHMnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignVmlydHVhbEJveCcpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnVmlydHVhbEJveCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMuaW5kZXhPZignVk13YXJlJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWTXdhcmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ1hlbicpID49IDAgJiYgIXJlc3VsdC52aXJ0dWFsSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmlydHVhbEhvc3QgPSAnWGVuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdWUlRVQUwnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ0h5cGVyLVYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmluZGV4T2YoJ0EgTSBJJykgPj0gMCAmJiAhcmVzdWx0LnZpcnR1YWxIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52aXJ0dWFsSG9zdCA9ICdWaXJ0dWFsIFBDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5pbmRleE9mKCdQYXJhbGxlbHMnKSA+PSAwICYmICFyZXN1bHQudmlydHVhbEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZpcnR1YWxIb3N0ID0gJ1BhcmFsbGVscyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuc3lzdGVtID0gc3lzdGVtO1xuXG5mdW5jdGlvbiBiaW9zKGNhbGxiYWNrKSB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgIHZlcnNpb246ICcnLFxuICAgICAgICByZWxlYXNlRGF0ZTogJycsXG4gICAgICAgIHJldmlzaW9uOiAnJyxcbiAgICAgIH07XG4gICAgICBsZXQgY21kID0gJyc7XG4gICAgICBpZiAoX2xpbnV4IHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgICAgICBjbWQgPSAnY2F0IC9wcm9jL2NwdWluZm8gfCBncmVwIFNlcmlhbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IGJpb3MgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCc7XG4gICAgICAgIH1cbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVmVuZG9yJyk7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVmVyc2lvbicpO1xuICAgICAgICAgIGxldCBkYXRldGltZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdSZWxlYXNlIERhdGUnKTtcbiAgICAgICAgICByZXN1bHQucmVsZWFzZURhdGUgPSB1dGlsLnBhcnNlRGF0ZVRpbWUoZGF0ZXRpbWUpLmRhdGU7XG4gICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JJT1MgUmV2aXNpb24nKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NlcmlhbE51bWJlcicpO1xuICAgICAgICAgIGxldCBsYW5ndWFnZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDdXJyZW50bHkgSW5zdGFsbGVkIExhbmd1YWdlJykuc3BsaXQoJ3wnKVswXTtcbiAgICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGluZXMubGVuZ3RoICYmIHN0ZG91dC50b1N0cmluZygpLmluZGV4T2YoJ0NoYXJhY3RlcmlzdGljczonKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignIGlzIHN1cHBvcnRlZCcpID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gbGluZS5zcGxpdCgnIGlzIHN1cHBvcnRlZCcpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5mZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOb24tUm9vdCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcImJpb3NfZGF0ZTogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYmlvc19kYXRlIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJpb3NfdmVuZG9yOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9iaW9zX3ZlbmRvciAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJiaW9zX3ZlcnNpb246IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2Jpb3NfdmVyc2lvbiAyPi9kZXYvbnVsbDsgZWNobztgO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQudmVuZG9yID0gIXJlc3VsdC52ZW5kb3IgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYmlvc192ZW5kb3InKSA6IHJlc3VsdC52ZW5kb3I7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9ICFyZXN1bHQudmVyc2lvbiA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdiaW9zX3ZlcnNpb24nKSA6IHJlc3VsdC52ZXJzaW9uO1xuICAgICAgICAgICAgZGF0ZXRpbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYmlvc19kYXRlJyk7XG4gICAgICAgICAgICByZXN1bHQucmVsZWFzZURhdGUgPSAhcmVzdWx0LnJlbGVhc2VEYXRlID8gdXRpbC5wYXJzZURhdGVUaW1lKGRhdGV0aW1lKS5kYXRlIDogcmVzdWx0LnJlbGVhc2VEYXRlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICByZXN1bHQudmVuZG9yID0gJ0FwcGxlIEluYy4nO1xuICAgICAgICBleGVjKFxuICAgICAgICAgICdzeXN0ZW1fcHJvZmlsZXIgU1BIYXJkd2FyZURhdGFUeXBlIC1qc29uJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGhhcmR3YXJlRGF0YSA9IEpTT04ucGFyc2Uoc3Rkb3V0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAoaGFyZHdhcmVEYXRhICYmIGhhcmR3YXJlRGF0YS5TUEhhcmR3YXJlRGF0YVR5cGUgJiYgaGFyZHdhcmVEYXRhLlNQSGFyZHdhcmVEYXRhVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYm9vdFJvbVZlcnNpb24gPSBoYXJkd2FyZURhdGEuU1BIYXJkd2FyZURhdGFUeXBlWzBdLmJvb3Rfcm9tX3ZlcnNpb247XG4gICAgICAgICAgICAgICAgYm9vdFJvbVZlcnNpb24gPSBib290Um9tVmVyc2lvbiA/IGJvb3RSb21WZXJzaW9uLnNwbGl0KCcoJylbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IGJvb3RSb21WZXJzaW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgcmVzdWx0LnZlbmRvciA9ICdTdW4gTWljcm9zeXN0ZW1zJztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfYmlvcyB8IHNlbGVjdCBEZXNjcmlwdGlvbixWZXJzaW9uLE1hbnVmYWN0dXJlcixAe249XCJSZWxlYXNlRGF0ZVwiO2U9eyRfLlJlbGVhc2VEYXRlLlRvU3RyaW5nKFwieXl5eS1NTS1kZFwiKX19LEJ1aWxkTnVtYmVyLFNlcmlhbE51bWJlciB8IGZsJykudGhlbigoc3Rkb3V0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2Rlc2NyaXB0aW9uJywgJzonKTtcbiAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLmluZGV4T2YoJyBWZXJzaW9uICcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBQaG9lbml4IFJPTSBCSU9TIFBMVVMgVmVyc2lvbiAxLjEwIEEwNFxuICAgICAgICAgICAgICAgIHJlc3VsdC52ZW5kb3IgPSBkZXNjcmlwdGlvbi5zcGxpdCgnIFZlcnNpb24gJylbMF0udHJpbSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZGVzY3JpcHRpb24uc3BsaXQoJyBWZXJzaW9uICcpWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbi5pbmRleE9mKCcgVmVyOiAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gQklPUyBEYXRlOiAwNi8yNy8xNiAxNzo1MDoxNiBWZXI6IDEuNC41XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlbmRvciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtYW51ZmFjdHVyZXInLCAnOicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZGVzY3JpcHRpb24uc3BsaXQoJyBWZXI6ICcpWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmVuZG9yID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc6Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VEYXRlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3JlbGVhc2VkYXRlJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnJldmlzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2J1aWxkbnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnNlcmlhbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzZXJpYWxudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuYmlvcyA9IGJpb3M7XG5cbmZ1bmN0aW9uIGJhc2Vib2FyZChjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBtYW51ZmFjdHVyZXI6ICcnLFxuICAgICAgICBtb2RlbDogJycsXG4gICAgICAgIHZlcnNpb246ICcnLFxuICAgICAgICBzZXJpYWw6ICctJyxcbiAgICAgICAgYXNzZXRUYWc6ICctJyxcbiAgICAgICAgbWVtTWF4OiBudWxsLFxuICAgICAgICBtZW1TbG90czogbnVsbFxuICAgICAgfTtcbiAgICAgIGxldCBjbWQgPSAnJztcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgICAgIGNtZCA9ICdjYXQgL3Byb2MvY3B1aW5mbyB8IGdyZXAgU2VyaWFsJztcbiAgICAgICAgICAvLyAnQkNNMjcwOScsICdCQ00yODM1JywgJ0JDTTI3MDgnIC0tPlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNtZCA9ICdleHBvcnQgTENfQUxMPUM7IGRtaWRlY29kZSAtdCAyIDI+L2Rldi9udWxsOyB1bnNldCBMQ19BTEwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtsb2FkID0gW107XG4gICAgICAgIHdvcmtsb2FkLnB1c2goZXhlY1Byb21pc2UoY21kKSk7XG4gICAgICAgIHdvcmtsb2FkLnB1c2goZXhlY1Byb21pc2UoJ2V4cG9ydCBMQ19BTEw9QzsgZG1pZGVjb2RlIC10IG1lbW9yeSAyPi9kZXYvbnVsbCcpKTtcbiAgICAgICAgdXRpbC5wcm9taXNlQWxsKFxuICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGEucmVzdWx0c1swXSA/IGRhdGEucmVzdWx0c1swXS50b1N0cmluZygpLnNwbGl0KCdcXG4nKSA6IFsnJ107XG4gICAgICAgICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYW51ZmFjdHVyZXInKTtcbiAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUHJvZHVjdCBOYW1lJyk7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVmVyc2lvbicpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU2VyaWFsIE51bWJlcicpO1xuICAgICAgICAgIHJlc3VsdC5hc3NldFRhZyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBc3NldCBUYWcnKTtcbiAgICAgICAgICAvLyBOb24tUm9vdCB2YWx1ZXNcbiAgICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcImJvYXJkX2Fzc2V0X3RhZzogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYm9hcmRfYXNzZXRfdGFnIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImJvYXJkX25hbWU6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2JvYXJkX25hbWUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYm9hcmRfc2VyaWFsOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9ib2FyZF9zZXJpYWwgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYm9hcmRfdmVuZG9yOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9ib2FyZF92ZW5kb3IgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiYm9hcmRfdmVyc2lvbjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvYm9hcmRfdmVyc2lvbiAyPi9kZXYvbnVsbDsgZWNobztgO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5lcyA9IGV4ZWNTeW5jKGNtZCkudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gIXJlc3VsdC5tYW51ZmFjdHVyZXIgPyB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmRfdmVuZG9yJykgOiByZXN1bHQubWFudWZhY3R1cmVyO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gIXJlc3VsdC5tb2RlbCA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZF9uYW1lJykgOiByZXN1bHQubW9kZWw7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9ICFyZXN1bHQudmVyc2lvbiA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZF92ZXJzaW9uJykgOiByZXN1bHQudmVyc2lvbjtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSAhcmVzdWx0LnNlcmlhbCA/IHV0aWwuZ2V0VmFsdWUobGluZXMsICdib2FyZF9zZXJpYWwnKSA6IHJlc3VsdC5zZXJpYWw7XG4gICAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSAhcmVzdWx0LmFzc2V0VGFnID8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkX2Fzc2V0X3RhZycpIDogcmVzdWx0LmFzc2V0VGFnO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0LnNlcmlhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuc2VyaWFsID0gJy0nOyB9XG4gICAgICAgICAgaWYgKHJlc3VsdC5hc3NldFRhZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuYXNzZXRUYWcgPSAnLSc7IH1cblxuICAgICAgICAgIC8vIG1lbVxuICAgICAgICAgIGxpbmVzID0gZGF0YS5yZXN1bHRzWzFdID8gZGF0YS5yZXN1bHRzWzFdLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpIDogWycnXTtcbiAgICAgICAgICByZXN1bHQubWVtTWF4ID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWF4aW11bSBDYXBhY2l0eScpKSAqIDEwMjQgKiAxMDI0ICogMTAyNCB8fCBudWxsO1xuICAgICAgICAgIHJlc3VsdC5tZW1TbG90cyA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ051bWJlciBPZiBEZXZpY2VzJykpIHx8IG51bGw7XG5cbiAgICAgICAgICAvLyByYXNwYmVycnlcbiAgICAgICAgICBsZXQgbGluZXNScGkgPSAnJztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluZXNScGkgPSBmcy5yZWFkRmlsZVN5bmMoJy9wcm9jL2NwdWluZm8nKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaGFyZHdhcmUgPSB1dGlsLmdldFZhbHVlKGxpbmVzUnBpLCAnaGFyZHdhcmUnKTtcbiAgICAgICAgICBpZiAoaGFyZHdhcmUuc3RhcnRzV2l0aCgnQkNNJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJwaSA9IHV0aWwuZGVjb2RlUGlDcHVpbmZvKGxpbmVzUnBpKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSBycGkubWFudWZhY3R1cmVyO1xuICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gJ1Jhc3BiZXJyeSBQaSc7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gcnBpLnNlcmlhbDtcbiAgICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gcnBpLnR5cGUgKyAnIC0gJyArIHJwaS5yZXZpc2lvbjtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1NYXggPSBvcy50b3RhbG1lbSgpO1xuICAgICAgICAgICAgcmVzdWx0Lm1lbVNsb3RzID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBjb25zdCB3b3JrbG9hZCA9IFtdO1xuICAgICAgICB3b3JrbG9hZC5wdXNoKGV4ZWNQcm9taXNlKCdpb3JlZyAtYyBJT1BsYXRmb3JtRXhwZXJ0RGV2aWNlIC1kIDInKSk7XG4gICAgICAgIHdvcmtsb2FkLnB1c2goZXhlY1Byb21pc2UoJ3N5c3RlbV9wcm9maWxlciBTUE1lbW9yeURhdGFUeXBlJykpO1xuICAgICAgICB1dGlsLnByb21pc2VBbGwoXG4gICAgICAgICAgd29ya2xvYWRcbiAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gZGF0YS5yZXN1bHRzWzBdID8gZGF0YS5yZXN1bHRzWzBdLnRvU3RyaW5nKCkucmVwbGFjZSgvWzw+XCJdL2csICcnKS5zcGxpdCgnXFxuJykgOiBbJyddO1xuICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwnLCAnPScsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3ZlcnNpb24nLCAnPScsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaW9wbGF0Zm9ybXNlcmlhbG51bWJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2JvYXJkLWlkJywgJz0nLCB0cnVlKTtcblxuICAgICAgICAgIC8vIG1lbVxuICAgICAgICAgIGxldCBkZXZpY2VzID0gZGF0YS5yZXN1bHRzWzFdID8gZGF0YS5yZXN1bHRzWzFdLnRvU3RyaW5nKCkuc3BsaXQoJyAgICAgICAgQkFOSyAnKSA6IFsnJ107XG4gICAgICAgICAgaWYgKGRldmljZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGF0YS5yZXN1bHRzWzFdID8gZGF0YS5yZXN1bHRzWzFdLnRvU3RyaW5nKCkuc3BsaXQoJyAgICAgICAgRElNTScpIDogWycnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV2aWNlcy5zaGlmdCgpO1xuICAgICAgICAgIHJlc3VsdC5tZW1TbG90cyA9IGRldmljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG9zLmFyY2goKSA9PT0gJ2FybTY0Jykge1xuICAgICAgICAgICAgcmVzdWx0Lm1lbVNsb3RzID0gMDtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1NYXggPSBvcy50b3RhbG1lbSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgd29ya2xvYWQgPSBbXTtcbiAgICAgICAgICBjb25zdCB3aW4xMHBsdXMgPSBwYXJzZUludChvcy5yZWxlYXNlKCkpID49IDEwO1xuICAgICAgICAgIGNvbnN0IG1heENhcGFjaXR5QXR0cmlidXRlID0gd2luMTBwbHVzID8gJ01heENhcGFjaXR5RXgnIDogJ01heENhcGFjaXR5JztcbiAgICAgICAgICB3b3JrbG9hZC5wdXNoKHV0aWwucG93ZXJTaGVsbCgnR2V0LUNpbUluc3RhbmNlIFdpbjMyX2Jhc2Vib2FyZCB8IHNlbGVjdCBNb2RlbCxNYW51ZmFjdHVyZXIsUHJvZHVjdCxWZXJzaW9uLFNlcmlhbE51bWJlcixQYXJ0TnVtYmVyLFNLVSB8IGZsJykpO1xuICAgICAgICAgIHdvcmtsb2FkLnB1c2godXRpbC5wb3dlclNoZWxsKGBHZXQtQ2ltSW5zdGFuY2UgV2luMzJfcGh5c2ljYWxtZW1vcnlhcnJheSB8IHNlbGVjdCAke21heENhcGFjaXR5QXR0cmlidXRlfSwgTWVtb3J5RGV2aWNlcyB8IGZsYCkpO1xuICAgICAgICAgIHV0aWwucHJvbWlzZUFsbChcbiAgICAgICAgICAgIHdvcmtsb2FkXG4gICAgICAgICAgKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhLnJlc3VsdHNbMF0gPyBkYXRhLnJlc3VsdHNbMF0udG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJykgOiBbJyddO1xuXG4gICAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21hbnVmYWN0dXJlcicsICc6Jyk7XG4gICAgICAgICAgICByZXN1bHQubW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbW9kZWwnLCAnOicpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQubW9kZWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Byb2R1Y3QnLCAnOicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc6Jyk7XG4gICAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NlcmlhbG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAncGFydG51bWJlcicsICc6Jyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5hc3NldFRhZykge1xuICAgICAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2t1JywgJzonKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWVtcGh5c2ljYWxcbiAgICAgICAgICAgIGxpbmVzID0gZGF0YS5yZXN1bHRzWzFdID8gZGF0YS5yZXN1bHRzWzFdLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpIDogWycnXTtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1NYXggPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsIG1heENhcGFjaXR5QXR0cmlidXRlLCAnOicpKSAqICh3aW4xMHBsdXMgPyAxMDI0IDogMSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC5tZW1TbG90cyA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01lbW9yeURldmljZXMnLCAnOicpKSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuYmFzZWJvYXJkID0gYmFzZWJvYXJkO1xuXG5mdW5jdGlvbiBjaGFzc2lzKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGNoYXNzaXNUeXBlcyA9IFsnT3RoZXInLFxuICAgICdVbmtub3duJyxcbiAgICAnRGVza3RvcCcsXG4gICAgJ0xvdyBQcm9maWxlIERlc2t0b3AnLFxuICAgICdQaXp6YSBCb3gnLFxuICAgICdNaW5pIFRvd2VyJyxcbiAgICAnVG93ZXInLFxuICAgICdQb3J0YWJsZScsXG4gICAgJ0xhcHRvcCcsXG4gICAgJ05vdGVib29rJyxcbiAgICAnSGFuZCBIZWxkJyxcbiAgICAnRG9ja2luZyBTdGF0aW9uJyxcbiAgICAnQWxsIGluIE9uZScsXG4gICAgJ1N1YiBOb3RlYm9vaycsXG4gICAgJ1NwYWNlLVNhdmluZycsXG4gICAgJ0x1bmNoIEJveCcsXG4gICAgJ01haW4gU3lzdGVtIENoYXNzaXMnLFxuICAgICdFeHBhbnNpb24gQ2hhc3NpcycsXG4gICAgJ1N1YkNoYXNzaXMnLFxuICAgICdCdXMgRXhwYW5zaW9uIENoYXNzaXMnLFxuICAgICdQZXJpcGhlcmFsIENoYXNzaXMnLFxuICAgICdTdG9yYWdlIENoYXNzaXMnLFxuICAgICdSYWNrIE1vdW50IENoYXNzaXMnLFxuICAgICdTZWFsZWQtQ2FzZSBQQycsXG4gICAgJ011bHRpLVN5c3RlbSBDaGFzc2lzJyxcbiAgICAnQ29tcGFjdCBQQ0knLFxuICAgICdBZHZhbmNlZCBUQ0EnLFxuICAgICdCbGFkZScsXG4gICAgJ0JsYWRlIEVuY2xvc3VyZScsXG4gICAgJ1RhYmxldCcsXG4gICAgJ0NvbnZlcnRpYmxlJyxcbiAgICAnRGV0YWNoYWJsZScsXG4gICAgJ0lvVCBHYXRld2F5ICcsXG4gICAgJ0VtYmVkZGVkIFBDJyxcbiAgICAnTWluaSBQQycsXG4gICAgJ1N0aWNrIFBDJyxcbiAgXTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgbWFudWZhY3R1cmVyOiAnJyxcbiAgICAgICAgbW9kZWw6ICcnLFxuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgdmVyc2lvbjogJycsXG4gICAgICAgIHNlcmlhbDogJy0nLFxuICAgICAgICBhc3NldFRhZzogJy0nLFxuICAgICAgICBza3U6ICcnLFxuICAgICAgfTtcbiAgICAgIGlmIChfbGludXggfHwgX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBjb25zdCBjbWQgPSBgZWNobyAtbiBcImNoYXNzaXNfYXNzZXRfdGFnOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9jaGFzc2lzX2Fzc2V0X3RhZyAyPi9kZXYvbnVsbDsgZWNobztcbiAgICAgICAgICAgIGVjaG8gLW4gXCJjaGFzc2lzX3NlcmlhbDogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvY2hhc3Npc19zZXJpYWwgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2hhc3Npc190eXBlOiBcIjsgY2F0IC9zeXMvZGV2aWNlcy92aXJ0dWFsL2RtaS9pZC9jaGFzc2lzX3R5cGUgMj4vZGV2L251bGw7IGVjaG87XG4gICAgICAgICAgICBlY2hvIC1uIFwiY2hhc3Npc192ZW5kb3I6IFwiOyBjYXQgL3N5cy9kZXZpY2VzL3ZpcnR1YWwvZG1pL2lkL2NoYXNzaXNfdmVuZG9yIDI+L2Rldi9udWxsOyBlY2hvO1xuICAgICAgICAgICAgZWNobyAtbiBcImNoYXNzaXNfdmVyc2lvbjogXCI7IGNhdCAvc3lzL2RldmljZXMvdmlydHVhbC9kbWkvaWQvY2hhc3Npc192ZXJzaW9uIDI+L2Rldi9udWxsOyBlY2hvO2A7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICByZXN1bHQubWFudWZhY3R1cmVyID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYXNzaXNfdmVuZG9yJyk7XG4gICAgICAgICAgY29uc3QgY3R5cGUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnY2hhc3Npc190eXBlJykucmVwbGFjZSgvXFxEL2csICcnKSk7XG4gICAgICAgICAgcmVzdWx0LnR5cGUgPSAoY3R5cGUgJiYgIWlzTmFOKGN0eXBlKSAmJiBjdHlwZSA8IGNoYXNzaXNUeXBlcy5sZW5ndGgpID8gY2hhc3Npc1R5cGVzW2N0eXBlIC0gMV0gOiAnJztcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFzc2lzX3ZlcnNpb24nKTtcbiAgICAgICAgICByZXN1bHQuc2VyaWFsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYXNzaXNfc2VyaWFsJyk7XG4gICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYXNzaXNfYXNzZXRfdGFnJyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5tYW51ZmFjdHVyZXIudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdvLmUubS4nKSAhPT0gLTEpIHsgcmVzdWx0Lm1hbnVmYWN0dXJlciA9ICctJzsgfVxuICAgICAgICAgIGlmIChyZXN1bHQudmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQudmVyc2lvbiA9ICctJzsgfVxuICAgICAgICAgIGlmIChyZXN1bHQuc2VyaWFsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5zZXJpYWwgPSAnLSc7IH1cbiAgICAgICAgICBpZiAocmVzdWx0LmFzc2V0VGFnLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5hc3NldFRhZyA9ICctJzsgfVxuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgZXhlYygnaW9yZWcgLWMgSU9QbGF0Zm9ybUV4cGVydERldmljZSAtZCAyJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5yZXBsYWNlKC9bPD5cIl0vZywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5tb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlbCcsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICd2ZXJzaW9uJywgJz0nLCB0cnVlKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaW9wbGF0Zm9ybXNlcmlhbG51bWJlcicsICc9JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQuYXNzZXRUYWcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYm9hcmQtaWQnLCAnPScsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfc3Vub3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKF93aW5kb3dzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXRpbC5wb3dlclNoZWxsKCdHZXQtQ2ltSW5zdGFuY2UgV2luMzJfU3lzdGVtRW5jbG9zdXJlIHwgc2VsZWN0IE1vZGVsLE1hbnVmYWN0dXJlcixDaGFzc2lzVHlwZXMsVmVyc2lvbixTZXJpYWxOdW1iZXIsUGFydE51bWJlcixTS1UgfCBmbCcpLnRoZW4oKHN0ZG91dCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgbGV0IGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuXG4gICAgICAgICAgICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbWFudWZhY3R1cmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0Lm1vZGVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ21vZGVsJywgJzonKTtcbiAgICAgICAgICAgICAgY29uc3QgY3R5cGUgPSBwYXJzZUludCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2hhc3Npc1R5cGVzJywgJzonKS5yZXBsYWNlKC9cXEQvZywgJycpKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSAoY3R5cGUgJiYgIWlzTmFOKGN0eXBlKSAmJiBjdHlwZSA8IGNoYXNzaXNUeXBlcy5sZW5ndGgpID8gY2hhc3Npc1R5cGVzW2N0eXBlIC0gMV0gOiAnJztcbiAgICAgICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndmVyc2lvbicsICc6Jyk7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXJpYWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnc2VyaWFsbnVtYmVyJywgJzonKTtcbiAgICAgICAgICAgICAgcmVzdWx0LmFzc2V0VGFnID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3BhcnRudW1iZXInLCAnOicpO1xuICAgICAgICAgICAgICByZXN1bHQuc2t1ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3NrdScsICc6Jyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQubWFudWZhY3R1cmVyLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5tYW51ZmFjdHVyZXIgPSAnLSc7IH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC52ZXJzaW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC52ZXJzaW9uID0gJy0nOyB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuc2VyaWFsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignby5lLm0uJykgIT09IC0xKSB7IHJlc3VsdC5zZXJpYWwgPSAnLSc7IH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hc3NldFRhZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ28uZS5tLicpICE9PSAtMSkgeyByZXN1bHQuYXNzZXRUYWcgPSAnLSc7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmNoYXNzaXMgPSBjaGFzc2lzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyB1c2IuanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxNi4gdXNiXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubGV0IF9wbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm07XG5cbmNvbnN0IF9saW51eCA9IChfcGxhdGZvcm0gPT09ICdsaW51eCcgfHwgX3BsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgX2RhcndpbiA9IChfcGxhdGZvcm0gPT09ICdkYXJ3aW4nKTtcbmNvbnN0IF93aW5kb3dzID0gKF9wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG5jb25zdCBfZnJlZWJzZCA9IChfcGxhdGZvcm0gPT09ICdmcmVlYnNkJyk7XG5jb25zdCBfb3BlbmJzZCA9IChfcGxhdGZvcm0gPT09ICdvcGVuYnNkJyk7XG5jb25zdCBfbmV0YnNkID0gKF9wbGF0Zm9ybSA9PT0gJ25ldGJzZCcpO1xuY29uc3QgX3N1bm9zID0gKF9wbGF0Zm9ybSA9PT0gJ3N1bm9zJyk7XG5cbmZ1bmN0aW9uIGdldExpbnV4VXNiVHlwZSh0eXBlLCBuYW1lKSB7XG4gIGxldCByZXN1bHQgPSB0eXBlO1xuICBjb25zdCBzdHIgPSAobmFtZSArICcgJyArIHR5cGUpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChzdHIuaW5kZXhPZignY2FtZXJhJykgPj0gMCkgeyByZXN1bHQgPSAnQ2FtZXJhJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignaHViJykgPj0gMCkgeyByZXN1bHQgPSAnSHViJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZigna2V5YnJkJykgPj0gMCkgeyByZXN1bHQgPSAnS2V5Ym9hcmQnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdrZXlib2FyZCcpID49IDApIHsgcmVzdWx0ID0gJ0tleWJvYXJkJzsgfVxuICBlbHNlIGlmIChzdHIuaW5kZXhPZignbW91c2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdNb3VzZSc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ3N0b3JhJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgZWxzZSBpZiAoc3RyLmluZGV4T2YoJ21pYycpID49IDApIHsgcmVzdWx0ID0gJ01pY3JvcGhvbmUnOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdoZWFkc2V0JykgPj0gMCkgeyByZXN1bHQgPSAnQXVkaW8nOyB9XG4gIGVsc2UgaWYgKHN0ci5pbmRleE9mKCdhdWRpbycpID49IDApIHsgcmVzdWx0ID0gJ0F1ZGlvJzsgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGludXhVc2IodXNiKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBsaW5lcyA9IHVzYi5zcGxpdCgnXFxuJyk7XG4gIGlmIChsaW5lcyAmJiBsaW5lcy5sZW5ndGggJiYgbGluZXNbMF0uaW5kZXhPZignRGV2aWNlJykgPj0gMCkge1xuICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICByZXN1bHQuYnVzID0gcGFyc2VJbnQocGFydHNbMF0sIDEwKTtcbiAgICBpZiAocGFydHNbMl0pIHtcbiAgICAgIHJlc3VsdC5kZXZpY2VJZCA9IHBhcnNlSW50KHBhcnRzWzJdLCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5kZXZpY2VJZCA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5idXMgPSBudWxsO1xuICAgIHJlc3VsdC5kZXZpY2VJZCA9IG51bGw7XG4gIH1cbiAgY29uc3QgaWRWZW5kb3IgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaWRWZW5kb3InLCAnICcsIHRydWUpLnRyaW0oKTtcbiAgbGV0IHZlbmRvclBhcnRzID0gaWRWZW5kb3Iuc3BsaXQoJyAnKTtcbiAgdmVuZG9yUGFydHMuc2hpZnQoKTtcbiAgY29uc3QgdmVuZG9yID0gdmVuZG9yUGFydHMuam9pbignICcpO1xuXG4gIGNvbnN0IGlkUHJvZHVjdCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpZFByb2R1Y3QnLCAnICcsIHRydWUpLnRyaW0oKTtcbiAgbGV0IHByb2R1Y3RQYXJ0cyA9IGlkUHJvZHVjdC5zcGxpdCgnICcpO1xuICBwcm9kdWN0UGFydHMuc2hpZnQoKTtcbiAgY29uc3QgcHJvZHVjdCA9IHByb2R1Y3RQYXJ0cy5qb2luKCcgJyk7XG5cbiAgY29uc3QgaW50ZXJmYWNlQ2xhc3MgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYkludGVyZmFjZUNsYXNzJywgJyAnLCB0cnVlKS50cmltKCk7XG4gIGxldCBpbnRlcmZhY2VDbGFzc1BhcnRzID0gaW50ZXJmYWNlQ2xhc3Muc3BsaXQoJyAnKTtcbiAgaW50ZXJmYWNlQ2xhc3NQYXJ0cy5zaGlmdCgpO1xuICBjb25zdCB1c2JUeXBlID0gaW50ZXJmYWNlQ2xhc3NQYXJ0cy5qb2luKCcgJyk7XG5cbiAgY29uc3QgaU1hbnVmYWN0dXJlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdpTWFudWZhY3R1cmVyJywgJyAnLCB0cnVlKS50cmltKCk7XG4gIGxldCBpTWFudWZhY3R1cmVyUGFydHMgPSBpTWFudWZhY3R1cmVyLnNwbGl0KCcgJyk7XG4gIGlNYW51ZmFjdHVyZXJQYXJ0cy5zaGlmdCgpO1xuICBjb25zdCBtYW51ZmFjdHVyZXIgPSBpTWFudWZhY3R1cmVyUGFydHMuam9pbignICcpO1xuXG4gIHJlc3VsdC5pZCA9IChpZFZlbmRvci5zdGFydHNXaXRoKCcweCcpID8gaWRWZW5kb3Iuc3BsaXQoJyAnKVswXS5zdWJzdHIoMiwgMTApIDogJycpICsgJzonICsgKGlkUHJvZHVjdC5zdGFydHNXaXRoKCcweCcpID8gaWRQcm9kdWN0LnNwbGl0KCcgJylbMF0uc3Vic3RyKDIsIDEwKSA6ICcnKTtcbiAgcmVzdWx0Lm5hbWUgPSBwcm9kdWN0O1xuICByZXN1bHQudHlwZSA9IGdldExpbnV4VXNiVHlwZSh1c2JUeXBlLCBwcm9kdWN0KTtcbiAgcmVzdWx0LnJlbW92YWJsZSA9IG51bGw7XG4gIHJlc3VsdC52ZW5kb3IgPSB2ZW5kb3I7XG4gIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXI7XG4gIHJlc3VsdC5tYXhQb3dlciA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNYXhQb3dlcicsICcgJywgdHJ1ZSk7XG4gIHJlc3VsdC5zZXJpYWxOdW1iZXIgPSBudWxsO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldERhcndpblVzYlR5cGUobmFtZSkge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmIChuYW1lLmluZGV4T2YoJ2NhbWVyYScpID49IDApIHsgcmVzdWx0ID0gJ0NhbWVyYSc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCd0b3VjaCBiYXInKSA+PSAwKSB7IHJlc3VsdCA9ICdUb3VjaCBCYXInOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignY29udHJvbGxlcicpID49IDApIHsgcmVzdWx0ID0gJ0NvbnRyb2xsZXInOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignaGVhZHNldCcpID49IDApIHsgcmVzdWx0ID0gJ0F1ZGlvJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ2tleWJvYXJkJykgPj0gMCkgeyByZXN1bHQgPSAnS2V5Ym9hcmQnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigndHJhY2twYWQnKSA+PSAwKSB7IHJlc3VsdCA9ICdUcmFja3BhZCc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdzZW5zb3InKSA+PSAwKSB7IHJlc3VsdCA9ICdTZW5zb3InOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignYnRodXNiJykgPj0gMCkgeyByZXN1bHQgPSAnQmx1ZXRvb3RoJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ2J0aCcpID49IDApIHsgcmVzdWx0ID0gJ0JsdWV0b290aCc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdyZmNvbW0nKSA+PSAwKSB7IHJlc3VsdCA9ICdCbHVldG9vdGgnOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigndXNiaHViJykgPj0gMCkgeyByZXN1bHQgPSAnSHViJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJyBodWInKSA+PSAwKSB7IHJlc3VsdCA9ICdIdWInOyB9XG4gIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignbW91c2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdNb3VzZSc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdtaWMnKSA+PSAwKSB7IHJlc3VsdCA9ICdNaWNyb3Bob25lJzsgfVxuICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3JlbW92YWJsZScpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gcGFyc2VEYXJ3aW5Vc2IodXNiLCBpZCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgcmVzdWx0LmlkID0gaWQ7XG5cbiAgdXNiID0gdXNiLnJlcGxhY2UoLyBcXHwvZywgJycpO1xuICB1c2IgPSB1c2IudHJpbSgpO1xuICBsZXQgbGluZXMgPSB1c2Iuc3BsaXQoJ1xcbicpO1xuICBsaW5lcy5zaGlmdCgpO1xuICB0cnkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0udHJpbSgpO1xuICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXS5yZXBsYWNlKC89L2csICc6Jyk7XG4gICAgICBpZiAobGluZXNbaV0gIT09ICd7JyAmJiBsaW5lc1tpXSAhPT0gJ30nICYmIGxpbmVzW2kgKyAxXSAmJiBsaW5lc1tpICsgMV0udHJpbSgpICE9PSAnfScpIHtcbiAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXSArICcsJztcbiAgICAgIH1cbiAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgnOiBZZXMsJywgJzogXCJZZXNcIiwnKTtcbiAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgnOiBObywnLCAnOiBcIk5vXCIsJyk7XG4gICAgfVxuICAgIGNvbnN0IHVzYk9iaiA9IEpTT04ucGFyc2UobGluZXMuam9pbignXFxuJykpO1xuICAgIGNvbnN0IHJlbW92YWJsZURyaXZlID0gdXNiT2JqWydCdWlsdC1JbiddLnRvTG93ZXJDYXNlKCkgIT09ICd5ZXMnICYmIHVzYk9ialsnbm9uLXJlbW92YWJsZSddLnRvTG93ZXJDYXNlKCkgPT09ICdubyc7XG5cbiAgICByZXN1bHQuYnVzID0gbnVsbDtcbiAgICByZXN1bHQuZGV2aWNlSWQgPSBudWxsO1xuICAgIHJlc3VsdC5pZCA9IHVzYk9ialsnVVNCIEFkZHJlc3MnXSB8fCBudWxsO1xuICAgIHJlc3VsdC5uYW1lID0gdXNiT2JqWydrVVNCUHJvZHVjdFN0cmluZyddIHx8IHVzYk9ialsnVVNCIFByb2R1Y3QgTmFtZSddIHx8IG51bGw7XG4gICAgcmVzdWx0LnR5cGUgPSBnZXREYXJ3aW5Vc2JUeXBlKCh1c2JPYmpbJ2tVU0JQcm9kdWN0U3RyaW5nJ10gfHwgdXNiT2JqWydVU0IgUHJvZHVjdCBOYW1lJ10gfHwgJycpLnRvTG93ZXJDYXNlKCkgKyAocmVtb3ZhYmxlRHJpdmUgPyAnIHJlbW92YWJsZScgOiAnJykpO1xuICAgIHJlc3VsdC5yZW1vdmFibGUgPSB1c2JPYmpbJ25vbi1yZW1vdmFibGUnXS50b0xvd2VyQ2FzZSgpID09PSAnbm8nO1xuICAgIHJlc3VsdC52ZW5kb3IgPSB1c2JPYmpbJ2tVU0JWZW5kb3JTdHJpbmcnXSB8fCB1c2JPYmpbJ1VTQiBWZW5kb3IgTmFtZSddIHx8IG51bGw7XG4gICAgcmVzdWx0Lm1hbnVmYWN0dXJlciA9IHVzYk9ialsna1VTQlZlbmRvclN0cmluZyddIHx8IHVzYk9ialsnVVNCIFZlbmRvciBOYW1lJ10gfHwgbnVsbDtcbiAgICByZXN1bHQubWF4UG93ZXIgPSBudWxsO1xuICAgIHJlc3VsdC5zZXJpYWxOdW1iZXIgPSB1c2JPYmpbJ2tVU0JTZXJpYWxOdW1iZXJTdHJpbmcnXSB8fCBudWxsO1xuXG4gICAgaWYgKHJlc3VsdC5uYW1lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dzVXNiVHlwZUNyZWF0aW9uKGNyZWF0aW9uY2xhc3MsIG5hbWUpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAobmFtZS5pbmRleE9mKCdzdG9yYWdlJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdzcGVpY2hlcicpID49IDApIHsgcmVzdWx0ID0gJ1N0b3JhZ2UnOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZigndXNiaHViJykgPj0gMCkgeyByZXN1bHQgPSAnSHViJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ3N0b3JhZ2UnKSA+PSAwKSB7IHJlc3VsdCA9ICdTdG9yYWdlJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ3VzYmNvbnRyb2xsZXInKSA+PSAwKSB7IHJlc3VsdCA9ICdDb250cm9sbGVyJzsgfVxuICBlbHNlIGlmIChjcmVhdGlvbmNsYXNzLmluZGV4T2YoJ2tleWJvYXJkJykgPj0gMCkgeyByZXN1bHQgPSAnS2V5Ym9hcmQnOyB9XG4gIGVsc2UgaWYgKGNyZWF0aW9uY2xhc3MuaW5kZXhPZigncG9pbnRpbmcnKSA+PSAwKSB7IHJlc3VsdCA9ICdNb3VzZSc7IH1cbiAgZWxzZSBpZiAoY3JlYXRpb25jbGFzcy5pbmRleE9mKCdkaXNrJykgPj0gMCkgeyByZXN1bHQgPSAnU3RvcmFnZSc7IH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzVXNiKGxpbmVzLCBpZCkge1xuICBjb25zdCB1c2JUeXBlID0gZ2V0V2luZG93c1VzYlR5cGVDcmVhdGlvbih1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ3JlYXRpb25DbGFzc05hbWUnLCAnOicpLnRvTG93ZXJDYXNlKCksIHV0aWwuZ2V0VmFsdWUobGluZXMsICduYW1lJywgJzonKS50b0xvd2VyQ2FzZSgpKTtcblxuICBpZiAodXNiVHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIHJlc3VsdC5idXMgPSBudWxsO1xuICAgIHJlc3VsdC5kZXZpY2VJZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdkZXZpY2VpZCcsICc6Jyk7XG4gICAgcmVzdWx0LmlkID0gaWQ7XG4gICAgcmVzdWx0Lm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnbmFtZScsICc6Jyk7XG4gICAgcmVzdWx0LnR5cGUgPSB1c2JUeXBlO1xuICAgIHJlc3VsdC5yZW1vdmFibGUgPSBudWxsO1xuICAgIHJlc3VsdC52ZW5kb3IgPSBudWxsO1xuICAgIHJlc3VsdC5tYW51ZmFjdHVyZXIgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTWFudWZhY3R1cmVyJywgJzonKTtcbiAgICByZXN1bHQubWF4UG93ZXIgPSBudWxsO1xuICAgIHJlc3VsdC5zZXJpYWxOdW1iZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2IoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgY29uc3QgY21kID0gJ2V4cG9ydCBMQ19BTEw9QzsgbHN1c2IgLXYgMj4vZGV2L251bGw7IHVuc2V0IExDX0FMTCc7XG4gICAgICAgIGV4ZWMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDEwMjQgKiAxMjggfSwgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9ICgnXFxuXFxuJyArIHN0ZG91dC50b1N0cmluZygpKS5zcGxpdCgnXFxuXFxuQnVzICcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCB1c2IgPSBwYXJzZUxpbnV4VXNiKHBhcnRzW2ldKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godXNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9kYXJ3aW4pIHtcbiAgICAgICAgbGV0IGNtZCA9ICdpb3JlZyAtcCBJT1VTQiAtYyBBcHBsZVVTQlJvb3RIdWJEZXZpY2UgLXcwIC1sJztcbiAgICAgICAgZXhlYyhjbWQsIHsgbWF4QnVmZmVyOiAxMDI0ICogMTAyNCAqIDEyOCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gKHN0ZG91dC50b1N0cmluZygpKS5zcGxpdCgnICstbyAnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdXNiID0gcGFyc2VEYXJ3aW5Vc2IocGFydHNbaV0pO1xuICAgICAgICAgICAgICBpZiAodXNiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godXNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChfd2luZG93cykge1xuICAgICAgICB1dGlsLnBvd2VyU2hlbGwoJ0dldC1DaW1JbnN0YW5jZSBDSU1fTG9naWNhbERldmljZSB8IHdoZXJlIHsgJF8uRGVzY3JpcHRpb24gLW1hdGNoIFwiVVNCXCJ9IHwgc2VsZWN0IE5hbWUsQ3JlYXRpb25DbGFzc05hbWUsRGV2aWNlSWQsTWFudWZhY3R1cmVyIHwgZmwnKS50aGVuKChzdGRvdXQsIGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgvXFxuXFxzKlxcbi8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCB1c2IgPSBwYXJzZVdpbmRvd3NVc2IocGFydHNbaV0uc3BsaXQoJ1xcbicpLCBpKTtcbiAgICAgICAgICAgICAgaWYgKHVzYikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVzYik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKF9zdW5vcyB8fCBfZnJlZWJzZCB8fCBfb3BlbmJzZCB8fCBfbmV0YnNkKSB7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnVzYiA9IHVzYjtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQHRzLWNoZWNrXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyB1c2Vycy5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDExLiBVc2Vycy9TZXNzaW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuY29uc3QgX2ZyZWVic2QgPSAoX3BsYXRmb3JtID09PSAnZnJlZWJzZCcpO1xuY29uc3QgX29wZW5ic2QgPSAoX3BsYXRmb3JtID09PSAnb3BlbmJzZCcpO1xuY29uc3QgX25ldGJzZCA9IChfcGxhdGZvcm0gPT09ICduZXRic2QnKTtcbmNvbnN0IF9zdW5vcyA9IChfcGxhdGZvcm0gPT09ICdzdW5vcycpO1xuXG5mdW5jdGlvbiBwYXJzZVVzZXJzTGludXgobGluZXMsIHBoYXNlKSB7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgbGV0IHJlc3VsdF93aG8gPSBbXTtcbiAgbGV0IHJlc3VsdF93ID0ge307XG4gIGxldCB3X2ZpcnN0ID0gdHJ1ZTtcbiAgbGV0IHdfaGVhZGVyID0gW107XG4gIGxldCB3X3BvcyA9IFtdO1xuICBsZXQgd2hvX2xpbmUgPSB7fTtcblxuICBsZXQgaXNfd2hvcGFydCA9IHRydWU7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAobGluZSA9PT0gJy0tLScpIHtcbiAgICAgIGlzX3dob3BhcnQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGwgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcblxuICAgICAgLy8gd2hvIHBhcnRcbiAgICAgIGlmIChpc193aG9wYXJ0KSB7XG4gICAgICAgIHJlc3VsdF93aG8ucHVzaCh7XG4gICAgICAgICAgdXNlcjogbFswXSxcbiAgICAgICAgICB0dHk6IGxbMV0sXG4gICAgICAgICAgZGF0ZTogbFsyXSxcbiAgICAgICAgICB0aW1lOiBsWzNdLFxuICAgICAgICAgIGlwOiAobCAmJiBsLmxlbmd0aCA+IDQpID8gbFs0XS5yZXBsYWNlKC9cXCgvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykgOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHcgcGFydFxuICAgICAgICBpZiAod19maXJzdCkgeyAgICAvLyBoZWFkZXJcbiAgICAgICAgICB3X2hlYWRlciA9IGw7XG4gICAgICAgICAgd19oZWFkZXIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgd19wb3MucHVzaChsaW5lLmluZGV4T2YoaXRlbSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdfZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzcGxpdCBieSB3X3Bvc1xuICAgICAgICAgIHJlc3VsdF93LnVzZXIgPSBsaW5lLnN1YnN0cmluZyh3X3Bvc1swXSwgd19wb3NbMV0gLSAxKS50cmltKCk7XG4gICAgICAgICAgcmVzdWx0X3cudHR5ID0gbGluZS5zdWJzdHJpbmcod19wb3NbMV0sIHdfcG9zWzJdIC0gMSkudHJpbSgpO1xuICAgICAgICAgIHJlc3VsdF93LmlwID0gbGluZS5zdWJzdHJpbmcod19wb3NbMl0sIHdfcG9zWzNdIC0gMSkucmVwbGFjZSgvXFwoL2csICcnKS5yZXBsYWNlKC9cXCkvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICByZXN1bHRfdy5jb21tYW5kID0gbGluZS5zdWJzdHJpbmcod19wb3NbN10sIDEwMDApLnRyaW0oKTtcbiAgICAgICAgICAvLyBmaW5kIGNvcnJlc3BvbmRpbmcgJ3dobycgbGluZVxuICAgICAgICAgIHdob19saW5lID0gcmVzdWx0X3doby5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIChvYmoudXNlci5zdWJzdHJpbmcoMCwgOCkudHJpbSgpID09PSByZXN1bHRfdy51c2VyICYmIG9iai50dHkgPT09IHJlc3VsdF93LnR0eSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHdob19saW5lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICB1c2VyOiB3aG9fbGluZVswXS51c2VyLFxuICAgICAgICAgICAgICB0dHk6IHdob19saW5lWzBdLnR0eSxcbiAgICAgICAgICAgICAgZGF0ZTogd2hvX2xpbmVbMF0uZGF0ZSxcbiAgICAgICAgICAgICAgdGltZTogd2hvX2xpbmVbMF0udGltZSxcbiAgICAgICAgICAgICAgaXA6IHdob19saW5lWzBdLmlwLFxuICAgICAgICAgICAgICBjb21tYW5kOiByZXN1bHRfdy5jb21tYW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCAmJiBwaGFzZSA9PT0gMikge1xuICAgIHJldHVybiByZXN1bHRfd2hvO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VVc2Vyc0RhcndpbihsaW5lcykge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGxldCByZXN1bHRfd2hvID0gW107XG4gIGxldCByZXN1bHRfdyA9IHt9O1xuICBsZXQgd2hvX2xpbmUgPSB7fTtcblxuICBsZXQgaXNfd2hvcGFydCA9IHRydWU7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICBpZiAobGluZSA9PT0gJy0tLScpIHtcbiAgICAgIGlzX3dob3BhcnQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGwgPSBsaW5lLnJlcGxhY2UoLyArL2csICcgJykuc3BsaXQoJyAnKTtcblxuICAgICAgLy8gd2hvIHBhcnRcbiAgICAgIGlmIChpc193aG9wYXJ0KSB7XG4gICAgICAgIHJlc3VsdF93aG8ucHVzaCh7XG4gICAgICAgICAgdXNlcjogbFswXSxcbiAgICAgICAgICB0dHk6IGxbMV0sXG4gICAgICAgICAgZGF0ZTogKCcnICsgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKSArICctJyArICgnMCcgKyAoJ0pBTkZFQk1BUkFQUk1BWUpVTkpVTEFVR1NFUE9DVE5PVkRFQycuaW5kZXhPZihsWzJdLnRvVXBwZXJDYXNlKCkpIC8gMyArIDEpKS5zbGljZSgtMikgKyAnLScgKyAoJzAnICsgbFszXSkuc2xpY2UoLTIpLFxuICAgICAgICAgIHRpbWU6IGxbNF0sXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdyBwYXJ0XG4gICAgICAgIC8vIHNwbGl0IGJ5IHdfcG9zXG4gICAgICAgIHJlc3VsdF93LnVzZXIgPSBsWzBdO1xuICAgICAgICByZXN1bHRfdy50dHkgPSBsWzFdO1xuICAgICAgICByZXN1bHRfdy5pcCA9IChsWzJdICE9PSAnLScpID8gbFsyXSA6ICcnO1xuICAgICAgICByZXN1bHRfdy5jb21tYW5kID0gbC5zbGljZSg1LCAxMDAwKS5qb2luKCcgJyk7XG4gICAgICAgIC8vIGZpbmQgY29ycmVzcG9uZGluZyAnd2hvJyBsaW5lXG4gICAgICAgIHdob19saW5lID0gcmVzdWx0X3doby5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiAob2JqLnVzZXIgPT09IHJlc3VsdF93LnVzZXIgJiYgKG9iai50dHkuc3Vic3RyaW5nKDMsIDEwMDApID09PSByZXN1bHRfdy50dHkgfHwgb2JqLnR0eSA9PT0gcmVzdWx0X3cudHR5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod2hvX2xpbmUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdXNlcjogd2hvX2xpbmVbMF0udXNlcixcbiAgICAgICAgICAgIHR0eTogd2hvX2xpbmVbMF0udHR5LFxuICAgICAgICAgICAgZGF0ZTogd2hvX2xpbmVbMF0uZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHdob19saW5lWzBdLnRpbWUsXG4gICAgICAgICAgICBpcDogcmVzdWx0X3cuaXAsXG4gICAgICAgICAgICBjb21tYW5kOiByZXN1bHRfdy5jb21tYW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2VycyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAvLyBsaW51eFxuICAgICAgaWYgKF9saW51eCkge1xuICAgICAgICBleGVjKCd3aG8gLS1pcHM7IGVjaG8gXCItLS1cIjsgdyB8IHRhaWwgLW4gKzInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGxpbmVzIC8gc3BsaXRcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVXNlcnNMaW51eChsaW5lcywgMSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBleGVjKCd3aG87IGVjaG8gXCItLS1cIjsgdyB8IHRhaWwgLW4gKzInLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGxpbmVzIC8gc3BsaXRcbiAgICAgICAgICAgICAgICAgIGxpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VVc2Vyc0xpbnV4KGxpbmVzLCAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX2ZyZWVic2QgfHwgX29wZW5ic2QgfHwgX25ldGJzZCkge1xuICAgICAgICBleGVjKCd3aG87IGVjaG8gXCItLS1cIjsgdyAtaWgnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGxpbmVzIC8gc3BsaXRcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVXNlcnNEYXJ3aW4obGluZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3N1bm9zKSB7XG4gICAgICAgIGV4ZWMoJ3dobzsgZWNobyBcIi0tLVwiOyB3IC1oJywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAvLyBsaW5lcyAvIHNwbGl0XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJzZVVzZXJzRGFyd2luKGxpbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKHJlc3VsdCk7IH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2Rhcndpbikge1xuICAgICAgICBleGVjKCd3aG87IGVjaG8gXCItLS1cIjsgdyAtaWgnLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGxpbmVzIC8gc3BsaXRcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlVXNlcnNEYXJ3aW4obGluZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgY21kID0gJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Mb2dvblNlc3Npb24gfCBzZWxlY3QgTG9nb25JZCxAe249XCJTdGFydFRpbWVcIjtlPXskXy5TdGFydFRpbWUuVG9TdHJpbmcoXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXCIpfX0gfCBmbCcgKyAnOyBlY2hvIFxcJyMtIy0jLSNcXCc7JztcbiAgICAgICAgICBjbWQgKz0gJ0dldC1DaW1JbnN0YW5jZSBXaW4zMl9Mb2dnZWRPblVzZXIgfCBzZWxlY3QgYW50ZWNlZGVudCxkZXBlbmRlbnQgfCBmbCAnICsgJzsgZWNobyBcXCcjLSMtIy0jXFwnOyc7XG4gICAgICAgICAgY21kICs9ICckcHJvY2VzcyA9IChHZXQtQ2ltSW5zdGFuY2UgV2luMzJfUHJvY2VzcyAtRmlsdGVyIFwibmFtZSA9IFxcJ2V4cGxvcmVyLmV4ZVxcJ1wiKTsgSW52b2tlLUNpbU1ldGhvZCAtSW5wdXRPYmplY3QgJHByb2Nlc3NbMF0gLU1ldGhvZE5hbWUgR2V0T3duZXIgfCBzZWxlY3QgdXNlciwgZG9tYWluIHwgZmw7IGdldC1wcm9jZXNzIC1uYW1lIGV4cGxvcmVyIHwgc2VsZWN0LW9iamVjdCBzZXNzaW9uaWQgfCBmbDsgZWNobyBcXCcjLSMtIy0jXFwnOyc7XG4gICAgICAgICAgY21kICs9ICdxdWVyeSB1c2VyJztcbiAgICAgICAgICB1dGlsLnBvd2VyU2hlbGwoY21kKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnIy0jLSMtIycpO1xuICAgICAgICAgICAgICBsZXQgc2Vzc2lvbnMgPSBwYXJzZVdpblNlc3Npb25zKChkYXRhWzBdIHx8ICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pKTtcbiAgICAgICAgICAgICAgbGV0IGxvZ2dlZG9ucyA9IHBhcnNlV2luTG9nZ2VkT24oKGRhdGFbMV0gfHwgJycpLnNwbGl0KC9cXG5cXHMqXFxuLykpO1xuICAgICAgICAgICAgICBsZXQgcXVlcnlVc2VyID0gcGFyc2VXaW5Vc2Vyc1F1ZXJ5KChkYXRhWzNdIHx8ICcnKS5zcGxpdCgnXFxyXFxuJykpO1xuICAgICAgICAgICAgICBsZXQgdXNlcnMgPSBwYXJzZVdpblVzZXJzKChkYXRhWzJdIHx8ICcnKS5zcGxpdCgvXFxuXFxzKlxcbi8pLCBxdWVyeVVzZXIpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBsb2dnZWRvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChsb2dnZWRvbnMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgbG9nZ2Vkb25zW2lkXS5kYXRlVGltZSA9IHt9Lmhhc093blByb3BlcnR5LmNhbGwoc2Vzc2lvbnMsIGlkKSA/IHNlc3Npb25zW2lkXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1c2Vycy5mb3JFYWNoKHVzZXIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkYXRlVGltZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGlkIGluIGxvZ2dlZG9ucykge1xuICAgICAgICAgICAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwobG9nZ2Vkb25zLCBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2dlZG9uc1tpZF0udXNlciA9PT0gdXNlci51c2VyICYmICghZGF0ZVRpbWUgfHwgZGF0ZVRpbWUgPCBsb2dnZWRvbnNbaWRdLmRhdGVUaW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGVUaW1lID0gbG9nZ2Vkb25zW2lkXS5kYXRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHVzZXI6IHVzZXIudXNlcixcbiAgICAgICAgICAgICAgICAgIHR0eTogdXNlci50dHksXG4gICAgICAgICAgICAgICAgICBkYXRlOiBgJHtkYXRlVGltZS5zdWJzdHJpbmcoMCwgMTApfWAsXG4gICAgICAgICAgICAgICAgICB0aW1lOiBgJHtkYXRlVGltZS5zdWJzdHJpbmcoMTEsIDE5KX1gLFxuICAgICAgICAgICAgICAgICAgaXA6ICcnLFxuICAgICAgICAgICAgICAgICAgY29tbWFuZDogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5TZXNzaW9ucyhzZXNzaW9uUGFydHMpIHtcbiAgY29uc3Qgc2Vzc2lvbnMgPSB7fTtcbiAgc2Vzc2lvblBhcnRzLmZvckVhY2goc2Vzc2lvbiA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBzZXNzaW9uLnNwbGl0KCdcXHJcXG4nKTtcbiAgICBjb25zdCBpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdMb2dvbklkJyk7XG4gICAgY29uc3Qgc3RhcnR0aW1lID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3N0YXJ0dGltZScpO1xuICAgIGlmIChpZCkge1xuICAgICAgc2Vzc2lvbnNbaWRdID0gc3RhcnR0aW1lO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXNzaW9ucztcbn1cblxuZnVuY3Rpb24gZnV6enlNYXRjaChuYW1lMSwgbmFtZTIpIHtcbiAgbmFtZTEgPSBuYW1lMS50b0xvd2VyQ2FzZSgpO1xuICBuYW1lMiA9IG5hbWUyLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBlcSA9IDA7XG4gIGxldCBsZW4gPSBuYW1lMS5sZW5ndGg7XG4gIGlmIChuYW1lMi5sZW5ndGggPiBsZW4pIHsgbGVuID0gbmFtZTIubGVuZ3RoOyB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGMxID0gbmFtZTFbaV0gfHwgJyc7XG4gICAgY29uc3QgYzIgPSBuYW1lMltpXSB8fCAnJztcbiAgICBpZiAoYzEgPT09IGMyKSB7IGVxKys7IH1cbiAgfVxuICByZXR1cm4gKGxlbiA+IDEwID8gZXEgLyBsZW4gPiAwLjkgOiAobGVuID4gMCA/IGVxIC8gbGVuID4gMC44IDogZmFsc2UpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaW5Vc2Vycyh1c2VyUGFydHMsIHVzZXJRdWVyeSkge1xuICBjb25zdCB1c2VycyA9IFtdO1xuICB1c2VyUGFydHMuZm9yRWFjaCh1c2VyID0+IHtcbiAgICBjb25zdCBsaW5lcyA9IHVzZXIuc3BsaXQoJ1xcclxcbicpO1xuXG4gICAgY29uc3QgZG9tYWluID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2RvbWFpbicsICc6JywgdHJ1ZSk7XG4gICAgY29uc3QgdXNlcm5hbWUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAndXNlcicsICc6JywgdHJ1ZSk7XG4gICAgY29uc3Qgc2Vzc2lvbmlkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ3Nlc3Npb25pZCcsICc6JywgdHJ1ZSk7XG5cbiAgICBpZiAodXNlcm5hbWUpIHtcbiAgICAgIGNvbnN0IHF1c2VyID0gdXNlclF1ZXJ5LmZpbHRlcihpdGVtID0+IGZ1enp5TWF0Y2goaXRlbS51c2VyLCB1c2VybmFtZSkpO1xuICAgICAgdXNlcnMucHVzaCh7XG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgdXNlcjogdXNlcm5hbWUsXG4gICAgICAgIHR0eTogcXVzZXIgJiYgcXVzZXJbMF0gJiYgcXVzZXJbMF0udHR5ID8gcXVzZXJbMF0udHR5IDogc2Vzc2lvbmlkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXNlcnM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2luTG9nZ2VkT24obG9nZ2Vkb25QYXJ0cykge1xuICBjb25zdCBsb2dnZWRvbnMgPSB7fTtcbiAgbG9nZ2Vkb25QYXJ0cy5mb3JFYWNoKGxvZ2dlZG9uID0+IHtcbiAgICBjb25zdCBsaW5lcyA9IGxvZ2dlZG9uLnNwbGl0KCdcXHJcXG4nKTtcblxuICAgIGNvbnN0IGFudGVjZW5kZW50ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2FudGVjZWRlbnQnLCAnOicsIHRydWUpO1xuICAgIGxldCBwYXJ0cyA9IGFudGVjZW5kZW50LnNwbGl0KCc9Jyk7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1sxXS5zcGxpdCgnLCcpWzBdLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCkgOiAnJztcbiAgICBjb25zdCBkb21haW4gPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0ucmVwbGFjZSgvXCIvZywgJycpLnJlcGxhY2UoL1xcKS9nLCAnJykudHJpbSgpIDogJyc7XG4gICAgY29uc3QgZGVwZW5kZW50ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2RlcGVuZGVudCcsICc6JywgdHJ1ZSk7XG4gICAgcGFydHMgPSBkZXBlbmRlbnQuc3BsaXQoJz0nKTtcbiAgICBjb25zdCBpZCA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgvXFwpL2csICcnKS50cmltKCkgOiAnJztcbiAgICBpZiAoaWQpIHtcbiAgICAgIGxvZ2dlZG9uc1tpZF0gPSB7XG4gICAgICAgIGRvbWFpbixcbiAgICAgICAgdXNlcjogbmFtZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbG9nZ2Vkb25zO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpblVzZXJzUXVlcnkobGluZXMpIHtcbiAgbGluZXMgPSBsaW5lcy5maWx0ZXIoaXRlbSA9PiBpdGVtKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBoZWFkZXIgPSBsaW5lc1swXTtcbiAgY29uc3QgaGVhZGVyRGVsaW1pdGVyID0gW107XG4gIGlmIChoZWFkZXIpIHtcbiAgICBjb25zdCBzdGFydCA9IChoZWFkZXJbMF0gPT09ICcgJykgPyAxIDogMDtcbiAgICBoZWFkZXJEZWxpbWl0ZXIucHVzaChzdGFydCAtIDEpO1xuICAgIGxldCBuZXh0U3BhY2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDE7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoZWFkZXJbaV0gPT09ICcgJyAmJiAoKGhlYWRlcltpIC0gMV0gPT09ICcgJykgfHwgKGhlYWRlcltpIC0gMV0gPT09ICcuJykpKSB7XG4gICAgICAgIG5leHRTcGFjZSA9IGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV4dFNwYWNlKSB7XG4gICAgICAgICAgaGVhZGVyRGVsaW1pdGVyLnB1c2gobmV4dFNwYWNlKTtcbiAgICAgICAgICBuZXh0U3BhY2UgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaW5lc1tpXS50cmltKCkpIHtcbiAgICAgICAgY29uc3QgdXNlciA9IGxpbmVzW2ldLnN1YnN0cmluZyhoZWFkZXJEZWxpbWl0ZXJbMF0gKyAxLCBoZWFkZXJEZWxpbWl0ZXJbMV0pLnRyaW0oKSB8fCAnJztcbiAgICAgICAgY29uc3QgdHR5ID0gbGluZXNbaV0uc3Vic3RyaW5nKGhlYWRlckRlbGltaXRlclsxXSArIDEsIGhlYWRlckRlbGltaXRlclsyXSAtIDIpLnRyaW0oKSB8fCAnJztcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgdHR5OiB0dHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLnVzZXJzID0gdXNlcnM7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHV0aWxzLmpzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZXNjcmlwdGlvbjogICBTeXN0ZW0gSW5mb3JtYXRpb24gLSBsaWJyYXJ5XG4vLyAgICAgICAgICAgICAgICBmb3IgTm9kZS5qc1xuLy8gQ29weXJpZ2h0OiAgICAgKGMpIDIwMTQgLSAyMDIzXG4vLyBBdXRob3I6ICAgICAgICBTZWJhc3RpYW4gSGlsZGVicmFuZHRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExpY2Vuc2U6ICAgICAgIE1JVFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gMC4gaGVscGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5jb25zdCBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG5jb25zdCBleGVjU3luYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuY29uc3QgX2xpbnV4ID0gKF9wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBfcGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBfZGFyd2luID0gKF9wbGF0Zm9ybSA9PT0gJ2RhcndpbicpO1xuY29uc3QgX3dpbmRvd3MgPSAoX3BsYXRmb3JtID09PSAnd2luMzInKTtcbmNvbnN0IF9mcmVlYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKTtcbmNvbnN0IF9vcGVuYnNkID0gKF9wbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKTtcbmNvbnN0IF9uZXRic2QgPSAoX3BsYXRmb3JtID09PSAnbmV0YnNkJyk7XG5cbmxldCBfY29yZXMgPSAwO1xubGV0IHdtaWNQYXRoID0gJyc7XG5sZXQgY29kZXBhZ2UgPSAnJztcbmxldCBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IG51bGw7XG5cbmNvbnN0IFdJTkRJUiA9IHByb2Nlc3MuZW52LldJTkRJUiB8fCAnQzpcXFxcV2luZG93cyc7XG5cbi8vIHBvd2VyU2hlbGxcbmxldCBfcHNDaGlsZDtcbmxldCBfcHNSZXN1bHQgPSAnJztcbmxldCBfcHNDbWRzID0gW107XG5sZXQgX3BzUGVyc2lzdGVudCA9IGZhbHNlO1xuY29uc3QgX3BzVG9VVEY4ID0gJyRPdXRwdXRFbmNvZGluZyA9IFtTeXN0ZW0uQ29uc29sZV06Ok91dHB1dEVuY29kaW5nID0gW1N5c3RlbS5Db25zb2xlXTo6SW5wdXRFbmNvZGluZyA9IFtTeXN0ZW0uVGV4dC5FbmNvZGluZ106OlVURjggOyAnO1xuY29uc3QgX3BzQ21kU3RhcnQgPSAnLS0jIyNTVEFSVCMjIy0tJztcbmNvbnN0IF9wc0Vycm9yID0gJy0tRVJST1ItLSc7XG5jb25zdCBfcHNDbWRTZXBlcmF0b3IgPSAnLS0jIyNFTkRDTUQjIyMtLSc7XG5jb25zdCBfcHNJZFNlcGVyYXRvciA9ICctLSMjSUQjIy0tJztcblxuY29uc3QgZXhlY09wdHNXaW4gPSB7XG4gIHdpbmRvd3NIaWRlOiB0cnVlLFxuICBtYXhCdWZmZXI6IDEwMjQgKiAyMDAwMCxcbiAgZW5jb2Rpbmc6ICdVVEYtOCcsXG4gIGVudjogdXRpbC5fZXh0ZW5kKHt9LCBwcm9jZXNzLmVudiwgeyBMQU5HOiAnZW5fVVMuVVRGLTgnIH0pXG59O1xuXG5mdW5jdGlvbiB0b0ludCh2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuY29uc3Qgc3RyaW5nUmVwbGFjZSA9IG5ldyBTdHJpbmcoKS5yZXBsYWNlO1xuY29uc3Qgc3RyaW5nVG9Mb3dlciA9IG5ldyBTdHJpbmcoKS50b0xvd2VyQ2FzZTtcbmNvbnN0IHN0cmluZ1RvU3RyaW5nID0gbmV3IFN0cmluZygpLnRvU3RyaW5nO1xuY29uc3Qgc3RyaW5nU3Vic3RyID0gbmV3IFN0cmluZygpLnN1YnN0cjtcbmNvbnN0IHN0cmluZ1RyaW0gPSBuZXcgU3RyaW5nKCkudHJpbTtcbmNvbnN0IHN0cmluZ1N0YXJ0V2l0aCA9IG5ldyBTdHJpbmcoKS5zdGFydHNXaXRoO1xuY29uc3QgbWF0aE1pbiA9IE1hdGgubWluO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICBsZXQgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiB1bmlxdWUob2JqKSB7XG4gIGxldCB1bmlxdWVzID0gW107XG4gIGxldCBzdHJpbmdpZnkgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9ialtpXSk7XG4gICAga2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KGtleXNbal0pO1xuICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9ialtpXVtrZXlzW2pdXSk7XG4gICAgfVxuICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChzdHJpbmdpZnksIHN0cikpIHtcbiAgICAgIHVuaXF1ZXMucHVzaChvYmpbaV0pO1xuICAgICAgc3RyaW5naWZ5W3N0cl0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pcXVlcztcbn1cblxuZnVuY3Rpb24gc29ydEJ5S2V5KGFycmF5LCBrZXlzKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbGV0IHggPSAnJztcbiAgICBsZXQgeSA9ICcnO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB4ID0geCArIGFba2V5XTsgeSA9IHkgKyBiW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb3JlcygpIHtcbiAgaWYgKF9jb3JlcyA9PT0gMCkge1xuICAgIF9jb3JlcyA9IG9zLmNwdXMoKS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIF9jb3Jlcztcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUobGluZXMsIHByb3BlcnR5LCBzZXBhcmF0b3IsIHRyaW1tZWQsIGxpbmVNYXRjaCkge1xuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJzonO1xuICBwcm9wZXJ0eSA9IHByb3BlcnR5LnRvTG93ZXJDYXNlKCk7XG4gIHRyaW1tZWQgPSB0cmltbWVkIHx8IGZhbHNlO1xuICBsaW5lTWF0Y2ggPSBsaW5lTWF0Y2ggfHwgZmFsc2U7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIGxldCBsaW5lTG93ZXIgPSBsaW5lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFx0L2csICcnKTtcbiAgICBpZiAodHJpbW1lZCkge1xuICAgICAgbGluZUxvd2VyID0gbGluZUxvd2VyLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGxpbmVMb3dlci5zdGFydHNXaXRoKHByb3BlcnR5KSAmJiAobGluZU1hdGNoID8gKGxpbmVMb3dlci5tYXRjaChwcm9wZXJ0eSArIHNlcGFyYXRvcikpIHx8IChsaW5lTG93ZXIubWF0Y2gocHJvcGVydHkgKyAnICcgKyBzZXBhcmF0b3IpKSA6IHRydWUpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRyaW1tZWQgPyBsaW5lLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpIDogbGluZS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdCA9IHBhcnRzLmpvaW4oc2VwYXJhdG9yKS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXNjYXBlU2VxdWVuY2Uoc3RyLCBiYXNlKSB7XG4gIGJhc2UgPSBiYXNlIHx8IDE2O1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFx4KFswLTlBLUZhLWZdezJ9KS9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYXJndW1lbnRzWzFdLCBiYXNlKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RTcGxpdChzdHIpIHtcbiAgbGV0IHNlcGVyYXRvciA9ICcnO1xuICBsZXQgcGFydCA9IDA7XG4gIHN0ci5zcGxpdCgnJykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudCA+PSAnMCcgJiYgZWxlbWVudCA8PSAnOScpIHtcbiAgICAgIGlmIChwYXJ0ID09PSAxKSB7IHBhcnQrKzsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFydCA9PT0gMCkgeyBwYXJ0Kys7IH1cbiAgICAgIGlmIChwYXJ0ID09PSAxKSB7XG4gICAgICAgIHNlcGVyYXRvciArPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXBlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0LCBwbURlc2lnbmF0b3IpIHtcbiAgcG1EZXNpZ25hdG9yID0gcG1EZXNpZ25hdG9yIHx8ICcnO1xuICB0ID0gdC50b1VwcGVyQ2FzZSgpO1xuICBsZXQgaG91ciA9IDA7XG4gIGxldCBtaW4gPSAwO1xuICBsZXQgc3BsaXR0ZXIgPSBkZXRlY3RTcGxpdCh0KTtcbiAgbGV0IHBhcnRzID0gdC5zcGxpdChzcGxpdHRlcik7XG4gIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChwYXJ0c1syXSkge1xuICAgICAgcGFydHNbMV0gKz0gcGFydHNbMl07XG4gICAgfVxuICAgIGxldCBpc1BNID0gKHBhcnRzWzFdICYmIChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3BtJykgPiAtMSkgfHwgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigncC5tLicpID4gLTEpIHx8IChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3AuIG0uJykgPiAtMSkgfHwgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbicpID4gLTEpIHx8IChwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2NoJykgPiAtMSkgfHwgKHBhcnRzWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignw7ZzJykgPiAtMSkgfHwgKHBtRGVzaWduYXRvciAmJiBwYXJ0c1sxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocG1EZXNpZ25hdG9yKSA+IC0xKSk7XG4gICAgaG91ciA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gICAgbWluID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICBob3VyID0gaXNQTSAmJiBob3VyIDwgMTIgPyBob3VyICsgMTIgOiBob3VyO1xuICAgIHJldHVybiAoJzAnICsgaG91cikuc3Vic3RyKC0yKSArICc6JyArICgnMCcgKyBtaW4pLnN1YnN0cigtMik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlVGltZShkdCwgY3VsdHVyZSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZGF0ZTogJycsXG4gICAgdGltZTogJydcbiAgfTtcbiAgY3VsdHVyZSA9IGN1bHR1cmUgfHwge307XG4gIGxldCBkYXRlRm9ybWF0ID0gKGN1bHR1cmUuZGF0ZUZvcm1hdCB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHBtRGVzaWduYXRvciA9IChjdWx0dXJlLnBtRGVzaWduYXRvciB8fCAnJyk7XG5cbiAgY29uc3QgcGFydHMgPSBkdC5zcGxpdCgnICcpO1xuICBpZiAocGFydHNbMF0pIHtcbiAgICBpZiAocGFydHNbMF0uaW5kZXhPZignLycpID49IDApIHtcbiAgICAgIC8vIERhdGVmb3JtYXQ6IG1tL2RkL3l5eXkgb3IgZGQvbW0veXl5eSBvciBkZC9tbS95eSBvciB5eXl5L21tL2RkXG4gICAgICBjb25zdCBkdHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcbiAgICAgIGlmIChkdHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBpZiAoZHRwYXJ0c1swXS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAvLyBEYXRlZm9ybWF0OiB5eXl5L21tL2RkXG4gICAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzBdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1syXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgfSBlbHNlIGlmIChkdHBhcnRzWzJdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGlmICgoZGF0ZUZvcm1hdC5pbmRleE9mKCcvZC8nKSA+IC0xIHx8IGRhdGVGb3JtYXQuaW5kZXhPZignL2RkLycpID4gLTEpKSB7XG4gICAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBtbS9kZC95eVxuICAgICAgICAgICAgcmVzdWx0LmRhdGUgPSAnMjAnICsgZHRwYXJ0c1syXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERhdGVmb3JtYXQ6IGRkL21tL3l5XG4gICAgICAgICAgICByZXN1bHQuZGF0ZSA9ICcyMCcgKyBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGF0ZWZvcm1hdDogbW0vZGQveXl5eSBvciBkZC9tbS95eXl5XG4gICAgICAgICAgY29uc3QgaXNFTiA9ICgoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwbScpID4gLTEpIHx8IChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3AubS4nKSA+IC0xKSB8fCAoZHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwLiBtLicpID4gLTEpIHx8IChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2FtJykgPiAtMSkgfHwgKGR0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYS5tLicpID4gLTEpIHx8IChkdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2EuIG0uJykgPiAtMSkpO1xuICAgICAgICAgIGlmICgoaXNFTiB8fCBkYXRlRm9ybWF0LmluZGV4T2YoJy9kLycpID4gLTEgfHwgZGF0ZUZvcm1hdC5pbmRleE9mKCcvZGQvJykgPiAtMSkgJiYgZGF0ZUZvcm1hdC5pbmRleE9mKCdkZC8nKSAhPT0gMCkge1xuICAgICAgICAgICAgLy8gRGF0ZWZvcm1hdDogbW0vZGQveXl5eVxuICAgICAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGF0ZWZvcm1hdDogZGQvbW0veXl5eVxuICAgICAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRzWzBdLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICBjb25zdCBkdHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy4nKTtcbiAgICAgIGlmIChkdHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBpZiAoZGF0ZUZvcm1hdC5pbmRleE9mKCcuZC4nKSA+IC0xIHx8IGRhdGVGb3JtYXQuaW5kZXhPZignLmRkLicpID4gLTEpIHtcbiAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBtbS5kZC55eXl5XG4gICAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMF0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1sxXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEYXRlZm9ybWF0OiBkZC5tbS55eXl5XG4gICAgICAgICAgcmVzdWx0LmRhdGUgPSBkdHBhcnRzWzJdICsgJy0nICsgKCcwJyArIGR0cGFydHNbMV0pLnN1YnN0cigtMikgKyAnLScgKyAoJzAnICsgZHRwYXJ0c1swXSkuc3Vic3RyKC0yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFydHNbMF0uaW5kZXhPZignLScpID49IDApIHtcbiAgICAgIC8vIERhdGVmb3JtYXQ6IHl5eXktbW0tZGRcbiAgICAgIGNvbnN0IGR0cGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLScpO1xuICAgICAgaWYgKGR0cGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJlc3VsdC5kYXRlID0gZHRwYXJ0c1swXSArICctJyArICgnMCcgKyBkdHBhcnRzWzFdKS5zdWJzdHIoLTIpICsgJy0nICsgKCcwJyArIGR0cGFydHNbMl0pLnN1YnN0cigtMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXJ0c1sxXSkge1xuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgbGV0IHRpbWUgPSBwYXJ0cy5qb2luKCcgJyk7XG4gICAgcmVzdWx0LnRpbWUgPSBwYXJzZVRpbWUodGltZSwgcG1EZXNpZ25hdG9yKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWQoaGVhZCwgcmlnaHRzKSB7XG4gIGxldCBzcGFjZSA9IChyaWdodHMgPiAwKTtcbiAgbGV0IGNvdW50ID0gMTtcbiAgbGV0IGZyb20gPSAwO1xuICBsZXQgdG8gPSAwO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb3VudCA8PSByaWdodHMpIHtcbiAgICAgIGlmICgvXFxzLy50ZXN0KGhlYWRbaV0pICYmICFzcGFjZSkge1xuICAgICAgICB0byA9IGkgLSAxO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICB0bzogdG8gKyAxLFxuICAgICAgICAgIGNhcDogaGVhZC5zdWJzdHJpbmcoZnJvbSwgdG8gKyAxKVxuICAgICAgICB9KTtcbiAgICAgICAgZnJvbSA9IHRvICsgMjtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH1cbiAgICAgIHNwYWNlID0gaGVhZFtpXSA9PT0gJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIS9cXHMvLnRlc3QoaGVhZFtpXSkgJiYgc3BhY2UpIHtcbiAgICAgICAgdG8gPSBpIC0gMTtcbiAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICBjYXA6IGhlYWQuc3Vic3RyaW5nKGZyb20sIHRvKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZyb20gPSB0byArIDE7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBzcGFjZSA9IGhlYWRbaV0gPT09ICcgJztcbiAgICB9XG4gIH1cbiAgdG8gPSA1MDAwO1xuICByZXN1bHQucHVzaCh7XG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogdG8sXG4gICAgY2FwOiBoZWFkLnN1YnN0cmluZyhmcm9tLCB0bylcbiAgfSk7XG4gIGxldCBsZW4gPSByZXN1bHQubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHJlc3VsdFtpXS5jYXAucmVwbGFjZSgvXFxzL2csICcnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICByZXN1bHRbaV0udG8gPSByZXN1bHRbaSArIDFdLnRvO1xuICAgICAgICByZXN1bHRbaV0uY2FwID0gcmVzdWx0W2ldLmNhcCArIHJlc3VsdFtpICsgMV0uY2FwO1xuICAgICAgICByZXN1bHQuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgbGVuID0gbGVuIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZmluZE9iamVjdEJ5S2V5KGFycmF5LCBrZXksIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV1ba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldFdtaWMoKSB7XG4gIGlmIChvcy50eXBlKCkgPT09ICdXaW5kb3dzX05UJyAmJiAhd21pY1BhdGgpIHtcbiAgICB3bWljUGF0aCA9IFdJTkRJUiArICdcXFxcc3lzdGVtMzJcXFxcd2JlbVxcXFx3bWljLmV4ZSc7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHdtaWNQYXRoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgd21pY1BhdGhBcnJheSA9IGV4ZWNTeW5jKCdXSEVSRSBXTUlDJywgZXhlY09wdHNXaW4pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICBpZiAod21pY1BhdGhBcnJheSAmJiB3bWljUGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIHdtaWNQYXRoID0gd21pY1BhdGhBcnJheVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3bWljUGF0aCA9ICd3bWljJztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3bWljUGF0aCA9ICd3bWljJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdtaWNQYXRoO1xufVxuXG5mdW5jdGlvbiB3bWljKGNvbW1hbmQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBwb3dlclNoZWxsKGdldFdtaWMoKSArICcgJyArIGNvbW1hbmQpLnRoZW4oc3Rkb3V0ID0+IHtcbiAgICAgICAgICByZXNvbHZlKHN0ZG91dCwgJycpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVzb2x2ZSgnJywgZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRWYm94bWFuYWdlKCkge1xuICByZXR1cm4gX3dpbmRvd3MgPyBgXCIke3Byb2Nlc3MuZW52LlZCT1hfSU5TVEFMTF9QQVRIIHx8IHByb2Nlc3MuZW52LlZCT1hfTVNJX0lOU1RBTExfUEFUSH1cXFxcVkJveE1hbmFnZS5leGVcImAgOiAndmJveG1hbmFnZSc7XG59XG5cbmZ1bmN0aW9uIHBvd2VyU2hlbGxQcm9jZWVkUmVzdWx0cyhkYXRhKSB7XG4gIGxldCBpZCA9ICcnO1xuICBsZXQgcGFydHM7XG4gIGxldCByZXMgPSAnJztcbiAgLy8gc3RhcnRJRFxuICBpZiAoZGF0YS5pbmRleE9mKF9wc0NtZFN0YXJ0KSA+PSAwKSB7XG4gICAgcGFydHMgPSBkYXRhLnNwbGl0KF9wc0NtZFN0YXJ0KTtcbiAgICBjb25zdCBwYXJ0czIgPSBwYXJ0c1sxXS5zcGxpdChfcHNJZFNlcGVyYXRvcik7XG4gICAgaWQgPSBwYXJ0czJbMF07XG4gICAgaWYgKHBhcnRzMi5sZW5ndGggPiAxKSB7XG4gICAgICBkYXRhID0gcGFydHMyLnNsaWNlKDEpLmpvaW4oX3BzSWRTZXBlcmF0b3IpO1xuICAgIH1cbiAgfVxuICAvLyByZXN1bHQ7XG4gIGlmIChkYXRhLmluZGV4T2YoX3BzQ21kU2VwZXJhdG9yKSA+PSAwKSB7XG4gICAgcGFydHMgPSBkYXRhLnNwbGl0KF9wc0NtZFNlcGVyYXRvcik7XG4gICAgcmVzID0gcGFydHNbMF07XG4gIH1cbiAgbGV0IHJlbW92ZSA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IF9wc0NtZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoX3BzQ21kc1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgIHJlbW92ZSA9IGk7XG4gICAgICBfcHNDbWRzW2ldLmNhbGxiYWNrKHJlcyk7XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmUgPj0gMCkge1xuICAgIF9wc0NtZHMuc3BsaWNlKHJlbW92ZSwgMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG93ZXJTaGVsbFN0YXJ0KCkge1xuICBpZiAoIV9wc0NoaWxkKSB7XG4gICAgX3BzQ2hpbGQgPSBzcGF3bigncG93ZXJzaGVsbC5leGUnLCBbJy1Ob0xvZ28nLCAnLUlucHV0Rm9ybWF0JywgJ1RleHQnLCAnLU5vRXhpdCcsICctQ29tbWFuZCcsICctJ10sIHtcbiAgICAgIHN0ZGlvOiAncGlwZScsXG4gICAgICB3aW5kb3dzSGlkZTogdHJ1ZSxcbiAgICAgIG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwLFxuICAgICAgZW5jb2Rpbmc6ICdVVEYtOCcsXG4gICAgICBlbnY6IHV0aWwuX2V4dGVuZCh7fSwgcHJvY2Vzcy5lbnYsIHsgTEFORzogJ2VuX1VTLlVURi04JyB9KVxuICAgIH0pO1xuICAgIGlmIChfcHNDaGlsZCAmJiBfcHNDaGlsZC5waWQpIHtcbiAgICAgIF9wc1BlcnNpc3RlbnQgPSB0cnVlO1xuICAgICAgX3BzQ2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX3BzUmVzdWx0ID0gX3BzUmVzdWx0ICsgZGF0YS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICBpZiAoZGF0YS5pbmRleE9mKF9wc0NtZFNlcGVyYXRvcikgPj0gMCkge1xuICAgICAgICAgIHBvd2VyU2hlbGxQcm9jZWVkUmVzdWx0cyhfcHNSZXN1bHQpO1xuICAgICAgICAgIF9wc1Jlc3VsdCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9wc0NoaWxkLnN0ZGVyci5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG93ZXJTaGVsbFByb2NlZWRSZXN1bHRzKF9wc1Jlc3VsdCArIF9wc0Vycm9yKTtcbiAgICAgIH0pO1xuICAgICAgX3BzQ2hpbGQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwb3dlclNoZWxsUHJvY2VlZFJlc3VsdHMoX3BzUmVzdWx0ICsgX3BzRXJyb3IpO1xuICAgICAgfSk7XG4gICAgICBfcHNDaGlsZC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9wc0NoaWxkLmtpbGwoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3dlclNoZWxsUmVsZWFzZSgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoX3BzQ2hpbGQpIHtcbiAgICAgIF9wc0NoaWxkLnN0ZGluLndyaXRlKCdleGl0JyArIG9zLkVPTCk7XG4gICAgICBfcHNDaGlsZC5zdGRpbi5lbmQoKTtcbiAgICAgIF9wc1BlcnNpc3RlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoX3BzQ2hpbGQpIHsgX3BzQ2hpbGQua2lsbCgpOyB9XG4gIH1cbiAgX3BzQ2hpbGQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3dlclNoZWxsKGNtZCkge1xuXG4gIGlmIChfcHNQZXJzaXN0ZW50KSB7XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGRhdGEpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIF9wc0NtZHMucHVzaCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY21kLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSgpXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfcHNDaGlsZCAmJiBfcHNDaGlsZC5waWQpIHtcbiAgICAgICAgICAgIF9wc0NoaWxkLnN0ZGluLndyaXRlKF9wc1RvVVRGOCArICdlY2hvICcgKyBfcHNDbWRTdGFydCArIGlkICsgX3BzSWRTZXBlcmF0b3IgKyAnOyAnICsgb3MuRU9MICsgY21kICsgb3MuRU9MICsgJ2VjaG8gJyArIF9wc0NtZFNlcGVyYXRvciArIG9zLkVPTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzb2x2ZSgnJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH0gZWxzZSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHNwYXduKCdwb3dlcnNoZWxsLmV4ZScsIFsnLU5vTG9nbycsICctSW5wdXRGb3JtYXQnLCAnVGV4dCcsICctTm9FeGl0JywgJy1FeGVjdXRpb25Qb2xpY3knLCAnVW5yZXN0cmljdGVkJywgJy1Db21tYW5kJywgJy0nXSwge1xuICAgICAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlLFxuICAgICAgICAgICAgbWF4QnVmZmVyOiAxMDI0ICogMjAwMDAsXG4gICAgICAgICAgICBlbmNvZGluZzogJ1VURi04JyxcbiAgICAgICAgICAgIGVudjogdXRpbC5fZXh0ZW5kKHt9LCBwcm9jZXNzLmVudiwgeyBMQU5HOiAnZW5fVVMuVVRGLTgnIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQgJiYgIWNoaWxkLnBpZCkge1xuICAgICAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnBpZCkge1xuICAgICAgICAgICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgZGF0YS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcblxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2hpbGQua2lsbCgpO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNoaWxkLnN0ZGluLndyaXRlKF9wc1RvVVRGOCArIGNtZCArIG9zLkVPTCk7XG4gICAgICAgICAgICAgIGNoaWxkLnN0ZGluLndyaXRlKCdleGl0JyArIG9zLkVPTCk7XG4gICAgICAgICAgICAgIGNoaWxkLnN0ZGluLmVuZCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjaGlsZC5raWxsKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY1NhZmUoY21kLCBhcmdzLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHNwYXduKGNtZCwgYXJncywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKGNoaWxkICYmICFjaGlsZC5waWQpIHtcbiAgICAgICAgICBjaGlsZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnBpZCkge1xuICAgICAgICAgIGNoaWxkLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNoaWxkLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjaGlsZC5vbignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjaGlsZC5raWxsKCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldENvZGVwYWdlKCkge1xuICBpZiAoX3dpbmRvd3MpIHtcbiAgICBpZiAoIWNvZGVwYWdlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnY2hjcCcsIGV4ZWNPcHRzV2luKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3BsaXQoJzonKTtcbiAgICAgICAgY29kZXBhZ2UgPSBwYXJ0cy5sZW5ndGggPiAxID8gcGFydHNbMV0ucmVwbGFjZSgnLicsICcnKS50cmltKCkgOiAnJztcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb2RlcGFnZSA9ICc0MzcnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29kZXBhZ2U7XG4gIH1cbiAgaWYgKF9saW51eCB8fCBfZGFyd2luIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICBpZiAoIWNvZGVwYWdlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGRvdXQgPSBleGVjU3luYygnZWNobyAkTEFORycpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lc1swXS5zcGxpdCgnLicpO1xuICAgICAgICBjb2RlcGFnZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS50cmltKCkgOiAnJztcbiAgICAgICAgaWYgKCFjb2RlcGFnZSkge1xuICAgICAgICAgIGNvZGVwYWdlID0gJ1VURi04JztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvZGVwYWdlID0gJ1VURi04JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVwYWdlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNtYXJ0TW9uVG9vbHNJbnN0YWxsZWQoKSB7XG4gIGlmIChfc21hcnRNb25Ub29sc0luc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBfc21hcnRNb25Ub29sc0luc3RhbGxlZDtcbiAgfVxuICBfc21hcnRNb25Ub29sc0luc3RhbGxlZCA9IGZhbHNlO1xuICBpZiAoX3dpbmRvd3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF0aEFycmF5ID0gZXhlY1N5bmMoJ1dIRVJFIHNtYXJ0Y3RsIDI+bnVsJywgZXhlY09wdHNXaW4pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgaWYgKHBhdGhBcnJheSAmJiBwYXRoQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gcGF0aEFycmF5WzBdLmluZGV4T2YoJzpcXFxcJykgPj0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKF9saW51eCB8fCBfZGFyd2luIHx8IF9mcmVlYnNkIHx8IF9vcGVuYnNkIHx8IF9uZXRic2QpIHtcbiAgICBjb25zdCBwYXRoQXJyYXkgPSBleGVjU3luYygnd2hpY2ggc21hcnRjdGwgMj4vZGV2L251bGwnLCBleGVjT3B0c1dpbikudG9TdHJpbmcoKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQgPSBwYXRoQXJyYXkubGVuZ3RoID4gMDtcbiAgfVxuICByZXR1cm4gX3NtYXJ0TW9uVG9vbHNJbnN0YWxsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzUmFzcGJlcnJ5KCkge1xuICBjb25zdCBQSV9NT0RFTF9OTyA9IFtcbiAgICAnQkNNMjcwOCcsXG4gICAgJ0JDTTI3MDknLFxuICAgICdCQ00yNzEwJyxcbiAgICAnQkNNMjcxMScsXG4gICAgJ0JDTTI4MzUnLFxuICAgICdCQ00yODM2JyxcbiAgICAnQkNNMjgzNycsXG4gICAgJ0JDTTI4MzdCMCdcbiAgXTtcbiAgbGV0IGNwdWluZm8gPSBbXTtcbiAgdHJ5IHtcbiAgICBjcHVpbmZvID0gZnMucmVhZEZpbGVTeW5jKCcvcHJvYy9jcHVpbmZvJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhcmR3YXJlID0gZ2V0VmFsdWUoY3B1aW5mbywgJ2hhcmR3YXJlJyk7XG4gIHJldHVybiAoaGFyZHdhcmUgJiYgUElfTU9ERUxfTk8uaW5kZXhPZihoYXJkd2FyZSkgPiAtMSk7XG59XG5cbmZ1bmN0aW9uIGlzUmFzcGJpYW4oKSB7XG4gIGxldCBvc3JlbGVhc2UgPSBbXTtcbiAgdHJ5IHtcbiAgICBvc3JlbGVhc2UgPSBmcy5yZWFkRmlsZVN5bmMoJy9ldGMvb3MtcmVsZWFzZScsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpZCA9IGdldFZhbHVlKG9zcmVsZWFzZSwgJ2lkJywgJz0nKTtcbiAgcmV0dXJuIChpZCAmJiBpZC5pbmRleE9mKCdyYXNwYmlhbicpID4gLTEpO1xufVxuXG5mdW5jdGlvbiBleGVjV2luKGNtZCwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0gZXhlY09wdHNXaW47XG4gIH1cbiAgbGV0IG5ld0NtZCA9ICdjaGNwIDY1MDAxID4gbnVsICYmIGNtZCAvQyAnICsgY21kICsgJyAmJiBjaGNwICcgKyBjb2RlcGFnZSArICcgPiBudWwnO1xuICBleGVjKG5ld0NtZCwgb3B0cywgZnVuY3Rpb24gKGVycm9yLCBzdGRvdXQpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgc3Rkb3V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRhcndpblhjb2RlRXhpc3RzKCkge1xuICBjb25zdCBjbWRMaW5lVG9vbHNFeGlzdHMgPSBmcy5leGlzdHNTeW5jKCcvTGlicmFyeS9EZXZlbG9wZXIvQ29tbWFuZExpbmVUb29scy91c3IvYmluLycpO1xuICBjb25zdCB4Y29kZUFwcEV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy9BcHBsaWNhdGlvbnMvWGNvZGUuYXBwL0NvbnRlbnRzL0RldmVsb3Blci9Ub29scycpO1xuICBjb25zdCB4Y29kZUV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoJy9MaWJyYXJ5L0RldmVsb3Blci9YY29kZS8nKTtcbiAgcmV0dXJuIChjbWRMaW5lVG9vbHNFeGlzdHMgfHwgeGNvZGVFeGlzdHMgfHwgeGNvZGVBcHBFeGlzdHMpO1xufVxuXG5mdW5jdGlvbiBuYW5vU2Vjb25kcygpIHtcbiAgY29uc3QgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aW1lKSB8fCB0aW1lLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiArdGltZVswXSAqIDFlOSArICt0aW1lWzFdO1xufVxuXG5mdW5jdGlvbiBjb3VudFVuaXF1ZUxpbmVzKGxpbmVzLCBzdGFydGluZ1dpdGgpIHtcbiAgc3RhcnRpbmdXaXRoID0gc3RhcnRpbmdXaXRoIHx8ICcnO1xuICBjb25zdCB1bmlxdWVMaW5lcyA9IFtdO1xuICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoc3RhcnRpbmdXaXRoKSkge1xuICAgICAgaWYgKHVuaXF1ZUxpbmVzLmluZGV4T2YobGluZSkgPT09IC0xKSB7XG4gICAgICAgIHVuaXF1ZUxpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVuaXF1ZUxpbmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gY291bnRMaW5lcyhsaW5lcywgc3RhcnRpbmdXaXRoKSB7XG4gIHN0YXJ0aW5nV2l0aCA9IHN0YXJ0aW5nV2l0aCB8fCAnJztcbiAgY29uc3QgdW5pcXVlTGluZXMgPSBbXTtcbiAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICBpZiAobGluZS5zdGFydHNXaXRoKHN0YXJ0aW5nV2l0aCkpIHtcbiAgICAgIHVuaXF1ZUxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHVuaXF1ZUxpbmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemVTaGVsbFN0cmluZyhzdHIsIHN0cmljdCkge1xuICBpZiAodHlwZW9mIHN0cmljdCA9PT0gJ3VuZGVmaW5lZCcpIHsgc3RyaWN0ID0gZmFsc2U7IH1cbiAgY29uc3QgcyA9IHN0ciB8fCAnJztcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXRoTWluKHMubGVuZ3RoLCAyMDAwKTsgaSsrKSB7XG4gICAgaWYgKCEoc1tpXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBzW2ldID09PSAnPicgfHxcbiAgICAgIHNbaV0gPT09ICc8JyB8fFxuICAgICAgc1tpXSA9PT0gJyonIHx8XG4gICAgICBzW2ldID09PSAnPycgfHxcbiAgICAgIHNbaV0gPT09ICdbJyB8fFxuICAgICAgc1tpXSA9PT0gJ10nIHx8XG4gICAgICBzW2ldID09PSAnfCcgfHxcbiAgICAgIHNbaV0gPT09ICfLmicgfHxcbiAgICAgIHNbaV0gPT09ICckJyB8fFxuICAgICAgc1tpXSA9PT0gJzsnIHx8XG4gICAgICBzW2ldID09PSAnJicgfHxcbiAgICAgIHNbaV0gPT09ICcoJyB8fFxuICAgICAgc1tpXSA9PT0gJyknIHx8XG4gICAgICBzW2ldID09PSAnXScgfHxcbiAgICAgIHNbaV0gPT09ICcjJyB8fFxuICAgICAgc1tpXSA9PT0gJ1xcXFwnIHx8XG4gICAgICBzW2ldID09PSAnXFx0JyB8fFxuICAgICAgc1tpXSA9PT0gJ1xcbicgfHxcbiAgICAgIHNbaV0gPT09ICdcXCcnIHx8XG4gICAgICBzW2ldID09PSAnYCcgfHxcbiAgICAgIHNbaV0gPT09ICdcIicgfHxcbiAgICAgIHNbaV0ubGVuZ3RoID4gMSB8fFxuICAgICAgKHN0cmljdCAmJiBzW2ldID09PSAnQCcpIHx8XG4gICAgICAoc3RyaWN0ICYmIHNbaV0gPT09ICcgJykgfHxcbiAgICAgIChzdHJpY3QgJiYgc1tpXSA9PSAneycpIHx8XG4gICAgICAoc3RyaWN0ICYmIHNbaV0gPT0gJyknKSkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoKSB7XG4gIGNvbnN0IHMgPSAnMTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonO1xuICBsZXQgbm90UG9sbHV0ZWQgPSB0cnVlO1xuICBsZXQgc3QgPSAnJztcblxuICBzdC5fX3Byb3RvX18ucmVwbGFjZSA9IHN0cmluZ1JlcGxhY2U7XG4gIHN0Ll9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHN0cmluZ1RvTG93ZXI7XG4gIHN0Ll9fcHJvdG9fXy50b1N0cmluZyA9IHN0cmluZ1RvU3RyaW5nO1xuICBzdC5fX3Byb3RvX18uc3Vic3RyID0gc3RyaW5nU3Vic3RyO1xuXG4gIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgfHwgKHMubGVuZ3RoICE9PSA2Mik7XG4gIGNvbnN0IG1zID0gRGF0ZS5ub3coKTtcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ251bWJlcicgJiYgbXMgPiAxNjAwMDAwMDAwMDAwKSB7XG4gICAgY29uc3QgbCA9IG1zICUgMTAwICsgMTU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogNjEuOTk5OTk5OTkgKyAxO1xuICAgICAgY29uc3QgcnMgPSBwYXJzZUludChNYXRoLmZsb29yKHIpLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgIGNvbnN0IHJzMiA9IHBhcnNlSW50KHIudG9TdHJpbmcoKS5zcGxpdCgnLicpWzBdLCAxMCk7XG4gICAgICBjb25zdCBxID0gTWF0aC5yYW5kb20oKSAqIDYxLjk5OTk5OTk5ICsgMTtcbiAgICAgIGNvbnN0IHFzID0gcGFyc2VJbnQoTWF0aC5mbG9vcihxKS50b1N0cmluZygpLCAxMCk7XG4gICAgICBjb25zdCBxczIgPSBwYXJzZUludChxLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXSwgMTApO1xuICAgICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiAociAhPT0gcSk7XG4gICAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIHJzID09PSByczIgJiYgcXMgPT09IHFzMjtcbiAgICAgIHN0ICs9IHNbcnMgLSAxXTtcbiAgICB9XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzdC5sZW5ndGggPT09IGw7XG4gICAgLy8gc3RyaW5nIG1hbmlwdWxhdGlvblxuICAgIGxldCBwID0gTWF0aC5yYW5kb20oKSAqIGwgKiAwLjk5OTk5OTk5OTk7XG4gICAgbGV0IHN0bSA9IHN0LnN1YnN0cigwLCBwKSArICcgJyArIHN0LnN1YnN0cihwLCAyMDAwKTtcbiAgICBzdG0uX19wcm90b19fLnJlcGxhY2UgPSBzdHJpbmdSZXBsYWNlO1xuICAgIGxldCBzdG8gPSBzdG0ucmVwbGFjZSgvIC9nLCAnJyk7XG4gICAgbm90UG9sbHV0ZWQgPSBub3RQb2xsdXRlZCAmJiBzdCA9PT0gc3RvO1xuICAgIHAgPSBNYXRoLnJhbmRvbSgpICogbCAqIDAuOTk5OTk5OTk5OTtcbiAgICBzdG0gPSBzdC5zdWJzdHIoMCwgcCkgKyAneycgKyBzdC5zdWJzdHIocCwgMjAwMCk7XG4gICAgc3RvID0gc3RtLnJlcGxhY2UoL3svZywgJycpO1xuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgc3QgPT09IHN0bztcbiAgICBwID0gTWF0aC5yYW5kb20oKSAqIGwgKiAwLjk5OTk5OTk5OTk7XG4gICAgc3RtID0gc3Quc3Vic3RyKDAsIHApICsgJyonICsgc3Quc3Vic3RyKHAsIDIwMDApO1xuICAgIHN0byA9IHN0bS5yZXBsYWNlKC9cXCovZywgJycpO1xuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgc3QgPT09IHN0bztcbiAgICBwID0gTWF0aC5yYW5kb20oKSAqIGwgKiAwLjk5OTk5OTk5OTk7XG4gICAgc3RtID0gc3Quc3Vic3RyKDAsIHApICsgJyQnICsgc3Quc3Vic3RyKHAsIDIwMDApO1xuICAgIHN0byA9IHN0bS5yZXBsYWNlKC9cXCQvZywgJycpO1xuICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgc3QgPT09IHN0bztcblxuICAgIC8vIGxvd2VyXG4gICAgY29uc3Qgc3RsID0gc3QudG9Mb3dlckNhc2UoKTtcbiAgICBub3RQb2xsdXRlZCA9IG5vdFBvbGx1dGVkICYmIChzdGwubGVuZ3RoID09PSBsKSAmJiBzdGxbbCAtIDFdICYmICEoc3RsW2xdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgczEgPSBzdFtpXTtcbiAgICAgIHMxLl9fcHJvdG9fXy50b0xvd2VyQ2FzZSA9IHN0cmluZ1RvTG93ZXI7XG4gICAgICBjb25zdCBzMiA9IHN0bCA/IHN0bFtpXSA6ICcnO1xuICAgICAgY29uc3QgczFsID0gczEudG9Mb3dlckNhc2UoKTtcbiAgICAgIG5vdFBvbGx1dGVkID0gbm90UG9sbHV0ZWQgJiYgczFsWzBdID09PSBzMiAmJiBzMWxbMF0gJiYgIShzMWxbMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIW5vdFBvbGx1dGVkO1xufVxuXG5mdW5jdGlvbiBoZXgyYmluKGhleCkge1xuICByZXR1cm4gKCcwMDAwMDAwMCcgKyAocGFyc2VJbnQoaGV4LCAxNikpLnRvU3RyaW5nKDIpKS5zdWJzdHIoLTgpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxlc0luUGF0aChzb3VyY2UpIHtcbiAgY29uc3QgbHN0YXRTeW5jID0gZnMubHN0YXRTeW5jO1xuICBjb25zdCByZWFkZGlyU3luYyA9IGZzLnJlYWRkaXJTeW5jO1xuICBjb25zdCBqb2luID0gcGF0aC5qb2luO1xuXG4gIGZ1bmN0aW9uIGlzRGlyZWN0b3J5KHNvdXJjZSkge1xuICAgIHJldHVybiBsc3RhdFN5bmMoc291cmNlKS5pc0RpcmVjdG9yeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGlzRmlsZShzb3VyY2UpIHsgcmV0dXJuIGxzdGF0U3luYyhzb3VyY2UpLmlzRmlsZSgpOyB9XG5cbiAgZnVuY3Rpb24gZ2V0RGlyZWN0b3JpZXMoc291cmNlKSB7XG4gICAgcmV0dXJuIHJlYWRkaXJTeW5jKHNvdXJjZSkubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBqb2luKHNvdXJjZSwgbmFtZSk7IH0pLmZpbHRlcihpc0RpcmVjdG9yeSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmlsZXMoc291cmNlKSB7XG4gICAgcmV0dXJuIHJlYWRkaXJTeW5jKHNvdXJjZSkubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBqb2luKHNvdXJjZSwgbmFtZSk7IH0pLmZpbHRlcihpc0ZpbGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmlsZXNSZWN1cnNpdmVseShzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRpcnMgPSBnZXREaXJlY3Rvcmllcyhzb3VyY2UpO1xuICAgICAgbGV0IGZpbGVzID0gZGlyc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGdldEZpbGVzUmVjdXJzaXZlbHkoZGlyKTsgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0sIFtdKTtcbiAgICAgIHJldHVybiBmaWxlcy5jb25jYXQoZ2V0RmlsZXMoc291cmNlKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gZ2V0RmlsZXNSZWN1cnNpdmVseShzb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVQaUNwdWluZm8obGluZXMpIHtcblxuICAvLyBodHRwczovL3d3dy5yYXNwYmVycnlwaS5vcmcvZG9jdW1lbnRhdGlvbi9oYXJkd2FyZS9yYXNwYmVycnlwaS9yZXZpc2lvbi1jb2Rlcy9SRUFETUUubWRcblxuICBjb25zdCBvbGRSZXZpc2lvbkNvZGVzID0ge1xuICAgICcwMDAyJzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcxLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDAzJzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcxLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA0Jzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwNSc6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnUWlzZGEnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA2Jzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA3Jzoge1xuICAgICAgdHlwZTogJ0EnLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDA4Jzoge1xuICAgICAgdHlwZTogJ0EnLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwOSc6IHtcbiAgICAgIHR5cGU6ICdBJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnUWlzZGEnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDBkJzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFZ29tYW4nLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDBlJzoge1xuICAgICAgdHlwZTogJ0InLFxuICAgICAgcmV2aXNpb246ICcyLjAnLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdTb255IFVLJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAwZic6IHtcbiAgICAgIHR5cGU6ICdCJyxcbiAgICAgIHJldmlzaW9uOiAnMi4wJyxcbiAgICAgIG1lbW9yeTogNTEyLFxuICAgICAgbWFudWZhY3R1cmVyOiAnRWdvbWFuJyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfSxcbiAgICAnMDAxMCc6IHtcbiAgICAgIHR5cGU6ICdCKycsXG4gICAgICByZXZpc2lvbjogJzEuMicsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDExJzoge1xuICAgICAgdHlwZTogJ0NNMScsXG4gICAgICByZXZpc2lvbjogJzEuMCcsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ1NvbnkgVUsnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDEyJzoge1xuICAgICAgdHlwZTogJ0ErJyxcbiAgICAgIHJldmlzaW9uOiAnMS4xJyxcbiAgICAgIG1lbW9yeTogMjU2LFxuICAgICAgbWFudWZhY3R1cmVyOiAnU29ueSBVSycsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTMnOiB7XG4gICAgICB0eXBlOiAnQisnLFxuICAgICAgcmV2aXNpb246ICcxLjInLFxuICAgICAgbWVtb3J5OiA1MTIsXG4gICAgICBtYW51ZmFjdHVyZXI6ICdFbWJlc3QnLFxuICAgICAgcHJvY2Vzc29yOiAnQkNNMjgzNSdcbiAgICB9LFxuICAgICcwMDE0Jzoge1xuICAgICAgdHlwZTogJ0NNMScsXG4gICAgICByZXZpc2lvbjogJzEuMCcsXG4gICAgICBtZW1vcnk6IDUxMixcbiAgICAgIG1hbnVmYWN0dXJlcjogJ0VtYmVzdCcsXG4gICAgICBwcm9jZXNzb3I6ICdCQ00yODM1J1xuICAgIH0sXG4gICAgJzAwMTUnOiB7XG4gICAgICB0eXBlOiAnQSsnLFxuICAgICAgcmV2aXNpb246ICcxLjEnLFxuICAgICAgbWVtb3J5OiAyNTYsXG4gICAgICBtYW51ZmFjdHVyZXI6ICc1MTJNQlx0RW1iZXN0JyxcbiAgICAgIHByb2Nlc3NvcjogJ0JDTTI4MzUnXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHByb2Nlc3Nvckxpc3QgPSBbXG4gICAgJ0JDTTI4MzUnLFxuICAgICdCQ00yODM2JyxcbiAgICAnQkNNMjgzNycsXG4gICAgJ0JDTTI3MTEnLFxuICBdO1xuICBjb25zdCBtYW51ZmFjdHVyZXJMaXN0ID0gW1xuICAgICdTb255IFVLJyxcbiAgICAnRWdvbWFuJyxcbiAgICAnRW1iZXN0JyxcbiAgICAnU29ueSBKYXBhbicsXG4gICAgJ0VtYmVzdCcsXG4gICAgJ1N0YWRpdW0nXG4gIF07XG4gIGNvbnN0IHR5cGVMaXN0ID0ge1xuICAgICcwMCc6ICdBJyxcbiAgICAnMDEnOiAnQicsXG4gICAgJzAyJzogJ0ErJyxcbiAgICAnMDMnOiAnQisnLFxuICAgICcwNCc6ICcyQicsXG4gICAgJzA1JzogJ0FscGhhIChlYXJseSBwcm90b3R5cGUpJyxcbiAgICAnMDYnOiAnQ00xJyxcbiAgICAnMDgnOiAnM0InLFxuICAgICcwOSc6ICdaZXJvJyxcbiAgICAnMGEnOiAnQ00zJyxcbiAgICAnMGMnOiAnWmVybyBXJyxcbiAgICAnMGQnOiAnM0IrJyxcbiAgICAnMGUnOiAnM0ErJyxcbiAgICAnMGYnOiAnSW50ZXJuYWwgdXNlIG9ubHknLFxuICAgICcxMCc6ICdDTTMrJyxcbiAgICAnMTEnOiAnNEInLFxuICAgICcxMic6ICdaZXJvIDIgVycsXG4gICAgJzEzJzogJzQwMCcsXG4gICAgJzE0JzogJ0NNNCdcbiAgfTtcblxuICBjb25zdCByZXZpc2lvbkNvZGUgPSBnZXRWYWx1ZShsaW5lcywgJ3JldmlzaW9uJywgJzonLCB0cnVlKTtcbiAgY29uc3QgbW9kZWwgPSBnZXRWYWx1ZShsaW5lcywgJ21vZGVsOicsICc6JywgdHJ1ZSk7XG4gIGNvbnN0IHNlcmlhbCA9IGdldFZhbHVlKGxpbmVzLCAnc2VyaWFsJywgJzonLCB0cnVlKTtcblxuICBsZXQgcmVzdWx0ID0ge307XG4gIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9sZFJldmlzaW9uQ29kZXMsIHJldmlzaW9uQ29kZSkpIHtcbiAgICAvLyBvbGQgcmV2aXNpb24gY29kZXNcbiAgICByZXN1bHQgPSB7XG4gICAgICBtb2RlbCxcbiAgICAgIHNlcmlhbCxcbiAgICAgIHJldmlzaW9uQ29kZSxcbiAgICAgIG1lbW9yeTogb2xkUmV2aXNpb25Db2Rlc1tyZXZpc2lvbkNvZGVdLm1lbW9yeSxcbiAgICAgIG1hbnVmYWN0dXJlcjogb2xkUmV2aXNpb25Db2Rlc1tyZXZpc2lvbkNvZGVdLm1hbnVmYWN0dXJlcixcbiAgICAgIHByb2Nlc3Nvcjogb2xkUmV2aXNpb25Db2Rlc1tyZXZpc2lvbkNvZGVdLnByb2Nlc3NvcixcbiAgICAgIHR5cGU6IG9sZFJldmlzaW9uQ29kZXNbcmV2aXNpb25Db2RlXS50eXBlLFxuICAgICAgcmV2aXNpb246IG9sZFJldmlzaW9uQ29kZXNbcmV2aXNpb25Db2RlXS5yZXZpc2lvbixcbiAgICB9O1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gbmV3IHJldmlzaW9uIGNvZGVcbiAgICBjb25zdCByZXZpc2lvbiA9ICgnMDAwMDAwMDAnICsgZ2V0VmFsdWUobGluZXMsICdyZXZpc2lvbicsICc6JywgdHJ1ZSkudG9Mb3dlckNhc2UoKSkuc3Vic3RyKC04KTtcbiAgICBjb25zdCBtZW1TaXplQ29kZSA9IHBhcnNlSW50KGhleDJiaW4ocmV2aXNpb24uc3Vic3RyKDIsIDEpKS5zdWJzdHIoNSwgMyksIDIpIHx8IDA7XG4gICAgY29uc3QgbWFudWZhY3R1cmVyID0gbWFudWZhY3R1cmVyTGlzdFtwYXJzZUludChyZXZpc2lvbi5zdWJzdHIoMywgMSksIDEwKV07XG4gICAgY29uc3QgcHJvY2Vzc29yID0gcHJvY2Vzc29yTGlzdFtwYXJzZUludChyZXZpc2lvbi5zdWJzdHIoNCwgMSksIDEwKV07XG4gICAgY29uc3QgdHlwZUNvZGUgPSByZXZpc2lvbi5zdWJzdHIoNSwgMik7XG5cblxuICAgIHJlc3VsdCA9IHtcbiAgICAgIG1vZGVsLFxuICAgICAgc2VyaWFsLFxuICAgICAgcmV2aXNpb25Db2RlLFxuICAgICAgbWVtb3J5OiAyNTYgKiBNYXRoLnBvdygyLCBtZW1TaXplQ29kZSksXG4gICAgICBtYW51ZmFjdHVyZXIsXG4gICAgICBwcm9jZXNzb3IsXG4gICAgICB0eXBlOiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGVMaXN0LCB0eXBlQ29kZSkgPyB0eXBlTGlzdFt0eXBlQ29kZV0gOiAnJyxcbiAgICAgIHJldmlzaW9uOiAnMS4nICsgcmV2aXNpb24uc3Vic3RyKDcsIDEpLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcHJvbWlzZUFsbChwcm9taXNlcykge1xuICBjb25zdCByZXNvbHZpbmdQcm9taXNlcyA9IHByb21pc2VzLm1hcChmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgbGV0IHBheWxvYWQgPSBuZXcgQXJyYXkoMik7XG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBwYXlsb2FkWzBdID0gcmVzdWx0O1xuICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIHBheWxvYWRbMV0gPSBlcnJvcjtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRoZSB3cmFwcGVkIFByb21pc2UgcmV0dXJucyBhbiBhcnJheTogMCA9IHJlc3VsdCwgMSA9IGVycm9yIC4uLiB3ZSByZXNvbHZlIGFsbFxuICAgICAgICAgIHJlc29sdmUocGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAvLyBFeGVjdXRlIGFsbCB3cmFwcGVkIFByb21pc2VzXG4gIHJldHVybiBQcm9taXNlLmFsbChyZXNvbHZpbmdQcm9taXNlcylcbiAgICAudGhlbihmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRbMV0pIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChwYXlsb2FkWzFdKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobnVsbCk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHBheWxvYWRbMF0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShub2RlU3R5bGVGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBub2RlU3R5bGVGdW5jdGlvbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5U2F2ZShub2RlU3R5bGVGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgbm9kZVN0eWxlRnVuY3Rpb24uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxpbnV4VmVyc2lvbigpIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBpZiAoX2xpbnV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGV4ZWNTeW5jKCd1bmFtZSAtdicpLnRvU3RyaW5nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBsaXN0UGFyc2VyKHhtbFN0cikge1xuICBjb25zdCB0YWdzID0gWydhcnJheScsICdkaWN0JywgJ2tleScsICdzdHJpbmcnLCAnaW50ZWdlcicsICdkYXRlJywgJ3JlYWwnLCAnZGF0YScsICdib29sZWFuJywgJ2FycmF5RW1wdHknXTtcbiAgY29uc3Qgc3RhcnRTdHIgPSAnPHBsaXN0IHZlcnNpb24nO1xuXG4gIGxldCBwb3MgPSB4bWxTdHIuaW5kZXhPZihzdGFydFN0cik7XG4gIGxldCBsZW4gPSB4bWxTdHIubGVuZ3RoO1xuICB3aGlsZSAoeG1sU3RyW3Bvc10gIT09ICc+JyAmJiBwb3MgPCBsZW4pIHtcbiAgICBwb3MrKztcbiAgfVxuXG4gIGxldCBkZXB0aCA9IDA7XG4gIGxldCBpblRhZ1N0YXJ0ID0gZmFsc2U7XG4gIGxldCBpblRhZ0NvbnRlbnQgPSBmYWxzZTtcbiAgbGV0IGluVGFnRW5kID0gZmFsc2U7XG4gIGxldCBtZXRhRGF0YSA9IFt7IHRhZ1N0YXJ0OiAnJywgdGFnRW5kOiAnJywgdGFnQ29udGVudDogJycsIGtleTogJycsIGRhdGE6IG51bGwgfV07XG4gIGxldCBjID0gJyc7XG4gIGxldCBjbiA9IHhtbFN0cltwb3NdO1xuXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBjID0gY247XG4gICAgaWYgKHBvcyArIDEgPCBsZW4pIHsgY24gPSB4bWxTdHJbcG9zICsgMV07IH1cbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBpblRhZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChjbiA9PT0gJy8nKSB7IGluVGFnRW5kID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0KSB7XG4gICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50ID0gJyc7XG4gICAgICAgIGlmICghbWV0YURhdGFbZGVwdGhdLmRhdGEpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICdhcnJheScgPyBbXSA6IHt9OyB9XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIG1ldGFEYXRhLnB1c2goeyB0YWdTdGFydDogJycsIHRhZ0VuZDogJycsIHRhZ0NvbnRlbnQ6ICcnLCBrZXk6IG51bGwsIGRhdGE6IG51bGwgfSk7XG4gICAgICAgIGluVGFnU3RhcnQgPSB0cnVlO1xuICAgICAgICBpblRhZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpblRhZ1N0YXJ0KSB7IGluVGFnU3RhcnQgPSB0cnVlOyB9XG4gICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICd0cnVlLycpIHsgaW5UYWdTdGFydCA9IGZhbHNlOyBpblRhZ0VuZCA9IHRydWU7IG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9ICcnOyBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJy9ib29sZWFuJzsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSB0cnVlOyB9XG4gICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAnZmFsc2UvJykgeyBpblRhZ1N0YXJ0ID0gZmFsc2U7IGluVGFnRW5kID0gdHJ1ZTsgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID0gJyc7IG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnL2Jvb2xlYW4nOyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IGZhbHNlOyB9XG4gICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID09PSAnYXJyYXkvJykgeyBpblRhZ1N0YXJ0ID0gZmFsc2U7IGluVGFnRW5kID0gdHJ1ZTsgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID0gJyc7IG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnL2FycmF5RW1wdHknOyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IFtdOyB9XG4gICAgICBpZiAoaW5UYWdDb250ZW50KSB7IGluVGFnQ29udGVudCA9IGZhbHNlOyB9XG4gICAgICBpZiAoaW5UYWdTdGFydCkge1xuICAgICAgICBpblRhZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGluVGFnQ29udGVudCA9IHRydWU7XG4gICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICdhcnJheScpIHtcbiAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnU3RhcnQgPT09ICdkaWN0Jykge1xuICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS5kYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpblRhZ0VuZCkge1xuICAgICAgICBpblRhZ0VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCAmJiB0YWdzLmluZGV4T2YobWV0YURhdGFbZGVwdGhdLnRhZ0VuZC5zdWJzdHIoMSkpID49IDApIHtcbiAgICAgICAgICBpZiAobWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9PT0gJy9kaWN0JyB8fCBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKGRlcHRoID4gMSAmJiBtZXRhRGF0YVtkZXB0aCAtIDJdLnRhZ1N0YXJ0ID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoIC0gMl0uZGF0YS5wdXNoKG1ldGFEYXRhW2RlcHRoIC0gMV0uZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAxICYmIG1ldGFEYXRhW2RlcHRoIC0gMl0udGFnU3RhcnQgPT09ICdkaWN0Jykge1xuICAgICAgICAgICAgICBtZXRhRGF0YVtkZXB0aCAtIDJdLmRhdGFbbWV0YURhdGFbZGVwdGggLSAxXS5rZXldID0gbWV0YURhdGFbZGVwdGggLSAxXS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIG1ldGFEYXRhLnBvcCgpO1xuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdTdGFydCA9ICcnO1xuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ0VuZCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2tleScgJiYgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLmtleSA9IG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvcmVhbCcgJiYgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBwYXJzZUZsb2F0KG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB8fCAwOyB9XG4gICAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2ludGVnZXInICYmIG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50KSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gcGFyc2VJbnQobWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQpIHx8IDA7IH1cbiAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvc3RyaW5nJyAmJiBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCkgeyBtZXRhRGF0YVtkZXB0aF0uZGF0YSA9IG1ldGFEYXRhW2RlcHRoXS50YWdDb250ZW50IHx8ICcnOyB9XG4gICAgICAgICAgICAgIGlmIChtZXRhRGF0YVtkZXB0aF0udGFnRW5kID09PSAnL2Jvb2xlYW4nKSB7IG1ldGFEYXRhW2RlcHRoXS5kYXRhID0gbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgfHwgZmFsc2U7IH1cbiAgICAgICAgICAgICAgaWYgKG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPT09ICcvYXJyYXlFbXB0eScpIHsgbWV0YURhdGFbZGVwdGhdLmRhdGEgPSBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCB8fCBbXTsgfVxuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAwICYmIG1ldGFEYXRhW2RlcHRoIC0gMV0udGFnU3RhcnQgPT09ICdhcnJheScpIHsgbWV0YURhdGFbZGVwdGggLSAxXS5kYXRhLnB1c2gobWV0YURhdGFbZGVwdGhdLmRhdGEpOyB9XG4gICAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgbWV0YURhdGFbZGVwdGggLSAxXS50YWdTdGFydCA9PT0gJ2RpY3QnKSB7IG1ldGFEYXRhW2RlcHRoIC0gMV0uZGF0YVttZXRhRGF0YVtkZXB0aF0ua2V5XSA9IG1ldGFEYXRhW2RlcHRoXS5kYXRhOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ID0gJyc7XG4gICAgICAgICAgICBtZXRhRGF0YVtkZXB0aF0udGFnRW5kID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFEYXRhW2RlcHRoXS50YWdFbmQgPSAnJztcbiAgICAgICAgaW5UYWdTdGFydCA9IGZhbHNlO1xuICAgICAgICBpblRhZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluVGFnU3RhcnQpIHsgbWV0YURhdGFbZGVwdGhdLnRhZ1N0YXJ0ICs9IGM7IH1cbiAgICAgIGlmIChpblRhZ0VuZCkgeyBtZXRhRGF0YVtkZXB0aF0udGFnRW5kICs9IGM7IH1cbiAgICAgIGlmIChpblRhZ0NvbnRlbnQpIHsgbWV0YURhdGFbZGVwdGhdLnRhZ0NvbnRlbnQgKz0gYzsgfVxuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICByZXR1cm4gbWV0YURhdGFbMF0uZGF0YTtcbn1cblxuZnVuY3Rpb24gc3RySXNOdW1lcmljKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKHN0cikgJiYgIWlzTmFOKHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBsaXN0UmVhZGVyKG91dHB1dCkge1xuICBjb25zdCBsaW5lcyA9IG91dHB1dC5zcGxpdCgnXFxuJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0uaW5kZXhPZignID0gJykgPj0gMCkge1xuICAgICAgY29uc3QgbGluZVBhcnRzID0gbGluZXNbaV0uc3BsaXQoJyA9ICcpO1xuICAgICAgbGluZVBhcnRzWzBdID0gbGluZVBhcnRzWzBdLnRyaW0oKTtcbiAgICAgIGlmICghbGluZVBhcnRzWzBdLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgICAgbGluZVBhcnRzWzBdID0gJ1wiJyArIGxpbmVQYXJ0c1swXSArICdcIic7XG4gICAgICB9XG4gICAgICBsaW5lUGFydHNbMV0gPSBsaW5lUGFydHNbMV0udHJpbSgpO1xuICAgICAgaWYgKGxpbmVQYXJ0c1sxXS5pbmRleE9mKCdcIicpID09PSAtMSAmJiBsaW5lUGFydHNbMV0uZW5kc1dpdGgoJzsnKSkge1xuICAgICAgICBjb25zdCB2YWx1ZVN0cmluZyA9IGxpbmVQYXJ0c1sxXS5zdWJzdHJpbmcoMCwgbGluZVBhcnRzWzFdLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoIXN0cklzTnVtZXJpYyh2YWx1ZVN0cmluZykpIHtcbiAgICAgICAgICBsaW5lUGFydHNbMV0gPSBgXCIke3ZhbHVlU3RyaW5nfVwiO2A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaW5lUGFydHNbMV0uaW5kZXhPZignXCInKSA+PSAwICYmIGxpbmVQYXJ0c1sxXS5lbmRzV2l0aCgnOycpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gbGluZVBhcnRzWzFdLnN1YnN0cmluZygwLCBsaW5lUGFydHNbMV0ubGVuZ3RoIC0gMSkucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgICBpZiAoc3RySXNOdW1lcmljKHZhbHVlU3RyaW5nKSkge1xuICAgICAgICAgIGxpbmVQYXJ0c1sxXSA9IGAke3ZhbHVlU3RyaW5nfTtgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lc1tpXSA9IGxpbmVQYXJ0cy5qb2luKCcgOiAnKTtcbiAgICB9XG4gICAgbGluZXNbaV0gPSBsaW5lc1tpXS5yZXBsYWNlKC9cXCgvZywgJ1snKS5yZXBsYWNlKC9cXCkvZywgJ10nKS5yZXBsYWNlKC87L2csICcsJykudHJpbSgpO1xuICAgIGlmIChsaW5lc1tpXS5zdGFydHNXaXRoKCd9JykgJiYgbGluZXNbaSAtIDFdICYmIGxpbmVzW2kgLSAxXS5lbmRzV2l0aCgnLCcpKSB7XG4gICAgICBsaW5lc1tpIC0gMV0gPSBsaW5lc1tpIC0gMV0uc3Vic3RyaW5nKDAsIGxpbmVzW2kgLSAxXS5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ID0gbGluZXMuam9pbignJyk7XG4gIGxldCBvYmogPSB7fTtcbiAgdHJ5IHtcbiAgICBvYmogPSBKU09OLnBhcnNlKG91dHB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBub29wKCk7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gc2VtdmVyQ29tcGFyZSh2MSwgdjIpIHtcbiAgbGV0IHJlcyA9IDA7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGlmIChwYXJ0czFbMF0gPCBwYXJ0czJbMF0pIHsgcmVzID0gMTsgfVxuICBlbHNlIGlmIChwYXJ0czFbMF0gPiBwYXJ0czJbMF0pIHsgcmVzID0gLTE7IH1cbiAgZWxzZSBpZiAocGFydHMxWzBdID09PSBwYXJ0czJbMF0gJiYgcGFydHMxLmxlbmd0aCA+PSAyICYmIHBhcnRzMi5sZW5ndGggPj0gMikge1xuICAgIGlmIChwYXJ0czFbMV0gPCBwYXJ0czJbMV0pIHsgcmVzID0gMTsgfVxuICAgIGVsc2UgaWYgKHBhcnRzMVsxXSA+IHBhcnRzMlsxXSkgeyByZXMgPSAtMTsgfVxuICAgIGVsc2UgaWYgKHBhcnRzMVsxXSA9PT0gcGFydHMyWzFdKSB7XG4gICAgICBpZiAocGFydHMxLmxlbmd0aCA+PSAzICYmIHBhcnRzMi5sZW5ndGggPj0gMykge1xuICAgICAgICBpZiAocGFydHMxWzJdIDwgcGFydHMyWzJdKSB7IHJlcyA9IDE7IH1cbiAgICAgICAgZWxzZSBpZiAocGFydHMxWzJdID4gcGFydHMyWzJdKSB7IHJlcyA9IC0xOyB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnRzMi5sZW5ndGggPj0gMykge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBub29wKCkgeyB9XG5cbmV4cG9ydHMudG9JbnQgPSB0b0ludDtcbmV4cG9ydHMuZXhlY09wdHNXaW4gPSBleGVjT3B0c1dpbjtcbmV4cG9ydHMuZ2V0Q29kZXBhZ2UgPSBnZXRDb2RlcGFnZTtcbmV4cG9ydHMuZXhlY1dpbiA9IGV4ZWNXaW47XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5leHBvcnRzLnNvcnRCeUtleSA9IHNvcnRCeUtleTtcbmV4cG9ydHMuY29yZXMgPSBjb3JlcztcbmV4cG9ydHMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbmV4cG9ydHMuZGVjb2RlRXNjYXBlU2VxdWVuY2UgPSBkZWNvZGVFc2NhcGVTZXF1ZW5jZTtcbmV4cG9ydHMucGFyc2VEYXRlVGltZSA9IHBhcnNlRGF0ZVRpbWU7XG5leHBvcnRzLnBhcnNlSGVhZCA9IHBhcnNlSGVhZDtcbmV4cG9ydHMuZmluZE9iamVjdEJ5S2V5ID0gZmluZE9iamVjdEJ5S2V5O1xuZXhwb3J0cy5nZXRXbWljID0gZ2V0V21pYztcbmV4cG9ydHMud21pYyA9IHdtaWM7XG5leHBvcnRzLmRhcndpblhjb2RlRXhpc3RzID0gZGFyd2luWGNvZGVFeGlzdHM7XG5leHBvcnRzLmdldFZib3htYW5hZ2UgPSBnZXRWYm94bWFuYWdlO1xuZXhwb3J0cy5wb3dlclNoZWxsID0gcG93ZXJTaGVsbDtcbmV4cG9ydHMucG93ZXJTaGVsbFN0YXJ0ID0gcG93ZXJTaGVsbFN0YXJ0O1xuZXhwb3J0cy5wb3dlclNoZWxsUmVsZWFzZSA9IHBvd2VyU2hlbGxSZWxlYXNlO1xuZXhwb3J0cy5leGVjU2FmZSA9IGV4ZWNTYWZlO1xuZXhwb3J0cy5uYW5vU2Vjb25kcyA9IG5hbm9TZWNvbmRzO1xuZXhwb3J0cy5jb3VudFVuaXF1ZUxpbmVzID0gY291bnRVbmlxdWVMaW5lcztcbmV4cG9ydHMuY291bnRMaW5lcyA9IGNvdW50TGluZXM7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5pc1Jhc3BiZXJyeSA9IGlzUmFzcGJlcnJ5O1xuZXhwb3J0cy5pc1Jhc3BiaWFuID0gaXNSYXNwYmlhbjtcbmV4cG9ydHMuc2FuaXRpemVTaGVsbFN0cmluZyA9IHNhbml0aXplU2hlbGxTdHJpbmc7XG5leHBvcnRzLmlzUHJvdG90eXBlUG9sbHV0ZWQgPSBpc1Byb3RvdHlwZVBvbGx1dGVkO1xuZXhwb3J0cy5kZWNvZGVQaUNwdWluZm8gPSBkZWNvZGVQaUNwdWluZm87XG5leHBvcnRzLnByb21pc2VBbGwgPSBwcm9taXNlQWxsO1xuZXhwb3J0cy5wcm9taXNpZnkgPSBwcm9taXNpZnk7XG5leHBvcnRzLnByb21pc2lmeVNhdmUgPSBwcm9taXNpZnlTYXZlO1xuZXhwb3J0cy5zbWFydE1vblRvb2xzSW5zdGFsbGVkID0gc21hcnRNb25Ub29sc0luc3RhbGxlZDtcbmV4cG9ydHMubGludXhWZXJzaW9uID0gbGludXhWZXJzaW9uO1xuZXhwb3J0cy5wbGlzdFBhcnNlciA9IHBsaXN0UGFyc2VyO1xuZXhwb3J0cy5wbGlzdFJlYWRlciA9IHBsaXN0UmVhZGVyO1xuZXhwb3J0cy5zdHJpbmdSZXBsYWNlID0gc3RyaW5nUmVwbGFjZTtcbmV4cG9ydHMuc3RyaW5nVG9Mb3dlciA9IHN0cmluZ1RvTG93ZXI7XG5leHBvcnRzLnN0cmluZ1RvU3RyaW5nID0gc3RyaW5nVG9TdHJpbmc7XG5leHBvcnRzLnN0cmluZ1N1YnN0ciA9IHN0cmluZ1N1YnN0cjtcbmV4cG9ydHMuc3RyaW5nVHJpbSA9IHN0cmluZ1RyaW07XG5leHBvcnRzLnN0cmluZ1N0YXJ0V2l0aCA9IHN0cmluZ1N0YXJ0V2l0aDtcbmV4cG9ydHMubWF0aE1pbiA9IG1hdGhNaW47XG5leHBvcnRzLldJTkRJUiA9IFdJTkRJUjtcbmV4cG9ydHMuZ2V0RmlsZXNJblBhdGggPSBnZXRGaWxlc0luUGF0aDtcbmV4cG9ydHMuc2VtdmVyQ29tcGFyZSA9IHNlbXZlckNvbXBhcmU7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBAdHMtY2hlY2tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHZpcnR1YWxib3guanNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlc2NyaXB0aW9uOiAgIFN5c3RlbSBJbmZvcm1hdGlvbiAtIGxpYnJhcnlcbi8vICAgICAgICAgICAgICAgIGZvciBOb2RlLmpzXG4vLyBDb3B5cmlnaHQ6ICAgICAoYykgMjAxNCAtIDIwMjNcbi8vIEF1dGhvcjogICAgICAgIFNlYmFzdGlhbiBIaWxkZWJyYW5kdFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGljZW5zZTogICAgICAgTUlUXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAxNC4gRG9ja2VyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlYztcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gdmJveEluZm8oY2FsbGJhY2spIHtcblxuICAvLyBmYWxsYmFjayAtIGlmIG9ubHkgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV4ZWModXRpbC5nZXRWYm94bWFuYWdlKCkgKyAnIGxpc3Qgdm1zIC0tbG9uZycsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgbGV0IHBhcnRzID0gKG9zLkVPTCArIHN0ZG91dC50b1N0cmluZygpKS5zcGxpdChvcy5FT0wgKyAnTmFtZTonKTtcbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9ICgnTmFtZTonICsgcGFydCkuc3BsaXQob3MuRU9MKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1N0YXRlJyk7XG4gICAgICAgICAgICBjb25zdCBydW5uaW5nID0gc3RhdGUuc3RhcnRzV2l0aCgncnVubmluZycpO1xuICAgICAgICAgICAgY29uc3QgcnVubmluZ1NpbmNlU3RyaW5nID0gcnVubmluZyA/IHN0YXRlLnJlcGxhY2UoJ3J1bm5pbmcgKHNpbmNlICcsICcnKS5yZXBsYWNlKCcpJywgJycpLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgbGV0IHJ1bm5pbmdTaW5jZSA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmNlRGF0ZU9iaiA9IG5ldyBEYXRlKHJ1bm5pbmdTaW5jZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2luY2VEYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgcnVubmluZ1NpbmNlID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIERhdGUucGFyc2Uoc2luY2VEYXRlT2JqKSkgLyAxMDAwKSArIG9mZnNldCAqIDYwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHV0aWwubm9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RvcHBlZFNpbmNlU3RyaW5nID0gIXJ1bm5pbmcgPyBzdGF0ZS5yZXBsYWNlKCdwb3dlcmVkIG9mZiAoc2luY2UnLCAnJykucmVwbGFjZSgnKScsICcnKS50cmltKCkgOiAnJztcbiAgICAgICAgICAgIGxldCBzdG9wcGVkU2luY2UgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luY2VEYXRlT2JqID0gbmV3IERhdGUoc3RvcHBlZFNpbmNlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzaW5jZURhdGVPYmouZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBzdG9wcGVkU2luY2UgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gRGF0ZS5wYXJzZShzaW5jZURhdGVPYmopKSAvIDEwMDApICsgb2Zmc2V0ICogNjA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdXRpbC5ub29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVVVJRCcpLFxuICAgICAgICAgICAgICBuYW1lOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTmFtZScpLFxuICAgICAgICAgICAgICBydW5uaW5nLFxuICAgICAgICAgICAgICBzdGFydGVkOiBydW5uaW5nU2luY2VTdHJpbmcsXG4gICAgICAgICAgICAgIHJ1bm5pbmdTaW5jZSxcbiAgICAgICAgICAgICAgc3RvcHBlZDogc3RvcHBlZFNpbmNlU3RyaW5nLFxuICAgICAgICAgICAgICBzdG9wcGVkU2luY2UsXG4gICAgICAgICAgICAgIGd1ZXN0T1M6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHdWVzdCBPUycpLFxuICAgICAgICAgICAgICBoYXJkd2FyZVVVSUQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdIYXJkd2FyZSBVVUlEJyksXG4gICAgICAgICAgICAgIG1lbW9yeTogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ01lbW9yeSBzaXplJywgJyAgICAgJyksIDEwKSxcbiAgICAgICAgICAgICAgdnJhbTogcGFyc2VJbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1ZSQU0gc2l6ZScpLCAxMCksXG4gICAgICAgICAgICAgIGNwdXM6IHBhcnNlSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdOdW1iZXIgb2YgQ1BVcycpLCAxMCksXG4gICAgICAgICAgICAgIGNwdUV4ZXBDYXA6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDUFUgZXhlYyBjYXAnKSxcbiAgICAgICAgICAgICAgY3B1UHJvZmlsZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NQVVByb2ZpbGUnKSxcbiAgICAgICAgICAgICAgY2hpcHNldDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0NoaXBzZXQnKSxcbiAgICAgICAgICAgICAgZmlybXdhcmU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGaXJtd2FyZScpLFxuICAgICAgICAgICAgICBwYWdlRnVzaW9uOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUGFnZSBGdXNpb24nKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBjb25maWdGaWxlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ29uZmlnIGZpbGUnKSxcbiAgICAgICAgICAgICAgc25hcHNob3RGb2xkZXI6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdTbmFwc2hvdCBmb2xkZXInKSxcbiAgICAgICAgICAgICAgbG9nRm9sZGVyOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9nIGZvbGRlcicpLFxuICAgICAgICAgICAgICBocGV0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnSFBFVCcpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIHBhZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1BBRScpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGxvbmdNb2RlOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnTG9uZyBNb2RlJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgdHJpcGxlRmF1bHRSZXNldDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RyaXBsZSBGYXVsdCBSZXNldCcpID09PSAnZW5hYmxlZCcsXG4gICAgICAgICAgICAgIGFwaWM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBUElDJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgeDJBcGljOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnWDJBUElDJykgPT09ICdlbmFibGVkJyxcbiAgICAgICAgICAgICAgYWNwaTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0FDUEknKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBpb0FwaWM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdJT0FQSUMnKSA9PT0gJ2VuYWJsZWQnLFxuICAgICAgICAgICAgICBiaW9zQXBpY01vZGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCSU9TIEFQSUMgbW9kZScpLFxuICAgICAgICAgICAgICBib290TWVudU1vZGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCb290IG1lbnUgbW9kZScpLFxuICAgICAgICAgICAgICBib290RGV2aWNlMTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Jvb3QgRGV2aWNlIDEnKSxcbiAgICAgICAgICAgICAgYm9vdERldmljZTI6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCb290IERldmljZSAyJyksXG4gICAgICAgICAgICAgIGJvb3REZXZpY2UzOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQm9vdCBEZXZpY2UgMycpLFxuICAgICAgICAgICAgICBib290RGV2aWNlNDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0Jvb3QgRGV2aWNlIDQnKSxcbiAgICAgICAgICAgICAgdGltZU9mZnNldDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RpbWUgb2Zmc2V0JyksXG4gICAgICAgICAgICAgIHJ0YzogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1JUQycpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2socmVzdWx0KTsgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhyZXN1bHQpOyB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMudmJveEluZm8gPSB2Ym94SW5mbztcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEB0cy1jaGVja1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gd2lmaS5qc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246ICAgU3lzdGVtIEluZm9ybWF0aW9uIC0gbGlicmFyeVxuLy8gICAgICAgICAgICAgICAgZm9yIE5vZGUuanNcbi8vIENvcHlyaWdodDogICAgIChjKSAyMDE0IC0gMjAyM1xuLy8gQXV0aG9yOiAgICAgICAgU2ViYXN0aWFuIEhpbGRlYnJhbmR0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMaWNlbnNlOiAgICAgICBNSVRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIDkuIHdpZmlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgZXhlYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjO1xuY29uc3QgZXhlY1N5bmMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmM7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmxldCBfcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtO1xuXG5jb25zdCBfbGludXggPSAoX3BsYXRmb3JtID09PSAnbGludXgnIHx8IF9wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbmNvbnN0IF9kYXJ3aW4gPSAoX3BsYXRmb3JtID09PSAnZGFyd2luJyk7XG5jb25zdCBfd2luZG93cyA9IChfcGxhdGZvcm0gPT09ICd3aW4zMicpO1xuXG5mdW5jdGlvbiB3aWZpREJGcm9tUXVhbGl0eShxdWFsaXR5KSB7XG4gIHJldHVybiAocGFyc2VGbG9hdChxdWFsaXR5KSAvIDIgLSAxMDApO1xufVxuXG5mdW5jdGlvbiB3aWZpUXVhbGl0eUZyb21EQihkYikge1xuICBjb25zdCByZXN1bHQgPSAyICogKHBhcnNlRmxvYXQoZGIpICsgMTAwKTtcbiAgcmV0dXJuIHJlc3VsdCA8PSAxMDAgPyByZXN1bHQgOiAxMDA7XG59XG5cbmNvbnN0IF93aWZpX2ZyZXF1ZW5jaWVzID0ge1xuICAxOiAyNDEyLFxuICAyOiAyNDE3LFxuICAzOiAyNDIyLFxuICA0OiAyNDI3LFxuICA1OiAyNDMyLFxuICA2OiAyNDM3LFxuICA3OiAyNDQyLFxuICA4OiAyNDQ3LFxuICA5OiAyNDUyLFxuICAxMDogMjQ1NyxcbiAgMTE6IDI0NjIsXG4gIDEyOiAyNDY3LFxuICAxMzogMjQ3MixcbiAgMTQ6IDI0ODQsXG4gIDMyOiA1MTYwLFxuICAzNDogNTE3MCxcbiAgMzY6IDUxODAsXG4gIDM4OiA1MTkwLFxuICA0MDogNTIwMCxcbiAgNDI6IDUyMTAsXG4gIDQ0OiA1MjIwLFxuICA0NjogNTIzMCxcbiAgNDg6IDUyNDAsXG4gIDUwOiA1MjUwLFxuICA1MjogNTI2MCxcbiAgNTQ6IDUyNzAsXG4gIDU2OiA1MjgwLFxuICA1ODogNTI5MCxcbiAgNjA6IDUzMDAsXG4gIDYyOiA1MzEwLFxuICA2NDogNTMyMCxcbiAgNjg6IDUzNDAsXG4gIDk2OiA1NDgwLFxuICAxMDA6IDU1MDAsXG4gIDEwMjogNTUxMCxcbiAgMTA0OiA1NTIwLFxuICAxMDY6IDU1MzAsXG4gIDEwODogNTU0MCxcbiAgMTEwOiA1NTUwLFxuICAxMTI6IDU1NjAsXG4gIDExNDogNTU3MCxcbiAgMTE2OiA1NTgwLFxuICAxMTg6IDU1OTAsXG4gIDEyMDogNTYwMCxcbiAgMTIyOiA1NjEwLFxuICAxMjQ6IDU2MjAsXG4gIDEyNjogNTYzMCxcbiAgMTI4OiA1NjQwLFxuICAxMzI6IDU2NjAsXG4gIDEzNDogNTY3MCxcbiAgMTM2OiA1NjgwLFxuICAxMzg6IDU2OTAsXG4gIDE0MDogNTcwMCxcbiAgMTQyOiA1NzEwLFxuICAxNDQ6IDU3MjAsXG4gIDE0OTogNTc0NSxcbiAgMTUxOiA1NzU1LFxuICAxNTM6IDU3NjUsXG4gIDE1NTogNTc3NSxcbiAgMTU3OiA1Nzg1LFxuICAxNTk6IDU3OTUsXG4gIDE2MTogNTgwNSxcbiAgMTY1OiA1ODI1LFxuICAxNjk6IDU4NDUsXG4gIDE3MzogNTg2NSxcbiAgMTgzOiA0OTE1LFxuICAxODQ6IDQ5MjAsXG4gIDE4NTogNDkyNSxcbiAgMTg3OiA0OTM1LFxuICAxODg6IDQ5NDAsXG4gIDE4OTogNDk0NSxcbiAgMTkyOiA0OTYwLFxuICAxOTY6IDQ5ODBcbn07XG5cbmZ1bmN0aW9uIHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbChjaGFubmVsKSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93aWZpX2ZyZXF1ZW5jaWVzLCBjaGFubmVsKSA/IF93aWZpX2ZyZXF1ZW5jaWVzW2NoYW5uZWxdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gd2lmaUNoYW5uZWxGcm9tRnJlcXVlbmNzKGZyZXF1ZW5jeSkge1xuICBsZXQgY2hhbm5lbCA9IDA7XG4gIGZvciAobGV0IGtleSBpbiBfd2lmaV9mcmVxdWVuY2llcykge1xuICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93aWZpX2ZyZXF1ZW5jaWVzLCBrZXkpKSB7XG4gICAgICBpZiAoX3dpZmlfZnJlcXVlbmNpZXNba2V5XSA9PT0gZnJlcXVlbmN5KSB7IGNoYW5uZWwgPSB1dGlsLnRvSW50KGtleSk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5uZWw7XG59XG5cbmZ1bmN0aW9uIGlmYWNlTGlzdExpbnV4KCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgY21kID0gJ2l3IGRldiAyPi9kZXYvbnVsbCc7XG4gIHRyeSB7XG4gICAgY29uc3QgYWxsID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSkuam9pbignXFxuJyk7XG4gICAgY29uc3QgcGFydHMgPSBhbGwuc3BsaXQoJ1xcbkludGVyZmFjZSAnKTtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICAgIHBhcnRzLmZvckVhY2goaWZhY2VEZXRhaWxzID0+IHtcbiAgICAgIGNvbnN0IGxpbmVzID0gaWZhY2VEZXRhaWxzLnNwbGl0KCdcXG4nKTtcbiAgICAgIGNvbnN0IGlmYWNlID0gbGluZXNbMF07XG4gICAgICBjb25zdCBpZCA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lcywgJ2lmaW5kZXgnLCAnICcpKTtcbiAgICAgIGNvbnN0IG1hYyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdhZGRyJywgJyAnKTtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdjaGFubmVsJywgJyAnKSk7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBpZmFjZSxcbiAgICAgICAgbWFjLFxuICAgICAgICBjaGFubmVsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsbCA9IGV4ZWNTeW5jKCdubWNsaSAtdCAtZiBnZW5lcmFsLHdpZmktcHJvcGVydGllcyx3aXJlZC1wcm9wZXJ0aWVzLGludGVyZmFjZS1mbGFncyxjYXBhYmlsaXRpZXMsbnNwIGRldmljZSBzaG93IDI+L2Rldi9udWxsJykudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gYWxsLnNwbGl0KCdcXG5HRU5FUkFMLkRFVklDRTonKTtcbiAgICAgIGxldCBpID0gMTtcbiAgICAgIHBhcnRzLmZvckVhY2goaWZhY2VEZXRhaWxzID0+IHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBpZmFjZURldGFpbHMuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBpZmFjZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLkRFVklDRScpO1xuICAgICAgICBjb25zdCB0eXBlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuVFlQRScpO1xuICAgICAgICBjb25zdCBpZCA9IGkrKzsgLy8gLy8gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuUEFUSCcpO1xuICAgICAgICBjb25zdCBtYWMgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5IV0FERFInKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9ICcnO1xuICAgICAgICBpZiAodHlwZS50b0xvd2VyQ2FzZSgpID09PSAnd2lmaScpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGlmYWNlLFxuICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgY2hhbm5lbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBubWlEZXZpY2VMaW51eChpZmFjZSkge1xuICBjb25zdCBjbWQgPSBgbm1jbGkgLXQgLWYgZ2VuZXJhbCx3aWZpLXByb3BlcnRpZXMsY2FwYWJpbGl0aWVzLGlwNCxpcDYgZGV2aWNlIHNob3cgJHtpZmFjZX0gMj4vZGV2L251bGxgO1xuICB0cnkge1xuICAgIGNvbnN0IGxpbmVzID0gZXhlY1N5bmMoY21kKS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuQ09OTkVDVElPTicpO1xuICAgIHJldHVybiB7XG4gICAgICBpZmFjZSxcbiAgICAgIHR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLlRZUEUnKSxcbiAgICAgIHZlbmRvcjogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0dFTkVSQUwuVkVORE9SJyksXG4gICAgICBwcm9kdWN0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnR0VORVJBTC5QUk9EVUNUJyksXG4gICAgICBtYWM6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdHRU5FUkFMLkhXQUREUicpLnRvTG93ZXJDYXNlKCksXG4gICAgICBzc2lkOiBzc2lkICE9PSAnLS0nID8gc3NpZCA6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5taUNvbm5lY3Rpb25MaW51eChzc2lkKSB7XG4gIGNvbnN0IGNtZCA9IGBubWNsaSAtdCAtLXNob3ctc2VjcmV0cyBjb25uZWN0aW9uIHNob3cgJHtzc2lkfSAyPi9kZXYvbnVsbGA7XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGJzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJzgwMi0xMS13aXJlbGVzcy5zZWVuLWJzc2lkcycpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNzaWQ6IHNzaWQgIT09ICctLScgPyBzc2lkIDogbnVsbCxcbiAgICAgIHV1aWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjb25uZWN0aW9uLnV1aWQnKSxcbiAgICAgIHR5cGU6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdjb25uZWN0aW9uLnR5cGUnKSxcbiAgICAgIGF1dG9jb25uZWN0OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnY29ubmVjdGlvbi5hdXRvY29ubmVjdCcpID09PSAneWVzJyxcbiAgICAgIHNlY3VyaXR5OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnODAyLTExLXdpcmVsZXNzLXNlY3VyaXR5LmtleS1tZ210JyksXG4gICAgICBic3NpZDogYnNzaWQgIT09ICctLScgPyBic3NpZCA6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdwYUNvbm5lY3Rpb25MaW51eChpZmFjZSkge1xuICBjb25zdCBjbWQgPSBgd3BhX2NsaSAtaSAke2lmYWNlfSBzdGF0dXMgMj4mMWA7XG4gIHRyeSB7XG4gICAgY29uc3QgbGluZXMgPSBleGVjU3luYyhjbWQpLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZyZXEgPSB1dGlsLnRvSW50KHV0aWwuZ2V0VmFsdWUobGluZXMsICdmcmVxJywgJz0nKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNzaWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICdzc2lkJywgJz0nKSxcbiAgICAgIHV1aWQ6IHV0aWwuZ2V0VmFsdWUobGluZXMsICd1dWlkJywgJz0nKSxcbiAgICAgIHNlY3VyaXR5OiB1dGlsLmdldFZhbHVlKGxpbmVzLCAna2V5X21nbXQnLCAnPScpLFxuICAgICAgZnJlcSxcbiAgICAgIGNoYW5uZWw6IHdpZmlDaGFubmVsRnJvbUZyZXF1ZW5jcyhmcmVxKSxcbiAgICAgIGJzc2lkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnYnNzaWQnLCAnPScpLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpZmlOZXR3b3JrTGlzdE5taSgpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNtZCA9ICdubWNsaSAtdCAtbSBtdWx0aWxpbmUgLS1maWVsZHMgYWN0aXZlLHNzaWQsYnNzaWQsbW9kZSxjaGFuLGZyZXEsc2lnbmFsLHNlY3VyaXR5LHdwYS1mbGFncyxyc24tZmxhZ3MgZGV2aWNlIHdpZmkgbGlzdCAyPi9kZXYvbnVsbCc7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rkb3V0ID0gZXhlY1N5bmMoY21kLCB7IG1heEJ1ZmZlcjogMTAyNCAqIDIwMDAwIH0pO1xuICAgIGNvbnN0IHBhcnRzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ0FDVElWRTonKTtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICBwYXJ0ID0gJ0FDVElWRTonICsgcGFydDtcbiAgICAgIGNvbnN0IGxpbmVzID0gcGFydC5zcGxpdChvcy5FT0wpO1xuICAgICAgY29uc3QgY2hhbm5lbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDSEFOJyk7XG4gICAgICBjb25zdCBmcmVxdWVuY3kgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRlJFUScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbWh6JywgJycpLnRyaW0oKTtcbiAgICAgIGNvbnN0IHNlY3VyaXR5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NFQ1VSSVRZJykucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpO1xuICAgICAgY29uc3Qgd3BhRmxhZ3MgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnV1BBLUZMQUdTJykucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpO1xuICAgICAgY29uc3QgcnNuRmxhZ3MgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUlNOLUZMQUdTJykucmVwbGFjZSgnKCcsICcnKS5yZXBsYWNlKCcpJywgJycpO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBzc2lkOiB1dGlsLmdldFZhbHVlKGxpbmVzLCAnU1NJRCcpLFxuICAgICAgICBic3NpZDogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0JTU0lEJykudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgbW9kZTogdXRpbC5nZXRWYWx1ZShsaW5lcywgJ01PREUnKSxcbiAgICAgICAgY2hhbm5lbDogY2hhbm5lbCA/IHBhcnNlSW50KGNoYW5uZWwsIDEwKSA6IG51bGwsXG4gICAgICAgIGZyZXF1ZW5jeTogZnJlcXVlbmN5ID8gcGFyc2VJbnQoZnJlcXVlbmN5LCAxMCkgOiBudWxsLFxuICAgICAgICBzaWduYWxMZXZlbDogd2lmaURCRnJvbVF1YWxpdHkodXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NJR05BTCcpKSxcbiAgICAgICAgcXVhbGl0eTogcGFyc2VGbG9hdCh1dGlsLmdldFZhbHVlKGxpbmVzLCAnU0lHTkFMJykpLFxuICAgICAgICBzZWN1cml0eTogc2VjdXJpdHkgJiYgc2VjdXJpdHkgIT09ICdub25lJyA/IHNlY3VyaXR5LnNwbGl0KCcgJykgOiBbXSxcbiAgICAgICAgd3BhRmxhZ3M6IHdwYUZsYWdzICYmIHdwYUZsYWdzICE9PSAnbm9uZScgPyB3cGFGbGFncy5zcGxpdCgnICcpIDogW10sXG4gICAgICAgIHJzbkZsYWdzOiByc25GbGFncyAmJiByc25GbGFncyAhPT0gJ25vbmUnID8gcnNuRmxhZ3Muc3BsaXQoJyAnKSA6IFtdXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpZmlOZXR3b3JrTGlzdEl3KGlmYWNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0cnkge1xuICAgIGxldCBpd2xpc3RQYXJ0cyA9IGV4ZWNTeW5jKGBleHBvcnQgTENfQUxMPUM7IGl3bGlzdCAke2lmYWNlfSBzY2FuIDI+JjE7IHVuc2V0IExDX0FMTGApLnRvU3RyaW5nKCkuc3BsaXQoJyAgICAgICAgQ2VsbCAnKTtcbiAgICBpZiAoaXdsaXN0UGFydHNbMF0uaW5kZXhPZigncmVzb3VyY2UgYnVzeScpID49IDApIHsgcmV0dXJuIC0xOyB9XG4gICAgaWYgKGl3bGlzdFBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGl3bGlzdFBhcnRzLnNoaWZ0KCk7XG4gICAgICBpd2xpc3RQYXJ0cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGVsZW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2NoYW5uZWwnLCAnOicsIHRydWUpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGxpbmVzICYmIGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5pbmRleE9mKCdBZGRyZXNzOicpID49IDAgPyBsaW5lc1swXS5zcGxpdCgnQWRkcmVzczonKVsxXS50cmltKCkudG9Mb3dlckNhc2UoKSA6ICcnKTtcbiAgICAgICAgY29uc3QgbW9kZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdtb2RlJywgJzonLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZnJlcXVlbmN5ID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ2ZyZXF1ZW5jeScsICc6JywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHF1YWxpdHlTdHJpbmcgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUXVhbGl0eScsICc9JywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGRiUGFydHMgPSBxdWFsaXR5U3RyaW5nLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ3NpZ25hbCBsZXZlbD0nKTtcbiAgICAgICAgY29uc3QgZGIgPSBkYlBhcnRzLmxlbmd0aCA+IDEgPyB1dGlsLnRvSW50KGRiUGFydHNbMV0pIDogMDtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IGRiID8gd2lmaVF1YWxpdHlGcm9tREIoZGIpIDogMDtcbiAgICAgICAgY29uc3Qgc3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdlc3NpZCcsICc6JywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gc2VjdXJpdHkgYW5kIHdwYS1mbGFnc1xuICAgICAgICBjb25zdCBpc1dwYSA9IGVsZW1lbnQuaW5kZXhPZignIFdQQSAnKSA+PSAwO1xuICAgICAgICBjb25zdCBpc1dwYTIgPSBlbGVtZW50LmluZGV4T2YoJ1dQQTIgJykgPj0gMDtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHkgPSBbXTtcbiAgICAgICAgaWYgKGlzV3BhKSB7IHNlY3VyaXR5LnB1c2goJ1dQQScpOyB9XG4gICAgICAgIGlmIChpc1dwYTIpIHsgc2VjdXJpdHkucHVzaCgnV1BBMicpOyB9XG4gICAgICAgIGNvbnN0IHdwYUZsYWdzID0gW107XG4gICAgICAgIGxldCB3cGFGbGFnID0gJyc7XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICBjb25zdCBsID0gbGluZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobC5pbmRleE9mKCdncm91cCBjaXBoZXInKSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAod3BhRmxhZykge1xuICAgICAgICAgICAgICB3cGFGbGFncy5wdXNoKHdwYUZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB3cGFGbGFnID0gcGFydHNbMV0udHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsLmluZGV4T2YoJ3BhaXJ3aXNlIGNpcGhlcicpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdLmluZGV4T2YoJ3RraXAnKSkgeyB3cGFGbGFnID0gKHdwYUZsYWcgPyAnVEtJUC8nICsgd3BhRmxhZyA6ICdUS0lQJyk7IH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMV0uaW5kZXhPZignY2NtcCcpKSB7IHdwYUZsYWcgPSAod3BhRmxhZyA/ICdDQ01QLycgKyB3cGFGbGFnIDogJ0NDTVAnKTsgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1sxXS5pbmRleE9mKCdwcm9wcmlldGFyeScpKSB7IHdwYUZsYWcgPSAod3BhRmxhZyA/ICdQUk9QLycgKyB3cGFGbGFnIDogJ1BST1AnKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobC5pbmRleE9mKCdhdXRoZW50aWNhdGlvbiBzdWl0ZXMnKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGwuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1sxXS5pbmRleE9mKCc4MDIuMXgnKSkgeyB3cGFGbGFnID0gKHdwYUZsYWcgPyAnODAyLjF4LycgKyB3cGFGbGFnIDogJzgwMi4xeCcpOyB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzFdLmluZGV4T2YoJ3BzaycpKSB7IHdwYUZsYWcgPSAod3BhRmxhZyA/ICdQU0svJyArIHdwYUZsYWcgOiAnUFNLJyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAod3BhRmxhZykge1xuICAgICAgICAgIHdwYUZsYWdzLnB1c2god3BhRmxhZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgc3NpZCxcbiAgICAgICAgICBic3NpZDogYWRkcmVzcyxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWwgPyB1dGlsLnRvSW50KGNoYW5uZWwpIDogbnVsbCxcbiAgICAgICAgICBmcmVxdWVuY3k6IGZyZXF1ZW5jeSA/IHV0aWwudG9JbnQoZnJlcXVlbmN5LnJlcGxhY2UoJy4nLCAnJykpIDogbnVsbCxcbiAgICAgICAgICBzaWduYWxMZXZlbDogZGIsXG4gICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICBzZWN1cml0eSxcbiAgICAgICAgICB3cGFGbGFncyxcbiAgICAgICAgICByc25GbGFnczogW11cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVdpZmlEYXJ3aW4od2lmaU9iaikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHdpZmlPYmopIHtcbiAgICB3aWZpT2JqLmZvckVhY2goZnVuY3Rpb24gKHdpZmlJdGVtKSB7XG4gICAgICBjb25zdCBzaWduYWxMZXZlbCA9IHdpZmlJdGVtLlJTU0k7XG4gICAgICBsZXQgc2VjdXJpdHkgPSBbXTtcbiAgICAgIGxldCB3cGFGbGFncyA9IFtdO1xuICAgICAgaWYgKHdpZmlJdGVtLldQQV9JRSkge1xuICAgICAgICBzZWN1cml0eS5wdXNoKCdXUEEnKTtcbiAgICAgICAgaWYgKHdpZmlJdGVtLldQQV9JRS5JRV9LRVlfV1BBX1VDSVBIRVJTKSB7XG4gICAgICAgICAgd2lmaUl0ZW0uV1BBX0lFLklFX0tFWV9XUEFfVUNJUEhFUlMuZm9yRWFjaChmdW5jdGlvbiAoY2lwaGVycykge1xuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDAgJiYgd3BhRmxhZ3MuaW5kZXhPZigndW5rbm93bi9US0lQJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ3Vua25vd24vVEtJUCcpOyB9XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gMiAmJiB3cGFGbGFncy5pbmRleE9mKCdQU0svVEtJUCcpID09PSAtMSkgeyB3cGFGbGFncy5wdXNoKCdQU0svVEtJUCcpOyB9XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gNCAmJiB3cGFGbGFncy5pbmRleE9mKCdQU0svQUVTJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ1BTSy9BRVMnKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2lmaUl0ZW0uUlNOX0lFKSB7XG4gICAgICAgIHNlY3VyaXR5LnB1c2goJ1dQQTInKTtcbiAgICAgICAgaWYgKHdpZmlJdGVtLlJTTl9JRS5JRV9LRVlfUlNOX1VDSVBIRVJTKSB7XG4gICAgICAgICAgd2lmaUl0ZW0uUlNOX0lFLklFX0tFWV9SU05fVUNJUEhFUlMuZm9yRWFjaChmdW5jdGlvbiAoY2lwaGVycykge1xuICAgICAgICAgICAgaWYgKGNpcGhlcnMgPT09IDAgJiYgd3BhRmxhZ3MuaW5kZXhPZigndW5rbm93bi9US0lQJykgPT09IC0xKSB7IHdwYUZsYWdzLnB1c2goJ3Vua25vd24vVEtJUCcpOyB9XG4gICAgICAgICAgICBpZiAoY2lwaGVycyA9PT0gMiAmJiB3cGFGbGFncy5pbmRleE9mKCdUS0lQL1RLSVAnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgnVEtJUC9US0lQJyk7IH1cbiAgICAgICAgICAgIGlmIChjaXBoZXJzID09PSA0ICYmIHdwYUZsYWdzLmluZGV4T2YoJ1BTSy9BRVMnKSA9PT0gLTEpIHsgd3BhRmxhZ3MucHVzaCgnUFNLL0FFUycpOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgc3NpZDogd2lmaUl0ZW0uU1NJRF9TVFIsXG4gICAgICAgIGJzc2lkOiB3aWZpSXRlbS5CU1NJRCxcbiAgICAgICAgbW9kZTogJycsXG4gICAgICAgIGNoYW5uZWw6IHdpZmlJdGVtLkNIQU5ORUwsXG4gICAgICAgIGZyZXF1ZW5jeTogd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKHdpZmlJdGVtLkNIQU5ORUwpLFxuICAgICAgICBzaWduYWxMZXZlbDogc2lnbmFsTGV2ZWwgPyBwYXJzZUludChzaWduYWxMZXZlbCwgMTApIDogbnVsbCxcbiAgICAgICAgcXVhbGl0eTogd2lmaVF1YWxpdHlGcm9tREIoc2lnbmFsTGV2ZWwpLFxuICAgICAgICBzZWN1cml0eSxcbiAgICAgICAgd3BhRmxhZ3MsXG4gICAgICAgIHJzbkZsYWdzOiBbXVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdpZmlOZXR3b3JrcyhjYWxsYmFjaykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgcmVzdWx0ID0gZ2V0V2lmaU5ldHdvcmtMaXN0Tm1pKCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGl3Y29uZmlnUGFydHMgPSBleGVjU3luYygnZXhwb3J0IExDX0FMTD1DOyBpd2NvbmZpZyAyPi9kZXYvbnVsbDsgdW5zZXQgTENfQUxMJykudG9TdHJpbmcoKS5zcGxpdCgnXFxuXFxuJyk7XG4gICAgICAgICAgICBsZXQgaWZhY2UgPSAnJztcbiAgICAgICAgICAgIGl3Y29uZmlnUGFydHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5kZXhPZignbm8gd2lyZWxlc3MnKSA9PT0gLTEgJiYgZWxlbWVudC50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWZhY2UgPSBlbGVtZW50LnNwbGl0KCcgJylbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlmYWNlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGdldFdpZmlOZXR3b3JrTGlzdEl3KGlmYWNlKTtcbiAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgYWdhaW4gYWZ0ZXIgNCBzZWNzXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoaWZhY2UpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGdldFdpZmlOZXR3b3JrTGlzdEl3KGlmYWNlKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXMgIT0gLTEpIHsgcmVzdWx0ID0gcmVzOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCA0MDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnL1N5c3RlbS9MaWJyYXJ5L1ByaXZhdGVGcmFtZXdvcmtzL0FwcGxlODAyMTEuZnJhbWV3b3JrL1ZlcnNpb25zL0N1cnJlbnQvUmVzb3VyY2VzL2FpcnBvcnQgLXMgLXgnO1xuICAgICAgICBleGVjKGNtZCwgeyBtYXhCdWZmZXI6IDEwMjQgKiA0MDAwMCB9LCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHN0ZG91dC50b1N0cmluZygpO1xuICAgICAgICAgIHJlc3VsdCA9IHBhcnNlV2lmaURhcndpbih1dGlsLnBsaXN0UGFyc2VyKG91dHB1dCkpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IGNtZCA9ICduZXRzaCB3bGFuIHNob3cgbmV0d29ya3MgbW9kZT1Cc3NpZCc7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbChjbWQpLnRoZW4oKHN0ZG91dCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNzaWRQYXJ0cyA9IHN0ZG91dC50b1N0cmluZygndXRmOCcpLnNwbGl0KG9zLkVPTCArIG9zLkVPTCArICdTU0lEICcpO1xuICAgICAgICAgIHNzaWRQYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgc3NpZFBhcnRzLmZvckVhY2goc3NpZFBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3NpZExpbmVzID0gc3NpZFBhcnQuc3BsaXQob3MuRU9MKTtcbiAgICAgICAgICAgIGlmIChzc2lkTGluZXMgJiYgc3NpZExpbmVzLmxlbmd0aCA+PSA4ICYmIHNzaWRMaW5lc1swXS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBic3NpZHNQYXJ0cyA9IHNzaWRQYXJ0LnNwbGl0KCcgQlNTSUQnKTtcbiAgICAgICAgICAgICAgYnNzaWRzUGFydHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICBic3NpZHNQYXJ0cy5mb3JFYWNoKChic3NpZFBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBic3NpZExpbmVzID0gYnNzaWRQYXJ0LnNwbGl0KG9zLkVPTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnNzaWRMaW5lID0gYnNzaWRMaW5lc1swXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGJzc2lkTGluZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJzc2lkID0gYnNzaWRMaW5lLmpvaW4oJzonKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gYnNzaWRMaW5lc1szXS5zcGxpdCgnOicpLnBvcCgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gYnNzaWRMaW5lc1sxXS5zcGxpdCgnOicpLnBvcCgpLnRyaW0oKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHNzaWQ6IHNzaWRMaW5lc1swXS5zcGxpdCgnOicpLnBvcCgpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgIGJzc2lkLFxuICAgICAgICAgICAgICAgICAgbW9kZTogJycsXG4gICAgICAgICAgICAgICAgICBjaGFubmVsOiBjaGFubmVsID8gcGFyc2VJbnQoY2hhbm5lbCwgMTApIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogd2lmaUZyZXF1ZW5jeUZyb21DaGFubmVsKGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgICAgc2lnbmFsTGV2ZWw6IHdpZmlEQkZyb21RdWFsaXR5KHF1YWxpdHkpLFxuICAgICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eSA/IHBhcnNlSW50KHF1YWxpdHksIDEwKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICBzZWN1cml0eTogW3NzaWRMaW5lc1syXS5zcGxpdCgnOicpLnBvcCgpLnRyaW0oKV0sXG4gICAgICAgICAgICAgICAgICB3cGFGbGFnczogW3NzaWRMaW5lc1szXS5zcGxpdCgnOicpLnBvcCgpLnRyaW0oKV0sXG4gICAgICAgICAgICAgICAgICByc25GbGFnczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMud2lmaU5ldHdvcmtzID0gd2lmaU5ldHdvcmtzO1xuXG5mdW5jdGlvbiBnZXRWZW5kb3IobW9kZWwpIHtcbiAgbW9kZWwgPSBtb2RlbC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGlmIChtb2RlbC5pbmRleE9mKCdpbnRlbCcpID49IDApIHsgcmVzdWx0ID0gJ0ludGVsJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdyZWFsdGVrJykgPj0gMCkgeyByZXN1bHQgPSAnUmVhbHRlayc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZigncXVhbGNvbScpID49IDApIHsgcmVzdWx0ID0gJ1F1YWxjb20nOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2Jyb2FkY29tJykgPj0gMCkgeyByZXN1bHQgPSAnQnJvYWRjb20nOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2Nhdml1bScpID49IDApIHsgcmVzdWx0ID0gJ0Nhdml1bSc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignY2lzY28nKSA+PSAwKSB7IHJlc3VsdCA9ICdDaXNjbyc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignbWFydmVsJykgPj0gMCkgeyByZXN1bHQgPSAnTWFydmVsJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCd6eXhlbCcpID49IDApIHsgcmVzdWx0ID0gJ1p5eGVsJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCdtZWxhbm94JykgPj0gMCkgeyByZXN1bHQgPSAnTWVsYW5veCc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignZC1saW5rJykgPj0gMCkgeyByZXN1bHQgPSAnRC1MaW5rJzsgfVxuICBlbHNlIGlmIChtb2RlbC5pbmRleE9mKCd0cC1saW5rJykgPj0gMCkgeyByZXN1bHQgPSAnVFAtTGluayc7IH1cbiAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignYXN1cycpID49IDApIHsgcmVzdWx0ID0gJ0FzdXMnOyB9XG4gIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJ2xpbmtzeXMnKSA+PSAwKSB7IHJlc3VsdCA9ICdMaW5rc3lzJzsgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3aWZpQ29ubmVjdGlvbnMoY2FsbGJhY2spIHtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoX2xpbnV4KSB7XG4gICAgICAgIGNvbnN0IGlmYWNlcyA9IGlmYWNlTGlzdExpbnV4KCk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtMaXN0ID0gZ2V0V2lmaU5ldHdvcmtMaXN0Tm1pKCk7XG4gICAgICAgIGlmYWNlcy5mb3JFYWNoKGlmYWNlRGV0YWlsID0+IHtcbiAgICAgICAgICBjb25zdCBubWlEZXRhaWxzID0gbm1pRGV2aWNlTGludXgoaWZhY2VEZXRhaWwuaWZhY2UpO1xuICAgICAgICAgIGNvbnN0IHdwYURldGFpbHMgPSB3cGFDb25uZWN0aW9uTGludXgoaWZhY2VEZXRhaWwuaWZhY2UpO1xuICAgICAgICAgIGNvbnN0IHNzaWQgPSBubWlEZXRhaWxzLnNzaWQgfHwgd3BhRGV0YWlscy5zc2lkO1xuICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSBuZXR3b3JrTGlzdC5maWx0ZXIobncgPT4gbncuc3NpZCA9PT0gc3NpZCk7XG4gICAgICAgICAgY29uc3Qgbm1pQ29ubmVjdGlvbiA9IG5taUNvbm5lY3Rpb25MaW51eChzc2lkKTtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gbmV0d29yayAmJiBuZXR3b3JrLmxlbmd0aCAmJiBuZXR3b3JrWzBdLmNoYW5uZWwgPyBuZXR3b3JrWzBdLmNoYW5uZWwgOiAod3BhRGV0YWlscy5jaGFubmVsID8gd3BhRGV0YWlscy5jaGFubmVsIDogbnVsbCk7XG4gICAgICAgICAgY29uc3QgYnNzaWQgPSBuZXR3b3JrICYmIG5ldHdvcmsubGVuZ3RoICYmIG5ldHdvcmtbMF0uYnNzaWQgPyBuZXR3b3JrWzBdLmJzc2lkIDogKHdwYURldGFpbHMuYnNzaWQgPyB3cGFEZXRhaWxzLmJzc2lkIDogbnVsbCk7XG4gICAgICAgICAgaWYgKHNzaWQgJiYgYnNzaWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGlmYWNlRGV0YWlsLmlkLFxuICAgICAgICAgICAgICBpZmFjZTogaWZhY2VEZXRhaWwuaWZhY2UsXG4gICAgICAgICAgICAgIG1vZGVsOiBubWlEZXRhaWxzLnByb2R1Y3QsXG4gICAgICAgICAgICAgIHNzaWQsXG4gICAgICAgICAgICAgIGJzc2lkOiBuZXR3b3JrICYmIG5ldHdvcmsubGVuZ3RoICYmIG5ldHdvcmtbMF0uYnNzaWQgPyBuZXR3b3JrWzBdLmJzc2lkIDogKHdwYURldGFpbHMuYnNzaWQgPyB3cGFEZXRhaWxzLmJzc2lkIDogbnVsbCksXG4gICAgICAgICAgICAgIGNoYW5uZWwsXG4gICAgICAgICAgICAgIGZyZXF1ZW5jeTogY2hhbm5lbCA/IHdpZmlGcmVxdWVuY3lGcm9tQ2hhbm5lbChjaGFubmVsKSA6IG51bGwsXG4gICAgICAgICAgICAgIHR5cGU6IG5taUNvbm5lY3Rpb24udHlwZSA/IG5taUNvbm5lY3Rpb24udHlwZSA6ICc4MDIuMTEnLFxuICAgICAgICAgICAgICBzZWN1cml0eTogbm1pQ29ubmVjdGlvbi5zZWN1cml0eSA/IG5taUNvbm5lY3Rpb24uc2VjdXJpdHkgOiAod3BhRGV0YWlscy5zZWN1cml0eSA/IHdwYURldGFpbHMuc2VjdXJpdHkgOiBudWxsKSxcbiAgICAgICAgICAgICAgc2lnbmFsTGV2ZWw6IG5ldHdvcmsgJiYgbmV0d29yay5sZW5ndGggJiYgbmV0d29ya1swXS5zaWduYWxMZXZlbCA/IG5ldHdvcmtbMF0uc2lnbmFsTGV2ZWwgOiBudWxsLFxuICAgICAgICAgICAgICB0eFJhdGU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmIChfZGFyd2luKSB7XG4gICAgICAgIGxldCBjbWQgPSAnc3lzdGVtX3Byb2ZpbGVyIFNQTmV0d29ya0RhdGFUeXBlJztcbiAgICAgICAgZXhlYyhjbWQsIGZ1bmN0aW9uIChlcnJvciwgc3Rkb3V0KSB7XG4gICAgICAgICAgY29uc3QgcGFydHMxID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcblxcbiAgICBXaS1GaTpcXG5cXG4nKTtcbiAgICAgICAgICBpZiAocGFydHMxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcGFydHMxWzFdLnNwbGl0KCdcXG5cXG4nKVswXS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBpZmFjZSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU0QgRGV2aWNlIE5hbWUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnaGFyZHdhcmUnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgY21kID0gJy9TeXN0ZW0vTGlicmFyeS9Qcml2YXRlRnJhbWV3b3Jrcy9BcHBsZTgwMjExLmZyYW1ld29yay9WZXJzaW9ucy9DdXJyZW50L1Jlc291cmNlcy9haXJwb3J0IC1JJztcbiAgICAgICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lczIgPSBzdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzaWQgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ3NzaWQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdic3NpZCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHkgPSB1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2xpbmsgYXV0aCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhSYXRlID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdsYXN0VHhSYXRlJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lczIsICdjaGFubmVsJywgJzonLCB0cnVlKS5zcGxpdCgnLCcpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAnODAyLjExJztcbiAgICAgICAgICAgICAgICBjb25zdCByc3NpID0gdXRpbC50b0ludCh1dGlsLmdldFZhbHVlKGxpbmVzMiwgJ2FnckN0bFJTU0knLCAnOicsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2lzZSA9IHV0aWwudG9JbnQodXRpbC5nZXRWYWx1ZShsaW5lczIsICdhZ3JDdGxOb2lzZScsICc6JywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbExldmVsID0gcnNzaSAtIG5vaXNlO1xuICAgICAgICAgICAgICAgIGlmIChzc2lkIHx8IGJzc2lkKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnV2ktRmknLFxuICAgICAgICAgICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHNzaWQsXG4gICAgICAgICAgICAgICAgICAgIGJzc2lkLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiB1dGlsLnRvSW50KGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IGNoYW5uZWwgPyB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwoY2hhbm5lbCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBzZWN1cml0eSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIHR4UmF0ZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IGNtZCA9ICduZXRzaCB3bGFuIHNob3cgaW50ZXJmYWNlcyc7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbChjbWQpLnRoZW4oZnVuY3Rpb24gKHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IGFsbExpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFsbExpbmVzW2ldID0gYWxsTGluZXNbaV0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IGFsbExpbmVzLmpvaW4oJ1xcclxcbicpLnNwbGl0KCc6XFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgICBjb25zdCBpZmFjZSA9IGxpbmVzWzBdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMF0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBsaW5lc1sxXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzFdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gbGluZXNbMl0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1syXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBzc2lkID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NTSUQnLCAnOicsIHRydWUpO1xuICAgICAgICAgICAgICBjb25zdCBic3NpZCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdCU1NJRCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hbExldmVsID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1NpZ25hbCcsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnUmFkaW8gdHlwZScsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1R5cGUgZGUgcmFkaW8nLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdGdW5rdHlwJywgJzonLCB0cnVlKSB8fCBudWxsO1xuICAgICAgICAgICAgICBjb25zdCBzZWN1cml0eSA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdhdXRoZW50aWNhdGlvbicsICc6JywgdHJ1ZSkgfHwgdXRpbC5nZXRWYWx1ZShsaW5lcywgJ0F1dGhlbnRpZmljYXRpb24nLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdBdXRoZW50aWZpemllcnVuZycsICc6JywgdHJ1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdDaGFubmVsJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQ2FuYWwnLCAnOicsIHRydWUpIHx8IHV0aWwuZ2V0VmFsdWUobGluZXMsICdLYW5hbCcsICc6JywgdHJ1ZSkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgY29uc3QgdHhSYXRlID0gdXRpbC5nZXRWYWx1ZShsaW5lcywgJ1RyYW5zbWl0IHJhdGUgKG1icHMpJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnVHJhbnNtaXNzaW9uIChtYml0L3MpJywgJzonLCB0cnVlKSB8fCB1dGlsLmdldFZhbHVlKGxpbmVzLCAnRW1wZmFuZ3NyYXRlIChNQml0L3MpJywgJzonLCB0cnVlKSB8fCBudWxsO1xuICAgICAgICAgICAgICBpZiAobW9kZWwgJiYgaWQgJiYgc3NpZCAmJiBic3NpZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgaWZhY2UsXG4gICAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICAgIHNzaWQsXG4gICAgICAgICAgICAgICAgICBic3NpZCxcbiAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHV0aWwudG9JbnQoY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IGNoYW5uZWwgPyB3aWZpRnJlcXVlbmN5RnJvbUNoYW5uZWwoY2hhbm5lbCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5LFxuICAgICAgICAgICAgICAgICAgc2lnbmFsTGV2ZWwsXG4gICAgICAgICAgICAgICAgICB0eFJhdGU6IHV0aWwudG9JbnQodHhSYXRlKSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydHMud2lmaUNvbm5lY3Rpb25zID0gd2lmaUNvbm5lY3Rpb25zO1xuXG5mdW5jdGlvbiB3aWZpSW50ZXJmYWNlcyhjYWxsYmFjaykge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChfbGludXgpIHtcbiAgICAgICAgY29uc3QgaWZhY2VzID0gaWZhY2VMaXN0TGludXgoKTtcbiAgICAgICAgaWZhY2VzLmZvckVhY2goaWZhY2VEZXRhaWwgPT4ge1xuICAgICAgICAgIGNvbnN0IG5taURldGFpbHMgPSBubWlEZXZpY2VMaW51eChpZmFjZURldGFpbC5pZmFjZSk7XG4gICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgaWQ6IGlmYWNlRGV0YWlsLmlkLFxuICAgICAgICAgICAgaWZhY2U6IGlmYWNlRGV0YWlsLmlmYWNlLFxuICAgICAgICAgICAgbW9kZWw6IG5taURldGFpbHMucHJvZHVjdCA/IG5taURldGFpbHMucHJvZHVjdCA6IG51bGwsXG4gICAgICAgICAgICB2ZW5kb3I6IG5taURldGFpbHMudmVuZG9yID8gbm1pRGV0YWlscy52ZW5kb3IgOiBudWxsLFxuICAgICAgICAgICAgbWFjOiBpZmFjZURldGFpbC5tYWMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoX2Rhcndpbikge1xuICAgICAgICBsZXQgY21kID0gJ3N5c3RlbV9wcm9maWxlciBTUE5ldHdvcmtEYXRhVHlwZSc7XG4gICAgICAgIGV4ZWMoY21kLCBmdW5jdGlvbiAoZXJyb3IsIHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IHBhcnRzMSA9IHN0ZG91dC50b1N0cmluZygpLnNwbGl0KCdcXG5cXG4gICAgV2ktRmk6XFxuXFxuJyk7XG4gICAgICAgICAgaWYgKHBhcnRzMS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IHBhcnRzMVsxXS5zcGxpdCgnXFxuXFxuJylbMF0uc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaWZhY2UgPSB1dGlsLmdldFZhbHVlKGxpbmVzLCAnQlNEIERldmljZSBOYW1lJywgJzonLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IG1hYyA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdNQUMgQWRkcmVzcycsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWwuZ2V0VmFsdWUobGluZXMsICdoYXJkd2FyZScsICc6JywgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiAnV2ktRmknLFxuICAgICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgIHZlbmRvcjogJycsXG4gICAgICAgICAgICAgIG1hY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX3dpbmRvd3MpIHtcbiAgICAgICAgbGV0IGNtZCA9ICduZXRzaCB3bGFuIHNob3cgaW50ZXJmYWNlcyc7XG4gICAgICAgIHV0aWwucG93ZXJTaGVsbChjbWQpLnRoZW4oZnVuY3Rpb24gKHN0ZG91dCkge1xuICAgICAgICAgIGNvbnN0IGFsbExpbmVzID0gc3Rkb3V0LnRvU3RyaW5nKCkuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFsbExpbmVzW2ldID0gYWxsTGluZXNbaV0udHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IGFsbExpbmVzLmpvaW4oJ1xcclxcbicpLnNwbGl0KCc6XFxyXFxuXFxyXFxuJyk7XG4gICAgICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBwYXJ0LnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPj0gNSkge1xuICAgICAgICAgICAgICBjb25zdCBpZmFjZSA9IGxpbmVzWzBdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbMF0uc3BsaXQoJzonKVsxXS50cmltKCkgOiAnJztcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBsaW5lc1sxXS5pbmRleE9mKCc6JykgPj0gMCA/IGxpbmVzWzFdLnNwbGl0KCc6JylbMV0udHJpbSgpIDogJyc7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gbGluZXNbMl0uaW5kZXhPZignOicpID49IDAgPyBsaW5lc1syXS5zcGxpdCgnOicpWzFdLnRyaW0oKSA6ICcnO1xuICAgICAgICAgICAgICBjb25zdCBtYWNQYXJ0cyA9IGxpbmVzWzNdLmluZGV4T2YoJzonKSA+PSAwID8gbGluZXNbM10uc3BsaXQoJzonKSA6IFtdO1xuICAgICAgICAgICAgICBtYWNQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgICBjb25zdCBtYWMgPSBtYWNQYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCB2ZW5kb3IgPSBnZXRWZW5kb3IobW9kZWwpO1xuICAgICAgICAgICAgICBpZiAoaWZhY2UgJiYgbW9kZWwgJiYgaWQgJiYgbWFjKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICBpZmFjZSxcbiAgICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgICAgdmVuZG9yLFxuICAgICAgICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLndpZmlJbnRlcmZhY2VzID0gd2lmaUludGVyZmFjZXM7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInN5c3RlbWluZm9ybWF0aW9uXCIsXG4gIFwidmVyc2lvblwiOiBcIjUuMTcuMTJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkFkdmFuY2VkLCBsaWdodHdlaWdodCBzeXN0ZW0gYW5kIE9TIGluZm9ybWF0aW9uIGxpYnJhcnlcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiYXV0aG9yXCI6IFwiU2ViYXN0aWFuIEhpbGRlYnJhbmR0IDxoaWxkZWJyYW5kdEBwbHVzLWlubm92YXRpb25zLmNvbT4gKGh0dHBzOi8vcGx1cy1pbm5vdmF0aW9ucy5jb20pXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3N5c3RlbWluZm9ybWF0aW9uLmlvXCIsXG4gIFwibWFpblwiOiBcIi4vbGliL2luZGV4LmpzXCIsXG4gIFwiYmluXCI6IHtcbiAgICBcInN5c3RlbWluZm9ybWF0aW9uXCI6IFwibGliL2NsaS5qc1wiXG4gIH0sXG4gIFwidHlwZXNcIjogXCIuL2xpYi9pbmRleC5kLnRzXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwibm9kZSAuL3Rlc3QvdGVzdC5qc1wiXG4gIH0sXG4gIFwiZmlsZXNcIjogW1xuICAgIFwibGliL1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwic3lzdGVtIGluZm9ybWF0aW9uXCIsXG4gICAgXCJzeXNpbmZvXCIsXG4gICAgXCJtb25pdG9yXCIsXG4gICAgXCJtb25pdG9yaW5nXCIsXG4gICAgXCJvc1wiLFxuICAgIFwibGludXhcIixcbiAgICBcIm9zeFwiLFxuICAgIFwid2luZG93c1wiLFxuICAgIFwiZnJlZWJzZFwiLFxuICAgIFwib3BlbmJzZFwiLFxuICAgIFwibmV0YnNkXCIsXG4gICAgXCJjcHVcIixcbiAgICBcImNwdWxvYWRcIixcbiAgICBcInBoeXNpY2FsIGNvcmVzXCIsXG4gICAgXCJsb2dpY2FsIGNvcmVzXCIsXG4gICAgXCJwcm9jZXNzb3JcIixcbiAgICBcImNvcmVzXCIsXG4gICAgXCJ0aHJlYWRzXCIsXG4gICAgXCJzb2NrZXQgdHlwZVwiLFxuICAgIFwibWVtb3J5XCIsXG4gICAgXCJmaWxlIHN5c3RlbVwiLFxuICAgIFwiZnNzdGF0c1wiLFxuICAgIFwiZGlza2lvXCIsXG4gICAgXCJibG9jayBkZXZpY2VzXCIsXG4gICAgXCJuZXRzdGF0c1wiLFxuICAgIFwibmV0d29ya1wiLFxuICAgIFwibmV0d29yayBpbnRlcmZhY2VzXCIsXG4gICAgXCJuZXR3b3JrIGNvbm5lY3Rpb25zXCIsXG4gICAgXCJuZXR3b3JrIHN0YXRzXCIsXG4gICAgXCJpZmFjZVwiLFxuICAgIFwicHJpbnRlclwiLFxuICAgIFwicHJvY2Vzc2VzXCIsXG4gICAgXCJ1c2Vyc1wiLFxuICAgIFwiaW50ZXJuZXRcIixcbiAgICBcImJhdHRlcnlcIixcbiAgICBcImRvY2tlclwiLFxuICAgIFwiZG9ja2VyIHN0YXRzXCIsXG4gICAgXCJkb2NrZXIgcHJvY2Vzc2VzXCIsXG4gICAgXCJncmFwaGljc1wiLFxuICAgIFwiZ3JhcGhpYyBjYXJkXCIsXG4gICAgXCJncmFwaGljIGNvbnRyb2xsZXJcIixcbiAgICBcImdwdVwiLFxuICAgIFwiZGlzcGxheVwiLFxuICAgIFwic21hcnRcIixcbiAgICBcImRpc2sgbGF5b3V0XCIsXG4gICAgXCJ1c2JcIixcbiAgICBcImF1ZGlvXCIsXG4gICAgXCJibHVldG9vdGhcIixcbiAgICBcIndpZmlcIixcbiAgICBcIndpZmluZXR3b3Jrc1wiLFxuICAgIFwidmlydHVhbCBib3hcIixcbiAgICBcInZpcnR1YWxib3hcIixcbiAgICBcInZtXCIsXG4gICAgXCJiYWNrZW5kXCIsXG4gICAgXCJoYXJkd2FyZVwiLFxuICAgIFwiQklPU1wiLFxuICAgIFwiY2hhc3Npc1wiXG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2ViaGlsZGVicmFuZHQvc3lzdGVtaW5mb3JtYXRpb24uZ2l0XCJcbiAgfSxcbiAgXCJmdW5kaW5nXCI6IHtcbiAgICBcInR5cGVcIjogXCJCdXkgbWUgYSBjb2ZmZWVcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vd3d3LmJ1eW1lYWNvZmZlZS5jb20vc3lzdGVtaW5mb1wiXG4gIH0sXG4gIFwib3NcIjogW1xuICAgIFwiZGFyd2luXCIsXG4gICAgXCJsaW51eFwiLFxuICAgIFwid2luMzJcIixcbiAgICBcImZyZWVic2RcIixcbiAgICBcIm9wZW5ic2RcIixcbiAgICBcIm5ldGJzZFwiLFxuICAgIFwic3Vub3NcIixcbiAgICBcImFuZHJvaWRcIlxuICBdLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49OC4wLjBcIlxuICB9XG59XG4iXX0="}