<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Reliability - Correctness Test</title>
    For testing the scripts:<br>
    availableOffloadingResources.js<br>
    offloadingDecision.js<br>
    offloadingTarget.js

    <br><br><br>

    <b>CORRECTNESS TESTING - RANDOMIZED SIMULATIONS=</b> <br><br>
    run test1()<br><br>
    run test2()
    <br><br><br>

    <b>INDIVIDUAL TESTS=</b><br><br>
    In the console,<br>
    1. input let odList = odRandomizeInputs() and let orList = orRandomizeInputs() to get randomized values for [odList] and [orList] or use your own values.<br>
    2. input testOffloadingDecision(odList) to execute 5 tests the offloading decision.<br>
    3. input let aorList = testAvailableOffloadingResources(orList) to get the list of available offloading resources of a peer<br>
    4. input decisionValueOfPOT(aorList) to get the DPOT value of the Peer (the higher the value the higher the change to be chosen by Source Peer<br>
    5. you can repeat set 1 to 4 to simulate multiple POTs in the network, save their values in a JS object peers with format { id : [ orList ] },
    then input testOffloadingTarget(peers) to output the chosen peer for offloading.

    <br><br><br>

    <b>INPUTS DESCRIPTION=</b><br><br>
    [odList] = [cpu %, mem %, battery %] limiting the resource usage on the source Peer<br>
    [orList] = [mem % , battery % , isCharging (binary)] limiting the available offloading resources of a Peer<br>

    <script src ="./availableOffloadingResources.js"></script>
    <script src ="./offloadingDecision.js"></script>
    <script src ="./offloadingTarget.js"></script>

    <script>
        function test1(){
            let odList = [];
            let intervalID =null;
            let offloading = false;
            return Promise.all([
                new Promise ( (resolve) => {
                    intervalID = setInterval ( async () => {
                        odList = odRandomizeInputs();
                        console.log('Randomized odList = ',odList);
                        offloading = await offloadingDecision(odList);

                        if (offloading) {
                            clearInterval(intervalID);
                            resolve('offloading');
                        } else {
                            console.log('no offloading')
                        }

                    },50)
                }),
                new Promise((resolve) =>{
                    function fibonacci(n) {
                        if (n <= 1) {
                            return n;
                        }
                        return fibonacci(n - 1) + fibonacci(n - 2);
                    }
                    resolve(fibonacci(42));
                })

            ]).then((result) => {
                clearInterval(intervalID);
                console.log('Promise RACE result = ',result);
            });
        }

        function test2() {
            let cluster = {};
            let resultFound = false;

            //Simulate cluster of 5 peers
            for (let i = 1; i < 6; i++) {
                let id = `peer${i}`;
                cluster[id]=orRandomizeInputs();
            }
            Object.entries(cluster).forEach(([key, value]) => {
                console.log(`${key}: ${value}`);
            });
            let randomPeerID = Math.floor(Math.random() * 5) + 1;
            console.log('Randomly chosen source = peer',randomPeerID);
            let deletedPeerID = 'peer'+randomPeerID;
            delete cluster[deletedPeerID];
            let i=4;
            while (!resultFound && i>0) {
                let chosenPeer = offloadingTarget(cluster);
                let randomOffloading = Math.random() < 0.5; //boolean

                if(randomOffloading){
                    console.log('Peer not strong enough. Offloading necessary');
                    delete cluster[chosenPeer];
                    i--;
                }else{
                    console.log('Offloading successful ! Result sent back to source')
                    resultFound= true;
                }

            }
            if(!resultFound){
                console.log('No available peer strong enough to execute the pipeline. offloading to the cloud...');
            }
        }

        function odRandomizeInputs(){
            let odList = [];
            for (let i = 0; i <3; i++) {
                odList.push(Math.round(Math.random() * 100))
            }
            return odList;
        }

        function orRandomizeInputs(){
            let orList = [];
            for (let i = 0; i <2; i++) {
                orList.push(Math.round(Math.random() * 100))
            }
            orList.push(Math.random() < 0.5);
            return orList;
        }

        function testOffloadingDecision(odList){
            let i = 1;
            let interval = setInterval(()=>{
                console.log('Monitoring Round #'+i);
                let startTime = Date.now();
                let startMem = performance.memory.usedJSHeapSize;
                offloadingDecision(odList).then ((result)=>{
                    let endMem = performance.memory.usedJSHeapSize;
                    let endTime = Date.now();
                    i++;
                    console.log(result);
                    console.log('Elapsed time: ',endTime-startTime, ' ms');
                    console.log('Used Memory: ',endMem-startMem, ' bytes');
                });
            },2000);

            // 10 measurements
            setTimeout  (()=>{
                console.log('Timeout !');
                clearInterval(interval);
            },20000)
        }

        function testAvailableOffloadingResources(orList) {
            let startTime = Date.now();
            let startMem = performance.memory.usedJSHeapSize;
            availableOffloadingResources(orList).then((result) => {
                let endMem = performance.memory.usedJSHeapSize;
                let endTime = Date.now();
                console.log(result);
                console.log('Elapsed time: ',endTime-startTime, ' ms');
                console.log('Used Memory: ',endMem-startMem, ' ms');

            });
        }

        function testOffloadingTarget(iDandORpairs){
            let startTime = Date.now();
            let startMem = performance.memory.usedJSHeapSize;
            offloadingTarget(iDandORpairs);
            let endMem = performance.memory.usedJSHeapSize;
            let endTime = Date.now();
            console.log('Elapsed time: ',endTime-startTime, ' ms');
            console.log('Used Memory: ',endMem-startMem, ' ms');
        }
    </script>


</head>
<body>

</body>
</html>